
> pizza@1.0.0 lint
> eslint . --ext .js,.jsx,.ts,.tsx --fix --format json

[{"filePath":"/home/leo/Escritorio/bite/app/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/common/AnimatedLabelInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/common/AnimatedLabelSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/common/AutoImage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/common/ConfirmationModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/common/CustomImagePicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/common/EmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/common/GlobalSnackbar.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'getBackgroundColor', 'getTextColor', 'theme.colors.shadow', and 'theme.roundness'. Either include them or remove the dependency array.","line":54,"column":6,"nodeType":"ArrayExpression","endLine":54,"endColumn":54,"suggestions":[{"desc":"Update the dependencies array to be: [visible, message, type, duration, hideSnackbar, getBackgroundColor, getTextColor, theme.colors.shadow, theme.roundness]","fix":{"range":[1512,1560],"text":"[visible, message, type, duration, hideSnackbar, getBackgroundColor, getTextColor, theme.colors.shadow, theme.roundness]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport Toast from 'react-native-root-toast';\nimport {\n  useSnackbarStore,\n  SnackbarType,\n} from '../../../app/store/snackbarStore';\nimport { useAppTheme } from '../../../app/styles/theme';\n\nconst GlobalSnackbar: React.FC = () => {\n  const { visible, message, type, duration, hideSnackbar } = useSnackbarStore();\n  const theme = useAppTheme();\n\n  useEffect(() => {\n    if (visible && message) {\n      const backgroundColor = getBackgroundColor(type);\n      const textColor = getTextColor(type);\n\n      const toast = Toast.show(message, {\n        duration: duration || 4000,\n        position: Toast.positions.BOTTOM,\n        shadow: true,\n        animation: true,\n        hideOnPress: true,\n        delay: 0,\n        backgroundColor: backgroundColor,\n        textColor: textColor,\n        shadowColor: theme.colors.shadow,\n        opacity: 0.95,\n        containerStyle: {\n          marginHorizontal: 16,\n          marginBottom: 40,\n          paddingHorizontal: 20,\n          paddingVertical: 14,\n          borderRadius: theme.roundness,\n          minHeight: 56,\n          justifyContent: 'center',\n          zIndex: 99999,\n          elevation: 9999,\n        },\n        textStyle: {\n          fontSize: 16,\n          fontWeight: '500',\n          lineHeight: 24,\n          textAlign: 'center',\n        },\n        onHidden: hideSnackbar,\n      });\n\n      // Limpiar el toast cuando se oculte el componente\n      return () => {\n        Toast.hide(toast);\n      };\n    }\n  }, [visible, message, type, duration, hideSnackbar]);\n\n  const getBackgroundColor = (snackbarType: SnackbarType) => {\n    switch (snackbarType) {\n      case 'success':\n        return theme.colors.successContainer;\n      case 'error':\n        return theme.colors.errorContainer;\n      case 'warning':\n        return theme.colors.warningContainer || theme.colors.tertiaryContainer;\n      case 'info':\n        return theme.colors.infoContainer || theme.colors.surfaceVariant;\n      default:\n        return theme.colors.inverseSurface;\n    }\n  };\n\n  const getTextColor = (snackbarType: SnackbarType) => {\n    const defaultTextColor = theme.dark\n      ? theme.colors.surface\n      : theme.colors.onSurface;\n\n    switch (snackbarType) {\n      case 'success':\n        return theme.colors.onSuccessContainer || defaultTextColor;\n      case 'error':\n        return theme.colors.onErrorContainer;\n      case 'warning':\n        return (\n          theme.colors.onWarningContainer || theme.colors.onTertiaryContainer\n        );\n      case 'info':\n        return theme.colors.onInfoContainer || theme.colors.onSurfaceVariant;\n      default:\n        return theme.colors.inverseOnSurface;\n    }\n  };\n\n  return null;\n};\n\nexport default GlobalSnackbar;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/common/SpeechRecognitionInput.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'instanceId'. Either include it or remove the dependency array.","line":67,"column":6,"nodeType":"ArrayExpression","endLine":67,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [instanceId]","fix":{"range":[1843,1845],"text":"[instanceId]"}}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":206,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":206,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5991,6103],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { View, StyleSheet, Animated } from 'react-native';\nimport { IconButton } from 'react-native-paper';\nimport {\n  ExpoSpeechRecognitionModule,\n  useSpeechRecognitionEvent,\n  ExpoSpeechRecognitionResultEvent,\n  ExpoSpeechRecognitionErrorEvent,\n} from 'expo-speech-recognition';\nimport AnimatedLabelInput from './AnimatedLabelInput';\nimport { useAppTheme } from '../../styles/theme';\n\nlet activeRecognizerId: string | null = null;\n\ninterface SpeechRecognitionInputProps\n  extends Omit<\n    React.ComponentProps<typeof AnimatedLabelInput>,\n    'value' | 'onChangeText'\n  > {\n  value: string;\n  onChangeText: (text: string) => void;\n  label: string;\n  speechLang?: string;\n  clearOnStart?: boolean;\n  replaceContent?: boolean;\n  onError?: (error: string) => void;\n}\n\nconst SpeechRecognitionInput: React.FC<SpeechRecognitionInputProps> = ({\n  value,\n  onChangeText,\n  label,\n  speechLang = 'es-MX',\n  clearOnStart = false,\n  replaceContent = true,\n  onError,\n  error,\n  errorColor,\n  activeBorderColor,\n  containerStyle,\n  inputStyle,\n  labelStyle,\n  style,\n  ...rest\n}) => {\n  const theme = useAppTheme();\n  const [isRecognizingSpeech, setIsRecognizingSpeech] = useState(false);\n  const isMounted = useRef(true);\n  const instanceId = useRef(Math.random().toString(36).substring(2)).current;\n  const scaleAnim = useRef(new Animated.Value(1)).current;\n  const inputRef = useRef<any>(null);\n\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n      if (activeRecognizerId === instanceId) {\n        try {\n          ExpoSpeechRecognitionModule.stop();\n        } catch (err) {\n          console.error('Error stopping on unmount:', err);\n        } finally {\n          activeRecognizerId = null;\n        }\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    Animated.spring(scaleAnim, {\n      toValue: isRecognizingSpeech ? 1.2 : 1,\n      friction: 3,\n      useNativeDriver: true,\n    }).start();\n  }, [isRecognizingSpeech, scaleAnim]);\n\n  const handleRecognitionStart = useCallback(() => {\n    if (isMounted.current && activeRecognizerId === instanceId) {\n      if (!isRecognizingSpeech) {\n        setIsRecognizingSpeech(true);\n        if (clearOnStart) {\n          onChangeText('');\n        }\n      }\n    }\n  }, [clearOnStart, onChangeText, instanceId, isRecognizingSpeech]);\n\n  const handleRecognitionEnd = useCallback(() => {\n    if (isMounted.current && activeRecognizerId === instanceId) {\n      setIsRecognizingSpeech(false);\n      activeRecognizerId = null;\n    }\n  }, [instanceId]);\n\n  const handleRecognitionResult = useCallback(\n    (event: ExpoSpeechRecognitionResultEvent) => {\n      if (\n        isMounted.current &&\n        activeRecognizerId === instanceId &&\n        event.results &&\n        event.results[0]\n      ) {\n        const transcript = event.results[0].transcript;\n        if (replaceContent) {\n          if (rest.keyboardType === 'phone-pad') {\n            const numericTranscript = transcript.replace(/\\D/g, '');\n            onChangeText(numericTranscript);\n          } else {\n            onChangeText(transcript);\n          }\n        } else {\n          const newValue = value ? value + ' ' + transcript : transcript;\n          onChangeText(newValue);\n        }\n      }\n    },\n    [instanceId, onChangeText, replaceContent, rest.keyboardType, value],\n  );\n\n  const handleRecognitionError = useCallback(\n    (event: ExpoSpeechRecognitionErrorEvent) => {\n      if (isMounted.current && activeRecognizerId === instanceId) {\n        console.error('Speech recognition error:', event.error, event.message);\n        setIsRecognizingSpeech(false);\n        activeRecognizerId = null;\n        onError?.(event.message || event.error || 'Unknown recognition error');\n      }\n    },\n    [instanceId, onError],\n  );\n\n  // Only register event listeners when this instance is active\n  useSpeechRecognitionEvent('start', (_event) => {\n    if (activeRecognizerId === instanceId) {\n      handleRecognitionStart();\n    }\n  });\n\n  useSpeechRecognitionEvent('end', (_event) => {\n    if (activeRecognizerId === instanceId) {\n      handleRecognitionEnd();\n    }\n  });\n\n  useSpeechRecognitionEvent(\n    'result',\n    (event: ExpoSpeechRecognitionResultEvent) => {\n      if (activeRecognizerId === instanceId) {\n        handleRecognitionResult(event);\n      }\n    },\n  );\n\n  useSpeechRecognitionEvent(\n    'error',\n    (event: ExpoSpeechRecognitionErrorEvent) => {\n      if (activeRecognizerId === instanceId) {\n        handleRecognitionError(event);\n      }\n    },\n  );\n\n  const toggleRecognition = async () => {\n    if (activeRecognizerId === instanceId) {\n      try {\n        await ExpoSpeechRecognitionModule.stop();\n      } catch (err) {\n        console.error('Failed to stop speech recognition:', err);\n      } finally {\n        if (isMounted.current) {\n          setIsRecognizingSpeech(false);\n        }\n        if (activeRecognizerId === instanceId) {\n          activeRecognizerId = null;\n        }\n      }\n    } else if (!activeRecognizerId) {\n      const permissions =\n        await ExpoSpeechRecognitionModule.requestPermissionsAsync();\n      if (!permissions.granted) {\n        console.warn('Permissions not granted for speech recognition');\n        onError?.('Permiso de micrófono denegado');\n        return;\n      }\n      try {\n        activeRecognizerId = instanceId;\n        if (isMounted.current) {\n          setIsRecognizingSpeech(true);\n        }\n        await ExpoSpeechRecognitionModule.start({\n          lang: speechLang,\n          interimResults: false,\n          continuous: false,\n        });\n      } catch (err: any) {\n        console.error('Failed to start speech recognition:', err);\n        if (isMounted.current) {\n          setIsRecognizingSpeech(false);\n        }\n        if (activeRecognizerId === instanceId) {\n          activeRecognizerId = null;\n        }\n        onError?.(err.message || 'Error al iniciar');\n      }\n    } else {\n      console.log(\n        `Recognizer ${activeRecognizerId} is already active. Cannot start ${instanceId}.`,\n      );\n      onError?.('Otro micrófono ya está activo');\n    }\n  };\n\n  const micIconColor = isRecognizingSpeech\n    ? theme.colors.error\n    : theme.colors.primary;\n\n  return (\n    <View style={styles.wrapper}>\n      <AnimatedLabelInput\n        ref={inputRef}\n        label={label}\n        value={value}\n        onChangeText={onChangeText}\n        error={error}\n        errorColor={errorColor}\n        activeBorderColor={activeBorderColor}\n        containerStyle={[containerStyle, { flex: 1 }]}\n        inputStyle={inputStyle}\n        labelStyle={labelStyle}\n        style={style}\n        {...rest}\n      />\n      <Animated.View style={{ transform: [{ scale: scaleAnim }] }}>\n        <IconButton\n          key={isRecognizingSpeech ? 'mic-active' : 'mic-inactive'}\n          icon={isRecognizingSpeech ? 'microphone-off' : 'microphone'}\n          size={24}\n          iconColor={micIconColor}\n          onPress={toggleRecognition}\n          style={styles.iconButton}\n        />\n      </Animated.View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  wrapper: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  iconButton: {\n    marginLeft: 8,\n    marginVertical: 0,\n    padding: 0,\n  },\n});\n\nexport default SpeechRecognitionInput;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/crud/GenericDetailModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/crud/GenericFormModal.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'getValues'. Either exclude it or remove the dependency array.","line":395,"column":5,"nodeType":"ArrayExpression","endLine":395,"endColumn":61,"suggestions":[{"desc":"Update the dependencies array to be: [setValue, imagePickerConfig, onFileSelected]","fix":{"range":[10327,10383],"text":"[setValue, imagePickerConfig, onFileSelected]"}}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":425,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":425,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11354,11417],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":428,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":428,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11508,11570],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":453,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":453,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[12436,12539],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, {\n  useEffect,\n  useMemo,\n  useState,\n  useCallback,\n  useRef,\n} from 'react';\nimport {\n  View,\n  StyleSheet,\n  Alert,\n  ScrollView,\n  StyleProp,\n  ViewStyle,\n} from 'react-native';\nimport {\n  Modal,\n  Portal,\n  Text,\n  TextInput,\n  Button,\n  Switch,\n  HelperText,\n  ActivityIndicator,\n} from 'react-native-paper';\nimport {\n  useForm,\n  Controller,\n  SubmitHandler,\n  FieldValues,\n  Path,\n  UseFormReturn,\n  DeepPartial,\n  DefaultValues,\n  Control,\n  FieldError, // Importar FieldError\n} from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { useAppTheme, AppTheme } from '../../styles/theme';\nimport CustomImagePicker, { FileObject } from '../common/CustomImagePicker';\nimport {\n  ImageUploadService,\n  EntityWithOptionalPhoto,\n} from '../../lib/imageUploadService';\n\ntype FieldType =\n  | 'text'\n  | 'textarea'\n  | 'switch'\n  | 'number'\n  | 'email'\n  | 'password';\n\nexport interface FormFieldConfig<TFormData extends FieldValues> {\n  name: Path<TFormData>;\n  label: string;\n  type: FieldType;\n  placeholder?: string;\n  required?: boolean;\n  defaultValue?: any;\n  inputProps?: Partial<React.ComponentProps<typeof TextInput>>;\n  switchProps?: Partial<React.ComponentProps<typeof Switch>>;\n  numberOfLines?: number;\n  switchLabel?: string;\n}\n\nexport interface ImagePickerConfig<TFormData extends FieldValues> {\n  imageUriField: Path<TFormData>;\n  onImageUpload: (file: FileObject) => Promise<{ id: string } | null>;\n  determineFinalPhotoId?: (\n    currentImageUri: string | null,\n    editingItem: EntityWithOptionalPhoto | undefined,\n  ) => string | null | undefined;\n  imagePickerSize?: number;\n}\n\ninterface GenericFormModalProps<\n  TFormData extends FieldValues,\n  TItem extends { id: string },\n> {\n  visible: boolean;\n  onDismiss: () => void;\n  onSubmit: (\n    data: TFormData,\n    photoId: string | null | undefined,\n  ) => Promise<void>;\n  formSchema: z.ZodType<TFormData>;\n  formFields: FormFieldConfig<TFormData>[];\n  imagePickerConfig?: ImagePickerConfig<TFormData>;\n  initialValues?: DeepPartial<TFormData>;\n  editingItem: (TItem & Partial<EntityWithOptionalPhoto>) | null;\n  isSubmitting: boolean;\n  modalTitle: (isEditing: boolean) => string;\n  submitButtonLabel?: (isEditing: boolean) => string;\n  cancelButtonLabel?: string;\n  modalStyle?: StyleProp<ViewStyle>;\n  formContainerStyle?: StyleProp<ViewStyle>;\n  onFileSelected?: (file: FileObject | null) => void;\n}\n\n// Componente separado para manejar campos numéricos correctamente\ninterface NumericInputProps {\n  value: number | null | undefined;\n  onChange: (value: number | null) => void;\n  onBlur: () => void;\n  label: string;\n  placeholder?: string;\n  keyboardType?: any; // Permitir cualquier KeyboardTypeOptions\n  error?: boolean;\n  disabled?: boolean;\n  inputProps?: any;\n}\n\nconst NumericInput: React.FC<NumericInputProps> = ({\n  value,\n  onChange,\n  onBlur,\n  label,\n  placeholder,\n  keyboardType = 'decimal-pad',\n  error,\n  disabled,\n  inputProps,\n}) => {\n  const [inputValue, setInputValue] = useState<string>(\n    value === null || value === undefined ? '' : String(value),\n  );\n\n  useEffect(() => {\n    const stringValue =\n      value === null || value === undefined ? '' : String(value);\n    if (stringValue !== inputValue) {\n      const numericValueFromInput = parseFloat(inputValue);\n      if (\n        !(inputValue.endsWith('.') && numericValueFromInput === value) &&\n        !(inputValue === '.' && value === null)\n      ) {\n        setInputValue(stringValue);\n      }\n    }\n  }, [value, inputValue]);\n\n  const theme = useAppTheme();\n  const styles = getStyles(theme);\n\n  return (\n    <TextInput\n      label={label}\n      value={inputValue}\n      onChangeText={(text) => {\n        const formattedText = text.replace(/,/g, '.');\n        if (/^(\\d*\\.?\\d*)$/.test(formattedText)) {\n          setInputValue(formattedText);\n\n          if (formattedText === '' || formattedText === '.') {\n            if (value !== null) onChange(null);\n          } else {\n            const numericValue = parseFloat(formattedText);\n            if (!isNaN(numericValue) && numericValue !== value) {\n              onChange(numericValue);\n            } else if (isNaN(numericValue) && value !== null) {\n              onChange(null);\n            }\n          }\n        }\n      }}\n      onBlur={onBlur}\n      mode=\"outlined\"\n      style={styles.input}\n      placeholder={placeholder}\n      keyboardType={keyboardType}\n      error={error}\n      disabled={disabled}\n      {...inputProps}\n    />\n  );\n};\n\nconst getDefaultValueForType = (\n  type: FieldType,\n): string | number | boolean | null | undefined => {\n  switch (type) {\n    case 'text':\n    case 'textarea':\n    case 'email':\n    case 'password':\n      return '';\n    case 'number':\n      return null;\n    case 'switch':\n      return false;\n    default:\n      return undefined;\n  }\n};\n\nconst getStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    modalSurface: {\n      padding: 0,\n      margin: theme.spacing.l,\n      borderRadius: theme.roundness * 2,\n      elevation: 4,\n      backgroundColor: theme.colors.background,\n      maxHeight: '90%',\n      overflow: 'hidden',\n    },\n    modalHeader: {\n      backgroundColor: theme.colors.primary,\n      paddingVertical: theme.spacing.m,\n      paddingHorizontal: theme.spacing.l,\n    },\n    formContainer: {\n      maxHeight: '100%',\n    },\n    scrollViewContent: {\n      padding: theme.spacing.l,\n      paddingBottom: theme.spacing.xl,\n    },\n    modalTitle: {\n      color: theme.colors.onPrimary,\n      fontWeight: '700',\n      textAlign: 'center',\n    },\n    input: {\n      marginBottom: theme.spacing.m,\n      backgroundColor: theme.colors.surfaceVariant,\n      borderRadius: theme.roundness,\n    },\n    switchLabel: {\n      color: theme.colors.onSurfaceVariant,\n      marginRight: theme.spacing.m,\n      fontSize: 16,\n      flexShrink: 1,\n    },\n    switchComponentContainer: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      justifyContent: 'flex-start',\n      marginBottom: theme.spacing.m,\n      paddingVertical: theme.spacing.s,\n    },\n    imagePickerContainer: {\n      alignItems: 'center',\n      marginBottom: theme.spacing.l,\n    },\n    modalActions: {\n      flexDirection: 'row',\n      justifyContent: 'center',\n      paddingVertical: theme.spacing.m,\n      paddingHorizontal: theme.spacing.l,\n      borderTopWidth: 1,\n      borderTopColor: theme.colors.outlineVariant,\n      backgroundColor: theme.colors.surface,\n      gap: theme.spacing.m,\n      minHeight: 60,\n    },\n    formButton: {\n      borderRadius: theme.roundness,\n      paddingHorizontal: theme.spacing.xs,\n      flex: 1,\n      maxWidth: 200,\n      minWidth: 140,\n    },\n    cancelButton: {},\n    loadingOverlay: {\n      ...StyleSheet.absoluteFillObject,\n      backgroundColor: 'rgba(0, 0, 0, 0.3)',\n      justifyContent: 'center',\n      alignItems: 'center',\n      borderRadius: theme.roundness * 2,\n      zIndex: 10,\n    },\n    helperText: {\n      marginTop: -theme.spacing.s,\n      marginBottom: theme.spacing.s,\n    },\n  });\n\nconst GenericFormModal = <\n  TFormData extends FieldValues,\n  TItem extends { id: string },\n>({\n  visible,\n  onDismiss,\n  onSubmit,\n  formSchema,\n  formFields,\n  imagePickerConfig,\n  initialValues,\n  editingItem,\n  isSubmitting: isParentSubmitting,\n  modalTitle,\n  submitButtonLabel = (isEditing: boolean) => (isEditing ? 'Guardar' : 'Crear'),\n  cancelButtonLabel = 'Cancelar',\n  modalStyle,\n  formContainerStyle,\n  onFileSelected,\n}: GenericFormModalProps<TFormData, TItem>) => {\n  const theme = useAppTheme();\n  const styles = useMemo(() => getStyles(theme), [theme]);\n  const [isInternalImageUploading, setIsInternalImageUploading] =\n    useState(false);\n  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(\n    null,\n  );\n  const prevVisibleRef = useRef(visible);\n  const prevEditingItemIdRef = useRef(editingItem?.id);\n\n  const isEditing = !!editingItem;\n  const isActuallySubmitting = isParentSubmitting || isInternalImageUploading;\n\n  const {\n    control,\n    handleSubmit,\n    reset,\n    setValue,\n    watch,\n    getValues,\n    formState: { errors },\n  }: UseFormReturn<TFormData> = useForm<TFormData>({\n    resolver: zodResolver(formSchema),\n    defaultValues: useMemo((): DefaultValues<TFormData> => {\n      const defaults = formFields.reduce(\n        (acc: DefaultValues<TFormData>, field) => {\n          acc[field.name] =\n            field.defaultValue ?? getDefaultValueForType(field.type);\n          return acc;\n        },\n        {} as DefaultValues<TFormData>,\n      );\n      return { ...defaults, ...(initialValues as DefaultValues<TFormData>) };\n    }, [formFields, initialValues]),\n  });\n\n  const watchedImageUri = imagePickerConfig\n    ? watch(imagePickerConfig.imageUriField)\n    : undefined;\n  const currentImageUri =\n    typeof watchedImageUri === 'string' ? watchedImageUri : null;\n\n  useEffect(() => {\n    const justOpened = visible && !prevVisibleRef.current;\n    const itemChanged =\n      visible && editingItem?.id !== prevEditingItemIdRef.current;\n\n    if (visible) {\n      const defaultFormValues = formFields.reduce(\n        (acc: DefaultValues<TFormData>, field) => {\n          acc[field.name] =\n            field.defaultValue ?? getDefaultValueForType(field.type);\n          return acc;\n        },\n        {} as DefaultValues<TFormData>,\n      );\n      const resetValues = {\n        ...defaultFormValues,\n        ...(initialValues as DefaultValues<TFormData>),\n      };\n\n      reset(resetValues, { keepDirtyValues: !justOpened && !itemChanged });\n\n      if (justOpened || itemChanged) {\n        setLocalSelectedFile(null);\n        onFileSelected?.(null);\n        setIsInternalImageUploading(false);\n      }\n    }\n\n    prevVisibleRef.current = visible;\n    prevEditingItemIdRef.current = editingItem?.id;\n  }, [\n    visible,\n    editingItem?.id,\n    reset,\n    formFields,\n    initialValues,\n    onFileSelected,\n  ]);\n\n  const handleImageSelected = useCallback(\n    (uri: string, file: FileObject) => {\n      if (imagePickerConfig) {\n        const fieldName = imagePickerConfig.imageUriField;\n        setValue(fieldName, uri as any, {\n          shouldValidate: true,\n          shouldDirty: true,\n          shouldTouch: true,\n        });\n        setLocalSelectedFile(file);\n        onFileSelected?.(file);\n      }\n    },\n    [setValue, getValues, imagePickerConfig, onFileSelected],\n  );\n\n  const handleImageRemoved = useCallback(() => {\n    if (imagePickerConfig) {\n      setValue(imagePickerConfig.imageUriField, null as any, {\n        shouldValidate: true,\n      });\n      setLocalSelectedFile(null);\n      onFileSelected?.(null);\n    }\n  }, [setValue, imagePickerConfig, onFileSelected]);\n\n  const processSubmit: SubmitHandler<TFormData> = async (formData) => {\n    if (isActuallySubmitting) return;\n\n    let finalPhotoId: string | null | undefined = undefined;\n\n    if (imagePickerConfig) {\n      const formImageUri = imagePickerConfig.imageUriField\n        ? formData[imagePickerConfig.imageUriField]\n        : null;\n\n      const isNewLocalImage =\n        typeof formImageUri === 'string' && formImageUri.startsWith('file://');\n      if (isNewLocalImage && localSelectedFile) {\n        setIsInternalImageUploading(true);\n        try {\n          const uploadResult =\n            await imagePickerConfig.onImageUpload(localSelectedFile);\n          console.log('[GenericFormModal] Upload result:', uploadResult);\n          if (uploadResult?.id) {\n            finalPhotoId = uploadResult.id;\n            console.log('[GenericFormModal] New photo ID:', finalPhotoId);\n          } else {\n            throw new Error('La subida de la imagen no devolvió un ID.');\n          }\n        } catch (error) {\n          console.error('Error subiendo imagen:', error);\n          console.error('[GenericFormModal] Error subiendo imagen:', error);\n          Alert.alert(\n            'Error',\n            `No se pudo subir la imagen: ${error instanceof Error ? error.message : 'Error desconocido'}`,\n          );\n          setIsInternalImageUploading(false);\n          return;\n        } finally {\n          setIsInternalImageUploading(false);\n        }\n      } else {\n        const determineFn =\n          imagePickerConfig.determineFinalPhotoId ??\n          ImageUploadService.determinePhotoId;\n        const entityForPhotoCheck = editingItem ?? undefined;\n        finalPhotoId = determineFn(formImageUri, entityForPhotoCheck);\n      }\n    }\n\n    console.log(\n      '[GenericFormModal] Calling onSubmit with finalPhotoId:',\n      finalPhotoId,\n    );\n    await onSubmit(formData, finalPhotoId);\n  };\n\n  const renderFormField = (fieldConfig: FormFieldConfig<TFormData>) => {\n    const fieldName = fieldConfig.name;\n    const fieldError = errors[fieldName] as FieldError | undefined;\n    const errorMessage = fieldError?.message;\n\n    switch (fieldConfig.type) {\n      case 'textarea':\n      case 'text':\n      case 'number':\n      case 'email':\n      case 'password':\n        return (\n          <View key={String(fieldName)}>\n            {/* Controller para campos numéricos con manejo de string local y decimales */}\n            <Controller\n              name={fieldName}\n              control={control as Control<FieldValues>}\n              render={({ field: { onChange, onBlur, value } }) => {\n                if (fieldConfig.type === 'number') {\n                  return (\n                    <NumericInput\n                      value={value}\n                      onChange={onChange}\n                      onBlur={onBlur}\n                      label={fieldConfig.label}\n                      placeholder={fieldConfig.placeholder}\n                      keyboardType={\n                        fieldConfig.inputProps?.keyboardType ?? 'decimal-pad'\n                      }\n                      error={!!errorMessage}\n                      disabled={isActuallySubmitting}\n                      inputProps={fieldConfig.inputProps}\n                    />\n                  );\n                } else {\n                  return (\n                    <TextInput\n                      label={fieldConfig.label}\n                      value={value ?? ''}\n                      onChangeText={onChange}\n                      onBlur={onBlur}\n                      mode=\"outlined\"\n                      style={styles.input}\n                      placeholder={fieldConfig.placeholder}\n                      secureTextEntry={fieldConfig.type === 'password'}\n                      keyboardType={\n                        fieldConfig.type === 'email'\n                          ? 'email-address'\n                          : 'default'\n                      }\n                      multiline={fieldConfig.type === 'textarea'}\n                      numberOfLines={\n                        fieldConfig.numberOfLines ??\n                        (fieldConfig.type === 'textarea' ? 3 : 1)\n                      }\n                      error={!!errorMessage}\n                      disabled={isActuallySubmitting}\n                      {...fieldConfig.inputProps}\n                    />\n                  );\n                }\n              }}\n            />\n            {errorMessage && (\n              <HelperText\n                type=\"error\"\n                visible={!!errorMessage}\n                style={styles.helperText}\n              >\n                {errorMessage}\n              </HelperText>\n            )}\n          </View>\n        );\n      case 'switch':\n        return (\n          <View key={String(fieldName)} style={styles.switchComponentContainer}>\n            <Text variant=\"bodyLarge\" style={styles.switchLabel}>\n              {fieldConfig.switchLabel ?? fieldConfig.label}\n            </Text>\n            <Controller\n              name={fieldName}\n              control={control as Control<FieldValues>}\n              render={({ field: { onChange, value } }) => (\n                <Switch\n                  value={value}\n                  onValueChange={onChange}\n                  disabled={isActuallySubmitting}\n                  style={{ transform: [{ scaleX: 1.5 }, { scaleY: 1.5 }] }}\n                  {...fieldConfig.switchProps}\n                />\n              )}\n            />\n            {errorMessage && (\n              <HelperText\n                type=\"error\"\n                visible={!!errorMessage}\n                style={styles.helperText}\n              >\n                {errorMessage}\n              </HelperText>\n            )}\n          </View>\n        );\n      default:\n        console.warn(`Tipo de campo no soportado: ${fieldConfig.type}`);\n        return null;\n    }\n  };\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible}\n        onDismiss={onDismiss}\n        contentContainerStyle={[styles.modalSurface, modalStyle]}\n        dismissable={!isActuallySubmitting}\n      >\n        <View style={styles.formContainer}>\n          <View style={styles.modalHeader}>\n            <Text variant=\"titleLarge\" style={styles.modalTitle}>\n              {modalTitle(isEditing)}\n            </Text>\n          </View>\n\n          <ScrollView\n            contentContainerStyle={[\n              styles.scrollViewContent,\n              formContainerStyle,\n            ]}\n          >\n            {imagePickerConfig && (\n              <View style={styles.imagePickerContainer}>\n                <CustomImagePicker\n                  value={currentImageUri}\n                  onImageSelected={handleImageSelected}\n                  onImageRemoved={handleImageRemoved}\n                  isLoading={isInternalImageUploading}\n                  disabled={isParentSubmitting}\n                  size={imagePickerConfig.imagePickerSize ?? 180}\n                />\n                {(\n                  errors[imagePickerConfig.imageUriField] as\n                    | FieldError\n                    | undefined\n                )?.message && (\n                  <HelperText\n                    type=\"error\"\n                    visible={!!errors[imagePickerConfig.imageUriField]}\n                    style={styles.helperText}\n                  >\n                    {\n                      (\n                        errors[imagePickerConfig.imageUriField] as\n                          | FieldError\n                          | undefined\n                      )?.message\n                    }\n                  </HelperText>\n                )}\n              </View>\n            )}\n\n            {formFields.map(renderFormField)}\n          </ScrollView>\n\n          {isActuallySubmitting && (\n            <View style={styles.loadingOverlay}>\n              <ActivityIndicator\n                animating={true}\n                size=\"large\"\n                color={theme.colors.primary}\n              />\n            </View>\n          )}\n\n          <View style={styles.modalActions}>\n            <Button\n              mode=\"outlined\"\n              onPress={onDismiss}\n              style={[styles.formButton, styles.cancelButton]}\n              disabled={isActuallySubmitting}\n            >\n              {cancelButtonLabel}\n            </Button>\n            <Button\n              mode=\"contained\"\n              onPress={() => {\n                handleSubmit(processSubmit)();\n              }}\n              loading={isActuallySubmitting}\n              disabled={isActuallySubmitting}\n              style={styles.formButton}\n            >\n              {submitButtonLabel(isEditing)}\n            </Button>\n          </View>\n        </View>\n      </Modal>\n    </Portal>\n  );\n};\n\nexport default GenericFormModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/components/crud/GenericList.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'showImagePlaceholder'. Either include it or remove the dependency array.","line":440,"column":5,"nodeType":"ArrayExpression","endLine":449,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [renderConfig.titleField, renderConfig.descriptionField, renderConfig.sortOrderField, renderConfig.priceField, renderConfig.imageField, renderConfig.statusConfig, renderConfig.descriptionMaxLength, renderConfig.isDefaultField, styles.listItem, styles.listItemContent, styles.statusChip, styles.title, styles.description, styles.listItemImage, styles.itemActionsContainer, listItemStyle, theme.colors.success, theme.colors.onSurfaceVariant, theme.colors.successContainer, theme.colors.surfaceVariant, theme.colors.onSurface, showImagePlaceholder, imageStyle, renderItemActions, itemActionsContainerStyle, onItemPress]","fix":{"range":[12758,12928],"text":"[renderConfig.titleField, renderConfig.descriptionField, renderConfig.sortOrderField, renderConfig.priceField, renderConfig.imageField, renderConfig.statusConfig, renderConfig.descriptionMaxLength, renderConfig.isDefaultField, styles.listItem, styles.listItemContent, styles.statusChip, styles.title, styles.description, styles.listItemImage, styles.itemActionsContainer, listItemStyle, theme.colors.success, theme.colors.onSurfaceVariant, theme.colors.successContainer, theme.colors.surfaceVariant, theme.colors.onSurface, showImagePlaceholder, imageStyle, renderItemActions, itemActionsContainerStyle, onItemPress]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useMemo, useState } from 'react';\nimport { useIsFocused } from '@react-navigation/native';\nimport {\n  StyleSheet,\n  RefreshControl,\n  ViewStyle,\n  StyleProp,\n  View,\n  TextStyle,\n} from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\nimport {\n  List,\n  Chip,\n  Text,\n  Surface,\n  Searchbar,\n  SegmentedButtons,\n  FAB,\n  Portal,\n} from 'react-native-paper';\nimport AutoImage from '../common/AutoImage';\nimport { useAppTheme, AppTheme } from '../../styles/theme';\nimport { getImageUrl } from '../../lib/imageUtils';\nexport interface FilterOption<TValue> {\n  value: TValue;\n  label: string;\n  icon?: string;\n  disabled?: boolean;\n}\n\ninterface StatusConfig<TItem> {\n  field: keyof TItem;\n  activeValue: TItem[keyof TItem];\n  activeLabel: string;\n  inactiveLabel: string;\n}\n\nexport interface RenderItemConfig<TItem> {\n  titleField: keyof TItem;\n  descriptionField?: keyof TItem;\n  descriptionMaxLength?: number;\n  priceField?: keyof TItem;\n  sortOrderField?: keyof TItem;\n  imageField?: keyof TItem;\n  isDefaultField?: keyof TItem;\n  statusConfig?: StatusConfig<TItem>;\n}\n\ninterface GenericListProps<TItem extends { id: string }> {\n  items: TItem[];\n  renderConfig: RenderItemConfig<TItem>;\n  onItemPress: (item: TItem) => void;\n  onRefresh: () => void;\n  isRefreshing: boolean;\n  ListEmptyComponent: React.ComponentType<any> | React.ReactElement | null;\n  isLoading?: boolean;\n  listItemStyle?: StyleProp<ViewStyle>;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  imageStyle?: StyleProp<ViewStyle>;\n  itemActionsContainerStyle?: StyleProp<ViewStyle>;\n  renderItemActions?: (item: TItem) => React.ReactNode;\n  enableSearch?: boolean;\n  searchPlaceholder?: string;\n  searchQuery?: string;\n  onSearchChange?: (query: string) => void;\n  enableSort?: boolean;\n  filterValue?: string | number;\n  onFilterChange?: (value: string | number) => void;\n  filterOptions?: FilterOption<string | number>[];\n  showFab?: boolean;\n  onFabPress?: () => void;\n  fabIcon?: string;\n  fabLabel?: string;\n  fabVisible?: boolean;\n  showImagePlaceholder?: boolean;\n  isModalOpen?: boolean;\n  isDrawerOpen?: boolean;\n}\n\nconst getStyles = (theme: AppTheme) => {\n  const listItemHorizontalMargin = theme.spacing.m;\n  return StyleSheet.create({\n    listContainer: {\n      flex: 1,\n    },\n    searchbarContainer: {\n      paddingHorizontal: listItemHorizontalMargin - theme.spacing.xs,\n      paddingTop: theme.spacing.s,\n      paddingBottom: theme.spacing.xs,\n      backgroundColor: theme.colors.background,\n    },\n    searchbar: {\n      backgroundColor: theme.colors.elevation.level2,\n    },\n    listItem: {\n      backgroundColor: theme.colors.surface,\n      marginVertical: theme.spacing.xs,\n      marginHorizontal: theme.spacing.m,\n      borderRadius: theme.roundness * 1.5,\n      elevation: 2,\n      overflow: 'hidden',\n    },\n    listItemContent: {\n      paddingVertical: theme.spacing.xs,\n    },\n    listItemImage: {\n      width: 60,\n      height: 60,\n      borderRadius: theme.roundness,\n      marginRight: theme.spacing.m,\n      backgroundColor: theme.colors.surfaceDisabled,\n    },\n    statusChip: {\n      borderRadius: theme.roundness * 1.5,\n      height: 40,\n      alignSelf: 'center',\n    },\n    title: {\n      fontWeight: '600',\n      color: theme.colors.onSurface,\n    },\n    description: {\n      color: theme.colors.onSurfaceVariant,\n    },\n    emptyListContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.l,\n    },\n    defaultContentContainer: {\n      paddingBottom: 80,\n      paddingTop: theme.spacing.xs,\n    },\n    itemActionsContainer: {\n      justifyContent: 'center',\n      alignItems: 'center',\n      paddingLeft: theme.spacing.s,\n    },\n    filtersOuterContainer: {\n      paddingTop: theme.spacing.s,\n      paddingBottom: theme.spacing.xs,\n      paddingHorizontal: theme.spacing.xs,\n      backgroundColor: theme.colors.background,\n    },\n    segmentedButtons: {\n      backgroundColor: 'transparent',\n      borderRadius: theme.roundness,\n      minHeight: 40,\n    },\n    filterButton: {\n      borderWidth: 0,\n      paddingVertical: theme.spacing.xs,\n    },\n    filterButtonLabel: {\n      fontSize: 15,\n      letterSpacing: 0.15,\n      paddingVertical: theme.spacing.xs,\n    },\n    fab: {\n      position: 'absolute',\n      margin: 16,\n      right: 0,\n      bottom: 0,\n    },\n  });\n};\n\nconst GenericList = <TItem extends { id: string }>({\n  items,\n  renderConfig,\n  onItemPress,\n  onRefresh,\n  isRefreshing,\n  ListEmptyComponent,\n  listItemStyle,\n  contentContainerStyle,\n  imageStyle,\n  renderItemActions,\n  itemActionsContainerStyle,\n  enableSearch = false,\n  searchPlaceholder = 'Buscar...',\n  enableSort = false,\n  filterValue,\n  onFilterChange,\n  filterOptions,\n  searchQuery: externalSearchQuery,\n  onSearchChange,\n  showFab = false,\n  onFabPress,\n  fabIcon = 'plus',\n  fabLabel,\n  fabVisible = true,\n  showImagePlaceholder = true,\n  isModalOpen = false,\n  isDrawerOpen = false,\n}: GenericListProps<TItem>) => {\n  const theme = useAppTheme();\n  const styles = useMemo(() => getStyles(theme), [theme]);\n  const [internalSearchTerm, setInternalSearchTerm] = useState('');\n  const isSearchControlled =\n    externalSearchQuery !== undefined && onSearchChange !== undefined;\n  const currentSearchTerm = isSearchControlled\n    ? externalSearchQuery\n    : internalSearchTerm;\n  const isFocused = useIsFocused();\n\n  const processedItems = useMemo(() => {\n    let processed = [...items];\n\n    if (enableSort && renderConfig.titleField) {\n      processed.sort((a, b) => {\n        const titleA = String(a[renderConfig.titleField] ?? '').toLowerCase();\n        const titleB = String(b[renderConfig.titleField] ?? '').toLowerCase();\n        return titleA.localeCompare(titleB);\n      });\n    }\n\n    if (enableSearch && !isSearchControlled && currentSearchTerm.trim()) {\n      const lowerCaseSearchTerm = currentSearchTerm.toLowerCase();\n      processed = processed.filter((item) => {\n        const title = String(item[renderConfig.titleField] ?? '').toLowerCase();\n        if (title.includes(lowerCaseSearchTerm)) {\n          return true;\n        }\n        if (renderConfig.descriptionField) {\n          const description = String(\n            item[renderConfig.descriptionField] ?? '',\n          ).toLowerCase();\n          if (description.includes(lowerCaseSearchTerm)) {\n            return true;\n          }\n        }\n        return false;\n      });\n    }\n\n    return processed;\n  }, [\n    items,\n    enableSort,\n    enableSearch,\n    isSearchControlled,\n    currentSearchTerm,\n    renderConfig,\n  ]);\n  const renderGenericItem = useCallback(\n    ({ item }: { item: TItem }) => {\n      const title = String(item[renderConfig.titleField] ?? '');\n\n      let description = '';\n      if (\n        renderConfig.descriptionField &&\n        item.hasOwnProperty(renderConfig.descriptionField)\n      ) {\n        const rawDescription = String(\n          item[renderConfig.descriptionField] || '',\n        );\n        if (rawDescription && rawDescription.toLowerCase() !== 'null') {\n          const maxLength = renderConfig.descriptionMaxLength ?? 50;\n          description =\n            rawDescription.length > maxLength\n              ? `${rawDescription.substring(0, maxLength)}...`\n              : rawDescription;\n        }\n      }\n\n      let sortOrderString: string | null = null;\n      if (\n        renderConfig.sortOrderField &&\n        item.hasOwnProperty(renderConfig.sortOrderField)\n      ) {\n        const sortOrderValue = item[renderConfig.sortOrderField];\n        if (sortOrderValue !== null && sortOrderValue !== undefined) {\n          sortOrderString = `Posicion: ${String(sortOrderValue)}`;\n        }\n      }\n\n      let priceString: string | null = null;\n      if (\n        renderConfig.priceField &&\n        item.hasOwnProperty(renderConfig.priceField)\n      ) {\n        const priceValue = item[renderConfig.priceField];\n        if (priceValue !== null && priceValue !== undefined) {\n          const numericPrice = Number(priceValue);\n          if (!isNaN(numericPrice)) {\n            priceString = `$${numericPrice.toFixed(2)}`;\n          } else if (\n            typeof priceValue === 'string' &&\n            priceValue.trim() !== ''\n          ) {\n            priceString = String(priceValue);\n          }\n        }\n      }\n\n      let imageSource: string | undefined = undefined;\n      if (\n        renderConfig.imageField &&\n        item.hasOwnProperty(renderConfig.imageField)\n      ) {\n        const imageFieldValue = item[renderConfig.imageField];\n        if (\n          typeof imageFieldValue === 'object' &&\n          imageFieldValue !== null &&\n          'path' in imageFieldValue &&\n          typeof imageFieldValue.path === 'string'\n        ) {\n          const url = getImageUrl(imageFieldValue.path);\n          imageSource = url ?? undefined;\n        } else if (typeof imageFieldValue === 'string') {\n          imageSource = imageFieldValue;\n        }\n      }\n\n      let statusChip = null;\n      if (\n        renderConfig.statusConfig &&\n        item.hasOwnProperty(renderConfig.statusConfig.field)\n      ) {\n        const { field, activeValue, activeLabel, inactiveLabel } =\n          renderConfig.statusConfig;\n        const isActive = item[field] === activeValue;\n        const chipLabel = isActive ? activeLabel : inactiveLabel;\n\n        statusChip = (props: {\n          color: string;\n          style?: StyleProp<TextStyle>;\n        }) => (\n          <Chip\n            {...props}\n            mode=\"flat\"\n            selectedColor={\n              isActive ? theme.colors.success : theme.colors.onSurfaceVariant\n            }\n            style={[\n              styles.statusChip,\n              {\n                backgroundColor: isActive\n                  ? theme.colors.successContainer\n                  : theme.colors.surfaceVariant,\n              },\n            ]}\n          >\n            {chipLabel}\n          </Chip>\n        );\n      }\n\n      return (\n        <Surface style={[styles.listItem, listItemStyle]} elevation={1}>\n          <List.Item\n            title={() => (\n              <Text variant=\"titleMedium\" style={styles.title}>\n                {title}\n              </Text>\n            )}\n            description={() => {\n              // Construir las partes del texto\n              const parts = [];\n\n              // Verificar si es por defecto\n              if (\n                renderConfig.isDefaultField &&\n                item.hasOwnProperty(renderConfig.isDefaultField) &&\n                item[renderConfig.isDefaultField] === true\n              ) {\n                parts.push('✓ Por defecto');\n              }\n\n              if (sortOrderString) {\n                parts.push(sortOrderString);\n              }\n\n              if (description) {\n                parts.push(description);\n              }\n\n              if (priceString) {\n                parts.push(priceString);\n              }\n\n              // Unir las partes con el separador apropiado\n              const combinedText = parts.join(' - ');\n\n              if (combinedText.trim()) {\n                return (\n                  <Text\n                    variant=\"bodyMedium\"\n                    style={styles.description}\n                    numberOfLines={2}\n                    ellipsizeMode=\"tail\"\n                  >\n                    {combinedText}\n                  </Text>\n                );\n              }\n              return null;\n            }}\n            left={() => {\n              if (imageSource) {\n                return (\n                  <AutoImage\n                    source={imageSource}\n                    placeholder={require('../../../../assets/icon.png')}\n                    style={[styles.listItemImage, imageStyle]}\n                    contentFit=\"cover\"\n                    transition={300}\n                  />\n                );\n              } else if (showImagePlaceholder) {\n                return <View style={[styles.listItemImage, imageStyle]} />;\n              } else {\n                return null;\n              }\n            }}\n            right={() => (\n              <View style={{ flexDirection: 'row', alignItems: 'center' }}>\n                {statusChip && statusChip({ color: theme.colors.onSurface })}\n                {renderItemActions && (\n                  <View\n                    style={[\n                      styles.itemActionsContainer,\n                      itemActionsContainerStyle,\n                    ]}\n                  >\n                    {renderItemActions(item)}\n                  </View>\n                )}\n              </View>\n            )}\n            onPress={() => onItemPress(item)}\n            style={styles.listItemContent}\n          />\n        </Surface>\n      );\n    },\n    [\n      theme,\n      renderConfig,\n      onItemPress,\n      styles,\n      listItemStyle,\n      imageStyle,\n      renderItemActions,\n      itemActionsContainerStyle,\n    ],\n  );\n\n  // Simplificado: contentContainerStyle solo debe tener padding/backgroundColor.\n  // El centrado del contenido vacío se maneja en el ListEmptyComponent.\n  const finalContentContainerStyle = useMemo(() => {\n    return StyleSheet.flatten([\n      styles.defaultContentContainer,\n      contentContainerStyle,\n    ]);\n  }, [styles.defaultContentContainer, contentContainerStyle]);\n\n  return (\n    <View style={styles.listContainer}>\n      {filterOptions && filterValue !== undefined && onFilterChange && (\n        <Surface style={styles.filtersOuterContainer} elevation={0}>\n          <SegmentedButtons\n            value={String(filterValue)}\n            onValueChange={(value) => {\n              const selectedOption = filterOptions.find(\n                (opt) => String(opt.value) === value,\n              );\n              if (selectedOption) {\n                onFilterChange(selectedOption.value);\n              }\n            }}\n            buttons={filterOptions.map((option) => ({\n              value: String(option.value),\n              label: option.label,\n              icon: option.icon,\n              disabled: option.disabled,\n              style: styles.filterButton,\n              labelStyle: styles.filterButtonLabel,\n              showSelectedCheck: false,\n            }))}\n            style={styles.segmentedButtons}\n            density=\"medium\"\n          />\n        </Surface>\n      )}\n\n      {enableSearch && (\n        <View style={styles.searchbarContainer}>\n          <Searchbar\n            placeholder={searchPlaceholder}\n            onChangeText={\n              isSearchControlled ? onSearchChange : setInternalSearchTerm\n            }\n            value={currentSearchTerm}\n            style={styles.searchbar}\n            inputStyle={{ color: theme.colors.onSurface }}\n            placeholderTextColor={theme.colors.onSurfaceVariant}\n            iconColor={theme.colors.onSurfaceVariant}\n            clearIcon={\n              currentSearchTerm\n                ? () => <List.Icon icon=\"close-circle\" />\n                : undefined\n            }\n            onClearIconPress={() =>\n              isSearchControlled\n                ? onSearchChange('')\n                : setInternalSearchTerm('')\n            }\n          />\n        </View>\n      )}\n\n      <FlashList\n        data={processedItems}\n        renderItem={renderGenericItem}\n        keyExtractor={(item) => item.id}\n        estimatedItemSize={80}\n        contentContainerStyle={finalContentContainerStyle}\n        ListEmptyComponent={\n          processedItems.length === 0 ? ListEmptyComponent : null\n        }\n        refreshControl={\n          <RefreshControl\n            refreshing={isRefreshing}\n            onRefresh={() => {\n              if (isSearchControlled) {\n                onSearchChange('');\n              } else {\n                setInternalSearchTerm('');\n              }\n              onRefresh();\n            }}\n            colors={[theme.colors.primary]}\n            tintColor={theme.colors.primary}\n          />\n        }\n        keyboardShouldPersistTaps=\"handled\"\n      />\n      {showFab && onFabPress && (\n        <Portal>\n          <FAB\n            icon={fabIcon}\n            style={styles.fab}\n            onPress={onFabPress}\n            visible={\n              isFocused &&\n              showFab &&\n              fabVisible &&\n              !isModalOpen &&\n              !isDrawerOpen\n            }\n            label={fabLabel}\n            color={theme.colors.onPrimary}\n            theme={{ colors: { primaryContainer: theme.colors.primary } }}\n          />\n        </Portal>\n      )}\n    </View>\n  );\n};\n\nexport default GenericList;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/constants/apiErrorCodes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/constants/apiPaths.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/constants/storageKeys.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/hooks/useCrudScreenLogic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/hooks/useInitializeAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/hooks/useListState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/lib/apiHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/lib/errorMapping.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/lib/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/lib/formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/lib/imageCache.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":11,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":11,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[341,409],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1631,1688],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":128,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":128,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4053,4265],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":132,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":132,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4285,4435],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":178,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":178,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5561,5622],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":183,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":183,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5763,5808],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":196,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":196,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6181,6246],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":199,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":199,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6326,6367],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as FileSystem from 'expo-file-system';\nimport * as Crypto from 'expo-crypto';\n\nconst CACHE_DIR = `${FileSystem.cacheDirectory}image-cache/`;\nconst MAX_CACHE_SIZE_MB = 100;\nconst MAX_CACHE_AGE_DAYS = 7;\n\nasync function ensureCacheDirExists() {\n  const dirInfo = await FileSystem.getInfoAsync(CACHE_DIR);\n  if (!dirInfo.exists) {\n    console.log(`📊 [CACHÉ] Creando directorio de caché: ${CACHE_DIR}`);\n    await FileSystem.makeDirectoryAsync(CACHE_DIR, { intermediates: true });\n  }\n}\n\nasync function getCacheFilename(remoteUrl: string): Promise<string> {\n  let urlToHash = remoteUrl;\n\n  // Si la URL es de nuestra API, incluir el host en el hash para evitar conflictos\n  // cuando cambia la IP del servidor\n  if (remoteUrl.includes('/api/v1/files/')) {\n    try {\n      const parsedUrl = new URL(remoteUrl);\n      // Incluir host + pathname para diferenciar entre diferentes servidores\n      urlToHash = `${parsedUrl.host}${parsedUrl.pathname}`;\n    } catch (e) {\n      console.warn(\n        `[CACHE] No se pudo parsear la URL para el hash: ${remoteUrl}`,\n      );\n      // Si falla el parseo, usar la URL completa\n      urlToHash = remoteUrl;\n    }\n  }\n\n  const digest = await Crypto.digestStringAsync(\n    Crypto.CryptoDigestAlgorithm.SHA256,\n    urlToHash,\n    { encoding: Crypto.CryptoEncoding.HEX },\n  );\n  const extensionMatch = remoteUrl.match(/\\.([a-zA-Z0-9]+)(?:[?#]|$)/);\n  const extension = extensionMatch ? extensionMatch[1] : 'jpg';\n  return `${digest}.${extension}`;\n}\n\ninterface ExistingFileInfo {\n  uri: string;\n  size: number;\n  modificationTime: number;\n  exists: true;\n}\n\nasync function cleanCache() {\n  console.log('📊 [CACHÉ] Iniciando limpieza de caché...');\n  await ensureCacheDirExists();\n\n  try {\n    const files = await FileSystem.readDirectoryAsync(CACHE_DIR);\n    const fileInfosPromises = files.map(\n      async (\n        file,\n      ): Promise<ExistingFileInfo | { exists: false; uri: string }> => {\n        const info = await FileSystem.getInfoAsync(`${CACHE_DIR}${file}`, {\n          size: true,\n        });\n        if (info.exists) {\n          return {\n            uri: info.uri,\n            size: info.size,\n            modificationTime: info.modificationTime,\n            exists: true,\n          };\n        } else {\n          return {\n            exists: false,\n            uri: info.uri,\n          };\n        }\n      },\n    );\n\n    const allFileInfos = await Promise.all(fileInfosPromises);\n    const existingFileInfos: ExistingFileInfo[] = allFileInfos.filter(\n      (f): f is ExistingFileInfo => f.exists,\n    );\n\n    let totalSize = existingFileInfos.reduce((sum, file) => sum + file.size, 0);\n    existingFileInfos.sort((a, b) => a.modificationTime - b.modificationTime);\n\n    const now = Date.now();\n    const maxAgeMillis = MAX_CACHE_AGE_DAYS * 24 * 60 * 60 * 1000;\n    const maxSizeInBytes = MAX_CACHE_SIZE_MB * 1024 * 1024;\n\n    let filesDeletedCount = 0;\n    let sizeDeleted = 0;\n\n    const filesToDeleteByAge = existingFileInfos.filter(\n      (file) => now - file.modificationTime * 1000 > maxAgeMillis,\n    );\n    for (const file of filesToDeleteByAge) {\n      await FileSystem.deleteAsync(file.uri, { idempotent: true });\n      totalSize -= file.size;\n      sizeDeleted += file.size;\n      filesDeletedCount++;\n    }\n\n    const remainingFiles = existingFileInfos\n      .filter((file) => !(now - file.modificationTime * 1000 > maxAgeMillis))\n      .sort((a, b) => a.modificationTime - b.modificationTime);\n\n    let currentIndex = 0;\n    while (totalSize > maxSizeInBytes && currentIndex < remainingFiles.length) {\n      const fileToDelete = remainingFiles[currentIndex];\n      try {\n        await FileSystem.deleteAsync(fileToDelete.uri, { idempotent: true });\n        totalSize -= fileToDelete.size;\n        sizeDeleted += fileToDelete.size;\n        filesDeletedCount++;\n      } catch (delError) {\n        console.error(\n          `❌ [CACHÉ] Error eliminando archivo ${fileToDelete.uri}:`,\n          delError,\n        );\n      }\n      currentIndex++;\n    }\n\n    if (filesDeletedCount > 0) {\n      console.log(\n        `📊 [CACHÉ] Limpieza completada. ${filesDeletedCount} archivos eliminados (${(sizeDeleted / 1024 / 1024).toFixed(2)} MB). Tamaño actual: ${(totalSize / 1024 / 1024).toFixed(2)} MB.`,\n      );\n    } else {\n      console.log(\n        `📊 [CACHÉ] Limpieza completada. No se eliminaron archivos. Tamaño actual: ${(totalSize / 1024 / 1024).toFixed(2)} MB.`,\n      );\n    }\n  } catch (error) {\n    console.error('❌ [CACHÉ] Error durante la limpieza:', error);\n  }\n}\n\nexport async function getCachedImageUri(\n  remoteUrl: string,\n): Promise<string | null> {\n  if (\n    !remoteUrl ||\n    typeof remoteUrl !== 'string' ||\n    (!remoteUrl.startsWith('http://') && !remoteUrl.startsWith('https://'))\n  ) {\n    return remoteUrl;\n  }\n\n  await ensureCacheDirExists();\n  const filename = await getCacheFilename(remoteUrl);\n  const localUri = `${CACHE_DIR}${filename}`;\n  const fileInfo = await FileSystem.getInfoAsync(localUri);\n\n  if (fileInfo.exists) {\n    return localUri;\n  } else {\n    try {\n      const { uri: downloadedUri } = await FileSystem.downloadAsync(\n        remoteUrl,\n        localUri,\n      );\n      return downloadedUri;\n    } catch (error) {\n      console.error(`❌ [CACHÉ] Error descargando imagen ${remoteUrl}:`, error);\n      const partialFileInfo = await FileSystem.getInfoAsync(localUri);\n      if (partialFileInfo.exists) {\n        await FileSystem.deleteAsync(localUri, { idempotent: true });\n      }\n      return null;\n    }\n  }\n}\n\nexport async function initImageCache() {\n  console.log('🚀 [CACHÉ] Inicializando caché de imágenes...');\n  await ensureCacheDirExists();\n  cleanCache().catch((error) =>\n    console.error('❌ [CACHÉ] Error en la limpieza inicial:', error),\n  );\n  console.log('✅ [CACHÉ] Caché inicializado.');\n}\n\nexport async function removeImageFromCache(remoteUrl: string) {\n  if (!remoteUrl || typeof remoteUrl !== 'string') return;\n  try {\n    const filename = await getCacheFilename(remoteUrl);\n    const localUri = `${CACHE_DIR}${filename}`;\n    await FileSystem.deleteAsync(localUri, { idempotent: true });\n  } catch (error) {}\n}\n\nexport async function clearImageCache() {\n  console.log('⚠️ [CACHÉ] Limpiando todo el caché de imágenes...');\n  try {\n    await FileSystem.deleteAsync(CACHE_DIR, { idempotent: true });\n    console.log('✅ [CACHÉ] Caché limpiado.');\n    await ensureCacheDirExists();\n  } catch (error) {\n    console.error('❌ [CACHÉ] Error limpiando el caché:', error);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/lib/imageUploadService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/lib/imageUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/navigation/AppDrawerNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/navigation/AppNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/navigation/AuthStack.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/navigation/OrdersStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/navigation/components/CustomDrawerContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/navigation/options.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/adjustment.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/area.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/category.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/delivery-info.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/modifier-group.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/modifier.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/order.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/photo.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/product-variant.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/product.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/subcategory.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/schemas/domain/table.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/services/apiClient.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":31,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":31,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[958,1049],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":50,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":50,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1650,1718],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":51,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":51,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1723,1796],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":52,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":52,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1801,1855],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":76,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":76,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2356,2416],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2671,2731],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3051,3106],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":101,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":101,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3330,3387],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":108,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":108,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3548,3607],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":118,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":118,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3864,3963],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4852,4903],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":153,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":153,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4910,4959],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":154,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":154,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4966,5019],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":155,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":155,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5026,5082],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":156,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":156,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5089,5204],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":164,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":164,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5299,5366],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":166,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":166,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5422,5477],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":168,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":168,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5536,5598],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":170,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":170,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5655,5709],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":176,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":176,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5795,5867],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":196,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":196,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6426,6524],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":203,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":203,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6670,6773],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":215,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":215,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7069,7140],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":221,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":221,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7269,7362],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":226,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":226,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7488,7562],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios, {\n  AxiosError,\n  InternalAxiosRequestConfig,\n  AxiosResponse,\n} from 'axios';\nimport { create as createApisauceInstance } from 'apisauce';\nimport { API_URL } from '@env';\nimport EncryptedStorage from 'react-native-encrypted-storage';\nimport { useAuthStore } from '../store/authStore';\nimport { ApiError } from '../lib/errors';\nimport axiosRetry from 'axios-retry';\n\nconst REFRESH_TOKEN_KEY = 'refresh_token';\nconst AUTH_REFRESH_PATH = '/api/v1/auth/refresh';\n\n// --- Instancia de Axios (para interceptores) ---\nconst axiosInstance = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Cache-Control': 'no-cache',\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n  },\n  timeout: 10000, // Reducido a 10 segundos para detectar problemas de red más rápido\n});\n\n// Configurar retry automático para errores de red\naxiosRetry(axiosInstance, {\n  retries: 3, // Número de reintentos\n  retryDelay: (retryCount: number) => {\n    console.log(\n      `[ApiClient] Reintento ${retryCount} después de error de red...`,\n    );\n    return retryCount * 1000; // Espera incremental: 1s, 2s, 3s\n  },\n  retryCondition: (error: AxiosError) => {\n    // Reintentar en errores de red y timeouts\n    return (\n      axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n      error.code === 'ECONNABORTED' ||\n      error.code === 'ETIMEDOUT' ||\n      error.code === 'ENOTFOUND' ||\n      error.code === 'ECONNREFUSED' ||\n      error.code === 'ECONNRESET' ||\n      !error.response\n    );\n  },\n  shouldResetTimeout: true, // Resetear timeout en cada reintento\n  onRetry: (retryCount: number, error: AxiosError, requestConfig: any) => {\n    console.log(`[ApiClient] Error de red detectado: ${error.message}`);\n    console.log(`[ApiClient] Reintentando petición a: ${requestConfig.url}`);\n    console.log(`[ApiClient] Intento ${retryCount} de 3`);\n  },\n});\n\n// --- Lógica de Refresco de Token (igual que antes) ---\nlet isRefreshing = false;\nlet failedQueue: Array<{\n  resolve: (token: string) => void;\n  reject: (error: Error) => void;\n}> = [];\n\nconst processQueue = (error: Error | null, token: string | null = null) => {\n  failedQueue.forEach((prom) => {\n    if (error) {\n      prom.reject(error);\n    } else if (token) {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\n\nasync function refreshToken(): Promise<string> {\n  try {\n    console.log('[ApiClient] Iniciando renovación de token...');\n    const currentRefreshToken =\n      await EncryptedStorage.getItem(REFRESH_TOKEN_KEY);\n    if (!currentRefreshToken) {\n      console.error('[ApiClient] No hay refresh token disponible');\n      throw new Error('No refresh token available.');\n    }\n\n    console.log('[ApiClient] Enviando solicitud de refresh...');\n    const response = await axios.post<{ token: string; refreshToken?: string }>(\n      `${API_URL}${AUTH_REFRESH_PATH}`,\n      {},\n      { headers: { Authorization: `Bearer ${currentRefreshToken}` } },\n    );\n\n    const newAccessToken = response.data.token;\n    const newRefreshToken = response.data.refreshToken;\n\n    console.log('[ApiClient] Token renovado exitosamente');\n\n    // Actualizar tokens en el store\n    const authStore = useAuthStore.getState();\n\n    // Si viene un nuevo refresh token, actualizarlo primero\n    if (newRefreshToken && newRefreshToken !== currentRefreshToken) {\n      console.log('[ApiClient] Actualizando refresh token...');\n      await authStore.setRefreshToken(newRefreshToken);\n    }\n\n    // Luego actualizar el access token\n    await authStore.setAccessToken(newAccessToken);\n\n    console.log('[ApiClient] Tokens actualizados en el store');\n\n    return newAccessToken;\n  } catch (error: any) {\n    console.error(\n      '[ApiClient] Error renovando token:',\n      error.response?.status,\n      error.message,\n    );\n    if (error.response?.status === 401 || error.response?.status === 404) {\n      console.log(\n        '[ApiClient] Token inválido o backend diferente, cerrando sesión...',\n      );\n      await useAuthStore.getState().logout();\n    }\n    throw error;\n  }\n}\n\n// --- Interceptores de Axios (aplicados a axiosInstance) ---\n\n// 1. Interceptor de Peticiones\naxiosInstance.interceptors.request.use(\n  (config: InternalAxiosRequestConfig) => {\n    const accessToken = useAuthStore.getState().accessToken;\n    if (accessToken && config.url !== AUTH_REFRESH_PATH) {\n      config.headers['Authorization'] = `Bearer ${accessToken}`;\n    }\n    return config;\n  },\n  (error) => Promise.reject(error),\n);\n\n// 2. Interceptor de Respuestas\naxiosInstance.interceptors.response.use(\n  (response: AxiosResponse) => response, // Pasa respuestas exitosas\n  async (error: AxiosError) => {\n    // Maneja errores\n    const originalRequest = error.config as InternalAxiosRequestConfig & {\n      _retry?: boolean;\n    };\n\n    // Log detallado para errores de red\n    if (!error.response) {\n      console.log('[ApiClient] Error de red detectado:');\n      console.log('[ApiClient] - Código:', error.code);\n      console.log('[ApiClient] - Mensaje:', error.message);\n      console.log('[ApiClient] - URL:', originalRequest?.url);\n      console.log(\n        '[ApiClient] - Timeout configurado:',\n        originalRequest?.timeout,\n        'ms',\n      );\n\n      // Información adicional para debug\n      if (error.code === 'ECONNABORTED') {\n        console.log('[ApiClient] La petición excedió el tiempo de espera');\n      } else if (error.code === 'ENOTFOUND') {\n        console.log('[ApiClient] No se pudo resolver el host');\n      } else if (error.code === 'ECONNREFUSED') {\n        console.log('[ApiClient] Conexión rechazada por el servidor');\n      } else if (error.code === 'ECONNRESET') {\n        console.log('[ApiClient] La conexión fue reiniciada');\n      }\n    }\n\n    // Log para debug\n    if (error.response?.status === 401) {\n      console.log('[ApiClient] Error 401 detectado en:', originalRequest.url);\n    }\n\n    // No intentar renovar si:\n    // 1. No es un error 401\n    // 2. Es la propia petición de refresh\n    // 3. Es la petición de verificación de token (/auth/me)\n    // 4. Ya se intentó renovar antes\n    if (\n      error.response?.status !== 401 ||\n      originalRequest.url === AUTH_REFRESH_PATH ||\n      originalRequest.url?.includes('/auth/me') ||\n      originalRequest._retry\n    ) {\n      const apiError = ApiError.fromAxiosError(error);\n      return Promise.reject(apiError);\n    }\n\n    // --- Manejo del 401 ---\n    if (isRefreshing) {\n      console.log(\n        '[ApiClient] Ya hay una renovación en curso, encolando petición...',\n      );\n      // Encolar petición\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve: (token) => {\n            console.log(\n              '[ApiClient] Reintentando petición encolada con nuevo token',\n            );\n            originalRequest.headers['Authorization'] = `Bearer ${token}`;\n            originalRequest._retry = true;\n            resolve(axiosInstance(originalRequest));\n          },\n          reject: (err) => reject(ApiError.fromAxiosError(err as AxiosError)),\n        });\n      });\n    }\n\n    console.log('[ApiClient] Iniciando proceso de renovación de token...');\n    isRefreshing = true;\n    originalRequest._retry = true;\n\n    try {\n      const newAccessToken = await refreshToken();\n      console.log(\n        '[ApiClient] Token renovado, procesando cola de peticiones...',\n      );\n      processQueue(null, newAccessToken);\n      originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;\n      console.log('[ApiClient] Reintentando petición original con nuevo token');\n      return axiosInstance(originalRequest);\n    } catch (refreshError: any) {\n      console.error(\n        '[ApiClient] Fallo al renovar token, rechazando todas las peticiones en cola',\n      );\n      processQueue(refreshError, null);\n\n      // Si el error es 401 o 404, ya se habrá cerrado la sesión en refreshToken()\n      // Solo necesitamos rechazar la promesa\n      return Promise.reject(ApiError.fromRefreshError(refreshError));\n    } finally {\n      isRefreshing = false;\n    }\n  },\n);\n\n// --- Crear instancia de Apisauce USANDO la instancia de Axios configurada ---\nconst apiClient = createApisauceInstance({\n  baseURL: API_URL,\n  headers: {\n    // Headers base que Apisauce podría usar/mergear\n    'Cache-Control': 'no-cache',\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n  },\n  timeout: 30000,\n  axiosInstance: axiosInstance, // ¡Aquí está la clave!\n});\n\n// Agregar un response transform para manejar errores\napiClient.addResponseTransform((response) => {\n  // Si la respuesta no es ok y tenemos un error original del interceptor\n  if (!response.ok && response.originalError instanceof ApiError) {\n    // Preservar el ApiError original\n    (response as any).apiError = response.originalError;\n  }\n});\n\n// Exportamos la instancia de APISAUCE que usa nuestro Axios configurado\nexport default apiClient;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/store/authStore.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":98,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":98,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2847,2878],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":133,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":133,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3911,3970],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":137,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":137,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4066,4122],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":139,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":139,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4146,4217],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":158,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":158,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4782,4832],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\nimport EncryptedStorage from 'react-native-encrypted-storage';\nimport type { User } from '../../modules/auth/schema/auth.schema'; // Corregida ruta de importación\nimport { authService } from '../../modules/auth/services/authService';\n\nconst AUTH_TOKEN_KEY = 'auth_token';\nconst REFRESH_TOKEN_KEY = 'refresh_token';\nconst USER_INFO_KEY = 'user_info';\n\nexport interface AuthState {\n  isAuthenticated: boolean;\n  accessToken: string | null;\n  refreshToken: string | null;\n  user: User | null;\n  setTokens: (\n    accessToken: string,\n    refreshToken: string,\n    user: User | null,\n  ) => Promise<void>;\n  setAccessToken: (accessToken: string) => Promise<void>;\n  setRefreshToken: (refreshToken: string) => Promise<void>;\n  setUser: (user: User | null) => Promise<void>;\n  logout: () => Promise<void>;\n}\n\nexport const useAuthStore = create<AuthState>((set) => ({\n  isAuthenticated: false,\n  accessToken: null,\n  refreshToken: null,\n  user: null,\n\n  setTokens: async (\n    accessToken: string,\n    refreshToken: string,\n    user: User | null,\n  ) => {\n    try {\n      await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);\n      await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);\n      if (user) {\n        await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));\n      } else {\n        await EncryptedStorage.removeItem(USER_INFO_KEY);\n      }\n      set({\n        accessToken,\n        refreshToken,\n        user: user ?? null,\n        isAuthenticated: true,\n      });\n    } catch (error) {\n      console.error('Error guardando tokens y user info:', error);\n    }\n  },\n\n  setAccessToken: async (accessToken: string) => {\n    try {\n      await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);\n      set({ accessToken, isAuthenticated: true });\n    } catch (error) {\n      console.error('Error guardando access token:', error);\n    }\n  },\n\n  setRefreshToken: async (refreshToken: string) => {\n    try {\n      await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);\n      set({ refreshToken });\n    } catch (error) {\n      console.error('Error guardando refresh token:', error);\n    }\n  },\n\n  setUser: async (user: User | null) => {\n    try {\n      if (user) {\n        await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));\n      } else {\n        await EncryptedStorage.removeItem(USER_INFO_KEY);\n      }\n      set({ user });\n    } catch (error) {\n      console.error('Error guardando user info:', error);\n    }\n  },\n\n  logout: async () => {\n    try {\n      await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);\n      await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);\n      await EncryptedStorage.removeItem(USER_INFO_KEY);\n      set({\n        accessToken: null,\n        refreshToken: null,\n        user: null,\n        isAuthenticated: false,\n      });\n      console.log('Sesión cerrada.');\n    } catch (error) {\n      console.error('Error al cerrar sesión:', error);\n    }\n  },\n}));\n\nexport const initializeAuthStore = async () => {\n  try {\n    const accessToken = await EncryptedStorage.getItem(AUTH_TOKEN_KEY);\n    const refreshToken = await EncryptedStorage.getItem(REFRESH_TOKEN_KEY);\n    const userInfoString = await EncryptedStorage.getItem(USER_INFO_KEY);\n    let user: User | null = null;\n    if (userInfoString) {\n      try {\n        user = JSON.parse(userInfoString);\n      } catch (parseError) {\n        console.error(\n          'Error parsing user info from EncryptedStorage:',\n          parseError,\n        );\n        await EncryptedStorage.removeItem(USER_INFO_KEY);\n      }\n    }\n\n    if (accessToken && refreshToken) {\n      // Primero establecemos el token en el estado para que el apiClient pueda usarlo\n      useAuthStore.setState({\n        accessToken,\n        refreshToken,\n        user,\n        isAuthenticated: true,\n      });\n\n      // Verificamos si el token es válido con el backend actual\n      console.log('Verificando validez del token almacenado...');\n      const isTokenValid = await authService.verifyToken();\n\n      if (isTokenValid) {\n        console.log('Token válido, manteniendo sesión activa.');\n      } else {\n        console.log('Token inválido o backend diferente, limpiando sesión...');\n        // Si el token no es válido, limpiamos todo\n        await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);\n        await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);\n        await EncryptedStorage.removeItem(USER_INFO_KEY);\n        useAuthStore.setState({\n          accessToken: null,\n          refreshToken: null,\n          user: null,\n          isAuthenticated: false,\n        });\n      }\n    } else {\n      useAuthStore.setState({\n        accessToken: null,\n        refreshToken: null,\n        user: null,\n        isAuthenticated: false,\n      });\n      console.log('AuthStore inicializado sin tokens.');\n    }\n  } catch (error) {\n    console.error('Error inicializando auth store:', error);\n    useAuthStore.setState({\n      accessToken: null,\n      refreshToken: null,\n      user: null,\n      isAuthenticated: false,\n    });\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/store/snackbarStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/store/themeStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/styles/colors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/styles/theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/styles/typography.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/types/api.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/types/env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/types/query.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/types/theme.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/app/utils/networkDiagnostics.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[975,1043],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":58,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":58,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1349,1421],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":69,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":69,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1641,1711],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":81,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":81,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2094,2166],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":100,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":100,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2593,2666],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":110,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":110,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2892,2945],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":183,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":183,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5268,5334],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { API_URL } from '@env';\nimport axios from 'axios';\nimport NetInfo from '@react-native-community/netinfo';\n\ninterface NetworkDiagnosticResult {\n  timestamp: Date;\n  apiUrl: string;\n  networkState: {\n    isConnected: boolean | null;\n    isInternetReachable: boolean | null;\n    type: string;\n    details: any;\n  };\n  apiTest: {\n    success: boolean;\n    responseTime?: number;\n    error?: string;\n    errorCode?: string;\n  };\n  dnsTest: {\n    success: boolean;\n    responseTime?: number;\n    error?: string;\n  };\n  recommendations: string[];\n}\n\nexport async function runNetworkDiagnostics(): Promise<NetworkDiagnosticResult> {\n  const result: NetworkDiagnosticResult = {\n    timestamp: new Date(),\n    apiUrl: API_URL,\n    networkState: {\n      isConnected: null,\n      isInternetReachable: null,\n      type: 'unknown',\n      details: null,\n    },\n    apiTest: {\n      success: false,\n    },\n    dnsTest: {\n      success: false,\n    },\n    recommendations: [],\n  };\n\n  console.log('[NetworkDiagnostics] Iniciando diagnóstico de red...');\n\n  // 1. Verificar estado de la red\n  try {\n    const netInfoState = await NetInfo.fetch();\n    result.networkState = {\n      isConnected: netInfoState.isConnected,\n      isInternetReachable: netInfoState.isInternetReachable,\n      type: netInfoState.type,\n      details: netInfoState.details,\n    };\n    console.log('[NetworkDiagnostics] Estado de red:', result.networkState);\n  } catch (error: any) {\n    console.error(\n      '[NetworkDiagnostics] Error obteniendo estado de red:',\n      error,\n    );\n  }\n\n  // 2. Probar conexión directa a la API\n  const apiStartTime = Date.now();\n  try {\n    console.log('[NetworkDiagnostics] Probando conexión a API:', API_URL);\n    const response = await axios.get(`${API_URL}/api/v1/health`, {\n      timeout: 5000,\n      validateStatus: () => true, // Aceptar cualquier status\n    });\n    const responseTime = Date.now() - apiStartTime;\n\n    result.apiTest = {\n      success: response.status < 500,\n      responseTime,\n      error: response.status >= 500 ? `Status ${response.status}` : undefined,\n    };\n    console.log('[NetworkDiagnostics] Resultado API test:', result.apiTest);\n  } catch (error: any) {\n    const responseTime = Date.now() - apiStartTime;\n    result.apiTest = {\n      success: false,\n      responseTime,\n      error: error.message,\n      errorCode: error.code,\n    };\n    console.error(\n      '[NetworkDiagnostics] Error en API test:',\n      error.code,\n      error.message,\n    );\n  }\n\n  // 3. Probar resolución DNS con un servicio externo\n  const dnsStartTime = Date.now();\n  try {\n    console.log('[NetworkDiagnostics] Probando DNS con servicio externo...');\n    await axios.get('https://dns.google/resolve?name=google.com', {\n      timeout: 5000,\n    });\n    const responseTime = Date.now() - dnsStartTime;\n\n    result.dnsTest = {\n      success: true,\n      responseTime,\n    };\n    console.log('[NetworkDiagnostics] DNS test exitoso');\n  } catch (error: any) {\n    const responseTime = Date.now() - dnsStartTime;\n    result.dnsTest = {\n      success: false,\n      responseTime,\n      error: error.message,\n    };\n    console.error('[NetworkDiagnostics] Error en DNS test:', error.message);\n  }\n\n  // 4. Generar recomendaciones basadas en los resultados\n  if (!result.networkState.isConnected) {\n    result.recommendations.push(\n      'No hay conexión de red. Verifica tu WiFi o datos móviles.',\n    );\n  }\n\n  if (\n    result.networkState.isConnected &&\n    !result.networkState.isInternetReachable\n  ) {\n    result.recommendations.push(\n      'Conectado a la red pero sin acceso a Internet. Verifica tu router o punto de acceso.',\n    );\n  }\n\n  if (!result.apiTest.success && result.apiTest.errorCode === 'ECONNREFUSED') {\n    result.recommendations.push(\n      'El servidor backend no está respondiendo. Verifica que esté en ejecución.',\n    );\n  }\n\n  if (!result.apiTest.success && result.apiTest.errorCode === 'ETIMEDOUT') {\n    result.recommendations.push(\n      'Timeout al conectar con el servidor. Posible problema de red local o firewall.',\n    );\n  }\n\n  if (!result.apiTest.success && result.apiTest.errorCode === 'ENOTFOUND') {\n    result.recommendations.push(\n      'No se puede resolver la dirección del servidor. Verifica la configuración de API_URL.',\n    );\n  }\n\n  if (result.apiTest.responseTime && result.apiTest.responseTime > 3000) {\n    result.recommendations.push(\n      'La latencia de red es muy alta. Considera acercarte al router o usar una conexión más estable.',\n    );\n  }\n\n  if (!result.dnsTest.success) {\n    result.recommendations.push(\n      'Problemas con la resolución DNS. Intenta cambiar los servidores DNS de tu red.',\n    );\n  }\n\n  // Recomendaciones específicas para el problema del PC\n  if (\n    result.apiTest.errorCode === 'ECONNRESET' ||\n    result.apiTest.errorCode === 'ECONNABORTED'\n  ) {\n    result.recommendations.push(\n      'La conexión se está interrumpiendo. Posibles causas:',\n    );\n    result.recommendations.push('- Firewall o antivirus interfiriendo');\n    result.recommendations.push('- Problemas con el adaptador de red');\n    result.recommendations.push(\n      '- Configuración de ahorro de energía en el adaptador',\n    );\n    result.recommendations.push('- Driver de red desactualizado');\n  }\n\n  console.log('[NetworkDiagnostics] Diagnóstico completo:', result);\n  return result;\n}\n\nexport function formatDiagnosticResult(\n  result: NetworkDiagnosticResult,\n): string {\n  let output = '=== DIAGNÓSTICO DE RED ===\\n\\n';\n\n  output += `Fecha: ${result.timestamp.toLocaleString()}\\n`;\n  output += `URL de API: ${result.apiUrl}\\n\\n`;\n\n  output += '📡 ESTADO DE RED:\\n';\n  output += `- Conectado: ${result.networkState.isConnected ? 'Sí' : 'No'}\\n`;\n  output += `- Internet accesible: ${result.networkState.isInternetReachable ? 'Sí' : 'No'}\\n`;\n  output += `- Tipo: ${result.networkState.type}\\n\\n`;\n\n  output += '🔌 TEST DE API:\\n';\n  output += `- Exitoso: ${result.apiTest.success ? 'Sí' : 'No'}\\n`;\n  if (result.apiTest.responseTime) {\n    output += `- Tiempo de respuesta: ${result.apiTest.responseTime}ms\\n`;\n  }\n  if (result.apiTest.error) {\n    output += `- Error: ${result.apiTest.error}\\n`;\n    output += `- Código: ${result.apiTest.errorCode || 'N/A'}\\n`;\n  }\n  output += '\\n';\n\n  output += '🌐 TEST DNS:\\n';\n  output += `- Exitoso: ${result.dnsTest.success ? 'Sí' : 'No'}\\n`;\n  if (result.dnsTest.responseTime) {\n    output += `- Tiempo de respuesta: ${result.dnsTest.responseTime}ms\\n`;\n  }\n  if (result.dnsTest.error) {\n    output += `- Error: ${result.dnsTest.error}\\n`;\n  }\n  output += '\\n';\n\n  if (result.recommendations.length > 0) {\n    output += '💡 RECOMENDACIONES:\\n';\n    result.recommendations.forEach((rec) => {\n      output += `- ${rec}\\n`;\n    });\n  }\n\n  return output;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/components/AreaFormModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/components/TableFormModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/hooks/useAreasQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/hooks/useTablesQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/navigation/AreasTablesStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/schema/area.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/schema/table.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/screens/AreasScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/screens/TablesScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/services/areaService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/services/tableService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/areasTables/types/areasTables.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/auth/components/LoginForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/auth/components/RegisterForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/auth/schema/auth.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/auth/screens/LoginScreen.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":87,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":87,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3012,3051],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":93,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":93,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3265,3368],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":217,"column":44,"nodeType":"MemberExpression","messageId":"unexpected","endLine":217,"endColumn":55},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":357,"column":32,"nodeType":"MemberExpression","messageId":"unexpected","endLine":357,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport {\n  Image,\n  KeyboardAvoidingView,\n  Platform,\n  ScrollView,\n  StyleSheet,\n  View,\n  ActivityIndicator,\n  Alert,\n} from 'react-native';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport {\n  Text,\n  IconButton,\n  Surface,\n  TouchableRipple,\n  Button,\n} from 'react-native-paper';\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport EncryptedStorage from 'react-native-encrypted-storage';\nimport { STORAGE_KEYS } from '../../../app/constants/storageKeys';\nimport { useNavigation } from '@react-navigation/native';\nimport { useAppTheme } from '../../../app/styles/theme';\nimport { useSnackbarStore } from '../../../app/store/snackbarStore';\nimport { getApiErrorMessage } from '../../../app/lib/errorMapping';\nimport { ApiError } from '../../../app/lib/errors';\nimport { useThemeStore } from '../../../app/store/themeStore';\nimport { useAuthStore } from '../../../app/store/authStore';\nimport { LoginFormInputs, LoginResponseDto } from '../schema/auth.schema';\nimport { authService } from '../services/authService';\nimport LoginForm from '../components/LoginForm';\nimport {\n  runNetworkDiagnostics,\n  formatDiagnosticResult,\n} from '../../../app/utils/networkDiagnostics';\n\nconst LoginScreen = () => {\n  const theme = useAppTheme();\n  const queryClient = useQueryClient();\n  const navigation = useNavigation();\n  const { showSnackbar } = useSnackbarStore();\n  const { setThemePreference } = useThemeStore();\n  const setTokens = useAuthStore((state) => state.setTokens);\n\n  const [initialEmailOrUsername, setInitialEmailOrUsername] = useState<\n    string | undefined\n  >(undefined);\n  const [initialPassword, setInitialPassword] = useState<string | undefined>(\n    undefined,\n  );\n  const [initialRememberMe, setInitialRememberMe] = useState(false);\n  const [isLoadingCredentials, setIsLoadingCredentials] = useState(true);\n  const [isRunningDiagnostics, setIsRunningDiagnostics] = useState(false);\n  const [showNetworkError, setShowNetworkError] = useState(false);\n\n  type LoginMutationVariables = LoginFormInputs & { rememberMe: boolean };\n\n  const loginMutation = useMutation<\n    LoginResponseDto,\n    Error,\n    LoginMutationVariables\n  >({\n    mutationFn: (variables) =>\n      authService.login({\n        emailOrUsername: variables.emailOrUsername,\n        password: variables.password,\n      }),\n    onSuccess: async (data, variables) => {\n      try {\n        await setTokens(data.token, data.refreshToken, data.user ?? null);\n        const { emailOrUsername, password, rememberMe } = variables;\n\n        if (rememberMe) {\n          const credentialsToSave = JSON.stringify({\n            emailOrUsername,\n            password,\n          });\n          await EncryptedStorage.setItem(\n            STORAGE_KEYS.REMEMBERED_CREDENTIALS,\n            credentialsToSave,\n          );\n          await EncryptedStorage.setItem(\n            STORAGE_KEYS.REMEMBER_ME_ENABLED,\n            'true',\n          );\n          console.log('Credenciales guardadas.');\n        } else {\n          await EncryptedStorage.removeItem(\n            STORAGE_KEYS.REMEMBERED_CREDENTIALS,\n          );\n          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);\n          console.log(\n            \"Preferencia 'Recordarme' desactivada, credenciales eliminadas.\",\n          );\n        }\n\n        showSnackbar({\n          message: `¡Bienvenido!`,\n          type: 'success',\n        });\n        queryClient.invalidateQueries({ queryKey: ['user', 'me'] });\n      } catch (error) {\n        console.error(\n          'Error al procesar post-login o guardar credenciales:',\n          error,\n        );\n        try {\n          await EncryptedStorage.removeItem(\n            STORAGE_KEYS.REMEMBERED_CREDENTIALS,\n          );\n          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);\n        } catch (cleanupError) {\n          console.error(\n            'Error al limpiar credenciales durante el manejo de error:',\n            cleanupError,\n          );\n        }\n        showSnackbar({\n          message: 'Error procesando el inicio de sesión.',\n          type: 'error',\n        });\n      }\n    },\n    onError: (error: unknown) => {\n      const userMessage = getApiErrorMessage(error);\n      showSnackbar({\n        message: userMessage,\n        type: 'error',\n        duration: 5000,\n      });\n      console.error('Login failed:', error);\n      if (error instanceof ApiError) {\n        console.error('API Error Details:', {\n          code: error.code,\n          status: error.status,\n          details: error.details,\n        });\n\n        // Mostrar opción de diagnóstico en errores de red\n        if (error.code === 'NETWORK_ERROR' || error.status === 0) {\n          setShowNetworkError(true);\n        }\n      }\n    },\n  });\n\n  const handleLoginSubmit = (data: LoginFormInputs, rememberMe: boolean) => {\n    loginMutation.mutate({ ...data, rememberMe });\n  };\n\n  useEffect(() => {\n    const loadCredentials = async () => {\n      setIsLoadingCredentials(true);\n      try {\n        const rememberEnabled = await EncryptedStorage.getItem(\n          STORAGE_KEYS.REMEMBER_ME_ENABLED,\n        );\n        if (rememberEnabled === 'true') {\n          const storedCredentialsJson = await EncryptedStorage.getItem(\n            STORAGE_KEYS.REMEMBERED_CREDENTIALS,\n          );\n          if (storedCredentialsJson) {\n            const storedCredentials = JSON.parse(storedCredentialsJson);\n            setInitialEmailOrUsername(storedCredentials.emailOrUsername);\n            setInitialPassword(storedCredentials.password);\n            setInitialRememberMe(true);\n          } else {\n            setInitialRememberMe(false);\n            setInitialEmailOrUsername('');\n            setInitialPassword('');\n            await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);\n          }\n        } else {\n          setInitialRememberMe(false);\n          setInitialEmailOrUsername('');\n          setInitialPassword('');\n        }\n      } catch (error) {\n        console.error('Error al cargar credenciales recordadas:', error);\n        setInitialRememberMe(false);\n        setInitialEmailOrUsername('');\n        setInitialPassword('');\n        try {\n          await EncryptedStorage.removeItem(\n            STORAGE_KEYS.REMEMBERED_CREDENTIALS,\n          );\n          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);\n        } catch (cleanupError) {\n          console.error(\n            'Error al limpiar credenciales durante manejo de error de carga:',\n            cleanupError,\n          );\n        }\n      } finally {\n        setIsLoadingCredentials(false);\n      }\n    };\n\n    loadCredentials();\n  }, []);\n\n  const toggleTheme = () => {\n    setThemePreference(theme.dark ? 'light' : 'dark');\n  };\n\n  const handleRunDiagnostics = async () => {\n    setIsRunningDiagnostics(true);\n    try {\n      const result = await runNetworkDiagnostics();\n      const formattedResult = formatDiagnosticResult(result);\n\n      Alert.alert(\n        'Diagnóstico de Red',\n        formattedResult,\n        [\n          { text: 'Copiar', onPress: () => console.log('Copiar resultado') },\n          { text: 'Cerrar', style: 'cancel' },\n        ],\n        { cancelable: true },\n      );\n    } catch (error) {\n      console.error('Error ejecutando diagnóstico:', error);\n      showSnackbar({\n        message: 'Error al ejecutar el diagnóstico de red',\n        type: 'error',\n      });\n    } finally {\n      setIsRunningDiagnostics(false);\n      setShowNetworkError(false);\n    }\n  };\n\n  const styles = React.useMemo(\n    () =>\n      StyleSheet.create({\n        safeArea: {\n          flex: 1,\n          backgroundColor: theme.colors.background,\n        },\n        scrollView: {\n          flexGrow: 1,\n        },\n        container: {\n          flex: 1,\n          padding: 24,\n          justifyContent: 'space-between',\n        },\n        logoContainer: {\n          alignItems: 'center',\n          marginTop: 30,\n          marginBottom: 5,\n        },\n        logo: {\n          width: 120,\n          height: 120,\n          marginBottom: 16,\n        },\n        title: {\n          fontSize: 32,\n          fontWeight: 'bold',\n          color: theme.colors.primary,\n          marginBottom: 8,\n          textAlign: 'center',\n        },\n        subtitle: {\n          fontSize: 16,\n          color: theme.colors.onSurfaceVariant,\n          marginBottom: 20,\n          textAlign: 'center',\n          paddingHorizontal: 20,\n        },\n        formContainer: {\n          backgroundColor: theme.colors.surface,\n          borderRadius: 16,\n          padding: 24,\n          elevation: 2,\n          marginBottom: 16,\n        },\n        forgotPassword: {\n          color: theme.colors.primary,\n          textAlign: 'right',\n          marginTop: 8,\n          marginBottom: 16,\n        },\n        registerContainer: {\n          flexDirection: 'row',\n          justifyContent: 'center',\n          alignItems: 'center',\n          marginTop: 20,\n        },\n        registerText: {\n          color: theme.colors.onSurfaceVariant,\n          marginRight: 8,\n        },\n        registerLink: {\n          color: theme.colors.primary,\n          fontWeight: 'bold',\n        },\n        bottomThemeToggleContainer: {\n          alignItems: 'center',\n          marginTop: 20,\n          marginBottom: 16,\n        },\n      }),\n    [theme],\n  );\n\n  if (isLoadingCredentials) {\n    return (\n      <SafeAreaView\n        style={[\n          styles.safeArea,\n          { justifyContent: 'center', alignItems: 'center' },\n        ]}\n      >\n        <ActivityIndicator size=\"large\" color={theme.colors.primary} />\n      </SafeAreaView>\n    );\n  }\n\n  return (\n    <SafeAreaView style={styles.safeArea}>\n      <KeyboardAvoidingView\n        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n        style={{ flex: 1 }}\n      >\n        <ScrollView\n          contentContainerStyle={styles.scrollView}\n          keyboardShouldPersistTaps=\"handled\"\n        >\n          <View style={styles.container}>\n            <View>\n              <View style={styles.logoContainer}>\n                <Image\n                  source={require('../../../assets/logo.png')}\n                  style={styles.logo}\n                  resizeMode=\"contain\"\n                />\n                <Text style={styles.title}>¡Bienvenido!</Text>\n                <Text style={styles.subtitle}>\n                  Inicia sesión para gestionar tus pedidos\n                </Text>\n              </View>\n\n              <Surface style={styles.formContainer}>\n                <LoginForm\n                  onSubmit={handleLoginSubmit}\n                  isLoading={loginMutation.isPending}\n                  initialEmailOrUsername={initialEmailOrUsername}\n                  initialPassword={initialPassword}\n                  initialRememberMe={initialRememberMe}\n                />\n              </Surface>\n\n              <TouchableRipple\n                onPress={() => console.log('Olvidé mi contraseña')}\n              >\n                <Text style={styles.forgotPassword}>\n                  ¿Olvidaste tu contraseña?\n                </Text>\n              </TouchableRipple>\n\n              {showNetworkError && (\n                <Button\n                  mode=\"outlined\"\n                  onPress={handleRunDiagnostics}\n                  loading={isRunningDiagnostics}\n                  disabled={isRunningDiagnostics}\n                  icon=\"wifi-alert\"\n                  style={{ marginTop: 16 }}\n                >\n                  Diagnosticar problemas de red\n                </Button>\n              )}\n            </View>\n\n            <View>\n              <View style={styles.registerContainer}>\n                <Text style={styles.registerText}>¿No tienes una cuenta?</Text>\n                <TouchableRipple\n                  onPress={() => navigation.navigate('Register')}\n                >\n                  <Text style={styles.registerLink}>Regístrate</Text>\n                </TouchableRipple>\n              </View>\n              <View style={styles.bottomThemeToggleContainer}>\n                <IconButton\n                  icon={theme.dark ? 'weather-night' : 'weather-sunny'}\n                  size={28}\n                  onPress={toggleTheme}\n                  iconColor={theme.colors.onSurfaceVariant}\n                />\n              </View>\n            </View>\n          </View>\n        </ScrollView>\n      </KeyboardAvoidingView>\n    </SafeAreaView>\n  );\n};\n\nexport default LoginScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/auth/screens/RegisterScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/auth/services/authService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":46,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":46,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1257,1312],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import apiClient from '../../../app/services/apiClient';\nimport {\n  handleApiResponse,\n  handleApiResponseVoid,\n} from '../../../app/lib/apiHelpers';\nimport { API_PATHS } from '../../../app/constants/apiPaths';\nimport {\n  AuthEmailLoginDto,\n  LoginResponseDto,\n  LoginFormInputs,\n  RegisterFormInputs,\n} from '../schema/auth.schema';\n\nclass AuthService {\n  async login(loginData: LoginFormInputs): Promise<LoginResponseDto> {\n    const isEmail = loginData.emailOrUsername.includes('@');\n    const payload: AuthEmailLoginDto = {\n      password: loginData.password,\n      ...(isEmail\n        ? { email: loginData.emailOrUsername }\n        : { username: loginData.emailOrUsername }),\n    };\n\n    const response = await apiClient.post<LoginResponseDto>(\n      API_PATHS.AUTH_EMAIL_LOGIN,\n      payload,\n    );\n\n    return handleApiResponse(response);\n  }\n\n  async register(data: RegisterFormInputs): Promise<void> {\n    const response = await apiClient.post<{ message?: string }>(\n      API_PATHS.AUTH_EMAIL_REGISTER,\n      data,\n    );\n\n    handleApiResponseVoid(response);\n  }\n\n  async verifyToken(): Promise<boolean> {\n    try {\n      const response = await apiClient.get(API_PATHS.AUTH_ME);\n      return response.status === 200;\n    } catch (error) {\n      console.log('[AuthService] Token inválido o expirado');\n      return false;\n    }\n  }\n}\n\nexport const authService = new AuthService();\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/auth/types/auth.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/availability/components/CategoryAvailabilityItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/availability/components/ModifierGroupAvailabilityItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/availability/hooks/useAvailabilityQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/availability/navigation/AvailabilityStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/availability/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/availability/screens/AvailabilityScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/availability/services/availabilityService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/availability/types/availability.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/components/AddressFormModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/components/CustomerFormModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/components/DateInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/components/LocationPicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/components/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/hooks/useCustomersQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/navigation/CustomersStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/schema/customer.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/screens/CustomersScreen.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback received a function whose dependencies are unknown. Pass an inline function instead.","line":45,"column":30,"nodeType":"Identifier","endLine":45,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useCallback, useState } from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport { Portal } from 'react-native-paper';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useDrawerStatus } from '@react-navigation/drawer';\nimport { debounce } from 'lodash';\nimport ConfirmationModal from '@/app/components/common/ConfirmationModal';\n\nimport {\n  useCustomers,\n  useCreateCustomer,\n  useUpdateCustomer,\n  useDeleteCustomer,\n} from '../hooks/useCustomersQueries';\nimport { Customer } from '../types/customer.types';\nimport { CustomerFormInputs } from '../schema/customer.schema';\nimport { useAppTheme, AppTheme } from '@/app/styles/theme';\nimport GenericList, { FilterOption } from '@/app/components/crud/GenericList';\nimport GenericDetailModal from '@/app/components/crud/GenericDetailModal';\nimport CustomerFormModal from '../components/CustomerFormModal';\nimport { useSnackbarStore } from '@/app/store/snackbarStore';\nimport { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';\nimport { useListState } from '@/app/hooks/useListState';\nimport { formatCurrency } from '@/app/lib/formatters';\n\nfunction CustomersScreen(): React.ReactElement {\n  const theme = useAppTheme();\n  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n  const drawerStatus = useDrawerStatus();\n  const isDrawerOpen = drawerStatus === 'open';\n\n  const [searchQuery, setSearchQuery] = useState('');\n  const [statusFilter, setStatusFilter] = useState<\n    'all' | 'active' | 'inactive' | 'banned'\n  >('all');\n  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');\n  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(\n    null,\n  );\n  const [detailModalVisible, setDetailModalVisible] = useState(false);\n  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);\n  const [customerToDelete, setCustomerToDelete] = useState<string | null>(null);\n\n  const debouncedSetSearch = useCallback(\n    debounce((query: string) => setDebouncedSearchQuery(query), 300),\n    [],\n  );\n\n  const handleSearchChange = (query: string) => {\n    setSearchQuery(query);\n    debouncedSetSearch(query);\n  };\n\n  const handleFilterChange = (value: string | number) => {\n    if (\n      value === 'all' ||\n      value === 'active' ||\n      value === 'inactive' ||\n      value === 'banned'\n    ) {\n      setStatusFilter(value);\n    } else {\n      setStatusFilter('all');\n    }\n  };\n\n  const queryFilters = useMemo(\n    () => ({\n      firstName: debouncedSearchQuery || undefined,\n      lastName: debouncedSearchQuery || undefined,\n      isActive:\n        statusFilter === 'all' || statusFilter === 'banned'\n          ? undefined\n          : statusFilter === 'active',\n      isBanned: statusFilter === 'banned' ? true : undefined,\n    }),\n    [debouncedSearchQuery, statusFilter],\n  );\n\n  const {\n    data: customers,\n    isLoading,\n    error,\n    refetch,\n    isFetching,\n  } = useCustomers(queryFilters);\n\n  const createMutation = useCreateCustomer();\n  const updateMutation = useUpdateCustomer();\n  const { mutateAsync: deleteCustomer } = useDeleteCustomer();\n\n  const {\n    isFormModalVisible,\n    editingItem,\n    handleOpenCreateModal,\n    handleOpenEditModal: originalHandleOpenEditModal,\n    handleCloseModals: originalHandleCloseModals,\n  } = useCrudScreenLogic<Customer>({\n    entityName: 'Cliente',\n    queryKey: ['customers', queryFilters],\n    deleteMutationFn: deleteCustomer,\n  });\n\n  const handleOpenEditModal = useCallback(\n    (item: any) => {\n      setDetailModalVisible(false);\n      // Remover el fullName antes de pasar al modal de edición\n      const { fullName, ...originalCustomer } = item;\n      originalHandleOpenEditModal(originalCustomer as Customer);\n    },\n    [originalHandleOpenEditModal],\n  );\n\n  const handleCloseModals = useCallback(() => {\n    originalHandleCloseModals();\n    setDetailModalVisible(false);\n  }, [originalHandleCloseModals]);\n\n  const handleItemPress = useCallback((item: Customer) => {\n    setSelectedCustomer(item);\n    setDetailModalVisible(true);\n  }, []);\n\n  const handleDelete = useCallback((id: string) => {\n    setCustomerToDelete(id);\n    setShowDeleteConfirmation(true);\n  }, []);\n\n  const handleConfirmDelete = useCallback(async () => {\n    if (!customerToDelete) return;\n\n    try {\n      await deleteCustomer(customerToDelete);\n      showSnackbar({\n        message: 'Cliente eliminado con éxito',\n        type: 'success',\n      });\n      setDetailModalVisible(false);\n      setShowDeleteConfirmation(false);\n      setCustomerToDelete(null);\n    } catch (error) {\n      showSnackbar({\n        message: 'Error al eliminar el cliente',\n        type: 'error',\n      });\n    }\n  }, [deleteCustomer, showSnackbar, customerToDelete]);\n\n  const filterOptions: FilterOption<\n    'all' | 'active' | 'inactive' | 'banned'\n  >[] = [\n    { label: 'Todos', value: 'all' },\n    { label: 'Activos', value: 'active' },\n    { label: 'Inactivos', value: 'inactive' },\n    { label: 'Baneados', value: 'banned' },\n  ];\n\n  const { ListEmptyComponent } = useListState({\n    isLoading,\n    isError: !!error,\n    data: customers,\n    emptyConfig: {\n      title: 'No hay clientes',\n      message:\n        statusFilter !== 'all'\n          ? `No hay clientes ${\n              statusFilter === 'active'\n                ? 'activos'\n                : statusFilter === 'inactive'\n                  ? 'inactivos'\n                  : 'baneados'\n            }.`\n          : 'No hay clientes registrados. Presiona el botón + para crear el primero.',\n      icon: 'account-group-outline',\n    },\n  });\n\n  // Mapear los clientes para combinar firstName y lastName\n  const mappedCustomers = useMemo(() => {\n    return (\n      customers?.map((customer) => ({\n        ...customer,\n        fullName: `${customer.firstName} ${customer.lastName}`.trim(),\n        displayStatus: customer.isBanned\n          ? 'banned'\n          : customer.isActive\n            ? 'active'\n            : 'inactive',\n        whatsappInfo:\n          customer.whatsappMessageCount > 0\n            ? `💬 ${customer.whatsappMessageCount}`\n            : null,\n      })) || []\n    );\n  }, [customers]);\n\n  const handleSubmit = useCallback(\n    async (data: CustomerFormInputs) => {\n      try {\n        if (editingItem) {\n          await updateMutation.mutateAsync({\n            id: editingItem.id,\n            data,\n          });\n          showSnackbar({\n            message: 'Cliente actualizado con éxito',\n            type: 'success',\n          });\n        } else {\n          await createMutation.mutateAsync(data);\n          showSnackbar({\n            message: 'Cliente creado con éxito',\n            type: 'success',\n          });\n        }\n        handleCloseModals();\n      } catch (error) {\n        showSnackbar({\n          message: 'Error al guardar el cliente',\n          type: 'error',\n        });\n      }\n    },\n    [\n      editingItem,\n      createMutation,\n      updateMutation,\n      handleCloseModals,\n      showSnackbar,\n    ],\n  );\n\n  return (\n    <SafeAreaView style={styles.container} edges={['bottom']}>\n      <View style={styles.container}>\n        <GenericList\n          items={mappedCustomers}\n          isLoading={isLoading}\n          isRefreshing={isFetching}\n          onRefresh={refetch}\n          onItemPress={handleItemPress}\n          renderConfig={{\n            titleField: 'fullName' as keyof Customer,\n            descriptionField: 'email' as keyof Customer,\n            imageField: undefined,\n            statusConfig: {\n              field: 'isActive' as keyof Customer,\n              activeValue: true,\n              activeLabel: 'Activo',\n              inactiveLabel: 'Inactivo',\n            },\n          }}\n          searchQuery={searchQuery}\n          onSearchChange={handleSearchChange}\n          searchPlaceholder=\"Buscar por nombre...\"\n          filterOptions={filterOptions}\n          filterValue={statusFilter}\n          onFilterChange={handleFilterChange}\n          showFab={true}\n          onFabPress={handleOpenCreateModal}\n          ListEmptyComponent={ListEmptyComponent}\n          isDrawerOpen={isDrawerOpen}\n          enableSearch={true}\n          showImagePlaceholder={false}\n        />\n      </View>\n\n      <Portal>\n        <CustomerFormModal\n          visible={isFormModalVisible}\n          onDismiss={handleCloseModals}\n          onSubmit={handleSubmit}\n          editingItem={editingItem}\n          isSubmitting={createMutation.isPending || updateMutation.isPending}\n        />\n\n        <GenericDetailModal\n          visible={detailModalVisible}\n          onDismiss={() => setDetailModalVisible(false)}\n          item={\n            selectedCustomer\n              ? {\n                  ...selectedCustomer,\n                  fullName:\n                    `${selectedCustomer.firstName} ${selectedCustomer.lastName}`.trim(),\n                }\n              : null\n          }\n          titleField=\"fullName\"\n          descriptionField=\"email\"\n          statusConfig={{\n            field: 'isActive' as keyof Customer,\n            activeValue: true,\n            activeLabel: 'Activo',\n            inactiveLabel: 'Inactivo',\n          }}\n          onEdit={handleOpenEditModal}\n          onDelete={handleDelete}\n          isDeleting={false}\n          fieldsToDisplay={[\n            {\n              field: 'isBanned' as keyof Customer,\n              label: 'Estado de baneo',\n              render: (value) => (value ? '⛔ Baneado' : '✅ No baneado'),\n            },\n            {\n              field: 'whatsappPhoneNumber' as keyof Customer,\n              label: 'WhatsApp',\n              render: (value) => (value as string) || 'No registrado',\n            },\n            {\n              field: 'stripeCustomerId' as keyof Customer,\n              label: 'Stripe Customer ID',\n              render: (value) => (value as string) || 'No registrado',\n            },\n            {\n              field: 'email' as keyof Customer,\n              label: 'Correo',\n              render: (value) => (value as string) || 'No registrado',\n            },\n            {\n              field: 'birthDate' as keyof Customer,\n              label: 'Fecha de nacimiento',\n              render: (value) =>\n                value\n                  ? new Date(value as string).toLocaleDateString()\n                  : 'No registrada',\n            },\n            {\n              field: 'totalOrders' as keyof Customer,\n              label: 'Total de pedidos',\n              render: (value) => value?.toString() || '0',\n            },\n            {\n              field: 'totalSpent' as keyof Customer,\n              label: 'Total gastado',\n              render: (value) => formatCurrency((value as number) || 0),\n            },\n            {\n              field: 'lastInteraction' as keyof Customer,\n              label: 'Última interacción',\n              render: (value) =>\n                value\n                  ? new Date(value as string).toLocaleString()\n                  : 'Sin interacciones',\n            },\n            {\n              field: 'whatsappMessageCount' as keyof Customer,\n              label: 'Mensajes de WhatsApp',\n              render: (value) => `${value || 0} mensajes`,\n            },\n            {\n              field: 'lastWhatsappMessageTime' as keyof Customer,\n              label: 'Último mensaje WhatsApp',\n              render: (value) =>\n                value\n                  ? new Date(value as string).toLocaleString()\n                  : 'Sin mensajes',\n            },\n          ]}\n        />\n\n        <ConfirmationModal\n          visible={showDeleteConfirmation}\n          title=\"Confirmar Eliminación\"\n          message=\"¿Estás seguro de que quieres eliminar este cliente? Esta acción no se puede deshacer.\"\n          confirmText=\"Eliminar\"\n          cancelText=\"Cancelar\"\n          confirmButtonColor={theme.colors.error}\n          onConfirm={handleConfirmDelete}\n          onCancel={() => {\n            setShowDeleteConfirmation(false);\n            setCustomerToDelete(null);\n          }}\n          onDismiss={() => {\n            setShowDeleteConfirmation(false);\n            setCustomerToDelete(null);\n          }}\n        />\n      </Portal>\n    </SafeAreaView>\n  );\n}\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    rightContent: {\n      flexDirection: 'column',\n      alignItems: 'flex-end',\n      gap: theme.spacing.xs,\n    },\n    activeChip: {\n      backgroundColor: theme.colors.primaryContainer,\n    },\n    inactiveChip: {\n      backgroundColor: theme.colors.errorContainer,\n    },\n    statsChip: {\n      backgroundColor: theme.colors.surfaceVariant,\n    },\n  });\n\nexport default CustomersScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/services/addressesService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/services/customersService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/customers/types/customer.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/components/ProductFormModal.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'allModifierGroups' logical expression could make the dependencies of useEffect Hook (at line 209) change on every render. To fix this, wrap the initialization of 'allModifierGroups' in its own useMemo() Hook.","line":183,"column":9,"nodeType":"VariableDeclarator","endLine":183,"endColumn":63}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useMemo, useState, useCallback } from 'react';\nimport { View, StyleSheet, ScrollView } from 'react-native';\nimport {\n  Modal,\n  Portal,\n  Button,\n  TextInput,\n  Text,\n  ActivityIndicator,\n  Switch,\n  HelperText,\n  Divider,\n  IconButton,\n  Card,\n  Checkbox,\n  TouchableRipple,\n} from 'react-native-paper';\nimport {\n  useForm,\n  Controller,\n  useFieldArray,\n  SubmitHandler,\n} from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\n\nimport { useAppTheme, AppTheme } from '@/app/styles/theme';\nimport {\n  ProductFormInputs,\n  productSchema,\n  updateProductSchema,\n  ProductVariant,\n  Product,\n} from '../schema/products.schema';\nimport { ModifierGroup } from '../../modifiers/schema/modifierGroup.schema';\nimport { getApiErrorMessage } from '@/app/lib/errorMapping';\nimport { useSnackbarStore } from '@/app/store/snackbarStore';\nimport VariantFormModal from './VariantFormModal';\nimport CustomImagePicker, {\n  FileObject,\n} from '@/app/components/common/CustomImagePicker';\nimport { ImageUploadService } from '@/app/lib/imageUploadService';\nimport { getImageUrl } from '@/app/lib/imageUtils';\nimport { useModifierGroupsQuery } from '../../modifiers/hooks/useModifierGroupsQueries';\nimport { modifierService } from '../../modifiers/services/modifierService';\n\ninterface ProductFormModalProps {\n  visible: boolean;\n  onDismiss: () => void;\n  onSubmit: (\n    data: ProductFormInputs,\n    photoId: string | null | undefined,\n    file?: FileObject | null,\n  ) => Promise<void>;\n  initialData?: Product | null;\n  isSubmitting: boolean;\n  productId?: string | null;\n  subcategoryId: string;\n}\n\nfunction ProductFormModal({\n  visible,\n  onDismiss,\n  onSubmit,\n  initialData,\n  isSubmitting,\n  productId,\n  subcategoryId,\n}: ProductFormModalProps): React.ReactElement {\n  const theme = useAppTheme();\n  const styles = useMemo(() => createStyles(theme), [theme]);\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n  const isEditing = !!productId && !!initialData;\n\n  const [isVariantModalVisible, setIsVariantModalVisible] = useState(false);\n  const [editingVariantIndex, setEditingVariantIndex] = useState<number | null>(\n    null,\n  );\n  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(\n    null,\n  );\n  const [isInternalImageUploading, setIsInternalImageUploading] =\n    useState(false);\n  const [groupModifiers, setGroupModifiers] = useState<Record<string, any[]>>(\n    {},\n  );\n  const [priceInputValue, setPriceInputValue] = useState<string>('');\n\n  const defaultValues = useMemo(\n    (): ProductFormInputs => ({\n      name: '',\n      description: null,\n      price: null,\n      hasVariants: false,\n      isActive: true,\n      isPizza: false,\n      subcategoryId: subcategoryId,\n      photoId: null,\n      estimatedPrepTime: 10,\n      preparationScreenId: null,\n      sortOrder: 0,\n      variants: [],\n      variantsToDelete: [],\n      imageUri: null,\n      modifierGroupIds: [],\n    }),\n    [subcategoryId],\n  );\n\n  const {\n    control,\n    handleSubmit,\n    reset,\n    watch,\n    setValue,\n    formState: { errors },\n  } = useForm<ProductFormInputs>({\n    resolver: zodResolver(initialData ? updateProductSchema : productSchema),\n    defaultValues: defaultValues,\n  });\n\n  const {\n    fields: variantFields,\n    append: appendVariant,\n    remove: removeVariant,\n    update: updateVariant,\n  } = useFieldArray({\n    control,\n    name: 'variants',\n  });\n\n  useEffect(() => {\n    if (visible) {\n      if (isEditing && initialData) {\n        const initialPrice = initialData.price;\n        const parsedPrice =\n          initialPrice !== null &&\n          initialPrice !== undefined &&\n          !isNaN(parseFloat(String(initialPrice)))\n            ? parseFloat(String(initialPrice))\n            : null;\n\n        reset({\n          name: initialData.name,\n          description: initialData.description || null,\n          price: parsedPrice,\n          hasVariants: initialData.hasVariants,\n          isActive: initialData.isActive,\n          isPizza: initialData.isPizza ?? false,\n          subcategoryId: initialData.subcategoryId,\n          photoId: initialData.photo?.id ?? null,\n          estimatedPrepTime: initialData.estimatedPrepTime,\n          preparationScreenId: initialData.preparationScreenId,\n          sortOrder: initialData.sortOrder ?? 0,\n          variants: initialData.variants || [],\n          variantsToDelete: [],\n          imageUri: getImageUrl(initialData.photo?.path) ?? null,\n          modifierGroupIds: [],\n        });\n        setLocalSelectedFile(null);\n      } else {\n        reset(defaultValues);\n        setLocalSelectedFile(null);\n      }\n    }\n  }, [visible, isEditing, initialData, reset, defaultValues, subcategoryId]);\n\n  const hasVariants = watch('hasVariants');\n  const currentImageUri = watch('imageUri');\n  const priceValue = watch('price');\n\n  // Sincronizar el valor del precio con el estado del input\n  useEffect(() => {\n    setPriceInputValue(\n      priceValue !== null && priceValue !== undefined\n        ? priceValue.toString()\n        : '',\n    );\n  }, [priceValue]);\n\n  const { data: modifierGroupsResponse, isLoading: isLoadingGroups } =\n    useModifierGroupsQuery({ isActive: true }); // Solo grupos activos\n\n  const allModifierGroups = modifierGroupsResponse?.data || [];\n\n  // Cargar los modificadores de cada grupo\n  useEffect(() => {\n    const loadModifiers = async () => {\n      const modifiersMap: Record<string, any[]> = {};\n\n      for (const group of allModifierGroups) {\n        try {\n          const modifiers = await modifierService.findByGroupId(group.id);\n          modifiersMap[group.id] = modifiers.filter((mod) => mod.isActive);\n        } catch (error) {\n          console.error(\n            `Error loading modifiers for group ${group.id}:`,\n            error,\n          );\n          modifiersMap[group.id] = [];\n        }\n      }\n\n      setGroupModifiers(modifiersMap);\n    };\n\n    if (allModifierGroups.length > 0) {\n      loadModifiers();\n    }\n  }, [allModifierGroups]);\n\n  useEffect(() => {\n    if (visible) {\n      if (isEditing && initialData?.modifierGroups) {\n        if (Array.isArray(initialData.modifierGroups)) {\n          const assignedIds = initialData.modifierGroups.map(\n            (group: ModifierGroup) => group.id,\n          );\n          setValue('modifierGroupIds', assignedIds);\n        } else {\n          setValue('modifierGroupIds', []);\n        }\n      } else if (!isEditing) {\n        setValue('modifierGroupIds', []);\n      } else if (isEditing && !initialData?.modifierGroups) {\n        setValue('modifierGroupIds', []);\n      }\n    }\n  }, [visible, isEditing, initialData, setValue, reset, defaultValues]);\n\n  const handleImageSelected = useCallback(\n    (uri: string, file: FileObject) => {\n      setValue('imageUri', uri, { shouldValidate: true, shouldDirty: true });\n      setLocalSelectedFile(file);\n    },\n    [setValue],\n  );\n\n  const handleImageRemoved = useCallback(() => {\n    setValue('imageUri', null, { shouldValidate: true, shouldDirty: true });\n    setLocalSelectedFile(null);\n  }, [setValue]);\n\n  const processSubmit: SubmitHandler<ProductFormInputs> = async (formData) => {\n    if (isSubmitting || isInternalImageUploading) return;\n\n    let finalPhotoId: string | null | undefined = undefined;\n\n    // 1. Determinar el photoId final\n    if (localSelectedFile) {\n      setIsInternalImageUploading(true);\n      try {\n        const uploadResult =\n          await ImageUploadService.uploadImage(localSelectedFile);\n        if (uploadResult.success && uploadResult.photoId) {\n          finalPhotoId = uploadResult.photoId;\n        } else {\n          throw new Error(\n            uploadResult.error || 'La subida de la imagen falló.',\n          );\n        }\n      } catch (error) {\n        showSnackbar({\n          message: `Error al subir imagen: ${getApiErrorMessage(error)}`,\n          type: 'error',\n        });\n        setIsInternalImageUploading(false);\n        return;\n      } finally {\n        setIsInternalImageUploading(false);\n      }\n    } else {\n      finalPhotoId = ImageUploadService.determinePhotoId(\n        currentImageUri,\n        initialData ?? undefined,\n      );\n    }\n    // 2. Preparar los datos finales\n    const finalData = {\n      ...formData,\n      price: hasVariants ? null : formData.price,\n      variants: hasVariants ? formData.variants : [],\n    };\n    // imageUri se maneja en ProductsScreen antes de la mutación\n\n    // 3. Llamar al onSubmit del padre\n    await onSubmit(finalData, finalPhotoId, localSelectedFile);\n    setLocalSelectedFile(null);\n  };\n\n  const showVariantModal = (index: number | null = null) => {\n    setEditingVariantIndex(index);\n    setIsVariantModalVisible(true);\n  };\n\n  const handleVariantSubmit = (variantData: ProductVariant) => {\n    if (editingVariantIndex !== null) {\n      const originalVariantId =\n        initialData?.variants?.[editingVariantIndex]?.id;\n\n      const priceAsNumber = Number(variantData.price);\n\n      const dataToUpdate = {\n        ...variantData,\n        price: isNaN(priceAsNumber) ? 0 : priceAsNumber, // Asegurar que el precio sea un número\n        ...(originalVariantId && { id: originalVariantId }),\n      };\n\n      // Crear un nuevo objeto sin 'id' si no había uno original, usando desestructuración\n      const finalDataToUpdate =\n        !originalVariantId && 'id' in dataToUpdate\n          ? (({ id, ...rest }) => rest)(dataToUpdate) // Correcto: crea un nuevo objeto sin 'id'\n          : dataToUpdate;\n\n      updateVariant(editingVariantIndex, finalDataToUpdate as ProductVariant);\n    } else {\n      const { id, price, ...restNewVariantData } = variantData;\n      const newPriceAsNumber = Number(price);\n      const newVariantData = {\n        ...restNewVariantData,\n        price: isNaN(newPriceAsNumber) ? 0 : newPriceAsNumber,\n      };\n      appendVariant(newVariantData as ProductVariant);\n    }\n    setIsVariantModalVisible(false);\n    setEditingVariantIndex(null);\n  };\n\n  const handleRemoveVariant = (index: number) => {\n    const variantToRemove = variantFields[index];\n    if (variantToRemove.id) {\n      const currentToDelete = watch('variantsToDelete') || [];\n      setValue('variantsToDelete', [...currentToDelete, variantToRemove.id]);\n    }\n    removeVariant(index);\n  };\n\n  const variantInitialData =\n    editingVariantIndex !== null\n      ? (variantFields[editingVariantIndex] as ProductVariant)\n      : undefined;\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible}\n        onDismiss={onDismiss}\n        contentContainerStyle={styles.modalSurface}\n        dismissable={!isSubmitting && !isInternalImageUploading}\n      >\n        <View style={styles.modalHeader}>\n          <Text variant=\"titleLarge\" style={styles.modalTitle}>\n            {isEditing ? 'Editar Producto' : 'Nuevo Producto'}\n          </Text>\n        </View>\n\n        <ScrollView contentContainerStyle={styles.scrollContent}>\n          <Card style={styles.card}>\n            <Card.Content>\n              <View style={styles.imagePickerContainer}>\n                <CustomImagePicker\n                  value={currentImageUri}\n                  onImageSelected={handleImageSelected}\n                  onImageRemoved={handleImageRemoved}\n                  isLoading={isInternalImageUploading}\n                  disabled={isSubmitting}\n                  size={150}\n                />\n                {errors.imageUri && (\n                  <HelperText type=\"error\">\n                    {errors.imageUri.message}\n                  </HelperText>\n                )}\n              </View>\n\n              <Controller\n                control={control}\n                name=\"name\"\n                render={({ field: { onChange, onBlur, value } }) => (\n                  <TextInput\n                    label=\"Nombre del Producto *\"\n                    value={value}\n                    onChangeText={onChange}\n                    onBlur={onBlur}\n                    error={!!errors.name}\n                    style={styles.input}\n                    disabled={isSubmitting}\n                  />\n                )}\n              />\n              {errors.name && (\n                <HelperText type=\"error\" visible={!!errors.name}>\n                  {errors.name.message}\n                </HelperText>\n              )}\n\n              <Controller\n                control={control}\n                name=\"description\"\n                render={({ field: { onChange, onBlur, value } }) => (\n                  <TextInput\n                    label=\"Descripción\"\n                    value={value || ''}\n                    onChangeText={onChange}\n                    onBlur={onBlur}\n                    error={!!errors.description}\n                    style={styles.input}\n                    disabled={isSubmitting}\n                    multiline\n                    numberOfLines={3}\n                  />\n                )}\n              />\n              {errors.description && (\n                <HelperText type=\"error\" visible={!!errors.description}>\n                  {errors.description.message}\n                </HelperText>\n              )}\n\n              <View style={styles.switchContainer}>\n                <Text style={styles.label}>¿Tiene Variantes?</Text>\n                <Controller\n                  control={control}\n                  name=\"hasVariants\"\n                  render={({ field: { onChange, value } }) => (\n                    <Switch\n                      value={value}\n                      onValueChange={(newValue) => {\n                        onChange(newValue);\n                        if (newValue) {\n                          setValue('price', null, { shouldValidate: true });\n                        }\n                      }}\n                      disabled={isSubmitting}\n                    />\n                  )}\n                />\n              </View>\n\n              {hasVariants && errors.price && (\n                <HelperText type=\"error\" visible={!!errors.price}>\n                  {errors.price.message}\n                </HelperText>\n              )}\n\n              {!hasVariants && (\n                <>\n                  <Controller\n                    control={control}\n                    name=\"price\"\n                    render={({ field }) => (\n                      <TextInput\n                        mode=\"outlined\"\n                        label=\"Precio *\"\n                        keyboardType=\"decimal-pad\"\n                        value={priceInputValue}\n                        onChangeText={(text) => {\n                          const formattedText = text.replace(/,/g, '.');\n\n                          if (/^(\\d*\\.?\\d*)$/.test(formattedText)) {\n                            setPriceInputValue(formattedText); // Actualizar estado local\n\n                            // Actualizar valor del formulario (number | null)\n                            if (formattedText === '') {\n                              field.onChange(null);\n                            } else if (formattedText !== '.') {\n                              field.onChange(parseFloat(formattedText));\n                            }\n                          }\n                        }}\n                        error={!!errors.price}\n                        disabled={isSubmitting || hasVariants}\n                        style={styles.input}\n                      />\n                    )}\n                  />\n                  {errors.price && (\n                    <HelperText type=\"error\" visible={!!errors.price}>\n                      {errors.price?.message || 'Precio inválido'}\n                    </HelperText>\n                  )}\n                </>\n              )}\n\n              {hasVariants && (\n                <View style={styles.variantsSection}>\n                  <Divider style={styles.divider} />\n                  <View style={styles.variantsHeader}>\n                    <Text variant=\"titleMedium\">Variantes</Text>\n                    <Button\n                      mode=\"contained-tonal\"\n                      icon=\"plus\"\n                      onPress={() => showVariantModal()}\n                      disabled={isSubmitting}\n                    >\n                      Añadir\n                    </Button>\n                  </View>\n                  {variantFields.length === 0 && (\n                    <Text style={styles.noVariantsText}>\n                      Aún no hay variantes añadidas.\n                    </Text>\n                  )}\n                  {variantFields.map((field, index) => (\n                    <Card\n                      key={field.id || `new-${index}`}\n                      style={[\n                        styles.variantCard,\n                        field.isActive === false && styles.variantCardInactive,\n                      ]}\n                    >\n                      <View style={styles.variantContent}>\n                        <View style={styles.variantInfo}>\n                          <View style={styles.variantHeader}>\n                            <Text\n                              style={[\n                                styles.variantName,\n                                field.isActive === false &&\n                                  styles.variantNameInactive,\n                              ]}\n                              numberOfLines={1}\n                              ellipsizeMode=\"tail\"\n                            >\n                              {field.name || 'Nueva Variante'}\n                            </Text>\n                            {field.isActive === false && (\n                              <View style={styles.inactiveBadge}>\n                                <Text style={styles.inactiveBadgeText}>\n                                  Inactiva\n                                </Text>\n                              </View>\n                            )}\n                          </View>\n                          <Text style={styles.variantPrice}>\n                            $\n                            {!isNaN(Number(field.price))\n                              ? Number(field.price).toFixed(2)\n                              : '0.00'}\n                          </Text>\n                        </View>\n                        <View style={styles.variantActions}>\n                          <IconButton\n                            icon=\"pencil\"\n                            size={24}\n                            onPress={() => showVariantModal(index)}\n                            disabled={isSubmitting}\n                            style={styles.variantActionButton}\n                          />\n                          <IconButton\n                            icon=\"delete\"\n                            size={24}\n                            onPress={() => handleRemoveVariant(index)}\n                            iconColor={theme.colors.error}\n                            disabled={isSubmitting}\n                            style={styles.variantActionButton}\n                          />\n                        </View>\n                      </View>\n                    </Card>\n                  ))}\n                  {/* Mostrar error si hasVariants es true pero no hay variantes */}\n                  {errors.variants?.message && (\n                    <HelperText\n                      type=\"error\"\n                      visible={!!errors.variants.message}\n                    >\n                      {errors.variants.message as string}\n                    </HelperText>\n                  )}\n                  {/* También podría estar en root para errores de array */}\n                  {errors.variants?.root?.message && (\n                    <HelperText\n                      type=\"error\"\n                      visible={!!errors.variants.root.message}\n                    >\n                      {errors.variants.root.message as string}\n                    </HelperText>\n                  )}\n                </View>\n              )}\n\n              <Divider style={styles.divider} />\n\n              <Controller\n                control={control}\n                name=\"estimatedPrepTime\"\n                render={({ field: { onChange, onBlur, value } }) => (\n                  <TextInput\n                    label=\"Tiempo Prep. Estimado (min)\"\n                    value={\n                      value !== null && value !== undefined ? String(value) : ''\n                    }\n                    onChangeText={(text) =>\n                      onChange(text ? parseInt(text, 10) : 0)\n                    }\n                    onBlur={onBlur}\n                    error={!!errors.estimatedPrepTime}\n                    style={styles.input}\n                    keyboardType=\"numeric\"\n                    disabled={isSubmitting}\n                  />\n                )}\n              />\n              {errors.estimatedPrepTime && (\n                <HelperText type=\"error\" visible={!!errors.estimatedPrepTime}>\n                  {errors.estimatedPrepTime.message}\n                </HelperText>\n              )}\n\n              <Controller\n                control={control}\n                name=\"sortOrder\"\n                render={({ field: { onChange, onBlur, value } }) => (\n                  <TextInput\n                    label=\"Orden de visualización\"\n                    value={\n                      value !== null && value !== undefined ? String(value) : ''\n                    }\n                    onChangeText={(text) =>\n                      onChange(text ? parseInt(text, 10) : 0)\n                    }\n                    onBlur={onBlur}\n                    error={!!errors.sortOrder}\n                    style={styles.input}\n                    keyboardType=\"numeric\"\n                    disabled={isSubmitting}\n                  />\n                )}\n              />\n              {errors.sortOrder && (\n                <HelperText type=\"error\" visible={!!errors.sortOrder}>\n                  {errors.sortOrder.message}\n                </HelperText>\n              )}\n\n              <View style={styles.switchContainer}>\n                <Text style={styles.label}>Activo</Text>\n                <Controller\n                  control={control}\n                  name=\"isActive\"\n                  render={({ field: { onChange, value } }) => (\n                    <Switch\n                      value={value}\n                      onValueChange={onChange}\n                      disabled={isSubmitting}\n                    />\n                  )}\n                />\n              </View>\n\n              <View style={styles.switchContainer}>\n                <Text style={styles.label}>Es Pizza</Text>\n                <Controller\n                  control={control}\n                  name=\"isPizza\"\n                  render={({ field: { onChange, value } }) => (\n                    <Switch\n                      value={value}\n                      onValueChange={onChange}\n                      disabled={isSubmitting}\n                    />\n                  )}\n                />\n              </View>\n\n              <Divider style={styles.divider} />\n\n              <View style={styles.modifierGroupSection}>\n                <Text variant=\"titleMedium\" style={styles.sectionTitle}>\n                  Grupos de Modificadores\n                </Text>\n                {isLoadingGroups ? (\n                  <ActivityIndicator\n                    animating={true}\n                    style={{ marginVertical: theme.spacing.m }}\n                  />\n                ) : allModifierGroups.length === 0 ? (\n                  <Text style={styles.noItemsText}>\n                    No hay grupos de modificadores disponibles.\n                  </Text>\n                ) : (\n                  <Controller\n                    control={control}\n                    name=\"modifierGroupIds\"\n                    render={({ field: { onChange, value } }) => {\n                      const currentIds = Array.isArray(value) ? value : []; // Asegurar que sea array\n                      const availableGroups = allModifierGroups; // Ya es un array de ModifierGroup\n\n                      return (\n                        <>\n                          {availableGroups.map((group: ModifierGroup) => {\n                            const isSelected = currentIds.includes(group.id);\n                            const modifiers = groupModifiers[group.id] || [];\n\n                            return (\n                              <TouchableRipple\n                                key={group.id}\n                                onPress={() => {\n                                  const newIds = isSelected\n                                    ? currentIds.filter((id) => id !== group.id)\n                                    : [...currentIds, group.id];\n                                  onChange(newIds);\n                                }}\n                                disabled={isSubmitting}\n                                style={styles.modifierGroupTouchable}\n                              >\n                                <View style={styles.modifierGroupContent}>\n                                  <Checkbox\n                                    status={\n                                      isSelected ? 'checked' : 'unchecked'\n                                    }\n                                    disabled={isSubmitting}\n                                  />\n                                  <View\n                                    style={styles.modifierGroupTextContainer}\n                                  >\n                                    <Text style={styles.modifierGroupName}>\n                                      {group.name}\n                                    </Text>\n                                    {modifiers.length > 0 && (\n                                      <View\n                                        style={styles.modifiersListContainer}\n                                      >\n                                        {modifiers.map((modifier, index) => (\n                                          <Text\n                                            key={modifier.id}\n                                            style={styles.modifierItem}\n                                          >\n                                            {modifier.isDefault && '✓ '}\n                                            {modifier.name}\n                                            {index < modifiers.length - 1 &&\n                                              ', '}\n                                          </Text>\n                                        ))}\n                                      </View>\n                                    )}\n                                    {modifiers.length === 0 && (\n                                      <Text style={styles.noModifiersText}>\n                                        Sin modificadores activos\n                                      </Text>\n                                    )}\n                                  </View>\n                                </View>\n                              </TouchableRipple>\n                            );\n                          })}\n                        </>\n                      );\n                    }}\n                  />\n                )}\n                {errors.modifierGroupIds && (\n                  <HelperText type=\"error\" visible={!!errors.modifierGroupIds}>\n                    {errors.modifierGroupIds.message as string}\n                  </HelperText>\n                )}\n              </View>\n            </Card.Content>\n          </Card>\n        </ScrollView>\n\n        {(isSubmitting || isInternalImageUploading) && (\n          <View style={styles.loadingOverlay}>\n            <ActivityIndicator\n              animating={true}\n              size=\"large\"\n              color={theme.colors.primary}\n            />\n          </View>\n        )}\n\n        <View style={styles.modalActions}>\n          <Button\n            mode=\"outlined\"\n            onPress={onDismiss}\n            style={[styles.formButton, styles.cancelButton]}\n            disabled={isSubmitting || isInternalImageUploading}\n          >\n            Cancelar\n          </Button>\n          <Button\n            mode=\"contained\"\n            onPress={handleSubmit(processSubmit)}\n            loading={isSubmitting || isInternalImageUploading}\n            disabled={isSubmitting || isInternalImageUploading}\n            style={styles.formButton}\n          >\n            {isEditing ? 'Guardar' : 'Crear'}\n          </Button>\n        </View>\n      </Modal>\n\n      <VariantFormModal\n        visible={isVariantModalVisible}\n        onDismiss={() => setIsVariantModalVisible(false)}\n        onSubmit={handleVariantSubmit}\n        initialData={variantInitialData}\n      />\n    </Portal>\n  );\n}\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    modalSurface: {\n      padding: 0,\n      margin: theme.spacing.m,\n      borderRadius: theme.roundness * 2,\n      elevation: 4,\n      backgroundColor: theme.colors.background,\n      maxHeight: '90%',\n      overflow: 'hidden',\n    },\n    modalHeader: {\n      backgroundColor: theme.colors.primary,\n      paddingVertical: theme.spacing.m,\n      paddingHorizontal: theme.spacing.l,\n      borderTopLeftRadius: theme.roundness * 2,\n      borderTopRightRadius: theme.roundness * 2,\n    },\n    modalTitle: {\n      color: theme.colors.onPrimary,\n      fontWeight: 'bold',\n      textAlign: 'center',\n    },\n    scrollContent: {\n      padding: theme.spacing.l,\n      paddingBottom: theme.spacing.xl,\n    },\n    card: {\n      backgroundColor: theme.colors.surface,\n      elevation: 1,\n    },\n    input: {\n      marginBottom: theme.spacing.m,\n      backgroundColor: theme.colors.surfaceVariant,\n    },\n    switchContainer: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      paddingVertical: theme.spacing.m,\n    },\n    label: {\n      color: theme.colors.onSurfaceVariant,\n      fontSize: 16,\n      marginRight: theme.spacing.m,\n    },\n    divider: {\n      marginVertical: theme.spacing.s,\n    },\n    variantsSection: {\n      marginTop: theme.spacing.s,\n    },\n    variantsHeader: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      marginBottom: theme.spacing.s,\n    },\n    variantCard: {\n      marginBottom: theme.spacing.s,\n      backgroundColor: theme.colors.elevation.level1,\n      paddingVertical: theme.spacing.xs,\n      paddingLeft: theme.spacing.m,\n      paddingRight: theme.spacing.xs,\n    },\n    variantCardInactive: {\n      opacity: 0.7,\n      backgroundColor: theme.colors.surfaceVariant,\n    },\n    variantContent: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n    },\n    variantInfo: {\n      flex: 1,\n      marginRight: theme.spacing.s,\n    },\n    variantHeader: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      marginBottom: 2,\n    },\n    variantName: {\n      fontSize: 15,\n      fontWeight: '500',\n      color: theme.colors.onSurface,\n      flex: 1,\n    },\n    variantNameInactive: {\n      color: theme.colors.onSurfaceVariant,\n    },\n    variantPrice: {\n      fontSize: 14,\n      color: theme.colors.primary,\n      fontWeight: '600',\n    },\n    inactiveBadge: {\n      backgroundColor: theme.colors.errorContainer,\n      paddingHorizontal: theme.spacing.xs,\n      paddingVertical: 2,\n      borderRadius: 4,\n      marginLeft: theme.spacing.xs,\n    },\n    inactiveBadgeText: {\n      fontSize: 10,\n      color: theme.colors.onErrorContainer,\n      fontWeight: '600',\n    },\n    variantActions: {\n      flexDirection: 'row',\n      alignItems: 'center',\n    },\n    variantActionButton: {\n      margin: 0,\n    },\n    noVariantsText: {\n      textAlign: 'center',\n      color: theme.colors.onSurfaceVariant,\n      marginVertical: theme.spacing.s,\n      fontStyle: 'italic',\n    },\n    imagePickerContainer: {\n      alignItems: 'center',\n      marginBottom: theme.spacing.l,\n    },\n    modifierGroupSection: {\n      marginTop: theme.spacing.m,\n    },\n    sectionTitle: {\n      marginBottom: theme.spacing.s,\n      marginLeft: theme.spacing.xs,\n    },\n    noItemsText: {\n      textAlign: 'center',\n      color: theme.colors.onSurfaceVariant,\n      marginVertical: theme.spacing.s,\n      fontStyle: 'italic',\n    },\n    modifierGroupTouchable: {\n      paddingVertical: theme.spacing.s,\n      paddingHorizontal: theme.spacing.m,\n      marginHorizontal: -theme.spacing.m,\n    },\n    modifierGroupContent: {\n      flexDirection: 'row',\n      alignItems: 'flex-start',\n    },\n    modifierGroupTextContainer: {\n      flex: 1,\n      marginLeft: theme.spacing.m,\n    },\n    modifierGroupName: {\n      fontSize: 15,\n      color: theme.colors.onSurface,\n    },\n    modifiersList: {\n      fontSize: 12,\n      color: theme.colors.onSurfaceVariant,\n      fontStyle: 'italic',\n      marginTop: 2,\n    },\n    modifiersListContainer: {\n      marginTop: 4,\n      flexDirection: 'row',\n      flexWrap: 'wrap',\n    },\n    modifierItem: {\n      fontSize: 13,\n      color: theme.colors.onSurfaceVariant,\n      lineHeight: 18,\n    },\n    noModifiersText: {\n      fontSize: 12,\n      color: theme.colors.onSurfaceVariant,\n      fontStyle: 'italic',\n      marginTop: 4,\n      opacity: 0.7,\n    },\n    modalActions: {\n      flexDirection: 'row',\n      justifyContent: 'flex-end',\n      paddingVertical: theme.spacing.m,\n      paddingHorizontal: theme.spacing.l,\n      borderTopWidth: 1,\n      borderTopColor: theme.colors.outlineVariant,\n      backgroundColor: theme.colors.surface,\n    },\n    formButton: {\n      borderRadius: theme.roundness * 2,\n      paddingHorizontal: theme.spacing.m,\n    },\n    cancelButton: {\n      marginRight: theme.spacing.m,\n    },\n    loadingOverlay: {\n      ...StyleSheet.absoluteFillObject,\n      backgroundColor: 'rgba(0, 0, 0, 0.3)',\n      justifyContent: 'center',\n      alignItems: 'center',\n      zIndex: 10,\n      borderRadius: theme.roundness * 2,\n    },\n  });\n\nexport default ProductFormModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/components/VariantFormModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/hooks/useProductsQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/hooks/useSubcategoriesQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/navigation/MenuStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/schema/category.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/schema/products.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/schema/subcategories.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/screens/CategoriesScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/screens/ProductsScreen.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback received a function whose dependencies are unknown. Pass an inline function instead.","line":47,"column":30,"nodeType":"Identifier","endLine":47,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useCallback, useState } from 'react';\nimport { StyleSheet } from 'react-native';\nimport { Portal } from 'react-native-paper';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useRoute, RouteProp, useNavigation } from '@react-navigation/native';\nimport { useDrawerStatus } from '@react-navigation/drawer';\nimport { debounce } from 'lodash';\nimport { useQueryClient } from '@tanstack/react-query';\n\nimport {\n  useProductsQuery,\n  useCreateProductMutation,\n  useUpdateProductMutation,\n  useDeleteProductMutation,\n} from '../hooks/useProductsQueries';\nimport { Product, ProductFormInputs } from '../schema/products.schema';\nimport { MenuStackParamList } from '@/modules/menu/navigation/types';\nimport { useAppTheme, AppTheme } from '@/app/styles/theme';\nimport { getApiErrorMessage } from '@/app/lib/errorMapping';\nimport GenericList, { FilterOption } from '@/app/components/crud/GenericList';\nimport ProductFormModal from '../components/ProductFormModal';\nimport { useSnackbarStore } from '@/app/store/snackbarStore';\nimport { FileObject } from '@/app/components/common/CustomImagePicker';\nimport { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';\nimport { useListState } from '@/app/hooks/useListState';\n\ntype ProductsScreenRouteProp = RouteProp<MenuStackParamList, 'Products'>;\n\nfunction ProductsScreen(): React.ReactElement {\n  const theme = useAppTheme();\n  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);\n  const navigation = useNavigation();\n  const route = useRoute<ProductsScreenRouteProp>();\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n  const drawerStatus = useDrawerStatus();\n  const isDrawerOpen = drawerStatus === 'open';\n\n  const { subcategoryId, subCategoryName } = route.params;\n\n  const [searchQuery, setSearchQuery] = useState('');\n  const [statusFilter, setStatusFilter] = useState<\n    'all' | 'active' | 'inactive'\n  >('all');\n  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');\n\n  const debouncedSetSearch = useCallback(\n    debounce((query: string) => setDebouncedSearchQuery(query), 300),\n    [],\n  );\n\n  const handleSearchChange = (query: string) => {\n    setSearchQuery(query);\n    debouncedSetSearch(query);\n  };\n\n  const handleFilterChange = (value: string | number) => {\n    if (value === 'all' || value === 'active' || value === 'inactive') {\n      setStatusFilter(value);\n    } else {\n      setStatusFilter('all');\n    }\n  };\n\n  const queryFilters = useMemo(\n    () => ({\n      subcategoryId: subcategoryId,\n      search: debouncedSearchQuery || undefined,\n      limit: 20,\n      page: 1,\n      isActive: statusFilter === 'all' ? undefined : statusFilter === 'active',\n    }),\n    [subcategoryId, debouncedSearchQuery, statusFilter],\n  );\n\n  const {\n    data: productsResponse,\n    isLoading,\n    error,\n    refetch,\n    isFetching,\n  } = useProductsQuery(queryFilters, {});\n\n  const createMutation = useCreateProductMutation();\n  const updateMutation = useUpdateProductMutation();\n  const { mutateAsync: deleteProduct } = useDeleteProductMutation();\n\n  const {\n    isFormModalVisible,\n    editingItem,\n    handleOpenCreateModal,\n    handleOpenEditModal,\n    handleCloseModals,\n  } = useCrudScreenLogic<Product>({\n    entityName: 'Producto',\n    queryKey: ['products', queryFilters],\n    deleteMutationFn: deleteProduct,\n  });\n\n  const products = useMemo(() => {\n    return (productsResponse?.data ?? []).map((p: Product) => ({\n      // Añadido tipo explícito\n      ...p,\n      _displayDescription: p.hasVariants\n        ? `${p.variants?.length || 0} variante(s)`\n        : !isNaN(parseFloat(String(p.price)))\n          ? `$${parseFloat(String(p.price)).toFixed(2)}`\n          : 'Precio no definido',\n    }));\n  }, [productsResponse]);\n\n  const handleFormSubmit = useCallback(\n    async (\n      formData: ProductFormInputs,\n      photoId: string | null | undefined,\n      _file?: FileObject | null,\n    ) => {\n      const isEditing = !!editingItem;\n\n      const { imageUri, ...dataToSend } = formData;\n\n      const mutationData = {\n        ...dataToSend,\n        modifierGroupIds: dataToSend.modifierGroupIds ?? [],\n        ...(photoId !== undefined && { photoId: photoId }),\n      };\n\n      try {\n        let productResult: Product;\n\n        if (isEditing && editingItem) {\n          productResult = await updateMutation.mutateAsync({\n            id: editingItem.id,\n            data: mutationData,\n          });\n        } else {\n          productResult = await createMutation.mutateAsync(mutationData);\n        }\n\n        // Éxito\n        const message = isEditing\n          ? 'Producto actualizado con éxito'\n          : 'Producto creado con éxito';\n\n        showSnackbar({ message, type: 'success' });\n        handleCloseModals();\n\n        queryClient.invalidateQueries({\n          queryKey: ['products', queryFilters],\n        });\n        if (productResult?.id) {\n          queryClient.invalidateQueries({\n            queryKey: ['product', productResult.id],\n          });\n        }\n      } catch (err) {\n        const errorMessage = getApiErrorMessage(err);\n        showSnackbar({\n          message: `Error al ${isEditing ? 'actualizar' : 'crear'} producto: ${errorMessage}`,\n          type: 'error',\n        });\n      }\n    },\n    [\n      editingItem,\n      updateMutation,\n      createMutation,\n      showSnackbar,\n      handleCloseModals,\n      queryClient,\n      queryFilters,\n    ],\n  );\n\n  const listRenderConfig = {\n    titleField: 'name' as keyof Product,\n    descriptionField: '_displayDescription' as keyof (Product & {\n      _displayDescription: string;\n    }),\n    imageField: 'photo' as keyof Product,\n    statusConfig: {\n      field: 'isActive' as keyof Product,\n      activeValue: true,\n      activeLabel: 'Activo',\n      inactiveLabel: 'Inactivo',\n    },\n  };\n\n  const filterOptions: FilterOption<'all' | 'active' | 'inactive'>[] = [\n    { value: 'all', label: 'Todos' },\n    { value: 'active', label: 'Activos' },\n    { value: 'inactive', label: 'Inactivos' },\n  ];\n\n  const { ListEmptyComponent } = useListState({\n    isLoading,\n    isError: !!error,\n    data: products,\n    emptyConfig: {\n      title: debouncedSearchQuery\n        ? `No se encontraron productos`\n        : 'No hay productos',\n      message: debouncedSearchQuery\n        ? `No se encontraron productos para \"${debouncedSearchQuery}\"`\n        : `No hay productos en \"${subCategoryName}\". Presiona el botón + para crear el primero.`,\n      icon: 'package-variant',\n    },\n  });\n\n  React.useLayoutEffect(() => {\n    navigation.setOptions({\n      title: subCategoryName ? `Productos de ${subCategoryName}` : 'Productos',\n    });\n  }, [navigation, subCategoryName]);\n\n  return (\n    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>\n      <GenericList<Product & { _displayDescription: string }>\n        items={products}\n        renderConfig={listRenderConfig}\n        onItemPress={handleOpenEditModal}\n        onRefresh={refetch}\n        isRefreshing={isFetching && !isLoading}\n        ListEmptyComponent={ListEmptyComponent}\n        isLoading={isLoading && !isFetching}\n        filterValue={statusFilter}\n        onFilterChange={handleFilterChange}\n        filterOptions={filterOptions}\n        enableSearch={true}\n        searchQuery={searchQuery}\n        onSearchChange={handleSearchChange}\n        searchPlaceholder=\"Buscar productos...\"\n        showFab={true}\n        onFabPress={handleOpenCreateModal}\n        isModalOpen={isFormModalVisible}\n        enableSort={false}\n        contentContainerStyle={styles.contentContainer}\n        showImagePlaceholder={true}\n        isDrawerOpen={isDrawerOpen}\n      />\n\n      <Portal>\n        <ProductFormModal\n          visible={isFormModalVisible}\n          onDismiss={handleCloseModals}\n          onSubmit={handleFormSubmit}\n          initialData={editingItem}\n          isSubmitting={createMutation.isPending || updateMutation.isPending}\n          productId={editingItem?.id}\n          subcategoryId={subcategoryId}\n        />\n      </Portal>\n    </SafeAreaView>\n  );\n}\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    centered: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.l,\n    },\n    errorText: {\n      color: theme.colors.error,\n      textAlign: 'center',\n    },\n    contentContainer: {\n      paddingBottom: 80,\n    },\n  });\n\nexport default ProductsScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/screens/SubcategoriesScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/services/categoryService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":65,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":65,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1831,1906],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":76,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":76,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2135,2208],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import apiClient from '../../../app/services/apiClient';\nimport { ApiError } from '../../../app/lib/errors';\nimport { API_PATHS } from '../../../app/constants/apiPaths';\nimport type {\n  Category,\n  CreateCategoryDto,\n  UpdateCategoryDto,\n} from '../schema/category.schema';\nimport { PaginatedResponse } from '../../../app/types/api.types';\n\nexport const getCategories = async (params?: {\n  isActive?: boolean;\n  page?: number;\n  limit?: number;\n}): Promise<PaginatedResponse<Category>> => {\n  const response = await apiClient.get<{\n    items: Category[];\n    total: number;\n    page: number;\n    limit: number;\n    hasNextPage: boolean;\n    hasPrevPage: boolean;\n  }>(API_PATHS.CATEGORIES, params);\n\n  if (!response.ok || !response.data) {\n    throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n  }\n\n  // Transforma la respuesta del backend a PaginatedResponse\n  return {\n    data: response.data.items,\n    total: response.data.total,\n    page: response.data.page,\n    limit: response.data.limit,\n    totalPages: Math.ceil(response.data.total / response.data.limit),\n  };\n};\n\nexport const getCategory = async (id: string): Promise<Category> => {\n  const response = await apiClient.get<Category>(\n    `${API_PATHS.CATEGORIES}/${id}`,\n  );\n\n  if (!response.ok || !response.data) {\n    throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n  }\n  return response.data;\n};\n\nexport const createCategory = async (\n  data: CreateCategoryDto,\n): Promise<Category> => {\n  const response = await apiClient.post<Category>(API_PATHS.CATEGORIES, data);\n\n  if (!response.ok || !response.data) {\n    throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n  }\n  return response.data;\n};\n\nexport const updateCategory = async (\n  id: string,\n  data: UpdateCategoryDto,\n): Promise<Category> => {\n  console.log('[categoryService] updateCategory called with:', { id, data });\n\n  const response = await apiClient.patch<Category>(\n    `${API_PATHS.CATEGORIES}/${id}`,\n    data,\n  );\n\n  if (!response.ok || !response.data) {\n    throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n  }\n\n  console.log('[categoryService] updateCategory response:', response.data);\n  return response.data;\n};\n\nexport const deleteCategory = async (id: string): Promise<void> => {\n  const response = await apiClient.delete(`${API_PATHS.CATEGORIES}/${id}`);\n\n  if (!response.ok) {\n    throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n  }\n};\n\nexport async function getFullMenu(): Promise<Category[]> {\n  const response = await apiClient.get<Category[]>(\n    `${API_PATHS.CATEGORIES}/full-menu`,\n  );\n\n  if (!response.ok || !response.data) {\n    throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n  }\n\n  return response.data;\n}\n\nconst categoryService = {\n  getCategories,\n  getCategory,\n  createCategory,\n  updateCategory,\n  deleteCategory,\n  getFullMenu,\n};\n\nexport default categoryService;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/services/fileService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/services/productsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/services/subcategoriesService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/types/category.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/menu/types/subcategories.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/components/ModifierFormModal.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has unnecessary dependencies: 'initialData.id', 'isEditing', 'onSaveSuccess', 'queryClient', and 'showSnackbar'. Either exclude them or remove the dependency array.","line":124,"column":5,"nodeType":"ArrayExpression","endLine":132,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [mutation, groupId]","fix":{"range":[3552,3690],"text":"[mutation, groupId]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useCallback } from 'react';\nimport { z } from 'zod';\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\n\nimport { useSnackbarStore } from '@/app/store/snackbarStore';\nimport { getApiErrorMessage } from '@/app/lib/errorMapping';\nimport GenericFormModal, {\n  FormFieldConfig,\n} from '@/app/components/crud/GenericFormModal';\nimport { modifierService } from '../services/modifierService';\nimport { ModifierFormInputs } from '../types/modifier.types';\nimport {\n  Modifier,\n  modifierFormValidationSchema, // Cambiado de modifierSchema\n  CreateModifierInput,\n  UpdateModifierInput,\n} from '../schema/modifier.schema';\n\ninterface Props {\n  visible: boolean;\n  onDismiss: () => void;\n  onSaveSuccess: () => void;\n  initialData?: Modifier | null;\n  groupId: string;\n}\n\nconst formFields: FormFieldConfig<ModifierFormInputs>[] = [\n  { name: 'name', label: 'Nombre *', type: 'text', required: true },\n  {\n    name: 'description',\n    label: 'Descripción (Opcional)',\n    type: 'textarea',\n    numberOfLines: 3,\n  },\n  {\n    name: 'price',\n    label: 'Precio Adicional (Opcional)',\n    type: 'number',\n    inputProps: { keyboardType: 'numeric' },\n  },\n  {\n    name: 'sortOrder',\n    label: 'Orden de Visualización',\n    type: 'number',\n    defaultValue: 0,\n    inputProps: { keyboardType: 'numeric' },\n  },\n  {\n    name: 'isDefault',\n    label: 'Seleccionado por Defecto',\n    type: 'switch',\n    defaultValue: false,\n  },\n  { name: 'isActive', label: 'Activo', type: 'switch', defaultValue: true },\n];\n\nconst formSchema = modifierFormValidationSchema;\n\nconst ModifierFormModal: React.FC<Props> = ({\n  visible,\n  onDismiss,\n  onSaveSuccess,\n  initialData,\n  groupId,\n}) => {\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  const isEditing = !!initialData;\n  const QUERY_KEY_TO_INVALIDATE = ['modifiers', groupId];\n\n  const mutation = useMutation<\n    Modifier,\n    Error,\n    CreateModifierInput | UpdateModifierInput\n  >({\n    mutationFn: (data) => {\n      if (isEditing && initialData) {\n        return modifierService.update(\n          initialData.id,\n          data as UpdateModifierInput,\n        );\n      } else {\n        return modifierService.create(data as CreateModifierInput);\n      }\n    },\n    onSuccess: (data) => {\n      queryClient.invalidateQueries({ queryKey: QUERY_KEY_TO_INVALIDATE });\n      showSnackbar({\n        message: `Modificador \"${data.name}\" ${isEditing ? 'actualizado' : 'creado'} correctamente`,\n        type: 'success',\n      });\n      onSaveSuccess();\n    },\n    onError: (error) => {\n      const message = getApiErrorMessage(error);\n      showSnackbar({ message, type: 'error' });\n      console.error('Error saving modifier:', error);\n    },\n  });\n\n  const handleFormSubmit = useCallback(\n    async (formData: ModifierFormInputs) => {\n      const dataToSend: CreateModifierInput | UpdateModifierInput = {\n        ...formData,\n        price:\n          formData.price === undefined || isNaN(Number(formData.price))\n            ? null\n            : Number(formData.price),\n        description:\n          formData.description === undefined ? null : formData.description,\n        sortOrder: formData.sortOrder ?? 0,\n        isDefault: formData.isDefault ?? false,\n        isActive: formData.isActive ?? true,\n        modifierGroupId: groupId,\n      };\n\n      try {\n        await mutation.mutateAsync(dataToSend);\n      } catch (error) {\n        console.error('Mutation failed in submit handler:', error);\n      }\n    },\n    [\n      mutation,\n      groupId,\n      isEditing,\n      initialData?.id,\n      onSaveSuccess,\n      queryClient,\n      showSnackbar,\n    ],\n  );\n\n  return (\n    <GenericFormModal<ModifierFormInputs, Modifier>\n      visible={visible}\n      onDismiss={onDismiss}\n      onSubmit={handleFormSubmit}\n      formSchema={formSchema as z.ZodSchema<ModifierFormInputs>}\n      formFields={formFields}\n      editingItem={initialData ?? null}\n      isSubmitting={mutation.isPending}\n      modalTitle={(isEditing) =>\n        isEditing ? 'Editar Modificador' : 'Crear Nuevo Modificador'\n      }\n      initialValues={useMemo(\n        () =>\n          initialData\n            ? {\n                name: initialData.name,\n                description: initialData.description,\n                price: initialData.price,\n                sortOrder: initialData.sortOrder,\n                isDefault: initialData.isDefault,\n                isActive: initialData.isActive,\n              }\n            : {\n                name: '',\n                description: null,\n                price: null,\n                sortOrder: 0,\n                isDefault: false,\n                isActive: true,\n              },\n        [initialData],\n      )}\n    />\n  );\n};\n\nexport default ModifierFormModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/components/ModifierGroupFormModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/hooks/useModifierGroupsQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/hooks/useModifiersQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/navigation/ModifiersStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/schema/modifier.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/schema/modifierGroup.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/screens/ModifierGroupsScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ActivityIndicator' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getApiErrorMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":28},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback received a function whose dependencies are unknown. Pass an inline function instead.","line":49,"column":30,"nodeType":"Identifier","endLine":49,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":74,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":10}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useCallback, useState } from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport {\n  ActivityIndicator,\n  Text,\n  Button,\n  IconButton,\n} from 'react-native-paper';\nimport { useQuery } from '@tanstack/react-query';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useNavigation } from '@react-navigation/native';\nimport { useDrawerStatus } from '@react-navigation/drawer';\n\nimport { modifierGroupService } from '../services/modifierGroupService';\nimport { ModifierGroup } from '../schema/modifierGroup.schema';\nimport { useAppTheme, AppTheme } from '@/app/styles/theme';\nimport { getApiErrorMessage } from '@/app/lib/errorMapping';\nimport { debounce } from 'lodash';\nimport ModifierGroupFormModal from '../components/ModifierGroupFormModal';\nimport GenericList, {\n  RenderItemConfig,\n  FilterOption,\n} from '@/app/components/crud/GenericList';\nimport GenericDetailModal, {\n  DisplayFieldConfig,\n} from '@/app/components/crud/GenericDetailModal';\nimport { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';\nimport { PaginatedResponse } from '@/app/types/api.types';\nimport { useListState } from '@/app/hooks/useListState';\n\ntype NavigationProps = {\n  navigate: (screen: string, params?: any) => void;\n};\n\ntype StatusFilter = 'all' | 'active' | 'inactive';\n\nconst QUERY_KEY = ['modifierGroups'];\n\nconst ModifierGroupsScreen = () => {\n  const theme = useAppTheme();\n  const navigation = useNavigation<NavigationProps>();\n  const drawerStatus = useDrawerStatus();\n  const isDrawerOpen = drawerStatus === 'open';\n\n  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');\n\n  const debouncedSetSearch = useCallback(\n    debounce((query: string) => setDebouncedSearchQuery(query), 300),\n    [],\n  );\n\n  const handleSearchChange = (query: string) => {\n    setSearchQuery(query);\n    debouncedSetSearch(query);\n  };\n\n  const queryParams = useMemo(() => {\n    const params: Parameters<typeof modifierGroupService.findAll>[0] = {};\n    if (statusFilter !== 'all') {\n      params.isActive = statusFilter === 'active';\n    }\n    if (debouncedSearchQuery) {\n      params.search = debouncedSearchQuery;\n    }\n    return params;\n  }, [statusFilter, debouncedSearchQuery]);\n\n  const {\n    data: paginatedData,\n    isLoading,\n    isError,\n    error,\n    refetch,\n    isRefetching,\n  } = useQuery<PaginatedResponse<ModifierGroup>, Error>({\n    queryKey: [QUERY_KEY[0], queryParams],\n    queryFn: () => modifierGroupService.findAll(queryParams),\n  });\n\n  const modifierGroups = paginatedData?.data || [];\n\n  const {\n    isFormModalVisible,\n    isDetailModalVisible,\n    editingItem,\n    selectedItem,\n    isDeleting,\n    handleOpenCreateModal,\n    handleOpenEditModal,\n    handleOpenDetailModal,\n    handleCloseModals,\n    handleDeleteItem,\n  } = useCrudScreenLogic<ModifierGroup>({\n    entityName: 'Grupo de Modificadores',\n    queryKey: [QUERY_KEY[0], queryParams],\n    deleteMutationFn: modifierGroupService.remove,\n  });\n\n  const handleNavigateToModifiers = (groupId: string, groupName: string) => {\n    navigation.navigate('ModifiersScreen', { groupId, groupName });\n  };\n\n  const handleFormSaveSuccess = () => {\n    handleCloseModals();\n  };\n\n  const handleFilterChange = (value: string | number) => {\n    // Validar que el valor sea uno de los StatusFilter esperados\n    if (value === 'all' || value === 'active' || value === 'inactive') {\n      setStatusFilter(value as StatusFilter);\n    } else {\n      // Opcional: manejar valor inesperado, por ahora default a 'all'\n      console.warn(\n        `Valor de filtro inesperado recibido: ${value}, usando 'all'.`,\n      );\n      setStatusFilter('all');\n    }\n  };\n\n  const handleRefresh = () => {\n    refetch();\n  };\n\n  const listRenderConfig: RenderItemConfig<ModifierGroup> = {\n    titleField: 'name',\n    descriptionField: 'description',\n    statusConfig: {\n      field: 'isActive',\n      activeValue: true,\n      activeLabel: 'Activo',\n      inactiveLabel: 'Inactivo',\n    },\n  };\n\n  const detailFields: DisplayFieldConfig<ModifierGroup>[] = [\n    { field: 'minSelections', label: 'Mín. Selecciones' },\n    { field: 'maxSelections', label: 'Máx. Selecciones' },\n    {\n      field: 'isRequired',\n      label: 'Requerido',\n      render: (value) => (\n        <Text style={{ color: theme.colors.onSurface }}>\n          {value ? 'Sí' : 'No'}\n        </Text>\n      ),\n    },\n    {\n      field: 'allowMultipleSelections',\n      label: 'Permite Múltiples',\n      render: (value) => (\n        <Text style={{ color: theme.colors.onSurface }}>\n          {value ? 'Sí' : 'No'}\n        </Text>\n      ),\n    },\n  ];\n\n  const styles = useMemo(() => createStyles(theme), [theme]);\n\n  const filterOptions: FilterOption<StatusFilter>[] = [\n    { value: 'all', label: 'Todos' },\n    { value: 'active', label: 'Activos' },\n    { value: 'inactive', label: 'Inactivos' },\n  ];\n\n  const { ListEmptyComponent } = useListState({\n    isLoading: isLoading && !isRefetching,\n    isError,\n    data: modifierGroups,\n    emptyConfig: {\n      title: searchQuery\n        ? 'No se encontraron grupos'\n        : 'No hay grupos de modificadores',\n      message: searchQuery\n        ? `No se encontraron grupos para \"${searchQuery}\"`\n        : statusFilter !== 'all'\n          ? `No hay grupos de modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'}.`\n          : 'No hay grupos de modificadores registrados. Presiona el botón + para crear el primero.',\n      icon: 'folder-multiple-outline',\n    },\n  });\n\n  return (\n    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>\n      <GenericList<ModifierGroup>\n        items={modifierGroups}\n        renderConfig={listRenderConfig}\n        onItemPress={handleOpenDetailModal}\n        onRefresh={handleRefresh}\n        isRefreshing={isRefetching}\n        ListEmptyComponent={ListEmptyComponent}\n        isLoading={isLoading} // Pasar directamente el estado de carga principal\n        enableSearch={true}\n        searchQuery={searchQuery}\n        onSearchChange={handleSearchChange}\n        searchPlaceholder=\"Buscar grupos...\"\n        filterValue={statusFilter}\n        onFilterChange={handleFilterChange}\n        filterOptions={filterOptions}\n        showFab={true}\n        onFabPress={handleOpenCreateModal}\n        isModalOpen={isFormModalVisible || isDetailModalVisible}\n        showImagePlaceholder={false}\n        isDrawerOpen={isDrawerOpen}\n        renderItemActions={(item) => (\n          <IconButton\n            icon=\"format-list-bulleted\"\n            size={24}\n            onPress={(e) => {\n              e.stopPropagation();\n              handleNavigateToModifiers(item.id, item.name);\n            }}\n          />\n        )}\n      />\n\n      <ModifierGroupFormModal\n        visible={isFormModalVisible}\n        onDismiss={handleCloseModals}\n        onSaveSuccess={handleFormSaveSuccess}\n        initialData={editingItem}\n      />\n\n      <GenericDetailModal<ModifierGroup>\n        visible={isDetailModalVisible}\n        onDismiss={handleCloseModals}\n        item={selectedItem}\n        titleField=\"name\"\n        descriptionField=\"description\"\n        statusConfig={listRenderConfig.statusConfig}\n        fieldsToDisplay={detailFields}\n        onEdit={() => {\n          if (selectedItem) {\n            handleOpenEditModal(selectedItem);\n          }\n        }}\n        onDelete={handleDeleteItem}\n        isDeleting={isDeleting}\n        editButtonLabel=\"Editar\"\n        deleteButtonLabel=\"Eliminar\"\n      ></GenericDetailModal>\n    </SafeAreaView>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    centered: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: 20,\n    },\n    emptyText: {\n      textAlign: 'center',\n      fontSize: 18,\n      color: theme.colors.onSurfaceVariant,\n      marginBottom: 8,\n    },\n    errorText: {\n      color: theme.colors.error,\n      marginBottom: 10,\n      textAlign: 'center',\n    },\n    detailActionButton: {\n      marginTop: theme.spacing.m,\n      alignSelf: 'stretch',\n      borderRadius: theme.roundness,\n    },\n  });\n\nexport default ModifierGroupsScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/screens/ModifiersScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Alert' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FAB' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":6},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useMutation' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'queryClient' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":54,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'showSnackbar' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":55,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":55,"endColumn":21},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback received a function whose dependencies are unknown. Pass an inline function instead.","line":67,"column":30,"nodeType":"Identifier","endLine":67,"endColumn":41}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useLayoutEffect, useCallback, useMemo, useState } from 'react';\nimport { View, StyleSheet, Alert } from 'react-native';\nimport {\n  FAB,\n  ActivityIndicator,\n  Text,\n  Portal,\n  Button,\n} from 'react-native-paper';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useNavigation, useRoute, RouteProp } from '@react-navigation/native';\nimport { useDrawerStatus } from '@react-navigation/drawer';\n\nimport { modifierService } from '../services/modifierService';\nimport { Modifier } from '../schema/modifier.schema';\nimport { useAppTheme } from '@/app/styles/theme';\nimport { useSnackbarStore } from '@/app/store/snackbarStore';\nimport { getApiErrorMessage } from '@/app/lib/errorMapping';\nimport { debounce } from 'lodash';\nimport { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';\n\nimport ModifierFormModal from '@/modules/modifiers/components/ModifierFormModal';\nimport GenericList, {\n  RenderItemConfig,\n  FilterOption,\n} from '@/app/components/crud/GenericList';\nimport GenericDetailModal, {\n  DisplayFieldConfig,\n} from '@/app/components/crud/GenericDetailModal';\nimport { useListState } from '@/app/hooks/useListState';\n\ntype StatusFilter = 'all' | 'active' | 'inactive';\n\ntype ModifiersScreenRouteParams = {\n  groupId: string;\n  groupName: string;\n};\n\ntype ModifiersScreenRouteProp = RouteProp<\n  { params: ModifiersScreenRouteParams },\n  'params'\n>;\n\ntype NavigationProps = {\n  goBack: () => void;\n  setOptions: (options: object) => void;\n};\n\nconst ModifiersScreen = () => {\n  const theme = useAppTheme();\n  const navigation = useNavigation<NavigationProps>();\n  const route = useRoute<ModifiersScreenRouteProp>();\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n  const drawerStatus = useDrawerStatus();\n  const isDrawerOpen = drawerStatus === 'open';\n\n  const { groupId, groupName } = route.params ?? {};\n\n  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');\n\n  const QUERY_KEY = ['modifiers', groupId];\n\n  const debouncedSetSearch = useCallback(\n    debounce((query: string) => setDebouncedSearchQuery(query), 300),\n    [],\n  );\n\n  const handleSearchChange = (query: string) => {\n    setSearchQuery(query);\n    debouncedSetSearch(query);\n  };\n\n  useLayoutEffect(() => {\n    if (groupName) {\n      navigation.setOptions({\n        headerTitle: `Modificadores: ${groupName}`,\n      });\n    }\n  }, [navigation, groupName]);\n\n  const queryParams = useMemo(() => {\n    const params: Parameters<typeof modifierService.findByGroupId>[1] = {};\n    if (statusFilter !== 'all') {\n      params.isActive = statusFilter === 'active';\n    }\n    if (debouncedSearchQuery) {\n      params.search = debouncedSearchQuery;\n    }\n    return params;\n  }, [statusFilter, debouncedSearchQuery]);\n\n  const {\n    data: modifiers = [],\n    isLoading,\n    isError,\n    error,\n    refetch,\n    isRefetching,\n  } = useQuery<Modifier[], Error>({\n    queryKey: [QUERY_KEY[0], groupId, queryParams],\n    queryFn: () => modifierService.findByGroupId(groupId, queryParams),\n    enabled: !!groupId,\n  });\n\n  const {\n    isFormModalVisible,\n    isDetailModalVisible,\n    editingItem,\n    selectedItem,\n    isDeleting,\n    handleOpenCreateModal,\n    handleOpenEditModal,\n    handleOpenDetailModal,\n    handleCloseModals,\n    handleDeleteItem,\n  } = useCrudScreenLogic<Modifier>({\n    entityName: 'Modificador',\n    queryKey: QUERY_KEY,\n    deleteMutationFn: modifierService.remove,\n  });\n\n  const handleFormModalSave = () => {\n    handleCloseModals();\n  };\n\n  const handleEditFromDetails = (modifier: Modifier) => {\n    handleOpenEditModal(modifier);\n  };\n\n  const handleFilterChange = (value: StatusFilter) => {\n    setStatusFilter(value);\n  };\n\n  const styles = React.useMemo(() => createStyles(theme), [theme]);\n\n  const { ListEmptyComponent } = useListState({\n    isLoading,\n    isError,\n    data: modifiers,\n    emptyConfig: {\n      title: searchQuery\n        ? 'No se encontraron modificadores'\n        : 'No hay modificadores',\n      message: searchQuery\n        ? `No se encontraron modificadores para \"${searchQuery}\"`\n        : statusFilter !== 'all'\n          ? `No hay modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'} en este grupo.`\n          : `No hay modificadores en \"${groupName}\". Presiona el botón + para crear el primero.`,\n      icon: 'format-list-bulleted',\n    },\n  });\n\n  if (!groupId) {\n    return (\n      <View style={styles.centered}>\n        <Text style={styles.errorText}>\n          Error: No se proporcionó ID del grupo.\n        </Text>\n        <Button onPress={() => navigation.goBack()}>Volver</Button>\n      </View>\n    );\n  }\n\n  if (isLoading && !isRefetching) {\n    return <ActivityIndicator animating={true} style={styles.centered} />;\n  }\n\n  if (isError) {\n    return (\n      <View style={styles.centered}>\n        <Text style={styles.errorText}>\n          Error al cargar modificadores: {getApiErrorMessage(error)}\n        </Text>\n        <Button onPress={() => refetch()}>Reintentar</Button>\n      </View>\n    );\n  }\n\n  const listRenderConfig: RenderItemConfig<Modifier> = {\n    titleField: 'name',\n    priceField: 'price',\n    sortOrderField: 'sortOrder',\n    isDefaultField: 'isDefault',\n    statusConfig: {\n      field: 'isActive',\n      activeValue: true,\n      activeLabel: 'Activo',\n      inactiveLabel: 'Inactivo',\n    },\n  };\n\n  const detailFields: DisplayFieldConfig<Modifier>[] = [\n    {\n      field: 'price',\n      label: 'Precio Adicional',\n      render: (value) => (\n        <Text style={styles.fieldValue}>\n          {value !== null ? `$${Number(value).toFixed(2)}` : 'N/A'}\n        </Text>\n      ),\n    },\n    {\n      field: 'sortOrder',\n      label: 'Orden',\n    },\n    {\n      field: 'isDefault',\n      label: 'Por Defecto',\n    },\n  ];\n\n  const filterOptions: FilterOption<StatusFilter>[] = [\n    { value: 'all', label: 'Todos' },\n    { value: 'active', label: 'Activos' },\n    { value: 'inactive', label: 'Inactivos' },\n  ];\n\n  return (\n    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>\n      <GenericList<Modifier>\n        items={modifiers}\n        renderConfig={listRenderConfig}\n        onItemPress={handleOpenDetailModal}\n        onRefresh={refetch}\n        isRefreshing={isRefetching}\n        ListEmptyComponent={ListEmptyComponent}\n        isLoading={isLoading && !isRefetching}\n        enableSearch={true}\n        searchQuery={searchQuery}\n        onSearchChange={handleSearchChange}\n        searchPlaceholder=\"Buscar modificadores...\"\n        filterValue={statusFilter}\n        onFilterChange={handleFilterChange}\n        filterOptions={filterOptions}\n        showFab={true}\n        onFabPress={handleOpenCreateModal}\n        fabLabel=\"Añadir Modificador\"\n        isModalOpen={isFormModalVisible || isDetailModalVisible}\n        showImagePlaceholder={false}\n        isDrawerOpen={isDrawerOpen}\n      />\n\n      <Portal>\n        <ModifierFormModal\n          visible={isFormModalVisible}\n          onDismiss={handleCloseModals}\n          onSaveSuccess={handleFormModalSave}\n          initialData={editingItem}\n          groupId={groupId}\n        />\n\n        <GenericDetailModal<Modifier>\n          visible={isDetailModalVisible}\n          onDismiss={handleCloseModals}\n          item={selectedItem}\n          titleField=\"name\"\n          descriptionField=\"description\"\n          statusConfig={listRenderConfig.statusConfig}\n          fieldsToDisplay={detailFields}\n          onEdit={handleEditFromDetails}\n          onDelete={handleDeleteItem}\n          isDeleting={isDeleting}\n        />\n      </Portal>\n    </SafeAreaView>\n  );\n};\n\nconst createStyles = (theme: ReturnType<typeof useAppTheme>) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    centered: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: 20,\n    },\n    emptyText: {\n      textAlign: 'center',\n      fontSize: 18,\n      color: theme.colors.onSurfaceVariant,\n      marginBottom: 8,\n    },\n    emptySubText: {\n      textAlign: 'center',\n      fontSize: 14,\n      color: theme.colors.onSurfaceVariant,\n    },\n    errorText: {\n      color: theme.colors.error,\n      marginBottom: 10,\n      textAlign: 'center',\n    },\n    fieldValue: {\n      flexShrink: 1,\n      textAlign: 'right',\n      color: theme.colors.onSurface,\n    },\n  });\n\nexport default ModifiersScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/services/modifierGroupService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'modifierGroupsListSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":13,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import apiClient from '@/app/services/apiClient';\nimport { ApiError } from '@/app/lib/errors';\nimport { API_PATHS } from '@/app/constants/apiPaths';\nimport {\n  ModifierGroup,\n  CreateModifierGroupInput,\n  UpdateModifierGroupInput,\n  modifierGroupApiSchema,\n} from '../schema/modifierGroup.schema';\nimport { z } from 'zod';\nimport { PaginatedResponse } from '@/app/types/api.types';\n\nconst modifierGroupsListSchema = z.array(modifierGroupApiSchema);\n\n// Schema para respuesta paginada\nconst paginatedModifierGroupsSchema = z.object({\n  items: z.array(modifierGroupApiSchema),\n  total: z.number(),\n  page: z.number(),\n  limit: z.number(),\n  hasNextPage: z.boolean(),\n  hasPrevPage: z.boolean(),\n});\n\ninterface FindAllParams {\n  page?: number;\n  limit?: number;\n  isActive?: boolean;\n  search?: string;\n}\n\nexport const modifierGroupService = {\n  /**\n   * Obtiene todos los grupos de modificadores con paginación.\n   */\n  async findAll(\n    params: FindAllParams = {},\n  ): Promise<PaginatedResponse<ModifierGroup>> {\n    const queryParams = {\n      page: params.page ?? 1,\n      limit: params.limit ?? 10,\n      ...(params.isActive !== undefined && { isActive: params.isActive }),\n      ...(params.search && { search: params.search }),\n    };\n    const response = await apiClient.get<unknown>(\n      API_PATHS.MODIFIER_GROUPS,\n      queryParams,\n    );\n\n    if (!response.ok || !response.data) {\n      console.error(\n        'Error fetching modifier groups:',\n        response.problem,\n        response.data,\n      );\n      throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n    }\n\n    // Parsear como respuesta paginada\n    const paginatedResult = paginatedModifierGroupsSchema.safeParse(\n      response.data,\n    );\n    if (paginatedResult.success) {\n      // Transformar la respuesta del backend a PaginatedResponse\n      return {\n        data: paginatedResult.data.items,\n        total: paginatedResult.data.total,\n        page: paginatedResult.data.page,\n        limit: paginatedResult.data.limit,\n        totalPages: Math.ceil(\n          paginatedResult.data.total / paginatedResult.data.limit,\n        ),\n      };\n    }\n\n    console.error('Invalid data received for modifier groups:', response.data);\n    throw new Error('Received invalid data format for modifier groups.');\n  },\n\n  /**\n   * Obtiene un grupo de modificadores por su ID.\n   */\n  async findOne(id: string): Promise<ModifierGroup> {\n    const response = await apiClient.get<unknown>(\n      `${API_PATHS.MODIFIER_GROUPS}/${id}`,\n    );\n\n    if (!response.ok || !response.data) {\n      console.error(\n        `Error fetching modifier group ${id}:`,\n        response.problem,\n        response.data,\n      );\n      throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n    }\n\n    const validationResult = modifierGroupApiSchema.safeParse(response.data);\n    if (!validationResult.success) {\n      console.error(\n        `Invalid data received for modifier group ${id}:`,\n        validationResult.error.flatten(),\n      );\n      throw new Error(`Received invalid data format for modifier group ${id}.`);\n    }\n    return validationResult.data;\n  },\n\n  /**\n   * Crea un nuevo grupo de modificadores.\n   */\n  async create(data: CreateModifierGroupInput): Promise<ModifierGroup> {\n    const response = await apiClient.post<unknown>(\n      API_PATHS.MODIFIER_GROUPS,\n      data,\n    );\n\n    if (!response.ok || !response.data) {\n      console.error(\n        'Error creating modifier group:',\n        response.problem,\n        response.data,\n      );\n      throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n    }\n\n    const validationResult = modifierGroupApiSchema.safeParse(response.data);\n    if (!validationResult.success) {\n      console.error(\n        'Invalid data received after creating modifier group:',\n        validationResult.error.flatten(),\n      );\n      throw new Error(\n        'Received invalid data format after creating modifier group.',\n      );\n    }\n    return validationResult.data;\n  },\n\n  /**\n   * Actualiza un grupo de modificadores existente.\n   */\n  async update(\n    id: string,\n    data: UpdateModifierGroupInput,\n  ): Promise<ModifierGroup> {\n    const response = await apiClient.patch<unknown>(\n      `${API_PATHS.MODIFIER_GROUPS}/${id}`,\n      data,\n    );\n\n    if (!response.ok || !response.data) {\n      console.error(\n        `Error updating modifier group ${id}:`,\n        response.problem,\n        response.data,\n      );\n      throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n    }\n\n    const validationResult = modifierGroupApiSchema.safeParse(response.data);\n    if (!validationResult.success) {\n      console.error(\n        `Invalid data received after updating modifier group ${id}:`,\n        validationResult.error.flatten(),\n      );\n      throw new Error(\n        `Received invalid data format after updating modifier group ${id}.`,\n      );\n    }\n    return validationResult.data;\n  },\n\n  /**\n   * Elimina un grupo de modificadores.\n   */\n  async remove(id: string): Promise<void> {\n    const response = await apiClient.delete(\n      `${API_PATHS.MODIFIER_GROUPS}/${id}`,\n    );\n\n    if (!response.ok) {\n      console.error(\n        `Error deleting modifier group ${id}:`,\n        response.problem,\n        response.data,\n      );\n      throw ApiError.fromApiResponse(response.data, response.status ?? 500);\n    }\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/services/modifierService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/modifiers/types/modifier.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orderFinalization/components/OrderCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orderFinalization/components/OrderDetailsModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, StyleSheet, ScrollView } from 'react-native';\nimport {\n  Modal,\n  Portal,\n  Surface,\n  Text,\n  Button,\n  Divider,\n  IconButton,\n} from 'react-native-paper';\nimport {\n  OrderForFinalization,\n  OrderItemForFinalization,\n} from '../types/orderFinalization.types';\nimport { useAppTheme } from '@/app/styles/theme';\n\ninterface OrderDetailsModalProps {\n  visible: boolean;\n  onDismiss: () => void;\n  order: OrderForFinalization | null;\n}\n\ninterface GroupedItem {\n  item: OrderItemForFinalization;\n  quantity: number;\n}\n\nexport const OrderDetailsModal: React.FC<OrderDetailsModalProps> = ({\n  visible,\n  onDismiss,\n  order,\n}) => {\n  const theme = useAppTheme();\n\n  // Agrupar items idénticos\n  const groupedItems = React.useMemo(() => {\n    if (!order) return [];\n\n    const groups = new Map<string, GroupedItem>();\n\n    order.orderItems.forEach((item) => {\n      // Crear una clave única basada en producto, variante y modificadores\n      const modifierKeys =\n        item.modifiers && item.modifiers.length > 0\n          ? item.modifiers\n              .map((m) => m.id)\n              .sort()\n              .join(',')\n          : '';\n      const key = `${item.product.id}-${item.productVariant?.id || ''}-${modifierKeys}-${item.preparationNotes || ''}`;\n\n      if (groups.has(key)) {\n        const existing = groups.get(key)!;\n        existing.quantity += item.quantity;\n      } else {\n        groups.set(key, { item, quantity: item.quantity });\n      }\n    });\n\n    return Array.from(groups.values());\n  }, [order]);\n\n  const totalItems =\n    order?.orderItems.reduce((sum, item) => sum + item.quantity, 0) || 0;\n\n  if (!order) return null;\n\n  const renderGroupedItem = ({ item, quantity }: GroupedItem) => {\n    const itemTotal = parseFloat(item.finalPrice) * quantity;\n\n    return (\n      <Surface\n        key={`${item.id}-${quantity}`}\n        style={styles.itemCard}\n        elevation={0}\n      >\n        <View style={styles.itemHeader}>\n          <View style={styles.itemInfo}>\n            <Text style={[styles.itemName, { color: theme.colors.onSurface }]}>\n              {quantity}x {item.product.name}\n            </Text>\n            {item.productVariant && (\n              <Text\n                style={[\n                  styles.variantText,\n                  { color: theme.colors.onSurfaceVariant },\n                ]}\n              >\n                {item.productVariant.name}\n              </Text>\n            )}\n          </View>\n          <Text style={[styles.itemPrice, { color: theme.colors.primary }]}>\n            ${itemTotal.toFixed(2)}\n          </Text>\n        </View>\n\n        {item.modifiers && item.modifiers.length > 0 && (\n          <View style={styles.modifiers}>\n            {item.modifiers.map((modifier) => (\n              <Text\n                key={modifier.id}\n                style={[\n                  styles.modifierText,\n                  { color: theme.colors.onSurfaceVariant },\n                ]}\n              >\n                + {modifier.name} ($\n                {(typeof modifier.price === 'string'\n                  ? parseFloat(modifier.price)\n                  : modifier.price\n                ).toFixed(2)}\n                )\n              </Text>\n            ))}\n          </View>\n        )}\n\n        {item.preparationNotes && (\n          <View style={styles.notes}>\n            <Text\n              style={[\n                styles.notesLabel,\n                { color: theme.colors.onSurfaceVariant },\n              ]}\n            >\n              Notas:\n            </Text>\n            <Text\n              style={[\n                styles.notesText,\n                { color: theme.colors.onSurfaceVariant },\n              ]}\n            >\n              {item.preparationNotes}\n            </Text>\n          </View>\n        )}\n      </Surface>\n    );\n  };\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible}\n        onDismiss={onDismiss}\n        contentContainerStyle={[\n          styles.modalContent,\n          { backgroundColor: theme.colors.background },\n        ]}\n      >\n        <View style={styles.header}>\n          <View>\n            <Text style={[styles.title, { color: theme.colors.onSurface }]}>\n              Orden #{order.dailyNumber}\n            </Text>\n            <Text\n              style={[\n                styles.subtitle,\n                { color: theme.colors.onSurfaceVariant },\n              ]}\n            >\n              {totalItems} {totalItems === 1 ? 'artículo' : 'artículos'}\n            </Text>\n          </View>\n          <IconButton\n            icon=\"close\"\n            size={24}\n            onPress={onDismiss}\n            style={styles.closeButton}\n          />\n        </View>\n\n        <Divider />\n\n        <ScrollView\n          style={styles.scrollView}\n          showsVerticalScrollIndicator={false}\n        >\n          <View style={styles.itemsList}>\n            {groupedItems.map((groupedItem) => renderGroupedItem(groupedItem))}\n          </View>\n        </ScrollView>\n\n        <Divider />\n\n        <View style={styles.footer}>\n          <Text style={[styles.totalLabel, { color: theme.colors.onSurface }]}>\n            Total:\n          </Text>\n          <Text style={[styles.totalAmount, { color: theme.colors.primary }]}>\n            $\n            {typeof order.total === 'string'\n              ? parseFloat(order.total).toFixed(2)\n              : order.total.toFixed(2)}\n          </Text>\n        </View>\n      </Modal>\n    </Portal>\n  );\n};\n\nconst styles = StyleSheet.create({\n  modalContent: {\n    margin: 20,\n    borderRadius: 12,\n    maxHeight: '80%',\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'flex-start',\n    paddingHorizontal: 20,\n    paddingTop: 20,\n    paddingBottom: 12,\n  },\n  closeButton: {\n    margin: -8,\n  },\n  title: {\n    fontSize: 20,\n    fontWeight: '600',\n  },\n  subtitle: {\n    fontSize: 14,\n    marginTop: 2,\n  },\n  scrollView: {\n    maxHeight: 400,\n  },\n  itemsList: {\n    padding: 20,\n    gap: 12,\n  },\n  itemCard: {\n    padding: 12,\n    borderRadius: 8,\n    marginBottom: 8,\n  },\n  itemHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'flex-start',\n  },\n  itemInfo: {\n    flex: 1,\n    marginRight: 12,\n  },\n  itemName: {\n    fontSize: 14,\n    fontWeight: '500',\n  },\n  variantText: {\n    fontSize: 12,\n    marginTop: 2,\n  },\n  itemPrice: {\n    fontSize: 14,\n    fontWeight: '600',\n  },\n  modifiers: {\n    marginTop: 6,\n    paddingLeft: 16,\n  },\n  modifierText: {\n    fontSize: 11,\n    marginTop: 2,\n  },\n  notes: {\n    marginTop: 6,\n    padding: 8,\n    backgroundColor: 'rgba(0,0,0,0.03)',\n    borderRadius: 4,\n  },\n  notesLabel: {\n    fontSize: 10,\n    fontWeight: '600',\n    marginBottom: 2,\n  },\n  notesText: {\n    fontSize: 11,\n  },\n  footer: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingHorizontal: 20,\n    paddingVertical: 16,\n  },\n  totalLabel: {\n    fontSize: 16,\n    fontWeight: '500',\n  },\n  totalAmount: {\n    fontSize: 20,\n    fontWeight: '700',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orderFinalization/hooks/useOrderFinalizationQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orderFinalization/navigation/OrderFinalizationStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orderFinalization/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orderFinalization/screens/OrderFinalizationScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":47,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":10}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo, useCallback, useEffect } from 'react';\nimport { View, StyleSheet, FlatList } from 'react-native';\nimport {\n  Surface,\n  Text,\n  SegmentedButtons,\n  Button,\n  ActivityIndicator,\n  Portal,\n  Dialog,\n  TextInput,\n  RadioButton,\n  IconButton,\n} from 'react-native-paper';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { OrderCard } from '../components/OrderCard';\nimport { OrderDetailsModal } from '../components/OrderDetailsModal';\nimport {\n  useOrdersForFinalization,\n  useFinalizeOrders,\n} from '../hooks/useOrderFinalizationQueries';\nimport {\n  OrderFinalizationFilter,\n  OrderSelectionState,\n  OrderForFinalization,\n} from '../types/orderFinalization.types';\nimport EmptyState from '@/app/components/common/EmptyState';\nimport { useAppTheme } from '@/app/styles/theme';\n\nexport const OrderFinalizationScreen: React.FC = () => {\n  const theme = useAppTheme();\n  const [filter, setFilter] = useState<OrderFinalizationFilter>('takeout');\n  const [selectionState, setSelectionState] = useState<OrderSelectionState>({\n    selectedOrders: new Set(),\n    totalAmount: 0,\n  });\n  const [showFinalizeDialog, setShowFinalizeDialog] = useState(false);\n  const [paymentMethod, setPaymentMethod] = useState('cash');\n  const [notes, setNotes] = useState('');\n  const [selectedOrderForDetails, setSelectedOrderForDetails] =\n    useState<OrderForFinalization | null>(null);\n\n  const {\n    data: orders = [],\n    isLoading,\n    refetch,\n    error,\n  } = useOrdersForFinalization();\n\n  // Debug removido - la funcionalidad está funcionando correctamente\n\n  const finalizeOrdersMutation = useFinalizeOrders();\n\n  // Filtrar órdenes según el filtro seleccionado\n  const filteredOrders = useMemo(() => {\n    return orders.filter((order) => {\n      if (filter === 'takeout')\n        return order.orderType === 'TAKEOUT' || order.orderType === 'DELIVERY';\n      return order.orderType === 'DINE_IN';\n    });\n  }, [orders, filter]);\n\n  // Limpiar selección cuando cambia el filtro\n  useEffect(() => {\n    setSelectionState({\n      selectedOrders: new Set(),\n      totalAmount: 0,\n    });\n  }, [filter]);\n\n  // Ya no necesitamos agrupar porque filtramos desde el inicio\n\n  const handleToggleOrderSelection = useCallback(\n    (orderId: string) => {\n      const order = orders.find((o) => o.id === orderId);\n      if (!order) return;\n\n      setSelectionState((prevState) => {\n        const newSelectedOrders = new Set(prevState.selectedOrders);\n        let newTotalAmount = prevState.totalAmount;\n        const orderTotal =\n          typeof order.total === 'string'\n            ? parseFloat(order.total)\n            : order.total;\n\n        if (newSelectedOrders.has(orderId)) {\n          newSelectedOrders.delete(orderId);\n          newTotalAmount -= orderTotal;\n        } else {\n          newSelectedOrders.add(orderId);\n          newTotalAmount += orderTotal;\n        }\n\n        return {\n          selectedOrders: newSelectedOrders,\n          totalAmount: newTotalAmount,\n        };\n      });\n    },\n    [orders],\n  );\n\n  const handleFinalizeOrders = useCallback(async () => {\n    if (selectionState.selectedOrders.size === 0) return;\n\n    await finalizeOrdersMutation.mutateAsync({\n      orderIds: Array.from(selectionState.selectedOrders),\n      paymentMethod,\n      notes: notes.trim() || undefined,\n    });\n\n    // Limpiar selección\n    setSelectionState({\n      selectedOrders: new Set(),\n      totalAmount: 0,\n    });\n    setShowFinalizeDialog(false);\n    setNotes('');\n    setPaymentMethod('cash');\n  }, [selectionState, paymentMethod, notes, finalizeOrdersMutation]);\n\n  const handleShowOrderDetails = useCallback((order: OrderForFinalization) => {\n    setSelectedOrderForDetails(order);\n  }, []);\n\n  const renderOrderCard = useCallback(\n    ({ item }) => (\n      <OrderCard\n        order={item}\n        isSelected={selectionState.selectedOrders.has(item.id)}\n        onToggleSelection={handleToggleOrderSelection}\n        onShowDetails={handleShowOrderDetails}\n      />\n    ),\n    [\n      selectionState.selectedOrders,\n      handleToggleOrderSelection,\n      handleShowOrderDetails,\n    ],\n  );\n\n  if (isLoading) {\n    return (\n      <View style={styles.loadingContainer}>\n        <ActivityIndicator size=\"large\" color={theme.colors.primary} />\n        <Text\n          style={[styles.loadingText, { color: theme.colors.onSurfaceVariant }]}\n        >\n          Cargando órdenes...\n        </Text>\n      </View>\n    );\n  }\n\n  return (\n    <SafeAreaView\n      style={[styles.container, { backgroundColor: theme.colors.background }]}\n      edges={['top']}\n    >\n      <Surface style={styles.header} elevation={2}>\n        <View style={styles.headerContent}>\n          <SegmentedButtons\n            value={filter}\n            onValueChange={setFilter as any}\n            buttons={[\n              { value: 'takeout', label: 'Para llevar', icon: 'bag-personal' },\n              {\n                value: 'dine_in',\n                label: 'Mesa',\n                icon: 'silverware-fork-knife',\n              },\n            ]}\n            style={styles.segmentedButtons}\n          />\n          <IconButton\n            icon=\"refresh\"\n            mode=\"contained-tonal\"\n            size={28}\n            onPress={() => refetch()}\n            loading={isLoading}\n            style={styles.refreshButton}\n            iconColor={theme.colors.primary}\n          />\n        </View>\n      </Surface>\n\n      <View style={styles.content}>\n        {filteredOrders.length === 0 ? (\n          <EmptyState\n            title=\"No hay órdenes para finalizar\"\n            description=\"Las órdenes aparecerán aquí cuando estén listas para finalizar\"\n            icon=\"clipboard-check-outline\"\n          />\n        ) : (\n          <FlatList\n            data={filteredOrders}\n            keyExtractor={(item) => item.id}\n            renderItem={renderOrderCard}\n            contentContainerStyle={styles.listContent}\n            showsVerticalScrollIndicator={false}\n            ItemSeparatorComponent={() => <View style={{ height: 8 }} />}\n            onRefresh={refetch}\n            refreshing={isLoading}\n          />\n        )}\n      </View>\n\n      {/* Botón flotante para finalizar */}\n      {selectionState.selectedOrders.size > 0 && (\n        <Surface style={styles.floatingButton} elevation={8}>\n          <Button\n            mode=\"contained\"\n            onPress={() => setShowFinalizeDialog(true)}\n            loading={finalizeOrdersMutation.isPending}\n            style={styles.finalizeButton}\n            labelStyle={styles.finalizeButtonLabel}\n          >\n            Finalizar ({selectionState.selectedOrders.size}) - $\n            {(selectionState.totalAmount || 0).toFixed(2)}\n          </Button>\n        </Surface>\n      )}\n\n      {/* Dialog de finalización */}\n      <Portal>\n        <Dialog\n          visible={showFinalizeDialog}\n          onDismiss={() => setShowFinalizeDialog(false)}\n        >\n          <Dialog.Title>Finalizar Órdenes</Dialog.Title>\n          <Dialog.Content>\n            <Text style={{ marginBottom: 16 }}>\n              ¿Finalizar {selectionState.selectedOrders.size}{' '}\n              {selectionState.selectedOrders.size === 1 ? 'orden' : 'órdenes'}{' '}\n              por un total de ${(selectionState.totalAmount || 0).toFixed(2)}?\n            </Text>\n\n            <Text style={{ marginBottom: 8, fontWeight: '600' }}>\n              Método de pago:\n            </Text>\n            <RadioButton.Group\n              onValueChange={setPaymentMethod}\n              value={paymentMethod}\n            >\n              <View\n                style={{\n                  flexDirection: 'row',\n                  alignItems: 'center',\n                  marginBottom: 8,\n                }}\n              >\n                <RadioButton value=\"cash\" />\n                <Text>Efectivo</Text>\n              </View>\n              <View\n                style={{\n                  flexDirection: 'row',\n                  alignItems: 'center',\n                  marginBottom: 8,\n                }}\n              >\n                <RadioButton value=\"card\" />\n                <Text>Tarjeta</Text>\n              </View>\n              <View\n                style={{\n                  flexDirection: 'row',\n                  alignItems: 'center',\n                  marginBottom: 16,\n                }}\n              >\n                <RadioButton value=\"transfer\" />\n                <Text>Transferencia</Text>\n              </View>\n            </RadioButton.Group>\n\n            <TextInput\n              label=\"Notas (opcional)\"\n              value={notes}\n              onChangeText={setNotes}\n              multiline\n              numberOfLines={3}\n              mode=\"outlined\"\n            />\n          </Dialog.Content>\n          <Dialog.Actions>\n            <Button onPress={() => setShowFinalizeDialog(false)}>\n              Cancelar\n            </Button>\n            <Button\n              mode=\"contained\"\n              onPress={handleFinalizeOrders}\n              loading={finalizeOrdersMutation.isPending}\n            >\n              Confirmar\n            </Button>\n          </Dialog.Actions>\n        </Dialog>\n      </Portal>\n\n      {/* Modal de detalles de orden */}\n      <OrderDetailsModal\n        visible={selectedOrderForDetails !== null}\n        onDismiss={() => setSelectedOrderForDetails(null)}\n        order={selectedOrderForDetails}\n      />\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomLeftRadius: 24,\n    borderBottomRightRadius: 24,\n  },\n  headerContent: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 12,\n  },\n  segmentedButtons: {\n    flex: 1,\n  },\n  refreshButton: {\n    margin: 0,\n  },\n  floatingButton: {\n    position: 'absolute',\n    bottom: 16,\n    left: 16,\n    right: 16,\n    borderRadius: 12,\n    padding: 8,\n  },\n  finalizeButton: {\n    borderRadius: 8,\n  },\n  finalizeButtonLabel: {\n    fontSize: 14,\n    fontWeight: '600',\n  },\n  content: {\n    flex: 1,\n  },\n  loadingContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  loadingText: {\n    marginTop: 12,\n    fontSize: 14,\n  },\n  listContent: {\n    paddingVertical: 8,\n    paddingBottom: 80, // Espacio para el botón flotante\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orderFinalization/services/orderFinalizationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orderFinalization/types/orderFinalization.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/AdjustmentFormModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Platform' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Icon' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":7}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { View, ScrollView, StyleSheet, Platform } from 'react-native';\nimport {\n  Modal,\n  Portal,\n  Text,\n  Button,\n  TextInput,\n  HelperText,\n  Chip,\n  IconButton,\n  Icon,\n} from 'react-native-paper';\nimport { useAppTheme } from '@/app/styles/theme';\nimport type {\n  OrderAdjustment,\n  AdjustmentFormData,\n} from '../types/adjustments.types';\n\ninterface AdjustmentFormModalProps {\n  visible: boolean;\n  onDismiss: () => void;\n  onSave: (adjustment: OrderAdjustment) => void;\n  adjustment?: OrderAdjustment | null;\n  orderSubtotal: number;\n}\n\nexport const AdjustmentFormModal: React.FC<AdjustmentFormModalProps> = ({\n  visible,\n  onDismiss,\n  onSave,\n  adjustment,\n  orderSubtotal,\n}) => {\n  const theme = useAppTheme();\n\n  // Estado del formulario\n  const [formData, setFormData] = useState<AdjustmentFormData>({\n    name: '',\n    isPercentage: true,\n    value: 0,\n    amount: 0,\n  });\n\n  // Estados separados para los campos de texto\n  const [percentageText, setPercentageText] = useState('');\n  const [amountText, setAmountText] = useState('');\n  const [isDiscount, setIsDiscount] = useState(false);\n  const [nameWasEdited, setNameWasEdited] = useState(false);\n\n  const [errors, setErrors] = useState<{\n    name?: string;\n    value?: string;\n    amount?: string;\n  }>({});\n\n  // Inicializar formulario cuando se abre o cambia el ajuste\n  useEffect(() => {\n    if (visible) {\n      if (adjustment) {\n        setFormData({\n          name: adjustment.name,\n          isPercentage: adjustment.isPercentage,\n          value: adjustment.value || 0,\n          amount: adjustment.amount || 0,\n        });\n        setPercentageText(Math.abs(adjustment.value || 0).toString());\n        setAmountText(Math.abs(adjustment.amount || 0).toString());\n        setIsDiscount((adjustment.value || adjustment.amount || 0) < 0);\n        setNameWasEdited(true); // Si es edición, asumimos que el nombre fue editado\n      } else {\n        setFormData({\n          name: 'Cargo adicional', // Por defecto cargo\n          isPercentage: true,\n          value: 0,\n          amount: 0,\n        });\n        setPercentageText('');\n        setAmountText('');\n        setIsDiscount(false);\n        setNameWasEdited(false);\n      }\n      setErrors({});\n    }\n  }, [visible, adjustment]);\n\n  // Calcular el monto cuando cambia el valor o tipo\n  useEffect(() => {\n    if (formData.isPercentage && formData.value !== undefined) {\n      const calculatedAmount = (orderSubtotal * formData.value) / 100;\n      setFormData((prev) => ({ ...prev, amount: calculatedAmount }));\n    }\n  }, [formData.isPercentage, formData.value, orderSubtotal]);\n\n  const handleTypeChange = (isPercentage: boolean) => {\n    setFormData((prev) => ({\n      ...prev,\n      isPercentage,\n      value: isPercentage ? 0 : undefined,\n      amount: isPercentage ? 0 : prev.amount,\n    }));\n    if (isPercentage) {\n      setPercentageText('');\n    } else {\n      setAmountText('');\n    }\n  };\n\n  const validateForm = (): boolean => {\n    const newErrors: typeof errors = {};\n\n    if (!formData.name.trim()) {\n      newErrors.name = 'El nombre es requerido';\n    }\n\n    if (formData.isPercentage) {\n      if (formData.value === undefined || formData.value === null) {\n        newErrors.value = 'El porcentaje es requerido';\n      } else if (formData.value === 0) {\n        newErrors.value = 'El porcentaje no puede ser 0';\n      } else if (formData.value < -100 || formData.value > 100) {\n        newErrors.value = 'El porcentaje debe estar entre -100 y 100';\n      }\n    } else {\n      if (formData.amount === undefined || formData.amount === null) {\n        newErrors.amount = 'El monto es requerido';\n      } else if (formData.amount === 0) {\n        newErrors.amount = 'El monto no puede ser 0';\n      }\n    }\n\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSave = () => {\n    if (!validateForm()) return;\n\n    const adjustmentData: OrderAdjustment = {\n      id: adjustment?.id || undefined,\n      name: formData.name.trim(),\n      isPercentage: formData.isPercentage,\n      value: formData.isPercentage ? formData.value : undefined,\n      amount: formData.amount,\n      isNew: !adjustment?.id,\n    };\n\n    onSave(adjustmentData);\n    onDismiss();\n  };\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible}\n        onDismiss={onDismiss}\n        contentContainerStyle={[\n          styles.modal,\n          { backgroundColor: theme.colors.surface },\n        ]}\n      >\n        {/* Header simplificado */}\n        <View\n          style={[styles.header, { backgroundColor: theme.colors.primary }]}\n        >\n          <Text\n            variant=\"titleLarge\"\n            style={[styles.title, { color: theme.colors.onPrimary }]}\n          >\n            {adjustment ? 'Editar Ajuste' : 'Nuevo Ajuste'}\n          </Text>\n          <IconButton\n            icon=\"close\"\n            size={20}\n            onPress={onDismiss}\n            style={styles.closeButton}\n            iconColor={theme.colors.onPrimary}\n          />\n        </View>\n\n        {/* Contenido */}\n        <View style={styles.content}>\n          {/* Nombre del ajuste */}\n          <TextInput\n            label=\"Nombre\"\n            value={formData.name}\n            onChangeText={(text) => {\n              setFormData((prev) => ({ ...prev, name: text }));\n              // Detectar si el usuario editó manualmente el nombre\n              setNameWasEdited(\n                text !== 'Descuento' && text !== 'Cargo adicional',\n              );\n            }}\n            mode=\"outlined\"\n            error={!!errors.name}\n            placeholder=\"Ej: Descuento especial\"\n            style={styles.input}\n          />\n          {errors.name && (\n            <HelperText type=\"error\" visible={true}>\n              {errors.name}\n            </HelperText>\n          )}\n\n          {/* Tipo de ajuste con chips */}\n          <View style={styles.typeContainer}>\n            <Text\n              variant=\"labelLarge\"\n              style={[styles.label, { color: theme.colors.onSurface }]}\n            >\n              Tipo de ajuste\n            </Text>\n            <View style={styles.chipGroup}>\n              <Chip\n                mode={formData.isPercentage ? 'flat' : 'outlined'}\n                onPress={() => handleTypeChange(true)}\n                selected={formData.isPercentage}\n                style={[\n                  styles.chip,\n                  formData.isPercentage && {\n                    backgroundColor: theme.colors.primaryContainer,\n                  },\n                ]}\n                textStyle={\n                  formData.isPercentage && {\n                    color: theme.colors.onPrimaryContainer,\n                  }\n                }\n              >\n                Porcentaje\n              </Chip>\n              <Chip\n                mode={!formData.isPercentage ? 'flat' : 'outlined'}\n                onPress={() => handleTypeChange(false)}\n                selected={!formData.isPercentage}\n                style={[\n                  styles.chip,\n                  !formData.isPercentage && {\n                    backgroundColor: theme.colors.primaryContainer,\n                  },\n                ]}\n                textStyle={\n                  !formData.isPercentage && {\n                    color: theme.colors.onPrimaryContainer,\n                  }\n                }\n              >\n                Monto fijo\n              </Chip>\n            </View>\n          </View>\n\n          {/* Tipo de operación (descuento o cargo) */}\n          <View style={styles.operationContainer}>\n            <Text\n              variant=\"labelLarge\"\n              style={[styles.label, { color: theme.colors.onSurface }]}\n            >\n              Tipo de operación\n            </Text>\n            <View style={styles.operationButtons}>\n              <Button\n                mode={isDiscount ? 'contained' : 'outlined'}\n                onPress={() => {\n                  setIsDiscount(true);\n                  // Siempre actualizar el nombre si no fue editado manualmente\n                  if (!nameWasEdited) {\n                    setFormData((prev) => ({ ...prev, name: 'Descuento' }));\n                  }\n                  if (formData.isPercentage) {\n                    const absValue = Math.abs(parseFloat(percentageText) || 0);\n                    setFormData((prev) => ({ ...prev, value: -absValue }));\n                  } else {\n                    const absValue = Math.abs(parseFloat(amountText) || 0);\n                    setFormData((prev) => ({ ...prev, amount: -absValue }));\n                  }\n                }}\n                style={[\n                  styles.operationButton,\n                  isDiscount && {\n                    backgroundColor: theme.colors.errorContainer,\n                    borderColor: theme.colors.error,\n                  },\n                ]}\n                labelStyle={{\n                  color: isDiscount\n                    ? theme.colors.onErrorContainer\n                    : theme.colors.error,\n                }}\n                icon=\"minus\"\n              >\n                Descuento\n              </Button>\n              <Button\n                mode={!isDiscount ? 'contained' : 'outlined'}\n                onPress={() => {\n                  setIsDiscount(false);\n                  // Siempre actualizar el nombre si no fue editado manualmente\n                  if (!nameWasEdited) {\n                    setFormData((prev) => ({\n                      ...prev,\n                      name: 'Cargo adicional',\n                    }));\n                  }\n                  if (formData.isPercentage) {\n                    const absValue = Math.abs(parseFloat(percentageText) || 0);\n                    setFormData((prev) => ({ ...prev, value: absValue }));\n                  } else {\n                    const absValue = Math.abs(parseFloat(amountText) || 0);\n                    setFormData((prev) => ({ ...prev, amount: absValue }));\n                  }\n                }}\n                style={[\n                  styles.operationButton,\n                  !isDiscount && {\n                    backgroundColor: theme.colors.primaryContainer,\n                    borderColor: theme.colors.primary,\n                  },\n                ]}\n                labelStyle={{\n                  color: !isDiscount\n                    ? theme.colors.onPrimaryContainer\n                    : theme.colors.primary,\n                }}\n                icon=\"plus\"\n              >\n                Cargo\n              </Button>\n            </View>\n          </View>\n\n          {/* Campo de valor */}\n          {formData.isPercentage ? (\n            <TextInput\n              label=\"Porcentaje\"\n              value={percentageText}\n              onChangeText={(text) => {\n                // Solo permitir números positivos\n                const regex = /^\\d*\\.?\\d*$/;\n                if (regex.test(text) || text === '') {\n                  setPercentageText(text);\n                  const value = parseFloat(text) || 0;\n                  setFormData((prev) => ({\n                    ...prev,\n                    value: isDiscount ? -value : value,\n                  }));\n                }\n              }}\n              mode=\"outlined\"\n              keyboardType=\"numeric\"\n              error={!!errors.value}\n              right={<TextInput.Affix text=\"%\" />}\n              style={styles.input}\n            />\n          ) : (\n            <TextInput\n              label=\"Monto\"\n              value={amountText}\n              onChangeText={(text) => {\n                // Solo permitir números positivos\n                const regex = /^\\d*\\.?\\d*$/;\n                if (regex.test(text) || text === '') {\n                  setAmountText(text);\n                  const amount = parseFloat(text) || 0;\n                  setFormData((prev) => ({\n                    ...prev,\n                    amount: isDiscount ? -amount : amount,\n                  }));\n                }\n              }}\n              mode=\"outlined\"\n              keyboardType=\"numeric\"\n              error={!!errors.amount}\n              left={<TextInput.Affix text=\"$\" />}\n              style={styles.input}\n            />\n          )}\n          {(errors.value || errors.amount) && (\n            <HelperText type=\"error\" visible={true}>\n              {errors.value || errors.amount}\n            </HelperText>\n          )}\n        </View>\n\n        {/* Botones de acción */}\n        <View\n          style={[\n            styles.actions,\n            { borderTopColor: theme.colors.outlineVariant },\n          ]}\n        >\n          <Button\n            mode=\"outlined\"\n            onPress={onDismiss}\n            style={[\n              styles.actionButton,\n              {\n                borderColor: theme.colors.outline,\n                backgroundColor: theme.colors.secondaryContainer,\n              },\n            ]}\n            textColor={theme.colors.onSecondaryContainer}\n          >\n            Cancelar\n          </Button>\n          <Button\n            mode=\"contained\"\n            onPress={handleSave}\n            style={[styles.actionButton, styles.saveButton]}\n            buttonColor={theme.colors.primary}\n          >\n            {adjustment ? 'Actualizar' : 'Guardar'}\n          </Button>\n        </View>\n      </Modal>\n    </Portal>\n  );\n};\n\nconst styles = StyleSheet.create({\n  modal: {\n    borderRadius: 16,\n    margin: 20,\n    maxWidth: 400,\n    width: '90%',\n    maxHeight: '80%',\n    alignSelf: 'center',\n    elevation: 5,\n    shadowColor: '#000',\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.25,\n    shadowRadius: 3.84,\n    overflow: 'hidden',\n  },\n  header: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    minHeight: 48,\n  },\n  title: {\n    flex: 1,\n    fontWeight: '500',\n  },\n  closeButton: {\n    margin: -4,\n  },\n  content: {\n    paddingHorizontal: 20,\n    paddingTop: 20,\n    paddingBottom: 16,\n  },\n  input: {\n    marginBottom: 16,\n  },\n  typeContainer: {\n    marginBottom: 16,\n  },\n  label: {\n    marginBottom: 8,\n    fontWeight: '500',\n  },\n  chipGroup: {\n    flexDirection: 'row',\n    gap: 12,\n  },\n  chip: {\n    flex: 1,\n  },\n  operationContainer: {\n    marginBottom: 16,\n  },\n  operationButtons: {\n    flexDirection: 'row',\n    gap: 12,\n    marginTop: 8,\n  },\n  operationButton: {\n    flex: 1,\n  },\n  actions: {\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: 20,\n    paddingVertical: 16,\n    borderTopWidth: 1,\n    gap: 12,\n  },\n  actionButton: {\n    minWidth: 100,\n  },\n  saveButton: {\n    marginLeft: 4,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/CartButton.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useState' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":33}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useState, useCallback } from 'react';\nimport { StyleSheet, View, Animated } from 'react-native';\nimport { IconButton, Badge, useTheme } from 'react-native-paper';\n\ninterface CartButtonProps {\n  itemCount: number;\n  onPress: () => void;\n}\n\nconst CartButton = React.forwardRef(\n  ({ itemCount, onPress }: CartButtonProps, ref) => {\n    const theme = useTheme();\n    const cartBadgeScale = useRef(new Animated.Value(1)).current;\n    const cartBounceAnimation = useRef(new Animated.Value(1)).current;\n    const isPressedRef = useRef(false);\n\n    const styles = StyleSheet.create({\n      cartButton: {\n        margin: 0,\n        backgroundColor: theme.colors.surfaceVariant,\n      },\n      cartBadge: {\n        position: 'absolute',\n        top: 0,\n        right: 0,\n        backgroundColor: theme.colors.error,\n      },\n    });\n\n    const animateCartButton = () => {\n      Animated.sequence([\n        Animated.timing(cartBounceAnimation, {\n          toValue: 1.3,\n          duration: 200,\n          useNativeDriver: true,\n        }),\n        Animated.timing(cartBounceAnimation, {\n          toValue: 1,\n          duration: 200,\n          useNativeDriver: true,\n        }),\n      ]).start();\n\n      Animated.sequence([\n        Animated.timing(cartBadgeScale, {\n          toValue: 1.6,\n          duration: 200,\n          useNativeDriver: true,\n        }),\n        Animated.timing(cartBadgeScale, {\n          toValue: 1,\n          duration: 200,\n          useNativeDriver: true,\n        }),\n      ]).start();\n    };\n\n    React.useImperativeHandle(ref, () => ({\n      animate: animateCartButton,\n    }));\n\n    const handlePress = useCallback(() => {\n      if (isPressedRef.current) return; // Prevenir múltiples clics\n\n      isPressedRef.current = true;\n      onPress();\n\n      // Re-habilitar después de 150ms\n      setTimeout(() => {\n        isPressedRef.current = false;\n      }, 150);\n    }, [onPress]);\n\n    return (\n      <View>\n        <Animated.View style={{ transform: [{ scale: cartBounceAnimation }] }}>\n          <IconButton\n            icon=\"cart-outline\"\n            iconColor={theme.colors.primary}\n            size={30}\n            onPress={handlePress}\n            style={styles.cartButton}\n          />\n        </Animated.View>\n        {itemCount > 0 && (\n          <Animated.View\n            style={{\n              transform: [{ scale: cartBadgeScale }],\n              position: 'absolute',\n              top: 0,\n              right: 0,\n            }}\n          >\n            <Badge style={styles.cartBadge} size={22}>\n              {itemCount}\n            </Badge>\n          </Animated.View>\n        )}\n      </View>\n    );\n  },\n);\n\nexport default CartButton;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/ChangeCalculatorModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Surface' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IconButton' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":13}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo } from 'react';\nimport { View, StyleSheet, Pressable } from 'react-native';\nimport {\n  Modal,\n  Portal,\n  Text,\n  Button,\n  TextInput,\n  Surface,\n  IconButton,\n} from 'react-native-paper';\nimport { useAppTheme, AppTheme } from '@/app/styles/theme';\n\ninterface ChangeCalculatorModalProps {\n  visible: boolean;\n  onDismiss: () => void;\n  onConfirm: () => void;\n  amountToPay: number;\n}\n\nexport const ChangeCalculatorModal: React.FC<ChangeCalculatorModalProps> = ({\n  visible,\n  onDismiss,\n  onConfirm,\n  amountToPay,\n}) => {\n  const theme = useAppTheme();\n  const styles = useMemo(() => createStyles(theme), [theme]);\n\n  const [receivedAmount, setReceivedAmount] = useState('');\n\n  // Calcular cambio\n  const changeAmount = useMemo(() => {\n    const received = parseFloat(receivedAmount);\n    if (isNaN(received)) return 0;\n    return Math.max(0, received - amountToPay);\n  }, [receivedAmount, amountToPay]);\n\n  // Determinar qué botones de billetes mostrar\n  const availableBills = useMemo(() => {\n    const bills = [50, 100, 200, 500, 1000];\n    // Filtrar billetes que sean mayores o iguales al monto a pagar\n    const validBills = bills.filter((bill) => bill >= amountToPay);\n    // Tomar máximo 4 opciones para que quepan en una línea\n    return validBills.slice(0, 4);\n  }, [amountToPay]);\n\n  // Resetear cuando se abre\n  useEffect(() => {\n    if (visible) {\n      setReceivedAmount(amountToPay.toFixed(2));\n    }\n  }, [visible, amountToPay]);\n\n  const handleConfirm = () => {\n    const received = parseFloat(receivedAmount);\n    if (!isNaN(received) && received >= amountToPay) {\n      onConfirm();\n    }\n  };\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible}\n        onDismiss={onDismiss}\n        contentContainerStyle={styles.modalContainer}\n      >\n        <Pressable style={styles.modalContent}>\n          <View style={styles.content}>\n            {/* Inputs en línea */}\n            <View style={styles.inputsRow}>\n              {/* Total a pagar */}\n              <View style={styles.inputContainer}>\n                <Text style={styles.inputLabel}>Total a pagar</Text>\n                <TextInput\n                  value={`$${amountToPay.toFixed(2)}`}\n                  editable={false}\n                  mode=\"flat\"\n                  style={styles.totalInput}\n                  dense\n                  theme={{\n                    colors: {\n                      primary: theme.colors.primary,\n                      background: 'rgba(255, 255, 255, 0.05)',\n                      text: theme.dark ? '#FFFFFF' : '#000000',\n                    },\n                  }}\n                />\n              </View>\n\n              {/* Monto recibido */}\n              <View style={styles.inputContainer}>\n                <Text style={styles.inputLabel}>Monto recibido</Text>\n                <TextInput\n                  value={receivedAmount}\n                  onChangeText={setReceivedAmount}\n                  keyboardType=\"decimal-pad\"\n                  mode=\"flat\"\n                  left={<TextInput.Affix text=\"$\" />}\n                  style={styles.receivedInput}\n                  error={\n                    receivedAmount !== '' &&\n                    (isNaN(parseFloat(receivedAmount)) ||\n                      parseFloat(receivedAmount) < amountToPay)\n                  }\n                  dense\n                  theme={{\n                    colors: {\n                      primary: theme.colors.primary,\n                      background: 'rgba(255, 255, 255, 0.05)',\n                    },\n                  }}\n                />\n              </View>\n            </View>\n\n            {/* Error message */}\n            {receivedAmount !== '' &&\n              (isNaN(parseFloat(receivedAmount)) ||\n                parseFloat(receivedAmount) < amountToPay) && (\n                <Text style={styles.errorText}>Monto insuficiente</Text>\n              )}\n\n            {/* Botones de billetes comunes */}\n            {availableBills.length > 0 && (\n              <View style={styles.quickAmountsRow}>\n                {availableBills.map((bill) => (\n                  <Pressable\n                    key={bill}\n                    onPress={() => setReceivedAmount(`${bill}.00`)}\n                    style={({ pressed }) => [\n                      styles.quickAmountButton,\n                      pressed && styles.quickAmountButtonPressed,\n                    ]}\n                  >\n                    <Text style={styles.quickAmountButtonText}>\n                      ${bill >= 1000 ? '1k' : bill}\n                    </Text>\n                  </Pressable>\n                ))}\n              </View>\n            )}\n\n            {/* Mostrar cambio */}\n            {receivedAmount !== '' &&\n              !isNaN(parseFloat(receivedAmount)) &&\n              parseFloat(receivedAmount) >= amountToPay && (\n                <View style={styles.changeSection}>\n                  <Text style={styles.changeLabel}>Cambio</Text>\n                  <Text style={styles.changeAmount}>\n                    ${changeAmount.toFixed(2)}\n                  </Text>\n                </View>\n              )}\n          </View>\n\n          {/* Footer */}\n          <View style={styles.footer}>\n            <Button\n              mode=\"outlined\"\n              onPress={onDismiss}\n              style={styles.cancelButton}\n              labelStyle={styles.cancelButtonLabel}\n              contentStyle={styles.footerButtonContent}\n            >\n              Cancelar\n            </Button>\n            <Button\n              mode=\"contained\"\n              onPress={handleConfirm}\n              disabled={\n                !receivedAmount ||\n                isNaN(parseFloat(receivedAmount)) ||\n                parseFloat(receivedAmount) < amountToPay\n              }\n              style={styles.confirmButton}\n              contentStyle={styles.footerButtonContent}\n              labelStyle={styles.confirmButtonLabel}\n            >\n              Confirmar Pago\n            </Button>\n          </View>\n        </Pressable>\n      </Modal>\n    </Portal>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    modalContainer: {\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.m,\n    },\n    modalContent: {\n      borderRadius: 16,\n      backgroundColor: theme.dark ? '#1C1C1E' : '#FFFFFF',\n      width: '100%',\n      maxWidth: 320,\n      overflow: 'hidden',\n      elevation: 8,\n      shadowColor: '#000',\n      shadowOffset: {\n        width: 0,\n        height: 4,\n      },\n      shadowOpacity: 0.3,\n      shadowRadius: 8,\n    },\n    content: {\n      paddingHorizontal: 16,\n      paddingTop: 16,\n      paddingBottom: 12,\n    },\n    inputsRow: {\n      flexDirection: 'row',\n      gap: 10,\n      marginBottom: 12,\n    },\n    inputContainer: {\n      flex: 1,\n    },\n    inputLabel: {\n      ...theme.fonts.bodySmall,\n      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',\n      marginBottom: 4,\n      fontSize: 11,\n    },\n    totalInput: {\n      backgroundColor: theme.dark\n        ? 'rgba(255, 255, 255, 0.08)'\n        : 'rgba(0, 0, 0, 0.04)',\n      borderRadius: 8,\n      fontSize: 16,\n      height: 40,\n      paddingHorizontal: 10,\n      opacity: 0.8,\n    },\n    receivedInput: {\n      backgroundColor: theme.dark\n        ? 'rgba(255, 255, 255, 0.08)'\n        : 'rgba(0, 0, 0, 0.04)',\n      borderRadius: 8,\n      fontSize: 16,\n      height: 40,\n      paddingHorizontal: 10,\n    },\n    quickAmountsRow: {\n      flexDirection: 'row',\n      gap: 6,\n      marginTop: 8,\n      justifyContent: 'center',\n    },\n    quickAmountButton: {\n      backgroundColor: theme.dark\n        ? 'rgba(255, 255, 255, 0.1)'\n        : 'rgba(0, 0, 0, 0.05)',\n      paddingHorizontal: 16,\n      paddingVertical: 10,\n      borderRadius: 8,\n      flex: 1,\n      alignItems: 'center',\n      minHeight: 42,\n      justifyContent: 'center',\n    },\n    quickAmountButtonPressed: {\n      backgroundColor: theme.dark\n        ? 'rgba(255, 255, 255, 0.2)'\n        : 'rgba(0, 0, 0, 0.1)',\n    },\n    quickAmountButtonText: {\n      ...theme.fonts.labelMedium,\n      color: theme.dark ? '#FFFFFF' : '#000000',\n      fontWeight: '600',\n      fontSize: 14,\n    },\n    errorText: {\n      ...theme.fonts.bodySmall,\n      color: '#FF4444',\n      marginTop: 2,\n      marginLeft: 2,\n      fontSize: 11,\n    },\n    changeSection: {\n      backgroundColor: theme.dark\n        ? 'rgba(16, 185, 129, 0.1)'\n        : 'rgba(16, 185, 129, 0.08)',\n      padding: 12,\n      borderRadius: 10,\n      alignItems: 'center',\n      marginTop: 8,\n    },\n    changeLabel: {\n      ...theme.fonts.bodySmall,\n      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',\n      marginBottom: 2,\n      fontSize: 12,\n    },\n    changeAmount: {\n      ...theme.fonts.titleLarge,\n      color: '#10B981',\n      fontWeight: '700',\n      letterSpacing: -0.5,\n    },\n    footer: {\n      flexDirection: 'row',\n      gap: 10,\n      paddingHorizontal: 12,\n      paddingVertical: 10,\n      borderTopWidth: 1,\n      borderTopColor: theme.dark\n        ? 'rgba(255, 255, 255, 0.1)'\n        : 'rgba(0, 0, 0, 0.05)',\n      backgroundColor: theme.dark ? '#1C1C1E' : '#FFFFFF',\n    },\n    cancelButton: {\n      flex: 1,\n      borderColor: theme.colors.outline,\n    },\n    cancelButtonLabel: {\n      fontSize: 13,\n      fontWeight: '600',\n    },\n    confirmButton: {\n      flex: 2,\n      backgroundColor: '#10B981',\n    },\n    confirmButtonLabel: {\n      fontSize: 13,\n      fontWeight: '600',\n      color: '#FFFFFF',\n    },\n    footerButtonContent: {\n      height: 36,\n    },\n  });\n\nexport default ChangeCalculatorModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/OrderCartDetail.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isSuccessOrder' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":175,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":175,"endColumn":30},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCart\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":205,"column":37,"nodeType":"Identifier","endLine":205,"endColumn":44},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":518,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":518,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[18735,18804],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'findModifierById'. Either include it or remove the dependency array.","line":648,"column":6,"nodeType":"ArrayExpression","endLine":648,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [findModifierById, isEditMode, orderData, visible]","fix":{"range":[23637,23669],"text":"[findModifierById, isEditMode, orderData, visible]"}}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":711,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":711,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26086,26193],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":727,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":727,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26722,26779],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":937,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":937,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[33189,33245],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":938,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":938,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[33250,33371],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1019,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1019,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[36199,36236],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1032,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1032,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[36606,36703],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo, useEffect, useCallback } from 'react';\nimport { Portal } from 'react-native-paper';\nimport {\n  View,\n  ScrollView,\n  StyleSheet,\n  TouchableOpacity,\n  ActivityIndicator,\n  TouchableWithoutFeedback,\n  Keyboard,\n  Animated,\n} from 'react-native';\nimport {\n  Swipeable,\n  GestureHandlerRootView,\n} from 'react-native-gesture-handler';\nimport {\n  Text,\n  Divider,\n  List,\n  Button,\n  RadioButton,\n  HelperText,\n  Menu,\n  IconButton,\n  Modal,\n} from 'react-native-paper';\nimport { useAppTheme } from '@/app/styles/theme';\nimport { OrderTypeEnum, type OrderType } from '../types/orders.types'; // Importar OrderTypeEnum y el tipo OrderType\nimport { useGetAreas } from '@/modules/areasTables/services/areaService';\nimport type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';\nimport OrderHeader from './OrderHeader';\nimport AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';\nimport SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';\nimport { TimePicker } from 'react-native-paper-dates';\nimport ConfirmationModal from '@/app/components/common/ConfirmationModal';\nimport { format } from 'date-fns';\nimport { es } from 'date-fns/locale';\nimport ProductCustomizationModal from './ProductCustomizationModal';\nimport type { FullMenuProduct as Product } from '../types/orders.types';\nimport { useGetTablesByArea } from '@/modules/areasTables/services/tableService';\nimport type { Table } from '@/modules/areasTables/types/areasTables.types';\nimport { useCart, CartItem, CartItemModifier } from '../context/CartContext'; // Importar CartItem y CartItemModifier\nimport { useAuthStore } from '@/app/store/authStore'; // Importar authStore\nimport { useSnackbarStore } from '@/app/store/snackbarStore'; // Importar snackbar store\nimport { useGetOrderByIdQuery } from '../hooks/useOrdersQueries'; // Para cargar datos en modo edición\nimport { useGetFullMenu } from '../hooks/useMenuQueries'; // Para obtener productos completos\nimport type { FullMenuCategory } from '../types/orders.types'; // Tipo con subcategorías\nimport OrderHistoryModal from './OrderHistoryModal'; // Modal de historial\nimport PaymentModal from './PaymentModal'; // Modal de pagos\nimport { FAB } from 'react-native-paper'; // Para el floating action button\nimport { AdjustmentFormModal } from './AdjustmentFormModal'; // Modal de ajustes\nimport type { OrderAdjustment } from '../types/adjustments.types'; // Tipo para ajustes\nimport { useGetPaymentsByOrderIdQuery } from '../hooks/usePaymentQueries'; // Para consultar pagos existentes\nimport { PaymentStatusEnum } from '../types/payment.types'; // Para verificar estados de pago\n\n// Definir la estructura esperada para los items en el DTO de backend\ninterface OrderItemModifierDto {\n  productModifierId: string;\n  quantity?: number;\n  price?: number | null;\n}\n\ninterface OrderItemDtoForBackend {\n  productId: string;\n  productVariantId?: string | null;\n  basePrice: number;\n  finalPrice: number;\n  preparationNotes?: string | null;\n  modifiers?: OrderItemModifierDto[];\n}\n\n// Definir la estructura completa del payload para onConfirmOrder (y exportarla)\nexport interface OrderDetailsForBackend {\n  userId?: string;\n  orderType: OrderType;\n  subtotal: number;\n  total: number;\n  items: OrderItemDtoForBackend[];\n  tableId?: string;\n  scheduledAt?: Date;\n  deliveryInfo: DeliveryInfo;\n  notes?: string;\n  adjustments?: {\n    orderId?: string;\n    name: string;\n    description?: string;\n    isPercentage: boolean;\n    value?: number;\n    amount?: number;\n  }[];\n  customerId?: string;\n  isFromWhatsApp?: boolean;\n}\n\ninterface OrderCartDetailProps {\n  visible: boolean;\n  onConfirmOrder: (details: OrderDetailsForBackend) => void;\n  onClose?: () => void;\n  onEditItem?: (item: CartItem) => void;\n  isEditMode?: boolean;\n  orderId?: string | null;\n  orderNumber?: number;\n  orderDate?: Date;\n  onCancelOrder?: () => void; // Función para cancelar la orden\n  navigation?: any; // Prop de navegación opcional para añadir productos\n  onAddProducts?: () => void; // Callback para añadir productos\n  pendingProductsToAdd?: CartItem[]; // Productos pendientes de añadir\n  onItemsCountChanged?: (count: number) => void; // Callback cuando cambia el conteo de items\n}\n\n// Helper para obtener el color del estado de preparación\nconst getPreparationStatusColor = (status: string | undefined, theme: any) => {\n  switch (status) {\n    case 'NEW':\n      return '#2196F3'; // Azul brillante para nuevo\n    case 'PENDING':\n      return theme.colors.error; // Rojo para pendiente\n    case 'IN_PROGRESS':\n      return '#FFA000'; // Naranja para en progreso\n    case 'READY':\n      return '#4CAF50'; // Verde para listo\n    case 'DELIVERED':\n      return theme.colors.tertiary; // Color terciario para entregado\n    case 'CANCELLED':\n      return theme.colors.onSurfaceDisabled; // Gris para cancelado\n    default:\n      return theme.colors.onSurfaceVariant;\n  }\n};\n\n// Helper para obtener el texto del estado de preparación\nconst getPreparationStatusText = (status: string | undefined): string => {\n  switch (status) {\n    case 'NEW':\n      return 'Nuevo';\n    case 'PENDING':\n      return 'Pendiente';\n    case 'IN_PROGRESS':\n      return 'En Preparación';\n    case 'READY':\n      return 'Listo';\n    case 'DELIVERED':\n      return 'Entregado';\n    case 'CANCELLED':\n      return 'Cancelado';\n    default:\n      return '';\n  }\n};\n\nconst OrderCartDetail: React.FC<OrderCartDetailProps> = ({\n  visible,\n  onConfirmOrder,\n  onClose,\n  onEditItem,\n  isEditMode = false,\n  orderId,\n  orderNumber,\n  orderDate,\n  onCancelOrder,\n  navigation,\n  onAddProducts,\n  pendingProductsToAdd = [],\n  onItemsCountChanged,\n}) => {\n  const theme = useAppTheme();\n  const styles = useMemo(() => createStyles(theme), [theme]);\n\n  // Query para cargar datos de la orden en modo edición\n  const {\n    data: orderData,\n    isLoading: isLoadingOrder,\n    isError: isErrorOrder,\n    isSuccess: isSuccessOrder,\n  } = useGetOrderByIdQuery(orderId, {\n    enabled: isEditMode && !!orderId && visible,\n  });\n\n  // Query para obtener el menú completo (para poder editar productos)\n  const { data: menu } = useGetFullMenu();\n\n  // Query para obtener los pagos de la orden (solo en modo edición)\n  const { data: payments = [] } = useGetPaymentsByOrderIdQuery(orderId || '', {\n    enabled: isEditMode && !!orderId && visible,\n  });\n\n  // Estados locales para modo edición (cuando no usamos el contexto del carrito)\n  const [editItems, setEditItems] = useState<CartItem[]>([]);\n  const [editOrderType, setEditOrderType] = useState<OrderType>(\n    OrderTypeEnum.DINE_IN,\n  );\n  const [editSelectedAreaId, setEditSelectedAreaId] = useState<string | null>(\n    null,\n  );\n  const [editSelectedTableId, setEditSelectedTableId] = useState<string | null>(\n    null,\n  );\n  const [editScheduledTime, setEditScheduledTime] = useState<Date | null>(null);\n  const [editDeliveryInfo, setEditDeliveryInfo] = useState<DeliveryInfo>({});\n  const [editOrderNotes, setEditOrderNotes] = useState<string>('');\n  const [editAdjustments, setEditAdjustments] = useState<OrderAdjustment[]>([]);\n\n  // Obtener estado del carrito Y del formulario desde el contexto SOLO si NO estamos en modo edición\n  const cartContext = !isEditMode ? useCart() : null;\n\n  const cartItems = cartContext?.items || [];\n  const removeCartItem = cartContext?.removeItem || (() => {});\n  const updateCartItemQuantity = cartContext?.updateItemQuantity || (() => {});\n  const isCartVisible = cartContext?.isCartVisible || false;\n  const cartOrderType = cartContext?.orderType || OrderTypeEnum.DINE_IN;\n  const setCartOrderType = cartContext?.setOrderType || (() => {});\n  const cartSelectedAreaId = cartContext?.selectedAreaId || null;\n  const setCartSelectedAreaId = cartContext?.setSelectedAreaId || (() => {});\n  const cartSelectedTableId = cartContext?.selectedTableId || null;\n  const setCartSelectedTableId = cartContext?.setSelectedTableId || (() => {});\n  const cartScheduledTime = cartContext?.scheduledTime || null;\n  const setCartScheduledTime = cartContext?.setScheduledTime || (() => {});\n  const cartDeliveryInfo = cartContext?.deliveryInfo || {};\n  const setCartDeliveryInfo = cartContext?.setDeliveryInfo || (() => {});\n  const cartOrderNotes = cartContext?.orderNotes || '';\n  const setCartOrderNotes = cartContext?.setOrderNotes || (() => {});\n\n  // Usar valores del contexto o locales según el modo\n  const items = isEditMode ? editItems : cartItems;\n  const orderType = isEditMode ? editOrderType : cartOrderType;\n  const selectedAreaId = isEditMode ? editSelectedAreaId : cartSelectedAreaId;\n  const selectedTableId = isEditMode\n    ? editSelectedTableId\n    : cartSelectedTableId;\n  const scheduledTime = isEditMode ? editScheduledTime : cartScheduledTime;\n  const deliveryInfo = isEditMode ? editDeliveryInfo : cartDeliveryInfo;\n  const orderNotes = isEditMode ? editOrderNotes : cartOrderNotes;\n  const adjustments = isEditMode ? editAdjustments : [];\n\n  const setOrderType = isEditMode ? setEditOrderType : setCartOrderType;\n  const setSelectedAreaId = isEditMode\n    ? setEditSelectedAreaId\n    : setCartSelectedAreaId;\n  const setSelectedTableId = isEditMode\n    ? setEditSelectedTableId\n    : setCartSelectedTableId;\n  const setScheduledTime = isEditMode\n    ? setEditScheduledTime\n    : setCartScheduledTime;\n  const setDeliveryInfo = isEditMode\n    ? setEditDeliveryInfo\n    : setCartDeliveryInfo;\n  const setOrderNotes = isEditMode ? setEditOrderNotes : setCartOrderNotes;\n\n  const removeItem = (itemId: string) => {\n    if (isEditMode) {\n      const item = editItems.find((i) => i.id === itemId);\n      if (!item) return;\n\n      // Verificar el estado del item\n      if (\n        item.preparationStatus === 'READY' ||\n        item.preparationStatus === 'DELIVERED'\n      ) {\n        // No permitir eliminar items listos o entregados\n        showSnackbar({\n          message: `No se puede eliminar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,\n          type: 'error',\n        });\n        return;\n      }\n\n      if (item.preparationStatus === 'IN_PROGRESS') {\n        // Pedir confirmación para items en preparación\n        setModifyingItemName(item.productName);\n        setPendingModifyAction(() => () => {\n          setEditItems((prev) => prev.filter((i) => i.id !== itemId));\n        });\n        setShowModifyInProgressConfirmation(true);\n      } else {\n        // Permitir eliminar items pendientes o cancelados sin confirmación\n        setEditItems((prev) => prev.filter((i) => i.id !== itemId));\n      }\n    } else {\n      removeCartItem(itemId);\n    }\n  };\n\n  const updateItemQuantity = (itemId: string, quantity: number) => {\n    if (isEditMode) {\n      if (quantity <= 0) {\n        removeItem(itemId);\n        return;\n      }\n\n      const item = editItems.find((i) => i.id === itemId);\n      if (!item) return;\n\n      // Verificar el estado del item\n      if (\n        item.preparationStatus === 'READY' ||\n        item.preparationStatus === 'DELIVERED'\n      ) {\n        // No permitir modificar items listos o entregados\n        showSnackbar({\n          message: `No se puede modificar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,\n          type: 'error',\n        });\n        return;\n      }\n\n      const updateQuantity = () => {\n        setEditItems((prev) =>\n          prev.map((item) => {\n            if (item.id === itemId) {\n              const modifiersPrice = item.modifiers.reduce(\n                (sum, mod) => sum + Number(mod.price || 0),\n                0,\n              );\n              const newTotalPrice =\n                (item.unitPrice + modifiersPrice) * quantity;\n              return {\n                ...item,\n                quantity,\n                totalPrice: newTotalPrice,\n              };\n            }\n            return item;\n          }),\n        );\n      };\n\n      if (item.preparationStatus === 'IN_PROGRESS') {\n        // Pedir confirmación para items en preparación\n        setModifyingItemName(item.productName);\n        setPendingModifyAction(() => updateQuantity);\n        setShowModifyInProgressConfirmation(true);\n      } else {\n        // Permitir modificar items pendientes o cancelados sin confirmación\n        updateQuantity();\n      }\n    } else {\n      updateCartItemQuantity(itemId, quantity);\n    }\n  };\n\n  // Calcular totales\n  const subtotal = useMemo(() => {\n    return items.reduce((sum, item) => sum + item.totalPrice, 0);\n  }, [items]);\n\n  // Calcular total de ajustes\n  const totalAdjustments = useMemo(() => {\n    if (!isEditMode) return 0;\n    return editAdjustments\n      .filter((adj) => !adj.isDeleted)\n      .reduce((sum, adj) => sum + (adj.amount || 0), 0);\n  }, [isEditMode, editAdjustments]);\n\n  const total = useMemo(() => {\n    return subtotal + totalAdjustments;\n  }, [subtotal, totalAdjustments]);\n\n  const totalItemsCount = useMemo(() => {\n    return items.reduce((sum, item) => sum + item.quantity, 0);\n  }, [items]);\n\n  // Calcular conteo de items existentes (no temporales)\n  const existingItemsCount = useMemo(() => {\n    if (!isEditMode) return 0;\n    return editItems\n      .filter((item) => !item.id.startsWith('new-'))\n      .reduce((sum, item) => sum + item.quantity, 0);\n  }, [isEditMode, editItems]);\n\n  // Notificar cambios en el conteo de items (solo en modo edición)\n  const [lastNotifiedCount, setLastNotifiedCount] = useState<number | null>(\n    null,\n  );\n\n  useEffect(() => {\n    if (isEditMode && onItemsCountChanged && visible && orderDataLoaded) {\n      // Solo notificar si el conteo realmente cambió\n      if (existingItemsCount !== lastNotifiedCount) {\n        onItemsCountChanged(existingItemsCount);\n        setLastNotifiedCount(existingItemsCount);\n      }\n    }\n  }, [\n    isEditMode,\n    existingItemsCount,\n    visible,\n    orderDataLoaded,\n    lastNotifiedCount,\n    onItemsCountChanged,\n  ]);\n\n  // Calcular total pagado\n  const totalPaid = useMemo(() => {\n    if (!isEditMode || !payments) return 0;\n    return payments\n      .filter((p) => p.paymentStatus === PaymentStatusEnum.COMPLETED)\n      .reduce((sum, payment) => sum + (Number(payment.amount) || 0), 0);\n  }, [payments, isEditMode]);\n\n  const pendingAmount = useMemo(() => {\n    return Math.max(0, total - totalPaid);\n  }, [total, totalPaid]);\n\n  const { user } = useAuthStore(); // Obtener usuario autenticado\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar); // Hook para snackbar\n\n  // Estados locales solo para UI (errores, visibilidad de menús/modales)\n  const [areaMenuVisible, setAreaMenuVisible] = useState(false);\n  const [tableMenuVisible, setTableMenuVisible] = useState(false);\n  const [areaError, setAreaError] = useState<string | null>(null);\n  const [tableError, setTableError] = useState<string | null>(null);\n  const [customerNameError, setCustomerNameError] = useState<string | null>(\n    null,\n  );\n  const [phoneError, setPhoneError] = useState<string | null>(null);\n  const [addressError, setAddressError] = useState<string | null>(null);\n  const [isTimePickerVisible, setTimePickerVisible] = useState(false);\n  const [timePickerHours, setTimePickerHours] = useState<number>(\n    new Date().getHours(),\n  );\n  const [timePickerMinutes, setTimePickerMinutes] = useState<number>(\n    new Date().getMinutes(),\n  );\n  const [isTimeAlertVisible, setTimeAlertVisible] = useState(false);\n  const [isConfirming, setIsConfirming] = useState(false);\n  const [showExitConfirmation, setShowExitConfirmation] = useState(false);\n  const [editingItemFromList, setEditingItemFromList] =\n    useState<CartItem | null>(null);\n  const [editingProduct, setEditingProduct] = useState<Product | null>(null);\n  const [isModalReady, setIsModalReady] = useState(false);\n  const [showOptionsMenu, setShowOptionsMenu] = useState(false);\n  const [showCancelConfirmation, setShowCancelConfirmation] = useState(false);\n  const [\n    showModifyInProgressConfirmation,\n    setShowModifyInProgressConfirmation,\n  ] = useState(false);\n  const [pendingModifyAction, setPendingModifyAction] = useState<\n    (() => void) | null\n  >(null);\n  const [modifyingItemName, setModifyingItemName] = useState<string>('');\n  const [showHistoryModal, setShowHistoryModal] = useState(false);\n  const [showPaymentModal, setShowPaymentModal] = useState(false);\n  const [showAdjustmentModal, setShowAdjustmentModal] = useState(false);\n  const [adjustmentToEdit, setAdjustmentToEdit] =\n    useState<OrderAdjustment | null>(null);\n  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);\n\n  // Estado original de la orden para detectar cambios\n  const [originalOrderState, setOriginalOrderState] = useState<{\n    items: CartItem[];\n    orderType: OrderType;\n    tableId: string | null;\n    deliveryInfo: DeliveryInfo;\n    notes: string;\n    scheduledAt: Date | null;\n    adjustments: OrderAdjustment[];\n  } | null>(null);\n\n  // --- Queries para Áreas y Mesas (sin cambios) ---\n  const {\n    data: areasData,\n    isLoading: isLoadingAreas,\n    error: errorAreas,\n  } = useGetAreas();\n  const {\n    data: tablesData,\n    isLoading: isLoadingTables,\n    error: errorTables,\n  } = useGetTablesByArea(selectedAreaId);\n\n  // Función helper para buscar información de un modifier por su ID\n  const findModifierById = useCallback(\n    (modifierId: string): CartItemModifier | null => {\n      if (!menu) return null;\n\n      for (const category of menu) {\n        for (const subcategory of category.subcategories || []) {\n          for (const product of subcategory.products || []) {\n            for (const modifierGroup of product.modifierGroups || []) {\n              const modifier = modifierGroup.productModifiers?.find(\n                (mod) => mod.id === modifierId,\n              );\n              if (modifier) {\n                return {\n                  id: modifier.id,\n                  modifierGroupId: modifierGroup.id,\n                  name: modifier.name,\n                  price: modifier.price,\n                };\n              }\n            }\n          }\n        }\n      }\n      return null;\n    },\n    [menu],\n  );\n\n  // Cargar datos de la orden cuando esté en modo edición\n  useEffect(() => {\n    if (!isEditMode || !orderData || !visible) return;\n\n    // Establecer los valores del formulario\n    setEditOrderType(orderData.orderType);\n    setEditSelectedTableId(orderData.tableId ?? null);\n    setEditScheduledTime(\n      orderData.scheduledAt ? new Date(orderData.scheduledAt) : null,\n    );\n    // Cargar deliveryInfo\n    setEditDeliveryInfo(orderData.deliveryInfo || {});\n    setEditOrderNotes(orderData.notes ?? '');\n\n    // Cargar ajustes si existen\n    if (orderData.adjustments && Array.isArray(orderData.adjustments)) {\n      console.log('Ajustes recibidos del backend:', orderData.adjustments);\n      setEditAdjustments(\n        orderData.adjustments.map((adj) => ({\n          id: adj.id,\n          name: adj.name,\n          description: adj.description || '',\n          isPercentage: adj.isPercentage,\n          value: adj.value,\n          amount: adj.amount,\n        })),\n      );\n    } else {\n      setEditAdjustments([]);\n    }\n\n    // Si hay una mesa, necesitamos encontrar el área\n    if (orderData.tableId && orderData.table) {\n      setEditSelectedAreaId(orderData.table.areaId);\n    }\n\n    // Mapa para agrupar items idénticos\n    const groupedItemsMap = new Map<string, CartItem>();\n\n    // Mapear y agrupar los items de la orden\n    if (orderData.orderItems && Array.isArray(orderData.orderItems)) {\n      orderData.orderItems.forEach((item: any) => {\n        // Mapear los modificadores desde el nuevo formato (productModifiers)\n        const modifiers: CartItemModifier[] = [];\n\n        // Si vienen en el formato antiguo (item.modifiers con objetos)\n        if (item.modifiers && Array.isArray(item.modifiers)) {\n          item.modifiers.forEach((mod: any) => {\n            modifiers.push({\n              id: mod.productModifierId,\n              modifierGroupId: mod.productModifier?.modifierGroupId || '',\n              name: mod.productModifier?.name || 'Modificador',\n              price: parseFloat(mod.price || '0'),\n            });\n          });\n        }\n        // Si vienen en el nuevo formato (item.productModifiers como array de entidades)\n        else if (\n          item.productModifiers &&\n          Array.isArray(item.productModifiers)\n        ) {\n          item.productModifiers.forEach((mod: any) => {\n            const modifierInfo = findModifierById(mod.id) || {\n              id: mod.id,\n              modifierGroupId: mod.modifierGroupId || '',\n              name: mod.name || 'Modificador',\n              price: mod.price || 0,\n            };\n            modifiers.push(modifierInfo);\n          });\n        }\n\n        const modifiersPrice = modifiers.reduce(\n          (sum: number, mod: any) => sum + (mod.price || 0),\n          0,\n        );\n        const unitPrice = parseFloat(item.basePrice || '0');\n\n        // Crear una clave única para agrupar items idénticos (incluyendo estado de preparación)\n        const groupKey = `${item.productId}-${item.productVariantId || 'null'}-${JSON.stringify(\n          modifiers.map((m) => m.id).sort(),\n        )}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;\n\n        const existingItem = groupedItemsMap.get(groupKey);\n\n        if (\n          existingItem &&\n          existingItem.preparationStatus === item.preparationStatus\n        ) {\n          // Si ya existe un item idéntico con el mismo estado, incrementar la cantidad\n          existingItem.quantity += 1;\n          existingItem.totalPrice =\n            (unitPrice + modifiersPrice) * existingItem.quantity;\n        } else {\n          // Si es un nuevo item, agregarlo al mapa\n          const cartItem: CartItem = {\n            id: item.id, // Usar el ID del primer item del grupo\n            productId: item.productId,\n            productName: item.product?.name || 'Producto desconocido',\n            quantity: 1, // Empezar con 1, el backend ya no envía quantity\n            unitPrice,\n            totalPrice: unitPrice + modifiersPrice,\n            modifiers,\n            variantId: item.productVariantId || undefined,\n            variantName: item.productVariant?.name || undefined,\n            preparationNotes: item.preparationNotes || undefined,\n            preparationStatus: item.preparationStatus || 'PENDING', // Incluir estado de preparación\n          };\n          groupedItemsMap.set(groupKey, cartItem);\n        }\n      });\n\n      // Convertir el mapa a array\n      const mappedItems = Array.from(groupedItemsMap.values());\n      setEditItems(mappedItems);\n    }\n\n    // Marcar que los datos de la orden ya se cargaron\n    setOrderDataLoaded(true);\n\n    // Guardar el estado original de la orden para detectar cambios\n    const originalItems = Array.from(groupedItemsMap.values());\n    const originalAdjustments =\n      orderData.adjustments?.map((adj) => ({\n        id: adj.id,\n        name: adj.name,\n        // description: adj.description, // No existe en el tipo Adjustment\n        isPercentage: adj.isPercentage,\n        value: adj.value,\n        amount: adj.amount,\n      })) || [];\n\n    setOriginalOrderState({\n      items: originalItems,\n      orderType: orderData.orderType,\n      tableId: orderData.tableId ?? null,\n      deliveryInfo: orderData.deliveryInfo || {},\n      notes: orderData.notes ?? '',\n      scheduledAt: orderData.scheduledAt\n        ? new Date(orderData.scheduledAt)\n        : null,\n      adjustments: originalAdjustments,\n    });\n\n    // Resetear el flag de cambios no guardados\n    setHasUnsavedChanges(false);\n  }, [isEditMode, orderData, visible]);\n\n  // Función para agrupar items idénticos\n  const groupIdenticalItems = useCallback((items: CartItem[]): CartItem[] => {\n    const groupedMap = new Map<string, CartItem>();\n\n    items.forEach((item) => {\n      // Crear una clave única basada en todas las propiedades que deben ser idénticas\n      const modifierIds = item.modifiers\n        .map((m) => m.id)\n        .sort()\n        .join(',');\n\n      const groupKey = `${item.productId}-${item.variantId || 'null'}-${modifierIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'NEW'}`;\n\n      const existingItem = groupedMap.get(groupKey);\n\n      if (existingItem) {\n        // Si ya existe un item idéntico, incrementar la cantidad\n        existingItem.quantity += item.quantity;\n        // Recalcular el precio total considerando modificadores\n        const modifiersPrice = existingItem.modifiers.reduce(\n          (sum, mod) => sum + (mod.price || 0),\n          0,\n        );\n        existingItem.totalPrice =\n          (existingItem.unitPrice + modifiersPrice) * existingItem.quantity;\n      } else {\n        // Si es nuevo, agregarlo al mapa con una copia completa\n        groupedMap.set(groupKey, { ...item });\n      }\n    });\n\n    return Array.from(groupedMap.values());\n  }, []);\n\n  // Estado para controlar si ya procesamos los productos pendientes\n  const [processedPendingProductsIds, setProcessedPendingProductsIds] =\n    useState<string[]>([]);\n  // Estado para controlar si los datos de la orden ya se cargaron\n  const [orderDataLoaded, setOrderDataLoaded] = useState(false);\n\n  // Manejar productos pendientes de añadir\n  useEffect(() => {\n    // Solo procesar cuando:\n    // 1. Hay productos pendientes\n    // 2. Estamos en modo edición\n    // 3. El modal es visible\n    // 4. Los datos de la orden ya se cargaron\n    if (\n      pendingProductsToAdd.length > 0 &&\n      isEditMode &&\n      visible &&\n      orderDataLoaded\n    ) {\n      // Filtrar productos que no han sido procesados aún\n      const unprocessedProducts = pendingProductsToAdd.filter((item) => {\n        // Usar una clave única para cada producto basada en sus propiedades\n        const productKey = `${item.productId}-${item.variantId || 'null'}-${JSON.stringify(item.modifiers.map((m) => m.id).sort())}-${item.preparationNotes || ''}`;\n        return !processedPendingProductsIds.includes(productKey);\n      });\n\n      if (unprocessedProducts.length > 0) {\n        console.log(\n          'Procesando productos pendientes:',\n          unprocessedProducts.length,\n        );\n\n        // Marcar los nuevos productos con estado \"NEW\"\n        const newProductsWithStatus = unprocessedProducts.map((item) => ({\n          ...item,\n          preparationStatus: 'NEW' as const,\n          id: `new-${Date.now()}-${Math.random()}`, // Asegurar IDs únicos para nuevos items\n        }));\n\n        // Combinar con items existentes y agrupar\n        setEditItems((prevItems) => {\n          const allItems = [...prevItems, ...newProductsWithStatus];\n          const grouped = groupIdenticalItems(allItems);\n          console.log('Items después de agrupar:', grouped.length);\n          return grouped;\n        });\n\n        // Marcar estos productos como procesados\n        const newProcessedIds = unprocessedProducts.map(\n          (item) =>\n            `${item.productId}-${item.variantId || 'null'}-${JSON.stringify(item.modifiers.map((m) => m.id).sort())}-${item.preparationNotes || ''}`,\n        );\n        setProcessedPendingProductsIds((prev) => [...prev, ...newProcessedIds]);\n\n        // Calcular cuántos items únicos se añadieron\n        const uniqueNewItems = newProductsWithStatus.length;\n        showSnackbar({\n          message: `${uniqueNewItems} producto${uniqueNewItems > 1 ? 's' : ''} añadido${uniqueNewItems > 1 ? 's' : ''}`,\n          type: 'success',\n        });\n      }\n    }\n  }, [\n    pendingProductsToAdd,\n    isEditMode,\n    visible,\n    orderDataLoaded,\n    processedPendingProductsIds,\n    groupIdenticalItems,\n    showSnackbar,\n  ]);\n\n  // Resetear los IDs procesados cuando el modal se cierre o cambie de orden\n  // (esto se maneja en el useEffect de reseteo de estados)\n\n  // Limpiar errores locales al cambiar tipo de orden (más simple)\n  useEffect(() => {\n    setAreaError(null);\n    setTableError(null);\n    setCustomerNameError(null);\n    setPhoneError(null);\n    setAddressError(null);\n  }, [orderType]);\n\n  // Detectar cambios sin guardar\n  useEffect(() => {\n    if (!isEditMode || !originalOrderState || !visible) {\n      setHasUnsavedChanges(false);\n      return;\n    }\n\n    // Comparar el estado actual con el original\n    const hasChanges =\n      // Cambios en items\n      JSON.stringify(editItems) !== JSON.stringify(originalOrderState.items) ||\n      // Cambios en tipo de orden\n      editOrderType !== originalOrderState.orderType ||\n      // Cambios en mesa\n      editSelectedTableId !== originalOrderState.tableId ||\n      // Cambios en datos del cliente\n      JSON.stringify(editDeliveryInfo) !==\n        JSON.stringify(originalOrderState.deliveryInfo) ||\n      editOrderNotes !== originalOrderState.notes ||\n      // Cambios en hora programada\n      (editScheduledTime?.getTime() || null) !==\n        (originalOrderState.scheduledAt?.getTime() || null) ||\n      // Cambios en ajustes\n      JSON.stringify(editAdjustments) !==\n        JSON.stringify(originalOrderState.adjustments);\n\n    setHasUnsavedChanges(hasChanges);\n  }, [\n    isEditMode,\n    originalOrderState,\n    visible,\n    editItems,\n    editOrderType,\n    editSelectedTableId,\n    editDeliveryInfo,\n    editOrderNotes,\n    editScheduledTime,\n    editAdjustments,\n  ]);\n\n  // Resetear estados cuando el modal se cierre\n  useEffect(() => {\n    if (!visible && isEditMode) {\n      // Resetear estados de edición cuando el modal se cierre\n      setEditOrderType(OrderTypeEnum.DINE_IN);\n      setEditSelectedAreaId(null);\n      setEditSelectedTableId(null);\n      setEditScheduledTime(null);\n      setEditDeliveryInfo({});\n      setEditOrderNotes('');\n      setEditItems([]);\n      setShowExitConfirmation(false);\n      setEditingItemFromList(null);\n      setEditingProduct(null);\n      setIsModalReady(false);\n      setOrderDataLoaded(false); // Resetear el flag de datos cargados\n      setProcessedPendingProductsIds([]); // Resetear los IDs de productos procesados\n      setLastNotifiedCount(null); // Resetear el conteo notificado\n      setOriginalOrderState(null); // Resetear el estado original\n      setHasUnsavedChanges(false); // Resetear el flag de cambios\n    }\n  }, [visible, isEditMode]);\n\n  // Manejar la preparación del modal con un pequeño delay\n  useEffect(() => {\n    if (visible && !isModalReady) {\n      const timer = setTimeout(() => {\n        setIsModalReady(true);\n      }, 100); // 100ms delay para evitar conflictos de focus\n      return () => clearTimeout(timer);\n    }\n  }, [visible, isModalReady]);\n\n  // Funciones para manejar ajustes\n  const handleAddAdjustment = useCallback(\n    (adjustment: OrderAdjustment) => {\n      if (isEditMode) {\n        // Asegurar que el ajuste tenga un ID único\n        const newAdjustment = {\n          ...adjustment,\n          id: adjustment.id || `new-adjustment-${Date.now()}-${Math.random()}`,\n          isNew: true,\n        };\n        setEditAdjustments((prev) => [...prev, newAdjustment]);\n      }\n    },\n    [isEditMode],\n  );\n\n  const handleUpdateAdjustment = useCallback(\n    (id: string, updatedAdjustment: OrderAdjustment) => {\n      if (isEditMode) {\n        setEditAdjustments((prev) =>\n          prev.map((adj) =>\n            adj.id === id ? { ...adj, ...updatedAdjustment, id } : adj,\n          ),\n        );\n      }\n    },\n    [isEditMode],\n  );\n\n  const handleRemoveAdjustment = useCallback(\n    (id: string) => {\n      if (isEditMode) {\n        setEditAdjustments((prev) => prev.filter((adj) => adj.id !== id));\n      }\n    },\n    [isEditMode],\n  );\n\n  const handleConfirm = async () => {\n    if (isConfirming) return; // Prevenir múltiples clics\n\n    setAreaError(null);\n    setTableError(null);\n    setCustomerNameError(null);\n    setPhoneError(null);\n    setAddressError(null);\n\n    if (items.length === 0) {\n      return;\n    }\n\n    let isValid = true;\n\n    if (orderType === OrderTypeEnum.DINE_IN) {\n      // Usar Enum\n      if (!selectedAreaId) {\n        setAreaError('Debe seleccionar un área');\n        isValid = false;\n      }\n      if (!selectedTableId) {\n        setTableError('Debe seleccionar una mesa');\n        isValid = false;\n      }\n    } else if (orderType === OrderTypeEnum.TAKE_AWAY) {\n      // Usar Enum\n      if (\n        !deliveryInfo.recipientName ||\n        deliveryInfo.recipientName.trim() === ''\n      ) {\n        setCustomerNameError('El nombre del cliente es obligatorio');\n        isValid = false;\n      }\n      // Phone is optional for take away\n    } else if (orderType === OrderTypeEnum.DELIVERY) {\n      // Usar Enum\n      // Customer name not required for delivery as per new spec\n      if (!deliveryInfo.fullAddress || deliveryInfo.fullAddress.trim() === '') {\n        setAddressError('La dirección es obligatoria para Domicilio');\n        isValid = false;\n      }\n      if (\n        !deliveryInfo.recipientPhone ||\n        deliveryInfo.recipientPhone.trim() === ''\n      ) {\n        setPhoneError('El teléfono es obligatorio para Domicilio');\n        isValid = false;\n      }\n    }\n\n    if (!isValid) {\n      return;\n    }\n\n    // Mapear items del carrito al formato esperado por el DTO del backend\n    const itemsForBackend: OrderItemDtoForBackend[] = [];\n\n    console.log('Items a enviar al backend:', items.length);\n    console.log(\n      'Items con estado NEW:',\n      items.filter((item) => item.preparationStatus === 'NEW').length,\n    );\n\n    // En ambos modos (creación y edición), expandir items según su cantidad\n    // El backend identifica items únicos por productId + variantId, así que necesitamos\n    // enviar items individuales para poder tener múltiples del mismo producto\n    items.forEach((item: CartItem) => {\n      // Crear un item individual por cada unidad de la cantidad\n      for (let i = 0; i < item.quantity; i++) {\n        itemsForBackend.push({\n          productId: item.productId,\n          productVariantId: item.variantId || null,\n          basePrice: Number(item.unitPrice), // Precio unitario\n          finalPrice: Number(item.totalPrice / item.quantity), // Precio final unitario\n          preparationNotes: item.preparationNotes || null,\n          // Mapear modificadores al formato del backend (ahora solo IDs)\n          productModifierIds:\n            item.modifiers && item.modifiers.length > 0\n              ? item.modifiers.map((mod) => mod.id)\n              : undefined,\n        });\n      }\n    });\n\n    // Formatear el número de teléfono para el backend\n    let formattedPhone: string | undefined = undefined;\n    if (\n      deliveryInfo.recipientPhone &&\n      deliveryInfo.recipientPhone.trim() !== ''\n    ) {\n      formattedPhone = deliveryInfo.recipientPhone.trim();\n      if (!formattedPhone.startsWith('+')) {\n        formattedPhone = `+52${formattedPhone}`;\n      }\n      const digitsOnly = formattedPhone.replace(/\\D/g, '');\n      if (digitsOnly.length < 10) {\n        setPhoneError('El teléfono debe tener al menos 10 dígitos');\n        return;\n      }\n      if (digitsOnly.length > 15) {\n        setPhoneError('El teléfono no puede tener más de 15 dígitos');\n        return;\n      }\n    }\n\n    const orderDetails: OrderDetailsForBackend = {\n      userId: user?.id, // userId ahora es opcional\n      orderType,\n      subtotal,\n      total,\n      items: itemsForBackend,\n      tableId:\n        orderType === OrderTypeEnum.DINE_IN\n          ? (selectedTableId ?? undefined)\n          : undefined, // Usar Enum\n      scheduledAt: scheduledTime ?? undefined,\n      deliveryInfo: {\n        recipientName:\n          orderType === OrderTypeEnum.TAKE_AWAY ||\n          orderType === OrderTypeEnum.DELIVERY\n            ? deliveryInfo.recipientName\n            : undefined,\n        recipientPhone:\n          (orderType === OrderTypeEnum.TAKE_AWAY ||\n            orderType === OrderTypeEnum.DELIVERY) &&\n          formattedPhone\n            ? formattedPhone\n            : undefined,\n        fullAddress:\n          orderType === OrderTypeEnum.DELIVERY\n            ? deliveryInfo.fullAddress\n            : undefined,\n        ...deliveryInfo,\n      },\n      notes: orderNotes || undefined,\n      adjustments: isEditMode\n        ? editAdjustments\n            .filter((adj) => !adj.isDeleted)\n            .map((adj) => {\n              console.log('Mapeando ajuste:', adj);\n              return {\n                orderId: orderId || undefined,\n                name: adj.name,\n                // description: adj.description, // No existe en el tipo Adjustment\n                isPercentage: adj.isPercentage,\n                value: adj.value,\n                amount: adj.amount,\n              };\n            })\n        : undefined,\n    };\n\n    console.log(\n      'Payload final a enviar:',\n      JSON.stringify(orderDetails, null, 2),\n    );\n\n    if (!orderDetails.userId) {\n      console.error('Error: Falta el ID del usuario al confirmar la orden.');\n      return; // Detener el proceso si falta el userId\n    }\n\n    setIsConfirming(true); // Marcar como procesando\n\n    try {\n      await onConfirmOrder(orderDetails);\n      // Si llegamos aquí, la orden fue exitosa\n      setIsConfirming(false);\n\n      // Actualizar el estado original después de guardar exitosamente\n      if (isEditMode) {\n        setOriginalOrderState({\n          items: [...editItems],\n          orderType: editOrderType,\n          tableId: editSelectedTableId,\n          deliveryInfo: editDeliveryInfo,\n          notes: editOrderNotes,\n          scheduledAt: editScheduledTime,\n          adjustments: editAdjustments,\n        });\n        setHasUnsavedChanges(false);\n\n        // Mostrar mensaje de éxito\n        showSnackbar({\n          message: 'Cambios guardados exitosamente',\n          type: 'success',\n        });\n\n        // Cerrar el modal después de una actualización exitosa\n        onClose?.();\n      }\n    } catch (error) {\n      // Solo re-habilitar si hubo un error\n      setIsConfirming(false);\n      console.error('Error en handleConfirm:', error);\n    }\n  };\n\n  const selectedAreaName = useMemo(\n    () => areasData?.find((a: any) => a.id === selectedAreaId)?.name,\n    [areasData, selectedAreaId],\n  );\n  const selectedTableName = useMemo(\n    () => tablesData?.find((t) => t.id === selectedTableId)?.name,\n    [tablesData, selectedTableId],\n  );\n\n  const showTimePicker = () => {\n    const currentTime = scheduledTime || new Date();\n    setTimePickerHours(currentTime.getHours());\n    setTimePickerMinutes(currentTime.getMinutes());\n    setTimePickerVisible(true);\n  };\n  const hideTimePicker = () => setTimePickerVisible(false);\n  const handleTimeConfirm = () => {\n    const selectedDate = new Date();\n    selectedDate.setHours(timePickerHours, timePickerMinutes, 0, 0);\n    const now = new Date();\n    now.setSeconds(0, 0);\n\n    if (selectedDate < now) {\n      hideTimePicker();\n      setTimeAlertVisible(true);\n    } else {\n      setScheduledTime(selectedDate);\n      hideTimePicker();\n    }\n  };\n\n  const formattedScheduledTime = useMemo(() => {\n    if (!scheduledTime) return null;\n    try {\n      return format(scheduledTime, 'p', { locale: es });\n    } catch (error) {\n      console.error('Error formatting time:', error);\n      return 'Hora inválida';\n    }\n  }, [scheduledTime]);\n\n  // [FUNCIÓN ELIMINADA - hasUnsavedChanges ya existe como estado]\n  /*\n    if (!isEditMode || !orderData) return false;\n\n    // Comparar tipo de orden\n    if (editOrderType !== orderData.orderType) return true;\n\n    // Comparar mesa (solo para DINE_IN)\n    if (\n      editOrderType === OrderTypeEnum.DINE_IN &&\n      editSelectedTableId !== orderData.tableId\n    )\n      return true;\n\n    // Comparar hora programada\n    const originalScheduledTime = orderData.scheduledAt\n      ? new Date(orderData.scheduledAt).getTime()\n      : null;\n    const currentScheduledTime = editScheduledTime\n      ? editScheduledTime.getTime()\n      : null;\n    if (originalScheduledTime !== currentScheduledTime) return true;\n\n    // Comparar datos del cliente\n    if (JSON.stringify(editDeliveryInfo) !== JSON.stringify(orderData.deliveryInfo || {})) return true;\n    if (editOrderNotes !== (orderData.notes || '')) return true;\n\n    // Comparar items\n    const originalItems = orderData.orderItems || [];\n\n    // Si algún item tiene un ID temporal (new-*), hay cambios\n    if (editItems.some((item) => item.id.startsWith('new-'))) return true;\n\n    // Calcular la cantidad total de items originales\n    const originalTotalQuantity = originalItems.length; // Backend envía items individuales\n    const editTotalQuantity = editItems.reduce(\n      (sum, item) => sum + item.quantity,\n      0,\n    );\n\n    // Si la cantidad total de items cambió, hay cambios\n    if (originalTotalQuantity !== editTotalQuantity) return true;\n\n    // Crear un mapa de items agrupados desde los items originales para comparación\n    const originalGroupedMap = new Map<string, number>();\n\n    originalItems.forEach((item: any) => {\n      // Crear una clave única para agrupar items idénticos\n      let modifierIds = '';\n      if (item.modifiers && Array.isArray(item.modifiers)) {\n        // Formato antiguo\n        modifierIds = item.modifiers\n          .map((m: any) => m.productModifierId)\n          .sort()\n          .join(',');\n      } else if (item.productModifiers && Array.isArray(item.productModifiers)) {\n        // Formato nuevo\n        modifierIds = item.productModifiers\n          .map((m: any) => m.id)\n          .sort()\n          .join(',');\n      }\n      const groupKey = `${item.productId}-${item.productVariantId || 'null'}-${modifierIds}-${item.preparationNotes || ''}`;\n\n      const currentQuantity = originalGroupedMap.get(groupKey) || 0;\n      originalGroupedMap.set(groupKey, currentQuantity + 1);\n    });\n\n    // Crear un mapa similar para los items editados\n    const editGroupedMap = new Map<string, number>();\n\n    editItems.forEach((item) => {\n      if (!item.id.startsWith('new-')) {\n        const modifierIds = item.modifiers\n          .map((m) => m.id)\n          .sort()\n          .join(',');\n        const groupKey = `${item.productId}-${item.variantId || 'null'}-${modifierIds}-${item.preparationNotes || ''}`;\n\n        editGroupedMap.set(groupKey, item.quantity);\n      }\n    });\n\n    // Comparar los mapas\n    if (originalGroupedMap.size !== editGroupedMap.size) return true;\n\n    for (const [key, originalQuantity] of originalGroupedMap) {\n      const editQuantity = editGroupedMap.get(key);\n      if (editQuantity === undefined || editQuantity !== originalQuantity) {\n        return true;\n      }\n    }\n\n    return false;\n  }, [\n    isEditMode,\n    orderData,\n    editOrderType,\n    editSelectedTableId,\n    editScheduledTime,\n    editCustomerName,\n    editPhoneNumber,\n    editDeliveryAddress,\n    editOrderNotes,\n    editItems,\n  ]); */\n\n  // Función para manejar la edición de un item del carrito\n  const handleEditCartItem = useCallback(\n    (item: CartItem) => {\n      if (!isEditMode) {\n        // En modo creación, usar la función pasada por props\n        if (onEditItem) {\n          onEditItem(item);\n        }\n      } else {\n        // Verificar el estado del item antes de permitir edición\n        if (\n          item.preparationStatus === 'READY' ||\n          item.preparationStatus === 'DELIVERED'\n        ) {\n          // No permitir editar items listos o entregados\n          showSnackbar({\n            message: `No se puede editar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,\n            type: 'error',\n          });\n          return;\n        }\n\n        const proceedWithEdit = () => {\n          // En modo edición, buscar el producto real del menú\n          if (!menu || !Array.isArray(menu)) {\n            console.warn('El menú no está disponible');\n            return;\n          }\n\n          // Buscar el producto en la estructura anidada del menú\n          let product: Product | undefined;\n\n          for (const category of menu as FullMenuCategory[]) {\n            if (\n              category.subcategories &&\n              Array.isArray(category.subcategories)\n            ) {\n              for (const subcategory of category.subcategories) {\n                if (\n                  subcategory.products &&\n                  Array.isArray(subcategory.products)\n                ) {\n                  product = subcategory.products.find(\n                    (p: Product) => p.id === item.productId,\n                  );\n                  if (product) break;\n                }\n              }\n            }\n            if (product) break;\n          }\n\n          if (product) {\n            setEditingItemFromList(item);\n            setEditingProduct(product);\n          } else {\n            // Si no encontramos el producto en el menú, crear uno temporal\n            console.warn(\n              'Producto no encontrado en el menú, usando datos temporales',\n            );\n            setEditingItemFromList(item);\n\n            const tempProduct: Product = {\n              id: item.productId,\n              name: item.productName,\n              price: item.unitPrice,\n              hasVariants: !!item.variantId,\n              variants: item.variantId\n                ? [\n                    {\n                      id: item.variantId,\n                      name: item.variantName || '',\n                      price: item.unitPrice,\n                    },\n                  ]\n                : [],\n              modifierGroups: [], // Sin grupos de modificadores\n              photo: null,\n              subcategoryId: '',\n              createdAt: new Date(),\n              updatedAt: new Date(),\n            };\n\n            setEditingProduct(tempProduct);\n          }\n        };\n\n        if (item.preparationStatus === 'IN_PROGRESS') {\n          // Pedir confirmación para items en preparación\n          setModifyingItemName(item.productName);\n          setPendingModifyAction(() => proceedWithEdit);\n          setShowModifyInProgressConfirmation(true);\n        } else {\n          // Permitir editar items pendientes o cancelados sin confirmación\n          proceedWithEdit();\n        }\n      }\n    },\n    [isEditMode, onEditItem, menu, showSnackbar],\n  );\n\n  // Función para actualizar un item editado\n  const handleUpdateEditedItem = useCallback(\n    (\n      itemId: string,\n      quantity: number,\n      modifiers: CartItemModifier[],\n      preparationNotes?: string,\n      variantId?: string,\n      variantName?: string,\n      unitPrice?: number,\n    ) => {\n      if (!isEditMode) return;\n\n      setEditItems((prev) =>\n        prev.map((item) => {\n          if (item.id === itemId) {\n            const modifiersPrice = modifiers.reduce(\n              (sum, mod) => sum + Number(mod.price || 0),\n              0,\n            );\n            const finalUnitPrice =\n              unitPrice !== undefined ? unitPrice : item.unitPrice;\n            const newTotalPrice = (finalUnitPrice + modifiersPrice) * quantity;\n\n            return {\n              ...item,\n              quantity,\n              modifiers,\n              preparationNotes:\n                preparationNotes !== undefined\n                  ? preparationNotes\n                  : item.preparationNotes,\n              variantId: variantId !== undefined ? variantId : item.variantId,\n              variantName:\n                variantName !== undefined ? variantName : item.variantName,\n              unitPrice: finalUnitPrice,\n              totalPrice: newTotalPrice,\n            };\n          }\n          return item;\n        }),\n      );\n\n      // Cerrar el modal de edición\n      setEditingItemFromList(null);\n      setEditingProduct(null);\n    },\n    [isEditMode],\n  );\n\n  // Helper function to render fields in order\n  const renderFields = () => {\n    switch (orderType) {\n      case OrderTypeEnum.DINE_IN: // Usar Enum\n        return (\n          <>\n            {/* 1. Área */}\n            <View style={styles.dineInSelectorsRow}>\n              <View style={styles.dineInSelectorContainer}>\n                <Menu\n                  visible={areaMenuVisible}\n                  onDismiss={() => setAreaMenuVisible(false)}\n                  anchor={\n                    <AnimatedLabelSelector\n                      label=\"Área *\"\n                      value={selectedAreaName}\n                      onPress={() => setAreaMenuVisible(true)}\n                      isLoading={isLoadingAreas}\n                      error={!!areaError || !!errorAreas}\n                      disabled={isLoadingAreas}\n                    />\n                  }\n                >\n                  {areasData?.map((area: any) => (\n                    <Menu.Item\n                      key={area.id}\n                      onPress={() => {\n                        setSelectedAreaId(area.id);\n                        setSelectedTableId(null);\n                        setAreaMenuVisible(false);\n                        setAreaError(null);\n                      }}\n                      title={area.name}\n                    />\n                  ))}\n                  {errorAreas && (\n                    <Menu.Item title=\"Error al cargar áreas\" disabled />\n                  )}\n                </Menu>\n                {areaError && !errorAreas && (\n                  <HelperText\n                    type=\"error\"\n                    visible={true}\n                    style={styles.helperTextFix}\n                  >\n                    {areaError}\n                  </HelperText>\n                )}\n                {errorAreas && (\n                  <HelperText\n                    type=\"error\"\n                    visible={true}\n                    style={styles.helperTextFix}\n                  >\n                    Error al cargar áreas\n                  </HelperText>\n                )}\n              </View>\n\n              {/* 2. Mesa */}\n              <View style={styles.dineInSelectorContainer}>\n                <Menu\n                  visible={tableMenuVisible}\n                  onDismiss={() => setTableMenuVisible(false)}\n                  anchor={\n                    <AnimatedLabelSelector\n                      label=\"Mesa *\"\n                      value={selectedTableName}\n                      onPress={() => setTableMenuVisible(true)}\n                      isLoading={isLoadingTables}\n                      error={!!tableError || !!errorTables}\n                      disabled={\n                        !selectedAreaId || isLoadingTables || isLoadingAreas\n                      }\n                    />\n                  }\n                >\n                  {tablesData?.map((table: Table) => (\n                    <Menu.Item\n                      key={table.id}\n                      onPress={() => {\n                        setSelectedTableId(table.id);\n                        setTableMenuVisible(false);\n                        setTableError(null);\n                      }}\n                      title={table.name}\n                    />\n                  ))}\n                  {selectedAreaId &&\n                    tablesData?.length === 0 &&\n                    !isLoadingTables &&\n                    !errorTables && <Menu.Item title=\"No hay mesas\" disabled />}\n                  {errorTables && (\n                    <Menu.Item title=\"Error al cargar mesas\" disabled />\n                  )}\n                </Menu>\n                {tableError && !errorTables && (\n                  <HelperText\n                    type=\"error\"\n                    visible={true}\n                    style={styles.helperTextFix}\n                  >\n                    {tableError}\n                  </HelperText>\n                )}\n                {errorTables && (\n                  <HelperText\n                    type=\"error\"\n                    visible={true}\n                    style={styles.helperTextFix}\n                  >\n                    Error al cargar mesas\n                  </HelperText>\n                )}\n              </View>\n            </View>\n\n            {/* 3. Notas */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <SpeechRecognitionInput\n                key=\"notes-input-dine-in\"\n                label=\"Notas de la Orden (Opcional)\"\n                value={orderNotes}\n                onChangeText={setOrderNotes}\n                multiline\n                speechLang=\"es-MX\"\n              />\n            </View>\n\n            {/* 4. Programar Hora */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <AnimatedLabelSelector\n                label=\"Programar Hora (Opcional)\"\n                value={formattedScheduledTime}\n                onPress={showTimePicker}\n                onClear={() => setScheduledTime(null)}\n              />\n            </View>\n          </>\n        );\n      case OrderTypeEnum.TAKE_AWAY: // Usar Enum\n        return (\n          <>\n            {/* 1. Nombre Cliente */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <SpeechRecognitionInput\n                key={`customer-name-input-${orderType}`}\n                label=\"Nombre del Cliente *\"\n                value={deliveryInfo.recipientName || ''}\n                onChangeText={(text) => {\n                  setDeliveryInfo({ ...deliveryInfo, recipientName: text });\n                  if (customerNameError) setCustomerNameError(null);\n                }}\n                error={!!customerNameError}\n                speechLang=\"es-MX\"\n                autoCapitalize=\"words\"\n                autoCorrect={false}\n              />\n              {customerNameError && (\n                <HelperText\n                  type=\"error\"\n                  visible={true}\n                  style={styles.helperTextFix}\n                >\n                  {customerNameError}\n                </HelperText>\n              )}\n            </View>\n\n            {/* 2. Teléfono */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <View style={styles.phoneInputWrapper}>\n                <SpeechRecognitionInput\n                  key={`phone-input-takeaway-${orderType}`}\n                  label=\"Teléfono (Opcional)\"\n                  value={deliveryInfo.recipientPhone || ''}\n                  onChangeText={(text) => {\n                    setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });\n                    if (phoneError) setPhoneError(null);\n                  }}\n                  keyboardType=\"phone-pad\"\n                  error={!!phoneError} // Aunque opcional, puede tener errores de formato si se ingresa\n                  speechLang=\"es-MX\"\n                  autoCorrect={false}\n                />\n                {(deliveryInfo.recipientPhone || '').length > 0 &&\n                  !phoneError && (\n                    <Text style={styles.digitCounterAbsolute}>\n                      {\n                        (deliveryInfo.recipientPhone || '').replace(/\\D/g, '')\n                          .length\n                      }{' '}\n                      dígitos\n                    </Text>\n                  )}\n              </View>\n              {phoneError && (\n                <HelperText\n                  type=\"error\"\n                  visible={true}\n                  style={styles.helperTextFix}\n                >\n                  {phoneError}\n                </HelperText>\n              )}\n            </View>\n\n            {/* 3. Notas */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <SpeechRecognitionInput\n                key=\"notes-input-takeaway\"\n                label=\"Notas de la Orden (Opcional)\"\n                value={orderNotes}\n                onChangeText={setOrderNotes}\n                multiline\n                speechLang=\"es-MX\"\n              />\n            </View>\n\n            {/* 4. Programar Hora */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <AnimatedLabelSelector\n                label=\"Programar Hora Recolección (Opcional)\"\n                value={formattedScheduledTime}\n                onPress={showTimePicker}\n                onClear={() => setScheduledTime(null)}\n              />\n            </View>\n          </>\n        );\n      case OrderTypeEnum.DELIVERY: // Usar Enum\n        return (\n          <>\n            {/* 1. Nombre Cliente */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <SpeechRecognitionInput\n                key={`customer-name-input-delivery-${orderType}`}\n                label=\"Nombre del Cliente (Opcional)\"\n                value={deliveryInfo.recipientName || ''}\n                onChangeText={(text) => {\n                  setDeliveryInfo({ ...deliveryInfo, recipientName: text });\n                  if (customerNameError) setCustomerNameError(null);\n                }}\n                speechLang=\"es-MX\"\n                autoCapitalize=\"words\"\n                autoCorrect={false}\n              />\n            </View>\n\n            {/* 2. Dirección */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <SpeechRecognitionInput\n                key=\"address-input-delivery\"\n                label=\"Dirección de Entrega *\"\n                value={deliveryInfo.fullAddress || ''}\n                onChangeText={(text) => {\n                  setDeliveryInfo({ ...deliveryInfo, fullAddress: text });\n                  if (addressError) setAddressError(null);\n                }}\n                error={!!addressError}\n                speechLang=\"es-MX\"\n                multiline\n                isInModal={true}\n              />\n              {addressError && (\n                <HelperText\n                  type=\"error\"\n                  visible={true}\n                  style={styles.helperTextFix}\n                >\n                  {addressError}\n                </HelperText>\n              )}\n            </View>\n\n            {/* 3. Teléfono */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <SpeechRecognitionInput\n                key={`phone-input-delivery-${orderType}`} // Key única y específica\n                label=\"Teléfono *\"\n                value={deliveryInfo.recipientPhone || ''}\n                onChangeText={(text) => {\n                  // Asegurar que la función esté bien definida aquí\n                  setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });\n                  if (phoneError) {\n                    setPhoneError(null);\n                  }\n                }}\n                keyboardType=\"phone-pad\"\n                error={!!phoneError}\n                speechLang=\"es-MX\"\n                autoCorrect={false}\n              />\n              <View style={styles.phoneHelperContainer}>\n                {phoneError ? (\n                  <HelperText\n                    type=\"error\"\n                    visible={true}\n                    style={[styles.helperTextFix, styles.phoneError]}\n                  >\n                    {phoneError}\n                  </HelperText>\n                ) : (\n                  (deliveryInfo.recipientPhone || '').length > 0 && (\n                    <Text style={styles.digitCounter}>\n                      {\n                        (deliveryInfo.recipientPhone || '').replace(/\\D/g, '')\n                          .length\n                      }{' '}\n                      dígitos\n                    </Text>\n                  )\n                )}\n              </View>\n            </View>\n\n            {/* 4. Notas */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <SpeechRecognitionInput\n                key=\"notes-input-delivery\" // Key única y específica\n                label=\"Notas de la Orden (Opcional)\"\n                value={orderNotes}\n                onChangeText={setOrderNotes}\n                multiline\n                speechLang=\"es-MX\"\n              />\n            </View>\n\n            {/* 5. Programar Hora */}\n            <View style={[styles.sectionCompact, styles.fieldContainer]}>\n              <AnimatedLabelSelector\n                label=\"Programar Hora Entrega (Opcional)\"\n                value={formattedScheduledTime}\n                onPress={showTimePicker}\n                onClear={() => setScheduledTime(null)}\n              />\n            </View>\n          </>\n        );\n      default:\n        return null;\n    }\n  };\n\n  // Mostrar loading si estamos en modo edición y aún cargando\n  if (isEditMode && isLoadingOrder) {\n    return (\n      <Portal>\n        <Modal\n          visible={visible}\n          onDismiss={onClose}\n          contentContainerStyle={styles.modalContent}\n        >\n          <View style={[styles.container, styles.loadingContainer]}>\n            <ActivityIndicator size=\"large\" color={theme.colors.primary} />\n            <Text style={styles.loadingText}>Cargando orden...</Text>\n          </View>\n        </Modal>\n      </Portal>\n    );\n  }\n\n  // Mostrar error si falló la carga en modo edición\n  if (isEditMode && isErrorOrder) {\n    return (\n      <Portal>\n        <Modal\n          visible={visible}\n          onDismiss={onClose}\n          contentContainerStyle={styles.modalContent}\n        >\n          <View style={[styles.container, styles.errorContainer]}>\n            <Text style={styles.errorText}>Error al cargar la orden</Text>\n            <Button onPress={onClose}>Cerrar</Button>\n          </View>\n        </Modal>\n      </Portal>\n    );\n  }\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible}\n        onDismiss={() => {\n          if (isEditMode && hasUnsavedChanges) {\n            setShowExitConfirmation(true);\n          } else {\n            onClose?.();\n          }\n        }}\n        contentContainerStyle={styles.modalContent}\n        dismissable={true}\n        dismissableBackButton={false}\n      >\n        <GestureHandlerRootView style={styles.container}>\n          <TouchableWithoutFeedback\n            onPress={Keyboard.dismiss}\n            accessible={false}\n          >\n            <View>\n              {isEditMode ? (\n                <View style={styles.customHeader}>\n                  <IconButton\n                    icon=\"arrow-left\"\n                    size={24}\n                    onPress={() => {\n                      if (hasUnsavedChanges) {\n                        setShowExitConfirmation(true);\n                      } else {\n                        onClose?.();\n                      }\n                    }}\n                    iconColor={theme.colors.onSurface}\n                  />\n\n                  <Text style={styles.headerTitle}>\n                    {orderNumber && orderDate\n                      ? `Editar Orden #${orderNumber} - ${format(orderDate, 'dd/MM/yyyy', { locale: es })}`\n                      : orderNumber\n                        ? `Editando Orden #${orderNumber}`\n                        : 'Editar Orden'}\n                  </Text>\n\n                  <Menu\n                    visible={showOptionsMenu}\n                    onDismiss={() => setShowOptionsMenu(false)}\n                    anchor={\n                      <IconButton\n                        icon=\"dots-vertical\"\n                        size={24}\n                        onPress={() => setShowOptionsMenu(true)}\n                        iconColor={theme.colors.onSurface}\n                      />\n                    }\n                  >\n                    <Menu.Item\n                      onPress={() => {\n                        setShowOptionsMenu(false);\n                        setShowHistoryModal(true);\n                      }}\n                      title=\"Ver Historial\"\n                      leadingIcon=\"history\"\n                    />\n                    <Menu.Item\n                      onPress={() => {\n                        setShowOptionsMenu(false);\n                        setShowCancelConfirmation(true);\n                      }}\n                      title=\"Cancelar Orden\"\n                      leadingIcon=\"cancel\"\n                    />\n                  </Menu>\n                </View>\n              ) : (\n                <OrderHeader\n                  title={\n                    orderNumber ? `Orden #${orderNumber}` : 'Resumen de Orden'\n                  }\n                  onBackPress={() => onClose?.()}\n                  itemCount={totalItemsCount}\n                  onCartPress={() => {}}\n                  isCartVisible={isCartVisible}\n                />\n              )}\n            </View>\n          </TouchableWithoutFeedback>\n\n          <ScrollView\n            style={styles.scrollView}\n            keyboardShouldPersistTaps=\"handled\"\n            keyboardDismissMode=\"on-drag\"\n          >\n            {/* Order Type Selection */}\n            <View style={styles.sectionCompact}>\n              <RadioButton.Group\n                onValueChange={(newValue) =>\n                  setOrderType(newValue as OrderType)\n                }\n                value={orderType}\n              >\n                <View style={styles.radioGroupHorizontal}>\n                  <RadioButton.Item\n                    label=\"COMER AQUÍ\"\n                    value={OrderTypeEnum.DINE_IN} // Usar Enum\n                    style={styles.radioButtonItem}\n                    labelStyle={styles.radioLabel}\n                    position=\"leading\"\n                  />\n                  <RadioButton.Item\n                    label=\"PARA LLEVAR\"\n                    value={OrderTypeEnum.TAKE_AWAY} // Usar Enum\n                    style={styles.radioButtonItem}\n                    labelStyle={styles.radioLabel}\n                    position=\"leading\"\n                  />\n                  <RadioButton.Item\n                    label=\"DOMICILIO\"\n                    value={OrderTypeEnum.DELIVERY} // Usar Enum\n                    style={styles.radioButtonItem}\n                    labelStyle={styles.radioLabel}\n                    position=\"leading\"\n                  />\n                </View>\n              </RadioButton.Group>\n            </View>\n\n            {/* Render fields based on order type */}\n            {renderFields()}\n\n            <Divider style={styles.divider} />\n\n            {/* Cart Items */}\n            <List.Section>\n              {items.map((item) => {\n                // Crear función de renderizado de acción de eliminar\n                const renderRightActions = (progress, dragX) => {\n                  const translateX = dragX.interpolate({\n                    inputRange: [-100, 0],\n                    outputRange: [0, 100],\n                    extrapolate: 'clamp',\n                  });\n\n                  const scale = dragX.interpolate({\n                    inputRange: [-100, -50, 0],\n                    outputRange: [1, 0.8, 0.5],\n                    extrapolate: 'clamp',\n                  });\n\n                  const opacity = dragX.interpolate({\n                    inputRange: [-100, -20, 0],\n                    outputRange: [1, 0.5, 0],\n                    extrapolate: 'clamp',\n                  });\n\n                  return (\n                    <Animated.View\n                      style={[\n                        styles.deleteActionContainer,\n                        {\n                          opacity,\n                          transform: [{ translateX }],\n                        },\n                      ]}\n                    >\n                      <Animated.View\n                        style={[\n                          styles.deleteAction,\n                          {\n                            backgroundColor: theme.colors.error,\n                            transform: [{ scale }],\n                          },\n                        ]}\n                      >\n                        <View style={styles.deleteIconContainer}>\n                          <IconButton\n                            icon=\"delete-sweep\"\n                            size={28}\n                            iconColor=\"white\"\n                            style={styles.deleteIcon}\n                          />\n                        </View>\n                        <Text style={styles.deleteActionText}>ELIMINAR</Text>\n                      </Animated.View>\n                    </Animated.View>\n                  );\n                };\n\n                return (\n                  <Swipeable\n                    key={item.id}\n                    renderRightActions={renderRightActions}\n                    overshootRight={false}\n                    friction={2}\n                    rightThreshold={90}\n                    leftThreshold={100}\n                    onSwipeableOpen={(direction) => {\n                      if (direction === 'right') {\n                        // Pequeño delay para que se vea la animación completa\n                        setTimeout(() => {\n                          removeItem(item.id);\n                        }, 150);\n                      }\n                    }}\n                  >\n                    <TouchableOpacity\n                      onPress={() => handleEditCartItem(item)}\n                      disabled={!onEditItem && !isEditMode}\n                      activeOpacity={0.7}\n                    >\n                      <List.Item\n                        // Mover title y description a un View contenedor para controlar el ancho\n                        title={() => (\n                          <View style={styles.itemTextContainer}>\n                            <View>\n                              <Text style={styles.itemTitleText}>\n                                {`${item.quantity}x ${String(item.productName ?? '')}${item.variantName ? ` (${String(item.variantName ?? '')})` : ''}`}\n                              </Text>\n                              {/* Mostrar estado de preparación solo en modo edición - siempre en nueva línea */}\n                              {isEditMode && item.preparationStatus && (\n                                <View style={styles.statusContainer}>\n                                  <View\n                                    style={[\n                                      styles.statusBadge,\n                                      {\n                                        backgroundColor:\n                                          getPreparationStatusColor(\n                                            item.preparationStatus,\n                                            theme,\n                                          ) + '20',\n                                      },\n                                    ]}\n                                  >\n                                    <View\n                                      style={[\n                                        styles.statusDot,\n                                        {\n                                          backgroundColor:\n                                            getPreparationStatusColor(\n                                              item.preparationStatus,\n                                              theme,\n                                            ),\n                                        },\n                                      ]}\n                                    />\n                                    <Text\n                                      style={[\n                                        styles.statusText,\n                                        {\n                                          color: getPreparationStatusColor(\n                                            item.preparationStatus,\n                                            theme,\n                                          ),\n                                        },\n                                      ]}\n                                    >\n                                      {getPreparationStatusText(\n                                        item.preparationStatus,\n                                      )}\n                                    </Text>\n                                  </View>\n                                </View>\n                              )}\n                            </View>\n                            {(() => {\n                              // Render description condicionalmente\n                              const hasModifiers =\n                                item.modifiers && item.modifiers.length > 0;\n                              const hasNotes =\n                                item.preparationNotes &&\n                                item.preparationNotes.trim() !== '';\n\n                              if (hasModifiers && hasNotes) {\n                                return (\n                                  <View>\n                                    {item.modifiers.map((mod, index) => (\n                                      <Text\n                                        key={mod.id || index}\n                                        style={styles.itemDescription}\n                                      >\n                                        • {mod.name}{' '}\n                                        {mod.price && mod.price > 0\n                                          ? `(+$${mod.price.toFixed(2)})`\n                                          : ''}\n                                      </Text>\n                                    ))}\n                                    <Text\n                                      style={[\n                                        styles.itemDescription,\n                                        styles.notesText,\n                                      ]}\n                                    >\n                                      Notas: {item.preparationNotes}\n                                    </Text>\n                                  </View>\n                                );\n                              } else if (hasModifiers) {\n                                return (\n                                  <View>\n                                    {item.modifiers.map((mod, index) => (\n                                      <Text\n                                        key={mod.id || index}\n                                        style={styles.itemDescription}\n                                      >\n                                        • {mod.name}{' '}\n                                        {mod.price && mod.price > 0\n                                          ? `(+$${mod.price.toFixed(2)})`\n                                          : ''}\n                                      </Text>\n                                    ))}\n                                  </View>\n                                );\n                              } else if (hasNotes) {\n                                return (\n                                  <Text\n                                    style={[\n                                      styles.itemDescription,\n                                      styles.notesText,\n                                    ]}\n                                  >\n                                    Notas: {item.preparationNotes}\n                                  </Text>\n                                );\n                              } else {\n                                return null;\n                              }\n                            })()}\n                          </View>\n                        )}\n                        // titleNumberOfLines y description ya no se usan directamente aquí\n                        right={() => (\n                          // Usar paréntesis para retorno implícito si es una sola expresión\n                          <View style={styles.itemActionsContainer}>\n                            <View style={styles.quantityActions}>\n                              <IconButton\n                                icon=\"minus-circle-outline\"\n                                size={20} // Reducir tamaño de icono\n                                onPress={() =>\n                                  updateItemQuantity(item.id, item.quantity - 1)\n                                }\n                                style={styles.quantityButton}\n                                disabled={item.quantity <= 1} // Deshabilitar si es 1\n                              />\n                              <Text style={styles.quantityText}>\n                                {item.quantity}\n                              </Text>\n                              <IconButton\n                                icon=\"plus-circle-outline\"\n                                size={20} // Reducir tamaño de icono\n                                onPress={() =>\n                                  updateItemQuantity(item.id, item.quantity + 1)\n                                }\n                                style={styles.quantityButton}\n                              />\n                            </View>\n                            <View style={styles.priceContainer}>\n                              <Text style={styles.itemPrice}>\n                                ${Number(item.totalPrice || 0).toFixed(2)}\n                              </Text>\n                              {item.quantity > 1 && (\n                                <Text style={styles.unitPriceText}>\n                                  ($\n                                  {(\n                                    Number(item.unitPrice || 0) +\n                                    item.modifiers.reduce(\n                                      (sum, mod) =>\n                                        sum + Number(mod.price || 0),\n                                      0,\n                                    )\n                                  ).toFixed(2)}{' '}\n                                  c/u)\n                                </Text>\n                              )}\n                            </View>\n                          </View>\n                        )}\n                        style={styles.listItem}\n                      />\n                    </TouchableOpacity>\n                  </Swipeable>\n                );\n              })}\n\n              {/* Renderizar ajustes como OrderItems - dentro del mismo List.Section */}\n              {isEditMode &&\n                adjustments\n                  .filter((adj) => !adj.isDeleted)\n                  .map((adjustment, index) => {\n                    const renderRightActions = (progress, dragX) => {\n                      const translateX = dragX.interpolate({\n                        inputRange: [-100, 0],\n                        outputRange: [0, 100],\n                        extrapolate: 'clamp',\n                      });\n\n                      const scale = dragX.interpolate({\n                        inputRange: [-100, -50, 0],\n                        outputRange: [1, 0.8, 0.5],\n                        extrapolate: 'clamp',\n                      });\n\n                      const opacity = dragX.interpolate({\n                        inputRange: [-100, -20, 0],\n                        outputRange: [1, 0.5, 0],\n                        extrapolate: 'clamp',\n                      });\n\n                      return (\n                        <Animated.View\n                          style={[\n                            styles.deleteActionContainer,\n                            {\n                              opacity,\n                              transform: [{ translateX }],\n                            },\n                          ]}\n                        >\n                          <Animated.View\n                            style={[\n                              styles.deleteAction,\n                              {\n                                backgroundColor: theme.colors.error,\n                                transform: [{ scale }],\n                              },\n                            ]}\n                          >\n                            <View style={styles.deleteIconContainer}>\n                              <IconButton\n                                icon=\"delete-sweep\"\n                                size={28}\n                                iconColor=\"white\"\n                                style={styles.deleteIcon}\n                              />\n                            </View>\n                            <Text style={styles.deleteActionText}>\n                              ELIMINAR\n                            </Text>\n                          </Animated.View>\n                        </Animated.View>\n                      );\n                    };\n\n                    return (\n                      <Swipeable\n                        key={adjustment.id || `new-${index}`}\n                        renderRightActions={renderRightActions}\n                        overshootRight={false}\n                        friction={2}\n                        rightThreshold={90}\n                        leftThreshold={100}\n                        onSwipeableOpen={(direction) => {\n                          if (direction === 'right') {\n                            setTimeout(() => {\n                              if (adjustment.id) {\n                                handleRemoveAdjustment(adjustment.id);\n                              }\n                            }, 150);\n                          }\n                        }}\n                      >\n                        <TouchableOpacity\n                          onPress={() => {\n                            setAdjustmentToEdit(adjustment);\n                            setShowAdjustmentModal(true);\n                          }}\n                          activeOpacity={0.7}\n                        >\n                          <List.Item\n                            title={() => (\n                              <View style={styles.itemTextContainer}>\n                                <Text\n                                  style={[\n                                    styles.itemTitleText,\n                                    {\n                                      color:\n                                        adjustment.amount < 0\n                                          ? theme.colors.error\n                                          : theme.colors.primary,\n                                    },\n                                  ]}\n                                >\n                                  {adjustment.name}\n                                  {adjustment.isPercentage\n                                    ? ` (${adjustment.value}%)`\n                                    : ''}\n                                </Text>\n                              </View>\n                            )}\n                            right={() => (\n                              <View style={styles.itemActionsContainer}>\n                                <View style={styles.priceContainer}>\n                                  <Text\n                                    style={[\n                                      styles.itemPrice,\n                                      {\n                                        color:\n                                          adjustment.amount < 0\n                                            ? theme.colors.error\n                                            : theme.colors.primary,\n                                      },\n                                    ]}\n                                  >\n                                    {adjustment.amount < 0 ? '-' : '+'}$\n                                    {Math.abs(adjustment.amount || 0).toFixed(\n                                      2,\n                                    )}\n                                  </Text>\n                                </View>\n                              </View>\n                            )}\n                            style={styles.listItem}\n                          />\n                        </TouchableOpacity>\n                      </Swipeable>\n                    );\n                  })}\n            </List.Section>\n\n            {/* Botón de ajustes - Solo en modo edición */}\n            {isEditMode && (\n              <Button\n                onPress={() => setShowAdjustmentModal(true)}\n                mode=\"outlined\"\n                style={{\n                  marginTop: theme.spacing.m,\n                  marginBottom: theme.spacing.s,\n                }}\n                icon=\"calculator-variant\"\n              >\n                Ajustes\n              </Button>\n            )}\n\n            {/* Botón para añadir productos en modo edición */}\n            {isEditMode && (\n              <Button\n                onPress={() => {\n                  if (onAddProducts) {\n                    // Si tenemos un callback personalizado, usarlo\n                    onAddProducts();\n                  } else if (navigation && orderId && orderNumber) {\n                    // Si no, usar navegación directa\n                    try {\n                      navigation.navigate('AddProductsToOrder', {\n                        orderId,\n                        orderNumber,\n                        // Pasar el conteo de items existentes (no incluir los temporales \"NEW\")\n                        existingOrderItemsCount: editItems\n                          .filter((item) => !item.id.startsWith('new-'))\n                          .reduce((sum, item) => sum + item.quantity, 0),\n                        onProductsAdded: (newProducts: CartItem[]) => {\n                          // Marcar los nuevos productos con estado \"NEW\"\n                          const newProductsWithStatus = newProducts.map(\n                            (item) => ({\n                              ...item,\n                              preparationStatus: 'NEW' as const,\n                              id: `new-${Date.now()}-${Math.random()}`,\n                            }),\n                          );\n\n                          // Combinar con items existentes y agrupar\n                          const allItems = [\n                            ...editItems,\n                            ...newProductsWithStatus,\n                          ];\n                          const groupedItems = groupIdenticalItems(allItems);\n\n                          setEditItems(groupedItems);\n                          showSnackbar({\n                            message: `${newProducts.length} producto${newProducts.length > 1 ? 's' : ''} añadido${newProducts.length > 1 ? 's' : ''}`,\n                            type: 'success',\n                          });\n                        },\n                      });\n                    } catch (error) {\n                      console.error('Error al navegar:', error);\n                    }\n                  }\n                }}\n                mode=\"outlined\"\n                style={{\n                  marginTop: theme.spacing.m,\n                  marginBottom: theme.spacing.m,\n                }}\n                icon=\"plus-circle-outline\"\n              >\n                Añadir Productos\n              </Button>\n            )}\n\n            <Divider style={styles.divider} />\n\n            {/* Totals */}\n            <View style={styles.totalsContainer}>\n              <Text style={styles.totalsText}>Subtotal:</Text>\n              <Text style={styles.totalsValue}>${subtotal.toFixed(2)}</Text>\n            </View>\n            {isEditMode && totalAdjustments !== 0 && (\n              <View style={styles.totalsContainer}>\n                <Text style={styles.totalsText}>Ajustes:</Text>\n                <Text\n                  style={[\n                    styles.totalsValue,\n                    {\n                      color:\n                        totalAdjustments < 0\n                          ? theme.colors.error\n                          : theme.colors.primary,\n                    },\n                  ]}\n                >\n                  {totalAdjustments < 0 ? '-' : '+'}$\n                  {Math.abs(totalAdjustments).toFixed(2)}\n                </Text>\n              </View>\n            )}\n            <View style={styles.totalsContainer}>\n              <Text style={[styles.totalsText, styles.totalLabel]}>Total:</Text>\n              <Text style={[styles.totalsValue, styles.totalValue]}>\n                ${total.toFixed(2)}\n              </Text>\n            </View>\n\n            {/* Mostrar información de pagos solo en modo edición */}\n            {isEditMode && (\n              <>\n                <View style={styles.totalsContainer}>\n                  <Text style={styles.totalsText}>Pagado:</Text>\n                  <Text style={[styles.totalsValue, { color: '#4CAF50' }]}>\n                    ${totalPaid.toFixed(2)}\n                  </Text>\n                </View>\n                <View style={styles.totalsContainer}>\n                  <Text style={[styles.totalsText, { fontWeight: 'bold' }]}>\n                    Restante:\n                  </Text>\n                  <Text\n                    style={[\n                      styles.totalsValue,\n                      {\n                        fontWeight: 'bold',\n                        color:\n                          pendingAmount > 0 ? theme.colors.error : '#4CAF50',\n                      },\n                    ]}\n                  >\n                    ${pendingAmount.toFixed(2)}\n                  </Text>\n                </View>\n              </>\n            )}\n          </ScrollView>\n\n          {/* Footer Button */}\n          <View style={styles.footer}>\n            <Button\n              mode=\"contained\"\n              onPress={handleConfirm}\n              disabled={\n                isConfirming || // Deshabilitar mientras se procesa\n                items.length === 0 ||\n                (orderType === OrderTypeEnum.DINE_IN &&\n                  (!selectedAreaId || !selectedTableId)) || // Usar Enum\n                (orderType === OrderTypeEnum.TAKE_AWAY &&\n                  (!deliveryInfo.recipientName ||\n                    deliveryInfo.recipientName.trim() === '')) || // Usar Enum\n                (orderType === OrderTypeEnum.DELIVERY &&\n                  (!deliveryInfo.fullAddress ||\n                    deliveryInfo.fullAddress.trim() === '')) || // Usar Enum\n                (orderType === OrderTypeEnum.DELIVERY &&\n                  (!deliveryInfo.recipientPhone ||\n                    deliveryInfo.recipientPhone.trim() === '')) // Usar Enum\n              }\n              style={[\n                styles.confirmButton,\n                isEditMode &&\n                  hasUnsavedChanges && {\n                    backgroundColor: '#FF6B35', // Naranja vibrante para indicar acción requerida\n                  },\n              ]}\n              loading={isConfirming} // Mostrar indicador de carga\n            >\n              {isConfirming\n                ? isEditMode\n                  ? 'Guardando...'\n                  : 'Enviando...'\n                : isEditMode\n                  ? hasUnsavedChanges\n                    ? '⚠️ Guardar Cambios'\n                    : 'Guardar Cambios'\n                  : 'Enviar Orden'}\n            </Button>\n          </View>\n\n          {/* Modals */}\n          <Portal>\n            <Modal\n              visible={isTimePickerVisible}\n              onDismiss={hideTimePicker}\n              contentContainerStyle={styles.timePickerModal}\n            >\n              <Text variant=\"titleMedium\" style={styles.timePickerTitle}>\n                Seleccionar hora de entrega\n              </Text>\n              <TimePicker\n                hours={timePickerHours}\n                minutes={timePickerMinutes}\n                onHoursChange={setTimePickerHours}\n                onMinutesChange={setTimePickerMinutes}\n                locale=\"es\"\n              />\n              <View style={styles.timePickerButtons}>\n                <Button mode=\"text\" onPress={hideTimePicker}>\n                  Cancelar\n                </Button>\n                <Button mode=\"contained\" onPress={handleTimeConfirm}>\n                  Confirmar\n                </Button>\n              </View>\n            </Modal>\n          </Portal>\n\n          <ConfirmationModal\n            visible={isTimeAlertVisible}\n            title=\"Hora Inválida\"\n            message=\"No puedes seleccionar una hora que ya ha pasado. Por favor, elige una hora futura.\"\n            confirmText=\"Entendido\"\n            onConfirm={() => setTimeAlertVisible(false)}\n          />\n\n          {/* Modal de confirmación para descartar cambios */}\n          <ConfirmationModal\n            visible={showExitConfirmation}\n            title=\"¿Descartar cambios?\"\n            message=\"Tienes cambios sin guardar. ¿Estás seguro de que quieres salir?\"\n            confirmText=\"Descartar\"\n            cancelText=\"Cancelar\"\n            onConfirm={() => {\n              setShowExitConfirmation(false);\n              onClose?.();\n            }}\n            onCancel={() => setShowExitConfirmation(false)}\n          />\n\n          {/* Modal de confirmación para cancelar la orden */}\n          <ConfirmationModal\n            visible={showCancelConfirmation}\n            title=\"¿Cancelar orden?\"\n            message={`¿Estás seguro de que quieres cancelar la orden #${orderNumber}? Esta acción no se puede deshacer.`}\n            confirmText=\"Cancelar Orden\"\n            cancelText=\"No, mantener\"\n            onConfirm={() => {\n              setShowCancelConfirmation(false);\n              if (onCancelOrder) {\n                onCancelOrder();\n              }\n            }}\n            onCancel={() => setShowCancelConfirmation(false)}\n          />\n\n          {/* Modal de confirmación para modificar items en preparación */}\n          <ConfirmationModal\n            visible={showModifyInProgressConfirmation}\n            title=\"¿Modificar producto en preparación?\"\n            message={`El producto \"${modifyingItemName}\" está actualmente en preparación. ¿Estás seguro de que quieres modificarlo?`}\n            confirmText=\"Sí, modificar\"\n            cancelText=\"No, cancelar\"\n            onConfirm={() => {\n              setShowModifyInProgressConfirmation(false);\n              if (pendingModifyAction) {\n                pendingModifyAction();\n                setPendingModifyAction(null);\n              }\n              setModifyingItemName('');\n            }}\n            onCancel={() => {\n              setShowModifyInProgressConfirmation(false);\n              setPendingModifyAction(null);\n              setModifyingItemName('');\n            }}\n          />\n\n          {/* Modal de personalización de producto para edición */}\n          {isEditMode && editingProduct && editingItemFromList && (\n            <ProductCustomizationModal\n              visible={true}\n              product={editingProduct}\n              editingItem={editingItemFromList}\n              onDismiss={() => {\n                setEditingItemFromList(null);\n                setEditingProduct(null);\n              }}\n              onAddToCart={() => {}} // No usado en modo edición\n              onUpdateItem={handleUpdateEditedItem}\n            />\n          )}\n\n          {/* Modal de historial de cambios */}\n          {isEditMode && (\n            <OrderHistoryModal\n              visible={showHistoryModal}\n              onDismiss={() => setShowHistoryModal(false)}\n              orderId={orderId}\n              orderNumber={orderNumber}\n            />\n          )}\n\n          {/* FAB para pagos - solo en modo edición */}\n          {isEditMode && orderId && visible && (\n            <FAB\n              icon=\"cash-multiple\"\n              style={[\n                styles.paymentFab,\n                {\n                  backgroundColor: hasUnsavedChanges\n                    ? '#9CA3AF' // Gris sólido pero visible\n                    : pendingAmount <= 0\n                      ? '#4CAF50'\n                      : theme.colors.primary,\n                },\n              ]}\n              color=\"white\"\n              onPress={() => {\n                if (hasUnsavedChanges) {\n                  showSnackbar({\n                    message:\n                      'Debes guardar los cambios antes de registrar pagos',\n                    type: 'warning',\n                  });\n                } else {\n                  setShowPaymentModal(true);\n                }\n              }}\n              visible={true}\n            />\n          )}\n\n          {/* Modal de pagos */}\n          {showPaymentModal && isEditMode && orderId && (\n            <PaymentModal\n              visible={showPaymentModal}\n              onDismiss={() => setShowPaymentModal(false)}\n              orderId={orderId}\n              orderTotal={total}\n              orderNumber={orderNumber}\n              onOrderCompleted={() => {\n                // Cerrar el modal de pagos\n                setShowPaymentModal(false);\n                // Cerrar el modal de edición de orden\n                onClose?.();\n              }}\n            />\n          )}\n\n          {/* Modal de ajustes */}\n          {showAdjustmentModal && isEditMode && (\n            <AdjustmentFormModal\n              visible={showAdjustmentModal}\n              onDismiss={() => {\n                setShowAdjustmentModal(false);\n                setAdjustmentToEdit(null);\n              }}\n              onSave={(adjustment: OrderAdjustment) => {\n                if (adjustmentToEdit) {\n                  handleUpdateAdjustment(adjustmentToEdit.id!, adjustment);\n                } else {\n                  handleAddAdjustment(adjustment);\n                }\n                setShowAdjustmentModal(false);\n                setAdjustmentToEdit(null);\n              }}\n              adjustment={adjustmentToEdit}\n              orderSubtotal={subtotal}\n            />\n          )}\n        </GestureHandlerRootView>\n      </Modal>\n    </Portal>\n  );\n};\n\nconst createStyles = (theme: ReturnType<typeof useAppTheme>) =>\n  StyleSheet.create({\n    modalContent: {\n      backgroundColor: theme.colors.background,\n      width: '100%',\n      height: '100%',\n      margin: 0,\n      padding: 0,\n      position: 'absolute',\n      top: 0,\n      left: 0,\n    },\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    scrollView: {\n      flex: 1,\n      paddingHorizontal: theme.spacing.s, // Restaurar padding pequeño\n    },\n    divider: {\n      marginVertical: theme.spacing.s,\n    },\n    // List Item Styles\n    listItem: {\n      flexDirection: 'row', // 1) Fila\n      alignItems: 'center',\n      justifyContent: 'space-between', // 2) Separar título y acciones\n      paddingVertical: theme.spacing.s,\n      paddingHorizontal: theme.spacing.s, // controla el “gap” desde el borde\n      backgroundColor: theme.colors.surface,\n      minHeight: 80, // Altura mínima para mejor experiencia de swipe\n    },\n\n    itemTextContainer: {\n      // Contenedor para título y descripción\n      flex: 3, // Darle aún más espacio al texto ahora que no hay botón de eliminar\n      marginRight: theme.spacing.xs, // Pequeño margen para separar de las acciones\n      justifyContent: 'center', // Centrar texto verticalmente\n      // backgroundColor: 'lightyellow', // Debug\n    },\n    itemTitleText: {\n      // Estilo para el texto del título\n      fontSize: 15, // Aumentar tamaño del título\n      fontWeight: '500',\n      color: theme.colors.onSurface,\n      flexWrap: 'wrap', // Permitir que el texto se ajuste\n      lineHeight: 20, // Ajustar altura de línea\n    },\n    itemDescription: {\n      fontSize: 13, // Aumentar tamaño de descripción\n      color: theme.colors.onSurfaceVariant,\n      marginTop: 2,\n      flexWrap: 'wrap', // Permitir que el texto se ajuste\n      lineHeight: 18, // Ajustar altura de línea\n    },\n    itemActionsContainer: {\n      // Contenedor para acciones (cantidad, precio, borrar)\n      flexDirection: 'row',\n      alignItems: 'center',\n      justifyContent: 'flex-end',\n      flexShrink: 0, // No permitir que se encoja\n      // backgroundColor: 'lightblue', // Debug\n    },\n    quantityActions: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      // marginRight: theme.spacing.s, // Adjust spacing as needed\n    }, // <<< COMA RESTAURADA\n    // quantityButton: { // <<< ESTILO DUPLICADO/INCORRECTO ELIMINADO\n    //    margin: 0,\n    //    // backgroundColor: 'lightgreen',\n    // },\n    //   flexDirection: \"row\", // <<< CÓDIGO INCORRECTO ELIMINADO\n    //   alignItems: \"center\",\n    //   // marginRight: theme.spacing.xs,\n    // },\n    quantityButton: {\n      // <<< ESTILO CORRECTO\n      marginHorizontal: -4, // Reducir espacio horizontal entre botones\n      padding: 0, // Eliminar padding interno\n      // backgroundColor: 'lightgreen', // Debug\n    }, // <<< COMA RESTAURADA\n    quantityText: {\n      fontSize: 14, // Aumentar tamaño\n      fontWeight: 'bold',\n      minWidth: 20, // Ajustar ancho mínimo\n      textAlign: 'center',\n      marginHorizontal: 2, // Ajustar margen horizontal\n      // backgroundColor: 'pink', // Debug\n    }, // <<< COMA RESTAURADA\n    itemPrice: {\n      alignSelf: 'center',\n      marginRight: theme.spacing.xs, // Reducir espacio\n      color: theme.colors.onSurfaceVariant,\n      fontSize: 15, // Aumentar tamaño\n      fontWeight: 'bold',\n      minWidth: 55, // Ajustar ancho mínimo\n      textAlign: 'right',\n      // backgroundColor: 'lightcoral', // Debug\n    }, // <<< COMA RESTAURADA\n    priceContainer: {\n      flexDirection: 'column',\n      alignItems: 'flex-end',\n      marginRight: theme.spacing.xs,\n    },\n    unitPriceText: {\n      fontSize: 12,\n      color: theme.colors.onSurfaceVariant,\n      fontStyle: 'italic',\n    },\n    deleteActionContainer: {\n      width: 120,\n      height: '100%',\n      justifyContent: 'center',\n      alignItems: 'flex-end',\n      paddingRight: theme.spacing.m,\n    },\n    deleteAction: {\n      backgroundColor: theme.colors.error,\n      justifyContent: 'center',\n      alignItems: 'center',\n      width: 90,\n      height: '90%',\n      borderRadius: theme.roundness * 2,\n      flexDirection: 'column',\n      shadowColor: theme.colors.error,\n      shadowOffset: {\n        width: 0,\n        height: 2,\n      },\n      shadowOpacity: 0.25,\n      shadowRadius: 3.84,\n      elevation: 5,\n    },\n    deleteIconContainer: {\n      width: 50,\n      height: 50,\n      borderRadius: 25,\n      backgroundColor: 'rgba(255, 255, 255, 0.2)',\n      justifyContent: 'center',\n      alignItems: 'center',\n      marginBottom: 4,\n    },\n    deleteIcon: {\n      margin: 0,\n      padding: 0,\n    },\n    deleteActionText: {\n      color: 'white',\n      fontSize: 11,\n      fontWeight: '700',\n      letterSpacing: 1,\n      textTransform: 'uppercase',\n    }, // <<< COMA RESTAURADA\n    // End List Item Styles\n    totalsContainer: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      marginBottom: theme.spacing.xs,\n      paddingHorizontal: theme.spacing.xs,\n    }, // <<< COMA RESTAURADA\n    totalsText: {\n      fontSize: 16,\n    }, // <<< COMA RESTAURADA\n    totalsValue: {\n      fontSize: 16,\n      fontWeight: 'bold',\n    }, // <<< COMA RESTAURADA\n    totalLabel: {\n      fontWeight: 'bold',\n      fontSize: 18,\n    }, // <<< COMA RESTAURADA\n    totalValue: {\n      fontSize: 18,\n      color: theme.colors.primary,\n    }, // <<< COMA RESTAURADA\n    section: {\n      marginBottom: theme.spacing.m,\n      marginTop: theme.spacing.s,\n    }, // <<< COMA RESTAURADA\n    sectionCompact: {\n      marginBottom: 0,\n      paddingBottom: 0,\n    }, // <<< COMA RESTAURADA\n    dineInSelectorsRow: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      marginBottom: 0,\n      gap: theme.spacing.s,\n      marginTop: theme.spacing.s,\n    }, // <<< COMA RESTAURADA\n    dineInSelectorContainer: {\n      flex: 1,\n    }, // <<< COMA RESTAURADA\n    selectorLoader: {}, // <<< COMA RESTAURADA\n    sectionTitleContainer: {\n      flexDirection: 'row',\n      alignItems: 'baseline',\n      marginBottom: theme.spacing.xs,\n    }, // <<< COMA RESTAURADA\n    sectionTitle: {\n      fontSize: 16,\n      fontWeight: 'bold',\n      marginBottom: theme.spacing.xs,\n    }, // <<< COMA RESTAURADA\n    sectionTitleOptional: {\n      ...theme.fonts.bodySmall,\n      color: theme.colors.onSurfaceVariant,\n      marginLeft: theme.spacing.xs,\n    }, // <<< COMA RESTAURADA\n    radioGroupHorizontal: {\n      flexDirection: 'row',\n      justifyContent: 'space-around',\n      alignItems: 'center',\n      width: '100%',\n      paddingVertical: theme.spacing.xs,\n    }, // <<< COMA RESTAURADA\n    radioLabel: {\n      marginLeft: 0,\n      fontSize: 11,\n      textTransform: 'uppercase',\n      textAlign: 'center',\n    }, // <<< COMA RESTAURADA\n    radioButtonItem: {\n      paddingHorizontal: 0,\n      paddingVertical: 4,\n      flexShrink: 1,\n      flex: 1,\n      marginHorizontal: 2,\n    }, // <<< COMA RESTAURADA\n    dropdownAnchor: {}, // <<< COMA RESTAURADA\n    dropdownContent: {}, // <<< COMA RESTAURADA\n    dropdownLabel: {}, // <<< COMA RESTAURADA\n    helperTextFix: {\n      marginTop: -6,\n      marginBottom: 0,\n      paddingHorizontal: 12,\n    }, // <<< COMA RESTAURADA\n    footer: {\n      padding: theme.spacing.m,\n      borderTopWidth: 1,\n      borderTopColor: theme.colors.outlineVariant,\n      backgroundColor: theme.colors.surface,\n    }, // <<< COMA RESTAURADA\n    confirmButton: {\n      paddingVertical: theme.spacing.xs,\n    }, // <<< COMA RESTAURADA\n    input: {}, // <<< COMA RESTAURADA\n    fieldContainer: {\n      marginTop: theme.spacing.s,\n    },\n    loadingContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    loadingText: {\n      marginTop: theme.spacing.m,\n      color: theme.colors.onSurfaceVariant,\n    },\n    errorContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    errorText: {\n      color: theme.colors.error,\n      marginBottom: theme.spacing.m,\n    },\n    phoneHelperContainer: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'flex-start',\n      marginTop: 2,\n      paddingHorizontal: 12,\n      minHeight: 20,\n    },\n    phoneError: {\n      flex: 1,\n      marginBottom: 0,\n      marginTop: 0,\n    },\n    digitCounter: {\n      fontSize: 10,\n      color: theme.colors.onSurfaceVariant,\n      opacity: 0.6,\n      marginLeft: theme.spacing.xs,\n      marginTop: 2,\n    },\n    phoneInputWrapper: {\n      position: 'relative',\n    },\n    digitCounterAbsolute: {\n      position: 'absolute',\n      right: 50, // Mover más a la izquierda para evitar el botón de micrófono\n      top: 10, // Ajustar para estar en la parte superior del input\n      fontSize: 10,\n      color: theme.colors.onSurfaceVariant,\n      opacity: 0.7,\n      backgroundColor: theme.colors.background,\n      paddingHorizontal: 8,\n      paddingVertical: 3,\n      borderRadius: 12,\n      zIndex: 1,\n    },\n    notesText: {\n      fontStyle: 'italic',\n      marginTop: 4,\n      paddingTop: 4,\n      borderTopWidth: 1,\n      borderTopColor: theme.colors.outlineVariant,\n    },\n    customHeader: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      paddingHorizontal: 4,\n      paddingVertical: 8,\n      backgroundColor: theme.colors.elevation.level2,\n    },\n    headerTitle: {\n      ...theme.fonts.titleMedium,\n      color: theme.colors.onSurface,\n      fontWeight: 'bold',\n      textAlign: 'center',\n      flex: 1,\n    },\n    statusContainer: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      marginTop: 2, // Pequeño margen para separar del nombre\n      justifyContent: 'flex-start', // Alinear a la izquierda\n    },\n    statusBadge: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      paddingHorizontal: theme.spacing.s,\n      paddingVertical: 2, // Reducido de 4 a 2 para ser más compacto\n      borderRadius: 12,\n      gap: 4,\n    },\n    statusDot: {\n      width: 6,\n      height: 6,\n      borderRadius: 3,\n    },\n    statusText: {\n      fontSize: 11,\n      fontWeight: '600',\n      textTransform: 'uppercase',\n      letterSpacing: 0.5,\n    },\n    paymentFab: {\n      position: 'absolute',\n      margin: 16,\n      right: 0,\n      bottom: 140, // Más arriba para mejor visibilidad\n      zIndex: 1000,\n      elevation: 6,\n      width: 56, // Tamaño estándar para FAB pequeño\n      height: 56,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    timePickerModal: {\n      backgroundColor: theme.colors.surface,\n      padding: 20,\n      margin: 20,\n      borderRadius: 12,\n    },\n    timePickerTitle: {\n      textAlign: 'center',\n      marginBottom: 20,\n    },\n    timePickerButtons: {\n      flexDirection: 'row',\n      justifyContent: 'flex-end',\n      marginTop: 20,\n      gap: 10,\n    },\n  });\nexport default OrderCartDetail;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/OrderHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/OrderHistoryModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Card' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Chip' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":7}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useMemo, useState, useEffect } from 'react';\nimport {\n  View,\n  ScrollView,\n  StyleSheet,\n  FlatList,\n  ActivityIndicator,\n  TouchableOpacity,\n} from 'react-native';\nimport {\n  Modal,\n  Portal,\n  Text,\n  IconButton,\n  Card,\n  Divider,\n  Chip,\n  Button,\n} from 'react-native-paper';\nimport { format } from 'date-fns';\nimport { es } from 'date-fns/locale';\nimport { useAppTheme } from '@/app/styles/theme';\nimport { useInfiniteQuery } from '@tanstack/react-query';\nimport apiClient from '@/app/services/apiClient';\n\ninterface OrderHistory {\n  id: number;\n  orderId: string;\n  operation: 'INSERT' | 'UPDATE' | 'DELETE';\n  changedBy: string;\n  changedAt: string;\n  diff: Record<string, any> | null;\n  snapshot: Record<string, any>;\n  user?: {\n    firstName: string;\n    lastName: string;\n  };\n  changedByUser?: {\n    firstName: string;\n    lastName: string;\n  };\n}\n\ninterface OrderHistoryModalProps {\n  visible: boolean;\n  onDismiss: () => void;\n  orderId: string | null;\n  orderNumber?: number;\n}\n\n// Helper para formatear los cambios\nconst formatFieldName = (field: string): string => {\n  const fieldNames: Record<string, string> = {\n    orderStatus: 'Estado',\n    orderType: 'Tipo de orden',\n    tableId: 'Mesa',\n    table: 'Mesa',\n    customerName: 'Nombre del cliente',\n    phoneNumber: 'Teléfono',\n    deliveryAddress: 'Dirección de entrega',\n    notes: 'Notas',\n    total: 'Total',\n    subtotal: 'Subtotal',\n    scheduledAt: 'Hora programada',\n    items: 'Productos',\n    orderItems: 'Productos',\n    productId: 'Producto',\n    productVariantId: 'Variante',\n    quantity: 'Cantidad',\n    basePrice: 'Precio base',\n    finalPrice: 'Precio final',\n    preparationNotes: 'Notas de preparación',\n    preparationStatus: 'Estado de preparación',\n    modifiers: 'Modificadores',\n  };\n  return fieldNames[field] || field;\n};\n\n// Helper para formatear valores\nconst formatValue = (field: string, value: any): string => {\n  if (value === null || value === undefined) return 'Sin valor';\n\n  // Manejar específicamente el campo table/tableId\n  if (field === 'table' || field === 'tableId') {\n    if (typeof value === 'object' && value !== null) {\n      return value.name || 'Sin mesa';\n    }\n    return value || 'Sin mesa';\n  }\n\n  // Si es un objeto (como el problema de table), manejarlo especialmente\n  if (\n    typeof value === 'object' &&\n    !Array.isArray(value) &&\n    !(value instanceof Date)\n  ) {\n    if (value.name) return value.name;\n    if (value.id) return `ID: ${value.id}`;\n    return 'Sin valor';\n  }\n\n  if (field === 'orderStatus' || field === 'preparationStatus') {\n    const statusMap: Record<string, string> = {\n      PENDING: 'Pendiente',\n      IN_PROGRESS: 'En Progreso',\n      READY: 'Lista',\n      DELIVERED: 'Entregada',\n      COMPLETED: 'Completada',\n      CANCELLED: 'Cancelada',\n    };\n    return statusMap[value] || value;\n  }\n\n  if (field === 'orderType') {\n    const typeMap: Record<string, string> = {\n      DINE_IN: 'Para Comer Aquí',\n      TAKE_AWAY: 'Para Llevar',\n      DELIVERY: 'Domicilio',\n    };\n    return typeMap[value] || value;\n  }\n\n  if (\n    field === 'total' ||\n    field === 'subtotal' ||\n    field === 'basePrice' ||\n    field === 'finalPrice'\n  ) {\n    return `$${Number(value).toFixed(2)}`;\n  }\n\n  if (field === 'scheduledAt') {\n    return format(new Date(value), 'PPp', { locale: es });\n  }\n\n  return String(value);\n};\n\n// Componente separado para cada item del historial\nconst HistoryItem: React.FC<{\n  item: OrderHistory;\n  theme: ReturnType<typeof useAppTheme>;\n}> = ({ item, theme }) => {\n  const [expanded, setExpanded] = useState(false);\n  const styles = useMemo(() => createStyles(theme), [theme]);\n\n  // Función para obtener un resumen rápido de los cambios\n  const getChangeSummary = () => {\n    if (item.operation === 'INSERT') return 'Orden creada';\n    if (item.operation === 'DELETE') return 'Orden eliminada';\n\n    if (item.operation === 'UPDATE' && item.diff) {\n      const changes = [];\n      for (const [field, change] of Object.entries(item.diff || {})) {\n        if (field === 'total' && Array.isArray(change) && change.length >= 2) {\n          changes.push('Total actualizado');\n        } else if (\n          field === 'orderStatus' &&\n          Array.isArray(change) &&\n          change.length >= 2\n        ) {\n          changes.push('Estado cambiado');\n        } else if (field === 'orderItems' && typeof change === 'object') {\n          changes.push('Productos modificados');\n        } else if (\n          field === 'customerName' ||\n          field === 'phoneNumber' ||\n          field === 'deliveryAddress'\n        ) {\n          changes.push('Datos del cliente');\n        }\n      }\n      return changes.length > 0 ? changes.join(' • ') : 'Cambios en la orden';\n    }\n    return '';\n  };\n\n  const renderChanges = () => {\n    if (item.operation === 'INSERT') {\n      return <Text style={styles.changeText}>Se creó una nueva orden</Text>;\n    }\n\n    if (item.operation === 'DELETE') {\n      return <Text style={styles.changeText}>La orden fue eliminada</Text>;\n    }\n\n    if (item.operation === 'UPDATE' && item.diff) {\n      const changes = [];\n\n      // Procesar los cambios del diff\n      for (const [field, change] of Object.entries(item.diff || {})) {\n        // Manejar cambios en items (array de productos)\n        if (field === 'orderItems' && typeof change === 'object') {\n          const productDetails = [];\n\n          // Extraer información de productos del snapshot si está disponible\n          const currentItems = item.snapshot?.orderItems || [];\n\n          for (const [key, value] of Object.entries(change as any)) {\n            if (key === '_t' && value === 'a') continue; // Indicador de array\n\n            // Si es un número, es un índice de item\n            if (!isNaN(parseInt(key))) {\n              const itemIndex = parseInt(key);\n\n              // Verificar si es un item nuevo (array con un solo elemento)\n              if (\n                Array.isArray(value) &&\n                value.length === 1 &&\n                typeof value[0] === 'object'\n              ) {\n                // Es un item agregado\n                const newItem = value[0];\n                const productName = newItem.product?.name || 'Producto';\n                const quantity = newItem.quantity || 1;\n                const price = newItem.finalPrice || newItem.basePrice || 0;\n\n                productDetails.push(\n                  <View key={`item-${key}`} style={styles.changeRow}>\n                    <Text style={styles.changeLabel}>Añadido:</Text>\n                    <Text style={styles.changeValue}>\n                      {productName} x{quantity} (${price})\n                    </Text>\n                  </View>,\n                );\n              } else if (\n                Array.isArray(value) &&\n                value.length === 3 &&\n                value[1] === 0 &&\n                value[2] === 0\n              ) {\n                // Item eliminado\n                const removedItem = value[0];\n                const productName = removedItem?.product?.name || 'Producto';\n                productDetails.push(\n                  <View key={`item-${key}`} style={styles.changeRow}>\n                    <Text style={[styles.changeLabel, styles.removedLabel]}>\n                      Eliminado:\n                    </Text>\n                    <Text style={[styles.changeValue, styles.removedText]}>\n                      {productName}\n                    </Text>\n                  </View>,\n                );\n              } else if (typeof value === 'object' && value !== null) {\n                // Item modificado - buscar cambios específicos\n                const itemData = currentItems[itemIndex];\n                const itemChanges = [];\n\n                if ('quantity' in value && Array.isArray(value.quantity)) {\n                  itemChanges.push(\n                    `Cantidad: ${value.quantity[0]} → ${value.quantity[1]}`,\n                  );\n                }\n                if ('finalPrice' in value && Array.isArray(value.finalPrice)) {\n                  itemChanges.push(\n                    `Precio: $${value.finalPrice[0]} → $${value.finalPrice[1]}`,\n                  );\n                }\n\n                if (itemChanges.length > 0 && itemData?.product) {\n                  productDetails.push(\n                    <View key={`item-${key}`} style={styles.changeRow}>\n                      <Text style={styles.changeLabel}>Modificado:</Text>\n                      <View style={styles.changeValues}>\n                        <Text style={styles.changeValue}>\n                          {itemData.product.name}\n                        </Text>\n                        <Text style={styles.changeSubValue}>\n                          {itemChanges.join(', ')}\n                        </Text>\n                      </View>\n                    </View>,\n                  );\n                }\n              }\n            }\n          }\n\n          if (productDetails.length > 0) {\n            changes.push(\n              <View key={field} style={styles.changeSection}>\n                <Text style={styles.sectionTitle}>Productos</Text>\n                {productDetails}\n              </View>,\n            );\n          }\n        } else if (Array.isArray(change) && change.length >= 2) {\n          // Cambio normal de campo: [oldValue, newValue]\n          const oldValue = formatValue(field, change[0]);\n          const newValue = formatValue(field, change[1]);\n\n          changes.push(\n            <View key={field} style={styles.changeRow}>\n              <Text style={styles.changeLabel}>{formatFieldName(field)}:</Text>\n              <View style={styles.changeValues}>\n                <Text style={styles.oldValue}>{oldValue}</Text>\n                <Text style={styles.changeArrow}>→</Text>\n                <Text style={styles.newValue}>{newValue}</Text>\n              </View>\n            </View>,\n          );\n        } else if (Array.isArray(change) && change.length === 1) {\n          // Campo añadido (no existía antes)\n          const newValue = formatValue(field, change[0]);\n          changes.push(\n            <View key={field} style={styles.changeRow}>\n              <Text style={styles.changeLabel}>{formatFieldName(field)}:</Text>\n              <Text style={styles.newValue}>{newValue}</Text>\n            </View>,\n          );\n        } else if (\n          Array.isArray(change) &&\n          change.length === 3 &&\n          change[1] === 0 &&\n          change[2] === 0\n        ) {\n          // Campo eliminado\n          const oldValue = formatValue(field, change[0]);\n          changes.push(\n            <View key={field} style={styles.changeRow}>\n              <Text style={[styles.changeLabel, styles.removedLabel]}>\n                {formatFieldName(field)}:\n              </Text>\n              <Text style={styles.removedText}>{oldValue}</Text>\n            </View>,\n          );\n        }\n      }\n\n      return changes.length > 0 ? (\n        changes\n      ) : (\n        <Text style={styles.changeText}>Cambios en la orden</Text>\n      );\n    }\n\n    return null;\n  };\n\n  return (\n    <TouchableOpacity\n      onPress={() => setExpanded(!expanded)}\n      activeOpacity={0.7}\n      style={styles.historyCard}\n    >\n      <View style={styles.historyHeader}>\n        <View style={styles.historyInfo}>\n          <Text style={styles.changeSummary}>{getChangeSummary()}</Text>\n          <Text style={styles.historyMeta}>\n            {item.user\n              ? `${item.user.firstName} ${item.user.lastName}`\n              : item.changedByUser\n                ? `${item.changedByUser.firstName} ${item.changedByUser.lastName}`\n                : 'Sistema'}\n            {' • '}\n            {format(new Date(item.changedAt), 'HH:mm', { locale: es })}\n          </Text>\n        </View>\n        <Text style={styles.expandIcon}>{expanded ? '−' : '+'}</Text>\n      </View>\n\n      {expanded && (\n        <View style={styles.expandedContent}>\n          <Divider style={styles.divider} />\n          <View style={styles.changesContainer}>{renderChanges()}</View>\n        </View>\n      )}\n    </TouchableOpacity>\n  );\n};\n\nexport const OrderHistoryModal: React.FC<OrderHistoryModalProps> = ({\n  visible,\n  onDismiss,\n  orderId,\n  orderNumber,\n}) => {\n  const theme = useAppTheme();\n  const styles = useMemo(() => createStyles(theme), [theme]);\n\n  const {\n    data: orderHistoryData,\n    isError,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage,\n    refetch,\n    isLoading: isLoadingHistory,\n  } = useInfiniteQuery({\n    queryKey: ['orderHistory', orderId],\n    queryFn: async ({ pageParam = 1 }) => {\n      if (!orderId) throw new Error('No order ID');\n      const url = `/api/v1/orders/${orderId}/history`;\n\n      const response = await apiClient.get(url, { page: pageParam, limit: 20 });\n\n      if (!response.ok) {\n        throw new Error(response.problem || 'Error fetching history');\n      }\n\n      return response.data as { data: OrderHistory[]; hasNextPage: boolean };\n    },\n    getNextPageParam: (lastPage, allPages) => {\n      if (!lastPage) return undefined;\n      return lastPage.hasNextPage ? allPages.length + 1 : undefined;\n    },\n    enabled: visible && !!orderId,\n    initialPageParam: 1,\n  });\n\n  // Refrescar datos cuando se abre el modal\n  useEffect(() => {\n    if (visible && orderId) {\n      refetch();\n    }\n  }, [visible, orderId, refetch]);\n\n  // Aplanar todas las páginas de datos\n  const allHistoryItems = useMemo(() => {\n    if (!orderHistoryData?.pages) return [];\n    return orderHistoryData.pages.flatMap(\n      (page) => (page as { data: OrderHistory[] })?.data || [],\n    );\n  }, [orderHistoryData]);\n\n  const renderHistoryItem = useCallback(\n    ({ item }: { item: OrderHistory }) => {\n      return <HistoryItem item={item} theme={theme} />;\n    },\n    [theme],\n  );\n\n  const handleLoadMore = () => {\n    if (hasNextPage && !isFetchingNextPage) {\n      fetchNextPage();\n    }\n  };\n\n  const renderFooter = () => {\n    if (!isFetchingNextPage) return null;\n    return (\n      <View style={styles.loadingFooter}>\n        <ActivityIndicator size=\"small\" color={theme.colors.primary} />\n      </View>\n    );\n  };\n\n  const renderEmpty = () => (\n    <View style={styles.emptyContainer}>\n      <Text style={styles.emptyText}>No hay historial de cambios</Text>\n      <Text style={styles.emptySubText}>\n        Los cambios en la orden se registrarán aquí\n      </Text>\n    </View>\n  );\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible}\n        onDismiss={onDismiss}\n        contentContainerStyle={styles.modalContent}\n        dismissable={true}\n        dismissableBackButton={true}\n      >\n        <View style={styles.container}>\n          <View style={styles.header}>\n            <IconButton\n              icon=\"arrow-left\"\n              size={24}\n              onPress={onDismiss}\n              iconColor={theme.colors.onSurface}\n            />\n            <Text style={styles.headerTitle}>\n              Historial de Orden #{orderNumber || ''}\n            </Text>\n            <View style={{ width: 48 }} />\n          </View>\n\n          <Divider />\n\n          {/* Historial de la orden */}\n          {!orderId ? (\n            <View style={styles.errorContainer}>\n              <Text style={styles.errorText}>\n                No se pudo cargar el historial\n              </Text>\n              <Text style={styles.emptySubText}>ID de orden no disponible</Text>\n            </View>\n          ) : isLoadingHistory || !orderHistoryData ? (\n            <View style={styles.loadingContainer}>\n              <ActivityIndicator size=\"large\" color={theme.colors.primary} />\n              <Text style={styles.loadingText}>Cargando historial...</Text>\n            </View>\n          ) : isError ? (\n            <View style={styles.errorContainer}>\n              <Text style={styles.errorText}>Error al cargar el historial</Text>\n              <Button onPress={() => refetch()} mode=\"text\">\n                Reintentar\n              </Button>\n            </View>\n          ) : (\n            <FlatList\n              data={allHistoryItems}\n              renderItem={renderHistoryItem}\n              keyExtractor={(item) => item.id.toString()}\n              contentContainerStyle={styles.listContent}\n              onEndReached={handleLoadMore}\n              onEndReachedThreshold={0.5}\n              ListFooterComponent={renderFooter}\n              ListEmptyComponent={renderEmpty}\n              showsVerticalScrollIndicator={false}\n            />\n          )}\n        </View>\n      </Modal>\n    </Portal>\n  );\n};\n\nconst createStyles = (theme: ReturnType<typeof useAppTheme>) =>\n  StyleSheet.create({\n    modalContent: {\n      backgroundColor: theme.colors.background,\n      margin: 20,\n      borderRadius: theme.roundness * 2,\n      maxHeight: '90%',\n      minHeight: 400,\n    },\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    header: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      paddingHorizontal: 4,\n      paddingVertical: 8,\n      backgroundColor: theme.colors.elevation.level2,\n    },\n    headerTitle: {\n      ...theme.fonts.titleMedium,\n      fontWeight: 'bold',\n      textAlign: 'center',\n      flex: 1,\n      color: theme.colors.onSurface,\n    },\n    listContent: {\n      padding: theme.spacing.m,\n      paddingBottom: theme.spacing.l,\n    },\n    historyCard: {\n      backgroundColor: theme.colors.surface,\n      borderRadius: theme.roundness,\n      marginBottom: theme.spacing.s,\n      padding: theme.spacing.m,\n      borderWidth: 1,\n      borderColor: theme.colors.surfaceVariant,\n    },\n    historyHeader: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n    },\n    historyInfo: {\n      flex: 1,\n    },\n    changeSummary: {\n      ...theme.fonts.bodyLarge,\n      color: theme.colors.onSurface,\n      fontWeight: '500',\n    },\n    historyMeta: {\n      ...theme.fonts.bodySmall,\n      color: theme.colors.onSurfaceVariant,\n      marginTop: 4,\n    },\n    expandIcon: {\n      ...theme.fonts.titleLarge,\n      color: theme.colors.onSurfaceVariant,\n      marginLeft: theme.spacing.s,\n    },\n    expandedContent: {\n      marginTop: theme.spacing.s,\n    },\n    divider: {\n      marginBottom: theme.spacing.s,\n    },\n    changesContainer: {\n      gap: theme.spacing.xs,\n    },\n    changeText: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurfaceVariant,\n    },\n    changeSection: {\n      marginBottom: theme.spacing.s,\n    },\n    sectionTitle: {\n      ...theme.fonts.labelLarge,\n      fontWeight: '600',\n      color: theme.colors.onSurface,\n      marginBottom: theme.spacing.xs,\n    },\n    changeRow: {\n      flexDirection: 'row',\n      alignItems: 'flex-start',\n      marginBottom: theme.spacing.xs,\n      gap: theme.spacing.s,\n    },\n    changeLabel: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurfaceVariant,\n      minWidth: 100,\n    },\n    changeValue: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurface,\n      flex: 1,\n    },\n    changeValues: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      flex: 1,\n      gap: theme.spacing.xs,\n      flexWrap: 'wrap',\n    },\n    changeSubValue: {\n      ...theme.fonts.bodySmall,\n      color: theme.colors.onSurfaceVariant,\n      fontStyle: 'italic',\n    },\n    oldValue: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurfaceVariant,\n      textDecorationLine: 'line-through',\n      opacity: 0.7,\n    },\n    newValue: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurface,\n      fontWeight: '500',\n    },\n    changeArrow: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurfaceVariant,\n      paddingHorizontal: 4,\n    },\n    removedLabel: {\n      color: theme.colors.error,\n    },\n    removedText: {\n      textDecorationLine: 'line-through',\n      color: theme.colors.error,\n      opacity: 0.7,\n    },\n    loadingContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.xl,\n    },\n    loadingText: {\n      marginTop: theme.spacing.m,\n      color: theme.colors.onSurfaceVariant,\n    },\n    loadingFooter: {\n      padding: theme.spacing.m,\n      alignItems: 'center',\n    },\n    errorContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.xl,\n    },\n    errorText: {\n      color: theme.colors.error,\n      marginBottom: theme.spacing.m,\n    },\n    emptyContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.xl,\n    },\n    emptyText: {\n      ...theme.fonts.bodyLarge,\n      color: theme.colors.onSurfaceDisabled,\n      marginTop: theme.spacing.m,\n    },\n    emptySubText: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurfaceDisabled,\n      marginTop: theme.spacing.xs,\n      opacity: 0.7,\n    },\n  });\n\nexport default OrderHistoryModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/PaymentModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'KeyboardAvoidingView' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Platform' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Card' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Payment' is defined but never used. Allowed unused vars must match /^_/u.","line":30,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'paymentMethodIcons' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":58,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'updatePaymentMutation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":95,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":95,"endColumn":30}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo, useRef } from 'react';\nimport {\n  View,\n  ScrollView,\n  StyleSheet,\n  TouchableOpacity,\n  KeyboardAvoidingView,\n  Platform,\n  Keyboard,\n} from 'react-native';\nimport {\n  Modal,\n  Portal,\n  Text,\n  Button,\n  RadioButton,\n  TextInput,\n  HelperText,\n  Divider,\n  IconButton,\n  Chip,\n  Card,\n  ActivityIndicator,\n  Surface,\n} from 'react-native-paper';\nimport { useAppTheme, AppTheme } from '@/app/styles/theme';\nimport {\n  PaymentMethodEnum,\n  PaymentStatusEnum,\n  type Payment,\n  type PaymentMethod,\n} from '../types/payment.types';\nimport {\n  useGetPaymentsByOrderIdQuery,\n  useCreatePaymentMutation,\n  useUpdatePaymentMutation,\n  useDeletePaymentMutation,\n} from '../hooks/usePaymentQueries';\nimport { useCompleteOrderMutation } from '../hooks/useOrdersQueries';\nimport ConfirmationModal from '@/app/components/common/ConfirmationModal';\nimport ChangeCalculatorModal from './ChangeCalculatorModal';\n\ninterface PaymentModalProps {\n  visible: boolean;\n  onDismiss: () => void;\n  orderId: string;\n  orderTotal: number;\n  orderNumber?: number;\n  onOrderCompleted?: () => void; // Callback cuando se completa la orden\n}\n\nconst paymentMethodLabels: Record<PaymentMethod, string> = {\n  CASH: '💵 Efectivo',\n  CARD: '💳 Tarjeta',\n  TRANSFER: '📱 Transferencia',\n};\n\nconst paymentMethodIcons: Record<PaymentMethod, string> = {\n  CASH: 'cash',\n  CARD: 'credit-card',\n  TRANSFER: 'bank-transfer',\n};\n\n// Métodos de pago deshabilitados temporalmente\nconst disabledMethods: PaymentMethod[] = ['CARD', 'TRANSFER'];\n\nexport const PaymentModal: React.FC<PaymentModalProps> = ({\n  visible,\n  onDismiss,\n  orderId,\n  orderTotal,\n  orderNumber,\n  onOrderCompleted,\n}) => {\n  const theme = useAppTheme();\n  const styles = useMemo(() => createStyles(theme), [theme]);\n  const scrollViewRef = useRef<ScrollView>(null);\n  const amountInputRef = useRef<View>(null);\n\n  // Estado del formulario\n  const [selectedMethod, setSelectedMethod] = useState<PaymentMethod>(\n    PaymentMethodEnum.CASH,\n  );\n  const [amount, setAmount] = useState('');\n  const [showChangeCalculator, setShowChangeCalculator] = useState(false);\n  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);\n  const [paymentToDelete, setPaymentToDelete] = useState<string | null>(null);\n  const [keyboardVisible, setKeyboardVisible] = useState(false);\n  const [showFinalizeConfirm, setShowFinalizeConfirm] = useState(false);\n\n  // Queries y mutations\n  const { data: payments = [], isLoading: isLoadingPayments } =\n    useGetPaymentsByOrderIdQuery(orderId);\n  const createPaymentMutation = useCreatePaymentMutation();\n  const updatePaymentMutation = useUpdatePaymentMutation();\n  const deletePaymentMutation = useDeletePaymentMutation();\n  const completeOrderMutation = useCompleteOrderMutation();\n\n  // Calcular totales\n  const totalPaid = useMemo(() => {\n    return (payments || [])\n      .filter((p) => p.paymentStatus === PaymentStatusEnum.COMPLETED)\n      .reduce((sum, payment) => sum + (Number(payment.amount) || 0), 0);\n  }, [payments]);\n\n  const pendingAmount = orderTotal - totalPaid;\n  const isFullyPaid = pendingAmount <= 0;\n\n  // Resetear formulario cuando se abre el modal\n  useEffect(() => {\n    if (visible) {\n      setAmount(pendingAmount > 0 ? pendingAmount.toFixed(2) : '');\n      setShowChangeCalculator(false);\n      setSelectedMethod(PaymentMethodEnum.CASH);\n    }\n  }, [visible, pendingAmount]);\n\n  // Manejar el teclado\n  useEffect(() => {\n    const keyboardDidShowListener = Keyboard.addListener(\n      'keyboardDidShow',\n      () => {\n        setKeyboardVisible(true);\n        // Pequeño delay para asegurar que el layout esté actualizado\n        setTimeout(() => {\n          if (amountInputRef.current && scrollViewRef.current) {\n            amountInputRef.current.measureLayout(\n              scrollViewRef.current as any,\n              (x, y) => {\n                scrollViewRef.current?.scrollTo({ y: y - 50, animated: true });\n              },\n              () => {},\n            );\n          }\n        }, 100);\n      },\n    );\n\n    const keyboardDidHideListener = Keyboard.addListener(\n      'keyboardDidHide',\n      () => {\n        setKeyboardVisible(false);\n      },\n    );\n\n    return () => {\n      keyboardDidShowListener.remove();\n      keyboardDidHideListener.remove();\n    };\n  }, []);\n\n  const handleSubmit = async () => {\n    const parsedAmount = parseFloat(amount);\n\n    if (isNaN(parsedAmount) || parsedAmount <= 0) {\n      return;\n    }\n\n    // Si es efectivo, mostrar calculadora de cambio\n    if (selectedMethod === PaymentMethodEnum.CASH) {\n      setShowChangeCalculator(true);\n      return;\n    }\n\n    // Para otros métodos de pago, procesar directamente\n    await processPayment();\n  };\n\n  const processPayment = async () => {\n    const parsedAmount = parseFloat(amount);\n\n    try {\n      await createPaymentMutation.mutateAsync({\n        orderId,\n        paymentMethod: selectedMethod,\n        amount: parsedAmount,\n      });\n\n      // Resetear formulario\n      setAmount('');\n      setShowChangeCalculator(false);\n\n      // Si ya está totalmente pagado, cerrar el modal\n      if (pendingAmount - parsedAmount <= 0) {\n        onDismiss();\n      }\n    } catch (error) {\n      console.error('Error al crear pago:', error);\n    }\n  };\n\n  const handleDeletePayment = async () => {\n    if (!paymentToDelete) return;\n\n    try {\n      await deletePaymentMutation.mutateAsync(paymentToDelete);\n      setShowDeleteConfirm(false);\n      setPaymentToDelete(null);\n    } catch (error) {\n      console.error('Error al eliminar pago:', error);\n    }\n  };\n\n  const handleFinalizeOrder = async () => {\n    try {\n      await completeOrderMutation.mutateAsync(orderId);\n      setShowFinalizeConfirm(false);\n\n      // Llamar al callback si existe\n      if (onOrderCompleted) {\n        onOrderCompleted();\n      } else {\n        // Si no hay callback, solo cerrar el modal\n        onDismiss();\n      }\n    } catch (error) {\n      console.error('Error al finalizar orden:', error);\n    }\n  };\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case PaymentStatusEnum.COMPLETED:\n        return '#4CAF50';\n      case PaymentStatusEnum.PENDING:\n        return theme.colors.primary;\n      case PaymentStatusEnum.CANCELLED:\n        return theme.colors.error;\n      case PaymentStatusEnum.FAILED:\n        return theme.colors.error;\n      case PaymentStatusEnum.REFUNDED:\n        return '#FF9800';\n      default:\n        return theme.colors.onSurfaceVariant;\n    }\n  };\n\n  const getStatusText = (status: string) => {\n    switch (status) {\n      case PaymentStatusEnum.COMPLETED:\n        return 'Completado';\n      case PaymentStatusEnum.PENDING:\n        return 'Pendiente';\n      case PaymentStatusEnum.CANCELLED:\n        return 'Cancelado';\n      case PaymentStatusEnum.FAILED:\n        return 'Fallido';\n      case PaymentStatusEnum.REFUNDED:\n        return 'Reembolsado';\n      default:\n        return status;\n    }\n  };\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible && !showChangeCalculator}\n        onDismiss={onDismiss}\n        contentContainerStyle={styles.modalContainer}\n      >\n        <View style={styles.modalWrapper}>\n          <Surface style={styles.modalContent} elevation={3}>\n            {/* Header */}\n            <View style={styles.header}>\n              <View style={styles.headerTextContainer}>\n                <Text style={styles.title}>Pagos</Text>\n                {orderNumber && (\n                  <Text style={styles.orderNumber}>Orden #{orderNumber}</Text>\n                )}\n              </View>\n              <IconButton icon=\"close\" size={24} onPress={onDismiss} />\n            </View>\n\n            <Divider />\n\n            <ScrollView\n              ref={scrollViewRef}\n              style={[\n                styles.scrollView,\n                keyboardVisible && styles.scrollViewWithKeyboard,\n              ]}\n              contentContainerStyle={styles.scrollViewContent}\n              showsVerticalScrollIndicator={true}\n              keyboardShouldPersistTaps=\"handled\"\n              bounces={true}\n              nestedScrollEnabled={true}\n            >\n              {/* Resumen de pagos */}\n              <View style={styles.summaryContainer}>\n                <View style={styles.summaryItem}>\n                  <Text style={styles.summaryLabel}>Total</Text>\n                  <Text style={styles.summaryAmount}>\n                    ${orderTotal.toFixed(2)}\n                  </Text>\n                </View>\n                <View style={styles.summaryDividerVertical} />\n                <View style={styles.summaryItem}>\n                  <Text style={styles.summaryLabel}>Pagado</Text>\n                  <Text style={[styles.summaryAmount, { color: '#4CAF50' }]}>\n                    ${totalPaid.toFixed(2)}\n                  </Text>\n                </View>\n                <View style={styles.summaryDividerVertical} />\n                <View style={styles.summaryItem}>\n                  <Text style={[styles.summaryLabel, { fontWeight: 'bold' }]}>\n                    Pendiente\n                  </Text>\n                  <Text\n                    style={[\n                      styles.summaryAmount,\n                      {\n                        fontWeight: 'bold',\n                        color:\n                          pendingAmount > 0 ? theme.colors.error : '#4CAF50',\n                      },\n                    ]}\n                  >\n                    ${pendingAmount.toFixed(2)}\n                  </Text>\n                </View>\n              </View>\n\n              {/* Lista de pagos existentes */}\n              {isLoadingPayments ? (\n                <ActivityIndicator style={styles.loader} />\n              ) : (payments || []).length > 0 ? (\n                <View style={styles.paymentsSection}>\n                  <Text style={styles.sectionTitle}>Pagos registrados</Text>\n                  {(payments || []).map((payment) => (\n                    <View key={payment.id} style={styles.paymentItem}>\n                      <View style={styles.paymentLeftInfo}>\n                        <View style={styles.paymentMethodRow}>\n                          <Text style={styles.paymentMethodCompact}>\n                            {paymentMethodLabels[payment.paymentMethod]}\n                          </Text>\n                        </View>\n                        <Text style={styles.paymentDateCompact}>\n                          {new Date(payment.createdAt).toLocaleTimeString(\n                            'es-MX',\n                            {\n                              hour: '2-digit',\n                              minute: '2-digit',\n                            },\n                          )}\n                        </Text>\n                      </View>\n\n                      <View style={styles.paymentRightInfo}>\n                        <Text style={styles.paymentAmountCompact}>\n                          ${(Number(payment.amount) || 0).toFixed(2)}\n                        </Text>\n\n                        <Chip\n                          mode=\"flat\"\n                          style={[\n                            styles.statusChipCompact,\n                            {\n                              backgroundColor: getStatusColor(\n                                payment.paymentStatus,\n                              ),\n                            },\n                          ]}\n                          textStyle={styles.statusChipTextCompact}\n                        >\n                          {getStatusText(payment.paymentStatus)}\n                        </Chip>\n\n                        <IconButton\n                          icon=\"delete\"\n                          size={20}\n                          iconColor={theme.colors.error}\n                          onPress={() => {\n                            setPaymentToDelete(payment.id);\n                            setShowDeleteConfirm(true);\n                          }}\n                          disabled={deletePaymentMutation.isPending}\n                          style={styles.deleteIconButton}\n                        />\n                      </View>\n                    </View>\n                  ))}\n                </View>\n              ) : null}\n\n              {/* Formulario para nuevo pago */}\n              {!isFullyPaid && (\n                <View style={styles.formSection}>\n                  <Text style={styles.sectionTitle}>Registrar nuevo pago</Text>\n\n                  {/* Métodos de pago */}\n                  <View style={styles.methodsContainer}>\n                    {Object.entries(PaymentMethodEnum).map(([key, value]) => {\n                      const isDisabled = disabledMethods.includes(\n                        value as PaymentMethod,\n                      );\n                      return (\n                        <TouchableOpacity\n                          key={key}\n                          style={[\n                            styles.methodCard,\n                            selectedMethod === value &&\n                              styles.methodCardSelected,\n                            isDisabled && styles.methodCardDisabled,\n                          ]}\n                          onPress={() =>\n                            !isDisabled && setSelectedMethod(value)\n                          }\n                          disabled={isDisabled}\n                        >\n                          <RadioButton\n                            value={value}\n                            status={\n                              selectedMethod === value ? 'checked' : 'unchecked'\n                            }\n                            onPress={() =>\n                              !isDisabled && setSelectedMethod(value)\n                            }\n                            disabled={isDisabled}\n                          />\n                          <View style={styles.methodLabelContainer}>\n                            <Text\n                              style={[\n                                styles.methodText,\n                                selectedMethod === value &&\n                                  styles.methodTextSelected,\n                                isDisabled && styles.methodTextDisabled,\n                              ]}\n                            >\n                              {paymentMethodLabels[value]}\n                            </Text>\n                            {isDisabled && (\n                              <Text style={styles.comingSoonText}>\n                                Próximamente\n                              </Text>\n                            )}\n                          </View>\n                        </TouchableOpacity>\n                      );\n                    })}\n                  </View>\n\n                  {/* Campo de monto */}\n                  <View style={styles.amountContainer} ref={amountInputRef}>\n                    <View style={styles.amountRow}>\n                      <TextInput\n                        label=\"Monto a pagar\"\n                        value={amount}\n                        onChangeText={setAmount}\n                        keyboardType=\"decimal-pad\"\n                        mode=\"outlined\"\n                        left={<TextInput.Affix text=\"$\" />}\n                        style={styles.amountInput}\n                        error={\n                          amount !== '' &&\n                          (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)\n                        }\n                      />\n                      <Button\n                        mode=\"outlined\"\n                        onPress={() => setAmount(pendingAmount.toFixed(2))}\n                        style={styles.totalPendingButton}\n                        labelStyle={styles.totalPendingButtonLabel}\n                        contentStyle={styles.totalPendingButtonContent}\n                        compact\n                      >\n                        Total a pagar\n                      </Button>\n                    </View>\n                    <HelperText\n                      type=\"error\"\n                      visible={\n                        amount !== '' &&\n                        (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)\n                      }\n                    >\n                      Ingrese un monto válido\n                    </HelperText>\n\n                    {/* Botones de monto rápido */}\n                    {pendingAmount > 100 && (\n                      <View style={styles.quickAmounts}>\n                        <Button\n                          mode=\"outlined\"\n                          onPress={() => setAmount('100.00')}\n                          compact\n                          style={styles.quickAmountButton}\n                        >\n                          $100\n                        </Button>\n                        <Button\n                          mode=\"outlined\"\n                          onPress={() => setAmount('200.00')}\n                          compact\n                          style={styles.quickAmountButton}\n                        >\n                          $200\n                        </Button>\n                        <Button\n                          mode=\"outlined\"\n                          onPress={() => setAmount('500.00')}\n                          compact\n                          style={styles.quickAmountButton}\n                        >\n                          $500\n                        </Button>\n                      </View>\n                    )}\n                  </View>\n                </View>\n              )}\n            </ScrollView>\n\n            {/* Botones de acción */}\n            <View style={styles.footer}>\n              <Button\n                mode=\"outlined\"\n                onPress={onDismiss}\n                style={[styles.footerButton, styles.cancelButton]}\n                contentStyle={styles.footerButtonContent}\n              >\n                Cerrar\n              </Button>\n              {!isFullyPaid && (\n                <Button\n                  mode=\"contained\"\n                  onPress={handleSubmit}\n                  disabled={\n                    !amount ||\n                    isNaN(parseFloat(amount)) ||\n                    parseFloat(amount) <= 0 ||\n                    createPaymentMutation.isPending\n                  }\n                  loading={createPaymentMutation.isPending}\n                  style={styles.footerButton}\n                  contentStyle={styles.footerButtonContent}\n                >\n                  Registrar Pago\n                </Button>\n              )}\n              {isFullyPaid && (\n                <Button\n                  mode=\"contained\"\n                  onPress={() => setShowFinalizeConfirm(true)}\n                  disabled={completeOrderMutation.isPending}\n                  loading={completeOrderMutation.isPending}\n                  style={[styles.footerButton, { backgroundColor: '#10B981' }]}\n                  contentStyle={styles.footerButtonContent}\n                  icon=\"check-circle\"\n                >\n                  Finalizar Orden\n                </Button>\n              )}\n            </View>\n          </Surface>\n        </View>\n      </Modal>\n\n      {/* Modal de confirmación para eliminar */}\n      <ConfirmationModal\n        visible={showDeleteConfirm}\n        onDismiss={() => {\n          setShowDeleteConfirm(false);\n          setPaymentToDelete(null);\n        }}\n        onCancel={() => {\n          setShowDeleteConfirm(false);\n          setPaymentToDelete(null);\n        }}\n        onConfirm={handleDeletePayment}\n        title=\"Eliminar pago\"\n        message=\"¿Está seguro de que desea eliminar este pago? Esta acción no se puede deshacer.\"\n        confirmText=\"Sí, eliminar\"\n        cancelText=\"No, cancelar\"\n        confirmButtonColor={theme.colors.error}\n      />\n\n      {/* Modal de cálculo de cambio */}\n      <ChangeCalculatorModal\n        visible={showChangeCalculator}\n        onDismiss={() => {\n          setShowChangeCalculator(false);\n        }}\n        onConfirm={() => {\n          setShowChangeCalculator(false);\n          processPayment();\n        }}\n        amountToPay={parseFloat(amount) || 0}\n      />\n\n      {/* Modal de confirmación para finalizar orden */}\n      <ConfirmationModal\n        visible={showFinalizeConfirm}\n        onDismiss={() => setShowFinalizeConfirm(false)}\n        onCancel={() => setShowFinalizeConfirm(false)}\n        onConfirm={handleFinalizeOrder}\n        title=\"Finalizar orden\"\n        message={`¿Está seguro de que desea finalizar la orden #${orderNumber}? La orden se marcará como completada.`}\n        confirmText=\"Sí, finalizar\"\n        cancelText=\"No, cancelar\"\n        confirmButtonColor=\"#10B981\"\n      />\n    </Portal>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    modalContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.m,\n    },\n    modalWrapper: {\n      width: '100%',\n      maxWidth: 600,\n      maxHeight: '85%',\n    },\n    modalContent: {\n      borderRadius: theme.roundness * 2,\n      backgroundColor: theme.colors.surface,\n      width: '100%',\n      maxHeight: '100%',\n      overflow: 'hidden',\n    },\n    header: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      paddingHorizontal: theme.spacing.m,\n      paddingVertical: theme.spacing.xs,\n    },\n    headerTextContainer: {\n      flex: 1,\n    },\n    title: {\n      ...theme.fonts.headlineSmall,\n      color: theme.colors.onSurface,\n      fontWeight: 'bold',\n    },\n    orderNumber: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurfaceVariant,\n    },\n    scrollView: {\n      maxHeight: 500,\n    },\n    scrollViewContent: {\n      paddingBottom: theme.spacing.m,\n    },\n    scrollViewWithKeyboard: {\n      maxHeight: 250,\n    },\n    summaryContainer: {\n      flexDirection: 'row',\n      justifyContent: 'space-around',\n      alignItems: 'center',\n      backgroundColor: theme.colors.primaryContainer,\n      paddingVertical: theme.spacing.s,\n      paddingHorizontal: theme.spacing.m,\n      marginHorizontal: theme.spacing.m,\n      marginTop: theme.spacing.s,\n      marginBottom: theme.spacing.m,\n      borderRadius: theme.roundness,\n    },\n    summaryItem: {\n      flex: 1,\n      alignItems: 'center',\n    },\n    summaryLabel: {\n      ...theme.fonts.bodySmall,\n      color: theme.colors.onPrimaryContainer,\n      opacity: 0.8,\n      marginBottom: 2,\n    },\n    summaryAmount: {\n      ...theme.fonts.titleSmall,\n      fontWeight: 'bold',\n      color: theme.colors.onPrimaryContainer,\n    },\n    summaryDividerVertical: {\n      width: 1,\n      height: '80%',\n      backgroundColor: theme.colors.onPrimaryContainer,\n      opacity: 0.2,\n      marginHorizontal: theme.spacing.xs,\n    },\n    loader: {\n      marginVertical: theme.spacing.xl,\n    },\n    paymentsSection: {\n      paddingHorizontal: theme.spacing.m,\n      paddingBottom: theme.spacing.s,\n    },\n    sectionTitle: {\n      ...theme.fonts.titleSmall,\n      color: theme.colors.onSurface,\n      marginBottom: theme.spacing.xs,\n      fontWeight: '600',\n    },\n    paymentItem: {\n      backgroundColor: theme.colors.surfaceVariant,\n      borderRadius: theme.roundness,\n      padding: theme.spacing.xs,\n      marginBottom: theme.spacing.xs,\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n    },\n    paymentLeftInfo: {\n      flex: 1,\n    },\n    paymentRightInfo: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      gap: theme.spacing.xs,\n    },\n    paymentMethodRow: {\n      flexDirection: 'row',\n      alignItems: 'center',\n    },\n    paymentMethodCompact: {\n      ...theme.fonts.bodyMedium,\n      fontWeight: '500',\n      color: theme.colors.onSurface,\n    },\n    paymentAmountCompact: {\n      ...theme.fonts.bodyMedium,\n      fontWeight: 'bold',\n      color: theme.colors.primary,\n      minWidth: 70,\n      textAlign: 'right',\n    },\n    paymentDateCompact: {\n      ...theme.fonts.bodySmall,\n      color: theme.colors.onSurfaceVariant,\n      marginTop: 2,\n    },\n    statusChipCompact: {\n      height: 22,\n      minWidth: 80,\n    },\n    statusChipTextCompact: {\n      fontSize: 10,\n      fontWeight: '600',\n      color: 'white',\n      lineHeight: 12,\n    },\n    deleteIconButton: {\n      margin: 0,\n      width: 36,\n      height: 36,\n    },\n    formSection: {\n      paddingHorizontal: theme.spacing.m,\n      paddingBottom: theme.spacing.xs,\n    },\n    methodsContainer: {\n      marginBottom: theme.spacing.s,\n    },\n    methodCard: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      paddingVertical: theme.spacing.xs,\n      paddingHorizontal: theme.spacing.s,\n      marginBottom: theme.spacing.xs,\n      borderRadius: theme.roundness,\n      borderWidth: 1,\n      borderColor: theme.colors.outline,\n      backgroundColor: theme.colors.surface,\n    },\n    methodCardSelected: {\n      borderColor: theme.colors.primary,\n      backgroundColor: theme.colors.primaryContainer,\n    },\n    methodText: {\n      ...theme.fonts.bodyLarge,\n      color: theme.colors.onSurface,\n      marginLeft: theme.spacing.xs,\n    },\n    methodTextSelected: {\n      color: theme.colors.onPrimaryContainer,\n      fontWeight: '500',\n    },\n    methodCardDisabled: {\n      opacity: 0.5,\n      borderColor: theme.colors.outlineVariant,\n    },\n    methodLabelContainer: {\n      flex: 1,\n      marginLeft: theme.spacing.xs,\n    },\n    methodTextDisabled: {\n      color: theme.colors.onSurfaceDisabled,\n    },\n    comingSoonText: {\n      ...theme.fonts.bodySmall,\n      color: theme.colors.onSurfaceVariant,\n      fontStyle: 'italic',\n      marginTop: 2,\n    },\n    amountContainer: {\n      marginTop: theme.spacing.s,\n    },\n    amountRow: {\n      flexDirection: 'row',\n      gap: theme.spacing.xs,\n      alignItems: 'flex-start',\n    },\n    amountInput: {\n      backgroundColor: theme.colors.surface,\n      flex: 1,\n    },\n    totalPendingButton: {\n      marginTop: 4, // Alinear con el input que tiene un label\n      height: 56, // Misma altura que el TextInput con outlined\n      borderColor: theme.colors.primary,\n      justifyContent: 'center',\n    },\n    totalPendingButtonContent: {\n      height: '100%',\n      paddingVertical: 0,\n      paddingHorizontal: theme.spacing.s,\n    },\n    totalPendingButtonLabel: {\n      fontSize: 13,\n      lineHeight: 20,\n      textAlignVertical: 'center',\n    },\n    quickAmounts: {\n      flexDirection: 'row',\n      flexWrap: 'wrap',\n      gap: theme.spacing.s,\n      marginTop: theme.spacing.xs,\n    },\n    quickAmountButton: {\n      borderColor: theme.colors.primary,\n    },\n    footer: {\n      flexDirection: 'row',\n      justifyContent: 'center',\n      alignItems: 'center',\n      gap: theme.spacing.m,\n      paddingHorizontal: theme.spacing.m,\n      paddingVertical: theme.spacing.m,\n      paddingTop: theme.spacing.s,\n      backgroundColor: theme.colors.surface,\n      borderTopWidth: 1,\n      borderTopColor: theme.colors.outlineVariant,\n    },\n    footerButton: {\n      minWidth: 120,\n    },\n    footerButtonContent: {\n      height: 40,\n    },\n    cancelButton: {\n      borderColor: theme.colors.outline,\n    },\n  });\n\nexport default PaymentModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/PrinterSelectionModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Text' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ActivityIndicator' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getApiErrorMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":39,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'refetch' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":40,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":12}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\nimport { View, StyleSheet, FlatList, ListRenderItemInfo } from 'react-native';\nimport {\n  Modal,\n  Portal,\n  Text,\n  Button,\n  List,\n  Divider,\n  ActivityIndicator,\n  Appbar,\n} from 'react-native-paper';\nimport { useAppTheme, AppTheme } from '../../../app/styles/theme';\nimport { usePrintersQuery } from '../../printers/hooks/usePrintersQueries';\nimport type { ThermalPrinter } from '../../printers/types/printer.types';\nimport { getApiErrorMessage } from '../../../app/lib/errorMapping';\nimport { useListState } from '../../../app/hooks/useListState';\n\ninterface PrinterSelectionModalProps {\n  visible: boolean;\n  onDismiss: () => void;\n  onPrinterSelect: (printer: ThermalPrinter) => void;\n  title?: string;\n}\n\nconst PrinterSelectionModal: React.FC<PrinterSelectionModalProps> = ({\n  visible,\n  onDismiss,\n  onPrinterSelect,\n  title = 'Seleccionar Impresora',\n}) => {\n  const theme = useAppTheme();\n  const styles = useMemo(() => createStyles(theme), [theme]);\n\n  const {\n    data: printersResponse,\n    isLoading,\n    isError,\n    error,\n    refetch,\n  } = usePrintersQuery(\n    { isActive: true, limit: 100, page: 1 },\n    { enabled: visible },\n  );\n\n  const printers = useMemo(\n    () => printersResponse?.data ?? [],\n    [printersResponse],\n  );\n\n  const renderPrinterItem = ({ item }: ListRenderItemInfo<ThermalPrinter>) => (\n    <List.Item\n      title={item.name}\n      description={`Tipo: ${item.connectionType}${item.ipAddress ? ` - IP: ${item.ipAddress}` : ''}`}\n      left={(props) => <List.Icon {...props} icon=\"printer\" />}\n      onPress={() => onPrinterSelect(item)}\n      style={styles.listItem}\n      titleStyle={styles.itemTitle}\n      descriptionStyle={styles.itemDescription}\n    />\n  );\n\n  const { ListEmptyComponent } = useListState({\n    isLoading,\n    isError,\n    data: printers,\n    emptyConfig: {\n      title: 'No hay impresoras activas',\n      message: 'No hay impresoras activas configuradas.',\n      icon: 'printer-off',\n    },\n  });\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible}\n        onDismiss={onDismiss}\n        contentContainerStyle={styles.modalContent}\n      >\n        <Appbar.Header style={styles.appBar} elevated>\n          <Appbar.BackAction\n            onPress={onDismiss}\n            color={theme.colors.onSurface}\n          />\n          <Appbar.Content title={title} titleStyle={styles.appBarTitle} />\n        </Appbar.Header>\n\n        <FlatList\n          data={printers}\n          renderItem={renderPrinterItem}\n          keyExtractor={(item: ThermalPrinter) => item.id}\n          ItemSeparatorComponent={() => <Divider style={styles.divider} />}\n          contentContainerStyle={styles.listContentContainer}\n          ListEmptyComponent={ListEmptyComponent}\n        />\n      </Modal>\n    </Portal>\n  );\n};\n\n// --- Estilos ---\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    modalContent: {\n      backgroundColor: theme.colors.background,\n      width: '90%',\n      maxHeight: '70%',\n      alignSelf: 'center',\n      borderRadius: theme.roundness * 2,\n      elevation: 5,\n      overflow: 'hidden',\n      display: 'flex',\n      flexDirection: 'column',\n    },\n    appBar: {\n      backgroundColor: theme.colors.elevation.level2,\n    },\n    appBarTitle: {\n      ...theme.fonts.titleMedium,\n      color: theme.colors.onSurface,\n      fontWeight: 'bold',\n    },\n    listContentContainer: {\n      paddingBottom: theme.spacing.m,\n      flexGrow: 1,\n    },\n    centeredView: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.l,\n      minHeight: 150,\n    },\n    statusText: {\n      marginTop: theme.spacing.m,\n      fontSize: 16,\n      textAlign: 'center',\n      color: theme.colors.onSurfaceVariant,\n    },\n    errorText: {\n      marginTop: theme.spacing.m,\n      color: theme.colors.error,\n      textAlign: 'center',\n      marginBottom: theme.spacing.m,\n    },\n    listItem: {\n      backgroundColor: theme.colors.surface,\n      paddingHorizontal: theme.spacing.m,\n    },\n    itemTitle: {\n      fontWeight: '500',\n    },\n    itemDescription: {\n      fontSize: 12,\n      color: theme.colors.onSurfaceVariant,\n    },\n    divider: {\n      height: StyleSheet.hairlineWidth,\n      backgroundColor: theme.colors.outlineVariant,\n      marginHorizontal: theme.spacing.m,\n    },\n  });\n\nexport default PrinterSelectionModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/ProductCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useTheme' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { Card, Title, Paragraph, Text, useTheme } from 'react-native-paper';\nimport { Image } from 'expo-image';\nimport { getImageUrl } from '@/app/lib/imageUtils';\nimport type { Product } from '../../../app/schemas/domain/product.schema';\nimport type { ProductVariant } from '../../../app/schemas/domain/product-variant.schema';\nimport { useAppTheme } from '@/app/styles/theme';\n\ninterface ProductCardProps {\n  product: Product;\n  onPress: (product: Product) => void;\n}\n\nconst ProductCard = ({ product, onPress }: ProductCardProps) => {\n  const theme = useAppTheme();\n\n  const styles = StyleSheet.create({\n    productCard: {\n      marginVertical: 8,\n      marginHorizontal: 12,\n      overflow: 'hidden',\n      opacity: product.isActive ? 1 : 0.6,\n    },\n    productImage: {\n      width: '100%',\n      height: 150,\n    },\n    productImagePlaceholder: {\n      width: '100%',\n      height: 150,\n      backgroundColor: theme.colors.surfaceVariant,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    productPlaceholderText: {\n      fontSize: 40,\n      fontWeight: 'bold',\n      color: theme.colors.onSurfaceVariant,\n    },\n    productTitle: {\n      fontSize: 16,\n      fontWeight: '700',\n    },\n    productPrice: {\n      fontSize: 16,\n      color: theme.colors.primary,\n      fontWeight: '600',\n    },\n    productDescription: {\n      fontSize: 14,\n      color: theme.colors.onSurfaceVariant,\n      marginTop: 4,\n    },\n    variantsText: {\n      color: theme.colors.primary,\n      fontStyle: 'italic',\n      marginTop: 4,\n    },\n    inactiveOverlay: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      backgroundColor: 'rgba(0, 0, 0, 0.3)',\n      justifyContent: 'center',\n      alignItems: 'center',\n      zIndex: 10,\n    },\n    inactiveText: {\n      color: 'white',\n      fontSize: 18,\n      fontWeight: 'bold',\n      backgroundColor: 'rgba(0, 0, 0, 0.7)',\n      paddingHorizontal: 16,\n      paddingVertical: 8,\n      borderRadius: 4,\n    },\n  });\n\n  const productImageUrl = product.photo\n    ? getImageUrl(product.photo.path)\n    : null;\n\n  const blurhash =\n    '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';\n\n  return (\n    <Card\n      key={product.id}\n      style={styles.productCard}\n      onPress={() => product.isActive && onPress(product)}\n      disabled={!product.isActive}\n    >\n      {!product.isActive && (\n        <View style={styles.inactiveOverlay}>\n          <Text style={styles.inactiveText}>NO DISPONIBLE</Text>\n        </View>\n      )}\n      {productImageUrl ? (\n        <Image\n          source={{ uri: productImageUrl }}\n          style={styles.productImage}\n          contentFit=\"cover\"\n          placeholder={blurhash}\n          transition={300}\n        />\n      ) : (\n        <View style={styles.productImagePlaceholder}>\n          <Text style={styles.productPlaceholderText}>\n            {product.name.charAt(0).toUpperCase()}\n          </Text>\n        </View>\n      )}\n\n      <Card.Content>\n        <Title style={styles.productTitle}>{product.name}</Title>\n        {/* Acceso seguro a las propiedades */}\n        {!product.hasVariants &&\n          product.price !== null &&\n          product.price !== undefined && (\n            <Text style={styles.productPrice}>\n              ${Number(product.price).toFixed(2)}\n            </Text>\n          )}\n        {product.hasVariants &&\n          product.variants &&\n          product.variants.length > 0 && (\n            <Text style={styles.variantsText}>\n              Desde $\n              {Math.min(\n                ...product.variants.map((v: ProductVariant) =>\n                  Number(v.price ?? 0),\n                ),\n              ).toFixed(2)}\n            </Text>\n          )}\n        {product.description && (\n          <Paragraph style={styles.productDescription} numberOfLines={2}>\n            {product.description}\n          </Paragraph>\n        )}\n      </Card.Content>\n    </Card>\n  );\n};\n\nexport default ProductCard;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/ProductCustomizationModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/components/SimpleProductDescriptionModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/context/CartContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/hooks/useAdjustmentQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/hooks/useMenuQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/hooks/useOrdersQueries.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'queryClient' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":33,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'showSnackbar' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":34,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":21},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":42,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":42,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1924,1984],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'message' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":48,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'variables' is defined but never used. Allowed unused args must match /^_/u.","line":68,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":40}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from 'react'; // Importar useMemo\n\nimport {\n  useMutation,\n  useQuery,\n  useQueryClient,\n  UseQueryResult,\n} from '@tanstack/react-query'; // Añadir useQueries y QueryObserverResult\nimport { orderService } from '../services/orderService';\nimport type { Order } from '../../../app/schemas/domain/order.schema'; // Ruta corregida\nimport type { OrderDetailsForBackend } from '../components/OrderCartDetail';\nimport type { FindAllOrdersDto } from '../types/orders.types';\nimport type { PaginatedResponse } from '../../../app/types/api.types'; // Corregir ruta relativa\nimport { ApiError } from '@/app/lib/errors';\nimport { useSnackbarStore } from '@/app/store/snackbarStore';\nimport { getApiErrorMessage } from '@/app/lib/errorMapping';\nimport type { UpdateOrderPayload } from '../types/update-order.types'; // Importar payload\n\n// --- Query Keys (si se necesitan queries futuras para órdenes) ---\nconst orderKeys = {\n  all: ['orders'] as const,\n  lists: () => [...orderKeys.all, 'list'] as const,\n  list: (filters: FindAllOrdersDto) => [...orderKeys.lists(), filters] as const,\n  openToday: () => [...orderKeys.all, 'list', 'open-today'] as const, // Nueva clave para órdenes abiertas del día\n  details: () => [...orderKeys.all, 'detail'] as const,\n  // detail: (id: string) => [...orderKeys.details(), id] as const, // Ejemplo\n};\n\n/**\n * Hook para crear una nueva orden.\n */\nexport const useCreateOrderMutation = () => {\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  return useMutation<Order, ApiError, OrderDetailsForBackend>({\n    mutationFn: orderService.createOrder,\n    onSuccess: (newOrder) => {\n      // Invalidar queries relevantes si es necesario (ej. lista de órdenes)\n      // queryClient.invalidateQueries({ queryKey: orderKeys.lists() });\n      // El mensaje de éxito se maneja en el componente que llama a la mutación\n      console.log('Orden creada con éxito en backend:', newOrder);\n    },\n    onError: (error) => {\n      // El mensaje de error se maneja en el componente que llama a la mutación\n      // Pero podemos loguearlo aquí también\n      console.error('Error en useCreateOrderMutation:', error);\n      const message = getApiErrorMessage(error);\n      // Opcional: Mostrar snackbar genérico desde aquí si se prefiere\n      // showSnackbar({ message: `Error al crear orden: ${message}`, type: 'error' });\n    },\n  });\n};\n\n/**\n * Hook para actualizar una orden existente.\n */\nexport const useUpdateOrderMutation = () => {\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  // Definir el tipo de las variables de la mutación\n  type UpdateVariables = { orderId: string; payload: UpdateOrderPayload };\n\n  return useMutation<Order, ApiError, UpdateVariables>({\n    mutationFn: ({ orderId, payload }) =>\n      orderService.updateOrder(orderId, payload),\n    onSuccess: (updatedOrder, variables) => {\n      // Invalidar queries relevantes para refrescar datos\n      queryClient.invalidateQueries({ queryKey: orderKeys.lists() }); // Invalida todas las listas\n      queryClient.invalidateQueries({ queryKey: orderKeys.openToday() }); // Invalida la lista de órdenes abiertas\n      // Opcional: invalidar detalle específico si se implementa query de detalle\n      // queryClient.invalidateQueries({ queryKey: orderKeys.detail(variables.orderId) });\n\n      showSnackbar({\n        message: `Orden #${updatedOrder.dailyNumber} actualizada`,\n        type: 'success',\n      });\n    },\n    onError: (error, variables) => {\n      const message = getApiErrorMessage(error);\n      showSnackbar({\n        message: `Error al actualizar orden #${variables.orderId}: ${message}`,\n        type: 'error',\n      });\n      console.error(`Error updating order ${variables.orderId}:`, error);\n    },\n  });\n};\n\n/**\n * Hook para cancelar una orden.\n */\nexport const useCancelOrderMutation = () => {\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  return useMutation<Order, ApiError, string>({\n    mutationFn: (orderId) => orderService.cancelOrder(orderId),\n    onSuccess: (cancelledOrder) => {\n      // Invalidar queries relevantes\n      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });\n      queryClient.invalidateQueries({ queryKey: orderKeys.openToday() });\n\n      showSnackbar({\n        message: `Orden #${cancelledOrder.dailyNumber} cancelada`,\n        type: 'info',\n      });\n    },\n    onError: (error) => {\n      const message = getApiErrorMessage(error);\n      showSnackbar({\n        message: `Error al cancelar orden: ${message}`,\n        type: 'error',\n      });\n      console.error('Error en useCancelOrderMutation:', error);\n    },\n  });\n};\n\n/**\n * Hook para completar una orden (cambiar estado a COMPLETED).\n */\nexport const useCompleteOrderMutation = () => {\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  return useMutation<Order, ApiError, string>({\n    mutationFn: (orderId) =>\n      orderService.updateOrder(orderId, { orderStatus: 'COMPLETED' }),\n    onSuccess: (completedOrder) => {\n      // Invalidar queries relevantes\n      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });\n      queryClient.invalidateQueries({ queryKey: orderKeys.openToday() });\n\n      showSnackbar({\n        message: `Orden #${completedOrder.dailyNumber} finalizada exitosamente`,\n        type: 'success',\n      });\n    },\n    onError: (error) => {\n      const message = getApiErrorMessage(error);\n      showSnackbar({\n        message: `Error al finalizar orden: ${message}`,\n        type: 'error',\n      });\n      console.error('Error en useCompleteOrderMutation:', error);\n    },\n  });\n};\n\n// Añadir aquí otros hooks para órdenes si son necesarios (useGetOrders, etc.)\n\n/**\n * Hook para obtener la lista de órdenes con filtros y paginación.\n */\nexport const useGetOrdersQuery = (\n  filters: FindAllOrdersDto = {},\n  options?: { enabled?: boolean },\n): UseQueryResult<PaginatedResponse<Order>, ApiError> => {\n  const queryKey = orderKeys.list(filters);\n  return useQuery<PaginatedResponse<Order>, ApiError>({\n    queryKey: queryKey,\n    queryFn: () => orderService.getOrders(filters), // Usar la función del servicio que añadiremos\n    enabled: options?.enabled ?? true,\n  });\n};\n\n/**\n * Hook para obtener las órdenes abiertas (PENDING, IN_PROGRESS, READY).\n */\n/**\n * Hook para solicitar la impresión del ticket de cocina.\n */\nexport const usePrintKitchenTicketMutation = () => {\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  // Definir el tipo de las variables de la mutación\n  type PrintVariables = { orderId: string; printerId: string };\n\n  return useMutation<void, ApiError, PrintVariables>({\n    mutationFn: ({ orderId, printerId }) =>\n      orderService.printOrderTicket(orderId, printerId), // Usar la función renombrada\n    onSuccess: (_, variables) => {\n      // Usar el número diario si está disponible en las variables o buscarlo si es necesario\n      // Por ahora, usamos solo el ID para el mensaje\n      showSnackbar({\n        message: `Ticket de cocina para orden ID ${variables.orderId} enviado a impresora.`,\n        type: 'success',\n      });\n      // No es necesario invalidar queries aquí, ya que solo es una acción\n    },\n    onError: (error) => {\n      const message = getApiErrorMessage(error);\n      showSnackbar({\n        message: `Error al imprimir ticket: ${message}`,\n        type: 'error',\n      });\n      console.error('Error printing kitchen ticket:', error);\n    },\n  });\n};\n\nexport const useGetOpenOrdersQuery = (options?: {\n  enabled?: boolean;\n}): UseQueryResult<Order[], ApiError> => {\n  // Devuelve Order[] directamente\n  const queryKey = orderKeys.openToday(); // Usar la nueva clave específica\n\n  return useQuery<Order[], ApiError>({\n    queryKey: queryKey,\n    queryFn: () => orderService.getOpenOrdersToday(), // Llamar a la nueva función del servicio\n    enabled: options?.enabled ?? true,\n    // Sin staleTime, se usará la configuración global (0)\n  });\n\n  // La lógica de useQueries y combinación se elimina\n};\n\n/**\n * Hook para obtener los detalles completos de una orden por su ID.\n */\nexport const useGetOrderByIdQuery = (\n  orderId: string | null | undefined,\n  options?: { enabled?: boolean },\n): UseQueryResult<Order, ApiError> => {\n  // Definir la clave de detalle usando el orderId\n  const detailQueryKey = useMemo(\n    () =>\n      orderId ? [...orderKeys.details(), orderId] : [...orderKeys.details()],\n    [orderId],\n  );\n\n  return useQuery<Order, ApiError>({\n    queryKey: detailQueryKey,\n    queryFn: () => {\n      if (!orderId) {\n        // Si no hay orderId, no intentar hacer fetch y devolver un error o estado inicial\n        return Promise.reject(new Error('Order ID no proporcionado'));\n      }\n      return orderService.getOrderById(orderId);\n    },\n    enabled: !!orderId && (options?.enabled ?? true), // Habilitar solo si hay orderId y está habilitado externamente\n    // Sin staleTime, se usará la configuración global (0)\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/hooks/usePaymentQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/screens/AddProductsToOrderScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useFocusEffect' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ConfirmationModal' is defined but never used. Allowed unused vars must match /^_/u.","line":30,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'orderId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":61,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":61,"endColumn":12},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'existingTempProducts' and 'showSnackbar'. Either include them or remove the dependency array.","line":114,"column":6,"nodeType":"ArrayExpression","endLine":114,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [existingTempProducts, showSnackbar]","fix":{"range":[3903,3905],"text":"[existingTempProducts, showSnackbar]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handleEditItem' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":308,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":308,"endColumn":23}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, {\n  useState,\n  useMemo,\n  useRef,\n  useCallback,\n  useEffect,\n} from 'react';\nimport { StyleSheet, View, FlatList } from 'react-native';\nimport {\n  Text,\n  Portal,\n  ActivityIndicator,\n  Card,\n  Title,\n  Appbar,\n  IconButton,\n} from 'react-native-paper';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport {\n  useNavigation,\n  useRoute,\n  useFocusEffect,\n} from '@react-navigation/native';\nimport { useGetFullMenu } from '../hooks/useMenuQueries';\nimport { Product, Category, SubCategory } from '../types/orders.types';\nimport { Image } from 'expo-image';\nimport { getImageUrl } from '@/app/lib/imageUtils';\nimport ProductCustomizationModal from '../components/ProductCustomizationModal';\nimport SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';\nimport ConfirmationModal from '@/app/components/common/ConfirmationModal';\nimport CartButton from '../components/CartButton';\nimport { useSnackbarStore } from '@/app/store/snackbarStore';\nimport { useAppTheme } from '@/app/styles/theme';\nimport type { OrdersStackScreenProps } from '@/app/navigation/types';\nimport { CartItem, CartItemModifier } from '../context/CartContext';\n\n// Props de navegación\ntype AddProductsRouteProps = {\n  orderId: string;\n  orderNumber: number;\n  existingOrderItemsCount?: number; // Número de items que ya están en la orden\n  existingTempProducts?: CartItem[]; // Productos temporales existentes\n  onProductsAdded?: (products: CartItem[]) => void;\n};\n\ninterface CartButtonHandle {\n  animate: () => void;\n}\n\nconst AddProductsToOrderScreen = () => {\n  const theme = useAppTheme();\n  const { colors, fonts } = theme;\n  const navigation = useNavigation();\n  const route =\n    useRoute<OrdersStackScreenProps<'AddProductsToOrder'>['route']>();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n  const cartButtonRef = useRef<CartButtonHandle>(null);\n\n  // Obtener parámetros de navegación\n  const {\n    orderId,\n    orderNumber,\n    existingTempProducts,\n    existingOrderItemsCount,\n    onProductsAdded,\n  } = route.params as AddProductsRouteProps;\n\n  // Estados para navegación y selección\n  const [navigationLevel, setNavigationLevel] = useState<\n    'categories' | 'subcategories' | 'products'\n  >('categories');\n  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(\n    null,\n  );\n  const [selectedSubcategoryId, setSelectedSubcategoryId] = useState<\n    string | null\n  >(null);\n  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);\n  const [editingItem, setEditingItem] = useState<CartItem | null>(null);\n  const [selectedProductForDescription, setSelectedProductForDescription] =\n    useState<Product | null>(null);\n  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =\n    useState(false);\n\n  // Estado local para productos seleccionados - inicializar con productos existentes si los hay\n  const [selectedProducts, setSelectedProducts] = useState<CartItem[]>(\n    existingTempProducts || [],\n  );\n\n  const { data: menu, isLoading } = useGetFullMenu();\n\n  // Calcular total de items (incluir items existentes de la orden)\n  const totalItemsCount = useMemo(() => {\n    const newItemsCount = selectedProducts.reduce(\n      (sum, item) => sum + item.quantity,\n      0,\n    );\n    const existingItemsCount = existingOrderItemsCount || 0;\n    return newItemsCount + existingItemsCount;\n  }, [selectedProducts, existingOrderItemsCount]);\n\n  // Mostrar mensaje si hay productos existentes al entrar\n  useEffect(() => {\n    if (existingTempProducts && existingTempProducts.length > 0) {\n      const totalItems = existingTempProducts.reduce(\n        (sum, item) => sum + item.quantity,\n        0,\n      );\n      showSnackbar({\n        message: `${totalItems} producto${totalItems > 1 ? 's' : ''} recuperado${totalItems > 1 ? 's' : ''}`,\n        type: 'info',\n      });\n    }\n  }, []);\n\n  const handleCategorySelect = (categoryId: string) => {\n    setSelectedCategoryId(categoryId);\n    setSelectedSubcategoryId(null);\n    setNavigationLevel('subcategories');\n  };\n\n  const handleSubCategorySelect = (subcategoryId: string) => {\n    setSelectedSubcategoryId(subcategoryId);\n    setNavigationLevel('products');\n  };\n\n  const productNeedsCustomization = (product: Product): boolean => {\n    if (!product) return false;\n    const hasVariants =\n      product.hasVariants &&\n      product.variants &&\n      Array.isArray(product.variants) &&\n      product.variants.length > 0;\n    const hasModifiers =\n      product.modifierGroups &&\n      Array.isArray(product.modifierGroups) &&\n      product.modifierGroups.length > 0;\n    return hasVariants || hasModifiers;\n  };\n\n  const handleProductSelect = (product: Product) => {\n    if (productNeedsCustomization(product)) {\n      setSelectedProduct(product);\n    } else {\n      // Añadir producto directamente sin personalización\n      addItemToSelection(product, 1);\n    }\n  };\n\n  const addItemToSelection = (\n    product: Product,\n    quantity: number,\n    selectedVariantId?: string,\n    selectedModifiers?: CartItemModifier[],\n    preparationNotes?: string,\n  ) => {\n    const selectedVariant = product.variants?.find(\n      (v) => v.id === selectedVariantId,\n    );\n    const variantPrice = selectedVariant?.price || product.price;\n    const modifiersPrice =\n      selectedModifiers?.reduce((sum, mod) => sum + (mod.price || 0), 0) || 0;\n    const unitPrice = variantPrice + modifiersPrice;\n\n    // Buscar si ya existe un item idéntico en la selección actual\n    const existingIndex = selectedProducts.findIndex((item) => {\n      // Verificar si es el mismo producto, variante, modificadores y notas\n      if (item.productId !== product.id) return false;\n      if (item.variantId !== selectedVariantId) return false;\n      if (item.preparationNotes !== preparationNotes) return false;\n\n      // Comparar modificadores\n      const itemModifierIds = item.modifiers\n        .map((m) => m.id)\n        .sort()\n        .join(',');\n      const newModifierIds = (selectedModifiers || [])\n        .map((m) => m.id)\n        .sort()\n        .join(',');\n\n      return itemModifierIds === newModifierIds;\n    });\n\n    if (existingIndex !== -1) {\n      // Si existe, actualizar la cantidad\n      setSelectedProducts((prev) => {\n        const updated = [...prev];\n        const existingItem = updated[existingIndex];\n        const newQuantity = existingItem.quantity + quantity;\n\n        // Recalcular el precio total correctamente\n        const modifiersTotal = existingItem.modifiers.reduce(\n          (sum, mod) => sum + Number(mod.price || 0),\n          0,\n        );\n        const unitPriceWithModifiers =\n          Number(existingItem.unitPrice || 0) + modifiersTotal;\n\n        updated[existingIndex] = {\n          ...existingItem,\n          quantity: newQuantity,\n          totalPrice: unitPriceWithModifiers * newQuantity,\n        };\n        return updated;\n      });\n    } else {\n      // Si no existe, agregar nuevo item\n      const newItem: CartItem = {\n        id: `temp-${Date.now()}-${Math.random()}`,\n        productId: product.id,\n        productName: product.name,\n        quantity,\n        unitPrice,\n        totalPrice: unitPrice * quantity,\n        modifiers: selectedModifiers || [],\n        variantId: selectedVariantId,\n        variantName: selectedVariant?.name,\n        preparationNotes,\n      };\n\n      setSelectedProducts((prev) => [...prev, newItem]);\n    }\n\n    // Animar el carrito\n    cartButtonRef.current?.animate();\n\n    showSnackbar({\n      message: `${product.name} añadido`,\n      type: 'success',\n    });\n  };\n\n  const updateItemInSelection = (\n    itemId: string,\n    quantity: number,\n    modifiers: CartItemModifier[],\n    preparationNotes?: string,\n    variantId?: string,\n    variantName?: string,\n    unitPrice?: number,\n  ) => {\n    setSelectedProducts((prev) =>\n      prev.map((item) => {\n        if (item.id === itemId) {\n          const modifiersPrice = modifiers.reduce(\n            (sum, mod) => sum + Number(mod.price || 0),\n            0,\n          );\n          const finalUnitPrice =\n            unitPrice !== undefined ? unitPrice : item.unitPrice;\n          const newTotalPrice = (finalUnitPrice + modifiersPrice) * quantity;\n\n          return {\n            ...item,\n            quantity,\n            modifiers,\n            preparationNotes:\n              preparationNotes !== undefined\n                ? preparationNotes\n                : item.preparationNotes,\n            variantId: variantId !== undefined ? variantId : item.variantId,\n            variantName:\n              variantName !== undefined ? variantName : item.variantName,\n            unitPrice: finalUnitPrice,\n            totalPrice: newTotalPrice,\n          };\n        }\n        return item;\n      }),\n    );\n  };\n\n  const handleAddToCart = (\n    product: Product,\n    quantity: number,\n    selectedVariantId?: string,\n    selectedModifiers?: CartItemModifier[],\n    preparationNotes?: string,\n  ) => {\n    if (editingItem) {\n      // Si estamos editando, actualizar el item existente\n      updateItemInSelection(\n        editingItem.id,\n        quantity,\n        selectedModifiers || [],\n        preparationNotes,\n        selectedVariantId,\n        product.variants?.find((v) => v.id === selectedVariantId)?.name,\n        selectedVariantId\n          ? product.variants?.find((v) => v.id === selectedVariantId)?.price\n          : product.price,\n      );\n      setEditingItem(null);\n    } else {\n      // Si es nuevo, añadir a la selección\n      addItemToSelection(\n        product,\n        quantity,\n        selectedVariantId,\n        selectedModifiers,\n        preparationNotes,\n      );\n    }\n    setSelectedProduct(null);\n  };\n\n  const handleEditItem = (item: CartItem) => {\n    // Buscar el producto completo en el menú\n    if (!menu || !Array.isArray(menu)) return;\n\n    let product: Product | undefined;\n    for (const category of menu) {\n      if (category.subcategories && Array.isArray(category.subcategories)) {\n        for (const subcategory of category.subcategories) {\n          if (subcategory.products && Array.isArray(subcategory.products)) {\n            product = subcategory.products.find(\n              (p: Product) => p.id === item.productId,\n            );\n            if (product) break;\n          }\n        }\n      }\n      if (product) break;\n    }\n\n    if (product) {\n      setEditingItem(item);\n      setSelectedProduct(product);\n    }\n  };\n\n  const handleCloseProductModal = useCallback(() => {\n    setSelectedProduct(null);\n    setEditingItem(null);\n  }, []);\n\n  const handleConfirmSelection = () => {\n    // No mostrar mensaje si no hay productos nuevos seleccionados\n    // pero permitir salir igualmente\n\n    // Llamar callback con todos los productos (existentes + nuevos)\n    if (onProductsAdded) {\n      onProductsAdded(selectedProducts);\n    }\n\n    // Navegar de vuelta al resumen de orden\n    navigation.goBack();\n  };\n\n  const handleBack = () => {\n    if (selectedProduct) {\n      setSelectedProduct(null);\n    } else if (navigationLevel === 'products') {\n      setNavigationLevel('subcategories');\n      setSelectedSubcategoryId(null);\n    } else if (navigationLevel === 'subcategories') {\n      setNavigationLevel('categories');\n      setSelectedCategoryId(null);\n    } else {\n      // Al salir, guardar los productos seleccionados\n      if (onProductsAdded) {\n        onProductsAdded(selectedProducts);\n      }\n      navigation.goBack();\n    }\n  };\n\n  const getCategories = () => {\n    if (!menu || !Array.isArray(menu)) return [];\n    return menu;\n  };\n\n  const getSubcategories = () => {\n    if (!selectedCategory || !Array.isArray(selectedCategory.subcategories))\n      return [];\n    return selectedCategory.subcategories;\n  };\n\n  const getProducts = () => {\n    if (!selectedSubCategory || !Array.isArray(selectedSubCategory.products))\n      return [];\n    return selectedSubCategory.products;\n  };\n\n  const selectedCategory = menu?.find(\n    (cat: Category) => cat.id === selectedCategoryId,\n  );\n  const selectedSubCategory = selectedCategory?.subcategories?.find(\n    (sub: SubCategory) => sub.id === selectedSubcategoryId,\n  );\n\n  const getNavTitle = useCallback(() => {\n    if (selectedProduct) {\n      return selectedProduct.name;\n    }\n    switch (navigationLevel) {\n      case 'categories':\n        return `Añadir a Orden #${orderNumber}`;\n      case 'subcategories':\n        return selectedCategory?.name || 'Subcategorías';\n      case 'products':\n        return selectedSubCategory?.name || 'Productos';\n      default:\n        return 'Categorías';\n    }\n  }, [\n    navigationLevel,\n    selectedCategory,\n    selectedSubCategory,\n    selectedProduct,\n    orderNumber,\n  ]);\n\n  const handleShowProductDescription = (product: Product) => {\n    setSelectedProductForDescription(product);\n    setIsDescriptionModalVisible(true);\n  };\n\n  const handleCloseDescriptionModal = () => {\n    setIsDescriptionModalVisible(false);\n    setSelectedProductForDescription(null);\n  };\n\n  const styles = useMemo(\n    () =>\n      StyleSheet.create({\n        safeArea: {\n          flex: 1,\n          backgroundColor: colors.background,\n        },\n        container: {\n          flex: 1,\n        },\n        content: {\n          flex: 1,\n        },\n        gridContainer: {\n          padding: 12,\n          paddingBottom: 60,\n        },\n        row: {\n          justifyContent: 'flex-start',\n        },\n        cardItem: {\n          width: '48%',\n          marginHorizontal: '1%',\n          marginVertical: 4,\n          overflow: 'hidden',\n          borderRadius: 8,\n          elevation: 2,\n        },\n        cardItemInactive: {\n          opacity: 0.5,\n        },\n        itemImage: {\n          width: '100%',\n          height: 120,\n        },\n        imageInactive: {\n          opacity: 0.6,\n        },\n        imagePlaceholder: {\n          width: '100%',\n          height: 120,\n          backgroundColor: '#eeeeee',\n          justifyContent: 'center',\n          alignItems: 'center',\n        },\n        placeholderText: {\n          fontSize: 24,\n          fontWeight: 'bold',\n          color: '#999',\n        },\n        cardContent: {\n          padding: 12,\n        },\n        cardTitle: {\n          fontSize: 16,\n          fontWeight: 'bold',\n          marginBottom: 4,\n        },\n        cardHeader: {\n          flexDirection: 'row',\n          justifyContent: 'space-between',\n          alignItems: 'flex-start',\n        },\n        infoButton: {\n          margin: -8,\n          marginTop: -12,\n          marginRight: -12,\n        },\n        priceText: {\n          color: '#2e7d32',\n          fontWeight: 'bold',\n          marginTop: 4,\n        },\n        noItemsText: {\n          textAlign: 'center',\n          marginTop: 40,\n          fontSize: 16,\n          color: '#666',\n        },\n        loadingContainer: {\n          flex: 1,\n          justifyContent: 'center',\n          alignItems: 'center',\n        },\n        appBar: {\n          backgroundColor: colors.elevation.level2,\n          alignItems: 'center',\n        },\n        appBarTitle: {\n          ...fonts.titleMedium,\n          color: colors.onSurface,\n          fontWeight: 'bold',\n          textAlign: 'center',\n        },\n        appBarContent: {},\n        spacer: {\n          width: 48,\n        },\n        inactiveBadge: {\n          position: 'absolute',\n          top: 8,\n          right: 8,\n          backgroundColor: colors.errorContainer,\n          paddingHorizontal: 8,\n          paddingVertical: 4,\n          borderRadius: 4,\n        },\n        inactiveBadgeText: {\n          fontSize: 12,\n          color: colors.onErrorContainer,\n          fontWeight: '600',\n        },\n      }),\n    [colors, fonts],\n  );\n\n  const blurhash =\n    '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';\n\n  const renderItem = ({ item }: { item: Category | SubCategory | Product }) => {\n    const imageUrl = (() => {\n      const photoPath = item.photo?.path || item.photo;\n      return photoPath ? getImageUrl(photoPath) : null;\n    })();\n    const isActive = item.isActive !== false;\n\n    const handlePress = () => {\n      if (!isActive) return;\n\n      if (navigationLevel === 'categories') {\n        handleCategorySelect(item.id);\n      } else if (navigationLevel === 'subcategories') {\n        handleSubCategorySelect(item.id);\n      } else if ('price' in item) {\n        handleProductSelect(item as Product);\n      }\n    };\n\n    const handleLongPress = () => {\n      if (\n        navigationLevel === 'products' &&\n        'price' in item &&\n        isActive &&\n        'description' in item &&\n        (item as Product).description &&\n        (item as Product).description.trim() !== ''\n      ) {\n        handleShowProductDescription(item as Product);\n      }\n    };\n\n    const renderPrice = () => {\n      if (\n        navigationLevel === 'products' &&\n        'price' in item &&\n        'hasVariants' in item\n      ) {\n        const productItem = item as Product;\n        if (\n          !productItem.hasVariants &&\n          productItem.price !== null &&\n          productItem.price !== undefined\n        ) {\n          return (\n            <Text style={styles.priceText}>\n              ${Number(productItem.price).toFixed(2)}\n            </Text>\n          );\n        }\n      }\n      return null;\n    };\n\n    return (\n      <Card\n        style={[styles.cardItem, !isActive && styles.cardItemInactive]}\n        onPress={handlePress}\n        onLongPress={handleLongPress}\n        disabled={!isActive}\n      >\n        {imageUrl ? (\n          <Image\n            source={{ uri: imageUrl }}\n            style={[styles.itemImage, !isActive && styles.imageInactive]}\n            contentFit=\"cover\"\n            placeholder={blurhash}\n            transition={300}\n          />\n        ) : (\n          <View\n            style={[styles.imagePlaceholder, !isActive && styles.imageInactive]}\n          >\n            <Text style={styles.placeholderText}>\n              {navigationLevel === 'categories'\n                ? '🍴'\n                : navigationLevel === 'subcategories'\n                  ? '🍽️'\n                  : '🥘'}\n            </Text>\n          </View>\n        )}\n        <Card.Content style={styles.cardContent}>\n          {navigationLevel === 'products' &&\n          'price' in item &&\n          (item as Product).description ? (\n            <View style={styles.cardHeader}>\n              <Title style={[styles.cardTitle, { flex: 1 }]}>{item.name}</Title>\n              <IconButton\n                icon=\"information-outline\"\n                size={20}\n                onPress={() => handleShowProductDescription(item as Product)}\n                style={styles.infoButton}\n              />\n            </View>\n          ) : (\n            <Title style={styles.cardTitle}>{item.name}</Title>\n          )}\n          {renderPrice()}\n        </Card.Content>\n        {!isActive && (\n          <View style={styles.inactiveBadge}>\n            <Text style={styles.inactiveBadgeText}>No disponible</Text>\n          </View>\n        )}\n      </Card>\n    );\n  };\n\n  if (isLoading) {\n    return (\n      <SafeAreaView style={styles.safeArea}>\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" />\n        </View>\n      </SafeAreaView>\n    );\n  }\n\n  const currentData =\n    navigationLevel === 'categories'\n      ? getCategories()\n      : navigationLevel === 'subcategories'\n        ? getSubcategories()\n        : getProducts();\n\n  return (\n    <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>\n      <View style={styles.container}>\n        <Appbar.Header style={styles.appBar}>\n          <Appbar.BackAction onPress={handleBack} />\n          <Appbar.Content\n            title={getNavTitle()}\n            titleStyle={styles.appBarTitle}\n            style={styles.appBarContent}\n          />\n          <CartButton\n            ref={cartButtonRef}\n            itemCount={totalItemsCount}\n            onPress={handleConfirmSelection}\n          />\n        </Appbar.Header>\n\n        <View style={styles.content}>\n          {currentData.length === 0 ? (\n            <Text style={styles.noItemsText}>\n              {navigationLevel === 'categories'\n                ? 'No hay categorías disponibles'\n                : navigationLevel === 'subcategories'\n                  ? 'No hay subcategorías disponibles'\n                  : 'No hay productos disponibles'}\n            </Text>\n          ) : (\n            <FlatList\n              data={currentData}\n              renderItem={renderItem}\n              keyExtractor={(item) => item.id}\n              numColumns={2}\n              contentContainerStyle={styles.gridContainer}\n              columnWrapperStyle={styles.row}\n              showsVerticalScrollIndicator={false}\n            />\n          )}\n        </View>\n\n        {/* Modal de personalización de producto */}\n        <Portal>\n          {selectedProduct && (\n            <ProductCustomizationModal\n              visible={true}\n              product={selectedProduct}\n              editingItem={editingItem}\n              onDismiss={handleCloseProductModal}\n              onAddToCart={handleAddToCart}\n              onUpdateItem={(\n                itemId,\n                quantity,\n                modifiers,\n                notes,\n                variantId,\n                variantName,\n                unitPrice,\n              ) => {\n                updateItemInSelection(\n                  itemId,\n                  quantity,\n                  modifiers,\n                  notes,\n                  variantId,\n                  variantName,\n                  unitPrice,\n                );\n                setEditingItem(null);\n                setSelectedProduct(null);\n              }}\n            />\n          )}\n\n          {/* Modal de descripción del producto */}\n          {selectedProductForDescription && (\n            <SimpleProductDescriptionModal\n              visible={isDescriptionModalVisible}\n              product={selectedProductForDescription}\n              onDismiss={handleCloseDescriptionModal}\n            />\n          )}\n        </Portal>\n      </View>\n    </SafeAreaView>\n  );\n};\n\nexport default AddProductsToOrderScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/screens/CreateOrderScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'OrderType' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Order' is defined but never used. Allowed unused vars must match /^_/u.","line":30,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'items' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":56,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setOrderType' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":65,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setSelectedTableId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":66,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":66,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setDeliveryInfo' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":67,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":67,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setOrderNotes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":68,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setItems' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":69,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setScheduledTime' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":70,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":21},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":239,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":239,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7531,7596],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, {\n  useState,\n  useMemo,\n  useRef,\n  useCallback,\n  useEffect,\n} from 'react';\nimport { StyleSheet, View, FlatList } from 'react-native';\nimport {\n  Text,\n  Portal,\n  ActivityIndicator,\n  Card,\n  Title,\n  Appbar,\n  IconButton,\n} from 'react-native-paper';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useNavigation } from '@react-navigation/native';\nimport { useGetFullMenu } from '../hooks/useMenuQueries';\n// Importar el hook de mutación para crear órdenes\nimport { useCreateOrderMutation } from '@/modules/orders/hooks/useOrdersQueries'; // Usar ruta absoluta\nimport { useCart, CartProvider, CartItem } from '../context/CartContext';\nimport { CartItemModifier } from '../context/CartContext';\nimport {\n  OrderType,\n  Product,\n  Category,\n  SubCategory,\n  Order, // Importar el tipo Order\n} from '../types/orders.types';\nimport { Image } from 'expo-image';\nimport { getImageUrl } from '@/app/lib/imageUtils';\n\nimport OrderCartDetail from '../components/OrderCartDetail';\nimport ProductCustomizationModal from '../components/ProductCustomizationModal';\nimport SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';\nimport CartButton from '../components/CartButton';\nimport ConfirmationModal from '@/app/components/common/ConfirmationModal';\nimport { useSnackbarStore } from '@/app/store/snackbarStore'; // Importar snackbar\nimport { getApiErrorMessage } from '@/app/lib/errorMapping'; // Importar mapeo de errores\n\nimport { useAppTheme } from '@/app/styles/theme';\n// Importar el tipo completo para el payload de confirmación\nimport type { OrderDetailsForBackend } from '../components/OrderCartDetail';\n\ninterface CartButtonHandle {\n  animate: () => void;\n}\n\nconst CreateOrderScreen = () => {\n  const theme = useAppTheme();\n  const { colors, fonts } = theme;\n  const navigation = useNavigation();\n  const {\n    items,\n    isCartEmpty,\n    addItem: originalAddItem,\n    updateItem,\n    isCartVisible,\n    showCart,\n    hideCart,\n    clearCart,\n    totalItemsCount,\n    setOrderType,\n    setSelectedTableId,\n    setDeliveryInfo,\n    setOrderNotes,\n    setItems,\n    setScheduledTime,\n  } = useCart();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar); // Hook para snackbar\n\n  // Instanciar la mutación para crear la orden\n  const createOrderMutation = useCreateOrderMutation();\n\n  const cartButtonRef = useRef<CartButtonHandle>(null);\n\n  const [navigationLevel, setNavigationLevel] = useState<\n    'categories' | 'subcategories' | 'products'\n  >('categories');\n  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(\n    null,\n  );\n  const [selectedSubcategoryId, setSelectedSubcategoryId] = useState<\n    string | null\n  >(null);\n  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);\n  const [editingItem, setEditingItem] = useState<CartItem | null>(null);\n  const [showExitConfirmationModal, setShowExitConfirmationModal] =\n    useState(false);\n  const [pendingNavigationAction, setPendingNavigationAction] = useState<\n    (() => void) | null\n  >(null);\n  const [isProcessingOrder, setIsProcessingOrder] = useState(false);\n  const [selectedProductForDescription, setSelectedProductForDescription] =\n    useState<Product | null>(null);\n  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =\n    useState(false);\n\n  const { data: menu, isLoading } = useGetFullMenu();\n\n  const handleCategorySelect = (categoryId: string) => {\n    setSelectedCategoryId(categoryId);\n    setSelectedSubcategoryId(null);\n    setNavigationLevel('subcategories');\n  };\n\n  const handleSubCategorySelect = (subcategoryId: string) => {\n    setSelectedSubcategoryId(subcategoryId);\n    setNavigationLevel('products');\n  };\n\n  const productNeedsCustomization = (product: Product): boolean => {\n    if (!product) return false;\n    const hasVariants =\n      product.hasVariants &&\n      product.variants &&\n      Array.isArray(product.variants) &&\n      product.variants.length > 0;\n    const hasModifiers =\n      product.modifierGroups &&\n      Array.isArray(product.modifierGroups) &&\n      product.modifierGroups.length > 0;\n    return hasVariants || hasModifiers;\n  };\n\n  const handleProductSelect = (product: Product) => {\n    if (productNeedsCustomization(product)) {\n      setSelectedProduct(product);\n    } else {\n      handleAddItem(product, 1);\n    }\n  };\n\n  const handleCloseProductModal = useCallback(() => {\n    setSelectedProduct(null);\n    setEditingItem(null);\n    // Si estábamos editando y hay items en el carrito, volver a mostrar el carrito\n    if (editingItem && !isCartEmpty) {\n      showCart();\n    }\n  }, [editingItem, isCartEmpty, showCart]);\n\n  const handleEditItem = useCallback(\n    (item: CartItem) => {\n      // Encontrar el producto completo desde el menú\n      if (!menu || !Array.isArray(menu)) {\n        showSnackbar({\n          message:\n            'El menú aún se está cargando. Por favor, intenta nuevamente.',\n          type: 'info',\n        });\n        return;\n      }\n\n      // Buscar el producto en la estructura anidada\n      let product: Product | undefined;\n\n      for (const category of menu) {\n        if (category.subcategories && Array.isArray(category.subcategories)) {\n          for (const subcategory of category.subcategories) {\n            if (subcategory.products && Array.isArray(subcategory.products)) {\n              product = subcategory.products.find(\n                (p) => p.id === item.productId,\n              );\n              if (product) break;\n            }\n          }\n        }\n        if (product) break;\n      }\n\n      if (product) {\n        setEditingItem(item);\n        setSelectedProduct(product);\n        hideCart(); // Cerrar el carrito para mostrar el modal de personalización\n      } else {\n        showSnackbar({\n          message:\n            'No se pudo encontrar el producto. Por favor, recarga la pantalla.',\n          type: 'error',\n        });\n      }\n    },\n    [menu, showSnackbar, hideCart],\n  );\n\n  const handleGoBackInternal = () => {\n    if (navigationLevel === 'products') {\n      setNavigationLevel('subcategories');\n      setSelectedSubcategoryId(null);\n    } else if (navigationLevel === 'subcategories') {\n      setNavigationLevel('categories');\n      setSelectedCategoryId(null);\n    }\n  };\n\n  const handleAttemptExit = (goBackAction: () => void) => {\n    if (isCartEmpty) {\n      goBackAction();\n    } else {\n      setPendingNavigationAction(() => goBackAction);\n      setShowExitConfirmationModal(true);\n    }\n  };\n\n  useEffect(() => {\n    const unsubscribe = navigation.addListener('beforeRemove', (e) => {\n      // Don't do anything if cart is empty or modal is already showing\n      if (isCartEmpty || showExitConfirmationModal) {\n        return;\n      }\n\n      // Prevent default for any navigation away when cart has items\n      // This includes back navigation and drawer navigation\n      e.preventDefault();\n      setPendingNavigationAction(\n        () => () => navigation.dispatch(e.data.action),\n      );\n      setShowExitConfirmationModal(true);\n    });\n\n    return unsubscribe;\n  }, [navigation, isCartEmpty, showExitConfirmationModal]);\n\n  const handleViewCart = useCallback(() => {\n    showCart();\n  }, [showCart]);\n\n  const handleCloseCart = useCallback(() => {\n    hideCart();\n  }, [hideCart]);\n\n  // Actualizar handleConfirmOrder para usar la mutación\n  const handleConfirmOrder = async (details: OrderDetailsForBackend) => {\n    if (isProcessingOrder) return; // Prevenir múltiples envíos\n\n    console.log('Intentando confirmar orden con detalles:', details);\n    setIsProcessingOrder(true);\n\n    try {\n      // Llamar a la mutación para enviar la orden al backend\n      const createdOrder = await createOrderMutation.mutateAsync(details);\n\n      // Usar 'dailyNumber' que es lo que devuelve el backend\n      showSnackbar({\n        message: `Orden #${createdOrder.dailyNumber} creada con éxito`,\n        type: 'success',\n      });\n      hideCart();\n      clearCart(); // Limpiar carrito después de éxito\n      // Opcional: Navegar a otra pantalla, por ejemplo, la lista de órdenes\n      // navigation.navigate('Orders'); // Asegúrate de que 'Orders' exista en tu stack\n      navigation.goBack(); // O simplemente volver atrás\n    } catch (error) {\n      // El manejo de errores con snackbar ya debería estar en el hook useCreateOrderMutation\n      const message = getApiErrorMessage(error as Error);\n      showSnackbar({\n        message: `Error al crear orden: ${message}`,\n        type: 'error',\n      });\n      console.error('Error al crear la orden:', error);\n    } finally {\n      setIsProcessingOrder(false);\n    }\n  };\n\n  const handleAddItem = (\n    product: Product,\n    quantity: number,\n    selectedVariantId?: string,\n    selectedModifiers?: CartItemModifier[],\n    preparationNotes?: string,\n  ) => {\n    originalAddItem(\n      product,\n      quantity,\n      selectedVariantId,\n      selectedModifiers,\n      preparationNotes,\n    );\n    cartButtonRef.current?.animate();\n  };\n\n  const getCategories = () => {\n    if (!menu || !Array.isArray(menu)) return [];\n    return menu;\n  };\n\n  const getSubcategories = () => {\n    if (!selectedCategory || !Array.isArray(selectedCategory.subcategories))\n      return [];\n    return selectedCategory.subcategories;\n  };\n\n  const getProducts = () => {\n    if (!selectedSubCategory || !Array.isArray(selectedSubCategory.products))\n      return [];\n    return selectedSubCategory.products;\n  };\n\n  const selectedCategory =\n    menu && Array.isArray(menu)\n      ? menu.find((cat: Category) => cat.id === selectedCategoryId)\n      : null;\n\n  const selectedSubCategory =\n    selectedCategory && Array.isArray(selectedCategory.subcategories) // Corregido a lowercase\n      ? selectedCategory.subcategories.find(\n          // Corregido a lowercase\n          (sub: SubCategory) => sub.id === selectedSubcategoryId,\n        )\n      : null;\n\n  const getNavTitle = useCallback(() => {\n    if (selectedProduct) {\n      return selectedProduct.name;\n    }\n    switch (navigationLevel) {\n      case 'categories':\n        return 'Categorías';\n      case 'subcategories':\n        return selectedCategory?.name\n          ? `Categoría: ${selectedCategory.name}`\n          : 'Subcategorías';\n      case 'products':\n        return selectedSubCategory?.name\n          ? `Subcategoría: ${selectedSubCategory.name}`\n          : 'Productos';\n      default:\n        return 'Categorías';\n    }\n  }, [navigationLevel, selectedCategory, selectedSubCategory, selectedProduct]);\n\n  const styles = useMemo(\n    () =>\n      StyleSheet.create({\n        safeArea: {\n          flex: 1,\n          backgroundColor: colors.background,\n        },\n        container: {\n          flex: 1,\n        },\n        content: {\n          flex: 1,\n        },\n        gridContainer: {\n          padding: 12,\n          paddingBottom: 60,\n        },\n        row: {\n          justifyContent: 'flex-start',\n        },\n        cardItem: {\n          width: '48%',\n          marginHorizontal: '1%',\n          marginVertical: 4,\n          overflow: 'hidden',\n          borderRadius: 8,\n          elevation: 2,\n        },\n        cardItemInactive: {\n          opacity: 0.5,\n        },\n        itemImage: {\n          width: '100%',\n          height: 120,\n        },\n        imagePlaceholder: {\n          width: '100%',\n          height: 120,\n          backgroundColor: '#eeeeee',\n          justifyContent: 'center',\n          alignItems: 'center',\n        },\n        imageInactive: {\n          opacity: 0.6,\n        },\n        placeholderText: {\n          fontSize: 24,\n          fontWeight: 'bold',\n          color: '#999',\n        },\n        cardContent: {\n          padding: 12,\n        },\n        cardTitle: {\n          fontSize: 16,\n          fontWeight: 'bold',\n          marginBottom: 4,\n        },\n        cardHeader: {\n          flexDirection: 'row',\n          justifyContent: 'space-between',\n          alignItems: 'flex-start',\n        },\n        infoButton: {\n          margin: -8,\n          marginTop: -12,\n          marginRight: -12,\n        },\n        priceText: {\n          color: '#2e7d32',\n          fontWeight: 'bold',\n          marginTop: 4,\n        },\n        noItemsText: {\n          textAlign: 'center',\n          marginTop: 40,\n          fontSize: 16,\n          color: '#666',\n        },\n        loadingContainer: {\n          flex: 1,\n          justifyContent: 'center',\n          alignItems: 'center',\n        },\n        appBar: {\n          backgroundColor: colors.elevation.level2,\n          alignItems: 'center',\n        },\n        appBarTitle: {\n          ...fonts.titleMedium,\n          color: colors.onSurface,\n          fontWeight: 'bold',\n          textAlign: 'center',\n        },\n        appBarContent: {},\n        spacer: {\n          width: 48,\n        },\n        inactiveBadge: {\n          position: 'absolute',\n          top: 8,\n          right: 8,\n          backgroundColor: colors.errorContainer,\n          paddingHorizontal: 8,\n          paddingVertical: 4,\n          borderRadius: 4,\n        },\n        inactiveBadgeText: {\n          fontSize: 12,\n          color: colors.onErrorContainer,\n          fontWeight: '600',\n        },\n      }),\n    [colors, fonts],\n  );\n\n  const handleConfirmExit = () => {\n    setShowExitConfirmationModal(false);\n\n    // Store the navigation action before clearing the cart\n    const navigationAction =\n      pendingNavigationAction || (() => navigation.goBack());\n\n    // Clear the pending action\n    setPendingNavigationAction(null);\n\n    // Execute navigation first\n    navigationAction();\n\n    // Clear cart after navigation to avoid the beforeRemove check\n    setTimeout(() => {\n      clearCart();\n    }, 100);\n  };\n\n  const handleCancelExit = () => {\n    setShowExitConfirmationModal(false);\n    setPendingNavigationAction(null);\n  };\n\n  const handleShowProductDescription = (product: Product) => {\n    setSelectedProductForDescription(product);\n    setIsDescriptionModalVisible(true);\n  };\n\n  const handleCloseDescriptionModal = () => {\n    setIsDescriptionModalVisible(false);\n    setSelectedProductForDescription(null);\n  };\n\n  const renderContent = () => {\n    if (isCartVisible) {\n      return (\n        <SafeAreaView\n          style={styles.safeArea}\n          edges={['left', 'right', 'bottom']}\n        >\n          <Appbar.Header style={styles.appBar}>\n            <Appbar.BackAction onPress={handleCloseCart} />\n            <Appbar.Content\n              title=\"Carrito de Compras\"\n              titleStyle={styles.appBarTitle}\n              style={styles.appBarContent}\n            />\n            <View style={styles.spacer} />\n          </Appbar.Header>\n          <OrderCartDetail\n            visible={isCartVisible}\n            onClose={handleCloseCart}\n            onConfirmOrder={handleConfirmOrder}\n            onEditItem={handleEditItem}\n            isEditMode={false}\n          />\n        </SafeAreaView>\n      );\n    }\n\n    const blurhash =\n      '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';\n\n    const renderItem = ({\n      item,\n    }: {\n      item: Category | SubCategory | Product;\n    }) => {\n      const imageUrl = item.photo ? getImageUrl(item.photo.path) : null;\n      const isActive = item.isActive !== false; // Por defecto true si no existe la propiedad\n\n      const handlePress = () => {\n        // No hacer nada si el elemento está inactivo\n        if (!isActive) return;\n\n        if (navigationLevel === 'categories') {\n          handleCategorySelect(item.id);\n        } else if (navigationLevel === 'subcategories') {\n          handleSubCategorySelect(item.id);\n        } else if ('price' in item) {\n          handleProductSelect(item as Product);\n        }\n      };\n\n      const renderPrice = () => {\n        if (\n          navigationLevel === 'products' &&\n          'price' in item &&\n          'hasVariants' in item\n        ) {\n          const productItem = item as Product;\n          if (\n            !productItem.hasVariants &&\n            productItem.price !== null &&\n            productItem.price !== undefined\n          ) {\n            return (\n              <Text style={styles.priceText}>\n                ${Number(productItem.price).toFixed(2)}\n              </Text>\n            );\n          }\n        }\n        return null;\n      };\n\n      return (\n        <Card\n          style={[styles.cardItem, !isActive && styles.cardItemInactive]}\n          onPress={handlePress}\n          disabled={!isActive}\n        >\n          {imageUrl ? (\n            <Image\n              source={{ uri: imageUrl }}\n              style={[styles.itemImage, !isActive && styles.imageInactive]}\n              contentFit=\"cover\"\n              placeholder={blurhash}\n              transition={300}\n            />\n          ) : (\n            <View\n              style={[\n                styles.imagePlaceholder,\n                !isActive && styles.imageInactive,\n              ]}\n            >\n              <Text style={styles.placeholderText}>\n                {item.name.charAt(0).toUpperCase()}\n              </Text>\n            </View>\n          )}\n          {!isActive && (\n            <View style={styles.inactiveBadge}>\n              <Text style={styles.inactiveBadgeText}>INACTIVO</Text>\n            </View>\n          )}\n          <View style={styles.cardContent}>\n            {navigationLevel === 'products' &&\n            'price' in item &&\n            (item as Product).description ? (\n              <View style={styles.cardHeader}>\n                <Title style={[styles.cardTitle, { flex: 1 }]}>\n                  {item.name}\n                </Title>\n                <IconButton\n                  icon=\"information-outline\"\n                  size={20}\n                  onPress={() => handleShowProductDescription(item as Product)}\n                  style={styles.infoButton}\n                />\n              </View>\n            ) : (\n              <Title style={styles.cardTitle}>{item.name}</Title>\n            )}\n            {renderPrice()}\n          </View>\n        </Card>\n      );\n    };\n\n    const getItemsToDisplay = () => {\n      switch (navigationLevel) {\n        case 'categories':\n          return getCategories();\n        case 'subcategories':\n          return getSubcategories();\n        case 'products':\n          return getProducts();\n        default:\n          return [];\n      }\n    };\n\n    const itemsToDisplay = getItemsToDisplay();\n    const showCartButton = !isCartVisible && !selectedProduct;\n\n    const backAction = selectedProduct\n      ? handleCloseProductModal\n      : navigationLevel === 'categories'\n        ? () => handleAttemptExit(() => navigation.goBack())\n        : handleGoBackInternal;\n\n    return (\n      <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>\n        <Appbar.Header style={styles.appBar} elevated>\n          <Appbar.BackAction onPress={backAction} />\n          <Appbar.Content\n            title={getNavTitle()}\n            titleStyle={styles.appBarTitle}\n            style={styles.appBarContent}\n          />\n          {showCartButton ? (\n            <CartButton\n              ref={cartButtonRef}\n              itemCount={totalItemsCount}\n              onPress={handleViewCart}\n            />\n          ) : (\n            <View style={styles.spacer} />\n          )}\n        </Appbar.Header>\n\n        <View style={styles.content}>\n          {isLoading ? (\n            <View style={styles.loadingContainer}>\n              <ActivityIndicator size=\"large\" color=\"#2e7d32\" />\n              <Text>Cargando...</Text>\n            </View>\n          ) : itemsToDisplay.length > 0 ? (\n            <FlatList\n              data={itemsToDisplay}\n              renderItem={renderItem}\n              keyExtractor={(item) => item.id}\n              contentContainerStyle={styles.gridContainer}\n              numColumns={2}\n              columnWrapperStyle={styles.row}\n              initialNumToRender={6}\n              maxToRenderPerBatch={10}\n              windowSize={5}\n            />\n          ) : (\n            <Text style={styles.noItemsText}>\n              {navigationLevel === 'products'\n                ? 'No hay productos disponibles'\n                : navigationLevel === 'subcategories'\n                  ? 'No hay subcategorías disponibles'\n                  : 'No hay categorías disponibles'}\n            </Text>\n          )}\n        </View>\n\n        <ConfirmationModal\n          visible={showExitConfirmationModal}\n          title=\"¿Descartar Orden?\"\n          message=\"Tienes artículos en el carrito. Si sales, se perderán. ¿Estás seguro?\"\n          confirmText=\"Salir y Descartar\"\n          cancelText=\"Cancelar\"\n          onConfirm={handleConfirmExit}\n          onCancel={handleCancelExit}\n        />\n\n        <Portal>\n          {selectedProduct && productNeedsCustomization(selectedProduct) && (\n            <ProductCustomizationModal\n              visible={true}\n              product={selectedProduct}\n              editingItem={editingItem}\n              onAddToCart={handleAddItem}\n              onUpdateItem={updateItem}\n              onDismiss={handleCloseProductModal}\n            />\n          )}\n\n          <SimpleProductDescriptionModal\n            visible={isDescriptionModalVisible}\n            product={selectedProductForDescription}\n            onDismiss={handleCloseDescriptionModal}\n          />\n        </Portal>\n      </SafeAreaView>\n    );\n  };\n  return renderContent();\n};\n\nconst CreateOrderScreenWithCart = () => (\n  <CartProvider>\n    <CreateOrderScreen />\n  </CartProvider>\n);\n\nexport default CreateOrderScreenWithCart;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/screens/OpenOrdersScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'route' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":120,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":120,"endColumn":14},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'getStatusColor'. Either include it or remove the dependency array.","line":344,"column":5,"nodeType":"ArrayExpression","endLine":351,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [styles.orderCard, styles.cardContent, styles.mainContainer, styles.leftContainer, styles.orderNumber, styles.orderPrice, styles.timeAndPaymentRow, styles.orderTime, styles.estimatedTime, styles.rightContainer, styles.statusChip, styles.statusChipText, styles.printButton, styles.notes, styles.paymentBadge, styles.paymentBadgeText, getStatusColor, printKitchenTicketMutation.isPending, printKitchenTicketMutation.variables?.orderId, handleOpenPrinterModal]","fix":{"range":[12247,12436],"text":"[styles.orderCard, styles.cardContent, styles.mainContainer, styles.leftContainer, styles.orderNumber, styles.orderPrice, styles.timeAndPaymentRow, styles.orderTime, styles.estimatedTime, styles.rightContainer, styles.statusChip, styles.statusChipText, styles.printButton, styles.notes, styles.paymentBadge, styles.paymentBadgeText, getStatusColor, printKitchenTicketMutation.isPending, printKitchenTicketMutation.variables?.orderId, handleOpenPrinterModal]"}}]},{"ruleId":"no-misleading-character-class","severity":2,"message":"Unexpected combined character in character class.","line":365,"column":24,"nodeType":"Literal","messageId":"combiningClass","endLine":365,"endColumn":65},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":646,"column":19,"nodeType":"MemberExpression","messageId":"unexpected","endLine":646,"endColumn":30,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[23629,23685],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect, useState } from 'react';\nimport { StyleSheet, View, FlatList, ScrollView } from 'react-native';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport {\n  Text,\n  ActivityIndicator,\n  Appbar,\n  IconButton,\n  Portal,\n  Card,\n  Chip,\n} from 'react-native-paper';\nimport { useAppTheme, AppTheme } from '../../../app/styles/theme'; // Corregida ruta\nimport type { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport type { OrdersStackParamList } from '../../../app/navigation/types'; // Corregida ruta\nimport { useRoute } from '@react-navigation/native';\nimport {\n  useGetOpenOrdersQuery,\n  usePrintKitchenTicketMutation,\n  useUpdateOrderMutation,\n  useCancelOrderMutation,\n} from '../hooks/useOrdersQueries'; // Importar hooks y mutaciones\nimport { useCreateBulkAdjustmentsMutation } from '../hooks/useAdjustmentQueries'; // Importar mutations de ajustes\nimport {\n  Order,\n  OrderStatusEnum,\n  type OrderStatus,\n  OrderType,\n  OrderTypeEnum,\n} from '../types/orders.types'; // Importar OrderStatusEnum y el tipo OrderStatus\nimport { format } from 'date-fns'; // Para formatear fechas\nimport { es } from 'date-fns/locale'; // Locale español\nimport PrinterSelectionModal from '../components/PrinterSelectionModal'; // Importar el modal\nimport type { ThermalPrinter } from '../../printers/types/printer.types';\n// Importar OrderCartDetail y el tipo de payload\nimport OrderCartDetail, {\n  OrderDetailsForBackend,\n} from '../components/OrderCartDetail';\nimport { useListState } from '../../../app/hooks/useListState'; // Para estado de lista consistente\nimport { CartItem } from '../context/CartContext'; // Para el tipo CartItem\n\ntype OpenOrdersScreenProps = NativeStackScreenProps<\n  OrdersStackParamList,\n  'OpenOrders'\n>;\n\n// Helper para formatear el estado de la orden\nconst formatOrderStatus = (status: OrderStatus): string => {\n  switch (status) {\n    case OrderStatusEnum.PENDING:\n      return 'Pendiente';\n    case OrderStatusEnum.IN_PROGRESS:\n      return 'En Progreso';\n    case OrderStatusEnum.READY:\n      return 'Lista';\n    case OrderStatusEnum.DELIVERED:\n      return 'Entregada';\n    case OrderStatusEnum.COMPLETED:\n      return 'Completada';\n    case OrderStatusEnum.CANCELLED:\n      return 'Cancelada';\n    default:\n      return status;\n  }\n};\n\n// Helper para formatear el tipo de orden\nconst formatOrderType = (type: OrderType): string => {\n  switch (type) {\n    case OrderTypeEnum.DINE_IN:\n      return '🍽️ Para Comer Aquí';\n    case OrderTypeEnum.TAKE_AWAY:\n      return '🥡 Para Llevar';\n    case OrderTypeEnum.DELIVERY:\n      return '🚚 Domicilio';\n    default:\n      return type;\n  }\n};\n\n// Helper para formatear el tipo de orden corto (para el título)\nconst formatOrderTypeShort = (type: OrderType): string => {\n  switch (type) {\n    case OrderTypeEnum.DINE_IN:\n      return '🍽️ Local';\n    case OrderTypeEnum.TAKE_AWAY:\n      return '🥡 Llevar';\n    case OrderTypeEnum.DELIVERY:\n      return '🚚 Envío';\n    default:\n      return type;\n  }\n};\n\n// Helper para determinar el estado de pago de una orden\nconst getPaymentStatus = (order: Order): 'unpaid' | 'partial' | 'paid' => {\n  if (!order.payments || order.payments.length === 0) {\n    return 'unpaid';\n  }\n\n  // Sumar todos los pagos completados\n  const totalPaid = order.payments\n    .filter((payment: any) => payment.paymentStatus === 'COMPLETED')\n    .reduce((sum: number, payment: any) => sum + (payment.amount || 0), 0);\n\n  const orderTotal = order.total || 0;\n\n  if (totalPaid === 0) {\n    return 'unpaid';\n  } else if (totalPaid >= orderTotal) {\n    return 'paid';\n  } else {\n    return 'partial';\n  }\n};\n\nconst OpenOrdersScreen: React.FC<OpenOrdersScreenProps> = ({ navigation }) => {\n  const theme = useAppTheme();\n  const styles = React.useMemo(() => createStyles(theme), [theme]);\n  const route = useRoute<OpenOrdersScreenProps['route']>();\n  const [isPrinterModalVisible, setIsPrinterModalVisible] = useState(false);\n  const [orderToPrintId, setOrderToPrintId] = useState<string | null>(null);\n  const printKitchenTicketMutation = usePrintKitchenTicketMutation();\n\n  // Estados para el modal de edición\n  const [isEditModalVisible, setIsEditModalVisible] = useState(false);\n  const [editingOrderId, setEditingOrderId] = useState<string | null>(null); // Cambiado a ID\n  const [pendingProductsToAdd, setPendingProductsToAdd] = useState<CartItem[]>(\n    [],\n  );\n  // Estado para mantener productos temporales mientras se navega\n  const [temporaryProducts, setTemporaryProducts] = useState<{\n    [orderId: string]: CartItem[];\n  }>({});\n  // Estado para rastrear el conteo de items existentes en cada orden\n  const [existingItemsCount, setExistingItemsCount] = useState<{\n    [orderId: string]: number;\n  }>({});\n\n  // Estado para filtro de tipo de orden\n  const [selectedOrderType, setSelectedOrderType] = useState<OrderType | 'ALL'>(\n    'ALL',\n  );\n\n  // Instanciar las mutaciones\n  const updateOrderMutation = useUpdateOrderMutation();\n  const cancelOrderMutation = useCancelOrderMutation();\n  const createBulkAdjustmentsMutation = useCreateBulkAdjustmentsMutation();\n\n  const {\n    data: ordersData, // Renombrar para claridad, ahora es Order[] | undefined\n    isLoading,\n    refetch,\n    isFetching,\n  } = useGetOpenOrdersQuery(); // Usar el hook para obtener órdenes abiertas\n\n  // Filtrar órdenes por tipo\n  const filteredOrders = React.useMemo(() => {\n    if (!ordersData) return [];\n    if (selectedOrderType === 'ALL') return ordersData;\n    return ordersData.filter((order) => order.orderType === selectedOrderType);\n  }, [ordersData, selectedOrderType]);\n\n  // Ya no necesitamos procesar items agregados porque la actualización se hace directamente en CreateOrderScreen\n  // Este efecto se puede eliminar o simplificar\n\n  const getStatusColor = (status: OrderStatus) => {\n    switch (status) {\n      case OrderStatusEnum.PENDING:\n        return '#FFA000'; // Orange\n      case OrderStatusEnum.IN_PROGRESS:\n        return theme.colors.primary;\n      case OrderStatusEnum.READY:\n        return '#4CAF50'; // Green\n      case OrderStatusEnum.DELIVERED:\n        return theme.colors.tertiary;\n      default:\n        return theme.colors.onSurfaceVariant;\n    }\n  };\n\n  const handleRefresh = useCallback(() => {\n    refetch();\n  }, [refetch]);\n\n  // Función para abrir el modal de selección de impresora\n  const handleOpenPrinterModal = useCallback((orderId: string) => {\n    setOrderToPrintId(orderId);\n    setIsPrinterModalVisible(true);\n  }, []);\n\n  const handleOrderItemPress = (order: Order) => {\n    // Guardar solo el ID y abrir el modal\n    setEditingOrderId(order.id);\n    setIsEditModalVisible(true);\n  };\n\n  const renderOrderItem = useCallback(\n    ({ item: order }: { item: Order }) => {\n      // Construir el título según el tipo de orden\n      let orderTitle = `#${order.dailyNumber} • ${formatOrderTypeShort(order.orderType)}`;\n\n      if (order.orderType === OrderTypeEnum.DINE_IN && order.table) {\n        orderTitle += ` • ${order.table.area?.name || 'Sin área'} • Mesa ${order.table.name || order.table.number || 'N/A'}`;\n      } else if (order.orderType === OrderTypeEnum.TAKE_AWAY) {\n        if (order.deliveryInfo?.recipientName) {\n          orderTitle += ` • ${order.deliveryInfo.recipientName}`;\n        }\n        if (order.deliveryInfo?.recipientPhone) {\n          orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;\n        }\n      } else if (order.orderType === OrderTypeEnum.DELIVERY) {\n        if (order.deliveryInfo?.fullAddress) {\n          orderTitle += ` • ${order.deliveryInfo.fullAddress}`;\n        }\n        if (order.deliveryInfo?.recipientPhone) {\n          orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;\n        }\n      }\n\n      return (\n        <Card\n          style={styles.orderCard}\n          mode=\"elevated\"\n          onPress={() => handleOrderItemPress(order)}\n        >\n          <Card.Content style={styles.cardContent}>\n            {/* Main Container */}\n            <View style={styles.mainContainer}>\n              {/* Left Side - Title and Time */}\n              <View style={styles.leftContainer}>\n                <Text style={styles.orderNumber} numberOfLines={2}>\n                  {orderTitle}\n                  <Text style={styles.orderPrice}> • ${order.total}</Text>\n                </Text>\n                <View style={styles.timeAndPaymentRow}>\n                  <Text style={styles.orderTime}>\n                    {format(new Date(order.createdAt), 'p', { locale: es })}\n                  </Text>\n                  {order.estimatedDeliveryTime && (\n                    <Text style={styles.estimatedTime}>\n                      ⏱️{' '}\n                      {format(new Date(order.estimatedDeliveryTime), 'p', {\n                        locale: es,\n                      })}\n                    </Text>\n                  )}\n                  {(() => {\n                    const paymentStatus = getPaymentStatus(order);\n                    if (paymentStatus === 'paid') {\n                      return (\n                        <View\n                          style={[\n                            styles.paymentBadge,\n                            { backgroundColor: '#10B981' },\n                          ]}\n                        >\n                          <Text\n                            style={[\n                              styles.paymentBadgeText,\n                              { color: '#FFFFFF' },\n                            ]}\n                          >\n                            💵 Pagado\n                          </Text>\n                        </View>\n                      );\n                    } else if (paymentStatus === 'partial') {\n                      return (\n                        <View\n                          style={[\n                            styles.paymentBadge,\n                            { backgroundColor: '#F59E0B' },\n                          ]}\n                        >\n                          <Text\n                            style={[\n                              styles.paymentBadgeText,\n                              { color: '#FFFFFF' },\n                            ]}\n                          >\n                            💵 Parcial\n                          </Text>\n                        </View>\n                      );\n                    } else {\n                      return (\n                        <View\n                          style={[\n                            styles.paymentBadge,\n                            { backgroundColor: '#EF4444' },\n                          ]}\n                        >\n                          <Text\n                            style={[\n                              styles.paymentBadgeText,\n                              { color: '#FFFFFF' },\n                            ]}\n                          >\n                            💵 Pendiente\n                          </Text>\n                        </View>\n                      );\n                    }\n                  })()}\n                </View>\n              </View>\n\n              {/* Right Side - Status and Print */}\n              <View style={styles.rightContainer}>\n                <Chip\n                  mode=\"flat\"\n                  style={[\n                    styles.statusChip,\n                    { backgroundColor: getStatusColor(order.orderStatus) },\n                  ]}\n                  textStyle={styles.statusChipText}\n                >\n                  {formatOrderStatus(order.orderStatus)}\n                </Chip>\n                <IconButton\n                  icon=\"printer\"\n                  size={28}\n                  style={styles.printButton}\n                  onPress={() => handleOpenPrinterModal(order.id)}\n                  disabled={\n                    printKitchenTicketMutation.isPending &&\n                    printKitchenTicketMutation.variables?.orderId === order.id\n                  }\n                />\n              </View>\n            </View>\n\n            {/* Notes if any */}\n            {order.notes ? (\n              <Text style={styles.notes} numberOfLines={2}>\n                📝 {order.notes}\n              </Text>\n            ) : null}\n          </Card.Content>\n        </Card>\n      );\n    },\n    [\n      handleOrderItemPress,\n      handleOpenPrinterModal,\n      printKitchenTicketMutation.isPending,\n      printKitchenTicketMutation.variables?.orderId,\n      theme,\n      styles,\n    ],\n  );\n\n  const { ListEmptyComponent } = useListState({\n    isLoading,\n    isError: false, // Ya no usamos isError porque no está disponible desde useGetOpenOrdersQuery\n    data: filteredOrders,\n    emptyConfig: {\n      title:\n        selectedOrderType === 'ALL'\n          ? 'No hay órdenes abiertas'\n          : `No hay órdenes de tipo ${formatOrderType(\n              selectedOrderType as OrderType,\n            )\n              .replace(/[\\u{1F37D}\\u{FE0F}\\u{1F961}\\u{1F69A}]/gu, '')\n              .trim()}`,\n      message:\n        selectedOrderType === 'ALL'\n          ? 'No hay órdenes abiertas en este momento.'\n          : `No hay órdenes de este tipo en este momento.`,\n      icon: 'clipboard-text-outline',\n    },\n  });\n\n  // Efecto para configurar el botón de refrescar en el header\n  useEffect(() => {\n    navigation.setOptions({\n      headerRight: () => (\n        <Appbar.Action\n          icon=\"refresh\"\n          iconColor={theme.colors.onPrimary}\n          size={28}\n          onPress={handleRefresh}\n          disabled={isFetching} // Deshabilitar mientras se refresca\n          style={{ marginRight: 8 }} // Agregar margen para mejor accesibilidad\n        />\n      ),\n    });\n  }, [navigation, handleRefresh, isFetching, theme.colors.onPrimary]); // Añadir dependencias\n\n  // Efecto para sincronizar productos temporales con pendientes\n  useEffect(() => {\n    if (\n      isEditModalVisible &&\n      editingOrderId &&\n      temporaryProducts[editingOrderId]\n    ) {\n      setPendingProductsToAdd(temporaryProducts[editingOrderId]);\n    }\n  }, [isEditModalVisible, editingOrderId, temporaryProducts]);\n\n  // Función que se ejecuta al seleccionar una impresora en el modal\n  const handlePrinterSelect = useCallback(\n    (printer: ThermalPrinter) => {\n      setIsPrinterModalVisible(false);\n      if (orderToPrintId) {\n        // Llamar a la mutación para imprimir\n        printKitchenTicketMutation.mutate({\n          orderId: orderToPrintId,\n          printerId: printer.id,\n        });\n        setOrderToPrintId(null); // Limpiar el ID de la orden\n      } else {\n        console.warn(\n          'Se seleccionó una impresora pero no había ID de orden guardado.',\n        );\n      }\n    },\n    [orderToPrintId, printKitchenTicketMutation],\n  ); // Dependencias\n\n  // Función para manejar la cancelación de una orden\n  const handleCancelOrder = useCallback(\n    async (orderId: string) => {\n      try {\n        await cancelOrderMutation.mutateAsync(orderId);\n        // Cerrar el modal después de cancelar exitosamente\n        setIsEditModalVisible(false);\n        setEditingOrderId(null);\n      } catch (error) {\n        console.error('Error al cancelar la orden:', error);\n        // El error se muestra a través del hook useCancelOrderMutation\n      }\n    },\n    [cancelOrderMutation],\n  );\n\n  return (\n    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>\n      {isLoading && !ordersData ? (\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" color={theme.colors.primary} />\n          <Text style={styles.loadingText}>Cargando órdenes...</Text>\n        </View>\n      ) : (\n        <>\n          {/* Filtros de tipo de orden - Fuera del View para mantener posición fija */}\n          <View style={styles.filterWrapper}>\n            <ScrollView\n              horizontal\n              showsHorizontalScrollIndicator={false}\n              style={styles.filterContainer}\n              contentContainerStyle={styles.filterContentContainer}\n            >\n              <Chip\n                mode=\"outlined\"\n                selected={selectedOrderType === 'ALL'}\n                onPress={() => setSelectedOrderType('ALL')}\n                style={[\n                  styles.filterChip,\n                  selectedOrderType === 'ALL' && styles.filterChipSelected,\n                ]}\n                textStyle={[\n                  styles.filterChipText,\n                  selectedOrderType === 'ALL' && styles.filterChipTextSelected,\n                ]}\n              >\n                Todas\n              </Chip>\n              <Chip\n                mode=\"outlined\"\n                selected={selectedOrderType === OrderTypeEnum.DINE_IN}\n                onPress={() => setSelectedOrderType(OrderTypeEnum.DINE_IN)}\n                style={[\n                  styles.filterChip,\n                  selectedOrderType === OrderTypeEnum.DINE_IN &&\n                    styles.filterChipSelected,\n                ]}\n                textStyle={[\n                  styles.filterChipText,\n                  selectedOrderType === OrderTypeEnum.DINE_IN &&\n                    styles.filterChipTextSelected,\n                ]}\n                icon=\"silverware-fork-knife\"\n              >\n                Para Comer Aquí\n              </Chip>\n              <Chip\n                mode=\"outlined\"\n                selected={selectedOrderType === OrderTypeEnum.TAKE_AWAY}\n                onPress={() => setSelectedOrderType(OrderTypeEnum.TAKE_AWAY)}\n                style={[\n                  styles.filterChip,\n                  selectedOrderType === OrderTypeEnum.TAKE_AWAY &&\n                    styles.filterChipSelected,\n                ]}\n                textStyle={[\n                  styles.filterChipText,\n                  selectedOrderType === OrderTypeEnum.TAKE_AWAY &&\n                    styles.filterChipTextSelected,\n                ]}\n                icon=\"package-variant\"\n              >\n                Para Llevar\n              </Chip>\n              <Chip\n                mode=\"outlined\"\n                selected={selectedOrderType === OrderTypeEnum.DELIVERY}\n                onPress={() => setSelectedOrderType(OrderTypeEnum.DELIVERY)}\n                style={[\n                  styles.filterChip,\n                  selectedOrderType === OrderTypeEnum.DELIVERY &&\n                    styles.filterChipSelected,\n                ]}\n                textStyle={[\n                  styles.filterChipText,\n                  selectedOrderType === OrderTypeEnum.DELIVERY &&\n                    styles.filterChipTextSelected,\n                ]}\n                icon=\"truck-delivery\"\n              >\n                Domicilio\n              </Chip>\n            </ScrollView>\n          </View>\n\n          {/* Lista de órdenes */}\n          <View style={styles.listContainer}>\n            <FlatList\n              data={filteredOrders}\n              keyExtractor={(item) => item.id}\n              renderItem={renderOrderItem}\n              refreshing={isFetching}\n              onRefresh={handleRefresh}\n              contentContainerStyle={styles.listContentContainer}\n              ListEmptyComponent={ListEmptyComponent}\n            />\n          </View>\n        </>\n      )}\n      {/* Modal de Selección de Impresora */}\n      <Portal>\n        <PrinterSelectionModal\n          visible={isPrinterModalVisible}\n          onDismiss={() => setIsPrinterModalVisible(false)}\n          onPrinterSelect={handlePrinterSelect}\n        />\n        {/* Modal de Edición de Orden usando OrderCartDetail */}\n        {editingOrderId && (\n          <OrderCartDetail\n            visible={isEditModalVisible}\n            isEditMode={true}\n            orderId={editingOrderId}\n            orderNumber={\n              ordersData?.find((o) => o.id === editingOrderId)?.dailyNumber\n            }\n            orderDate={\n              ordersData?.find((o) => o.id === editingOrderId)?.createdAt\n                ? new Date(\n                    ordersData.find((o) => o.id === editingOrderId)!.createdAt,\n                  )\n                : undefined\n            }\n            navigation={navigation}\n            pendingProductsToAdd={\n              editingOrderId && temporaryProducts[editingOrderId]\n                ? temporaryProducts[editingOrderId]\n                : pendingProductsToAdd\n            }\n            onItemsCountChanged={(count) => {\n              // Actualizar el conteo de items existentes para esta orden\n              setExistingItemsCount((prev) => ({\n                ...prev,\n                [editingOrderId]: count,\n              }));\n            }}\n            onClose={() => {\n              setIsEditModalVisible(false);\n              setEditingOrderId(null);\n              setPendingProductsToAdd([]);\n              // NO limpiar temporaryProducts aquí para mantener los productos\n              // Refrescar la lista de órdenes por si hubo cambios\n              refetch();\n            }}\n            onAddProducts={() => {\n              // Cerrar el modal temporalmente para navegar\n              setIsEditModalVisible(false);\n\n              const orderId = editingOrderId;\n              const orderNumber = ordersData?.find(\n                (o) => o.id === editingOrderId,\n              )?.dailyNumber;\n\n              // Navegar a añadir productos\n              setTimeout(() => {\n                const existingProducts = temporaryProducts[orderId!] || [];\n                navigation.navigate('AddProductsToOrder', {\n                  orderId: orderId!,\n                  orderNumber: orderNumber!,\n                  // Pasar productos temporales existentes si los hay\n                  existingTempProducts: existingProducts,\n                  existingOrderItemsCount: existingItemsCount[orderId!] || 0, // Usar el conteo rastreado\n                  onProductsAdded: (newProducts) => {\n                    // Actualizar productos temporales para esta orden\n                    setTemporaryProducts((prev) => ({\n                      ...prev,\n                      [orderId!]: newProducts,\n                    }));\n                    // NO establecer pendingProductsToAdd aquí, se hará en el useEffect\n                    // Reabrir el modal cuando regresemos\n                    setIsEditModalVisible(true);\n                  },\n                });\n              }, 100);\n            }}\n            onConfirmOrder={async (details: OrderDetailsForBackend) => {\n              // Adaptar el formato de OrderDetailsForBackend a UpdateOrderPayload\n              const payload = {\n                orderType: details.orderType,\n                items: details.items, // Enviar items para actualizar\n                tableId: details.tableId || null,\n                scheduledAt: details.scheduledAt || null,\n                deliveryInfo: details.deliveryInfo,\n                notes: details.notes || null,\n                total: details.total,\n                subtotal: details.subtotal,\n                // NO incluir ajustes aquí, se manejan por separado\n              };\n\n              try {\n                // Primero actualizar la orden\n                await updateOrderMutation.mutateAsync({\n                  orderId: editingOrderId,\n                  payload,\n                });\n\n                // Luego, si hay ajustes, crearlos\n                if (details.adjustments && details.adjustments.length > 0) {\n                  // Asegurarse de que cada ajuste tenga el orderId correcto\n                  const adjustmentsWithOrderId = details.adjustments.map(\n                    (adj) => ({\n                      ...adj,\n                      orderId: editingOrderId,\n                    }),\n                  );\n                  console.log('Ajustes a crear:', adjustmentsWithOrderId);\n                  await createBulkAdjustmentsMutation.mutateAsync(\n                    adjustmentsWithOrderId,\n                  );\n                }\n\n                // Limpiar estados después de actualización exitosa\n                setIsEditModalVisible(false);\n                setEditingOrderId(null);\n                // Limpiar productos temporales y conteo para esta orden\n                if (editingOrderId) {\n                  setTemporaryProducts((prev) => {\n                    const newState = { ...prev };\n                    delete newState[editingOrderId];\n                    return newState;\n                  });\n                  setExistingItemsCount((prev) => {\n                    const newState = { ...prev };\n                    delete newState[editingOrderId];\n                    return newState;\n                  });\n                }\n              } catch (error) {\n                console.error('Error al actualizar la orden:', error);\n                // No cerrar el modal en caso de error para que el usuario pueda reintentar\n              }\n            }}\n            onCancelOrder={() => {\n              if (editingOrderId) {\n                handleCancelOrder(editingOrderId);\n              }\n            }}\n          />\n        )}\n      </Portal>\n    </SafeAreaView>\n  );\n};\n\nconst createStyles = (\n  theme: AppTheme, // Usar AppTheme directamente\n) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    loadingContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    loadingText: {\n      marginTop: theme.spacing.m,\n      color: theme.colors.onSurfaceVariant,\n    },\n    filterWrapper: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      right: 0,\n      zIndex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    filterContainer: {\n      backgroundColor: theme.colors.surface,\n      elevation: 2,\n      shadowOpacity: 0.1,\n      shadowRadius: 2,\n      shadowOffset: { width: 0, height: 1 },\n      height: 56,\n    },\n    filterContentContainer: {\n      paddingHorizontal: theme.spacing.m,\n      paddingVertical: theme.spacing.s,\n      gap: theme.spacing.s,\n      alignItems: 'center',\n    },\n    filterChip: {\n      marginRight: theme.spacing.xs,\n      height: 32,\n      backgroundColor: theme.colors.surface,\n    },\n    filterChipSelected: {\n      backgroundColor: theme.colors.primaryContainer,\n      borderColor: theme.colors.primary,\n      borderWidth: 2,\n      elevation: 3,\n    },\n    filterChipText: {\n      fontSize: 12,\n      lineHeight: 16,\n    },\n    filterChipTextSelected: {\n      color: theme.colors.onPrimaryContainer,\n      fontWeight: '600',\n    },\n    listContainer: {\n      flex: 1,\n      paddingTop: 56, // Mismo height que filterContainer\n    },\n    listContentContainer: {\n      padding: theme.spacing.s, // Reducido de theme.spacing.m\n      paddingBottom: theme.spacing.l * 2,\n      flexGrow: 1,\n    },\n    orderCard: {\n      marginBottom: theme.spacing.s, // Reducido de theme.spacing.m\n      backgroundColor: theme.colors.surface,\n    },\n    cardContent: {\n      paddingBottom: theme.spacing.s,\n    },\n    mainContainer: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'flex-start',\n    },\n    leftContainer: {\n      flex: 1,\n      paddingRight: theme.spacing.s,\n    },\n    rightContainer: {\n      alignItems: 'center',\n      justifyContent: 'flex-start',\n    },\n    orderNumber: {\n      ...theme.fonts.bodyLarge,\n      fontWeight: 'bold',\n      color: theme.colors.onSurface,\n      lineHeight: 22,\n      marginBottom: theme.spacing.xs,\n    },\n    orderPrice: {\n      color: theme.colors.primary,\n      fontWeight: '700',\n    },\n    statusChip: {\n      height: 28,\n      minHeight: 28,\n      marginBottom: theme.spacing.xs,\n    },\n    statusChipText: {\n      fontSize: 12,\n      fontWeight: '600',\n      color: 'white',\n      lineHeight: 16,\n    },\n    paidChip: {\n      height: 28,\n      minHeight: 28,\n      marginBottom: theme.spacing.xs,\n    },\n    paidChipText: {\n      fontSize: 12,\n      fontWeight: '600',\n      color: 'white',\n      lineHeight: 16,\n    },\n    orderTime: {\n      ...theme.fonts.titleMedium,\n      color: theme.colors.primary,\n      fontWeight: '600',\n    },\n    estimatedTime: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurfaceVariant,\n      marginLeft: theme.spacing.xs,\n    },\n    timeAndPaymentRow: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      gap: theme.spacing.s,\n    },\n    paymentBadge: {\n      paddingHorizontal: 8,\n      paddingVertical: 2,\n      borderRadius: 12,\n      alignItems: 'center',\n      justifyContent: 'center',\n    },\n    paymentBadgeText: {\n      ...theme.fonts.labelSmall,\n      fontWeight: '600',\n      fontSize: 11,\n      lineHeight: 14,\n    },\n    printButton: {\n      margin: 0,\n      padding: theme.spacing.xs, // Aumentar el área táctil\n    },\n    customerInfo: {\n      ...theme.fonts.bodyMedium,\n      color: theme.colors.onSurfaceVariant,\n      marginBottom: theme.spacing.xs, // Reducido de theme.spacing.s\n    },\n    phoneInfo: {\n      ...theme.fonts.bodySmall,\n      color: theme.colors.onSurfaceVariant,\n      marginBottom: theme.spacing.xs,\n    },\n    notes: {\n      ...theme.fonts.bodySmall,\n      color: theme.colors.onSurfaceVariant,\n      marginTop: theme.spacing.xs, // Reducido de theme.spacing.s\n      fontStyle: 'italic',\n    },\n  });\n\nexport default OpenOrdersScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/screens/OrdersScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/services/adjustmentService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/services/orderService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/services/paymentService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/types/adjustments.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/types/orders.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/types/payment.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/orders/types/update-order.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/components/PizzaCustomizationCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IconButton' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":38}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport { Card, Text, Chip, IconButton } from 'react-native-paper';\nimport { useAppTheme } from '@/app/styles/theme';\nimport {\n  CustomizationType,\n  type PizzaCustomization,\n} from '../types/pizzaCustomization.types';\n\ninterface PizzaCustomizationCardProps {\n  customization: PizzaCustomization;\n  onPress: () => void;\n}\n\nexport function PizzaCustomizationCard({\n  customization,\n  onPress,\n}: PizzaCustomizationCardProps) {\n  const theme = useAppTheme();\n\n  const styles = StyleSheet.create({\n    card: {\n      marginBottom: theme.spacing.s,\n    },\n    content: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      paddingVertical: -4,\n    },\n    info: {\n      flex: 1,\n    },\n    name: {\n      ...theme.fonts.titleMedium,\n      color: theme.colors.onSurface,\n      marginBottom: 2,\n    },\n    ingredients: {\n      ...theme.fonts.bodySmall,\n      color: theme.colors.onSurfaceVariant,\n      fontStyle: 'italic',\n      lineHeight: 16,\n    },\n    chip: {\n      marginRight: theme.spacing.xs,\n      height: 24,\n    },\n    rightSection: {\n      alignItems: 'flex-end',\n      marginLeft: theme.spacing.s,\n    },\n    toppingValue: {\n      ...theme.fonts.titleLarge,\n      color: theme.colors.primary,\n      fontWeight: 'bold',\n    },\n    toppingLabel: {\n      ...theme.fonts.labelSmall,\n      color: theme.colors.onSurfaceVariant,\n      marginTop: -2,\n    },\n  });\n\n  const getTypeLabel = (type: CustomizationType) => {\n    return type === CustomizationType.FLAVOR ? 'Sabor' : 'Ingrediente';\n  };\n\n  const getTypeIcon = (type: CustomizationType) => {\n    return type === CustomizationType.FLAVOR ? 'pizza' : 'food-variant';\n  };\n\n  return (\n    <Card style={styles.card} onPress={onPress} mode=\"contained\">\n      <Card.Content style={{ paddingVertical: 12, paddingHorizontal: 16 }}>\n        <View style={styles.content}>\n          <View style={styles.info}>\n            <View\n              style={{\n                flexDirection: 'row',\n                alignItems: 'center',\n                marginBottom: 4,\n              }}\n            >\n              <Text style={styles.name}>{customization.name}</Text>\n              <Chip\n                icon={getTypeIcon(customization.type)}\n                style={[styles.chip, { marginLeft: theme.spacing.s }]}\n                compact\n                textStyle={{ fontSize: 11 }}\n              >\n                {getTypeLabel(customization.type)}\n              </Chip>\n              {!customization.isActive && (\n                <Chip\n                  icon=\"eye-off\"\n                  style={[styles.chip, { marginLeft: theme.spacing.xs }]}\n                  compact\n                  mode=\"outlined\"\n                  textStyle={{ fontSize: 11 }}\n                >\n                  Inactivo\n                </Chip>\n              )}\n            </View>\n\n            {customization.ingredients && (\n              <Text style={styles.ingredients} numberOfLines={1}>\n                {customization.ingredients}\n              </Text>\n            )}\n          </View>\n\n          <View style={styles.rightSection}>\n            <Text style={styles.toppingValue}>\n              {customization.toppingValue}\n            </Text>\n            <Text style={styles.toppingLabel}>\n              topping{customization.toppingValue !== 1 ? 's' : ''}\n            </Text>\n          </View>\n        </View>\n      </Card.Content>\n    </Card>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/hooks/usePizzaCustomizationsQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/schema/pizzaConfiguration.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/schema/pizzaCustomization.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/screens/AssociatePizzaCustomizationsScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport { Text } from 'react-native-paper';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useAppTheme } from '@/app/styles/theme';\n\nexport function AssociatePizzaCustomizationsScreen() {\n  const theme = useAppTheme();\n\n  const styles = StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n  });\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <Text>Asociar Personalizaciones - Por implementar</Text>\n    </SafeAreaView>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/screens/PizzaConfigurationsScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport { Text } from 'react-native-paper';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useAppTheme } from '@/app/styles/theme';\n\nexport function PizzaConfigurationsScreen() {\n  const theme = useAppTheme();\n\n  const styles = StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n  });\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <Text>Configuración de Pizzas - Por implementar</Text>\n    </SafeAreaView>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/screens/PizzaCustomizationDetailScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport { Text } from 'react-native-paper';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useAppTheme } from '@/app/styles/theme';\n\nexport function PizzaCustomizationDetailScreen() {\n  const theme = useAppTheme();\n\n  const styles = StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n  });\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <Text>Detalle de Personalización - Por implementar</Text>\n    </SafeAreaView>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/screens/PizzaCustomizationsListScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Chip' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Portal' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Modal' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isError' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":41,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":35}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport {\n  Text,\n  FAB,\n  Searchbar,\n  Chip,\n  ActivityIndicator,\n  Portal,\n  Modal,\n  Button,\n  Menu,\n  IconButton,\n  SegmentedButtons,\n} from 'react-native-paper';\nimport { FlashList } from '@shopify/flash-list';\nimport { useNavigation } from '@react-navigation/native';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useAppTheme } from '@/app/styles/theme';\nimport { usePizzaCustomizationsList } from '../hooks/usePizzaCustomizationsQueries';\nimport { PizzaCustomizationCard } from '../components/PizzaCustomizationCard';\nimport { CustomizationType } from '../types/pizzaCustomization.types';\nimport type { NativeStackNavigationProp } from '@react-navigation/native-stack';\nimport type { PizzaCustomizationsStackParamList } from '../navigation/types';\n\ntype NavigationProp = NativeStackNavigationProp<\n  PizzaCustomizationsStackParamList,\n  'PizzaCustomizationsList'\n>;\n\nexport function PizzaCustomizationsListScreen() {\n  const theme = useAppTheme();\n  const navigation = useNavigation<NavigationProp>();\n\n  const [searchQuery, setSearchQuery] = useState('');\n  const [selectedType, setSelectedType] = useState<CustomizationType | 'all'>(\n    'all',\n  );\n  const [menuVisible, setMenuVisible] = useState(false);\n\n  const { data, isLoading, isError, refetch } = usePizzaCustomizationsList({\n    search: searchQuery || undefined,\n    type: selectedType === 'all' ? undefined : selectedType,\n  });\n\n  const filteredData = data?.data || [];\n\n  const styles = StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    header: {\n      padding: theme.spacing.s,\n      backgroundColor: theme.colors.surface,\n      elevation: 2,\n    },\n    headerTop: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      marginBottom: theme.spacing.s,\n    },\n    searchbar: {\n      flex: 1,\n      marginRight: theme.spacing.s,\n    },\n    segmentedButtons: {\n      marginBottom: 0,\n    },\n    content: {\n      flex: 1,\n    },\n    listContainer: {\n      padding: theme.spacing.s,\n    },\n    emptyContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.xl,\n    },\n    emptyText: {\n      ...theme.fonts.bodyLarge,\n      color: theme.colors.onSurfaceVariant,\n      textAlign: 'center',\n      marginTop: theme.spacing.m,\n    },\n    fab: {\n      position: 'absolute',\n      margin: 16,\n      right: 0,\n      bottom: 0,\n      backgroundColor: theme.colors.primary,\n    },\n  });\n\n  const renderItem = ({ item }: { item: any }) => (\n    <PizzaCustomizationCard\n      customization={item}\n      onPress={() =>\n        navigation.navigate('PizzaCustomizationDetail', { id: item.id })\n      }\n    />\n  );\n\n  const renderEmpty = () => (\n    <View style={styles.emptyContainer}>\n      <Text style={styles.emptyText}>No hay personalizaciones disponibles</Text>\n    </View>\n  );\n\n  if (isLoading) {\n    return (\n      <View\n        style={[\n          styles.container,\n          { justifyContent: 'center', alignItems: 'center' },\n        ]}\n      >\n        <ActivityIndicator size=\"large\" />\n      </View>\n    );\n  }\n\n  return (\n    <SafeAreaView style={styles.container} edges={['bottom']}>\n      <View style={styles.header}>\n        <View style={styles.headerTop}>\n          <Searchbar\n            placeholder=\"Buscar personalización...\"\n            onChangeText={setSearchQuery}\n            value={searchQuery}\n            style={styles.searchbar}\n            mode=\"bar\"\n            elevation={0}\n          />\n\n          <Menu\n            visible={menuVisible}\n            onDismiss={() => setMenuVisible(false)}\n            anchor={\n              <IconButton\n                icon=\"dots-vertical\"\n                onPress={() => setMenuVisible(true)}\n                size={24}\n              />\n            }\n          >\n            <Menu.Item\n              onPress={() => {\n                setMenuVisible(false);\n                navigation.navigate('PizzaConfigurations');\n              }}\n              title=\"Configuración de Precios\"\n              leadingIcon=\"currency-usd\"\n            />\n            <Menu.Item\n              onPress={() => {\n                setMenuVisible(false);\n                navigation.navigate('AssociatePizzaCustomizations');\n              }}\n              title=\"Asociar a Pizzas\"\n              leadingIcon=\"link-variant\"\n            />\n          </Menu>\n        </View>\n\n        <SegmentedButtons\n          value={selectedType}\n          onValueChange={(value) =>\n            setSelectedType(value as CustomizationType | 'all')\n          }\n          buttons={[\n            { value: 'all', label: 'Todas' },\n            { value: CustomizationType.FLAVOR, label: 'Sabores' },\n            { value: CustomizationType.INGREDIENT, label: 'Ingredientes' },\n          ]}\n          style={styles.segmentedButtons}\n          density=\"small\"\n        />\n      </View>\n\n      <View style={styles.content}>\n        <FlashList\n          data={filteredData}\n          renderItem={renderItem}\n          estimatedItemSize={100}\n          ListEmptyComponent={renderEmpty}\n          contentContainerStyle={styles.listContainer}\n          keyExtractor={(item) => item.id}\n          refreshing={isLoading}\n          onRefresh={refetch}\n        />\n      </View>\n\n      <FAB\n        icon=\"plus\"\n        style={styles.fab}\n        onPress={() => navigation.navigate('PizzaCustomizationDetail', {})}\n        size=\"medium\"\n      />\n    </SafeAreaView>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/services/pizzaConfigurationsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/services/pizzaCustomizationsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/types/pizzaConfiguration.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/pizzaCustomizations/types/pizzaCustomization.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/components/PreparationScreenFormModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/components/ProductSelectionModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/hooks/usePreparationScreensQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/navigation/PreparationScreensStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/schema/preparationScreen.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/schema/preparationScreens.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/screens/PreparationScreensScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/services/preparationScreenService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/preparationScreens/types/preparationScreens.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/printers/components/PrinterDiscoveryModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useState' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Card' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":7},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'discoverMutation' and 'showSnackbar'. Either include them or remove the dependency array.","line":56,"column":6,"nodeType":"ArrayExpression","endLine":56,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [discoverMutation, showSnackbar, visible]","fix":{"range":[1723,1732],"text":"[discoverMutation, showSnackbar, visible]"}}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo } from 'react';\nimport { View, StyleSheet } from 'react-native'; // FlatList eliminado\nimport { FlashList, ListRenderItemInfo } from '@shopify/flash-list'; // Importar FlashList y tipo\nimport {\n  Modal,\n  Portal,\n  Text,\n  Button,\n  ActivityIndicator,\n  List,\n  Icon, // Añadir Icon a la importación\n  Divider,\n  IconButton,\n  Card,\n  Appbar, // Importar Appbar\n} from 'react-native-paper';\nimport {\n  useDiscoverPrinters,\n  useTestPrintDiscoveredPrinter,\n} from '../hooks/usePrintersQueries';\nimport { DiscoveredPrinter } from '../types/printer.types';\nimport { useAppTheme, AppTheme } from '@/app/styles/theme';\nimport { useSnackbarStore } from '@/app/store/snackbarStore';\nimport { getApiErrorMessage } from '@/app/lib/errorMapping';\n\ninterface PrinterDiscoveryModalProps {\n  visible: boolean;\n  onDismiss: () => void;\n  onPrinterSelect: (printer: DiscoveredPrinter) => void; // Callback cuando se selecciona una impresora\n}\n\nconst PrinterDiscoveryModal: React.FC<PrinterDiscoveryModalProps> = ({\n  visible,\n  onDismiss,\n  onPrinterSelect,\n}) => {\n  const theme = useAppTheme();\n  const styles = useMemo(() => createStyles(theme), [theme]);\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  const discoverMutation = useDiscoverPrinters();\n  const testPrintMutation = useTestPrintDiscoveredPrinter();\n\n  useEffect(() => {\n    if (visible) {\n      discoverMutation.mutate(undefined, {\n        // undefined para usar la duración por defecto\n        onError: (error) => {\n          showSnackbar({\n            message: `Error descubriendo impresoras: ${getApiErrorMessage(error)}`,\n            type: 'error',\n          });\n        },\n      });\n    }\n  }, [visible]); // Ejecutar solo cuando 'visible' cambia\n\n  const handleRescan = () => {\n    discoverMutation.mutate(undefined); // Volver a escanear con duración por defecto\n  };\n\n  const handleTestPrint = (printer: DiscoveredPrinter) => {\n    testPrintMutation.mutate(printer);\n  };\n\n  const renderPrinterItem = (\n    { item }: ListRenderItemInfo<DiscoveredPrinter>, // Añadir tipo\n  ) => (\n    <List.Item\n      title={item.name || item.ip} // Mostrar nombre o IP si no hay nombre\n      description={`IP: ${item.ip}:${item.port}${item.mac ? ` | MAC: ${item.mac}` : ''}${item.model ? ` (${item.model})` : ''}`}\n      left={(props) => <List.Icon {...props} icon=\"printer\" />}\n      right={(props) => (\n        <View style={styles.itemActions}>\n          <IconButton\n            {...props}\n            icon=\"printer-check\"\n            size={24}\n            onPress={() => handleTestPrint(item)}\n            disabled={testPrintMutation.isPending}\n            loading={\n              testPrintMutation.isPending &&\n              testPrintMutation.variables?.ip === item.ip\n            }\n            tooltip=\"Imprimir prueba\"\n          />\n          <IconButton\n            {...props}\n            icon=\"plus\"\n            size={24}\n            onPress={() => onPrinterSelect(item)}\n            disabled={testPrintMutation.isPending}\n            tooltip=\"Agregar impresora\"\n          />\n        </View>\n      )}\n      style={styles.listItem}\n      titleStyle={styles.itemTitle}\n      descriptionStyle={styles.itemDescription}\n    />\n  );\n\n  return (\n    <Portal>\n      <Modal\n        visible={visible}\n        onDismiss={onDismiss}\n        contentContainerStyle={styles.modalContent}\n        dismissable={\n          !discoverMutation.isPending && !testPrintMutation.isPending\n        } // No permitir cerrar mientras busca o imprime\n      >\n        <Appbar.Header style={styles.appBar} elevated>\n          <Appbar.BackAction\n            onPress={onDismiss}\n            disabled={discoverMutation.isPending || testPrintMutation.isPending}\n          />\n          <Appbar.Content\n            title=\"Descubrir Impresoras\"\n            titleStyle={styles.appBarTitle}\n          />\n          {/* Botón de Refrescar/Re-escanear */}\n          <Appbar.Action\n            icon=\"refresh\"\n            size={32} // <-- Aumentar tamaño del icono\n            onPress={handleRescan}\n            disabled={discoverMutation.isPending || testPrintMutation.isPending}\n            color={theme.colors.primary} // Color distintivo\n          />\n        </Appbar.Header>\n\n        <View style={styles.contentContainer}>\n          {discoverMutation.isPending && (\n            <View style={styles.centeredView}>\n              <ActivityIndicator animating={true} size=\"large\" />\n              <Text style={styles.statusText}>\n                Buscando impresoras en la red...\n              </Text>\n              <Text style={styles.statusSubText}>\n                (Esto puede tardar unos segundos)\n              </Text>\n            </View>\n          )}\n\n          {discoverMutation.isError && !discoverMutation.isPending && (\n            <View style={styles.centeredView}>\n              <Icon\n                source=\"alert-circle-outline\"\n                color={theme.colors.error}\n                size={48}\n              />\n              <Text style={styles.errorText}>\n                Error al buscar impresoras:{' '}\n                {getApiErrorMessage(discoverMutation.error)}\n              </Text>\n              {/* Botón eliminado, se usa el icono en Appbar */}\n            </View>\n          )}\n\n          {discoverMutation.isSuccess && !discoverMutation.isPending && (\n            <>\n              {discoverMutation.data.length === 0 ? (\n                <View style={styles.centeredView}>\n                  <Icon\n                    source=\"printer-off\"\n                    color={theme.colors.onSurfaceVariant}\n                    size={48}\n                  />\n                  <Text style={styles.statusText}>\n                    No se encontraron impresoras.\n                  </Text>\n                  <Text style={styles.statusSubText}>\n                    Asegúrate de que estén encendidas y en la misma red.\n                  </Text>\n                  {/* Botón eliminado, se usa el icono en Appbar */}\n                </View>\n              ) : (\n                <>\n                  {/* Texto estilizado */}\n                  <Text style={styles.foundText}>Impresoras encontradas:</Text>\n                  <FlashList\n                    data={discoverMutation.data}\n                    renderItem={renderPrinterItem}\n                    keyExtractor={(item: DiscoveredPrinter) =>\n                      `${item.ip}:${item.port}`\n                    } // Añadir tipo y clave única\n                    estimatedItemSize={70} // Añadir tamaño estimado\n                    ItemSeparatorComponent={() => (\n                      <Divider style={styles.divider} />\n                    )}\n                  />\n                  {/* Botón eliminado, se usa el icono en Appbar */}\n                </>\n              )}\n            </>\n          )}\n        </View>\n\n        {/* Footer eliminado, se usa Appbar.BackAction */}\n      </Modal>\n    </Portal>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    modalContent: {\n      backgroundColor: theme.colors.background,\n\n      width: '100%',\n      height: '100%',\n      margin: 0,\n\n      justifyContent: 'flex-start', // Alinear contenido arriba\n    },\n    appBar: {\n      backgroundColor: theme.colors.elevation.level2,\n    },\n    appBarTitle: {\n      ...theme.fonts.titleMedium,\n      color: theme.colors.onSurface,\n      fontWeight: 'bold',\n      textAlign: 'center', // Centrar título\n    },\n    contentContainer: {\n      flex: 1, // Ocupar espacio restante\n      padding: theme.spacing.m,\n    },\n    centeredView: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.l,\n    },\n    statusText: {\n      marginTop: theme.spacing.m,\n      fontSize: 16,\n      textAlign: 'center',\n      color: theme.colors.onSurface,\n    },\n    statusSubText: {\n      marginTop: theme.spacing.xs,\n      fontSize: 14,\n      textAlign: 'center',\n      color: theme.colors.onSurfaceVariant,\n    },\n    errorText: {\n      marginTop: theme.spacing.m,\n      color: theme.colors.error,\n      textAlign: 'center',\n      marginBottom: theme.spacing.m,\n    },\n    foundText: {\n      fontSize: 16,\n      fontWeight: 'bold',\n      marginBottom: theme.spacing.m,\n      color: theme.colors.primary, // Color primario para destacar\n    },\n    list: {\n      flex: 1, // Permitir que la lista ocupe espacio\n      marginBottom: theme.spacing.m, // Espacio antes del botón de re-escanear\n    },\n    listItem: {\n      backgroundColor: theme.colors.surface,\n      borderRadius: theme.roundness,\n      marginBottom: theme.spacing.xs,\n    },\n    itemTitle: {\n      fontWeight: '500',\n    },\n    itemDescription: {\n      fontSize: 12,\n      color: theme.colors.onSurfaceVariant,\n    },\n    itemActions: {\n      flexDirection: 'row',\n      alignItems: 'center',\n    },\n    divider: {\n      height: 0, // Ocultar divider si no se desea\n    },\n    button: {\n      marginTop: theme.spacing.m,\n      minWidth: 150, // Ancho mínimo para botones\n    },\n    // Estilo footer eliminado\n  });\n\nexport default PrinterDiscoveryModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/printers/components/PrinterFormModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/printers/hooks/usePrintersQueries.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'QueryKey' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'variables' is defined but never used. Allowed unused args must match /^_/u.","line":140,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":140,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'printerId' is defined but never used. Allowed unused args must match /^_/u.","line":189,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":189,"endColumn":32}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  useMutation,\n  UseMutationResult,\n  useQuery,\n  UseQueryResult,\n  useQueryClient,\n  QueryKey,\n} from '@tanstack/react-query';\nimport { printerService } from '../services/printerService';\nimport {\n  DiscoveredPrinter,\n  ThermalPrinter,\n  CreateThermalPrinterDto,\n  UpdateThermalPrinterDto,\n  FindAllThermalPrintersDto,\n} from '../types/printer.types';\nimport { ApiError } from '../../../app/lib/errors';\nimport { PaginatedResponse } from '../../../app/types/api.types';\nimport { useSnackbarStore } from '../../../app/store/snackbarStore';\nimport { getApiErrorMessage } from '../../../app/lib/errorMapping';\n\n// --- Query Keys ---\nconst printerKeys = {\n  all: ['thermalPrinters'] as const,\n  lists: () => [...printerKeys.all, 'list'] as const,\n  list: (filters: FindAllThermalPrintersDto) =>\n    [...printerKeys.lists(), filters] as const,\n  details: () => [...printerKeys.all, 'detail'] as const,\n  detail: (id: string) => [...printerKeys.details(), id] as const,\n  discover: ['discoverPrinters'] as const, // Clave para descubrimiento\n};\n\n/**\n * Hook para disparar el descubrimiento de impresoras.\n * Utiliza useMutation ya que es una acción iniciada por el usuario.\n */\nexport const useDiscoverPrinters = (): UseMutationResult<\n  DiscoveredPrinter[], // Tipo de dato que devuelve la mutación en caso de éxito\n  ApiError, // Tipo de error esperado\n  number | undefined // Tipo del argumento que recibe la función mutate (duration o undefined)\n> => {\n  // No necesita invalidar caché, es una acción puntual\n  return useMutation<DiscoveredPrinter[], ApiError, number | undefined>({\n    mutationFn: (duration: number | undefined) =>\n      printerService.discoverPrinters(duration),\n    // Opcional: manejo de errores/éxito específico para descubrimiento si es necesario\n  });\n};\n\n/**\n * Hook para obtener la lista paginada de impresoras registradas.\n */\nexport const usePrintersQuery = (\n  // Proporcionar valores por defecto para page y limit si params está vacío\n  params: FindAllThermalPrintersDto = { page: 1, limit: 10 },\n  options?: { enabled?: boolean },\n): UseQueryResult<PaginatedResponse<ThermalPrinter>, ApiError> => {\n  const queryKey = printerKeys.list(params);\n  return useQuery<PaginatedResponse<ThermalPrinter>, ApiError>({\n    queryKey: queryKey,\n    queryFn: () => printerService.findAllPrinters(params),\n    enabled: options?.enabled ?? true,\n  });\n};\n\n/**\n * Hook para obtener los detalles de una impresora registrada por ID.\n */\nexport const usePrinterQuery = (\n  id: string | undefined,\n  options?: { enabled?: boolean },\n): UseQueryResult<ThermalPrinter, ApiError> => {\n  const queryKey = printerKeys.detail(id!);\n  return useQuery<ThermalPrinter, ApiError>({\n    queryKey: queryKey,\n    queryFn: () => printerService.findOnePrinter(id!),\n    enabled: !!id && (options?.enabled ?? true),\n  });\n};\n\n/**\n * Hook para crear una nueva impresora registrada.\n */\nexport const useCreatePrinterMutation = (): UseMutationResult<\n  ThermalPrinter,\n  ApiError,\n  CreateThermalPrinterDto\n> => {\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  return useMutation<ThermalPrinter, ApiError, CreateThermalPrinterDto>({\n    mutationFn: printerService.createPrinter,\n    onSuccess: (newPrinter) => {\n      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });\n      showSnackbar({\n        message: `Impresora \"${newPrinter.name}\" creada con éxito`,\n        type: 'success',\n      });\n    },\n    onError: (error) => {\n      showSnackbar({\n        message: `Error al crear impresora: ${getApiErrorMessage(error)}`,\n        type: 'error',\n      });\n    },\n  });\n};\n\n/**\n * Hook para actualizar una impresora registrada existente.\n */\nexport const useUpdatePrinterMutation = (): UseMutationResult<\n  ThermalPrinter,\n  ApiError,\n  { id: string; data: UpdateThermalPrinterDto }\n> => {\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  return useMutation<\n    ThermalPrinter,\n    ApiError,\n    { id: string; data: UpdateThermalPrinterDto }\n  >({\n    mutationFn: ({ id, data }) => printerService.updatePrinter(id, data),\n    onSuccess: (updatedPrinter, variables) => {\n      // Invalidar lista y detalle específico\n      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: printerKeys.detail(variables.id),\n      });\n      // Opcional: Actualizar caché directamente si se desea optimización\n      // queryClient.setQueryData(printerKeys.detail(variables.id), updatedPrinter);\n      showSnackbar({\n        message: `Impresora \"${updatedPrinter.name}\" actualizada`,\n        type: 'success',\n      });\n    },\n    onError: (error, variables) => {\n      showSnackbar({\n        message: `Error al actualizar impresora: ${getApiErrorMessage(error)}`,\n        type: 'error',\n      });\n    },\n  });\n};\n\n/**\n * Hook para eliminar (soft delete) una impresora registrada.\n */\nexport const useDeletePrinterMutation = (): UseMutationResult<\n  void,\n  ApiError,\n  string // ID de la impresora a eliminar\n> => {\n  const queryClient = useQueryClient();\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  return useMutation<void, ApiError, string>({\n    mutationFn: printerService.deletePrinter,\n    onSuccess: (_, deletedId) => {\n      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });\n      // Opcional: Remover de la caché de detalle\n      queryClient.removeQueries({ queryKey: printerKeys.detail(deletedId) });\n      showSnackbar({ message: 'Impresora eliminada', type: 'success' });\n    },\n    onError: (error) => {\n      showSnackbar({\n        message: `Error al eliminar impresora: ${getApiErrorMessage(error)}`,\n        type: 'error',\n      });\n    },\n  });\n};\n\n/**\n * Hook para realizar un ping a una impresora.\n */\nexport const usePingPrinterMutation = (): UseMutationResult<\n  { status: string }, // Tipo de dato que devuelve la mutación en caso de éxito\n  ApiError, // Tipo de error esperado\n  string // Tipo del argumento que recibe la función mutate (printer ID)\n> => {\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  return useMutation<{ status: string }, ApiError, string>({\n    mutationFn: (printerId: string) => printerService.pingPrinter(printerId),\n    onSuccess: (data, printerId) => {\n      const message =\n        data.status === 'online'\n          ? `Impresora conectada (ping exitoso).`\n          : `Impresora desconectada (ping fallido).`;\n      const type = data.status === 'online' ? 'success' : 'warning';\n      showSnackbar({ message, type });\n    },\n    onError: (error, printerId) => {\n      showSnackbar({\n        message: `Error al hacer ping a la impresora: ${getApiErrorMessage(error)}`,\n        type: 'error',\n      });\n      console.error(`Error pinging printer ${printerId}:`, error);\n    },\n  });\n};\n\n/**\n * Hook para imprimir un ticket de prueba en una impresora descubierta.\n */\nexport const useTestPrintDiscoveredPrinter = (): UseMutationResult<\n  { success: boolean; message?: string },\n  ApiError,\n  DiscoveredPrinter\n> => {\n  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);\n\n  return useMutation<\n    { success: boolean; message?: string },\n    ApiError,\n    DiscoveredPrinter\n  >({\n    mutationFn: (printer: DiscoveredPrinter) =>\n      printerService.testPrintDiscoveredPrinter(printer),\n    onSuccess: (data) => {\n      showSnackbar({\n        message: data.message || 'Ticket de prueba impreso correctamente',\n        type: 'success',\n      });\n    },\n    onError: (error) => {\n      showSnackbar({\n        message: `Error al imprimir ticket de prueba: ${getApiErrorMessage(error)}`,\n        type: 'error',\n      });\n      console.error('Error printing test ticket:', error);\n    },\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/printers/navigation/PrintersStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/printers/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/printers/schema/printer.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/printers/screens/PrintersScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Alert' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Text' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Surface' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UpdateThermalPrinterDto' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PrinterConnectionType' is defined but never used. Allowed unused vars must match /^_/u.","line":28,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useCreatePrinterMutation' is defined but never used. Allowed unused vars must match /^_/u.","line":33,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useUpdatePrinterMutation' is defined but never used. Allowed unused vars must match /^_/u.","line":34,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":27}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo, useCallback } from 'react';\nimport { View, StyleSheet, Alert } from 'react-native';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport {\n  Text,\n  Button,\n  Surface,\n  Portal,\n  ActivityIndicator,\n  IconButton,\n  FAB, // <-- Importar FAB\n} from 'react-native-paper';\nimport { useAppTheme, AppTheme } from '../../../app/styles/theme';\nimport PrinterDiscoveryModal from '../components/PrinterDiscoveryModal';\nimport PrinterFormModal from '../components/PrinterFormModal'; // Importar el nuevo modal\nimport GenericList, {\n  RenderItemConfig,\n  FilterOption,\n} from '../../../app/components/crud/GenericList'; // Importar GenericList\nimport GenericDetailModal, {\n  DisplayFieldConfig,\n} from '../../../app/components/crud/GenericDetailModal'; // Importar GenericDetailModal\nimport {\n  DiscoveredPrinter,\n  ThermalPrinter,\n  CreateThermalPrinterDto,\n  UpdateThermalPrinterDto,\n  PrinterConnectionType,\n} from '../types/printer.types';\nimport { useListState } from '../../../app/hooks/useListState';\nimport {\n  usePrintersQuery,\n  useCreatePrinterMutation,\n  useUpdatePrinterMutation,\n  useDeletePrinterMutation,\n  usePingPrinterMutation, // <-- Importar hook de ping\n} from '../hooks/usePrintersQueries';\nimport { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic'; // Importar hook CRUD\nimport { useDrawerStatus } from '@react-navigation/drawer';\n\ntype StatusFilter = 'all' | 'active' | 'inactive';\n\nconst PrintersScreen: React.FC = () => {\n  const theme = useAppTheme();\n  const styles = React.useMemo(() => createStyles(theme), [theme]);\n  const drawerStatus = useDrawerStatus();\n  const isDrawerOpen = drawerStatus === 'open';\n\n  const [isDiscoveryModalVisible, setIsDiscoveryModalVisible] = useState(false);\n  const [discoveredPrinterData, setDiscoveredPrinterData] =\n    useState<Partial<CreateThermalPrinterDto> | null>(null);\n  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');\n  const [pingingPrinterId, setPingingPrinterId] = useState<string | null>(null);\n  const [fabOpen, setFabOpen] = useState(false); // Estado para el FAB.Group\n\n  // --- Lógica CRUD ---\n  const queryParams = useMemo(\n    () => ({\n      isActive: statusFilter === 'all' ? undefined : statusFilter === 'active',\n      // Añadir otros filtros si son necesarios (ej. name, connectionType)\n      page: 1, // O manejar paginación si es necesario\n      limit: 50, // Ajustar límite según necesidad\n    }),\n    [statusFilter],\n  );\n\n  const {\n    data: printersResponse,\n    isLoading: isLoadingList,\n    isFetching: isFetchingList,\n    refetch: refetchList,\n    error: listError,\n  } = usePrintersQuery(queryParams);\n\n  const { mutateAsync: deletePrinter } = useDeletePrinterMutation();\n  const pingPrinterMutation = usePingPrinterMutation(); // Instanciar la mutación de ping\n\n  const {\n    isFormModalVisible,\n    isDetailModalVisible,\n    editingItem,\n    selectedItem,\n    isDeleting,\n    handleOpenCreateModal,\n    handleOpenEditModal,\n    handleOpenDetailModal,\n    handleCloseModals,\n    handleDeleteItem,\n  } = useCrudScreenLogic<ThermalPrinter>({\n    entityName: 'Impresora',\n    queryKey: ['thermalPrinters', queryParams], // Usar queryKey consistente\n    deleteMutationFn: deletePrinter,\n  });\n  // --- Fin Lógica CRUD ---\n\n  const handleOpenAddModal = () => {\n    setDiscoveredPrinterData(null); // Limpiar datos de descubrimiento\n    handleOpenCreateModal(); // Abrir modal de formulario vacío\n  };\n\n  const handleOpenDiscoveryModal = () => {\n    setIsDiscoveryModalVisible(true);\n  };\n\n  const handleDismissDiscoveryModal = () => {\n    setIsDiscoveryModalVisible(false);\n  };\n\n  const handlePrinterSelectedFromDiscovery = (printer: DiscoveredPrinter) => {\n    // Pre-rellenar datos para el formulario\n    setDiscoveredPrinterData({\n      name: printer.name || `Impresora ${printer.ip}`,\n      connectionType: 'NETWORK', // Asumir NETWORK\n      ipAddress: printer.ip,\n      port: printer.port,\n      macAddress: printer.mac || undefined,\n    });\n    setIsDiscoveryModalVisible(false); // Cerrar modal de descubrimiento\n    handleOpenCreateModal(); // Abrir modal de formulario con datos pre-rellenados\n  };\n\n  // Configuración para GenericList\n  const listRenderConfig: RenderItemConfig<ThermalPrinter> = {\n    titleField: 'name',\n    descriptionField: 'ipAddress', // Usar este campo, GenericList lo mostrará\n    // descriptionRender eliminado, GenericList debería manejar la lógica de descripción básica o se ajusta GenericList\n    statusConfig: {\n      field: 'isActive',\n      activeValue: true,\n      activeLabel: 'Activa',\n      inactiveLabel: 'Inactiva',\n    },\n  };\n\n  // Configuración para GenericDetailModal\n  const detailFields: DisplayFieldConfig<ThermalPrinter>[] = [\n    { field: 'connectionType', label: 'Tipo Conexión' },\n    { field: 'ipAddress', label: 'Dirección IP' },\n    { field: 'port', label: 'Puerto' },\n    { field: 'path', label: 'Ruta/ID' },\n    { field: 'macAddress', label: 'MAC Address' },\n  ];\n\n  const filterOptions: FilterOption<StatusFilter>[] = [\n    { value: 'all', label: 'Todas' },\n    { value: 'active', label: 'Activas' },\n    { value: 'inactive', label: 'Inactivas' },\n  ];\n\n  const { ListEmptyComponent } = useListState({\n    isLoading: isLoadingList,\n    isError: !!listError,\n    data: printersResponse?.data,\n    emptyConfig: {\n      title: 'No hay impresoras',\n      message:\n        statusFilter !== 'all'\n          ? `No hay impresoras ${statusFilter === 'active' ? 'activas' : 'inactivas'} configuradas.`\n          : 'No hay impresoras configuradas. Presiona el botón + para agregar una nueva o descubrir impresoras en la red.',\n      icon: 'printer-outline',\n    },\n  });\n\n  // Wrapper para el cambio de filtro\n  const handleFilterChange = useCallback((value: string | number) => {\n    // Asegurar que el valor sea uno de los esperados por StatusFilter\n    if (value === 'all' || value === 'active' || value === 'inactive') {\n      setStatusFilter(value as StatusFilter);\n    } else {\n      // Opcional: manejar caso inesperado, por ahora default a 'all'\n      setStatusFilter('all');\n    }\n  }, []);\n\n  // --- Funcionalidad de Ping ---\n  const handlePingPrinter = useCallback(\n    async (printerId: string) => {\n      setPingingPrinterId(printerId);\n      try {\n        await pingPrinterMutation.mutateAsync(printerId);\n      } catch (error) {\n        // El error ya se maneja en el hook con un snackbar\n      } finally {\n        setPingingPrinterId(null);\n      }\n    },\n    [pingPrinterMutation],\n  );\n\n  const renderItemActions = useCallback(\n    (item: ThermalPrinter) => {\n      const isPingingThis = pingingPrinterId === item.id;\n      const canPing = item.connectionType === 'NETWORK';\n\n      return (\n        <View style={styles.itemActionsContainer}>\n          {isPingingThis ? (\n            <ActivityIndicator size={24} style={styles.pingIndicator} />\n          ) : (\n            <IconButton\n              icon=\"access-point-network\" // Icono para ping\n              size={24}\n              onPress={() => handlePingPrinter(item.id)}\n              disabled={!canPing || pingPrinterMutation.isPending} // Deshabilitar si no es NETWORK o si hay un ping en curso\n              iconColor={\n                canPing ? theme.colors.primary : theme.colors.onSurfaceDisabled\n              } // Usar color para deshabilitado\n              style={styles.actionButton}\n            />\n          )}\n        </View>\n      );\n    },\n    [\n      pingingPrinterId,\n      pingPrinterMutation.isPending,\n      handlePingPrinter,\n      theme.colors,\n      styles,\n    ],\n  );\n  // --- Fin Funcionalidad de Ping ---\n\n  return (\n    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>\n      {/* Eliminar la View de headerButtons */}\n\n      <GenericList<ThermalPrinter>\n        items={printersResponse?.data ?? []}\n        renderConfig={listRenderConfig}\n        onItemPress={handleOpenDetailModal} // Abrir detalle al presionar\n        onRefresh={refetchList}\n        isRefreshing={isFetchingList && !isLoadingList}\n        ListEmptyComponent={ListEmptyComponent}\n        isLoading={isLoadingList && !isFetchingList}\n        filterValue={statusFilter}\n        onFilterChange={handleFilterChange} // Usar el wrapper\n        filterOptions={filterOptions}\n        // showFab ya no es necesario aquí, se maneja con FAB.Group\n        isModalOpen={\n          isFormModalVisible || isDetailModalVisible || isDiscoveryModalVisible\n        }\n        showImagePlaceholder={false} // No hay imágenes para impresoras\n        isDrawerOpen={isDrawerOpen}\n        contentContainerStyle={styles.listPadding} // Añadir padding inferior\n        renderItemActions={renderItemActions} // <-- Pasar la función para renderizar acciones\n      />\n\n      <Portal>\n        {/* Modal de Descubrimiento */}\n        <PrinterDiscoveryModal\n          visible={isDiscoveryModalVisible}\n          onDismiss={handleDismissDiscoveryModal}\n          onPrinterSelect={handlePrinterSelectedFromDiscovery}\n        />\n        {/* Modal de Formulario */}\n        <PrinterFormModal\n          visible={isFormModalVisible}\n          onDismiss={handleCloseModals}\n          editingItem={editingItem}\n          // Pasar datos descubiertos al crear, usar undefined en lugar de null\n          initialDataFromDiscovery={\n            !editingItem ? (discoveredPrinterData ?? undefined) : undefined\n          }\n        />\n        {/* Modal de Detalle */}\n        <GenericDetailModal<ThermalPrinter>\n          visible={isDetailModalVisible}\n          onDismiss={handleCloseModals}\n          item={selectedItem}\n          titleField=\"name\"\n          statusConfig={listRenderConfig.statusConfig}\n          fieldsToDisplay={detailFields}\n          onEdit={() => selectedItem && handleOpenEditModal(selectedItem)}\n          onDelete={() => selectedItem && handleDeleteItem(selectedItem.id)}\n          isDeleting={isDeleting}\n        />\n        {/* Añadir FAB.Group dentro del Portal */}\n        <FAB.Group\n          open={fabOpen}\n          visible={\n            !isFormModalVisible &&\n            !isDetailModalVisible &&\n            !isDiscoveryModalVisible &&\n            !isDrawerOpen\n          } // Ocultar si hay modales abiertos o drawer\n          icon={fabOpen ? 'close' : 'plus'}\n          actions={[\n            {\n              icon: 'magnify-scan',\n              label: 'Descubrir en Red',\n              onPress: handleOpenDiscoveryModal,\n              style: { backgroundColor: theme.colors.tertiaryContainer }, // Color diferente\n              color: theme.colors.onTertiaryContainer,\n              labelTextColor: theme.colors.onTertiaryContainer,\n              size: 'small',\n            },\n            {\n              icon: 'plus',\n              label: 'Añadir Manual',\n              onPress: handleOpenAddModal,\n              style: { backgroundColor: theme.colors.secondaryContainer }, // Color diferente\n              color: theme.colors.onSecondaryContainer,\n              labelTextColor: theme.colors.onSecondaryContainer,\n              size: 'small',\n            },\n          ]}\n          onStateChange={({ open }) => setFabOpen(open)}\n          onPress={() => {\n            if (fabOpen) {\n              // Acción opcional al cerrar el FAB principal\n            }\n          }}\n          fabStyle={{ backgroundColor: theme.colors.primary }} // Color principal para el FAB\n          color={theme.colors.onPrimary} // Color del icono principal\n        />\n      </Portal>\n    </SafeAreaView>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    // Eliminar estilos de headerButtons\n    listPadding: {\n      paddingBottom: 80, // Espacio para que el FAB no tape el último item\n    },\n    emptyListContent: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.l,\n      minHeight: 200, // Asegurar altura mínima\n    },\n    emptyListText: {\n      color: theme.colors.onSurfaceVariant,\n      fontStyle: 'italic',\n      textAlign: 'center',\n    },\n    itemActionsContainer: {\n      // Contenedor para los botones de acción de cada item\n      flexDirection: 'row',\n      alignItems: 'center',\n      justifyContent: 'flex-end',\n    },\n    actionButton: {\n      // Estilo base para botones de acción en la lista\n      margin: 0,\n      padding: 0,\n      width: 40, // Ancho fijo para alinear\n      height: 40, // Alto fijo para alinear\n    },\n    pingIndicator: {\n      // Estilo para el indicador de carga del ping\n      width: 40, // Mismo ancho que el botón para mantener alineación\n      height: 40, // Mismo alto\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    errorText: {\n      color: theme.colors.error,\n      textAlign: 'center',\n    },\n  });\n\nexport default PrintersScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/printers/services/printerService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/printers/types/printer.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/receipts/components/ConfirmRecoverModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/receipts/components/ReceiptDetailModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/receipts/hooks/useReceiptsQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/receipts/navigation/ReceiptsStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/receipts/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/receipts/screens/ReceiptsScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/receipts/services/receiptService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3042,3244],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import apiClient from '@/app/services/apiClient';\nimport type { Order } from '@/modules/orders/types/orders.types';\nimport type { QueryOptions } from '@tanstack/react-query';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport { API_PATHS } from '@/app/constants/apiPaths';\nimport { ApiError } from '@/app/lib/errors';\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  totalPages: number;\n  totalData: number;\n  page: number;\n  limit: number;\n}\n\ninterface GetReceiptsParams {\n  page?: number;\n  limit?: number;\n  status?: 'COMPLETED' | 'CANCELLED';\n  startDate?: Date;\n  endDate?: Date;\n  search?: string;\n}\n\n// Ya no necesitamos parámetros para recuperar la orden\n\nexport const receiptService = {\n  // Obtener órdenes finalizadas o canceladas\n  getReceipts: async (\n    params: GetReceiptsParams,\n  ): Promise<PaginatedResponse<Order>> => {\n    const { page = 1, limit = 20, status, startDate, endDate, search } = params;\n\n    const queryParams: Record<string, any> = {\n      page: page.toString(),\n      limit: limit.toString(),\n    };\n\n    // Si hay un estado específico, usarlo. Si no, obtener ambos estados\n    if (status) {\n      queryParams.orderStatus = status;\n    } else {\n      // Por defecto mostrar órdenes completadas y canceladas usando el nuevo parámetro orderStatuses\n      queryParams.orderStatuses = ['COMPLETED', 'CANCELLED'];\n    }\n\n    // Agregar filtros de fecha si se proporcionan\n    if (startDate) {\n      queryParams.startDate = startDate.toISOString();\n    }\n    if (endDate) {\n      queryParams.endDate = endDate.toISOString();\n    }\n\n    const response = await apiClient.get<any>(API_PATHS.ORDERS, queryParams);\n\n    if (!response.ok || !response.data) {\n      console.error(\n        '[receiptService.getReceipts] Failed to fetch receipts:',\n        response,\n      );\n      throw ApiError.fromApiResponse(response.data, response.status);\n    }\n\n    let data: Order[] = [];\n    let total = 0;\n    let totalPages = 1;\n\n    // Manejar diferentes formatos de respuesta\n    if (Array.isArray(response.data) && response.data.length === 2) {\n      // Formato antiguo: [data, totalCount]\n      [data, total] = response.data;\n      totalPages = limit > 0 ? Math.ceil(total / limit) : 1;\n    } else if (response.data.data && Array.isArray(response.data.data)) {\n      // Nuevo formato: { data: [], hasNextPage: boolean }\n      data = response.data.data;\n      total = data.length; // No tenemos el total real, usar la longitud\n      // Si hay más páginas, estimar que hay al menos una página más\n      totalPages = response.data.hasNextPage ? page + 1 : page;\n\n      // Si estamos en la primera página y no hay siguiente, entonces solo hay una página\n      if (page === 1 && !response.data.hasNextPage) {\n        totalPages = 1;\n      }\n    } else {\n      console.error(\n        '[receiptService.getReceipts] Unexpected response format:',\n        response.data,\n      );\n      throw new Error('Formato de respuesta inesperado del servidor');\n    }\n\n    // Debug: ver qué órdenes están llegando\n    console.log(\n      '[receiptService] Órdenes recibidas del backend:',\n      data.map((o) => ({\n        id: o.id,\n        orderStatus: o.orderStatus,\n        dailyNumber: o.dailyNumber,\n      })),\n    );\n\n    // Filtrar para asegurar que solo se muestren COMPLETED y CANCELLED\n    let filteredData = data.filter(\n      (order) =>\n        order.orderStatus === 'COMPLETED' || order.orderStatus === 'CANCELLED',\n    );\n\n    // Si hay búsqueda, filtrar adicionalmente del lado del cliente\n    if (search) {\n      const searchLower = search.toLowerCase();\n      filteredData = filteredData.filter(\n        (order) =>\n          order.orderNumber?.toString().includes(searchLower) ||\n          // TODO: Implementar búsqueda por customerName cuando esté disponible\n          // order.customerName?.toLowerCase().includes(searchLower) ||\n          order.dailyNumber?.toString().includes(searchLower),\n      );\n    }\n\n    // Si estamos filtrando del lado del cliente, actualizar el total\n    const actualTotal = filteredData.length;\n\n    return {\n      data: filteredData,\n      totalPages,\n      totalData: actualTotal, // Usar el total real después del filtrado\n      page,\n      limit,\n    };\n  },\n\n  // Obtener detalles de un recibo específico\n  getReceiptById: async (id: string): Promise<Order> => {\n    const response = await apiClient.get<Order>(`${API_PATHS.ORDERS}/${id}`);\n\n    if (!response.ok || !response.data) {\n      console.error(\n        '[receiptService.getReceiptById] Failed to fetch receipt:',\n        response,\n      );\n      throw ApiError.fromApiResponse(response.data, response.status);\n    }\n\n    return response.data;\n  },\n\n  // Recuperar una orden completada o cancelada\n  recoverOrder: async (id: string): Promise<Order> => {\n    const response = await apiClient.post<Order>(\n      `${API_PATHS.ORDERS}/${id}/recover`,\n      {}, // Body vacío ya que no necesitamos parámetros\n    );\n\n    if (!response.ok || !response.data) {\n      console.error(\n        '[receiptService.recoverOrder] Failed to recover order:',\n        response,\n      );\n      throw ApiError.fromApiResponse(response.data, response.status);\n    }\n\n    return response.data;\n  },\n};\n\n// Query options para React Query\nexport const receiptQueryOptions = {\n  receiptsInfinite: (filters?: Omit<GetReceiptsParams, 'page'>) =>\n    infiniteQueryOptions({\n      queryKey: ['receipts', 'infinite', filters],\n      queryFn: ({ pageParam = 1 }) =>\n        receiptService.getReceipts({\n          ...filters,\n          page: pageParam,\n        }),\n      getNextPageParam: (lastPage) =>\n        lastPage.page < lastPage.totalPages ? lastPage.page + 1 : undefined,\n      initialPageParam: 1,\n    }),\n\n  receipts: (\n    params: GetReceiptsParams,\n  ): QueryOptions<PaginatedResponse<Order>, Error> => ({\n    queryKey: ['receipts', params],\n    queryFn: () => receiptService.getReceipts(params),\n  }),\n\n  receipt: (id: string): QueryOptions<Order, Error> => ({\n    queryKey: ['receipt', id],\n    queryFn: () => receiptService.getReceiptById(id),\n  }),\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/restaurantConfig/components/BusinessHoursForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/restaurantConfig/components/WebViewDeliveryCoverageMap.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Platform' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Text' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Portal' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Dialog' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Chip' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":7},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":51,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":51,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1290,1392],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":362,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":362,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9414,9541],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":377,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":377,"endColumn":47},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":391,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":391,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10249,10322],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":392,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":392,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10327,10460],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":403,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":403,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10615,10718],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'sendMessageToWebView'. Either include it or remove the dependency array.","line":416,"column":6,"nodeType":"ArrayExpression","endLine":416,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [isEditing, isDrawing, mapReady, sendMessageToWebView]","fix":{"range":[10928,10960],"text":"[isEditing, isDrawing, mapReady, sendMessageToWebView]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'sendMessageToWebView'. Either include it or remove the dependency array.","line":424,"column":6,"nodeType":"ArrayExpression","endLine":424,"endColumn":32,"suggestions":[{"desc":"Update the dependencies array to be: [initialPolygon, mapReady, sendMessageToWebView]","fix":{"range":[11232,11258],"text":"[initialPolygon, mapReady, sendMessageToWebView]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'clearPolygon' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":449,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":449,"endColumn":21},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":493,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":493,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[12883,12942],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useEffect, useState } from 'react';\nimport {\n  View,\n  StyleSheet,\n  Alert,\n  useWindowDimensions,\n  Platform,\n} from 'react-native';\nimport { WebView } from 'react-native-webview';\nimport {\n  Surface,\n  Text,\n  IconButton,\n  Button,\n  Portal,\n  Dialog,\n  Chip,\n} from 'react-native-paper';\nimport { useAppTheme, AppTheme } from '@/app/styles/theme';\nimport { DeliveryCoveragePoint } from '../types/restaurantConfig.types';\n\ninterface DeliveryCoverageMapProps {\n  initialPolygon?: DeliveryCoveragePoint[] | null;\n  isEditing: boolean;\n  onChange?: (polygon: DeliveryCoveragePoint[]) => void;\n  restaurantLocation?: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport const WebViewDeliveryCoverageMap: React.FC<DeliveryCoverageMapProps> = ({\n  initialPolygon,\n  isEditing,\n  onChange,\n  restaurantLocation,\n}) => {\n  const theme = useAppTheme();\n  const { width, height } = useWindowDimensions();\n  const webViewRef = useRef<WebView>(null);\n\n  const styles = React.useMemo(\n    () => createStyles(theme, width, height),\n    [theme, width, height],\n  );\n\n  const [mapReady, setMapReady] = useState(false);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [currentPolygon, setCurrentPolygon] = useState<DeliveryCoveragePoint[]>(\n    () => {\n      console.log(\n        '[WebViewDeliveryCoverageMap] Initial polygon:',\n        initialPolygon,\n      );\n      return initialPolygon || [];\n    },\n  );\n\n  // HTML del mapa con Google Maps API\n  const mapHtml = `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n      box-sizing: border-box;\n    }\n    html, body {\n      height: 100%;\n      width: 100%;\n      overflow: hidden;\n    }\n    #map {\n      height: 100%;\n      width: 100%;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"map\"></div>\n  <script>\n    let map;\n    let polygon;\n    let markers = [];\n    let isEditing = false;\n    let polygonPath = [];\n\n    function initMap() {\n      // Inicializar el mapa\n      const initialLocation = ${\n        restaurantLocation\n          ? `{ lat: ${restaurantLocation.latitude}, lng: ${restaurantLocation.longitude} }`\n          : '{ lat: 20.5425, lng: -102.7935 }'\n      };\n      \n      map = new google.maps.Map(document.getElementById('map'), {\n        center: initialLocation,\n        zoom: 14,\n        disableDefaultUI: true,\n        zoomControl: true,\n        mapTypeControl: false,\n        scaleControl: false,\n        streetViewControl: false,\n        rotateControl: false,\n        fullscreenControl: false\n      });\n\n      // Escuchar mensajes desde React Native\n      window.addEventListener('message', handleMessage);\n      \n      // Notificar que el mapa está listo\n      sendMessage('mapReady', {});\n    }\n\n    function handleMessage(event) {\n      try {\n        const data = JSON.parse(event.data);\n        \n        switch(data.type) {\n          case 'setPolygon':\n            setPolygon(data.coordinates);\n            break;\n          case 'setEditMode':\n            setEditMode(data.isEditing);\n            break;\n          case 'centerOnPolygon':\n            centerOnPolygon();\n            break;\n          case 'clearPolygon':\n            clearPolygon();\n            break;\n        }\n      } catch (e) {\n        console.error('Error handling message:', e);\n      }\n    }\n\n    function setPolygon(coordinates) {\n      console.log('setPolygon called with:', coordinates);\n      \n      // Limpiar polígono anterior\n      if (polygon) {\n        polygon.setMap(null);\n      }\n      \n      // Limpiar marcadores\n      markers.forEach(marker => marker.setMap(null));\n      markers = [];\n      \n      // Convertir coordenadas\n      polygonPath = coordinates.map(coord => ({\n        lat: coord.lat || coord.latitude,\n        lng: coord.lng || coord.longitude\n      }));\n      \n      console.log('Converted polygonPath:', polygonPath);\n      \n      if (polygonPath.length >= 3) {\n        // Crear polígono\n        polygon = new google.maps.Polygon({\n          paths: polygonPath,\n          strokeColor: '#FF0000',\n          strokeOpacity: 0.8,\n          strokeWeight: 3,\n          fillColor: '#FF0000',\n          fillOpacity: 0.35,\n          editable: false,\n          draggable: false\n        });\n        \n        polygon.setMap(map);\n        console.log('Polygon created and added to map');\n        \n        // Centrar en el polígono\n        setTimeout(() => {\n          centerOnPolygon();\n        }, 100);\n      }\n    }\n\n    function setEditMode(editing) {\n      console.log('setEditMode called with:', editing);\n      isEditing = editing;\n      \n      if (isEditing) {\n        // Habilitar clicks en el mapa\n        google.maps.event.clearListeners(map, 'click');\n        map.addListener('click', function(event) {\n          addPoint(event.latLng);\n        });\n        \n        // Mostrar marcadores inmediatamente\n        updateMarkers();\n        console.log('Edit mode enabled, markers updated');\n      } else {\n        // Deshabilitar clicks\n        google.maps.event.clearListeners(map, 'click');\n        \n        // Ocultar marcadores\n        markers.forEach(marker => marker.setMap(null));\n        markers = [];\n        console.log('Edit mode disabled, markers removed');\n      }\n    }\n\n    function addPoint(latLng) {\n      if (!isEditing) return;\n      \n      polygonPath.push({\n        lat: latLng.lat(),\n        lng: latLng.lng()\n      });\n      \n      updatePolygon();\n      updateMarkers();\n      \n      // Enviar actualización a React Native\n      sendMessage('polygonUpdated', {\n        coordinates: polygonPath\n      });\n    }\n\n    function updatePolygon() {\n      if (polygon) {\n        polygon.setPath(polygonPath);\n      } else if (polygonPath.length >= 3) {\n        polygon = new google.maps.Polygon({\n          paths: polygonPath,\n          strokeColor: '#FF0000',\n          strokeOpacity: 0.8,\n          strokeWeight: 3,\n          fillColor: '#FF0000',\n          fillOpacity: 0.35\n        });\n        polygon.setMap(map);\n      }\n    }\n\n    function updateMarkers() {\n      // Limpiar marcadores anteriores\n      markers.forEach(marker => marker.setMap(null));\n      markers = [];\n      \n      if (!isEditing) return;\n      \n      // Crear nuevos marcadores\n      polygonPath.forEach((point, index) => {\n        const marker = new google.maps.Marker({\n          position: point,\n          map: map,\n          draggable: true,\n          label: {\n            text: (index + 1).toString(),\n            color: 'white',\n            fontSize: '12px',\n            fontWeight: 'bold'\n          },\n          icon: {\n            path: google.maps.SymbolPath.CIRCLE,\n            scale: 20,\n            fillColor: '#2563eb',\n            fillOpacity: 1,\n            strokeColor: 'white',\n            strokeWeight: 2\n          }\n        });\n        \n        // Permitir arrastrar\n        marker.addListener('dragend', function() {\n          polygonPath[index] = {\n            lat: marker.getPosition().lat(),\n            lng: marker.getPosition().lng()\n          };\n          updatePolygon();\n          sendMessage('polygonUpdated', {\n            coordinates: polygonPath\n          });\n        });\n        \n        // Click para eliminar\n        marker.addListener('click', function() {\n          if (polygonPath.length > 3) {\n            polygonPath.splice(index, 1);\n            updatePolygon();\n            updateMarkers();\n            sendMessage('polygonUpdated', {\n              coordinates: polygonPath\n            });\n          }\n        });\n        \n        markers.push(marker);\n      });\n    }\n\n    function centerOnPolygon() {\n      console.log('centerOnPolygon called, polygonPath length:', polygonPath.length);\n      if (polygonPath.length > 0) {\n        const bounds = new google.maps.LatLngBounds();\n        polygonPath.forEach(point => {\n          bounds.extend(point);\n        });\n        map.fitBounds(bounds);\n        \n        // Ajustar el zoom si es necesario\n        const listener = google.maps.event.addListener(map, 'idle', function() { \n          if (map.getZoom() > 18) {\n            map.setZoom(18);\n          }\n          google.maps.event.removeListener(listener);\n        });\n      }\n    }\n\n    function clearPolygon() {\n      polygonPath = [];\n      if (polygon) {\n        polygon.setMap(null);\n        polygon = null;\n      }\n      markers.forEach(marker => marker.setMap(null));\n      markers = [];\n      \n      sendMessage('polygonUpdated', {\n        coordinates: []\n      });\n    }\n\n    function sendMessage(type, data) {\n      try {\n        if (window.ReactNativeWebView) {\n          window.ReactNativeWebView.postMessage(JSON.stringify({\n            type: type,\n            ...data\n          }));\n        } else {\n          console.error('ReactNativeWebView not available');\n        }\n      } catch (e) {\n        console.error('Error sending message:', e);\n      }\n    }\n  </script>\n  <script async defer\n    src=\"https://maps.googleapis.com/maps/api/js?key=${process.env.GOOGLE_MAPS_API_KEY || 'AIzaSyBYpMTaB42iRspFTEEtZ_fexZV0qhmRZvU'}&callback=initMap\">\n  </script>\n</body>\n</html>\n  `;\n\n  // Manejar mensajes del WebView\n  const handleWebViewMessage = (event: any) => {\n    try {\n      const data = JSON.parse(event.nativeEvent.data);\n\n      switch (data.type) {\n        case 'mapReady':\n          setMapReady(true);\n          console.log(\n            '[WebViewDeliveryCoverageMap] Map is ready, initialPolygon:',\n            initialPolygon,\n          );\n\n          // Enviar polígono inicial si existe\n          if (initialPolygon && initialPolygon.length > 0) {\n            setTimeout(() => {\n              sendMessageToWebView('setPolygon', {\n                coordinates: initialPolygon,\n              });\n            }, 1000);\n          }\n          break;\n        case 'polygonUpdated':\n          const newPolygon = data.coordinates;\n          setCurrentPolygon(newPolygon);\n          if (onChange) {\n            onChange(newPolygon);\n          }\n          break;\n      }\n    } catch (e) {\n      console.error('Error handling WebView message:', e);\n    }\n  };\n\n  // Enviar mensaje al WebView\n  const sendMessageToWebView = (type: string, data: any) => {\n    console.log('[WebViewDeliveryCoverageMap] Sending message:', type, data);\n    console.log(\n      '[WebViewDeliveryCoverageMap] Map ready:',\n      mapReady,\n      'Ref exists:',\n      !!webViewRef.current,\n    );\n\n    if (webViewRef.current) {\n      const message = JSON.stringify({ type, ...data });\n      webViewRef.current.postMessage(message);\n    } else {\n      console.log(\n        '[WebViewDeliveryCoverageMap] Cannot send message - WebView ref missing',\n      );\n    }\n  };\n\n  // Actualizar el modo de edición cuando cambie\n  useEffect(() => {\n    if (mapReady) {\n      sendMessageToWebView('setEditMode', {\n        isEditing: isEditing && isDrawing,\n      });\n    }\n  }, [isEditing, isDrawing, mapReady]);\n\n  // Actualizar el polígono cuando cambie desde fuera\n  useEffect(() => {\n    if (mapReady && initialPolygon && initialPolygon.length > 0) {\n      setCurrentPolygon(initialPolygon);\n      sendMessageToWebView('setPolygon', { coordinates: initialPolygon });\n    }\n  }, [initialPolygon, mapReady]);\n\n  const toggleDrawing = () => {\n    if (isDrawing && currentPolygon.length < 3) {\n      Alert.alert(\n        'Área incompleta',\n        'Necesitas al menos 3 puntos para crear un área de cobertura.',\n      );\n      return;\n    }\n    const newDrawingState = !isDrawing;\n    setIsDrawing(newDrawingState);\n\n    // Enviar el estado de edición al mapa inmediatamente\n    if (webViewRef.current) {\n      const jsCode = `\n        if (typeof setEditMode === 'function') {\n          setEditMode(${newDrawingState});\n        }\n        true;\n      `;\n      webViewRef.current.injectJavaScript(jsCode);\n    }\n  };\n\n  const clearPolygon = () => {\n    sendMessageToWebView('clearPolygon', {});\n\n    // También usar inyección directa\n    if (webViewRef.current) {\n      const jsCode = `\n        if (typeof clearPolygon === 'function') {\n          clearPolygon();\n        }\n        true;\n      `;\n      webViewRef.current.injectJavaScript(jsCode);\n    }\n\n    setCurrentPolygon([]);\n    setIsDrawing(false);\n    if (onChange) {\n      onChange([]);\n    }\n  };\n\n  const centerOnPolygon = () => {\n    sendMessageToWebView('centerOnPolygon', {});\n\n    // También usar inyección directa\n    if (webViewRef.current) {\n      const jsCode = `\n        if (typeof centerOnPolygon === 'function') {\n          centerOnPolygon();\n        }\n        true;\n      `;\n      webViewRef.current.injectJavaScript(jsCode);\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <WebView\n        ref={webViewRef}\n        source={{ html: mapHtml }}\n        style={styles.map}\n        onMessage={handleWebViewMessage}\n        onLoad={() => {\n          console.log('[WebViewDeliveryCoverageMap] WebView loaded');\n          // Inyectar código JavaScript después de cargar\n          if (\n            webViewRef.current &&\n            initialPolygon &&\n            initialPolygon.length > 0\n          ) {\n            const jsCode = `\n              setTimeout(() => {\n                if (typeof setPolygon === 'function') {\n                  setPolygon(${JSON.stringify(initialPolygon)});\n                  console.log('Polygon set via injected JS');\n                }\n              }, 1500);\n              true;\n            `;\n            webViewRef.current.injectJavaScript(jsCode);\n          }\n        }}\n        onError={(error) =>\n          console.error('[WebViewDeliveryCoverageMap] WebView error:', error)\n        }\n        javaScriptEnabled={true}\n        domStorageEnabled={true}\n        startInLoadingState={true}\n        mixedContentMode=\"compatibility\"\n        allowsInlineMediaPlayback={true}\n        originWhitelist={['*']}\n      />\n\n      {/* Controles flotantes */}\n      {isEditing && (\n        <View style={styles.controls}>\n          <Surface style={styles.controlsCard} elevation={2}>\n            <View style={styles.controlsRow}>\n              <IconButton\n                icon={isDrawing ? 'check' : 'draw'}\n                mode=\"contained\"\n                containerColor={\n                  isDrawing ? theme.colors.primary : theme.colors.secondary\n                }\n                iconColor={\n                  isDrawing ? theme.colors.onPrimary : theme.colors.onSecondary\n                }\n                size={24}\n                onPress={toggleDrawing}\n              />\n              <IconButton\n                icon=\"crosshairs-gps\"\n                mode=\"contained\"\n                containerColor={theme.colors.tertiaryContainer}\n                iconColor={theme.colors.onTertiaryContainer}\n                size={24}\n                onPress={centerOnPolygon}\n                disabled={currentPolygon.length === 0}\n              />\n            </View>\n          </Surface>\n        </View>\n      )}\n\n      {/* Botón de centrar cuando no se está editando */}\n      {!isEditing && currentPolygon.length > 0 && (\n        <View style={styles.centerButtonContainer}>\n          <IconButton\n            icon=\"crosshairs-gps\"\n            mode=\"contained\"\n            containerColor={theme.colors.primaryContainer}\n            iconColor={theme.colors.onPrimaryContainer}\n            size={24}\n            onPress={centerOnPolygon}\n            style={styles.floatingCenterButton}\n          />\n        </View>\n      )}\n    </View>\n  );\n};\n\nconst createStyles = (theme: AppTheme, width: number, height: number) =>\n  StyleSheet.create({\n    container: {\n      height: Math.min(height * 0.6, 500),\n      width: '100%',\n      borderRadius: 16,\n      overflow: 'hidden',\n      backgroundColor: theme.colors.surfaceVariant,\n    },\n    map: {\n      ...StyleSheet.absoluteFillObject,\n    },\n    controls: {\n      position: 'absolute',\n      top: theme.spacing.m,\n      right: theme.spacing.m,\n    },\n    controlsCard: {\n      borderRadius: 12,\n      padding: theme.spacing.s,\n      backgroundColor: theme.colors.surface,\n      alignItems: 'center',\n      gap: theme.spacing.xs,\n    },\n    controlsRow: {\n      flexDirection: 'row',\n      gap: theme.spacing.xs,\n    },\n    statusText: {\n      fontSize: 12,\n      color: theme.colors.onSurfaceVariant,\n      marginTop: theme.spacing.xs,\n    },\n    centerButtonContainer: {\n      position: 'absolute',\n      bottom: theme.spacing.m,\n      right: theme.spacing.m,\n    },\n    floatingCenterButton: {\n      elevation: 4,\n      shadowColor: '#000',\n      shadowOffset: { width: 0, height: 2 },\n      shadowOpacity: 0.25,\n      shadowRadius: 3.84,\n    },\n  });\n\nexport default WebViewDeliveryCoverageMap;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/restaurantConfig/hooks/useRestaurantConfigQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/restaurantConfig/navigation/RestaurantConfigStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/restaurantConfig/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/restaurantConfig/screens/RestaurantConfigScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useEffect' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Paragraph' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IconButton' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useSnackbarStore' is defined but never used. Allowed unused vars must match /^_/u.","line":31,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":26}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { Portal } from 'react-native-paper';\nimport {\n  View,\n  StyleSheet,\n  ScrollView,\n  useWindowDimensions,\n  BackHandler,\n} from 'react-native';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport {\n  Text,\n  Switch,\n  TextInput,\n  Button,\n  ActivityIndicator,\n  Dialog,\n  Paragraph,\n  Surface,\n  Chip,\n  SegmentedButtons,\n  IconButton,\n} from 'react-native-paper';\nimport { MaterialCommunityIcons } from '@expo/vector-icons';\nimport { useAppTheme, AppTheme } from '@/app/styles/theme';\nimport { useRestaurantConfigQueries } from '../hooks/useRestaurantConfigQueries';\nimport {\n  UpdateRestaurantConfigDto,\n  CreateBusinessHoursDto,\n} from '../types/restaurantConfig.types';\nimport { useSnackbarStore } from '@/app/store/snackbarStore';\nimport BusinessHoursForm from '../components/BusinessHoursForm';\nimport { KeyboardAwareScrollView } from 'react-native-keyboard-aware-scroll-view';\nimport { WebViewDeliveryCoverageMap } from '../components/WebViewDeliveryCoverageMap';\nimport ConfirmationModal from '@/app/components/common/ConfirmationModal';\nimport { useNavigation } from '@react-navigation/native';\nimport { useFocusEffect } from '@react-navigation/native';\n\ntype TabType = 'basic' | 'operation' | 'schedule';\n\nconst RestaurantConfigScreen: React.FC = () => {\n  const theme = useAppTheme();\n  const { width, height } = useWindowDimensions();\n  const navigation = useNavigation();\n  const styles = React.useMemo(\n    () => createStyles(theme, width, height),\n    [theme, width, height],\n  );\n\n  const { useGetConfig, useUpdateConfig } = useRestaurantConfigQueries();\n  const { data: config, isLoading, error } = useGetConfig();\n  const updateConfigMutation = useUpdateConfig();\n  const updateDeliveryAreaMutation = useUpdateConfig({\n    successMessage: 'Área de cobertura actualizada exitosamente',\n  });\n\n  const [activeTab, setActiveTab] = useState<TabType>('basic');\n  const [pendingTab, setPendingTab] = useState<TabType | null>(null);\n  const [formData, setFormData] = useState<UpdateRestaurantConfigDto>({});\n  const [isEditing, setIsEditing] = useState(false);\n  const [showDiscardDialog, setShowDiscardDialog] = useState(false);\n  const [showDeliveryModal, setShowDeliveryModal] = useState(false);\n  const [isEditingDelivery, setIsEditingDelivery] = useState(false);\n  const [isNavigatingAway, setIsNavigatingAway] = useState(false);\n\n  // Función para verificar si hay cambios sin guardar\n  const hasChanges = React.useCallback(() => {\n    if (!config) return false;\n    return (\n      JSON.stringify(formData) !==\n      JSON.stringify({\n        restaurantName: config.restaurantName,\n        phoneMain: config.phoneMain,\n        phoneSecondary: config.phoneSecondary,\n        address: config.address,\n        city: config.city,\n        state: config.state,\n        postalCode: config.postalCode,\n        country: config.country,\n        acceptingOrders: config.acceptingOrders,\n        estimatedPickupTime: config.estimatedPickupTime,\n        estimatedDeliveryTime: config.estimatedDeliveryTime,\n        estimatedDineInTime: config.estimatedDineInTime,\n        openingGracePeriod: config.openingGracePeriod,\n        closingGracePeriod: config.closingGracePeriod,\n        timeZone: config.timeZone,\n        deliveryCoverageArea: config.deliveryCoverageArea,\n        businessHours: config.businessHours,\n      })\n    );\n  }, [config, formData]);\n\n  // Interceptar navegación cuando hay cambios sin guardar\n  useFocusEffect(\n    React.useCallback(() => {\n      const unsubscribe = navigation.addListener('beforeRemove', (e) => {\n        if (!isEditing || !hasChanges()) {\n          // Si no está editando o no hay cambios, permitir navegación\n          return;\n        }\n\n        // Prevenir la navegación por defecto\n        e.preventDefault();\n\n        // Mostrar el diálogo de confirmación\n        setIsNavigatingAway(true);\n        setShowDiscardDialog(true);\n      });\n\n      return unsubscribe;\n    }, [navigation, isEditing, hasChanges]),\n  );\n\n  // Manejar botón de retroceso de Android\n  useFocusEffect(\n    React.useCallback(() => {\n      const onBackPress = () => {\n        if (isEditing && hasChanges()) {\n          setIsNavigatingAway(true);\n          setShowDiscardDialog(true);\n          return true; // Prevenir el comportamiento por defecto\n        }\n        return false;\n      };\n\n      const subscription = BackHandler.addEventListener(\n        'hardwareBackPress',\n        onBackPress,\n      );\n\n      return () => subscription.remove();\n    }, [isEditing, hasChanges]),\n  );\n\n  React.useEffect(() => {\n    if (config) {\n      setFormData({\n        // Información básica\n        restaurantName: config.restaurantName,\n        phoneMain: config.phoneMain,\n        phoneSecondary: config.phoneSecondary,\n        address: config.address,\n        city: config.city,\n        state: config.state,\n        postalCode: config.postalCode,\n        country: config.country,\n        // Configuración de operación\n        acceptingOrders: config.acceptingOrders,\n        estimatedPickupTime: config.estimatedPickupTime,\n        estimatedDeliveryTime: config.estimatedDeliveryTime,\n        estimatedDineInTime: config.estimatedDineInTime,\n        openingGracePeriod: config.openingGracePeriod,\n        closingGracePeriod: config.closingGracePeriod,\n        timeZone: config.timeZone,\n        // Configuración de delivery\n        deliveryCoverageArea: config.deliveryCoverageArea,\n        // Horarios\n        businessHours: config.businessHours,\n      });\n    }\n  }, [config]);\n\n  const handleSubmit = async () => {\n    try {\n      // Formatear los datos antes de enviarlos\n      const dataToSubmit = {\n        ...formData,\n        // Formatear businessHours para quitar los segundos\n        businessHours: formData.businessHours?.map((hour) => ({\n          ...hour,\n          openingTime: hour.openingTime\n            ? hour.openingTime.substring(0, 5)\n            : null,\n          closingTime: hour.closingTime\n            ? hour.closingTime.substring(0, 5)\n            : null,\n        })),\n        // deliveryCoverageArea se envía tal como está (array de coordenadas)\n      };\n\n      await updateConfigMutation.mutateAsync(dataToSubmit);\n      setIsEditing(false);\n    } catch (error) {\n      // Error handling is done in the mutation hook\n    }\n  };\n\n  const handleSaveDeliveryArea = async () => {\n    try {\n      // Guardar solo el área de cobertura\n      await updateDeliveryAreaMutation.mutateAsync({\n        deliveryCoverageArea: formData.deliveryCoverageArea,\n      });\n\n      // Actualizar el estado del config con la nueva área\n      if (config) {\n        // Esto asegura que el estado local se mantenga sincronizado\n        setFormData((prev) => ({\n          ...prev,\n          deliveryCoverageArea: formData.deliveryCoverageArea,\n        }));\n      }\n    } catch (error) {\n      // Error handling is done in the mutation hook\n    }\n  };\n\n  const handleCancel = () => {\n    if (hasChanges()) {\n      setShowDiscardDialog(true);\n    } else {\n      resetForm();\n    }\n  };\n\n  const resetForm = () => {\n    if (config) {\n      setFormData({\n        restaurantName: config.restaurantName,\n        phoneMain: config.phoneMain,\n        phoneSecondary: config.phoneSecondary,\n        address: config.address,\n        city: config.city,\n        state: config.state,\n        postalCode: config.postalCode,\n        country: config.country,\n        acceptingOrders: config.acceptingOrders,\n        estimatedPickupTime: config.estimatedPickupTime,\n        estimatedDeliveryTime: config.estimatedDeliveryTime,\n        estimatedDineInTime: config.estimatedDineInTime,\n        openingGracePeriod: config.openingGracePeriod,\n        closingGracePeriod: config.closingGracePeriod,\n        timeZone: config.timeZone,\n        deliveryCoverageArea: config.deliveryCoverageArea,\n        businessHours: config.businessHours,\n      });\n    }\n    setIsEditing(false);\n  };\n\n  const confirmDiscard = () => {\n    resetForm();\n    setShowDiscardDialog(false);\n\n    // Si estaba navegando fuera de la pantalla\n    if (isNavigatingAway) {\n      setIsNavigatingAway(false);\n      navigation.goBack();\n      return;\n    }\n\n    // Si hay una pestaña pendiente, cambiar a ella\n    if (pendingTab) {\n      setActiveTab(pendingTab);\n      setPendingTab(null);\n    }\n  };\n\n  const handleTabChange = (newTab: TabType) => {\n    if (isEditing && hasChanges()) {\n      // Guardar la pestaña a la que quiere ir\n      setPendingTab(newTab);\n      setShowDiscardDialog(true);\n    } else {\n      setActiveTab(newTab);\n    }\n  };\n\n  const renderBasicInfo = () => (\n    <View style={styles.tabContent}>\n      <Surface style={styles.section} elevation={1}>\n        <View style={styles.sectionHeader}>\n          <MaterialCommunityIcons\n            name=\"store-outline\"\n            size={24}\n            color={theme.colors.primary}\n          />\n          <Text style={styles.sectionTitle}>Información del Restaurante</Text>\n        </View>\n\n        <View style={styles.sectionContent}>\n          <TextInput\n            label=\"Nombre del restaurante\"\n            value={formData.restaurantName || ''}\n            onChangeText={(text) =>\n              setFormData({ ...formData, restaurantName: text })\n            }\n            mode=\"outlined\"\n            disabled={!isEditing}\n            style={styles.input}\n            outlineStyle={styles.inputOutline}\n          />\n\n          <View style={styles.row}>\n            <TextInput\n              label=\"Teléfono principal\"\n              value={formData.phoneMain || ''}\n              onChangeText={(text) =>\n                setFormData({ ...formData, phoneMain: text })\n              }\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={[styles.input, styles.halfInput]}\n              outlineStyle={styles.inputOutline}\n              keyboardType=\"phone-pad\"\n              left={<TextInput.Icon icon=\"phone\" />}\n            />\n            <TextInput\n              label=\"Teléfono secundario\"\n              value={formData.phoneSecondary || ''}\n              onChangeText={(text) =>\n                setFormData({ ...formData, phoneSecondary: text })\n              }\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={[styles.input, styles.halfInput]}\n              outlineStyle={styles.inputOutline}\n              keyboardType=\"phone-pad\"\n              left={<TextInput.Icon icon=\"cellphone\" />}\n            />\n          </View>\n\n          <TextInput\n            label=\"Dirección\"\n            value={formData.address || ''}\n            onChangeText={(text) => setFormData({ ...formData, address: text })}\n            mode=\"outlined\"\n            disabled={!isEditing}\n            style={styles.input}\n            outlineStyle={styles.inputOutline}\n            multiline\n            numberOfLines={2}\n            left={<TextInput.Icon icon=\"map-marker\" />}\n          />\n\n          <View style={styles.row}>\n            <TextInput\n              label=\"Ciudad\"\n              value={formData.city || ''}\n              onChangeText={(text) => setFormData({ ...formData, city: text })}\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={[styles.input, styles.halfInput]}\n              outlineStyle={styles.inputOutline}\n            />\n            <TextInput\n              label=\"Estado\"\n              value={formData.state || ''}\n              onChangeText={(text) => setFormData({ ...formData, state: text })}\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={[styles.input, styles.halfInput]}\n              outlineStyle={styles.inputOutline}\n            />\n          </View>\n\n          <View style={styles.row}>\n            <TextInput\n              label=\"Código postal\"\n              value={formData.postalCode || ''}\n              onChangeText={(text) =>\n                setFormData({ ...formData, postalCode: text })\n              }\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={[styles.input, styles.halfInput]}\n              outlineStyle={styles.inputOutline}\n              keyboardType=\"numeric\"\n            />\n            <TextInput\n              label=\"País\"\n              value={formData.country || ''}\n              onChangeText={(text) =>\n                setFormData({ ...formData, country: text })\n              }\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={[styles.input, styles.halfInput]}\n              outlineStyle={styles.inputOutline}\n            />\n          </View>\n\n          {/* Botón para área de cobertura */}\n          <View style={styles.deliveryButtonContainer}>\n            <Button\n              mode=\"contained-tonal\"\n              onPress={() => setShowDeliveryModal(true)}\n              icon=\"map-marker-radius\"\n              style={styles.deliveryButton}\n              contentStyle={styles.deliveryButtonContent}\n              labelStyle={styles.deliveryButtonLabel}\n            >\n              Área de Cobertura\n            </Button>\n            {formData.deliveryCoverageArea &&\n            formData.deliveryCoverageArea.length > 0 ? (\n              <Text style={styles.deliveryStatusText}>\n                Área de cobertura definida\n              </Text>\n            ) : (\n              <Text\n                style={[\n                  styles.deliveryStatusText,\n                  styles.deliveryStatusWarning,\n                ]}\n              >\n                Sin área de cobertura definida\n              </Text>\n            )}\n          </View>\n        </View>\n      </Surface>\n    </View>\n  );\n\n  const renderOperationConfig = () => (\n    <View style={styles.tabContent}>\n      {/* Service Status Card */}\n      <Surface style={styles.section} elevation={1}>\n        <View style={styles.sectionHeader}>\n          <MaterialCommunityIcons\n            name=\"store-check\"\n            size={24}\n            color={theme.colors.primary}\n          />\n          <Text style={styles.sectionTitle}>Estado del Servicio</Text>\n        </View>\n\n        <View style={styles.sectionContent}>\n          <View style={styles.statusRow}>\n            <View style={styles.statusInfo}>\n              <Text style={styles.statusLabel}>Recepción de Órdenes</Text>\n              <Text style={styles.statusDescription}>\n                {formData.acceptingOrders\n                  ? 'Las órdenes están siendo aceptadas'\n                  : 'No se están aceptando órdenes nuevas'}\n              </Text>\n            </View>\n            <Switch\n              value={formData.acceptingOrders}\n              onValueChange={(value) =>\n                setFormData({ ...formData, acceptingOrders: value })\n              }\n              disabled={!isEditing}\n              color={theme.colors.primary}\n            />\n          </View>\n        </View>\n      </Surface>\n\n      {/* Delivery Times Card */}\n      <Surface style={styles.section} elevation={1}>\n        <View style={styles.sectionHeader}>\n          <MaterialCommunityIcons\n            name=\"clock-time-four\"\n            size={24}\n            color={theme.colors.primary}\n          />\n          <Text style={styles.sectionTitle}>Tiempos de Servicio</Text>\n        </View>\n\n        <View style={styles.sectionContent}>\n          <View style={styles.timeInputContainer}>\n            <View style={styles.timeIconWrapper}>\n              <MaterialCommunityIcons\n                name=\"walk\"\n                size={20}\n                color={theme.colors.onSurfaceVariant}\n              />\n            </View>\n            <TextInput\n              label=\"Para recoger en tienda\"\n              value={formData.estimatedPickupTime?.toString() || ''}\n              onChangeText={(text) =>\n                setFormData({\n                  ...formData,\n                  estimatedPickupTime: parseInt(text) || 0,\n                })\n              }\n              keyboardType=\"numeric\"\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={styles.timeInput}\n              right={<TextInput.Affix text=\"min\" />}\n              outlineStyle={styles.inputOutline}\n            />\n          </View>\n\n          <View style={styles.timeInputContainer}>\n            <View style={styles.timeIconWrapper}>\n              <MaterialCommunityIcons\n                name=\"moped\"\n                size={20}\n                color={theme.colors.onSurfaceVariant}\n              />\n            </View>\n            <TextInput\n              label=\"Entrega a domicilio\"\n              value={formData.estimatedDeliveryTime?.toString() || ''}\n              onChangeText={(text) =>\n                setFormData({\n                  ...formData,\n                  estimatedDeliveryTime: parseInt(text) || 0,\n                })\n              }\n              keyboardType=\"numeric\"\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={styles.timeInput}\n              right={<TextInput.Affix text=\"min\" />}\n              outlineStyle={styles.inputOutline}\n            />\n          </View>\n\n          <View style={styles.timeInputContainer}>\n            <View style={styles.timeIconWrapper}>\n              <MaterialCommunityIcons\n                name=\"silverware-fork-knife\"\n                size={20}\n                color={theme.colors.onSurfaceVariant}\n              />\n            </View>\n            <TextInput\n              label=\"Para comer en el local\"\n              value={formData.estimatedDineInTime?.toString() || ''}\n              onChangeText={(text) =>\n                setFormData({\n                  ...formData,\n                  estimatedDineInTime: parseInt(text) || 0,\n                })\n              }\n              keyboardType=\"numeric\"\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={styles.timeInput}\n              right={<TextInput.Affix text=\"min\" />}\n              outlineStyle={styles.inputOutline}\n            />\n          </View>\n\n          <View style={styles.timeInputContainer}>\n            <View style={styles.timeIconWrapper}>\n              <MaterialCommunityIcons\n                name=\"timer\"\n                size={20}\n                color={theme.colors.onSurfaceVariant}\n              />\n            </View>\n            <TextInput\n              label=\"Periodo de gracia al abrir\"\n              value={formData.openingGracePeriod?.toString() || ''}\n              onChangeText={(text) =>\n                setFormData({\n                  ...formData,\n                  openingGracePeriod: parseInt(text) || 0,\n                })\n              }\n              keyboardType=\"numeric\"\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={styles.timeInput}\n              right={<TextInput.Affix text=\"min\" />}\n              outlineStyle={styles.inputOutline}\n            />\n          </View>\n\n          <View style={styles.timeInputContainer}>\n            <View style={styles.timeIconWrapper}>\n              <MaterialCommunityIcons\n                name=\"timer-off-outline\"\n                size={20}\n                color={theme.colors.onSurfaceVariant}\n              />\n            </View>\n            <TextInput\n              label=\"Periodo de gracia al cerrar\"\n              value={formData.closingGracePeriod?.toString() || ''}\n              onChangeText={(text) =>\n                setFormData({\n                  ...formData,\n                  closingGracePeriod: parseInt(text) || 0,\n                })\n              }\n              keyboardType=\"numeric\"\n              mode=\"outlined\"\n              disabled={!isEditing}\n              style={styles.timeInput}\n              right={<TextInput.Affix text=\"min\" />}\n              outlineStyle={styles.inputOutline}\n            />\n          </View>\n\n          <View style={styles.infoChip}>\n            <Chip\n              icon=\"information\"\n              mode=\"flat\"\n              style={styles.chip}\n              textStyle={styles.chipText}\n            >\n              Los tiempos son estimados y pueden variar\n            </Chip>\n          </View>\n        </View>\n      </Surface>\n\n      {/* Time Zone */}\n      <Surface style={styles.section} elevation={1}>\n        <View style={styles.sectionHeader}>\n          <MaterialCommunityIcons\n            name=\"earth\"\n            size={24}\n            color={theme.colors.primary}\n          />\n          <Text style={styles.sectionTitle}>Zona Horaria</Text>\n        </View>\n\n        <View style={styles.sectionContent}>\n          <TextInput\n            label=\"Zona horaria\"\n            value={formData.timeZone || ''}\n            onChangeText={(text) =>\n              setFormData({ ...formData, timeZone: text })\n            }\n            mode=\"outlined\"\n            disabled={!isEditing}\n            style={styles.input}\n            outlineStyle={styles.inputOutline}\n            left={<TextInput.Icon icon=\"map-clock\" />}\n          />\n        </View>\n      </Surface>\n    </View>\n  );\n\n  const renderSchedule = () => (\n    <View style={styles.tabContent}>\n      <Surface style={styles.section} elevation={1}>\n        <View style={styles.sectionHeader}>\n          <MaterialCommunityIcons\n            name=\"calendar-clock\"\n            size={24}\n            color={theme.colors.primary}\n          />\n          <Text style={styles.sectionTitle}>Horario de Operación</Text>\n        </View>\n\n        <View style={styles.sectionContent}>\n          <BusinessHoursForm\n            businessHours={formData.businessHours || []}\n            isEditing={isEditing}\n            onChange={(hours: CreateBusinessHoursDto[]) =>\n              setFormData({ ...formData, businessHours: hours })\n            }\n          />\n        </View>\n      </Surface>\n    </View>\n  );\n\n  if (isLoading) {\n    return (\n      <View style={styles.loadingContainer}>\n        <ActivityIndicator size=\"large\" color={theme.colors.primary} />\n      </View>\n    );\n  }\n\n  if (error) {\n    return (\n      <View style={styles.errorContainer}>\n        <Text style={styles.errorText}>Error al cargar la configuración</Text>\n      </View>\n    );\n  }\n\n  return (\n    <SafeAreaView style={styles.container} edges={['bottom']}>\n      {/* Header */}\n      <View style={styles.header}>\n        <View style={styles.headerContent}>\n          <Text style={styles.headerTitle}>Configuración del Restaurante</Text>\n          <Text style={styles.headerSubtitle}>\n            Administra todos los ajustes de tu negocio\n          </Text>\n        </View>\n      </View>\n\n      {/* Tabs */}\n      <View style={styles.tabsContainer}>\n        <ScrollView\n          horizontal\n          showsHorizontalScrollIndicator={false}\n          contentContainerStyle={styles.tabsContent}\n        >\n          <SegmentedButtons\n            value={activeTab}\n            onValueChange={(value) => handleTabChange(value as TabType)}\n            buttons={[\n              {\n                value: 'basic',\n                label: 'Información',\n                icon: 'store',\n              },\n              {\n                value: 'operation',\n                label: 'Operación',\n                icon: 'cog',\n              },\n              {\n                value: 'schedule',\n                label: 'Horarios',\n                icon: 'calendar',\n              },\n            ]}\n            style={styles.tabs}\n          />\n        </ScrollView>\n      </View>\n\n      {/* Content */}\n      <KeyboardAwareScrollView\n        contentContainerStyle={styles.scrollContent}\n        showsVerticalScrollIndicator={false}\n        extraScrollHeight={100}\n      >\n        {activeTab === 'basic' && renderBasicInfo()}\n        {activeTab === 'operation' && renderOperationConfig()}\n        {activeTab === 'schedule' && renderSchedule()}\n      </KeyboardAwareScrollView>\n\n      {/* Action Buttons */}\n      <View style={styles.actionContainer}>\n        {!isEditing ? (\n          <Button\n            mode=\"contained\"\n            onPress={() => setIsEditing(true)}\n            style={[\n              styles.editButton,\n              { backgroundColor: theme.colors.tertiary },\n            ]}\n            contentStyle={styles.editButtonContent}\n            labelStyle={styles.editButtonLabel}\n            icon=\"pencil\"\n            textColor={theme.colors.onTertiary}\n          >\n            Editar Configuración\n          </Button>\n        ) : (\n          <View style={styles.editActions}>\n            <Button\n              mode=\"outlined\"\n              onPress={handleCancel}\n              style={styles.cancelButton}\n              contentStyle={styles.buttonContent}\n            >\n              Cancelar\n            </Button>\n            <Button\n              mode=\"contained\"\n              onPress={handleSubmit}\n              loading={updateConfigMutation.isPending}\n              disabled={updateConfigMutation.isPending || !hasChanges()}\n              style={styles.saveButton}\n              contentStyle={styles.buttonContent}\n              icon=\"check\"\n            >\n              Guardar\n            </Button>\n          </View>\n        )}\n      </View>\n\n      {/* System Info Card */}\n      {config && (\n        <Surface style={styles.infoCard} elevation={1}>\n          <View style={styles.infoContent}>\n            <MaterialCommunityIcons\n              name=\"information-outline\"\n              size={20}\n              color={theme.colors.onSurfaceVariant}\n            />\n            <View style={styles.infoTextContainer}>\n              <Text style={styles.infoTitle}>Última actualización</Text>\n              <Text style={styles.infoText}>\n                {new Date(config.updatedAt).toLocaleString('es-MX', {\n                  dateStyle: 'medium',\n                  timeStyle: 'short',\n                })}\n              </Text>\n            </View>\n          </View>\n        </Surface>\n      )}\n\n      <ConfirmationModal\n        visible={showDiscardDialog}\n        title=\"Descartar cambios\"\n        message=\"¿Estás seguro de que deseas descartar los cambios realizados?\"\n        onConfirm={confirmDiscard}\n        onCancel={() => {\n          setShowDiscardDialog(false);\n          setIsNavigatingAway(false);\n          setPendingTab(null);\n        }}\n        confirmText=\"Descartar\"\n        cancelText=\"Continuar editando\"\n        confirmButtonColor={theme.colors.error}\n      />\n\n      {/* Modal de Área de Cobertura */}\n      <Portal>\n        <Dialog\n          visible={showDeliveryModal}\n          onDismiss={() => {\n            if (!updateDeliveryAreaMutation.isPending) {\n              setShowDeliveryModal(false);\n              setIsEditingDelivery(false);\n            }\n          }}\n          style={styles.deliveryDialog}\n        >\n          <Dialog.Content style={styles.deliveryDialogContent}>\n            <Surface style={styles.deliveryMapWrapper} elevation={1}>\n              <View style={styles.deliveryMapContainer}>\n                <WebViewDeliveryCoverageMap\n                  initialPolygon={formData.deliveryCoverageArea}\n                  isEditing={isEditingDelivery}\n                  onChange={(polygon) =>\n                    setFormData({ ...formData, deliveryCoverageArea: polygon })\n                  }\n                  restaurantLocation={{\n                    latitude: config?.latitude || 20.5425,\n                    longitude: config?.longitude || -102.7935,\n                  }}\n                />\n              </View>\n            </Surface>\n          </Dialog.Content>\n          <View style={styles.deliveryDialogActions}>\n            <View style={styles.deliveryDialogButtonsContainer}>\n              {!isEditingDelivery ? (\n                <>\n                  <Button\n                    onPress={() => setShowDeliveryModal(false)}\n                    mode=\"outlined\"\n                    style={[styles.deliveryDialogButton, styles.cancelButton]}\n                    contentStyle={styles.deliveryButtonContent}\n                    labelStyle={styles.cancelButtonLabel}\n                  >\n                    Cerrar\n                  </Button>\n                  <Button\n                    onPress={() => setIsEditingDelivery(true)}\n                    icon=\"pencil\"\n                    mode=\"contained\"\n                    style={[styles.deliveryDialogButton, styles.editButton]}\n                    contentStyle={styles.deliveryButtonContent}\n                    labelStyle={styles.deliveryButtonLabel}\n                  >\n                    Editar\n                  </Button>\n                </>\n              ) : (\n                <>\n                  <Button\n                    onPress={() => setIsEditingDelivery(false)}\n                    mode=\"outlined\"\n                    style={[styles.deliveryDialogButton, styles.cancelButton]}\n                    contentStyle={styles.deliveryButtonContent}\n                    labelStyle={styles.cancelButtonLabel}\n                    disabled={updateDeliveryAreaMutation.isPending}\n                  >\n                    Cancelar\n                  </Button>\n                  <Button\n                    onPress={async () => {\n                      setIsEditingDelivery(false);\n                      // Guardar el área de cobertura inmediatamente\n                      await handleSaveDeliveryArea();\n                      setShowDeliveryModal(false);\n                    }}\n                    mode=\"contained\"\n                    icon=\"check\"\n                    style={[styles.deliveryDialogButton, styles.saveButton]}\n                    contentStyle={styles.deliveryButtonContent}\n                    labelStyle={styles.deliveryButtonLabel}\n                    loading={updateDeliveryAreaMutation.isPending}\n                    disabled={updateDeliveryAreaMutation.isPending}\n                  >\n                    Guardar\n                  </Button>\n                </>\n              )}\n            </View>\n          </View>\n        </Dialog>\n      </Portal>\n    </SafeAreaView>\n  );\n};\n\nconst createStyles = (theme: AppTheme, width: number, height: number) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    scrollContent: {\n      paddingBottom: theme.spacing.xl,\n    },\n    deliveryContent: {\n      flex: 1,\n      paddingHorizontal: theme.spacing.md,\n      paddingTop: theme.spacing.md,\n    },\n    loadingContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    errorContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.xl,\n    },\n    errorText: {\n      fontSize: 16,\n      color: theme.colors.error,\n      textAlign: 'center',\n    },\n    // Header styles\n    header: {\n      backgroundColor: theme.colors.primaryContainer,\n      paddingTop: theme.spacing.m,\n      paddingBottom: theme.spacing.m,\n      paddingHorizontal: theme.spacing.m,\n    },\n    headerContent: {\n      alignItems: 'center',\n    },\n    headerTitle: {\n      fontSize: 20,\n      fontWeight: '600',\n      color: theme.colors.onPrimaryContainer,\n      marginBottom: theme.spacing.xs,\n    },\n    headerSubtitle: {\n      fontSize: 13,\n      color: theme.colors.onPrimaryContainer,\n      opacity: 0.8,\n      textAlign: 'center',\n    },\n    // Tabs\n    tabsContainer: {\n      backgroundColor: theme.colors.background,\n      paddingVertical: theme.spacing.s,\n      borderBottomWidth: 1,\n      borderBottomColor: theme.colors.surfaceVariant,\n    },\n    tabsContent: {\n      paddingHorizontal: theme.spacing.m,\n    },\n    tabs: {\n      minWidth: width - theme.spacing.m * 2,\n    },\n    tabContent: {\n      padding: theme.spacing.m,\n      gap: theme.spacing.m,\n    },\n    // Section styles\n    section: {\n      borderRadius: 16,\n      padding: theme.spacing.m,\n      backgroundColor: theme.colors.surface,\n    },\n    sectionHeader: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      marginBottom: theme.spacing.m,\n    },\n    sectionTitle: {\n      fontSize: 18,\n      fontWeight: '600',\n      color: theme.colors.onSurface,\n      marginLeft: theme.spacing.s,\n    },\n    sectionContent: {\n      gap: theme.spacing.m,\n    },\n    deliveryInfo: {\n      paddingHorizontal: theme.spacing.md,\n      marginBottom: theme.spacing.sm,\n    },\n    // Input styles\n    input: {\n      backgroundColor: theme.colors.surface,\n    },\n    inputOutline: {\n      borderRadius: 12,\n    },\n    row: {\n      flexDirection: 'row',\n      gap: theme.spacing.s,\n    },\n    halfInput: {\n      flex: 1,\n    },\n    // Status styles\n    statusRow: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n    },\n    statusInfo: {\n      flex: 1,\n      marginRight: theme.spacing.m,\n    },\n    statusLabel: {\n      fontSize: 16,\n      fontWeight: '500',\n      color: theme.colors.onSurface,\n      marginBottom: theme.spacing.xs,\n    },\n    statusDescription: {\n      fontSize: 14,\n      color: theme.colors.onSurfaceVariant,\n    },\n    // Time input styles\n    timeInputContainer: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      gap: theme.spacing.s,\n    },\n    timeIconWrapper: {\n      width: 40,\n      height: 40,\n      borderRadius: 20,\n      backgroundColor: theme.colors.surfaceVariant,\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    timeInput: {\n      flex: 1,\n      backgroundColor: theme.colors.surface,\n    },\n    infoChip: {\n      marginTop: theme.spacing.xs,\n    },\n    chip: {\n      backgroundColor: theme.colors.secondaryContainer,\n    },\n    chipText: {\n      fontSize: 12,\n    },\n    // Delivery styles\n    deliveryInfo: {\n      marginTop: theme.spacing.m,\n      alignItems: 'center',\n    },\n    // Action styles\n    actionContainer: {\n      marginHorizontal: theme.spacing.m,\n      marginTop: theme.spacing.l,\n      alignItems: 'center',\n    },\n    editButton: {\n      borderRadius: 12,\n      elevation: 2,\n      alignSelf: 'stretch',\n    },\n    editButtonContent: {\n      paddingVertical: theme.spacing.xs,\n    },\n    editButtonLabel: {\n      fontSize: 16,\n      fontWeight: '600',\n    },\n    editActions: {\n      flexDirection: 'row',\n      gap: theme.spacing.l,\n      width: '100%',\n      justifyContent: 'center',\n      paddingHorizontal: theme.spacing.m,\n    },\n    cancelButton: {\n      flex: 1,\n      borderRadius: 12,\n    },\n    saveButton: {\n      flex: 1,\n      borderRadius: 12,\n      elevation: 2,\n    },\n    buttonContent: {\n      paddingVertical: theme.spacing.xs,\n    },\n    // Info Card styles\n    infoCard: {\n      marginHorizontal: theme.spacing.m,\n      marginTop: theme.spacing.m,\n      borderRadius: 12,\n      padding: theme.spacing.m,\n      backgroundColor: theme.colors.surfaceVariant,\n    },\n    infoContent: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      gap: theme.spacing.s,\n    },\n    infoTextContainer: {\n      flex: 1,\n    },\n    infoTitle: {\n      fontSize: 12,\n      color: theme.colors.onSurfaceVariant,\n      opacity: 0.7,\n    },\n    infoText: {\n      fontSize: 14,\n      fontWeight: '500',\n      color: theme.colors.onSurfaceVariant,\n    },\n    deliveryContainer: {\n      flex: 1,\n      paddingHorizontal: theme.spacing.md,\n      paddingTop: theme.spacing.md,\n    },\n    deliveryActions: {\n      position: 'absolute',\n      bottom: 16,\n      right: 16,\n    },\n    deliveryFab: {\n      position: 'absolute',\n      bottom: 0,\n      right: 0,\n    },\n    deliveryFabSmall: {\n      position: 'absolute',\n      right: 0,\n    },\n    mapSection: {\n      paddingHorizontal: theme.spacing.md,\n      paddingBottom: theme.spacing.md,\n    },\n    // Estilos para el botón de área de cobertura\n    deliveryButtonContainer: {\n      marginTop: theme.spacing.l,\n      alignItems: 'center',\n    },\n    deliveryButton: {\n      borderRadius: 12,\n      width: '100%',\n    },\n    deliveryButtonContent: {\n      paddingVertical: theme.spacing.s,\n    },\n    deliveryButtonLabel: {\n      fontSize: 16,\n      fontWeight: '500',\n    },\n    deliveryStatusText: {\n      fontSize: 12,\n      color: theme.colors.onSurfaceVariant,\n      marginTop: theme.spacing.xs,\n      fontStyle: 'italic',\n    },\n    deliveryStatusWarning: {\n      color: theme.colors.error,\n    },\n    // Estilos para el modal\n    deliveryDialog: {\n      maxWidth: width * 0.95,\n      width: width * 0.95,\n      maxHeight: height * 0.9,\n      alignSelf: 'center',\n      borderRadius: 16,\n      backgroundColor: theme.colors.surface,\n    },\n    deliveryDialogContent: {\n      paddingHorizontal: theme.spacing.m,\n      paddingTop: theme.spacing.m,\n      paddingBottom: theme.spacing.m,\n    },\n    deliveryMapWrapper: {\n      borderRadius: 12,\n      padding: theme.spacing.xs,\n      backgroundColor: theme.colors.surfaceVariant,\n    },\n    deliveryMapContainer: {\n      height: height * 0.65,\n      width: '100%',\n      borderRadius: 8,\n      overflow: 'hidden',\n    },\n    deliveryDialogActions: {\n      paddingHorizontal: theme.spacing.m,\n      paddingVertical: theme.spacing.m,\n      paddingBottom: theme.spacing.l,\n    },\n    deliveryDialogButtonsContainer: {\n      flexDirection: 'row',\n      justifyContent: 'center',\n      alignItems: 'center',\n      gap: theme.spacing.m,\n    },\n    deliveryDialogButton: {\n      minWidth: 120,\n      borderRadius: 12,\n    },\n    editButton: {\n      backgroundColor: theme.colors.primary,\n    },\n    cancelButton: {\n      borderColor: theme.colors.outline,\n    },\n    saveButton: {\n      backgroundColor: theme.colors.primary,\n    },\n    deliveryButtonContent: {\n      paddingVertical: theme.spacing.s,\n    },\n    deliveryButtonLabel: {\n      fontSize: 16,\n      fontWeight: '600',\n    },\n    cancelButtonLabel: {\n      fontSize: 16,\n      fontWeight: '500',\n      color: theme.colors.onSurface,\n    },\n  });\n\nexport default RestaurantConfigScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/restaurantConfig/services/restaurantConfigService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/restaurantConfig/types/restaurantConfig.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/sync/navigation/SyncStackNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/sync/screens/SyncStatusScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/sync/services/syncService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/leo/Escritorio/bite/app/src/modules/sync/types/sync.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
