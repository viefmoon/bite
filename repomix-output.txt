This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/.eslintignore
app/.eslintrc.js
app/.gitignore
app/.prettierrc
app/android/app/src/main/res/xml/network_security_config.xml
app/app.config.js
app/App.tsx
app/babel.config.js
app/docs/guides/BUILD_LOCAL_GUIDE.md
app/docs/guides/BUILD_QUICKSTART.md
app/docs/guides/EAS_PROJECT_SETUP_GUIDE.md
app/docs/guides/FIRST_UPLOAD_GUIDE.md
app/docs/guides/PLAY_STORE_PUBLISHING.md
app/eas.json
app/index.ts
app/ios/.gitignore
app/ios/.xcode.env
app/ios/pizza.xcodeproj/project.pbxproj
app/ios/pizza.xcodeproj/xcshareddata/xcschemes/pizza.xcscheme
app/ios/pizza/AppDelegate.swift
app/ios/pizza/Images.xcassets/AppIcon.appiconset/Contents.json
app/ios/pizza/Images.xcassets/Contents.json
app/ios/pizza/Images.xcassets/SplashScreenBackground.colorset/Contents.json
app/ios/pizza/Info.plist
app/ios/pizza/pizza-Bridging-Header.h
app/ios/pizza/pizza.entitlements
app/ios/pizza/SplashScreen.storyboard
app/ios/pizza/Supporting/Expo.plist
app/ios/Podfile
app/ios/Podfile.properties.json
app/metro.config.js
app/package.json
app/plugins/withCustomIcons.js
app/scripts/check-new-arch-compatibility.js
app/scripts/dev/reset-project.sh
app/scripts/install-android-sdk.sh
app/scripts/install-java.sh
app/scripts/release-to-playstore.sh
app/scripts/verify-android-setup.sh
app/src/app/components/common/AdaptiveModal.tsx
app/src/app/components/common/AnimatedLabelInput.tsx
app/src/app/components/common/AnimatedLabelSelector.tsx
app/src/app/components/common/AutoImage.tsx
app/src/app/components/common/ConfirmationModal.tsx
app/src/app/components/common/CustomImagePicker.tsx
app/src/app/components/common/EmptyState.tsx
app/src/app/components/common/GlobalSnackbar.tsx
app/src/app/components/common/PhoneNumberInput.tsx
app/src/app/components/common/SpeechRecognitionInput.tsx
app/src/app/components/ConnectionErrorModal.tsx
app/src/app/components/ConnectionIndicator.tsx
app/src/app/components/crud/GenericDetailModal.tsx
app/src/app/components/crud/GenericFormModal.tsx
app/src/app/components/crud/GenericList.tsx
app/src/app/components/DateTimePickerSafe.tsx
app/src/app/components/OrientationTransition.tsx
app/src/app/components/responsive/index.ts
app/src/app/components/responsive/ResponsiveGrid.tsx
app/src/app/components/responsive/ResponsiveImage.tsx
app/src/app/components/responsive/ResponsiveModal.tsx
app/src/app/components/responsive/ResponsiveView.tsx
app/src/app/components/ServerConfigModal.tsx
app/src/app/components/ShiftIndicator.tsx
app/src/app/constants/apiErrorCodes.ts
app/src/app/constants/apiPaths.ts
app/src/app/constants/navigationPaths.ts
app/src/app/constants/network.ts
app/src/app/constants/rolePermissions.ts
app/src/app/constants/storageKeys.ts
app/src/app/docs/DateTimePickerUsage.md
app/src/app/docs/RESPONSIVE_GUIDE.md
app/src/app/hooks/useCrudScreenLogic.ts
app/src/app/hooks/useGlobalShift.ts
app/src/app/hooks/useInitializeAuth.ts
app/src/app/hooks/useListState.ts
app/src/app/hooks/useNativeDriver.ts
app/src/app/hooks/useRefreshOnFocus.ts
app/src/app/hooks/useResponsive.ts
app/src/app/hooks/useServerConnection.ts
app/src/app/lib/apiHelpers.ts
app/src/app/lib/apiResponseHelper.ts
app/src/app/lib/errorMapping.ts
app/src/app/lib/errors.ts
app/src/app/lib/formatters.ts
app/src/app/lib/IMAGE_CACHE_GUIDE.md
app/src/app/lib/imageCache.ts
app/src/app/lib/imageUploadService.ts
app/src/app/lib/imageUtils.ts
app/src/app/lib/zodResolver.ts
app/src/app/navigation/AppDrawerNavigator.tsx
app/src/app/navigation/AppNavigator.tsx
app/src/app/navigation/AuthStack.tsx
app/src/app/navigation/components/CustomDrawerContent.tsx
app/src/app/navigation/components/WebDrawer.tsx
app/src/app/navigation/components/WebDrawerContent.tsx
app/src/app/navigation/ConditionalAppNavigator.tsx
app/src/app/navigation/helpers/navigationHelpers.ts
app/src/app/navigation/KitchenOnlyNavigator.tsx
app/src/app/navigation/KitchenWebNavigator.tsx
app/src/app/navigation/options.ts
app/src/app/navigation/OrdersStackNavigator.tsx
app/src/app/navigation/types.ts
app/src/app/schemas/domain/adjustment.schema.ts
app/src/app/schemas/domain/area.schema.ts
app/src/app/schemas/domain/category.schema.ts
app/src/app/schemas/domain/delivery-info.schema.ts
app/src/app/schemas/domain/modifier-group.schema.ts
app/src/app/schemas/domain/modifier.schema.ts
app/src/app/schemas/domain/order.schema.ts
app/src/app/schemas/domain/photo.schema.ts
app/src/app/schemas/domain/preparation-screen.schema.ts
app/src/app/schemas/domain/product-variant.schema.ts
app/src/app/schemas/domain/product.schema.ts
app/src/app/schemas/domain/subcategory.schema.ts
app/src/app/schemas/domain/table.schema.ts
app/src/app/services/apiClient.ts
app/src/app/services/apiClientWrapper.ts
app/src/app/services/certificateValidator.ts
app/src/app/services/discoveryService.ts
app/src/app/services/secureStorageService.ts
app/src/app/store/authStore.ts
app/src/app/store/snackbarStore.ts
app/src/app/store/themeStore.ts
app/src/app/styles/colors.ts
app/src/app/styles/responsive.ts
app/src/app/styles/theme.ts
app/src/app/styles/typography.ts
app/src/app/types/api.types.ts
app/src/app/types/query.types.ts
app/src/app/types/theme.types.ts
app/src/app/utils/__tests__/dateTimeHelpers.test.ts
app/src/app/utils/dateTimeHelpers.ts
app/src/app/utils/networkDiagnostics.ts
app/src/app/utils/orderFormatters.ts
app/src/app/utils/roleUtils.ts
app/src/app/utils/shadowStyles.ts
app/src/app/utils/tokenVerification.ts
app/src/components/AudioOrderModal.tsx
app/src/components/AudioRecorderWidget.tsx
app/src/components/index.ts
app/src/hooks/useAudioRecorder.ts
app/src/hooks/useGoogleMapsConfig.ts
app/src/hooks/useOrientation.ts
app/src/hooks/useResponsiveFontScale.ts
app/src/hooks/useSnackbar.ts
app/src/modules/areasTables/components/AreaFormModal.tsx
app/src/modules/areasTables/components/TableFormModal.tsx
app/src/modules/areasTables/hooks/useAreasQueries.ts
app/src/modules/areasTables/hooks/useTablesQueries.ts
app/src/modules/areasTables/navigation/AreasTablesStackNavigator.tsx
app/src/modules/areasTables/navigation/types.ts
app/src/modules/areasTables/schema/area.schema.ts
app/src/modules/areasTables/schema/table.schema.ts
app/src/modules/areasTables/screens/AreasScreen.tsx
app/src/modules/areasTables/screens/TablesScreen.tsx
app/src/modules/areasTables/services/areaService.ts
app/src/modules/areasTables/services/tableService.ts
app/src/modules/areasTables/types/areasTables.types.ts
app/src/modules/auth/components/LoginForm.tsx
app/src/modules/auth/components/RegisterForm.tsx
app/src/modules/auth/schema/auth.schema.ts
app/src/modules/auth/screens/LoginScreen.tsx
app/src/modules/auth/services/authService.ts
app/src/modules/auth/types/auth.types.ts
app/src/modules/availability/components/AvailabilityListItem.tsx
app/src/modules/availability/components/CategoryAvailabilityItem.tsx
app/src/modules/availability/components/ModifierGroupAvailabilityItem.tsx
app/src/modules/availability/components/PizzaCustomizationAvailabilityItem.tsx
app/src/modules/availability/hooks/useAvailabilityQueries.ts
app/src/modules/availability/hooks/useOptimisticAvailability.ts
app/src/modules/availability/hooks/usePizzaCustomizationsAvailability.ts
app/src/modules/availability/navigation/AvailabilityStackNavigator.tsx
app/src/modules/availability/navigation/types.ts
app/src/modules/availability/screens/AvailabilityScreen.tsx
app/src/modules/availability/services/availabilityService.ts
app/src/modules/availability/types/availability.types.ts
app/src/modules/customers/components/AddressFormModal.tsx
app/src/modules/customers/components/CustomerFormModal.tsx
app/src/modules/customers/components/LocationPicker.tsx
app/src/modules/customers/constants/maps.config.ts
app/src/modules/customers/hooks/useCustomersQueries.ts
app/src/modules/customers/navigation/CustomersStackNavigator.tsx
app/src/modules/customers/schema/customer.schema.ts
app/src/modules/customers/screens/CustomersScreen.tsx
app/src/modules/customers/services/addressesService.ts
app/src/modules/customers/services/customersService.ts
app/src/modules/customers/types/customer.types.ts
app/src/modules/kitchen/components/KitchenFilterButton.tsx
app/src/modules/kitchen/components/OrderCard.tsx
app/src/modules/kitchen/components/OrderItemRow.tsx
app/src/modules/kitchen/components/RefreshButton.tsx
app/src/modules/kitchen/context/KitchenContext.tsx
app/src/modules/kitchen/hooks/useKitchenOrders.ts
app/src/modules/kitchen/hooks/useKitchenSnackbar.ts
app/src/modules/kitchen/navigation/KitchenNavigator.tsx
app/src/modules/kitchen/screens/KitchenOrdersScreen.tsx
app/src/modules/kitchen/services/kitchenService.ts
app/src/modules/kitchen/store/kitchenStore.ts
app/src/modules/kitchen/types/kitchen.types.ts
app/src/modules/menu/components/ProductFormModal.tsx
app/src/modules/menu/components/VariantFormModal.tsx
app/src/modules/menu/hooks/useProductsQueries.ts
app/src/modules/menu/hooks/useSubcategoriesQueries.ts
app/src/modules/menu/navigation/MenuStackNavigator.tsx
app/src/modules/menu/navigation/types.ts
app/src/modules/menu/schema/category.schema.ts
app/src/modules/menu/schema/products.schema.ts
app/src/modules/menu/schema/subcategories.schema.ts
app/src/modules/menu/screens/CategoriesScreen.tsx
app/src/modules/menu/screens/ProductsScreen.tsx
app/src/modules/menu/screens/SubcategoriesScreen.tsx
app/src/modules/menu/services/categoryService.ts
app/src/modules/menu/services/fileService.ts
app/src/modules/menu/services/productsService.ts
app/src/modules/menu/services/subcategoriesService.ts
app/src/modules/menu/types/category.types.ts
app/src/modules/menu/types/subcategories.types.ts
app/src/modules/modifiers/components/ModifierFormModal.tsx
app/src/modules/modifiers/components/ModifierGroupFormModal.tsx
app/src/modules/modifiers/hooks/useModifierGroupsQuery.ts
app/src/modules/modifiers/navigation/ModifiersStackNavigator.tsx
app/src/modules/modifiers/schema/modifier.schema.ts
app/src/modules/modifiers/schema/modifierGroup.schema.ts
app/src/modules/modifiers/screens/ModifierGroupsScreen.tsx
app/src/modules/modifiers/screens/ModifiersScreen.tsx
app/src/modules/modifiers/services/modifierGroupService.ts
app/src/modules/modifiers/services/modifierService.ts
app/src/modules/modifiers/types/modifier.types.ts
app/src/modules/orderFinalization/components/OrderCard.tsx
app/src/modules/orderFinalization/components/OrderDetailsModal.tsx
app/src/modules/orderFinalization/hooks/useOrderFinalizationQueries.ts
app/src/modules/orderFinalization/navigation/OrderFinalizationStackNavigator.tsx
app/src/modules/orderFinalization/navigation/types.ts
app/src/modules/orderFinalization/screens/OrderFinalizationScreen.tsx
app/src/modules/orderFinalization/services/orderFinalizationService.ts
app/src/modules/orderFinalization/types/orderFinalization.types.ts
app/src/modules/orders/components/AdjustmentFormModal.tsx
app/src/modules/orders/components/CartButton.tsx
app/src/modules/orders/components/ChangeCalculatorModal.tsx
app/src/modules/orders/components/CloseShiftModal.tsx
app/src/modules/orders/components/MenuItemCard.tsx
app/src/modules/orders/components/OpenShiftModal.tsx
app/src/modules/orders/components/OrderCartDetail.tsx
app/src/modules/orders/components/OrderDetailModal.tsx
app/src/modules/orders/components/OrderHeader.tsx
app/src/modules/orders/components/PaymentModal.tsx
app/src/modules/orders/components/PizzaCustomizationSection.tsx
app/src/modules/orders/components/PrinterSelectionModal.tsx
app/src/modules/orders/components/ProductCustomizationModal.tsx
app/src/modules/orders/components/ShiftStatusBanner.tsx
app/src/modules/orders/components/ShiftStatusModal.tsx
app/src/modules/orders/components/SimpleProductDescriptionModal.tsx
app/src/modules/orders/hooks/useAdjustmentQueries.ts
app/src/modules/orders/hooks/useMenuQueries.ts
app/src/modules/orders/hooks/useOrdersQueries.ts
app/src/modules/orders/hooks/usePaymentQueries.ts
app/src/modules/orders/screens/AddProductsToOrderScreen.tsx
app/src/modules/orders/screens/CreateOrderScreen.tsx
app/src/modules/orders/screens/OpenOrdersScreen.tsx
app/src/modules/orders/screens/OrdersScreen.tsx
app/src/modules/orders/services/adjustmentService.ts
app/src/modules/orders/services/orderPrintService.ts
app/src/modules/orders/services/orderService.ts
app/src/modules/orders/services/paymentService.ts
app/src/modules/orders/stores/useCartStore.ts
app/src/modules/orders/stores/useOrderFormStore.ts
app/src/modules/orders/types/adjustments.types.ts
app/src/modules/orders/types/orders.types.ts
app/src/modules/orders/types/payment.types.ts
app/src/modules/orders/types/update-order.types.ts
app/src/modules/payments/services/prepaymentService.ts
app/src/modules/pizzaCustomizations/components/AssociatePizzaToppingsModal.tsx
app/src/modules/pizzaCustomizations/components/index.ts
app/src/modules/pizzaCustomizations/components/PizzaConfigurationModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationCard.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationDetailModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationFormModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationsTab.tsx
app/src/modules/pizzaCustomizations/components/PizzaProductsTab.tsx
app/src/modules/pizzaCustomizations/hooks/usePizzaCustomizationsQueries.ts
app/src/modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator.tsx
app/src/modules/pizzaCustomizations/navigation/types.ts
app/src/modules/pizzaCustomizations/schema/pizzaConfiguration.schema.ts
app/src/modules/pizzaCustomizations/schema/pizzaCustomization.schema.ts
app/src/modules/pizzaCustomizations/screens/PizzaManagementScreen.tsx
app/src/modules/pizzaCustomizations/services/pizzaConfigurationsService.ts
app/src/modules/pizzaCustomizations/services/pizzaCustomizationsService.ts
app/src/modules/pizzaCustomizations/types/pizzaConfiguration.types.ts
app/src/modules/pizzaCustomizations/types/pizzaCustomization.types.ts
app/src/modules/preparationScreens/components/PreparationScreenDetailModalSimple.tsx
app/src/modules/preparationScreens/components/PreparationScreenFormModal.tsx
app/src/modules/preparationScreens/components/PreparationScreenListItem.tsx
app/src/modules/preparationScreens/components/ProductSelectionModal.tsx
app/src/modules/preparationScreens/hooks/usePreparationScreensQueries.ts
app/src/modules/preparationScreens/navigation/PreparationScreensStackNavigator.tsx
app/src/modules/preparationScreens/navigation/types.ts
app/src/modules/preparationScreens/schema/preparationScreen.schema.ts
app/src/modules/preparationScreens/screens/PreparationScreensScreen.tsx
app/src/modules/preparationScreens/services/preparationScreenService.ts
app/src/modules/printers/components/NumericField.tsx
app/src/modules/printers/components/PrinterAdvancedConfig.tsx
app/src/modules/printers/components/PrinterDetailModal.tsx
app/src/modules/printers/components/PrinterDiscoveryModal.tsx
app/src/modules/printers/components/PrinterFormModal.tsx
app/src/modules/printers/components/PrinterListItem.tsx
app/src/modules/printers/hooks/usePrintersQueries.ts
app/src/modules/printers/navigation/PrintersStackNavigator.tsx
app/src/modules/printers/navigation/types.ts
app/src/modules/printers/schema/printer.schema.ts
app/src/modules/printers/screens/PrintersScreen.tsx
app/src/modules/printers/services/printerService.ts
app/src/modules/printers/types/printer.types.ts
app/src/modules/receipts/components/ReceiptDetailsModal.tsx
app/src/modules/receipts/hooks/useReceiptsQueries.ts
app/src/modules/receipts/navigation/ReceiptsStackNavigator.tsx
app/src/modules/receipts/navigation/types.ts
app/src/modules/receipts/screens/ReceiptsScreen.tsx
app/src/modules/receipts/services/receiptService.ts
app/src/modules/receipts/types/receipt.types.ts
app/src/modules/restaurantConfig/components/BusinessHoursForm.tsx
app/src/modules/restaurantConfig/components/TimeZoneSelector.tsx
app/src/modules/restaurantConfig/components/WebViewDeliveryCoverageMap.tsx
app/src/modules/restaurantConfig/hooks/useRestaurantConfigQueries.ts
app/src/modules/restaurantConfig/navigation/RestaurantConfigStackNavigator.tsx
app/src/modules/restaurantConfig/navigation/types.ts
app/src/modules/restaurantConfig/screens/RestaurantConfigScreen.tsx
app/src/modules/restaurantConfig/services/restaurantConfigService.ts
app/src/modules/restaurantConfig/types/restaurantConfig.types.ts
app/src/modules/settings/navigation/SettingsStackNavigator.tsx
app/src/modules/settings/navigation/types.ts
app/src/modules/settings/screens/ServerSettingsScreen.tsx
app/src/modules/shared/components/OrderHistoryModal.tsx
app/src/modules/shared/components/OrderSummaryCard.tsx
app/src/modules/shared/components/PrintTicketModal.tsx
app/src/modules/shiftAudit/components/index.ts
app/src/modules/shiftAudit/components/OrderDetailsView.tsx
app/src/modules/shiftAudit/components/OrderHistoryView.tsx
app/src/modules/shiftAudit/components/ShiftOrdersModal.tsx
app/src/modules/shiftAudit/components/ShiftSalesSummaryView.tsx
app/src/modules/shiftAudit/hooks/useShiftOrders.ts
app/src/modules/shiftAudit/hooks/useShifts.ts
app/src/modules/shiftAudit/hooks/useShiftSalesSummary.ts
app/src/modules/shiftAudit/navigation/ShiftAuditStackNavigator.tsx
app/src/modules/shiftAudit/navigation/types.ts
app/src/modules/shiftAudit/screens/index.ts
app/src/modules/shiftAudit/screens/ShiftsListScreen.tsx
app/src/modules/shiftAudit/types/index.ts
app/src/modules/sync/navigation/SyncStackNavigator.tsx
app/src/modules/sync/screens/SyncStatusScreen.tsx
app/src/modules/sync/services/syncService.ts
app/src/modules/sync/types/sync.types.ts
app/src/modules/users/components/index.ts
app/src/modules/users/components/UserDetailModal.tsx
app/src/modules/users/components/UserFormModal.tsx
app/src/modules/users/hooks/index.ts
app/src/modules/users/hooks/useUsers.tsx
app/src/modules/users/navigation/UsersStackNavigator.tsx
app/src/modules/users/screens/index.ts
app/src/modules/users/screens/UsersListScreen.tsx
app/src/modules/users/services/index.ts
app/src/modules/users/services/usersApi.service.ts
app/src/modules/users/types/index.ts
app/src/modules/users/types/user.types.ts
app/src/services/appConfig.ts
app/src/services/audioOrderService.ts
app/src/services/audioServiceHealth.ts
app/src/services/autoReconnectService.ts
app/src/services/healthMonitoringService.ts
app/src/services/reconnectionSnackbarService.ts
app/src/services/serverConnectionService.ts
app/src/services/shifts.ts
app/src/utils/logging.ts
app/tsconfig.json

================================================================
Files
================================================================

================
File: app/.eslintignore
================
node_modules/
android/
ios/
.expo/
dist/
build/
coverage/
*.config.js
*.config.ts
babel.config.js
metro.config.js
.eslintrc.js
fix-*.js
fix-*.sh
scripts/

================
File: app/.gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files


# Node
node_modules/

# Prebuild
# android/

# ios/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# Archivos específicos
roo-code-messages.log
repomix-output.txt
bundles.json

# Ignorar carpeta .repomix y su archivo bundles.json
.repomix/
.repomix/bundles.json

# @generated expo-cli sync-8d4afeec25ea8a192358fae2f8e2fc766bdce4ec
# The following patterns were generated by expo-cli

# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# @end expo-cli

*.apk

# Build files
build-*.apk
build-*.aab
build-*.ipa

# Google Play Service Account
google-play-service-account.json

# Temporary files
tmp/
temp/

================
File: app/.prettierrc
================
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "endOfLine": "lf"
}

================
File: app/docs/guides/BUILD_LOCAL_GUIDE.md
================
# Guía para Builds Locales con EAS

## Instalación Rápida (Scripts Automatizados)

Esta app incluye scripts automatizados para configurar todo el entorno necesario:

### 1. **Configuración Completa de Java y Expo**
```bash
cd app
./scripts/install-java.sh
source ~/.bashrc
```

### 2. **Instalación de Android SDK**
```bash
./scripts/install-android-sdk.sh
source ~/.bashrc
```

### 3. **Verificar el Entorno (Opcional)**
```bash
./scripts/verify-android-setup.sh  # Verifica la configuración
```

## Requisitos Previos (Instalación Manual)

### Para Android:

1. **Java Development Kit (JDK)**
   ```bash
   # Instalar OpenJDK 17 (recomendado para React Native)
   sudo apt update
   sudo apt install openjdk-17-jdk
   ```

2. **Android SDK**
   - Opción 1: Usar el script automatizado `./scripts/install-android-sdk.sh`
   - Opción 2: Instalar manualmente:
   ```bash
   # Crear directorio para Android SDK
   mkdir -p ~/Android/Sdk
   cd ~/Android/Sdk
   
   # Descargar herramientas de línea de comandos
   wget https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip
   unzip commandlinetools-linux-11076708_latest.zip
   mkdir -p cmdline-tools/latest
   mv cmdline-tools/* cmdline-tools/latest/
   ```

3. **Configurar variables de entorno**
   Agrega esto a tu `~/.bashrc` o `~/.zshrc`:
   ```bash
   export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
   export ANDROID_HOME=$HOME/Android/Sdk
   export ANDROID_SDK_ROOT=$HOME/Android/Sdk
   export PATH=$PATH:$JAVA_HOME/bin
   export PATH=$PATH:$ANDROID_HOME/emulator
   export PATH=$PATH:$ANDROID_HOME/platform-tools
   export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
   export PATH=$PATH:$ANDROID_HOME/tools
   export PATH=$PATH:$ANDROID_HOME/tools/bin
   ```

4. **Instalar componentes de Android SDK**
   ```bash
   # Después de configurar las variables de entorno
   source ~/.bashrc  # o ~/.zshrc
   
   # Instalar componentes necesarios
   sdkmanager "platform-tools" "platforms;android-34" "build-tools;34.0.0"
   sdkmanager "ndk;25.1.8937393"  # NDK necesario para React Native
   ```

5. **Configurar local.properties**
   ```bash
   echo "sdk.dir=$HOME/Android/Sdk" > android/local.properties
   ```

### Para iOS (solo en macOS):

1. **Xcode**
   - Instala desde App Store
   - Instala las herramientas de línea de comandos:
   ```bash
   xcode-select --install
   ```

2. **CocoaPods**
   ```bash
   sudo gem install cocoapods
   ```

## Construcción de Builds Locales

### Android

#### APK de Desarrollo (para pruebas):
```bash
cd app
npm run build:android:sim
```

#### APK para Dispositivo:
```bash
npm run build:android:dev
```

#### APK/AAB de Producción:
```bash
npm run build:android:prod
```

### iOS (solo en macOS)

#### Build para Simulador:
```bash
npm run build:ios:sim
```

#### Build para Dispositivo:
```bash
npm run build:ios:dev
```

#### Build de Producción:
```bash
npm run build:ios:prod
```

## Proceso de Build

1. **Primera vez**: EAS te pedirá autenticarte
   ```bash
   npx eas login
   ```

2. **Durante el build local**:
   - EAS descargará las herramientas necesarias
   - Compilará tu aplicación localmente
   - El archivo generado estará en la carpeta del proyecto

3. **Ubicación de los archivos generados**:
   - Android: `build-*.apk` o `build-*.aab`
   - iOS: `build-*.tar.gz` (contiene el .app o .ipa)

## Instalación en Dispositivos

### Android:

#### Instalar en Dispositivo Físico:
```bash
# 1. Habilita el modo desarrollador en tu dispositivo Android
# 2. Habilita la depuración USB
# 3. Conecta el dispositivo por USB
# 4. Verifica que el dispositivo esté conectado:
adb devices

# 5. Instalar el APK generado:
adb install build-*.apk
# o específicamente:
adb install build-1748967974325.apk
```

#### Instalar en Emulador:
```bash
# 1. Abrir emulador (si tienes Android Studio):
emulator -avd Pixel_6_API_34  # Reemplaza con el nombre de tu AVD

# 2. Instalar APK:
adb install build-*.apk
```

#### Ejecutar la App con Expo Dev Client:
```bash
# Una vez instalada la build de desarrollo, puedes ejecutar:
npm start

# Esto abrirá el servidor de desarrollo de Expo
# Escanea el código QR con la app instalada o presiona 'a' para Android
```

### iOS:
- Para simulador: Arrastra el .app al simulador
- Para dispositivo: Usa Xcode o herramientas como ios-deploy

## Solución de Problemas

### Error: "ANDROID_HOME not set"
Asegúrate de haber configurado las variables de entorno correctamente.

### Error: "SDK location not found"
Crea el archivo `local.properties` en `android/`:
```
sdk.dir=/home/tu-usuario/Android/Sdk
```

### Error de memoria durante el build
Aumenta la memoria de Gradle en `android/gradle.properties`:
```
org.gradle.jvmargs=-Xmx4096m -XX:MaxPermSize=1024m
```

## Notas Importantes

- Las builds locales requieren más recursos que las builds en la nube
- El primer build descargará muchas dependencias (puede tomar tiempo)
- Asegúrate de tener al menos 10GB de espacio libre
- Para producción, considera usar certificados y keystore apropiados

================
File: app/docs/guides/BUILD_QUICKSTART.md
================
# 🚀 Guía Rápida - Builds Locales

## Primera vez (Configuración)

```bash
# 1. Ejecutar scripts de instalación
cd app
./scripts/install-java.sh
./scripts/install-android-sdk.sh
source ~/.bashrc

# 2. Instalar EAS CLI y login
npm install -g eas-cli
eas login
```

## Crear Build Local

```bash
# Build de desarrollo para dispositivo Android
npm run build:android:sim

# El APK se generará como: build-[timestamp].apk
```

## Instalar en Dispositivo

```bash
# Ver dispositivos conectados
adb devices

# Instalar APK
adb install build-*.apk
```

## Ejecutar la App

```bash
# Para Expo Go
npx expo start

# Para Development Build (APK instalado)
npx expo start --dev-client

# Si tienes problemas de conexión de red, usa modo tunnel
npx expo start --tunnel          # Para Expo Go
npx expo start --dev-client --tunnel  # Para Development Build
```

**Nota:** El modo tunnel es más confiable para problemas de red aunque ligeramente más lento.

## Scripts Disponibles

| Script | Descripción |
|--------|-------------|
| `scripts/install-java.sh` | Instala Java 17 |
| `scripts/install-android-sdk.sh` | Instala Android SDK y configura el entorno |
| `scripts/verify-android-setup.sh` | Verifica la configuración del entorno |
| `scripts/fix-expo-packages.sh` | Actualiza y corrige versiones de paquetes Expo |

## Comandos de Build

| Comando | Descripción |
|---------|-------------|
| `npm run build:android:sim` | Build para emulador Android |
| `npm run build:android:dev` | Build para dispositivo Android (desarrollo) |
| `npm run build:android:prod` | Build de producción Android |

## Requisitos del Sistema

- Ubuntu/Debian
- Node.js >=18.18.0
- Java JDK 17
- Android SDK con API 34
- ~10GB de espacio libre

## Notas Importantes

- Las variables de entorno de Android SDK pueden no persistir entre sesiones
- Si encuentras errores de SDK, ejecuta `source ~/.bashrc` o crea el archivo `android/local.properties`
- Los builds locales con EAS pueden fallar si no se aceptan todas las licencias del Android SDK

## Troubleshooting

### Error: Cannot determine which native SDK version (expo module not installed)
```bash
# Este error ocurre cuando el módulo expo no está instalado
# Solución:
npm install expo
npx expo install --fix
```

### Error: could not determine executable to run (npx eas)
```bash
# Este error ocurre cuando EAS CLI no está instalado
# Solución:
npm install -g eas-cli
eas login  # En lugar de npx eas login
```

### Java no encontrado
```bash
./scripts/install-java.sh
source ~/.bashrc
```

### Android SDK no encontrado (Build local con EAS)
```bash
# 1. Instalar Android SDK
./scripts/install-android-sdk.sh
source ~/.bashrc

# 2. Si el error persiste, configurar variables en la sesión actual:
export ANDROID_HOME=$HOME/android-sdk
export ANDROID_SDK_ROOT=$HOME/android-sdk
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools

# 3. Crear local.properties
echo "sdk.dir=$HOME/android-sdk" > android/local.properties

# 4. Alternativa: Usar una shell con las variables cargadas
bash -c "source ~/.bashrc && npm run build:android:sim"

# 5. Si nada funciona, considerar usar build en la nube:
eas build --platform android --profile development  # Sin --local
```

### Dispositivo no detectado
```bash
# Verificar modo desarrollador y depuración USB
adb devices
adb kill-server
adb start-server
```

### Error: expo doctor failed
```bash
# Este error puede ignorarse si el resto del build funciona
# Es causado por tener carpetas android/ios en un proyecto Expo
# Si necesitas solucionarlo, añade a .gitignore:
/android
/ios
```

## Build Exitosa

Cuando la build sea exitosa verás:
```
Build successful
You can find the build artifacts in app/build-1748967974325.apk
```

================
File: app/docs/guides/EAS_PROJECT_SETUP_GUIDE.md
================
# Guía para Crear un Nuevo Proyecto EAS

Esta guía te ayudará a desvincular el proyecto actual de EAS y crear uno nuevo con el slug "bite-restaurant".

## Prerrequisitos

- Tener instalado EAS CLI: `npm install -g eas-cli`
- Estar logueado en tu cuenta de Expo: `eas login`
- Tener el proyecto React Native/Expo funcionando localmente

## Paso 1: Verificar el Estado Actual del Proyecto

```bash
cd app
eas project:info
```

Esto mostrará información sobre el proyecto actual vinculado a EAS (si existe).

## Paso 2: Desvincular el Proyecto Actual

### Opción A: Limpiar completamente la configuración (recomendado)

1. Eliminar el ID del proyecto del archivo `app.json`:
   ```json
   {
     "expo": {
       // Eliminar esta línea si existe:
       "extra": {
         "eas": {
           "projectId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
         }
       }
     }
   }
   ```

2. Eliminar la carpeta .expo si existe:
   ```bash
   rm -rf .expo
   ```

3. Verificar que no hay archivos de configuración EAS locales:
   ```bash
   # Estos archivos normalmente no existen, pero verificar por si acaso
   ls -la .easignore .eas.json 2>/dev/null
   ```

## Paso 3: Actualizar app.json con el Nuevo Slug

Editar `app/app.json` y asegurarse de que tenga la configuración correcta:

```json
{
  "expo": {
    "name": "Bite Restaurant",
    "slug": "bite-restaurant",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#FF6B6B"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.biterestaurant.app"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#FF6B6B"
      },
      "package": "com.biterestaurant.app"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "backgroundColor": "#FF6B6B",
          "image": "./assets/splash-icon.png",
          "imageWidth": 200
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    },
    "scheme": "bite-restaurant"
  }
}
```

## Paso 4: Crear el Nuevo Proyecto en EAS

```bash
# Inicializar EAS con el nuevo proyecto
eas init

# Si ya tienes un proyecto vinculado, usa:
eas project:init
```

Durante este proceso:
1. EAS detectará el slug "bite-restaurant"
2. Te preguntará si quieres crear un nuevo proyecto
3. Selecciona "Yes" para crear el nuevo proyecto
4. EAS generará un nuevo project ID y lo agregará a tu app.json

## Paso 5: Verificar la Configuración de EAS

Asegúrate de que `app/eas.json` esté configurado correctamente:

```json
{
  "cli": {
    "version": ">= 5.2.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "android": {
        "gradleCommand": ":app:assembleDebug"
      },
      "ios": {
        "buildConfiguration": "Debug"
      }
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
```

## Paso 6: Verificar el Nuevo Proyecto

```bash
# Verificar que el proyecto esté correctamente vinculado
eas project:info

# Debería mostrar:
# Project: bite-restaurant
# ID: [nuevo-project-id]
# Owner: [tu-usuario]
```

## Paso 7: Configurar los Secretos del Proyecto (Opcional)

Si tu proyecto necesita variables de entorno secretas:

```bash
# Configurar secretos para el nuevo proyecto
eas secret:create --name API_URL --value "https://tu-api.com"
eas secret:create --name OTRO_SECRETO --value "valor-secreto"

# Listar secretos configurados
eas secret:list
```

## Paso 8: Realizar una Build de Prueba

Para verificar que todo esté funcionando correctamente:

```bash
# Build de desarrollo para Android
eas build --platform android --profile development

# Build de desarrollo para iOS
eas build --platform ios --profile development
```

## Troubleshooting

### Error: "Project already exists"
Si EAS dice que el proyecto ya existe con ese slug:
1. Intenta con un slug diferente (ej: "bite-restaurant-app")
2. O contacta al soporte de Expo para liberar el slug si es tuyo

### Error: "Invalid project ID"
Si hay problemas con el project ID:
1. Elimina completamente la sección `extra.eas` de app.json
2. Ejecuta `eas init` nuevamente

### Error: "Authentication required"
Si tienes problemas de autenticación:
```bash
eas logout
eas login
```

## Notas Importantes

1. **Backup**: Antes de desvincular, asegúrate de tener un backup de cualquier configuración importante
2. **Builds anteriores**: Las builds del proyecto anterior seguirán disponibles en tu cuenta de Expo
3. **Colaboradores**: Si tienes colaboradores, deberán actualizar su configuración local después del cambio
4. **CI/CD**: Si usas CI/CD, actualiza las variables de entorno con el nuevo project ID

## Comandos Útiles

```bash
# Ver todos tus proyectos en EAS
eas project:list

# Ver información detallada del proyecto actual
eas project:info

# Ver el estado de las builds
eas build:list

# Cancelar una build en progreso
eas build:cancel [build-id]
```

## Siguiente Paso

Una vez completada la configuración, puedes continuar con el desarrollo normal:

```bash
# Desarrollo local
npm start

# Crear builds
npm run build:android:dev
npm run build:ios:dev
```

================
File: app/docs/guides/FIRST_UPLOAD_GUIDE.md
================
# Guía para la Primera Subida a Play Store

## Generar y subir tu primer AAB (Android App Bundle)

### 1. Generar el AAB de producción

```bash
cd app

# Asegúrate de estar logueado en EAS
eas login

# Generar el AAB de producción
eas build --platform android --profile production
```

### 2. Descargar el AAB

Una vez que el build termine (aproximadamente 15-20 minutos):

1. Ve a https://expo.dev y busca tu build
2. Descarga el archivo `.aab` 
3. O usa el comando: `eas build:download --platform android`

### 3. Subir a Play Store

En la pantalla que estás viendo:

1. Haz clic en "Subir" (el botón junto a "Suelta los paquetes de aplicaciones aquí para subirlos")
2. Selecciona el archivo `.aab` que descargaste
3. Espera a que se procese

### 4. Completar información de la versión

Después de subir el AAB:

1. **Nombre de la versión**: Se llenará automáticamente (ej: "1.0.0")
2. **Notas de la versión**: Escribe algo como:
   ```
   - Versión inicial de Bite
   - Sistema de gestión de restaurante
   - Gestión de pedidos y mesas
   - Impresión térmica
   ```

3. Haz clic en "Guardar"

### 5. Configurar el lanzamiento

1. Ve a "Pruebas" → "Prueba interna"
2. Crea un nuevo lanzamiento
3. Agrega el AAB que subiste
4. Completa las notas de la versión
5. Revisa y lanza

## Importante

- Esta primera subida DEBE hacerse manualmente
- Después de esta primera subida, podrás usar la automatización con EAS Submit
- El AAB debe estar firmado (EAS lo hace automáticamente)
- Google Play procesará el AAB y generará APKs optimizados para cada dispositivo

## Próximos pasos

Una vez que hayas subido el primer AAB:

1. Completa todas las secciones requeridas en Play Console:
   - Descripción de la app
   - Capturas de pantalla
   - Categorización
   - Clasificación de contenido
   - Política de privacidad

2. Configura el Service Account para automatización futura
3. Usa `npm run release:playstore` para publicaciones futuras

================
File: app/docs/guides/PLAY_STORE_PUBLISHING.md
================
# Guía de Publicación en Google Play Store

Esta guía te ayudará a publicar tu app Bite en Google Play Store de forma automatizada usando EAS (Expo Application Services).

## Requisitos Previos

1. **Cuenta de Google Play Console** ($25 único pago)
   - Crear cuenta en: https://play.google.com/console
   - Crear tu primera aplicación en la consola

2. **Configuración inicial en Play Console**:
   - Crear aplicación nueva
   - Completar todas las secciones requeridas:
     - Detalles de la app
     - Clasificación de contenido
     - Política de privacidad
     - Información de contacto
   - Subir al menos un APK/AAB manualmente la primera vez

3. **Service Account para automatización**:
   - Ve a Play Console → Configuración → Acceso a API
   - Crear proyecto en Google Cloud Console
   - Habilitar Google Play Android Developer API
   - Crear Service Account con permisos de "Release Manager"
   - Descargar el archivo JSON de credenciales

## Configuración del Proyecto

### 1. Preparar app.json para producción

```json
{
  "expo": {
    "name": "Bite",
    "slug": "bite-restaurant",
    "version": "1.0.0",
    "android": {
      "package": "com.tuempresa.bite",
      "versionCode": 1,
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "permissions": []
    }
  }
}
```

### 2. Configurar eas.json para Play Store

```json
{
  "build": {
    "production": {
      "android": {
        "buildType": "app-bundle",
        "env": {
          "API_URL": "https://tu-api-produccion.com"
        }
      }
    }
  },
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "./google-play-service-account.json",
        "track": "internal",
        "releaseStatus": "draft",
        "changesNotSentForReview": false
      }
    }
  }
}
```

### 3. Variables de entorno para producción

Crear archivo `.env.production`:
```
API_URL=https://tu-api-produccion.com
```

## Proceso de Publicación Automatizado

### Método 1: Script NPM (Recomendado)

Agregar estos scripts a tu `package.json`:

```json
{
  "scripts": {
    "build:prod": "eas build --platform android --profile production",
    "submit:prod": "eas submit --platform android --profile production",
    "release:prod": "npm run build:prod && npm run submit:prod",
    "release:prod:auto": "eas build --platform android --profile production --auto-submit"
  }
}
```

### Método 2: GitHub Actions (CI/CD)

Crear `.github/workflows/release.yml`:

```yaml
name: Release to Play Store

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-submit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18
          
      - name: Setup Expo
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build and Submit
        run: eas build --platform android --profile production --auto-submit --non-interactive
```

## Pasos para Publicar

### Primera vez (configuración):

```bash
# 1. Login en EAS
eas login

# 2. Configurar el proyecto
eas build:configure

# 3. Guardar el service account JSON
cp ~/Downloads/tu-service-account.json ./google-play-service-account.json

# 4. Agregar a .gitignore
echo "google-play-service-account.json" >> .gitignore
```

### Publicación regular:

```bash
# Opción 1: Build y submit por separado
npm run build:prod
# Esperar a que termine el build
npm run submit:prod

# Opción 2: Todo automatizado
npm run release:prod:auto

# Opción 3: Con versión específica
eas build --platform android --profile production --auto-submit --message "Version 1.0.1: Bug fixes"
```

## Configuración de Tracks en Play Store

- **internal**: Testing interno (recomendado para empezar)
- **alpha**: Testing cerrado
- **beta**: Testing abierto
- **production**: Producción

Modificar en `eas.json`:
```json
"track": "internal"  // cambiar según necesites
```

## Automatización Completa con Script

Crear `scripts/release-to-playstore.sh`:

```bash
#!/bin/bash

# Colores para output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}🚀 Iniciando release a Play Store...${NC}"

# 1. Verificar que estamos en main
BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH" != "main" ]; then
    echo "❌ Debes estar en la rama main para hacer release"
    exit 1
fi

# 2. Actualizar version en app.json
echo -e "${YELLOW}📝 Ingresa la nueva versión (actual: $(node -p "require('./app.json').expo.version")):${NC}"
read VERSION

# 3. Actualizar versionCode
CURRENT_VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))

# 4. Actualizar app.json
node -e "
const fs = require('fs');
const appJson = require('./app.json');
appJson.expo.version = '$VERSION';
appJson.expo.android.versionCode = $NEW_VERSION_CODE;
fs.writeFileSync('./app.json', JSON.stringify(appJson, null, 2));
"

echo -e "${GREEN}✅ Versión actualizada a $VERSION (versionCode: $NEW_VERSION_CODE)${NC}"

# 5. Commit cambios
git add app.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# 6. Build y submit
echo -e "${YELLOW}🏗️  Iniciando build y submit...${NC}"
eas build --platform android --profile production --auto-submit --non-interactive

# 7. Push cambios
git push origin main --tags

echo -e "${GREEN}✅ Release completado!${NC}"
```

Hacer ejecutable:
```bash
chmod +x scripts/release-to-playstore.sh
```

## Tips y Mejores Prácticas

1. **Versionado**: Siempre incrementa `versionCode` para cada build
2. **Testing**: Usa track "internal" primero antes de producción
3. **Changelogs**: Mantén un CHANGELOG.md actualizado
4. **Assets**: Prepara todos los assets requeridos:
   - Screenshots (mínimo 2)
   - Feature graphic (1024x500)
   - Icono alta resolución (512x512)
5. **Monitoreo**: Configura Sentry o similar para crashes en producción

## Troubleshooting

- **Error de permisos**: Verifica que el Service Account tenga rol "Release Manager"
- **Build fallido**: Revisa los logs en https://expo.dev
- **Versión rechazada**: Incrementa `versionCode` e intenta de nuevo

================
File: app/index.ts
================
import { registerRootComponent } from 'expo';
import App from './App';

registerRootComponent(App);

================
File: app/ios/.gitignore
================
# OSX
#
.DS_Store

# Xcode
#
build/
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
xcuserdata
*.xccheckout
*.moved-aside
DerivedData
*.hmap
*.ipa
*.xcuserstate
project.xcworkspace
.xcode.env.local

# Bundle artifacts
*.jsbundle

# CocoaPods
/Pods/

================
File: app/ios/.xcode.env
================
# This `.xcode.env` file is versioned and is used to source the environment
# used when running script phases inside Xcode.
# To customize your local environment, you can create an `.xcode.env.local`
# file that is not versioned.

# NODE_BINARY variable contains the PATH to the node executable.
#
# Customize the NODE_BINARY variable here.
# For example, to use nvm with brew, add the following line
# . "$(brew --prefix nvm)/nvm.sh" --no-use
export NODE_BINARY=$(command -v node)

================
File: app/ios/pizza.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		13B07FBF1A68108700A75B9A /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 13B07FB51A68108700A75B9A /* Images.xcassets */; };
		3E461D99554A48A4959DE609 /* SplashScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */; };
		BB2F792D24A3F905000567C9 /* Expo.plist in Resources */ = {isa = PBXBuildFile; fileRef = BB2F792C24A3F905000567C9 /* Expo.plist */; };
		F11748422D0307B40044C1D9 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = F11748412D0307B40044C1D9 /* AppDelegate.swift */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		13B07F961A680F5B00A75B9A /* pizza.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = pizza.app; sourceTree = BUILT_PRODUCTS_DIR; };
		13B07FB51A68108700A75B9A /* Images.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Images.xcassets; path = pizza/Images.xcassets; sourceTree = "<group>"; };
		13B07FB61A68108700A75B9A /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = Info.plist; path = pizza/Info.plist; sourceTree = "<group>"; };
		AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.storyboard; name = SplashScreen.storyboard; path = pizza/SplashScreen.storyboard; sourceTree = "<group>"; };
		BB2F792C24A3F905000567C9 /* Expo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Expo.plist; sourceTree = "<group>"; };
		ED297162215061F000B7C4FE /* JavaScriptCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = JavaScriptCore.framework; path = System/Library/Frameworks/JavaScriptCore.framework; sourceTree = SDKROOT; };
		F11748412D0307B40044C1D9 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = AppDelegate.swift; path = pizza/AppDelegate.swift; sourceTree = "<group>"; };
		F11748442D0722820044C1D9 /* pizza-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = "pizza-Bridging-Header.h"; path = "pizza/pizza-Bridging-Header.h"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		13B07F8C1A680F5B00A75B9A /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		13B07FAE1A68108700A75B9A /* pizza */ = {
			isa = PBXGroup;
			children = (
				F11748412D0307B40044C1D9 /* AppDelegate.swift */,
				F11748442D0722820044C1D9 /* pizza-Bridging-Header.h */,
				BB2F792B24A3F905000567C9 /* Supporting */,
				13B07FB51A68108700A75B9A /* Images.xcassets */,
				13B07FB61A68108700A75B9A /* Info.plist */,
				AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */,
			);
			name = pizza;
			sourceTree = "<group>";
		};
		2D16E6871FA4F8E400B85C8A /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				ED297162215061F000B7C4FE /* JavaScriptCore.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		832341AE1AAA6A7D00B99B32 /* Libraries */ = {
			isa = PBXGroup;
			children = (
			);
			name = Libraries;
			sourceTree = "<group>";
		};
		83CBB9F61A601CBA00E9B192 = {
			isa = PBXGroup;
			children = (
				13B07FAE1A68108700A75B9A /* pizza */,
				832341AE1AAA6A7D00B99B32 /* Libraries */,
				83CBBA001A601CBA00E9B192 /* Products */,
				2D16E6871FA4F8E400B85C8A /* Frameworks */,
			);
			indentWidth = 2;
			sourceTree = "<group>";
			tabWidth = 2;
			usesTabs = 0;
		};
		83CBBA001A601CBA00E9B192 /* Products */ = {
			isa = PBXGroup;
			children = (
				13B07F961A680F5B00A75B9A /* pizza.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		BB2F792B24A3F905000567C9 /* Supporting */ = {
			isa = PBXGroup;
			children = (
				BB2F792C24A3F905000567C9 /* Expo.plist */,
			);
			name = Supporting;
			path = pizza/Supporting;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		13B07F861A680F5B00A75B9A /* pizza */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 13B07F931A680F5B00A75B9A /* Build configuration list for PBXNativeTarget "pizza" */;
			buildPhases = (
				08A4A3CD28434E44B6B9DE2E /* [CP] Check Pods Manifest.lock */,
				13B07F871A680F5B00A75B9A /* Sources */,
				13B07F8C1A680F5B00A75B9A /* Frameworks */,
				13B07F8E1A680F5B00A75B9A /* Resources */,
				00DD1BFF1BD5951E006B06BC /* Bundle React Native code and images */,
				800E24972A6A228C8D4807E9 /* [CP] Copy Pods Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = pizza;
			productName = pizza;
			productReference = 13B07F961A680F5B00A75B9A /* pizza.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		83CBB9F71A601CBA00E9B192 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastUpgradeCheck = 1130;
				TargetAttributes = {
					13B07F861A680F5B00A75B9A = {
						LastSwiftMigration = 1250;
					};
				};
			};
			buildConfigurationList = 83CBB9FA1A601CBA00E9B192 /* Build configuration list for PBXProject "pizza" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 83CBB9F61A601CBA00E9B192;
			productRefGroup = 83CBBA001A601CBA00E9B192 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				13B07F861A680F5B00A75B9A /* pizza */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		13B07F8E1A680F5B00A75B9A /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				BB2F792D24A3F905000567C9 /* Expo.plist in Resources */,
				13B07FBF1A68108700A75B9A /* Images.xcassets in Resources */,
				3E461D99554A48A4959DE609 /* SplashScreen.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		00DD1BFF1BD5951E006B06BC /* Bundle React Native code and images */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Bundle React Native code and images";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "if [[ -f \"$PODS_ROOT/../.xcode.env\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env\"\nfi\nif [[ -f \"$PODS_ROOT/../.xcode.env.local\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.local\"\nfi\n\n# The project root by default is one level up from the ios directory\nexport PROJECT_ROOT=\"$PROJECT_DIR\"/..\n\nif [[ \"$CONFIGURATION\" = *Debug* ]]; then\n  export SKIP_BUNDLING=1\nfi\nif [[ -z \"$ENTRY_FILE\" ]]; then\n  # Set the entry JS file using the bundler's entry resolution.\n  export ENTRY_FILE=\"$(\"$NODE_BINARY\" -e \"require('expo/scripts/resolveAppEntry')\" \"$PROJECT_ROOT\" ios absolute | tail -n 1)\"\nfi\n\nif [[ -z \"$CLI_PATH\" ]]; then\n  # Use Expo CLI\n  export CLI_PATH=\"$(\"$NODE_BINARY\" --print \"require.resolve('@expo/cli', { paths: [require.resolve('expo/package.json')] })\")\"\nfi\nif [[ -z \"$BUNDLE_COMMAND\" ]]; then\n  # Default Expo CLI command for bundling\n  export BUNDLE_COMMAND=\"export:embed\"\nfi\n\n# Source .xcode.env.updates if it exists to allow\n# SKIP_BUNDLING to be unset if needed\nif [[ -f \"$PODS_ROOT/../.xcode.env.updates\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.updates\"\nfi\n# Source local changes to allow overrides\n# if needed\nif [[ -f \"$PODS_ROOT/../.xcode.env.local\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.local\"\nfi\n\n`\"$NODE_BINARY\" --print \"require('path').dirname(require.resolve('react-native/package.json')) + '/scripts/react-native-xcode.sh'\"`\n\n";
		};
		08A4A3CD28434E44B6B9DE2E /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-pizza-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		800E24972A6A228C8D4807E9 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-pizza/Pods-pizza-resources.sh",
				"${PODS_CONFIGURATION_BUILD_DIR}/EXConstants/EXConstants.bundle",
				"${PODS_CONFIGURATION_BUILD_DIR}/EXUpdates/EXUpdates.bundle",
				"${PODS_CONFIGURATION_BUILD_DIR}/React-Core/RCTI18nStrings.bundle",
			);
			name = "[CP] Copy Pods Resources";
			outputPaths = (
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/EXConstants.bundle",
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/EXUpdates.bundle",
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/RCTI18nStrings.bundle",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-pizza/Pods-pizza-resources.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		13B07F871A680F5B00A75B9A /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				F11748422D0307B40044C1D9 /* AppDelegate.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		13B07F941A680F5B00A75B9A /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				ENABLE_BITCODE = NO;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"$(inherited)",
					"FB_SONARKIT_ENABLED=1",
				);
				INFOPLIST_FILE = pizza/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "com.viefmoon.pizza";
				PRODUCT_NAME = "pizza";
				SWIFT_OBJC_BRIDGING_HEADER = "pizza/pizza-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
				TARGETED_DEVICE_FAMILY = "1";
				CODE_SIGN_ENTITLEMENTS = pizza/pizza.entitlements;
			};
			name = Debug;
		};
		13B07F951A680F5B00A75B9A /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				INFOPLIST_FILE = pizza/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "com.viefmoon.pizza";
				PRODUCT_NAME = "pizza";
				SWIFT_OBJC_BRIDGING_HEADER = "pizza/pizza-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
				TARGETED_DEVICE_FAMILY = "1";
				CODE_SIGN_ENTITLEMENTS = pizza/pizza.entitlements;
			};
			name = Release;
		};
		83CBBA201A601CBA00E9B192 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "c++20";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					/usr/lib/swift,
					"$(inherited)",
				);
				LIBRARY_SEARCH_PATHS = "\"$(inherited)\"";
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
			};
			name = Debug;
		};
		83CBBA211A601CBA00E9B192 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "c++20";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = YES;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					/usr/lib/swift,
					"$(inherited)",
				);
				LIBRARY_SEARCH_PATHS = "\"$(inherited)\"";
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		13B07F931A680F5B00A75B9A /* Build configuration list for PBXNativeTarget "pizza" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				13B07F941A680F5B00A75B9A /* Debug */,
				13B07F951A680F5B00A75B9A /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		83CBB9FA1A601CBA00E9B192 /* Build configuration list for PBXProject "pizza" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				83CBBA201A601CBA00E9B192 /* Debug */,
				83CBBA211A601CBA00E9B192 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 83CBB9F71A601CBA00E9B192 /* Project object */;
}

================
File: app/ios/pizza.xcodeproj/xcshareddata/xcschemes/pizza.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1130"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
               BuildableName = "pizza.app"
               BlueprintName = "pizza"
               ReferencedContainer = "container:pizza.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
         <TestableReference
            skipped = "NO">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "00E356ED1AD99517003FC87E"
               BuildableName = "pizzaTests.xctest"
               BlueprintName = "pizzaTests"
               ReferencedContainer = "container:pizza.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "pizza.app"
            BlueprintName = "pizza"
            ReferencedContainer = "container:pizza.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "pizza.app"
            BlueprintName = "pizza"
            ReferencedContainer = "container:pizza.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: app/ios/pizza/AppDelegate.swift
================
import Expo
import React
import ReactAppDependencyProvider

@UIApplicationMain
public class AppDelegate: ExpoAppDelegate {
  var window: UIWindow?

  var reactNativeDelegate: ExpoReactNativeFactoryDelegate?
  var reactNativeFactory: RCTReactNativeFactory?

  public override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
    let delegate = ReactNativeDelegate()
    let factory = ExpoReactNativeFactory(delegate: delegate)
    delegate.dependencyProvider = RCTAppDependencyProvider()

    reactNativeDelegate = delegate
    reactNativeFactory = factory
    bindReactNativeFactory(factory)

#if os(iOS) || os(tvOS)
    window = UIWindow(frame: UIScreen.main.bounds)
    factory.startReactNative(
      withModuleName: "main",
      in: window,
      launchOptions: launchOptions)
#endif

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  // Linking API
  public override func application(
    _ app: UIApplication,
    open url: URL,
    options: [UIApplication.OpenURLOptionsKey: Any] = [:]
  ) -> Bool {
    return super.application(app, open: url, options: options) || RCTLinkingManager.application(app, open: url, options: options)
  }

  // Universal Links
  public override func application(
    _ application: UIApplication,
    continue userActivity: NSUserActivity,
    restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void
  ) -> Bool {
    let result = RCTLinkingManager.application(application, continue: userActivity, restorationHandler: restorationHandler)
    return super.application(application, continue: userActivity, restorationHandler: restorationHandler) || result
  }
}

class ReactNativeDelegate: ExpoReactNativeFactoryDelegate {
  // Extension point for config-plugins

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    // needed to return the correct URL for expo-dev-client.
    bridge.bundleURL ?? bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    return RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: ".expo/.virtual-metro-entry")
#else
    return Bundle.main.url(forResource: "main", withExtension: "jsbundle")
#endif
  }
}

================
File: app/ios/pizza/Images.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images": [
    {
      "filename": "App-Icon-1024x1024@1x.png",
      "idiom": "universal",
      "platform": "ios",
      "size": "1024x1024"
    }
  ],
  "info": {
    "version": 1,
    "author": "expo"
  }
}

================
File: app/ios/pizza/Images.xcassets/Contents.json
================
{
  "info" : {
    "version" : 1,
    "author" : "expo"
  }
}

================
File: app/ios/pizza/Images.xcassets/SplashScreenBackground.colorset/Contents.json
================
{
  "colors": [
    {
      "color": {
        "components": {
          "alpha": "1.000",
          "blue": "1.00000000000000",
          "green": "1.00000000000000",
          "red": "1.00000000000000"
        },
        "color-space": "srgb"
      },
      "idiom": "universal"
    }
  ],
  "info": {
    "version": 1,
    "author": "expo"
  }
}

================
File: app/ios/pizza/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>CADisableMinimumFrameDurationOnPhone</key>
    <true/>
    <key>CFBundleDevelopmentRegion</key>
    <string>$(DEVELOPMENT_LANGUAGE)</string>
    <key>CFBundleDisplayName</key>
    <string>CloudBite</string>
    <key>CFBundleExecutable</key>
    <string>$(EXECUTABLE_NAME)</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundlePackageType</key>
    <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0.0</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleURLTypes</key>
    <array>
      <dict>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>com.viefmoon.cloudbite</string>
        </array>
      </dict>
      <dict>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>exp+cloudbite</string>
        </array>
      </dict>
    </array>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>LSMinimumSystemVersion</key>
    <string>12.0</string>
    <key>LSRequiresIPhoneOS</key>
    <true/>
    <key>NSAppTransportSecurity</key>
    <dict>
      <key>NSAllowsArbitraryLoads</key>
      <false/>
      <key>NSAllowsLocalNetworking</key>
      <true/>
    </dict>
    <key>NSCameraUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to access your camera</string>
    <key>NSMicrophoneUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to use the microphone.</string>
    <key>NSPhotoLibraryUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to access your photos</string>
    <key>NSSpeechRecognitionUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to use speech recognition.</string>
    <key>UILaunchStoryboardName</key>
    <string>SplashScreen</string>
    <key>UIRequiredDeviceCapabilities</key>
    <array>
      <string>arm64</string>
    </array>
    <key>UIRequiresFullScreen</key>
    <false/>
    <key>UIStatusBarStyle</key>
    <string>UIStatusBarStyleDefault</string>
    <key>UISupportedInterfaceOrientations</key>
    <array>
      <string>UIInterfaceOrientationPortrait</string>
      <string>UIInterfaceOrientationPortraitUpsideDown</string>
      <string>UIInterfaceOrientationLandscapeLeft</string>
      <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
    <key>UIUserInterfaceStyle</key>
    <string>Light</string>
    <key>UIViewControllerBasedStatusBarAppearance</key>
    <false/>
  </dict>
</plist>

================
File: app/ios/pizza/pizza-Bridging-Header.h
================
//
// Use this file to import your target's public headers that you would like to expose to Swift.
//

================
File: app/ios/pizza/pizza.entitlements
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict/>
</plist>

================
File: app/ios/pizza/SplashScreen.storyboard
================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="32700.99.1234" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="EXPO-VIEWCONTROLLER-1">
    <device id="retina6_12" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="22685"/>
        <capability name="Named colors" minToolsVersion="9.0"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <scene sceneID="EXPO-SCENE-1">
            <objects>
                <viewController storyboardIdentifier="SplashScreenViewController" id="EXPO-VIEWCONTROLLER-1" sceneMemberID="viewController">
                    <view key="view" userInteractionEnabled="NO" contentMode="scaleToFill" insetsLayoutMarginsFromSafeArea="NO" id="EXPO-ContainerView" userLabel="ContainerView">
                        <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMaxY="YES"/>
                        <subviews/>
                        <viewLayoutGuide key="safeArea" id="Rmq-lb-GrQ"/>
                        <constraints>
                            <constraint firstItem="EXPO-SplashScreen" firstAttribute="centerY" secondItem="EXPO-ContainerView" secondAttribute="centerY" id="0VC-Wk-OaO"/>
                            <constraint firstItem="EXPO-SplashScreen" firstAttribute="centerX" secondItem="EXPO-ContainerView" secondAttribute="centerX" id="zR4-NK-mVN"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="EXPO-PLACEHOLDER-1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="0.0" y="0.0"/>
        </scene>
    </scenes>
    <resources>
        <image name="SplashScreenLogo" width="100" height="90.333335876464844"/>
    </resources>
</document>

================
File: app/ios/pizza/Supporting/Expo.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>EXUpdatesCheckOnLaunch</key>
    <string>ALWAYS</string>
    <key>EXUpdatesEnabled</key>
    <false/>
    <key>EXUpdatesLaunchWaitMs</key>
    <integer>0</integer>
  </dict>
</plist>

================
File: app/ios/Podfile
================
require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

require 'json'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

ENV['RCT_NEW_ARCH_ENABLED'] = '0' if podfile_properties['newArchEnabled'] == 'false'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] = podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']

platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'
install! 'cocoapods',
  :deterministic_uuids => false

prepare_react_native_project!

target 'pizza' do
  use_expo_modules!

  if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
    config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
  else
    config_command = [
      'npx',
      'expo-modules-autolinking',
      'react-native-config',
      '--json',
      '--platform',
      'ios'
    ]
  end

  config = use_native_modules!(config_command)

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
  )

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      :ccache_enabled => podfile_properties['apple.ccacheEnabled'] == 'true',
    )

    # This is necessary for Xcode 14, because it signs resource bundles by default
    # when building for devices.
    installer.target_installation_results.pod_target_installation_results
      .each do |pod_name, target_installation_result|
      target_installation_result.resource_bundle_targets.each do |resource_bundle_target|
        resource_bundle_target.build_configurations.each do |config|
          config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'
        end
      end
    end
  end
end

================
File: app/ios/Podfile.properties.json
================
{
  "expo.jsEngine": "hermes",
  "EX_DEV_CLIENT_NETWORK_INSPECTOR": "true"
}

================
File: app/scripts/dev/reset-project.sh
================
#!/bin/bash

echo "🧹 Limpiando proyecto React Native..."

# Detener Metro bundler
echo "Deteniendo Metro bundler..."
pkill -f "react-native.*metro" || true

# Limpiar watchman
echo "Limpiando watchman..."
watchman watch-del-all 2>/dev/null || true

# Limpiar caches de React Native
echo "Limpiando caches..."
rm -rf $TMPDIR/react-* 2>/dev/null || true
rm -rf $TMPDIR/metro-* 2>/dev/null || true
rm -rf $TMPDIR/haste-* 2>/dev/null || true

# Limpiar node_modules y lock files
echo "Eliminando node_modules..."
rm -rf node_modules
rm -rf package-lock.json

# Limpiar caches de npm
echo "Limpiando cache de npm..."
npm cache clean --force

# Reinstalar dependencias
echo "Reinstalando dependencias..."
npm install

# Limpiar cache de Expo
echo "Limpiando cache de Expo..."
npx expo start --clear

echo "✅ Limpieza completa!"

================
File: app/scripts/install-android-sdk.sh
================
#!/bin/bash

echo "=== Instalación de Android SDK para builds locales ==="
echo ""

# Crear directorio para Android SDK
ANDROID_SDK_ROOT="$HOME/Android/Sdk"
mkdir -p "$ANDROID_SDK_ROOT"

# Instalar unzip si no está instalado
if ! command -v unzip &> /dev/null; then
    echo "📦 Instalando unzip..."
    sudo apt install -y unzip
fi

# Descargar Android command line tools
if [ ! -d "$ANDROID_SDK_ROOT/cmdline-tools" ]; then
    echo "📦 Descargando Android Command Line Tools..."
    cd "$ANDROID_SDK_ROOT"
    
    # URL de las herramientas más recientes
    TOOLS_URL="https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip"
    
    echo "Descargando desde: $TOOLS_URL"
    wget -q --show-progress "$TOOLS_URL" -O cmdline-tools.zip
    
    echo "Extrayendo herramientas..."
    unzip -q cmdline-tools.zip
    
    # Reorganizar la estructura de directorios correctamente
    mkdir -p cmdline-tools/latest
    mv cmdline-tools/* cmdline-tools/latest/ 2>/dev/null || true
    
    # Limpiar
    rm -f cmdline-tools.zip
    
    echo "✅ Android Command Line Tools instaladas"
else
    echo "✅ Android Command Line Tools ya existen"
fi

# Configurar variables de entorno
echo ""
echo "🔧 Configurando variables de entorno..."

# Detectar shell
SHELL_CONFIG="$HOME/.bashrc"
if [ -n "$ZSH_VERSION" ]; then
    SHELL_CONFIG="$HOME/.zshrc"
fi

# Agregar ANDROID_HOME si no existe
if ! grep -q "ANDROID_HOME" "$SHELL_CONFIG"; then
    echo "" >> "$SHELL_CONFIG"
    echo "# Android SDK" >> "$SHELL_CONFIG"
    echo "export ANDROID_HOME=$ANDROID_SDK_ROOT" >> "$SHELL_CONFIG"
    echo "export ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/emulator" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/platform-tools" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/cmdline-tools/latest/bin" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/tools" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/tools/bin" >> "$SHELL_CONFIG"
fi

# Exportar para la sesión actual
export ANDROID_HOME=$ANDROID_SDK_ROOT
export ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
export PATH=$PATH:$ANDROID_HOME/tools
export PATH=$PATH:$ANDROID_HOME/tools/bin

# Verificar que sdkmanager esté disponible
if ! command -v sdkmanager &> /dev/null; then
    echo "❌ Error: sdkmanager no se encuentra. Verificando instalación..."
    ls -la "$ANDROID_HOME/cmdline-tools/latest/bin/"
    exit 1
fi

echo ""
echo "📦 Instalando componentes de Android SDK..."
echo "Esto puede tomar varios minutos..."

# Aceptar licencias
yes | sdkmanager --licenses 2>/dev/null || true

# Instalar componentes esenciales
sdkmanager "platform-tools"
sdkmanager "platforms;android-34"
sdkmanager "build-tools;34.0.0"
sdkmanager "ndk;25.1.8937393"

# Crear/actualizar local.properties
echo ""
echo "📝 Actualizando local.properties..."
echo "sdk.dir=$ANDROID_SDK_ROOT" > "$HOME/bite/app/android/local.properties"

echo ""
echo "✅ ¡Android SDK instalado y configurado!"
echo ""
echo "📋 Resumen de la configuración:"
echo "   ANDROID_HOME=$ANDROID_HOME"
echo "   JAVA_HOME=$JAVA_HOME"
echo ""
echo "⚠️  IMPORTANTE: Ejecuta este comando para cargar las variables:"
echo "    source $SHELL_CONFIG"
echo ""
echo "🚀 Luego puedes ejecutar tu build con:"
echo "    npm run build:android:dev"

================
File: app/scripts/install-java.sh
================
#!/bin/bash

# Install Java JDK 17 and configure environment for Android builds

echo "Installing OpenJDK 17..."
sudo apt update
sudo apt install -y openjdk-17-jdk

# Verify installation
echo -e "\nVerifying Java installation..."
java -version
javac -version

# Find Java installation path
JAVA_PATH=$(update-alternatives --list java | grep java-17)
if [ -z "$JAVA_PATH" ]; then
    echo "Error: Java 17 installation not found"
    exit 1
fi

# Extract JAVA_HOME from the path (remove /bin/java from the end)
JAVA_HOME_PATH=$(dirname $(dirname $JAVA_PATH))

echo -e "\nJava installed at: $JAVA_HOME_PATH"

# Add JAVA_HOME and PATH to .bashrc
echo -e "\nConfiguring environment variables..."

# Check if JAVA_HOME is already in .bashrc
if ! grep -q "export JAVA_HOME=" ~/.bashrc; then
    echo "" >> ~/.bashrc
    echo "# Java configuration" >> ~/.bashrc
    echo "export JAVA_HOME=$JAVA_HOME_PATH" >> ~/.bashrc
    echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.bashrc
    echo "Environment variables added to ~/.bashrc"
else
    echo "JAVA_HOME already exists in ~/.bashrc, updating..."
    sed -i "s|export JAVA_HOME=.*|export JAVA_HOME=$JAVA_HOME_PATH|" ~/.bashrc
fi

# Also add to .profile for non-interactive shells
if ! grep -q "export JAVA_HOME=" ~/.profile; then
    echo "" >> ~/.profile
    echo "# Java configuration" >> ~/.profile
    echo "export JAVA_HOME=$JAVA_HOME_PATH" >> ~/.profile
    echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.profile
fi

# Export for current session
export JAVA_HOME=$JAVA_HOME_PATH
export PATH=$JAVA_HOME/bin:$PATH

echo -e "\nJava installation complete!"
echo "JAVA_HOME set to: $JAVA_HOME"
echo -e "\nPlease run: source ~/.bashrc"
echo "Or restart your terminal for changes to take effect."

================
File: app/scripts/release-to-playstore.sh
================
#!/bin/bash

# Colores para output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

echo -e "${YELLOW}🚀 Iniciando release a Play Store...${NC}"

# 1. Verificar que estamos en main
BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH" != "main" ]; then
    echo -e "${RED}❌ Debes estar en la rama main para hacer release${NC}"
    exit 1
fi

# 2. Verificar que no hay cambios sin commitear
if ! git diff-index --quiet HEAD --; then
    echo -e "${RED}❌ Hay cambios sin commitear. Por favor commitea o stashea los cambios primero.${NC}"
    exit 1
fi

# 3. Obtener versión actual
CURRENT_VERSION=$(node -p "require('./app.json').expo.version")
echo -e "${GREEN}Versión actual: $CURRENT_VERSION${NC}"

# 4. Solicitar nueva versión
echo -e "${YELLOW}📝 Ingresa la nueva versión (formato: X.Y.Z):${NC}"
read VERSION

# Validar formato de versión
if ! [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo -e "${RED}❌ Formato de versión inválido. Usa X.Y.Z (ej: 1.0.1)${NC}"
    exit 1
fi

# 5. Actualizar versionCode
CURRENT_VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))

# 6. Actualizar app.json
node -e "
const fs = require('fs');
const appJson = require('./app.json');
appJson.expo.version = '$VERSION';
appJson.expo.android.versionCode = $NEW_VERSION_CODE;
fs.writeFileSync('./app.json', JSON.stringify(appJson, null, 2));
"

echo -e "${GREEN}✅ Versión actualizada a $VERSION (versionCode: $NEW_VERSION_CODE)${NC}"

# 7. Solicitar mensaje de release
echo -e "${YELLOW}📝 Ingresa una descripción breve de los cambios:${NC}"
read RELEASE_MESSAGE

# 8. Commit cambios
git add app.json
git commit -m "Release v$VERSION: $RELEASE_MESSAGE"
git tag "v$VERSION"

# 9. Verificar credenciales de Google Play
if [ ! -f "./google-play-service-account.json" ]; then
    echo -e "${RED}❌ No se encontró google-play-service-account.json${NC}"
    echo -e "${YELLOW}Por favor, descarga el archivo de credenciales de Google Play Console y guárdalo como google-play-service-account.json${NC}"
    exit 1
fi

# 10. Confirmar build
echo -e "${YELLOW}¿Deseas continuar con el build y publicación? (s/n)${NC}"
read CONFIRM

if [ "$CONFIRM" != "s" ]; then
    echo -e "${RED}❌ Release cancelado${NC}"
    # Revertir cambios
    git reset --hard HEAD~1
    git tag -d "v$VERSION"
    exit 1
fi

# 11. Build y submit
echo -e "${YELLOW}🏗️  Iniciando build y submit a Play Store...${NC}"
eas build --platform android --profile production --auto-submit --non-interactive --message "v$VERSION: $RELEASE_MESSAGE"

# 12. Push cambios si el build fue exitoso
if [ $? -eq 0 ]; then
    echo -e "${YELLOW}📤 Subiendo cambios a repositorio...${NC}"
    git push origin main --tags
    echo -e "${GREEN}✅ Release v$VERSION completado exitosamente!${NC}"
    echo -e "${GREEN}📱 Tu app será revisada y publicada en el track 'internal' de Play Store${NC}"
else
    echo -e "${RED}❌ Error en el build. Los cambios locales no se han subido.${NC}"
    echo -e "${YELLOW}Para revertir los cambios locales, ejecuta:${NC}"
    echo "git reset --hard HEAD~1 && git tag -d v$VERSION"
fi

================
File: app/scripts/verify-android-setup.sh
================
#!/bin/bash

# Verify Android development environment setup

echo "=== Android Development Environment Verification ==="
echo

# Check Java
echo "1. Java Installation:"
if command -v java &> /dev/null; then
    java -version
    echo "✓ Java is installed"
else
    echo "✗ Java is not installed or not in PATH"
fi
echo

# Check JAVA_HOME
echo "2. JAVA_HOME Environment Variable:"
if [ -n "$JAVA_HOME" ]; then
    echo "JAVA_HOME is set to: $JAVA_HOME"
    if [ -d "$JAVA_HOME" ]; then
        echo "✓ JAVA_HOME directory exists"
    else
        echo "✗ JAVA_HOME directory does not exist"
    fi
else
    echo "✗ JAVA_HOME is not set"
fi
echo

# Check Android SDK (if exists)
echo "3. Android SDK:"
if [ -n "$ANDROID_HOME" ] || [ -n "$ANDROID_SDK_ROOT" ]; then
    if [ -n "$ANDROID_HOME" ]; then
        echo "ANDROID_HOME is set to: $ANDROID_HOME"
    fi
    if [ -n "$ANDROID_SDK_ROOT" ]; then
        echo "ANDROID_SDK_ROOT is set to: $ANDROID_SDK_ROOT"
    fi
    echo "✓ Android SDK environment variables are set"
else
    echo "✗ Android SDK environment variables not set (this is OK if using EAS Build)"
fi
echo

# Check Node.js
echo "4. Node.js:"
if command -v node &> /dev/null; then
    echo "Node version: $(node --version)"
    echo "✓ Node.js is installed"
else
    echo "✗ Node.js is not installed"
fi
echo

# Check npm
echo "5. npm:"
if command -v npm &> /dev/null; then
    echo "npm version: $(npm --version)"
    echo "✓ npm is installed"
else
    echo "✗ npm is not installed"
fi
echo

# Check EAS CLI
echo "6. EAS CLI:"
if command -v eas &> /dev/null; then
    echo "EAS CLI version: $(eas --version)"
    echo "✓ EAS CLI is installed"
else
    echo "✗ EAS CLI is not installed"
    echo "  Install with: npm install -g eas-cli"
fi
echo

# Check Expo CLI
echo "7. Expo CLI:"
if npx expo --version &> /dev/null 2>&1; then
    echo "Expo CLI version: $(npx expo --version)"
    echo "✓ Expo CLI is available"
else
    echo "✗ Expo CLI is not available"
fi
echo

echo "=== Summary ==="
echo "Run the following commands to complete setup:"
echo "1. ./scripts/install-java.sh          # Install Java JDK 17"
echo "2. source ~/.bashrc                  # Reload environment variables"
echo "3. ./scripts/fix-expo-packages.sh     # Fix Expo package versions"
echo "4. npm install -g eas-cli            # Install EAS CLI if needed"

================
File: app/src/app/components/common/CustomImagePicker.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  Alert,
  TouchableOpacity,
  StyleProp,
  ViewStyle,
} from 'react-native';
import {
  ActivityIndicator,
  Avatar,
  IconButton,
  Surface,
  Text,
  useTheme,
} from 'react-native-paper';
import * as ImagePicker from 'expo-image-picker';
import { Image } from 'expo-image';
import { AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';

export interface FileObject {
  uri: string;
  name: string;
  type: string;
}

interface CustomImagePickerProps {
  value?: string | null;
  onImageSelected?: (imageUri: string, file: FileObject) => void;
  onImageRemoved?: () => void;
  style?: StyleProp<ViewStyle>;
  size?: number;
  placeholderIcon?: string;
  placeholderText?: string;
  isLoading?: boolean;
  disabled?: boolean;
}

export const CustomImagePicker: React.FC<CustomImagePickerProps> = ({
  value,
  onImageSelected,
  onImageRemoved,
  style,
  size = 150,
  placeholderIcon = 'camera-plus-outline',
  placeholderText = 'Añadir imagen',
  isLoading = false,
  disabled = false,
}) => {
  const theme = useTheme<AppTheme>();
  const responsive = useResponsive();
  const [imageUri, setImageUri] = useState<string | null | undefined>(value);
  const [hasPermission, setHasPermission] = useState<boolean | null>(null);
  const [imageLoadError, setImageLoadError] = useState(false);

  useEffect(() => {
    let isMounted = true;

    (async () => {
      try {
        const { status } = await ImagePicker.getMediaLibraryPermissionsAsync();
        if (isMounted) {
          setHasPermission(status === 'granted');
        }
      } catch {
        if (isMounted) {
          setHasPermission(false);
        }
      }
    })();

    return () => {
      isMounted = false;
    };
  }, []);

  useEffect(() => {
    setImageUri(value);
    setImageLoadError(false);
  }, [value]);

  const requestPermission = async (): Promise<boolean> => {
    if (hasPermission) return true;
    try {
      const { status } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status === 'granted') {
        setHasPermission(true);
        return true;
      } else {
        Alert.alert(
          'Permiso requerido',
          'Se necesita acceso a la galería para seleccionar imágenes.',
        );
        setHasPermission(false);
        return false;
      }
    } catch (e) {
      Alert.alert(
        'Error',
        'No se pudieron solicitar los permisos de la galería.',
      );
      setHasPermission(false);
      return false;
    }
  };

  const handlePickImage = async () => {
    if (isLoading || disabled) return;

    const permissionGranted = await requestPermission();
    if (!permissionGranted) return;

    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: 'images',
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.8,
      });

      if (!result.canceled && result.assets && result.assets.length > 0) {
        const selectedAsset = result.assets[0];
        const selectedUri = selectedAsset.uri;
        const fileName = selectedUri.split('/').pop() || 'image.jpg';
        const fileType =
          selectedAsset.mimeType ||
          (fileName.toLowerCase().endsWith('.png')
            ? 'image/png'
            : 'image/jpeg');

        const fileObject: FileObject = {
          uri: selectedUri,
          name: fileName,
          type: fileType,
        };
        setImageUri(selectedUri);
        onImageSelected?.(selectedUri, fileObject);
      }
    } catch (error) {
      Alert.alert(
        'Error',
        `No se pudo abrir la galería: ${error instanceof Error ? error.message : 'Inténtalo de nuevo.'}`,
      );
    }
  };

  const handleRemoveImage = () => {
    if (isLoading || disabled) return;
    setImageUri(null);
    onImageRemoved?.();
  };

  // Calcular tamaño responsive
  const responsiveSize = responsive.getResponsiveDimension(size, size * 1.2);

  const styles = StyleSheet.create({
    container: {
      width: responsiveSize,
      height: responsiveSize,
      borderRadius: theme.roundness * 1.5,
      justifyContent: 'center',
      alignItems: 'center',
      overflow: 'hidden',
      position: 'relative',
      backgroundColor: theme.colors.surfaceVariant,
    },
    touchable: {
      width: '100%',
      height: '100%',
      justifyContent: 'center',
      alignItems: 'center',
    },
    image: {
      width: '100%',
      height: '100%',
    },
    placeholderContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing.s,
    },
    placeholderText: {
      marginTop: responsive.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      fontSize: responsive.fontSize.s,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0,0,0,0.4)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 1.5,
    },
    removeButton: {
      position: 'absolute',
      top: responsive.spacing.xs,
      right: responsive.spacing.xs,
      backgroundColor: 'rgba(0, 0, 0, 0.6)',
    },
  });

  return (
    <Surface style={[styles.container, style]} elevation={1}>
      <TouchableOpacity
        style={styles.touchable}
        onPress={handlePickImage}
        disabled={isLoading || disabled}
      >
        {imageUri && !imageLoadError ? (
          <Image
            source={{ uri: imageUri }}
            style={styles.image}
            contentFit="cover"
            onError={() => setImageLoadError(true)}
          />
        ) : (
          <View style={styles.placeholderContainer}>
            <Avatar.Icon
              size={responsiveSize * 0.4}
              icon={placeholderIcon}
              style={{ backgroundColor: 'transparent' }}
              color={theme.colors.onSurfaceVariant}
            />
            <Text style={styles.placeholderText} variant="bodySmall">
              {placeholderText}
            </Text>
          </View>
        )}

        {isLoading && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
          </View>
        )}

        {imageUri && !imageLoadError && !isLoading && !disabled && (
          <IconButton
            icon="close-circle"
            size={responsive.dimensions.iconSize.medium}
            iconColor={theme.colors.onErrorContainer}
            style={styles.removeButton}
            onPress={handleRemoveImage}
            rippleColor="rgba(255, 255, 255, 0.32)"
          />
        )}
      </TouchableOpacity>
    </Surface>
  );
};

export default CustomImagePicker;

================
File: app/src/app/components/common/SpeechRecognitionInput.tsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { View, StyleSheet, Animated } from 'react-native';
import { IconButton } from 'react-native-paper';
import {
  ExpoSpeechRecognitionModule,
  useSpeechRecognitionEvent,
} from 'expo-speech-recognition';
import AnimatedLabelInput from './AnimatedLabelInput';
import { useAppTheme } from '../../styles/theme';

// Clase para manejar instancias de reconocimiento de forma aislada
class RecognitionInstance {
  private static instances = new Map<string, RecognitionInstance>();
  private static activeInstanceId: string | null = null;

  private id: string;
  private isActive: boolean = false;
  private onResultCallback: ((text: string) => void) | null = null;
  private onErrorCallback: ((error: string) => void) | null = null;
  private onStartCallback: (() => void) | null = null;
  private onEndCallback: (() => void) | null = null;

  constructor(id: string) {
    this.id = id;
    RecognitionInstance.instances.set(id, this);
  }

  static getInstance(id: string): RecognitionInstance {
    if (!RecognitionInstance.instances.has(id)) {
      new RecognitionInstance(id);
    }
    return RecognitionInstance.instances.get(id)!;
  }

  static removeInstance(id: string) {
    const instance = RecognitionInstance.instances.get(id);
    if (instance && instance.isActive) {
      instance.stop();
    }
    RecognitionInstance.instances.delete(id);
  }

  static getActiveInstance(): RecognitionInstance | null {
    if (RecognitionInstance.activeInstanceId) {
      return (
        RecognitionInstance.instances.get(
          RecognitionInstance.activeInstanceId,
        ) || null
      );
    }
    return null;
  }

  setCallbacks(callbacks: {
    onResult?: (text: string) => void;
    onError?: (error: string) => void;
    onStart?: () => void;
    onEnd?: () => void;
  }) {
    this.onResultCallback = callbacks.onResult || null;
    this.onErrorCallback = callbacks.onError || null;
    this.onStartCallback = callbacks.onStart || null;
    this.onEndCallback = callbacks.onEnd || null;
  }

  async start(lang: string) {
    // Si hay otra instancia activa, detenerla primero
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance && activeInstance.id !== this.id) {
      await activeInstance.stop();
    }

    try {
      const permissions =
        await ExpoSpeechRecognitionModule.requestPermissionsAsync();
      if (!permissions.granted) {
        this.onErrorCallback?.('Permiso de micrófono denegado');
        return;
      }

      RecognitionInstance.activeInstanceId = this.id;
      this.isActive = true;

      await ExpoSpeechRecognitionModule.start({
        lang,
        interimResults: false,
        continuous: false,
      });

      this.onStartCallback?.();
    } catch (error: any) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onErrorCallback?.(
        error.message || 'Error al iniciar reconocimiento',
      );
    }
  }

  async stop() {
    if (this.isActive) {
      try {
        await ExpoSpeechRecognitionModule.stop();
      } catch (error) {
        // Ignorar errores al detener
      } finally {
        this.isActive = false;
        if (RecognitionInstance.activeInstanceId === this.id) {
          RecognitionInstance.activeInstanceId = null;
        }
        this.onEndCallback?.();
      }
    }
  }

  handleResult(transcript: string) {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.onResultCallback?.(transcript);
    }
  }

  handleError(error: string) {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onErrorCallback?.(error);
    }
  }

  handleEnd() {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onEndCallback?.();
    }
  }
}

interface SpeechRecognitionInputProps
  extends Omit<
    React.ComponentProps<typeof AnimatedLabelInput>,
    'value' | 'onChangeText'
  > {
  value: string;
  onChangeText: (text: string) => void;
  label: string;
  speechLang?: string;
  clearOnStart?: boolean;
  replaceContent?: boolean;
  onError?: (error: string) => void;
}

const SpeechRecognitionInput: React.FC<SpeechRecognitionInputProps> = ({
  value,
  onChangeText,
  label,
  speechLang = 'es-MX',
  clearOnStart = false,
  replaceContent = true,
  onError,
  error,
  errorColor,
  activeBorderColor,
  containerStyle,
  inputStyle,
  labelStyle,
  style,
  ...rest
}) => {
  const theme = useAppTheme();
  const [isRecognizingSpeech, setIsRecognizingSpeech] = useState(false);
  const [localValue, setLocalValue] = useState(value);
  const instanceId = useRef(
    `speech-${Date.now()}-${Math.floor(Math.random() * 10000)}`,
  ).current;
  const recognitionInstance = useRef<RecognitionInstance | null>(null);
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const lastProcessedValue = useRef(value);
  const isUpdatingFromSpeech = useRef(false);

  // Sincronizar valor externo con valor local solo cuando cambia externamente
  useEffect(() => {
    if (!isUpdatingFromSpeech.current && value !== lastProcessedValue.current) {
      setLocalValue(value);
      lastProcessedValue.current = value;
    }
  }, [value]);

  // Configurar la instancia de reconocimiento
  useEffect(() => {
    recognitionInstance.current = RecognitionInstance.getInstance(instanceId);

    recognitionInstance.current.setCallbacks({
      onStart: () => {
        setIsRecognizingSpeech(true);
        if (clearOnStart) {
          setLocalValue('');
          lastProcessedValue.current = '';
          onChangeText('');
        }
      },
      onEnd: () => {
        setIsRecognizingSpeech(false);
      },
      onResult: (transcript: string) => {
        let newValue: string;

        if (replaceContent) {
          if (rest.keyboardType === 'phone-pad') {
            newValue = transcript.replace(/\D/g, '');
          } else {
            newValue = transcript;
          }
        } else {
          // Usar el valor local más actualizado
          newValue = localValue ? localValue + ' ' + transcript : transcript;
        }

        isUpdatingFromSpeech.current = true;
        setLocalValue(newValue);
        lastProcessedValue.current = newValue;
        onChangeText(newValue);

        // Resetear flag después de un breve delay
        setTimeout(() => {
          isUpdatingFromSpeech.current = false;
        }, 100);
      },
      onError: (errorMsg: string) => {
        setIsRecognizingSpeech(false);
        onError?.(errorMsg);
      },
    });

    return () => {
      RecognitionInstance.removeInstance(instanceId);
    };
  }, [
    instanceId,
    clearOnStart,
    onChangeText,
    replaceContent,
    rest.keyboardType,
    onError,
    localValue,
  ]);

  // Animación del botón
  useEffect(() => {
    Animated.spring(scaleAnim, {
      toValue: isRecognizingSpeech ? 1.2 : 1,
      friction: 3,
      useNativeDriver: true,
    }).start();
  }, [isRecognizingSpeech, scaleAnim]);

  // Event listeners globales - solo procesan si la instancia activa coincide
  useSpeechRecognitionEvent('start', () => {
    // El evento start ya se maneja en el método start() de RecognitionInstance
  });

  useSpeechRecognitionEvent('end', () => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId) {
      activeInstance.handleEnd();
    }
  });

  useSpeechRecognitionEvent('result', (event) => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId && event.results?.[0]) {
      activeInstance.handleResult(event.results[0].transcript);
    }
  });

  useSpeechRecognitionEvent('error', (event) => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId) {
      activeInstance.handleError(
        event.message || event.error || 'Error desconocido',
      );
    }
  });

  const toggleRecognition = async () => {
    if (!recognitionInstance.current) return;

    if (isRecognizingSpeech) {
      await recognitionInstance.current.stop();
    } else {
      await recognitionInstance.current.start(speechLang);
    }
  };

  const micIconColor = isRecognizingSpeech
    ? theme.colors.error
    : theme.colors.primary;

  // Manejar cambios de texto desde el teclado
  const handleTextChange = useCallback(
    (text: string) => {
      // Actualizar estado local inmediatamente
      setLocalValue(text);
      lastProcessedValue.current = text;

      // Notificar al padre
      onChangeText(text);
    },
    [onChangeText],
  );

  return (
    <View style={styles.wrapper}>
      <AnimatedLabelInput
        label={label}
        value={localValue}
        onChangeText={handleTextChange}
        error={error}
        errorColor={errorColor}
        activeBorderColor={activeBorderColor}
        containerStyle={[containerStyle, { flex: 1 }]}
        inputStyle={inputStyle}
        labelStyle={labelStyle}
        style={style}
        {...rest}
      />
      <Animated.View style={{ transform: [{ scale: scaleAnim }] }}>
        <IconButton
          key={isRecognizingSpeech ? 'mic-active' : 'mic-inactive'}
          icon={isRecognizingSpeech ? 'microphone-off' : 'microphone'}
          size={24}
          iconColor={micIconColor}
          onPress={toggleRecognition}
          style={styles.iconButton}
        />
      </Animated.View>
    </View>
  );
};

const styles = StyleSheet.create({
  wrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconButton: {
    marginLeft: 8,
    marginVertical: 0,
    padding: 0,
  },
});

export default SpeechRecognitionInput;

================
File: app/src/app/components/responsive/index.ts
================
// Exportar todos los componentes responsive desde un único punto
export {
  ResponsiveView,
  ResponsiveRow,
  ResponsiveColumn,
} from './ResponsiveView';
export { ResponsiveGrid, ResponsiveFlexGrid, GridItem } from './ResponsiveGrid';
export {
  ResponsiveImage,
  ResponsiveAvatar,
  ResponsiveThumbnail,
} from './ResponsiveImage';
export { ResponsiveModal, ResponsiveConfirmModal } from './ResponsiveModal';

// Re-exportar tipos si es necesario
// export type { ResponsiveViewProps } from './ResponsiveView';
// export type { ResponsiveGridProps } from './ResponsiveGrid';
// export type { ResponsiveImageProps } from './ResponsiveImage';
// export type { ResponsiveModalProps } from './ResponsiveModal';

================
File: app/src/app/components/responsive/ResponsiveView.tsx
================
import React, { ReactNode, useMemo } from 'react';
import {
  View,
  ViewStyle,
  StyleProp,
  ViewProps,
  DimensionValue,
} from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ResponsiveViewProps extends ViewProps {
  children?: ReactNode;
  style?: StyleProp<ViewStyle>;

  // Estilos responsivos por breakpoint
  xsStyle?: ViewStyle;
  smStyle?: ViewStyle;
  mdStyle?: ViewStyle;
  lgStyle?: ViewStyle;
  xlStyle?: ViewStyle;
  xxlStyle?: ViewStyle;

  // Estilos por tipo de dispositivo
  mobileStyle?: ViewStyle;
  tabletStyle?: ViewStyle;

  // Estilos por orientación
  portraitStyle?: ViewStyle;
  landscapeStyle?: ViewStyle;

  // Props de layout responsive
  direction?: 'row' | 'column' | 'row-reverse' | 'column-reverse';
  directionTablet?: 'row' | 'column' | 'row-reverse' | 'column-reverse';

  // Padding responsive
  padding?: number | 'auto';
  paddingHorizontal?: number | 'auto';
  paddingVertical?: number | 'auto';

  // Margin responsive
  margin?: number | 'auto';
  marginHorizontal?: number | 'auto';
  marginVertical?: number | 'auto';

  // Gap responsive (para flex)
  gap?: number | 'auto';
  gapTablet?: number;

  // Alignment responsive
  align?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  alignTablet?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justify?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';
  justifyTablet?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';

  // Flex responsive
  flex?: number;
  flexTablet?: number;
  wrap?: boolean;
  wrapTablet?: boolean;

  // Dimensiones responsive
  width?: number | string | 'auto';
  widthTablet?: number | string | 'auto';
  height?: number | string | 'auto';
  heightTablet?: number | string | 'auto';

  // Max/Min dimensiones
  maxWidth?: number | string;
  maxWidthTablet?: number | string;
  maxHeight?: number | string;
  maxHeightTablet?: number | string;
  minWidth?: number | string;
  minWidthTablet?: number | string;
  minHeight?: number | string;
  minHeightTablet?: number | string;

  // Mostrar/Ocultar según dispositivo
  hideOnMobile?: boolean;
  hideOnTablet?: boolean;
  hideOnPortrait?: boolean;
  hideOnLandscape?: boolean;
}

export const ResponsiveView: React.FC<ResponsiveViewProps> = ({
  children,
  style,

  // Estilos por breakpoint
  xsStyle,
  smStyle,
  mdStyle,
  lgStyle,
  xlStyle,
  xxlStyle,

  // Estilos por dispositivo
  mobileStyle,
  tabletStyle,

  // Estilos por orientación
  portraitStyle,
  landscapeStyle,

  // Props de layout
  direction = 'column',
  directionTablet,

  // Padding
  padding,
  paddingHorizontal,
  paddingVertical,

  // Margin
  margin,
  marginHorizontal,
  marginVertical,

  // Gap
  gap,
  gapTablet,

  // Alignment
  align,
  alignTablet,
  justify,
  justifyTablet,

  // Flex
  flex,
  flexTablet,
  wrap = false,
  wrapTablet,

  // Dimensiones
  width,
  widthTablet,
  height,
  heightTablet,

  // Max/Min
  maxWidth,
  maxWidthTablet,
  maxHeight,
  maxHeightTablet,
  minWidth,
  minWidthTablet,
  minHeight,
  minHeightTablet,

  // Visibility
  hideOnMobile = false,
  hideOnTablet = false,
  hideOnPortrait = false,
  hideOnLandscape = false,

  ...restProps
}) => {
  const responsive = useResponsive();

  // Calcular estilos responsivos
  const responsiveStyles = useMemo(() => {
    // Ocultar según condiciones
    if (
      (hideOnMobile && responsive.isMobile) ||
      (hideOnTablet && responsive.isTablet) ||
      (hideOnPortrait && responsive.isPortrait) ||
      (hideOnLandscape && responsive.isLandscape)
    ) {
      return { display: 'none' } as ViewStyle;
    }

    // Base styles
    const baseStyle: ViewStyle = {
      // Dirección
      flexDirection:
        responsive.isTablet && directionTablet ? directionTablet : direction,

      // Flex
      flex: responsive.isTablet && flexTablet !== undefined ? flexTablet : flex,
      flexWrap:
        responsive.isTablet && wrapTablet !== undefined
          ? wrapTablet
            ? 'wrap'
            : 'nowrap'
          : wrap
            ? 'wrap'
            : 'nowrap',

      // Alignment
      alignItems: responsive.isTablet && alignTablet ? alignTablet : align,
      justifyContent:
        responsive.isTablet && justifyTablet ? justifyTablet : justify,

      // Dimensiones
      width: (responsive.isTablet && widthTablet !== undefined
        ? widthTablet
        : width) as any,
      height: (responsive.isTablet && heightTablet !== undefined
        ? heightTablet
        : height) as DimensionValue,

      // Max/Min
      maxWidth: (responsive.isTablet && maxWidthTablet !== undefined
        ? maxWidthTablet
        : maxWidth) as DimensionValue,
      maxHeight: (responsive.isTablet && maxHeightTablet !== undefined
        ? maxHeightTablet
        : maxHeight) as DimensionValue,
      minWidth: (responsive.isTablet && minWidthTablet !== undefined
        ? minWidthTablet
        : minWidth) as DimensionValue,
      minHeight: (responsive.isTablet && minHeightTablet !== undefined
        ? minHeightTablet
        : minHeight) as DimensionValue,
    };

    // Padding responsive
    if (padding !== undefined) {
      const paddingValue =
        padding === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(padding);
      baseStyle.padding = paddingValue;
    }
    if (paddingHorizontal !== undefined) {
      const paddingValue =
        paddingHorizontal === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(paddingHorizontal);
      baseStyle.paddingHorizontal = paddingValue;
    }
    if (paddingVertical !== undefined) {
      const paddingValue =
        paddingVertical === 'auto'
          ? responsive.spacing.m
          : responsive.scaleHeight(paddingVertical);
      baseStyle.paddingVertical = paddingValue;
    }

    // Margin responsive
    if (margin !== undefined) {
      const marginValue =
        margin === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(margin);
      baseStyle.margin = marginValue;
    }
    if (marginHorizontal !== undefined) {
      const marginValue =
        marginHorizontal === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(marginHorizontal);
      baseStyle.marginHorizontal = marginValue;
    }
    if (marginVertical !== undefined) {
      const marginValue =
        marginVertical === 'auto'
          ? responsive.spacing.m
          : responsive.scaleHeight(marginVertical);
      baseStyle.marginVertical = marginValue;
    }

    // Gap responsive
    if (gap !== undefined || gapTablet !== undefined) {
      const gapValue =
        responsive.isTablet && gapTablet !== undefined
          ? gapTablet
          : gap === 'auto'
            ? responsive.spacing.m
            : gap;
      baseStyle.gap = responsive.scaleWidth(gapValue as number);
    }

    // Aplicar estilos por breakpoint
    const breakpointStyle = responsive.applyResponsiveStyle({
      xs: xsStyle,
      sm: smStyle,
      md: mdStyle,
      lg: lgStyle,
      xl: xlStyle,
      xxl: xxlStyle,
    });

    // Aplicar estilos por dispositivo
    const deviceStyle = responsive.isTablet ? tabletStyle : mobileStyle;

    // Aplicar estilos por orientación
    const orientationStyle = responsive.isPortrait
      ? portraitStyle
      : landscapeStyle;

    // Combinar todos los estilos
    return [
      baseStyle,
      breakpointStyle,
      deviceStyle,
      orientationStyle,
      style,
    ].filter(Boolean);
  }, [
    responsive,
    style,
    xsStyle,
    smStyle,
    mdStyle,
    lgStyle,
    xlStyle,
    xxlStyle,
    mobileStyle,
    tabletStyle,
    portraitStyle,
    landscapeStyle,
    direction,
    directionTablet,
    padding,
    paddingHorizontal,
    paddingVertical,
    margin,
    marginHorizontal,
    marginVertical,
    gap,
    gapTablet,
    align,
    alignTablet,
    justify,
    justifyTablet,
    flex,
    flexTablet,
    wrap,
    wrapTablet,
    width,
    widthTablet,
    height,
    heightTablet,
    maxWidth,
    maxWidthTablet,
    maxHeight,
    maxHeightTablet,
    minWidth,
    minWidthTablet,
    minHeight,
    minHeightTablet,
    hideOnMobile,
    hideOnTablet,
    hideOnPortrait,
    hideOnLandscape,
  ]);

  return (
    <View style={responsiveStyles} {...restProps}>
      {children}
    </View>
  );
};

// Exportar también un componente Row para facilitar layouts horizontales
export const ResponsiveRow: React.FC<ResponsiveViewProps> = (props) => {
  return <ResponsiveView direction="row" {...props} />;
};

// Exportar un componente Column para mantener consistencia
export const ResponsiveColumn: React.FC<ResponsiveViewProps> = (props) => {
  return <ResponsiveView direction="column" {...props} />;
};

================
File: app/src/app/constants/apiErrorCodes.ts
================
export const ERROR_CODES = {
  AUTH_INVALID_CREDENTIALS: 'AUTH_INVALID_CREDENTIALS',
  AUTH_INCORRECT_PASSWORD: 'AUTH_INCORRECT_PASSWORD',
  AUTH_DUPLICATE_EMAIL: 'AUTH_DUPLICATE_EMAIL',
  AUTH_DUPLICATE_USERNAME: 'AUTH_DUPLICATE_USERNAME',
  AUTH_UNAUTHORIZED: 'AUTH_UNAUTHORIZED',
  AUTH_FORBIDDEN: 'AUTH_FORBIDDEN',
  REFRESH_FAILED: 'REFRESH_FAILED',

  VALIDATION_ERROR: 'VALIDATION_ERROR',

  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',

  CONFLICT_ERROR: 'CONFLICT_ERROR',
  PRODUCT_NAME_EXISTS: 'PRODUCT_NAME_EXISTS',

  NETWORK_ERROR: 'NETWORK_ERROR',
  API_CLIENT_ERROR: 'API_CLIENT_ERROR',
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
  UNKNOWN_API_ERROR: 'UNKNOWN_API_ERROR',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR',

  UPLOAD_FAILED: 'UPLOAD_FAILED',
  FILE_TOO_LARGE: 'FILE_TOO_LARGE',
} as const;

export type ApiErrorCode = (typeof ERROR_CODES)[keyof typeof ERROR_CODES];

================
File: app/src/app/constants/storageKeys.ts
================
/**
 * Constantes para las claves utilizadas en el almacenamiento seguro (EncryptedStorage).
 */
export const STORAGE_KEYS = {
  /** Clave para almacenar las credenciales del usuario (email/username y password) en formato JSON string. */
  REMEMBERED_CREDENTIALS: 'user_credentials',

  /** Clave para almacenar la preferencia del usuario sobre si desea ser recordado ('true' o 'false'). */
  REMEMBER_ME_ENABLED: 'remember_me_preference',

  /** Clave existente para el token de autenticación. */
  AUTH_TOKEN: 'auth_token',
} as const;

================
File: app/src/app/docs/DateTimePickerUsage.md
================
# Uso del DateTimePickerSafe

## Problema Original

El error "Loss of precision during arithmetic conversion" ocurre cuando React Native con Hermes intenta hacer conversiones aritméticas con objetos Date, especialmente al usar librerías como `@react-native-community/datetimepicker` o `react-native-modal-datetime-picker`.

## Solución

Hemos creado dos utilidades para manejar fechas/horas de forma segura:

1. **DateTimePickerSafe**: Un componente selector de fecha/hora que evita conversiones problemáticas
2. **dateTimeHelpers**: Funciones helper para conversiones seguras

## Ejemplo de Uso

### 1. Reemplazar TimePickerModal actual

```tsx
// Antes (problemático)
import DateTimePicker from '@react-native-community/datetimepicker';

// Después (seguro)
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';

// En tu componente:
const [showPicker, setShowPicker] = useState(false);
const [selectedDateTime, setSelectedDateTime] = useState<Date | null>(null);

return (
  <>
    <Button onPress={() => setShowPicker(true)}>
      Seleccionar Fecha/Hora
    </Button>
    
    <DateTimePickerSafe
      visible={showPicker}
      onDismiss={() => setShowPicker(false)}
      onConfirm={(date) => {
        setSelectedDateTime(date);
        setShowPicker(false);
      }}
      mode="datetime" // o "date" o "time"
      initialDate={selectedDateTime || undefined}
      title="Seleccionar hora de entrega"
    />
  </>
);
```

### 2. Usar los helpers seguros

```tsx
import {
  safeTimeStringToDate,
  safeDateToTimeString,
  getNextAvailableTime,
  parseDateFromBackend
} from '@/app/utils/dateTimeHelpers';

// Convertir string de hora a Date
const date = safeTimeStringToDate("14:30"); // Hoy a las 14:30

// Convertir Date a string de hora
const timeStr = safeDateToTimeString(new Date()); // "14:30"

// Obtener próxima hora disponible (redondeada a 5 min)
const nextTime = getNextAvailableTime(30); // 30 min en el futuro

// Parsear fecha del backend de forma segura
const backendDate = parseDateFromBackend(orderData.scheduledAt);
if (backendDate) {
  const timeString = safeDateToTimeString(backendDate);
}
```

### 3. Integración en OrderCartDetail

```tsx
// Para hora programada de pedidos
const handleScheduleTime = () => {
  setShowDateTimePicker(true);
};

const handleConfirmScheduledTime = (date: Date) => {
  const timeString = safeDateToTimeString(date);
  setScheduledTime(timeString);
  setShowDateTimePicker(false);
};

// En el render:
<DateTimePickerSafe
  visible={showDateTimePicker}
  onDismiss={() => setShowDateTimePicker(false)}
  onConfirm={handleConfirmScheduledTime}
  mode="time"
  title="Hora de entrega"
  initialDate={scheduledTime ? safeTimeStringToDate(scheduledTime) : undefined}
/>
```

## Ventajas

1. **Sin pérdida de precisión**: Evita conversiones aritméticas problemáticas
2. **Compatible con Hermes**: Usa operaciones seguras y date-fns
3. **UX mejorada**: Interfaz nativa de selección sin dependencias problemáticas
4. **Validación incluida**: Maneja errores y casos edge automáticamente
5. **Localización**: Soporta español por defecto con date-fns/locale

## Migración

Para migrar del componente actual:

1. Reemplaza `TimePickerModal` por `DateTimePickerSafe` con `mode="time"`
2. Reemplaza `convertTimeStringToDate` por `safeTimeStringToDate`
3. Reemplaza `format(new Date(date), 'HH:mm')` por `safeDateToTimeString(parseDateFromBackend(date))`
4. Usa `getDateTimeForBackend(date)` al enviar fechas al backend

================
File: app/src/app/docs/RESPONSIVE_GUIDE.md
================
# Guía del Sistema Responsive

## Introducción

Este documento describe cómo utilizar el sistema responsive implementado en la aplicación para garantizar una experiencia óptima en diferentes tamaños de pantalla y dispositivos.

## Conceptos Clave

### Breakpoints
```typescript
xs: 0     // Extra pequeño (móviles pequeños)
sm: 360   // Pequeño (móviles estándar)
md: 600   // Mediano (móviles grandes y tablets pequeñas)
lg: 900   // Grande (tablets)
xl: 1200  // Extra grande (tablets grandes)
xxl: 1536 // Doble extra grande (tablets pro)
```

### Hook useResponsive

El hook principal que proporciona toda la información responsive:

```typescript
const responsive = useResponsive();

// Propiedades disponibles:
responsive.window          // Dimensiones de la ventana
responsive.isTablet        // true si es tablet
responsive.spacing         // Espaciado responsive
responsive.fontSize        // Tamaños de fuente responsive
responsive.dimensions      // Dimensiones comunes responsive
responsive.getResponsiveDimension(mobile, tablet) // Dimensión adaptativa
responsive.getGridColumns(minWidth, gap, padding) // Columnas dinámicas
responsive.scaleFont(size) // Escalar fuente según DPI
responsive.scaleSize(size) // Escalar tamaño según DPI
```

## Componentes Responsive

### ResponsiveView
Componente base para layouts responsive:

```tsx
<ResponsiveView
  breakpoints={{
    xs: { padding: 16 },
    md: { padding: 24 },
    lg: { padding: 32 }
  }}
  mobileProps={{ flexDirection: 'column' }}
  tabletProps={{ flexDirection: 'row' }}
>
  {/* Contenido */}
</ResponsiveView>
```

### ResponsiveGrid
Grid con columnas dinámicas:

```tsx
<ResponsiveGrid
  columns={3}
  columnsTablet={4}
  gap={responsive.spacing.m}
  minItemWidth={150}
>
  {/* Items del grid */}
</ResponsiveGrid>
```

### ResponsiveImage
Imágenes con escalado automático:

```tsx
<ResponsiveImage
  source={require('./image.png')}
  baseWidth={200}
  baseHeight={150}
  maxScale={1.5}
/>
```

### ResponsiveModal
Modales con tamaño adaptativo:

```tsx
<ResponsiveModal
  visible={visible}
  onDismiss={onDismiss}
  size="medium" // small, medium, large, fullscreen
>
  {/* Contenido del modal */}
</ResponsiveModal>
```

## Mejores Prácticas

### 1. Siempre usa valores responsive

❌ **Evitar:**
```tsx
style={{ padding: 16, fontSize: 14 }}
```

✅ **Preferir:**
```tsx
style={{ 
  padding: responsive.spacing.m,
  fontSize: responsive.fontSize.m 
}}
```

### 2. Diseña mobile-first

Comienza con el diseño móvil y añade mejoras para tablets:

```tsx
const styles = StyleSheet.create({
  container: {
    // Base móvil
    flexDirection: 'column',
    padding: responsive.spacing.m,
    
    // Mejoras para tablet
    ...(responsive.isTablet && {
      flexDirection: 'row',
      padding: responsive.spacing.xl,
    }),
  },
});
```

### 3. Usa grids dinámicos

Para listas de items, usa ResponsiveGrid o calcula columnas dinámicamente:

```tsx
const numColumns = useMemo(() => {
  return responsive.getGridColumns(150, responsive.spacing.m, responsive.spacing.m);
}, [responsive]);

<FlatList
  numColumns={numColumns}
  key={numColumns} // Importante para re-render
  // ...
/>
```

### 4. Considera la orientación

Para pantallas específicas como cocina:

```tsx
useEffect(() => {
  // Forzar orientación horizontal
  ScreenOrientation.lockAsync(ScreenOrientation.OrientationLock.LANDSCAPE);
  
  return () => {
    ScreenOrientation.unlockAsync();
  };
}, []);
```

### 5. Optimiza imágenes

Usa dimensiones responsive para imágenes:

```tsx
<AutoImage
  source={imageUrl}
  maxWidth={responsive.getResponsiveDimension(300, 500)}
  maxHeight={responsive.getResponsiveDimension(200, 350)}
/>
```

### 6. Tipografía responsive

Usa la escala de fuentes predefinida:

```tsx
responsive.fontSize.xs  // 10
responsive.fontSize.s   // 12
responsive.fontSize.m   // 14
responsive.fontSize.l   // 16
responsive.fontSize.xl  // 20
responsive.fontSize.xxl // 24
responsive.fontSize.xxxl // 32
```

### 7. Espaciado consistente

Usa la escala de espaciado:

```tsx
responsive.spacing.xs  // 4
responsive.spacing.s   // 8
responsive.spacing.m   // 16
responsive.spacing.l   // 24
responsive.spacing.xl  // 32
responsive.spacing.xxl // 48
```

## Patrones Comunes

### Layout Lado a Lado en Tablets

```tsx
if (responsive.isTablet && responsive.window.width > responsive.window.height) {
  return (
    <View style={{ flexDirection: 'row' }}>
      <View style={{ flex: 1 }}>{/* Panel izquierdo */}</View>
      <View style={{ flex: 1 }}>{/* Panel derecho */}</View>
    </View>
  );
}
```

### Modal Adaptativo

```tsx
const modalWidth = responsive.isTablet 
  ? Math.min(600, responsive.window.width * 0.8)
  : responsive.window.width * 0.9;
```

### Grid con Mínimo de Items

```tsx
const columns = Math.max(2, responsive.getGridColumns(100));
```

## Pruebas Recomendadas

1. **Dispositivos móviles:** 
   - iPhone SE (375x667)
   - iPhone 14 (390x844)
   - Pixel 5 (393x851)

2. **Tablets:**
   - iPad Mini (768x1024)
   - iPad Pro 11" (834x1194)
   - iPad Pro 12.9" (1024x1366)

3. **Orientaciones:**
   - Portrait y Landscape
   - Cambios dinámicos de orientación

4. **Densidades de píxeles:**
   - @1x, @2x, @3x
   - Verificar escalado de fuentes e iconos

================
File: app/src/app/hooks/useCrudScreenLogic.ts
================
import { useState, useCallback } from 'react';
import { useMutation, useQueryClient, QueryKey } from '@tanstack/react-query';
import { Alert } from 'react-native';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';

interface CrudLogicParams {
  entityName: string;
  queryKey: QueryKey;
  deleteMutationFn: (id: string) => Promise<void>;
}

export function useCrudScreenLogic<TItem extends { id: string }>({
  entityName,
  queryKey,
  deleteMutationFn,
}: CrudLogicParams) {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((s) => s.showSnackbar);
  const [isFormModalVisible, setIsFormModalVisible] = useState(false);
  const [isDetailModalVisible, setIsDetailModalVisible] = useState(false);
  const [editingItem, setEditingItem] = useState<TItem | null>(null);
  const [selectedItem, setSelectedItem] = useState<TItem | null>(null);

  const deleteMutation = useMutation({
    mutationFn: deleteMutationFn,
    onSuccess: (_, _deletedId) => {
      queryClient.invalidateQueries({ queryKey });
      showSnackbar({
        message: `${entityName} eliminado con éxito`,
        type: 'success',
      });
      handleCloseModals();
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al eliminar ${entityName}: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });

  const handleOpenCreateModal = useCallback(() => {
    setEditingItem(null);
    setSelectedItem(null);
    setIsFormModalVisible(true);
    setIsDetailModalVisible(false);
  }, []);

  const handleOpenEditModal = useCallback((item: TItem) => {
    setEditingItem(item);
    setSelectedItem(null);
    setIsFormModalVisible(true);
    setIsDetailModalVisible(false);
  }, []);

  const handleOpenDetailModal = useCallback((item: TItem) => {
    setSelectedItem(item);
    setEditingItem(null);
    setIsDetailModalVisible(true);
    setIsFormModalVisible(false);
  }, []);

  const handleCloseModals = useCallback(() => {
    setIsFormModalVisible(false);
    setIsDetailModalVisible(false);
    setEditingItem(null);
    setSelectedItem(null);
  }, []);

  const handleDeleteItem = useCallback(
    (id: string) => {
      Alert.alert(
        `Confirmar Eliminación`,
        `¿Estás seguro de que deseas eliminar este ${entityName.toLowerCase()}?`,
        [
          { text: 'Cancelar', style: 'cancel' },
          {
            text: 'Eliminar',
            style: 'destructive',
            onPress: () => deleteMutation.mutate(id),
          },
        ],
      );
    },
    [deleteMutation, entityName],
  );

  // Alternative deletion methods for use with ConfirmationModal
  const [deleteConfirmationState, setDeleteConfirmationState] = useState<{
    visible: boolean;
    itemId: string | null;
  }>({
    visible: false,
    itemId: null,
  });

  const showDeleteConfirmation = useCallback((id: string) => {
    setDeleteConfirmationState({ visible: true, itemId: id });
  }, []);

  const hideDeleteConfirmation = useCallback(() => {
    setDeleteConfirmationState({ visible: false, itemId: null });
  }, []);

  const confirmDelete = useCallback(() => {
    if (deleteConfirmationState.itemId) {
      deleteMutation.mutate(deleteConfirmationState.itemId);
      hideDeleteConfirmation();
    }
  }, [deleteConfirmationState.itemId, deleteMutation, hideDeleteConfirmation]);

  return {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting: deleteMutation.isPending,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    handleDeleteItem,
    // New properties for ConfirmationModal integration
    deleteConfirmation: {
      visible: deleteConfirmationState.visible,
      title: 'Confirmar Eliminación',
      message: `¿Estás seguro de que deseas eliminar este ${entityName.toLowerCase()}?`,
      onConfirm: confirmDelete,
      onCancel: hideDeleteConfirmation,
      show: showDeleteConfirmation,
    },
  };
}

================
File: app/src/app/hooks/useListState.ts
================
import React, { useMemo } from 'react';
import EmptyState from '../components/common/EmptyState';

interface UseListStateProps {
  isLoading: boolean;
  isError: boolean;
  data: any[] | undefined;
  emptyConfig: {
    title: string;
    message?: string;
    actionLabel?: string;
    onAction?: () => void;
    icon?: string;
  };
  errorConfig?: {
    title?: string;
    message?: string;
    actionLabel?: string;
    onAction?: () => void;
    icon?: string;
  };
}

export const useListState = ({
  isLoading,
  isError,
  data,
  emptyConfig,
  errorConfig,
}: UseListStateProps) => {
  const isEmpty = useMemo(() => {
    return !isLoading && !isError && data && data.length === 0;
  }, [isLoading, isError, data]);

  const ListEmptyComponent = useMemo(() => {
    // Return a function component instead of JSX directly
    return () => {
      if (isLoading) return null;

      if (isError) {
        return React.createElement(EmptyState, {
          icon: errorConfig?.icon || 'alert-circle',
          title: errorConfig?.title || 'Error al cargar los datos',
          message:
            errorConfig?.message ||
            'Ocurrió un error al cargar la información. Por favor, intenta de nuevo.',
          actionLabel: errorConfig?.actionLabel || 'Reintentar',
          onAction: errorConfig?.onAction || emptyConfig.onAction,
        });
      }

      if (isEmpty) {
        return React.createElement(EmptyState, {
          icon: emptyConfig.icon || 'folder-open',
          title: emptyConfig.title,
          message: emptyConfig.message,
          actionLabel: emptyConfig.actionLabel,
          onAction: emptyConfig.onAction,
        });
      }

      return null;
    };
  }, [isLoading, isError, isEmpty, emptyConfig, errorConfig]);

  return {
    isEmpty,
    ListEmptyComponent,
  };
};

================
File: app/src/app/lib/apiHelpers.ts
================
import { ApiResponse } from 'apisauce';
import { ApiError } from './errors';

/**
 * Helper function to handle API responses consistently.
 * If the response is not ok, it extracts the error from the response.
 *
 * @param response - The API response from apisauce
 * @returns The response data if successful
 * @throws ApiError if the response is not ok
 */
export function handleApiResponse<T>(response: ApiResponse<T>): T {
  // Caso especial: si data es un array vacío, es una respuesta válida
  if (
    response.ok &&
    Array.isArray(response.data) &&
    response.data.length === 0
  ) {
    return response.data;
  }

  if (!response.ok || !response.data) {
    // Check if the originalError is already an ApiError (from interceptor)
    if (response.originalError && response.originalError instanceof ApiError) {
      throw response.originalError;
    }

    // Otherwise, create a new ApiError from the response
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

/**
 * Helper function to handle API responses that don't return data.
 *
 * @param response - The API response from apisauce
 * @throws ApiError if the response is not ok
 */
export function handleApiResponseVoid(response: ApiResponse<any>): void {
  if (!response.ok) {
    // Check if the originalError is already an ApiError (from interceptor)
    if (response.originalError && response.originalError instanceof ApiError) {
      throw response.originalError;
    }

    // Otherwise, create a new ApiError from the response
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

================
File: app/src/app/lib/errors.ts
================
import { ERROR_CODES, ApiErrorCode } from '../constants/apiErrorCodes';
import { BackendErrorResponse } from '../types/api.types';
import { AxiosError } from 'axios'; // Import AxiosError type

export class ApiError extends Error {
  public readonly code: ApiErrorCode | string;
  public readonly status: number;
  public readonly details?: any;
  public readonly originalMessage: string;

  constructor(
    code: ApiErrorCode | string = ERROR_CODES.UNKNOWN_API_ERROR,
    backendMessage: string = 'Ocurrió un error en la API',
    status: number = 500,
    details?: any,
  ) {
    super(backendMessage);
    this.code = code;
    this.status = status;
    this.details = details;
    this.originalMessage = backendMessage;
    this.name = 'ApiError';
    // Mantener compatibilidad con entornos Node/V8
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ApiError);
    }
  }

  /**
   * Creates an ApiError instance from an apisauce ApiResponse (legacy or direct use).
   * Kept for potential compatibility, but prefer fromAxiosError.
   */
  static fromApiResponse(
    responseData: BackendErrorResponse | any,
    responseStatus?: number,
  ): ApiError {
    const status = responseStatus ?? responseData?.statusCode ?? 500;
    const code = responseData?.code ?? ERROR_CODES.UNKNOWN_API_ERROR;
    const message = responseData?.message ?? 'Error desconocido de la API.';
    const details = responseData?.details;
    // Uses the main constructor signature: code, message, status, details
    return new ApiError(code, message, status, details);
  }

  /**
   * Creates an ApiError instance from an AxiosError.
   * Extracts relevant information from the Axios error response.
   */
  static fromAxiosError(error: any): ApiError {
    if (error instanceof ApiError) {
      // If it's already an ApiError (e.g., from refresh failure), return it directly
      return error;
    }

    // Use type assertion for better property access
    const axiosError = error as AxiosError;
    const responseData = axiosError.response?.data as
      | BackendErrorResponse
      | any;
    const status = axiosError.response?.status ?? 500;

    // Manejar errores de red específicamente
    if (axiosError.code === 'ERR_NETWORK' || !axiosError.response) {
      return new ApiError(
        ERROR_CODES.NETWORK_ERROR,
        'Error de conexión. Verifica tu conexión a internet e intenta nuevamente.',
        0,
        { originalError: axiosError.message },
      );
    }

    // Manejar timeout
    if (
      axiosError.code === 'ECONNABORTED' ||
      axiosError.message.includes('timeout')
    ) {
      return new ApiError(
        ERROR_CODES.NETWORK_ERROR,
        'La solicitud tardó demasiado tiempo. Intenta nuevamente con una conexión más estable.',
        0,
        { originalError: axiosError.message },
      );
    }

    // Extract error code - check multiple possible locations
    const code =
      responseData?.code ||
      responseData?.error?.code ||
      responseData?.errors?.[0]?.code ||
      ERROR_CODES.UNKNOWN_API_ERROR;

    // Extract error message - check multiple possible locations
    const message =
      responseData?.message ||
      responseData?.error?.message ||
      responseData?.errors?.[0]?.message ||
      axiosError.message ||
      'Error desconocido de la API.';

    // Include full response data as details if no specific 'details' property exists
    const details = responseData?.details ?? responseData;

    // Uses the main constructor signature: code, message, status, details
    return new ApiError(code, message, status, details);
  }

  /**
   * Creates a specific ApiError for refresh token failures.
   */
  static fromRefreshError(error: any): ApiError {
    // Note: Logout logic should primarily reside in the refreshToken function itself

    // Uses the main constructor signature: code, message, status, details
    return new ApiError(
      ERROR_CODES.REFRESH_FAILED, // Specific code for refresh failure - Ensure this exists in ERROR_CODES
      error?.message || 'La sesión ha expirado o no se pudo renovar.', // Message
      401, // Status (force 401)
      error, // Details (original error)
    );
  }
} // End of ApiError class definition

================
File: app/src/app/lib/IMAGE_CACHE_GUIDE.md
================
# 🖼️ Sistema de Cache de Imágenes Optimizado

## 📋 Resumen de Optimizaciones Implementadas

### ✅ **Correcciones Críticas**
1. **Eliminación de doble resolución de URLs**
   - Componentes ahora pasan `path` directamente a `AutoImage`
   - `AutoImage` maneja internamente la resolución con `getImageUrl()`
   - Eliminado uso innecesario de `await getImageUrl()` en componentes

2. **Archivos corregidos:**
   - `GenericDetailModal.tsx`: Usa `imageSource` en lugar de `imageUrl`
   - `CategoriesScreen.tsx`: Pasa `photo.path` directamente al formulario
   - `ProductFormModal.tsx`: Pasa `photo.path` directamente al formulario
   - `SubcategoriesScreen.tsx`: Pasa `photo.path` directamente al formulario

### 🔧 **Optimizaciones Implementadas**

#### 1. **Logging Optimizado (Solo Errores)**
```typescript
// Logs reducidos a lo esencial:
- CACHE_MISS_FAILED: Fallo en descarga
- CACHE_CLEANED: Limpieza exitosa (con detalles)
- CACHE_CLEAN_ERROR: Error en limpieza
- CACHE_ITEM_REMOVE_FAILED: Error al remover item
- CACHE_CLEAR_FAILED: Error al limpiar cache
- PREFETCH_FAILED: Fallos en prefetch
```

#### 2. **Retry Logic con Backoff Exponencial**
```typescript
// Configuración:
- MAX_RETRIES: 3 intentos
- BASE_RETRY_DELAY: 1000ms
- Backoff: 1s, 2s, 4s, 8s...
- Límite de cache: 500MB (aumentado desde 100MB)
```

#### 3. **Prefetching Inteligente**
```typescript
// Funciones disponibles:
- prefetchImages(): Prefetch genérico
- prefetchMenuImages(): Específico para menús
- Integración automática en useGetFullMenu()
```

#### 4. **Limpieza de Cache Optimizada**
```typescript
// Estrategia mejorada:
- Fase 1: Eliminación por edad (más eficiente)
- Fase 2: Eliminación por tamaño (LRU)
- Margen del 10% para evitar limpiezas frecuentes
- Logging detallado con métricas
```

### 📊 **Impacto en Rendimiento**

#### **Antes:**
- ❌ Doble resolución de URLs (componente + AutoImage)
- ❌ Sin retry en descargas fallidas
- ❌ Sin prefetch automático
- ❌ Limpieza básica de cache
- ❌ Logs excesivos para cada operación

#### **Después:**
- ✅ Resolución única de URLs (solo AutoImage)
- ✅ Retry automático con backoff exponencial
- ✅ Prefetch automático en background
- ✅ Limpieza inteligente con métricas
- ✅ Logging optimizado (solo errores y operaciones críticas)

### 🎯 **Beneficios Esperados**
- **30-50% reducción** en tiempo de carga de imágenes
- **60-80% reducción** en uso de ancho de banda
- **Mejor experiencia** en menús largos
- **Mayor confiabilidad** en conexiones inestables
- **Performance mejorada** sin logs innecesarios
- **Límite de cache aumentado** a 500MB para casos extremos

### 💡 **Uso Recomendado**

#### Para Desarrolladores:
```typescript
// ✅ Correcto - Usar AutoImage con path
<AutoImage source={item.photo?.path} />

// ❌ Incorrecto - No resolver URL manualmente
const imageUrl = await getImageUrl(item.photo.path);
<AutoImage source={imageUrl} />
```

#### Para Prefetch Manual:
```typescript
// Prefetch específico para menús
await prefetchMenuImages(menuData, {
  maxConcurrent: 3,
  onProgress: (completed, total) => console.log(`${completed}/${total}`)
});
```

### 📝 **Logs de Ejemplo (Solo Errores)**
```
[ImageCache] CACHE_MISS_FAILED: {
  url: "https://api.example.com/image.jpg",
  filename: "abc123.jpg",
  error: "Download failed after all retries"
}

[ImageCache] CACHE_CLEANED: {
  filesDeleted: 45,
  sizeCleaned: "123.45MB",
  totalFilesRemaining: 155,
  totalSizeRemaining: "376.55MB",
  originalSize: "500.00MB",
  spaceFreed: "123.45MB",
  cacheUtilization: "75.3%"
}

[ImageCache] PREFETCH_FAILED: {
  totalImages: 25,
  failed: 2,
  successRate: "92.0%"
}
```

## 🔍 **Monitoreo**

Para monitorear el rendimiento del cache, busca en los logs:
- Fallos en `CACHE_MISS_FAILED` 
- Limpiezas en `CACHE_CLEANED` para verificar uso de espacio
- Tasas de error en `PREFETCH_FAILED`
- Errores de sistema en `CACHE_*_ERROR`

## 🚀 **Activación**

El sistema está **completamente activado** y funcionando automáticamente:
- Cache se inicializa al arrancar la app
- Prefetch se ejecuta automáticamente al cargar menús
- Retry funciona automáticamente en descargas fallidas
- Limpieza se ejecuta automáticamente en segundo plano

================
File: app/src/app/navigation/OrdersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import OrdersScreen from '../../modules/orders/screens/OrdersScreen';
import CreateOrderScreen from '../../modules/orders/screens/CreateOrderScreen';
import OpenOrdersScreen from '../../modules/orders/screens/OpenOrdersScreen';
import AddProductsToOrderScreen from '../../modules/orders/screens/AddProductsToOrderScreen';

import type { OrdersStackParamList } from './types';
import { useAppTheme } from '../styles/theme';
import { getStackHeaderOptions } from './options';

const Stack = createNativeStackNavigator<OrdersStackParamList>();

function OrdersStackNavigator() {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="Orders"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="Orders"
        component={OrdersScreen}
        options={{ title: 'Órdenes' }}
      />
      <Stack.Screen
        name="CreateOrder"
        component={CreateOrderScreen}
        options={{ title: 'Crear Nueva Orden', headerShown: false }}
      />
      <Stack.Screen
        name="OpenOrders"
        component={OpenOrdersScreen}
        options={{ title: 'Órdenes Abiertas' }}
      />
      <Stack.Screen
        name="AddProductsToOrder"
        component={AddProductsToOrderScreen}
        options={{ title: 'Añadir Productos', headerShown: false }}
      />
    </Stack.Navigator>
  );
}

export default OrdersStackNavigator;

================
File: app/src/app/schemas/domain/adjustment.schema.ts
================
import { z } from 'zod';

export const adjustmentSchema = z.object({
  id: z.string(),
  orderId: z.string().nullable().optional(),
  orderItemId: z.string().nullable().optional(),
  name: z.string(),
  isPercentage: z.boolean(),
  value: z.number(), // Porcentaje si isPercentage es true (0-100)
  amount: z.number(), // Monto calculado o fijo
  appliedById: z.string(),
  appliedAt: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  deletedAt: z.string().nullable().optional(),

  // Relaciones opcionales
  order: z.any().optional(),
  orderItem: z.any().optional(),
  appliedBy: z.any().optional(),
});

export type Adjustment = z.infer<typeof adjustmentSchema>;

// Schema base para crear un ajuste (sin validaciones)
const createAdjustmentBaseSchema = z.object({
  orderId: z.string().uuid().optional(),
  orderItemId: z.string().uuid().optional(),
  name: z.string().max(100),
  isPercentage: z.boolean(),
  value: z.number().min(0).max(100).optional(), // Solo requerido si isPercentage es true
  amount: z.number().optional(), // Solo requerido si isPercentage es false
});

// Schema para crear un ajuste con validaciones
export const createAdjustmentSchema = createAdjustmentBaseSchema
  .refine(
    (data) => {
      // Debe tener orderId O orderItemId, pero no ambos
      return (
        (data.orderId && !data.orderItemId) ||
        (!data.orderId && data.orderItemId)
      );
    },
    {
      message:
        'El ajuste debe aplicarse a una orden o a un item de orden, pero no a ambos',
    },
  )
  .refine(
    (data) => {
      // Si es porcentaje, debe tener value. Si no, debe tener amount
      if (data.isPercentage) {
        return data.value !== undefined;
      } else {
        return data.amount !== undefined;
      }
    },
    {
      message:
        "Si es porcentaje debe incluir 'value', si no debe incluir 'amount'",
    },
  );

export type CreateAdjustment = z.infer<typeof createAdjustmentSchema>;

// Schema para actualizar un ajuste (usando el schema base sin validaciones)
export const updateAdjustmentSchema = createAdjustmentBaseSchema.partial();
export type UpdateAdjustment = z.infer<typeof updateAdjustmentSchema>;

================
File: app/src/app/schemas/domain/area.schema.ts
================
import { z } from 'zod';

// Única fuente de verdad para la entidad Area
export const areaSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  createdAt: z.string().datetime().optional(), // O z.date() si se prefiere
  updatedAt: z.string().datetime().optional(), // O z.date() si se prefiere
});

// Tipo TypeScript inferido y exportado centralmente
export type Area = z.infer<typeof areaSchema>;

================
File: app/src/app/schemas/domain/category.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar la estructura de una foto de categoría.
 * Fuente de verdad centralizada.
 */
export const categoryPhotoSchema = z.object({
  id: z.string(), // Asumiendo que el ID puede no ser UUID aquí, ajustar si es necesario
  path: z.string(), // Podría ser z.string().url() si siempre es URL
});

/**
 * Esquema Zod para validar un objeto Category completo.
 * Fuente de verdad centralizada.
 */
export const categorySchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  sortOrder: z.number(),
  photo: categoryPhotoSchema.nullable().optional(),
});

// Tipos TypeScript inferidos y exportados centralmente
export type CategoryPhoto = z.infer<typeof categoryPhotoSchema>;
export type Category = z.infer<typeof categorySchema>;

================
File: app/src/app/schemas/domain/delivery-info.schema.ts
================
import { z } from 'zod';

export const DeliveryInfoSchema = z.object({
  id: z.string().optional(),
  orderId: z.string().optional(),
  fullAddress: z.string().optional(),
  street: z.string().optional(),
  number: z.string().optional(),
  interiorNumber: z.string().optional(),
  neighborhood: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zipCode: z.string().optional(),
  country: z.string().optional(),
  recipientName: z.string().optional(),
  recipientPhone: z.string().optional(),
  deliveryInstructions: z.string().optional(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});

export type DeliveryInfo = z.infer<typeof DeliveryInfoSchema>;

================
File: app/src/app/schemas/domain/modifier-group.schema.ts
================
import { z } from 'zod';
// Importar Modifier si se incluye en el schema de dominio
// import { modifierSchema } from './modifier.schema';

/**
 * Esquema Zod para validar un objeto ModifierGroup completo.
 * Fuente de verdad centralizada.
 */
export const modifierGroupSchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  minSelections: z.number().int().min(0).optional(),
  maxSelections: z.number().int().min(1).optional(),
  isRequired: z.boolean().optional(),
  allowMultipleSelections: z.boolean().optional(),
  isActive: z.boolean().optional(), // Mantener opcional si la API puede no devolverlo siempre
  sortOrder: z.number(),
  // Opcional: Incluir schema de modificadores si es parte del dominio central
  // modifiers: z.array(modifierSchema).optional(),
});

// Tipo TypeScript inferido y exportado centralmente
export type ModifierGroup = z.infer<typeof modifierGroupSchema>;

================
File: app/src/app/schemas/domain/modifier.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto Modifier completo.
 * Fuente de verdad centralizada.
 */
export const modifierSchema = z.object({
  id: z.string(),
  modifierGroupId: z.string().min(1, 'El ID del grupo no es válido'),
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.coerce.number().nullable().optional(),
  sortOrder: z.number().int().default(0),
  isDefault: z.boolean().default(false),
  isActive: z.boolean().default(true),
});

// Tipo TypeScript inferido y exportado centralmente
export type Modifier = z.infer<typeof modifierSchema>;

================
File: app/src/app/schemas/domain/photo.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar la estructura de una foto en el dominio.
 * Fuente de verdad centralizada.
 */
export const photoSchema = z.object({
  id: z.string().uuid(), // ID puede ser custom format
  path: z.string().url(), // Usar url() como en products/subcategories
});

// Tipo TypeScript inferido y exportado centralmente
export type Photo = z.infer<typeof photoSchema>;

================
File: app/src/app/schemas/domain/product-variant.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto ProductVariant completo.
 * Fuente de verdad centralizada.
 */
export const productVariantSchema = z.object({
  id: z.string(), // ID es requerido en el dominio
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce.number({
    // Usar coerce para asegurar que sea número
    invalid_type_error: 'El precio debe ser un número',
    required_error: 'El precio es requerido',
  }), // No necesita ser positivo aquí, puede ser 0
  isActive: z.boolean(),
  sortOrder: z.number(),
});

// Tipo TypeScript inferido y exportado centralmente
export type ProductVariant = z.infer<typeof productVariantSchema>;

// Schema opcional para Input (definido manualmente, sin ID)
export const productVariantInputSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce.number({
    invalid_type_error: 'El precio debe ser un número',
    required_error: 'El precio es requerido',
  }),
  isActive: z.boolean(),
  sortOrder: z.number(),
});
export type ProductVariantInput = z.infer<typeof productVariantInputSchema>;

================
File: app/src/app/schemas/domain/product.schema.ts
================
import { z } from 'zod';
import { photoSchema } from './photo.schema';
import { productVariantSchema } from './product-variant.schema';
import { modifierGroupSchema } from './modifier-group.schema';
import { preparationScreenSchema } from './preparation-screen.schema';

/**
 * Esquema Zod para validar un objeto Product completo.
 * Fuente de verdad centralizada.
 */
export const productSchema = z.object({
  id: z.string(), // ID es requerido en el dominio
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(), // Campo descripción agregado
  price: z
    .number()
    .positive('El precio debe ser positivo')
    .refine((val) => /^\d+(\.\d{1,2})?$/.test(String(val)), {
      message: 'El precio debe tener como máximo dos decimales',
    })
    .optional()
    .nullable(),
  hasVariants: z.boolean(),
  isActive: z.boolean(),
  isPizza: z.boolean(),
  subcategoryId: z.string().min(1, 'La subcategoría es requerida'),
  sortOrder: z.number(),
  photo: photoSchema.optional().nullable(),
  estimatedPrepTime: z
    .number()
    .min(1, 'El tiempo debe ser al menos 1 minuto')
    .optional(),
  preparationScreenId: z.string().optional().nullable(),
  preparationScreen: preparationScreenSchema.optional().nullable(),
  variants: z.array(productVariantSchema).optional(),
  modifierGroups: z.array(modifierGroupSchema).optional(),
  pizzaCustomizations: z.array(z.any()).optional(),
  pizzaConfiguration: z.any().optional(),
  createdAt: z.union([z.string().datetime(), z.date()]).optional(),
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(),
});

export type Product = z.infer<typeof productSchema> & {
  pizzaCustomizations?: any[];
  pizzaConfiguration?: any;
};

================
File: app/src/app/schemas/domain/subcategory.schema.ts
================
import { z } from 'zod';
import { photoSchema } from './photo.schema'; // Importar schema de Photo centralizado
// import { productSchema } from './product.schema'; // Opcional: Importar si se incluyen productos

/**
 * Esquema Zod para validar un objeto SubCategory completo.
 * Fuente de verdad centralizada.
 */
export const subCategorySchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  categoryId: z.string().min(1, 'El ID de categoría no es válido'),
  sortOrder: z.number(),
  photo: photoSchema.nullable().optional(), // Usar photoSchema centralizado
  // Opcional: Incluir productos si es relevante en el dominio general
  // products: z.array(productSchema).optional(),
  createdAt: z.union([z.string().datetime(), z.date()]).optional(), // Incluido desde la interfaz original
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(), // Incluido desde la interfaz original
});

// Tipo TypeScript inferido y exportado centralmente
export type SubCategory = z.infer<typeof subCategorySchema>;

================
File: app/src/app/store/snackbarStore.ts
================
import { create } from 'zustand';

export type SnackbarType = 'info' | 'success' | 'error' | 'warning';

export interface SnackbarState {
  visible: boolean;
  message: string;
  type: SnackbarType;
  duration?: number;
  showSnackbar: (params: {
    message: string;
    type?: SnackbarType;
    duration?: number;
  }) => void;
  hideSnackbar: () => void;
}

export const useSnackbarStore = create<SnackbarState>((set) => ({
  visible: false,
  message: '',
  type: 'info',
  duration: 2000,
  showSnackbar: ({ message, type = 'info', duration = 2000 }) =>
    set({ visible: true, message, type, duration }),
  hideSnackbar: () => set({ visible: false }),
}));

================
File: app/src/app/styles/colors.ts
================
export const lightColors = {
  primary: '#1976D2',
  primaryContainer: '#BBDEFB',
  onPrimary: '#FFFFFF',
  onPrimaryContainer: '#004C8B',

  secondary: '#FF9800',
  secondaryContainer: '#FFE0B2',
  onSecondary: '#FFFFFF',
  onSecondaryContainer: '#562800',

  tertiary: '#43A047',
  tertiaryContainer: '#C8E6C9',
  onTertiary: '#FFFFFF',
  onTertiaryContainer: '#002411',

  background: '#F8F9FA',
  onBackground: '#202124',
  surface: '#FFFFFF',
  onSurface: '#202124',
  surfaceVariant: '#E4E6EB',
  onSurfaceVariant: '#44464F',

  error: '#B00020',
  errorContainer: '#FFDAD6',
  onError: '#FFFFFF',
  onErrorContainer: '#410002',

  outline: '#74777F',
  outlineVariant: '#C4C7C5',
  inverseSurface: '#2E3133',
  inverseOnSurface: '#F2F2F2',
  inversePrimary: '#80CBC4',

  success: '#2E7D32',
  successContainer: '#C8E6C9',
  onSuccessContainer: '#0D3912',
  warning: '#F57C00',
  warningContainer: '#FFE0B2',
  onWarningContainer: '#662D00',
  info: '#1976D2',
  infoContainer: '#BBDEFB',
  onInfoContainer: '#00325B',
};

export const darkColors = {
  primary: '#FF7043',
  primaryContainer: '#662E1A',
  onPrimary: '#FFFFFF',
  onPrimaryContainer: '#FFDACF',

  secondary: '#FFB74D',
  secondaryContainer: '#774B1F',
  onSecondary: '#000000',
  onSecondaryContainer: '#FFE0B2',

  tertiary: '#FFD54F',
  tertiaryContainer: '#775B25',
  onTertiary: '#000000',
  onTertiaryContainer: '#FFF3C4',

  background: '#121212',
  onBackground: '#FFFFFF',
  surface: '#1E1E1E',
  onSurface: '#FFFFFF',
  surfaceVariant: '#2C2C2C',
  onSurfaceVariant: '#9E9E9E',

  error: '#FF6B6B',
  errorContainer: '#4D2626',
  onError: '#FFFFFF',
  onErrorContainer: '#FFE5E5',

  outline: '#4F4F4F',
  outlineVariant: '#3D3D3D',
  inverseSurface: '#FFFFFF',
  inverseOnSurface: '#121212',
  inversePrimary: '#FF5722',

  success: '#69F0AE',
  successContainer: '#1B5E20',
  onSuccessContainer: '#B3FFD1',
  warning: '#FFC107',
  warningContainer: '#795548',
  onWarningContainer: '#FFE0B2',
  info: '#64B5F6',
  infoContainer: '#1565C0',
  onInfoContainer: '#B3E5FC',
};

================
File: app/src/app/styles/theme.ts
================
import { MD3LightTheme, MD3DarkTheme, useTheme } from 'react-native-paper';
import type { MD3Typescale } from 'react-native-paper/lib/typescript/types';
import { lightColors, darkColors } from './colors';
import { typography } from './typography';
import { BREAKPOINTS, DEVICE_TYPES, RESPONSIVE_DIMENSIONS } from './responsive';

declare global {
  namespace ReactNativePaper {
    interface MD3Colors {
      success: string;
      successContainer: string;
      onSuccessContainer: string;
      warning: string;
      warningContainer: string;
      onWarningContainer: string;
      info: string;
      infoContainer: string;
      onInfoContainer: string;
    }
  }
}

const spacing = {
  xs: 4,
  s: 8,
  m: 16,
  l: 24,
  xl: 32,
  xxl: 40,
};

// Sistema responsive integrado con el tema
const responsive = {
  breakpoints: BREAKPOINTS,
  deviceTypes: DEVICE_TYPES,
  dimensions: RESPONSIVE_DIMENSIONS,
};

const typescale: MD3Typescale = {
  default: {
    fontFamily: typography.bodyMedium.fontFamily,
    fontWeight: 'normal',
    letterSpacing: typography.bodyMedium.letterSpacing,
  },
  displayLarge: { ...typography.displayLarge, fontWeight: 'normal' },
  displayMedium: { ...typography.displayMedium, fontWeight: 'normal' },
  displaySmall: { ...typography.displaySmall, fontWeight: 'normal' },
  headlineLarge: { ...typography.headlineLarge, fontWeight: 'normal' },
  headlineMedium: { ...typography.headlineMedium, fontWeight: 'normal' },
  headlineSmall: { ...typography.headlineSmall, fontWeight: 'normal' },
  titleLarge: { ...typography.titleLarge, fontWeight: 'normal' },
  titleMedium: { ...typography.titleMedium, fontWeight: '500' },
  titleSmall: { ...typography.titleSmall, fontWeight: '500' },
  bodyLarge: { ...typography.bodyLarge, fontWeight: 'normal' },
  bodyMedium: { ...typography.bodyMedium, fontWeight: 'normal' },
  bodySmall: { ...typography.bodySmall, fontWeight: 'normal' },
  labelLarge: { ...typography.labelLarge, fontWeight: '500' },
  labelMedium: { ...typography.labelMedium, fontWeight: '500' },
  labelSmall: { ...typography.labelSmall, fontWeight: '500' },
};

export const lightTheme = {
  ...MD3LightTheme,
  colors: {
    ...MD3LightTheme.colors,
    ...lightColors,
  },
  fonts: typescale,
  spacing,
  responsive,
  roundness: 8,
};

export const darkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...MD3DarkTheme.colors,
    ...darkColors,
  },
  fonts: typescale,
  spacing,
  responsive,
  roundness: 8,
};

export type AppTheme = typeof lightTheme;

export const useAppTheme = () => {
  try {
    const theme = useTheme();
    // Verificar que el tema sea un objeto válido
    if (!theme || typeof theme !== 'object') {
      return lightTheme;
    }
    return theme as AppTheme;
  } catch (error) {
    return lightTheme;
  }
};

================
File: app/src/app/styles/typography.ts
================
import { Platform } from 'react-native';

export const typography = {
  fonts: {
    regular: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    medium: Platform.select({
      ios: 'SF Pro Text-Medium',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    light: Platform.select({
      ios: 'SF Pro Text-Light',
      android: 'Roboto-Light',
      default: 'System-Light',
    }),
    thin: Platform.select({
      ios: 'SF Pro Text-Thin',
      android: 'Roboto-Thin',
      default: 'System-Thin',
    }),
  },

  displayLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 57,
    lineHeight: 64,
    letterSpacing: -0.25,
  },
  displayMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 45,
    lineHeight: 52,
    letterSpacing: 0,
  },
  displaySmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 36,
    lineHeight: 44,
    letterSpacing: 0,
  },
  headlineLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 32,
    lineHeight: 40,
    letterSpacing: 0,
  },
  headlineMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 28,
    lineHeight: 36,
    letterSpacing: 0,
  },
  headlineSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 24,
    lineHeight: 32,
    letterSpacing: 0,
  },
  titleLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 22,
    lineHeight: 28,
    letterSpacing: 0,
  },
  titleMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.15,
  },
  titleSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  labelSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 11,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  bodyLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.5,
  },
  bodyMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.25,
  },
  bodySmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.4,
  },
};

export const iosFontFamily = {
  regular: 'System',
  medium: 'System',
  light: 'System',
  thin: 'System',
};

export const androidFontFamily = {
  regular: 'sans-serif',
  medium: 'sans-serif-medium',
  light: 'sans-serif-light',
  thin: 'sans-serif-thin',
};

================
File: app/src/app/types/api.types.ts
================
import { z } from 'zod';

export interface BackendErrorResponse {
  statusCode: number;
  code: string;
  message: string;
  details?: any;
  timestamp?: string;
  path?: string;
}

export const baseListQuerySchema = z.object({
  page: z.coerce.number().int().positive().optional().default(1),
  limit: z.coerce.number().int().positive().optional().default(10),
});

export type BaseListQueryDto = {
  page?: number;
  limit?: number;
};

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

================
File: app/src/app/types/query.types.ts
================
import { z } from 'zod';

export const baseListQuerySchema = z.object({
  page: z.number().int().positive().optional().default(1),
  limit: z.number().int().positive().optional().default(10),
  search: z.string().optional(),
});

export type BaseListQuery = z.infer<typeof baseListQuerySchema>;

================
File: app/src/app/utils/dateTimeHelpers.ts
================
import { format, parse, setHours, setMinutes, isValid } from 'date-fns';
import { es } from 'date-fns/locale';

/**
 * Helpers seguros para manejo de fechas/horas en React Native con Hermes
 * Evita conversiones aritméticas que causan pérdida de precisión
 */

/**
 * Convierte un string de hora (HH:mm) a un objeto Date seguro
 * @param timeString - String en formato HH:mm
 * @param baseDate - Fecha base opcional (por defecto hoy)
 * @returns Date con la hora configurada
 */
export const safeTimeStringToDate = (
  timeString: string,
  baseDate?: Date,
): Date => {
  // Validar formato
  if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) {
    throw new Error('Formato de hora inválido. Use HH:mm');
  }

  const [hourStr, minuteStr] = timeString.split(':');
  const hour = parseInt(hourStr, 10);
  const minute = parseInt(minuteStr, 10);

  // Validar rangos
  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
    throw new Error('Hora o minutos fuera de rango');
  }

  // Usar date-fns para operaciones seguras
  let date = baseDate ? new Date(baseDate) : new Date();
  date = setHours(date, hour);
  date = setMinutes(date, minute);
  date.setSeconds(0);
  date.setMilliseconds(0);

  return date;
};

/**
 * Convierte un Date a string de hora (HH:mm) de forma segura
 * @param date - Objeto Date
 * @returns String en formato HH:mm
 */
export const safeDateToTimeString = (date: Date): string => {
  if (!date || !isValid(date)) {
    throw new Error('Fecha inválida');
  }

  return format(date, 'HH:mm');
};

/**
 * Crea una fecha programada combinando fecha y hora de forma segura
 * @param dateStr - String de fecha (yyyy-MM-dd) o Date
 * @param timeStr - String de hora (HH:mm)
 * @returns Date con fecha y hora combinadas
 */
export const createScheduledDateTime = (
  dateStr: string | Date,
  timeStr: string,
): Date => {
  let baseDate: Date;

  if (typeof dateStr === 'string') {
    // Parsear fecha string de forma segura
    baseDate = parse(dateStr, 'yyyy-MM-dd', new Date());
    if (!isValid(baseDate)) {
      throw new Error('Fecha inválida');
    }
  } else {
    baseDate = new Date(dateStr);
  }

  return safeTimeStringToDate(timeStr, baseDate);
};

/**
 * Formatea una fecha para mostrar de forma amigable
 * @param date - Fecha a formatear
 * @param includeTime - Si incluir la hora
 * @returns String formateado
 */
export const formatDateTimeDisplay = (
  date: Date,
  includeTime: boolean = true,
): string => {
  if (!date || !isValid(date)) {
    return '';
  }

  if (includeTime) {
    return format(date, "d 'de' MMMM 'a las' HH:mm", { locale: es });
  }

  return format(date, "d 'de' MMMM 'de' yyyy", { locale: es });
};

/**
 * Obtiene el timestamp de una fecha de forma segura para enviar al backend
 * @param date - Fecha a convertir
 * @returns ISO string seguro
 */
export const getDateTimeForBackend = (date: Date): string => {
  if (!date || !isValid(date)) {
    throw new Error('Fecha inválida para backend');
  }

  // Usar toISOString() que es seguro en Hermes
  return date.toISOString();
};

/**
 * Parsea una fecha del backend de forma segura
 * @param dateStr - String de fecha del backend
 * @returns Date parseado o null si es inválido
 */
export const parseDateFromBackend = (
  dateStr: string | null | undefined,
): Date | null => {
  if (!dateStr) {
    return null;
  }

  try {
    const date = new Date(dateStr);
    return isValid(date) ? date : null;
  } catch {
    return null;
  }
};

/**
 * Redondea minutos al múltiplo de 5 más cercano
 * @param minutes - Minutos a redondear
 * @returns Minutos redondeados
 */
export const roundMinutesToFive = (minutes: number): number => {
  // Evitar operaciones aritméticas directas
  const quotient = Math.floor(minutes / 5);
  const remainder = minutes - quotient * 5;

  if (remainder >= 3) {
    return (quotient + 1) * 5;
  }

  return quotient * 5;
};

/**
 * Valida si una fecha/hora está en el futuro
 * @param date - Fecha a validar
 * @returns true si está en el futuro
 */
export const isFutureDateTime = (date: Date): boolean => {
  if (!date || !isValid(date)) {
    return false;
  }

  const now = new Date();
  return date.getTime() > now.getTime();
};

/**
 * Obtiene la próxima hora disponible para programación (redondeada a 5 minutos)
 * @param minimumMinutesAhead - Minutos mínimos en el futuro (default: 30)
 * @returns Date con la próxima hora disponible
 */
export const getNextAvailableTime = (
  minimumMinutesAhead: number = 30,
): Date => {
  const now = new Date();

  // Añadir minutos mínimos
  const futureTime = new Date(now.getTime() + minimumMinutesAhead * 60 * 1000);

  // Redondear minutos
  const roundedMinutes = roundMinutesToFive(futureTime.getMinutes());

  let result = setMinutes(futureTime, roundedMinutes);
  result.setSeconds(0);
  result.setMilliseconds(0);

  // Si el redondeo nos llevó al pasado, añadir 5 minutos más
  if (result.getTime() <= now.getTime()) {
    result = new Date(result.getTime() + 5 * 60 * 1000);
  }

  return result;
};

================
File: app/src/components/index.ts
================
export { AudioRecorderWidget } from './AudioRecorderWidget';
export { AudioOrderModal } from './AudioOrderModal';

================
File: app/src/hooks/useOrientation.ts
================
import { useState, useEffect } from 'react';
import { Dimensions } from 'react-native';

export function useOrientation() {
  const [isLandscape, setIsLandscape] = useState(
    Dimensions.get('window').width > Dimensions.get('window').height,
  );

  useEffect(() => {
    const updateOrientation = () => {
      const { width, height } = Dimensions.get('window');
      setIsLandscape(width > height);
    };

    const subscription = Dimensions.addEventListener(
      'change',
      updateOrientation,
    );
    return () => subscription?.remove();
  }, []);

  return isLandscape;
}

================
File: app/src/hooks/useSnackbar.ts
================
import { useSnackbarStore, SnackbarType } from '@/app/store/snackbarStore';

export function useSnackbar() {
  const { showSnackbar: show, hideSnackbar } = useSnackbarStore();

  const showSnackbar = (
    message: string,
    type: SnackbarType = 'info',
    duration?: number,
  ) => {
    show({ message, type, duration });
  };

  return {
    showSnackbar,
    hideSnackbar,
  };
}

================
File: app/src/modules/areasTables/components/AreaFormModal.tsx
================
import React from 'react';
import GenericFormModal, {
  FormFieldConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  CreateAreaSchema,
  UpdateAreaSchema,
} from '../schema/area.schema';
import { z } from 'zod';

const areaFormFields: FormFieldConfig<CreateAreaDto | UpdateAreaDto>[] = [
  {
    name: 'name',
    label: 'Nombre del Área',
    type: 'text',
    placeholder: 'Ej: Terraza, Salón Principal',
    required: true,
  },
  {
    name: 'description',
    label: 'Descripción (Opcional)',
    type: 'textarea',
    placeholder: 'Ej: Área al aire libre con vista',
    numberOfLines: 3,
  },
  {
    name: 'isActive',
    label: '¿Está activa?',
    type: 'switch',
    switchLabel: 'Activa',
    defaultValue: true,
  },
];

interface AreaFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: CreateAreaDto | UpdateAreaDto,
    photoId: string | null | undefined,
  ) => Promise<void>;
  editingItem: Area | null;
  isSubmitting: boolean;
}

const AreaFormModal: React.FC<AreaFormModalProps> = ({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}) => {
  const isEditing = !!editingItem;

  const formSchema = isEditing ? UpdateAreaSchema : CreateAreaSchema;
  const initialValues = isEditing
    ? {
        name: editingItem?.name,
        description: editingItem?.description ?? undefined,
        isActive: editingItem?.isActive,
      }
    : {
        name: '',
        description: undefined,
        isActive: true,
      };

  return (
    <GenericFormModal<CreateAreaDto | UpdateAreaDto, Area>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={onSubmit}
      formSchema={formSchema as z.ZodSchema<CreateAreaDto | UpdateAreaDto>}
      formFields={areaFormFields}
      initialValues={initialValues}
      editingItem={editingItem}
      isSubmitting={isSubmitting}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Área' : 'Crear Nueva Área'
      }
    />
  );
};

export default AreaFormModal;

================
File: app/src/modules/areasTables/components/TableFormModal.tsx
================
import React from 'react';
import GenericFormModal, {
  FormFieldConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  CreateTableSchema,
  UpdateTableSchema,
} from '../schema/table.schema';
import { z } from 'zod';

const tableFormFields: FormFieldConfig<CreateTableDto | UpdateTableDto>[] = [
  {
    name: 'name',
    label: 'Nombre de la Mesa',
    type: 'text',
    placeholder: 'Ej: Mesa 1, Barra 2',
    required: true,
  },
  {
    name: 'capacity',
    label: 'Capacidad (Opcional)',
    type: 'number',
    placeholder: 'Ej: 4',
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'isActive',
    label: '¿Está activa?',
    type: 'switch',
    switchLabel: 'Activa',
    defaultValue: true,
  },
];

interface TableFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: CreateTableDto | UpdateTableDto,
    photoId: string | null | undefined,
  ) => Promise<void>;
  editingItem: Table | null;
  isSubmitting: boolean;
}

const TableFormModal: React.FC<TableFormModalProps> = ({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}) => {
  const isEditing = !!editingItem;

  const formSchema = isEditing ? UpdateTableSchema : CreateTableSchema;
  const initialValues = isEditing
    ? {
        name: editingItem?.name,
        capacity: editingItem?.capacity ?? undefined,
        isActive: editingItem?.isActive,
      }
    : {
        name: '',
        capacity: undefined,
        isActive: true,
      };

  return (
    <GenericFormModal<CreateTableDto | UpdateTableDto, Table>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={onSubmit}
      formSchema={formSchema as z.ZodSchema<CreateTableDto | UpdateTableDto>}
      formFields={tableFormFields}
      initialValues={initialValues}
      editingItem={editingItem}
      isSubmitting={isSubmitting}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Mesa' : 'Crear Nueva Mesa'
      }
    />
  );
};

export default TableFormModal;

================
File: app/src/modules/areasTables/navigation/AreasTablesStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AreasTablesStackParamList } from './types';
import AreasScreen from '../screens/AreasScreen';
import TablesScreen from '../screens/TablesScreen';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';

const Stack = createNativeStackNavigator<AreasTablesStackParamList>();

const AreasTablesStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="AreasList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="AreasList"
        component={AreasScreen}
        options={{
          title: 'Áreas',
        }}
      />
      <Stack.Screen
        name="TablesList"
        component={TablesScreen}
        options={({ route }) => ({
          title: `Mesas de ${route.params.areaName || 'Área'}`,
        })}
      />
    </Stack.Navigator>
  );
};

export default AreasTablesStackNavigator;

================
File: app/src/modules/areasTables/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '../../../app/navigation/types';

export type AreasTablesStackParamList = {
  AreasList: undefined;
  TablesList: { areaId: string; areaName: string };
};

export type AreasListScreenProps = NativeStackScreenProps<
  AreasTablesStackParamList,
  'AreasList'
>;
export type TablesListScreenProps = NativeStackScreenProps<
  AreasTablesStackParamList,
  'TablesList'
>;

export type AreasTablesDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'AreasTablesStack'
>;

================
File: app/src/modules/areasTables/schema/area.schema.ts
================
import { z } from 'zod';
// Importar el tipo central
import type { Area } from '../../../app/schemas/domain/area.schema';

// Schemas específicos para DTOs (Create, Update, FindAll) permanecen aquí
export const CreateAreaSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().optional(),
  isActive: z.boolean().optional().default(true),
});

export const UpdateAreaSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').optional(),
  description: z.string().optional(),
  isActive: z.boolean().optional(),
});

export type CreateAreaDto = z.infer<typeof CreateAreaSchema>;
export type UpdateAreaDto = z.infer<typeof UpdateAreaSchema>;

export const FindAllAreasSchema = z.object({
  name: z.string().optional(),
  isActive: z.boolean().optional(),
});
export type FindAllAreasDto = z.infer<typeof FindAllAreasSchema>;

// Re-exportar el tipo de dominio si es conveniente para el módulo
export type { Area };

================
File: app/src/modules/areasTables/schema/table.schema.ts
================
import { z } from 'zod';
// Importar el tipo de dominio centralizado
import type { Table } from '../../../app/schemas/domain/table.schema';

// Schemas específicos para DTOs (Create, Update, FindAll) permanecen aquí
export const CreateTableSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  capacity: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce
      .number()
      .int()
      .positive('La capacidad debe ser un número positivo')
      .nullable()
      .optional(),
  ),
  isActive: z.boolean().optional().default(true),
  // areaId se añadirá en el servicio al crear, no viene del formulario directamente
});

export const UpdateTableSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').optional(),
  capacity: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce
      .number()
      .int()
      .positive('La capacidad debe ser un número positivo')
      .nullable()
      .optional(),
  ),
  isActive: z.boolean().optional(),
  // areaId no se suele actualizar, pero si fuera necesario, se añadiría aquí
});

export type CreateTableDto = z.infer<typeof CreateTableSchema>;
export type UpdateTableDto = z.infer<typeof UpdateTableSchema>;

const transformBoolean = (val: unknown) => {
  if (val === 'true') return true;
  if (val === 'false') return false;
  return val;
};

export const FindAllTablesSchema = z.object({
  name: z.string().optional(),
  areaId: z.string().uuid().optional(),
  capacity: z.coerce.number().int().optional(),
  isActive: z.preprocess(transformBoolean, z.boolean().optional()),
  isAvailable: z.preprocess(transformBoolean, z.boolean().optional()),
  isTemporary: z.preprocess(transformBoolean, z.boolean().optional()),
});
export type FindAllTablesDto = z.infer<typeof FindAllTablesSchema>;

// Re-exportar el tipo de dominio para conveniencia del módulo
export type { Table };

================
File: app/src/modules/areasTables/types/areasTables.types.ts
================
import type { Area } from '../schema/area.schema'; // Corregida ruta de importación
import type { Table } from '../schema/table.schema'; // Corregida ruta de importación

export type { Area, Table };

================
File: app/src/modules/auth/schema/auth.schema.ts
================
import { z } from 'zod';

// Schemas moved from auth.types.ts
export const loginSchema = z.object({
  emailOrUsername: z
    .string()
    .min(1, 'El correo o nombre de usuario es requerido'),
  password: z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
});

export type LoginFormInputs = z.infer<typeof loginSchema>;

export const authResponseSchema = z.object({
  token: z.string(),
  user: z.object({
    id: z.string(),
    email: z.string().email(),
    username: z.string(),
    role: z.enum(['admin', 'staff']),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().url().optional(),
  }),
});

export type AuthResponse = z.infer<typeof authResponseSchema>;

export const authEmailLoginDtoSchema = z.object({
  email: z.string().email().optional(),
  username: z.string().optional(),
  password: z.string(),
});
export type AuthEmailLoginDto = z.infer<typeof authEmailLoginDtoSchema>;

export const userSchema = z.object({
  id: z.string().uuid('El ID de usuario debe ser un UUID válido'), // Cambiado a string().uuid()
  email: z.string().email().nullable(),
  username: z.string().nullable(),
  firstName: z.string().nullable(),
  lastName: z.string().nullable(),
  role: z
    .object({
      id: z.number(),
      name: z.string(),
    })
    .optional(),
  isActive: z.boolean().optional(),
  preparationScreen: z
    .object({
      id: z.string(),
      name: z.string(),
      description: z.string().nullable(),
      isActive: z.boolean(),
    })
    .nullable()
    .optional(),
});
export type User = z.infer<typeof userSchema>;

export const loginResponseDtoSchema = z.object({
  token: z.string(),
  refreshToken: z.string(),
  tokenExpires: z.number(),
  user: userSchema,
});
export type LoginResponseDto = z.infer<typeof loginResponseDtoSchema>;

export const registerSchema = z.object({
  email: z.string().email('Correo electrónico inválido'),
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .regex(
      /^[a-zA-Z0-9_]+$/,
      'Solo se permiten letras, números y guiones bajos',
    ),
  password: z.string().min(8, 'La contraseña debe tener al menos 8 caracteres'),
  firstName: z.string().min(1, 'El nombre es requerido'),
  lastName: z.string().min(1, 'El apellido es requerido'),
});

export type RegisterFormInputs = z.infer<typeof registerSchema>;

================
File: app/src/modules/auth/types/auth.types.ts
================
import type { AuthResponse, LoginFormInputs } from '../schema/auth.schema';

// Pure TypeScript interfaces/types remain here
export interface AuthState {
  token: string | null;
  user: AuthResponse['user'] | null;
  isLoading: boolean;
  error: string | null;
  login: (credentials: LoginFormInputs) => Promise<void>;
  logout: () => void;
  clearError: () => void;
}

export interface RegisterResponseDto {
  message: string;
}

// Zod schemas (loginSchema, authResponseSchema, etc.)
// are defined in ../schema/auth.schema.ts

================
File: app/src/modules/availability/hooks/useAvailabilityQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { availabilityService } from '../services/availabilityService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

export const useMenuAvailability = () => {
  return useQuery({
    queryKey: ['availability', 'menu'],
    queryFn: availabilityService.getMenuAvailability,
  });
};

export const useModifierGroupsAvailability = () => {
  return useQuery({
    queryKey: ['availability', 'modifierGroups'],
    queryFn: availabilityService.getModifierGroupsAvailability,
  });
};

export const useUpdateAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: availabilityService.updateAvailability,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: () => {
      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
  });
};

export const useBulkUpdateAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: availabilityService.bulkUpdateAvailability,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: () => {
      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/availability/hooks/usePizzaCustomizationsAvailability.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { PizzaCustomizationGroupAvailability } from '../types/availability.types';

export function usePizzaCustomizationsAvailability(search?: string) {
  return useQuery({
    queryKey: ['availability', 'pizzaCustomizations', search],
    queryFn: async () => {
      const response = await apiClient.get<
        PizzaCustomizationGroupAvailability[]
      >(API_PATHS.AVAILABILITY_PIZZA_CUSTOMIZATIONS);

      if (!response.ok || !response.data) {
        throw new Error('Failed to fetch pizza customizations availability');
      }

      let data = response.data;

      if (search) {
        const searchLower = search.toLowerCase();
        data = data
          .map((group) => ({
            ...group,
            items: group.items.filter((item) =>
              item.name.toLowerCase().includes(searchLower),
            ),
          }))
          .filter((group) => group.items.length > 0);
      }

      return data;
    },
  });
}

================
File: app/src/modules/availability/navigation/AvailabilityStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AvailabilityScreen } from '../screens/AvailabilityScreen';
import { AvailabilityStackParamList } from './types';
import { getStackHeaderOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';

const Stack = createNativeStackNavigator<AvailabilityStackParamList>();

export const AvailabilityStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="AvailabilityScreen"
        component={AvailabilityScreen}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/availability/navigation/types.ts
================
import { NativeStackScreenProps } from '@react-navigation/native-stack';

export type AvailabilityStackParamList = {
  AvailabilityScreen: undefined;
};

export type AvailabilityScreenProps = NativeStackScreenProps<
  AvailabilityStackParamList,
  'AvailabilityScreen'
>;

================
File: app/src/modules/availability/services/availabilityService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  AvailabilityUpdatePayload,
  CategoryAvailability,
  ModifierGroupAvailability,
} from '../types/availability.types';

export const availabilityService = {
  // Obtener la disponibilidad del menú completo
  async getMenuAvailability(): Promise<CategoryAvailability[]> {
    const response = await apiClient.get<CategoryAvailability[]>(
      API_PATHS.AVAILABILITY_MENU,
    );
    return response.data || [];
  },

  // Obtener la disponibilidad de grupos de modificadores
  async getModifierGroupsAvailability(): Promise<ModifierGroupAvailability[]> {
    const response = await apiClient.get<ModifierGroupAvailability[]>(
      API_PATHS.AVAILABILITY_MODIFIER_GROUPS,
    );
    return response.data || [];
  },

  // Actualizar disponibilidad (con opción de cascada)
  async updateAvailability(payload: AvailabilityUpdatePayload): Promise<void> {
    await apiClient.patch(API_PATHS.AVAILABILITY_UPDATE, payload);
  },

  // Actualización masiva de disponibilidad
  async bulkUpdateAvailability(
    updates: AvailabilityUpdatePayload[],
  ): Promise<void> {
    await apiClient.patch(API_PATHS.AVAILABILITY_BULK_UPDATE, { updates });
  },
};

================
File: app/src/modules/availability/types/availability.types.ts
================
export interface CategoryAvailability {
  id: string;
  name: string;
  isActive: boolean;
  subcategories: SubcategoryAvailability[];
}

export interface SubcategoryAvailability {
  id: string;
  name: string;
  isActive: boolean;
  categoryId: string;
  products: ProductAvailability[];
}

export interface ProductAvailability {
  id: string;
  name: string;
  isActive: boolean;
  subcategoryId: string;
  modifierGroups?: ModifierGroupAvailability[];
}

export interface ModifierGroupAvailability {
  id: string;
  name: string;
  isActive: boolean;
  modifiers: ModifierAvailability[];
}

export interface ModifierAvailability {
  id: string;
  name: string;
  isActive: boolean;
  modifierGroupId: string;
}

export interface PizzaCustomizationAvailability {
  id: string;
  name: string;
  type: 'FLAVOR' | 'INGREDIENT';
  isActive: boolean;
  sortOrder: number;
}

export interface PizzaCustomizationGroupAvailability {
  type: string;
  items: PizzaCustomizationAvailability[];
}

export interface AvailabilityUpdatePayload {
  type:
    | 'category'
    | 'subcategory'
    | 'product'
    | 'modifierGroup'
    | 'modifier'
    | 'pizzaCustomization';
  id: string;
  isActive: boolean;
  cascade?: boolean;
}

export interface AvailabilityFilter {
  search?: string;
  showOnlyUnavailable?: boolean;
  categoryId?: string;
  subcategoryId?: string;
}

================
File: app/src/modules/customers/navigation/CustomersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import CustomersScreen from '../screens/CustomersScreen';

export type CustomersStackParamList = {
  Customers: undefined;
  CustomerDetail?: { customerId: string };
  CustomerAddresses?: { customerId: string };
  CustomerChatHistory?: { customerId: string };
};

const Stack = createNativeStackNavigator<CustomersStackParamList>();

export function CustomersStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="Customers"
        component={CustomersScreen}
        options={{
          title: 'Clientes',
        }}
      />
      {/* Aquí se pueden agregar más pantallas como:
          - CustomerDetail
          - CustomerAddresses
          - CustomerChatHistory
      */}
    </Stack.Navigator>
  );
}

================
File: app/src/modules/kitchen/components/KitchenFilterButton.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  Dimensions,
  TouchableOpacity,
  Animated,
  ScrollView,
} from 'react-native';
import { Portal, Modal, Surface, Text, Switch } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useKitchenStore } from '../store/kitchenStore';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { OrderType } from '../types/kitchen.types';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

export const KitchenFilterButton: React.FC = () => {
  const theme = useAppTheme();
  const [visible, setVisible] = useState(false);
  const { filters, setFilters } = useKitchenStore();
  const scaleAnim = React.useRef(new Animated.Value(1)).current;

  const activeFiltersCount = [
    filters.showPrepared,
    filters.showAllProducts,
    filters.ungroupProducts,
    filters.orderType !== undefined,
  ].filter(Boolean).length;

  const handleToggleFilter = (filterName: keyof typeof filters) => {
    setFilters({
      ...filters,
      [filterName]: !filters[filterName],
    });
  };

  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: 0.9,
      useNativeDriver: true,
    }).start();
  };

  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      useNativeDriver: true,
    }).start();
  };

  return (
    <>
      <TouchableOpacity
        onPress={() => setVisible(true)}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        activeOpacity={0.8}
        style={styles.buttonContainer}
      >
        <Animated.View
          style={[
            styles.filterButton,
            {
              backgroundColor:
                activeFiltersCount > 0
                  ? theme.colors.primaryContainer
                  : 'rgba(255,255,255,0.2)',
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <Icon
            name="tune-variant"
            size={24}
            color={
              activeFiltersCount > 0
                ? theme.colors.onPrimaryContainer
                : theme.colors.onPrimary
            }
          />
          {activeFiltersCount > 0 && (
            <View
              style={[
                styles.badge,
                {
                  backgroundColor: theme.colors.error,
                },
              ]}
            >
              <Text style={[styles.badgeText, { color: theme.colors.onError }]}>
                {activeFiltersCount}
              </Text>
            </View>
          )}
        </Animated.View>
      </TouchableOpacity>

      <Portal>
        <Modal
          visible={visible}
          onDismiss={() => setVisible(false)}
          contentContainerStyle={[
            styles.modalContent,
            {
              backgroundColor: theme.colors.surface,
            },
          ]}
        >
          <ScrollView
            style={{
              maxHeight: screenHeight < 400 ? screenHeight - 80 : undefined,
            }}
            showsVerticalScrollIndicator={false}
          >
            <Surface
              style={[
                styles.modalSurface,
                { backgroundColor: theme.colors.surface },
              ]}
              elevation={3}
            >
              <View
                style={[
                  styles.modalHeader,
                  { backgroundColor: theme.colors.primaryContainer },
                ]}
              >
                <View style={styles.headerContent}>
                  <Icon
                    name="tune-variant"
                    size={24}
                    color={theme.colors.onPrimaryContainer}
                  />
                  <View style={styles.headerTextContainer}>
                    <Text
                      variant="titleMedium"
                      style={[
                        styles.modalTitle,
                        { color: theme.colors.onPrimaryContainer },
                      ]}
                    >
                      Filtros de visualización
                    </Text>
                  </View>
                </View>
                <TouchableOpacity
                  onPress={() => setVisible(false)}
                  style={styles.closeButton}
                >
                  <Icon
                    name="close"
                    size={22}
                    color={theme.colors.onPrimaryContainer}
                  />
                </TouchableOpacity>
              </View>

              <View style={styles.filtersList}>
                {/* Tipo de orden */}
                <View style={styles.sectionHeader}>
                  <Text
                    variant="titleMedium"
                    style={{ color: theme.colors.onSurface, fontWeight: '600' }}
                  >
                    Tipo de orden
                  </Text>
                </View>
                <View style={styles.orderTypeContainer}>
                  {[
                    { value: undefined, label: 'Todos', icon: 'check-all' },
                    {
                      value: OrderType.DINE_IN,
                      label: 'Mesa',
                      icon: 'table-chair',
                    },
                    {
                      value: OrderType.TAKE_AWAY,
                      label: 'Llevar',
                      icon: 'bag-checked',
                    },
                    {
                      value: OrderType.DELIVERY,
                      label: 'Domicilio',
                      icon: 'moped',
                    },
                  ].map((option) => {
                    const isSelected = filters.orderType === option.value;
                    return (
                      <TouchableOpacity
                        key={option.label}
                        style={[
                          styles.orderTypeButton,
                          isSelected && {
                            backgroundColor: theme.colors.primaryContainer,
                            borderColor: theme.colors.primary,
                          },
                          !isSelected && {
                            backgroundColor: theme.colors.surfaceVariant,
                            borderColor: 'transparent',
                          },
                        ]}
                        onPress={() =>
                          setFilters({ ...filters, orderType: option.value })
                        }
                        activeOpacity={0.8}
                      >
                        <Icon
                          name={option.icon}
                          size={20}
                          color={
                            isSelected
                              ? theme.colors.onPrimaryContainer
                              : theme.colors.onSurfaceVariant
                          }
                        />
                        <Text
                          variant="labelMedium"
                          style={{
                            color: isSelected
                              ? theme.colors.onPrimaryContainer
                              : theme.colors.onSurfaceVariant,
                            fontWeight: isSelected ? '700' : '500',
                            marginTop: 4,
                          }}
                        >
                          {option.label}
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </View>

                <View
                  style={[
                    styles.divider,
                    { backgroundColor: theme.colors.outlineVariant },
                  ]}
                />

                {/* Otros filtros */}
                <View style={styles.sectionHeader}>
                  <Text
                    variant="titleMedium"
                    style={{ color: theme.colors.onSurface, fontWeight: '600' }}
                  >
                    Opciones de visualización
                  </Text>
                </View>
                <TouchableOpacity
                  onPress={() => handleToggleFilter('showPrepared')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.showPrepared && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.showPrepared
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="check-circle-outline"
                          size={22}
                          color={
                            filters.showPrepared
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={{
                            color: theme.colors.onSurface,
                            fontWeight: '600',
                          }}
                        >
                          Mostrar listas
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={{ color: theme.colors.onSurfaceVariant }}
                        >
                          Muestra solo las órdenes listas
                        </Text>
                      </View>
                      <Switch
                        value={filters.showPrepared}
                        onValueChange={() => handleToggleFilter('showPrepared')}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>

                <TouchableOpacity
                  onPress={() => handleToggleFilter('showAllProducts')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.showAllProducts && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.showAllProducts
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="eye-outline"
                          size={22}
                          color={
                            filters.showAllProducts
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={{
                            color: theme.colors.onSurface,
                            fontWeight: '600',
                          }}
                        >
                          Ver todos los productos
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={{ color: theme.colors.onSurfaceVariant }}
                        >
                          Muestra productos de todas las órdenes
                        </Text>
                      </View>
                      <Switch
                        value={filters.showAllProducts}
                        onValueChange={() =>
                          handleToggleFilter('showAllProducts')
                        }
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>

                <TouchableOpacity
                  onPress={() => handleToggleFilter('ungroupProducts')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.ungroupProducts && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.ungroupProducts
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="ungroup"
                          size={22}
                          color={
                            filters.ungroupProducts
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={{
                            color: theme.colors.onSurface,
                            fontWeight: '600',
                          }}
                        >
                          Desagrupar productos
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={{ color: theme.colors.onSurfaceVariant }}
                        >
                          Muestra cada producto individualmente
                        </Text>
                      </View>
                      <Switch
                        value={filters.ungroupProducts}
                        onValueChange={() =>
                          handleToggleFilter('ungroupProducts')
                        }
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>
              </View>
            </Surface>
          </ScrollView>
        </Modal>
      </Portal>
    </>
  );
};

const styles = StyleSheet.create({
  buttonContainer: {
    marginRight: 12,
  },
  filterButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
    width: 20,
    height: 20,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
  },
  badgeText: {
    fontSize: 11,
    fontWeight: 'bold',
  },
  modalContent: {
    margin: screenHeight < 400 ? 10 : 20,
    maxWidth: screenHeight < 400 ? screenWidth - 40 : 380,
    maxHeight: screenHeight < 400 ? screenHeight - 60 : undefined,
    alignSelf: 'center',
    width: Math.min(screenWidth - (screenHeight < 400 ? 40 : 60), 380),
    borderRadius: 20,
    overflow: 'hidden',
  },
  modalSurface: {
    borderRadius: 20,
    overflow: 'hidden',
    maxHeight: screenHeight < 400 ? screenHeight - 60 : undefined,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: screenHeight < 400 ? 12 : 16,
    paddingBottom: screenHeight < 400 ? 8 : 12,
    marginBottom: 4,
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  headerTextContainer: {
    marginLeft: 10,
    flex: 1,
  },
  modalTitle: {
    fontWeight: '700',
  },
  closeButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 8,
  },
  filtersList: {
    padding: screenHeight < 400 ? 8 : 12,
    paddingTop: screenHeight < 400 ? 4 : 8,
    gap: screenHeight < 400 ? 6 : 10,
  },
  filterItem: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'transparent',
    overflow: 'hidden',
  },
  filterItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: screenHeight < 400 ? 8 : 12,
    gap: screenHeight < 400 ? 8 : 10,
  },
  iconContainer: {
    width: screenHeight < 400 ? 32 : 40,
    height: screenHeight < 400 ? 32 : 40,
    borderRadius: screenHeight < 400 ? 16 : 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  filterTextContent: {
    flex: 1,
    gap: 2,
  },
  sectionHeader: {
    marginBottom: screenHeight < 400 ? 8 : 12,
    paddingHorizontal: 4,
  },
  orderTypeContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
    gap: 8,
  },
  orderTypeButton: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: screenHeight < 400 ? 8 : 12,
    paddingHorizontal: screenHeight < 400 ? 4 : 8,
    borderRadius: 12,
    borderWidth: 1.5,
  },
  divider: {
    height: 1,
    marginVertical: screenHeight < 400 ? 8 : 16,
    marginHorizontal: screenHeight < 400 ? -8 : -12,
  },
});

================
File: app/src/modules/kitchen/components/RefreshButton.tsx
================
import React, { useState } from 'react';
import { View, TouchableOpacity, Animated, StyleSheet } from 'react-native';
import { ActivityIndicator } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useKitchenContext } from '../context/KitchenContext';

export const RefreshButton: React.FC = () => {
  const { refetchRef } = useKitchenContext();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const scaleAnim = new Animated.Value(1);

  const handleRefresh = async () => {
    if (refetchRef.current && !isRefreshing) {
      // Animación de presión
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 0.9,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();

      setIsRefreshing(true);
      try {
        await refetchRef.current();
      } finally {
        setTimeout(() => setIsRefreshing(false), 500);
      }
    }
  };

  return (
    <Animated.View
      style={[styles.container, { transform: [{ scale: scaleAnim }] }]}
    >
      <TouchableOpacity
        style={[styles.button, isRefreshing && styles.buttonRefreshing]}
        onPress={handleRefresh}
        disabled={isRefreshing}
        activeOpacity={0.8}
      >
        <View style={styles.iconContainer}>
          {isRefreshing ? (
            <ActivityIndicator size={26} color="white" />
          ) : (
            <Icon name="refresh" size={26} color="white" />
          )}
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginHorizontal: 8,
  },
  button: {
    backgroundColor: 'rgba(255, 255, 255, 0.25)',
    borderRadius: 22,
    width: 44,
    height: 44,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1.5,
    borderColor: 'rgba(255, 255, 255, 0.4)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  buttonRefreshing: {
    backgroundColor: 'rgba(255, 255, 255, 0.15)',
    borderColor: 'rgba(255, 255, 255, 0.3)',
  },
  iconContainer: {
    width: 26,
    height: 26,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

================
File: app/src/modules/kitchen/context/KitchenContext.tsx
================
import React, {
  createContext,
  useContext,
  useRef,
  MutableRefObject,
} from 'react';

interface KitchenContextType {
  refetchRef: MutableRefObject<(() => void) | null>;
}

const KitchenContext = createContext<KitchenContextType | undefined>(undefined);

export const KitchenProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const refetchRef = useRef<(() => void) | null>(null);

  return (
    <KitchenContext.Provider value={{ refetchRef }}>
      {children}
    </KitchenContext.Provider>
  );
};

export const useKitchenContext = () => {
  const context = useContext(KitchenContext);
  if (!context) {
    throw new Error('useKitchenContext must be used within a KitchenProvider');
  }
  return context;
};

================
File: app/src/modules/kitchen/navigation/KitchenNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import KitchenOrdersScreen from '../screens/KitchenOrdersScreen';

export type KitchenStackParamList = {
  KitchenOrders: undefined;
};

const Stack = createNativeStackNavigator<KitchenStackParamList>();

export default function KitchenNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen name="KitchenOrders" component={KitchenOrdersScreen} />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/menu/navigation/MenuStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';
import type { MenuStackParamList } from './types.ts';

import CategoriesScreen from '../screens/CategoriesScreen';
import SubcategoriesScreen from '../screens/SubcategoriesScreen';
import ProductsScreen from '../screens/ProductsScreen';

const Stack = createNativeStackNavigator<MenuStackParamList>();

export const MenuStackNavigator: React.FC = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        ...getStackHeaderOptions(theme),
        headerShown: true,
      }}
    >
      <Stack.Screen
        name="CategoriesScreen"
        component={CategoriesScreen}
        options={{
          title: 'Categorías',
        }}
      />
      <Stack.Screen
        name="SubcategoriesScreen"
        component={SubcategoriesScreen}
        options={({ route }) => ({
          title: route.params?.categoryName
            ? `Subcategorías de ${route.params.categoryName}`
            : 'Subcategorías',
        })}
      />
      <Stack.Screen
        name="Products"
        component={ProductsScreen}
        options={({ route }) => ({
          title: route.params?.subCategoryName
            ? `Productos de ${route.params.subCategoryName}`
            : 'Productos',
        })}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/menu/navigation/types.ts
================
export type MenuStackParamList = {
  CategoriesScreen: undefined;
  SubcategoriesScreen: { categoryId: string; categoryName: string };
  Products: { subcategoryId: string; subCategoryName: string };
};

================
File: app/src/modules/menu/schema/category.schema.ts
================
import { z } from 'zod';
import type { Category } from '../../../app/schemas/domain/category.schema';
import { type Photo } from '../../../app/schemas/domain/photo.schema'; // Eliminado photoSchema no usado

export const createCategoryDtoSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean().optional().default(true),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  sortOrder: z.number().optional().default(0),
});

export const updateCategoryDtoSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').optional(),
  description: z.string().optional().nullable(),
  isActive: z.boolean().optional(),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  sortOrder: z.number().optional(),
});

export const categoryFormSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  sortOrder: z.number().optional().default(0),
  imageUri: z
    .union([
      z.string().url(),
      z.string().startsWith('file://'),
      z.string().startsWith('http://'),
      z.string().startsWith('https://'),
      z.null(),
    ])
    .optional(),
});

export type CreateCategoryDto = z.infer<typeof createCategoryDtoSchema>;
export type UpdateCategoryDto = z.infer<typeof updateCategoryDtoSchema>;
export type CategoryFormData = z.infer<typeof categoryFormSchema>;

export type { Category, Photo };

================
File: app/src/modules/menu/schema/subcategories.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/api.types';
import { type Photo } from '../../../app/schemas/domain/photo.schema'; // Eliminado photoSchema no usado
import type { SubCategory } from '../../../app/schemas/domain/subcategory.schema';

export const createSubCategoryDtoSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().optional().nullable(),
  isActive: z.boolean().optional().default(true),
  categoryId: z.string().min(1, 'Debe seleccionar una categoría válida'),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  imageUri: z
    .union([
      z.string().url(),
      z.string().startsWith('file://'),
      z.string().startsWith('http://'),
      z.string().startsWith('https://'),
      z.null(),
    ])
    .optional(),
  sortOrder: z.number().optional().default(0),
});
export type CreateSubCategoryDto = z.infer<typeof createSubCategoryDtoSchema>;

export const updateSubCategoryDtoSchema = createSubCategoryDtoSchema.partial();
export type UpdateSubCategoryDto = z.infer<typeof updateSubCategoryDtoSchema>;

export const findAllSubcategoriesDtoSchema = baseListQuerySchema.extend({
  categoryId: z.string().optional(),
  isActive: z.boolean().optional(),
});

export type SubCategoryFormInputs = CreateSubCategoryDto;
export type UpdateSubCategoryFormInputs = UpdateSubCategoryDto;

export type { Photo, SubCategory };

================
File: app/src/modules/menu/types/category.types.ts
================
// Tipos de dominio centralizados en src/app/types/domain/
// import type { Category, CategoryPhoto } from '../../../app/types/domain/category.types';

/**
 * Estructura genérica para respuestas paginadas de la API.
 * TODO: Mover a un archivo de tipos comunes de API si se usa en más módulos.
 */
export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export type ActiveFilter = 'all' | 'active' | 'inactive';

// Los tipos inferidos de Zod (CreateCategoryDto, UpdateCategoryDto, CategoryFormData)
// se definen y exportan directamente desde ../schema/category.schema.ts
// y se usan donde se necesiten los tipos específicos del schema/formulario.

================
File: app/src/modules/menu/types/subcategories.types.ts
================
// Import base types if needed
import type { BaseListQueryDto } from '../../../app/types/api.types';

export type FindAllSubcategoriesDto = BaseListQueryDto & {
  categoryId?: string;
  isActive?: boolean;
};

================
File: app/src/modules/modifiers/navigation/ModifiersStackNavigator.tsx
================
import React from 'react';
import {
  createNativeStackNavigator,
  NativeStackNavigationOptions,
} from '@react-navigation/native-stack';
import { ModifiersStackParamList } from '@/app/navigation/types';
import ModifierGroupsScreen from '../screens/ModifierGroupsScreen';
import ModifiersScreen from '../screens/ModifiersScreen';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';

const Stack = createNativeStackNavigator<ModifiersStackParamList>();

const ModifiersStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="ModifierGroupsScreen"
        component={ModifierGroupsScreen}
        options={(): NativeStackNavigationOptions => ({
          title: 'Grupos de Modificadores',
        })}
      />
      <Stack.Screen
        name="ModifiersScreen"
        component={ModifiersScreen}
        options={{ title: 'Modificadores' }}
      />
    </Stack.Navigator>
  );
};

export default ModifiersStackNavigator;

================
File: app/src/modules/modifiers/schema/modifier.schema.ts
================
import { z } from 'zod';
import { modifierSchema as domainModifierSchema } from '../../../app/schemas/domain/modifier.schema';
import type { Modifier } from '../../../app/schemas/domain/modifier.schema';

// Schema para DTO de creación (definido manualmente, sin id)
export const createModifierSchema = z.object({
  modifierGroupId: z.string().min(1, 'El ID del grupo no es válido'),
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.coerce.number().nullable().optional(),
  sortOrder: z.number().int().default(0),
  isDefault: z.boolean().default(false),
  isActive: z.boolean().default(true),
});
export type CreateModifierInput = z.infer<typeof createModifierSchema>;

// Schema para DTO de actualización (parcial, sin id ni modifierGroupId)
export const updateModifierSchema = z
  .object({
    name: z.string().min(1, 'El nombre es requerido').max(100),
    description: z.string().max(255).nullable().optional(),
    price: z.coerce.number().nullable().optional(),
    sortOrder: z.number().int().default(0),
    isDefault: z.boolean().default(false),
    isActive: z.boolean().default(true),
  })
  .partial();
export type UpdateModifierInput = z.infer<typeof updateModifierSchema>;

// Schema específico para validación del formulario (puede tener reglas diferentes a los DTOs)
export const modifierFormValidationSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  // Usar z.preprocess para manejar strings vacíos o null antes de coercer a número
  price: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce.number().nullable().optional(),
  ),
  sortOrder: z.preprocess(
    (val) => (val === '' || val === null ? 0 : val),
    z.coerce.number().int().optional().default(0),
  ),
  isDefault: z.boolean().optional().default(false),
  isActive: z.boolean().optional().default(true),
});

// Schema para la respuesta de la API (extiende el schema de dominio)
export const modifierApiSchema = domainModifierSchema.extend({
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
  deletedAt: z.string().datetime().nullable().optional(),
});

// Re-exportar el tipo de dominio centralizado
export type { Modifier };

================
File: app/src/modules/modifiers/schema/modifierGroup.schema.ts
================
import { z } from 'zod';
// Importar tipo de dominio centralizado
import { modifierGroupSchema as domainModifierGroupSchema } from '../../../app/schemas/domain/modifier-group.schema'; // Importar el schema Zod
import type { ModifierGroup } from '../../../app/schemas/domain/modifier-group.schema'; // Mantener importación de tipo

// Schema base local para validaciones y transformaciones de DTO/Form
const modifierGroupBaseSchemaForForm = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  minSelections: z.number().int().min(0).optional(),
  maxSelections: z.number().int().min(1).optional(),
  isRequired: z.boolean().optional(),
  allowMultipleSelections: z.boolean().optional(),
  isActive: z.boolean().optional(),
  sortOrder: z.number().optional().default(0),
});

// Schema de validación para el formulario (usa el schema base local)
export const modifierGroupFormValidationSchema =
  modifierGroupBaseSchemaForForm.superRefine((data, ctx) => {
    if (data.allowMultipleSelections) {
      if (data.maxSelections === undefined || data.maxSelections === null) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['maxSelections'],
          message:
            'Máx. selecciones es requerido si se permiten múltiples selecciones.',
        });
      } else {
        if (data.maxSelections <= 1) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['maxSelections'],
            message:
              'Máx. selecciones debe ser mayor que 1 si se permiten múltiples selecciones.',
          });
        }

        const min = data.minSelections ?? 0;
        if (data.maxSelections > 1 && min > data.maxSelections) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['minSelections'],
            message:
              'Mín. selecciones no puede ser mayor que Máx. selecciones.',
          });
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['maxSelections'],
            message:
              'Máx. selecciones no puede ser menor que Mín. selecciones.',
          });
        }
      }
    } else {
      // Si no se permiten múltiples selecciones, maxSelections debe ser 1
      // y minSelections debe ser 0 o 1 (dependiendo de isRequired)
      // Esta lógica puede ajustarse según las reglas de negocio exactas.
      // Por ahora, no añadimos validación extra aquí si allowMultipleSelections es false.
    }
  });

// Tipo inferido para el formulario
export type ModifierGroupFormInputs = z.infer<
  typeof modifierGroupFormValidationSchema
>;

// Schema para DTO de creación (usa el schema base local y transforma)
export const createModifierGroupSchema =
  modifierGroupBaseSchemaForForm.transform((data) => ({
    ...data,
    minSelections: data.minSelections ?? 0,
    isRequired: data.isRequired ?? false,
    allowMultipleSelections: data.allowMultipleSelections ?? false,
    isActive: data.isActive ?? true,
    sortOrder: data.sortOrder ?? 0,
    maxSelections: data.allowMultipleSelections ? (data.maxSelections ?? 1) : 1,
  }));
// Tipo inferido para DTO de creación
export type CreateModifierGroupInput = z.infer<
  typeof createModifierGroupSchema
>;

// Schema para DTO de actualización (usa el schema base local y lo hace parcial)
export const updateModifierGroupSchema =
  modifierGroupBaseSchemaForForm.partial();
// Tipo inferido para DTO de actualización
export type UpdateModifierGroupInput = z.infer<
  typeof updateModifierGroupSchema
>;

// Schema para la respuesta de la API (extiende el schema de dominio)
export const modifierGroupApiSchema = domainModifierGroupSchema.extend({
  // Añadir campos que vienen de la API pero no están en el schema de dominio base
  id: z.string(), // ID puede ser custom format como "MODG-7"
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  deletedAt: z.string().datetime().nullable().optional(),
  // Definir schemas placeholder o importar los reales si existen
  productModifiers: z.array(z.any()).optional(), // Usar z.any() o un schema específico si existe
  products: z.array(z.any()).optional(), // Usar z.any() o un schema específico si existe
});

// Re-exportar el tipo de dominio centralizado
export type { ModifierGroup };

// Mantener exportaciones anteriores si otros archivos dependen de ellas (revisar si es necesario)
export const modifierGroupSchema = modifierGroupFormValidationSchema; // Alias para compatibilidad?
export const modifierGroupBaseSchema = modifierGroupBaseSchemaForForm; // Alias para compatibilidad?

================
File: app/src/modules/modifiers/types/modifier.types.ts
================
// Pure TypeScript types remain here
export type ModifierFormInputs = {
  name: string;
  description?: string | null;
  price?: number | null;
  sortOrder?: number;
  isDefault?: boolean;
  isActive?: boolean;
};

// Zod schemas (Modifier, CreateModifierInput, UpdateModifierInput, etc.)
// are defined in ../schema/modifier.schema.ts

================
File: app/src/modules/orderFinalization/navigation/OrderFinalizationStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { OrderFinalizationScreen } from '../screens/OrderFinalizationScreen';
import { OrderFinalizationStackParamList } from './types';
import { defaultScreenOptions } from '@/app/navigation/options';

const Stack = createNativeStackNavigator<OrderFinalizationStackParamList>();

export const OrderFinalizationStackNavigator = () => {
  return (
    <Stack.Navigator screenOptions={defaultScreenOptions}>
      <Stack.Screen
        name="OrderFinalizationScreen"
        component={OrderFinalizationScreen}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/orderFinalization/navigation/types.ts
================
export type OrderFinalizationStackParamList = {
  OrderFinalizationScreen: undefined;
};

================
File: app/src/modules/orders/components/MenuItemCard.tsx
================
import React, { useMemo } from 'react';
import { StyleSheet, View } from 'react-native';
import { Card, Title, Text, IconButton } from 'react-native-paper';
import { AutoImage } from '@/app/components/common/AutoImage';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import type { Product, Category, SubCategory } from '../types/orders.types';

interface MenuItemCardProps {
  item: Category | SubCategory | Product;
  onPress: () => void;
  onLongPress?: () => void;
  onInfoPress?: () => void;
  navigationLevel: 'categories' | 'subcategories' | 'products';
  disabled?: boolean;
  showPrice?: boolean;
}

const MenuItemCard = React.memo<MenuItemCardProps>(
  ({
    item,
    onPress,
    onLongPress,
    onInfoPress,
    navigationLevel,
    disabled = false,
    showPrice = true,
  }) => {
    const theme = useAppTheme();
    const { colors, fonts } = theme;
    const responsive = useResponsive();

    const blurhash =
      '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';

    const styles = useMemo(
      () =>
        StyleSheet.create({
          cardItem: {
            flex: 1,
            minWidth: 120, // Ancho mínimo para evitar cards muy pequeños
            overflow: 'hidden',
            borderRadius: theme.roundness,
            elevation: 2,
          },
          cardItemInactive: {
            opacity: 0.5,
          },
          itemImage: {
            width: '100%',
            height: responsive.getResponsiveDimension(120, 160),
          },
          imageInactive: {
            opacity: 0.6,
          },
          cardContent: {
            paddingHorizontal: responsive.spacing.s,
            paddingVertical: responsive.spacing.xs,
          },
          cardTitle: {
            fontSize: responsive.fontSize.m,
            fontWeight: '600',
            lineHeight: responsive.fontSize.m * 1.2,
            marginBottom: responsive.spacing.xs,
          },
          cardHeader: {
            flexDirection: 'row',
            justifyContent: 'space-between',
            alignItems: 'flex-start',
          },
          infoButton: {
            margin: -4,
            marginTop: -6,
            marginRight: -6,
          },
          priceText: {
            color: theme.colors.primary,
            fontWeight: '600',
            fontSize: responsive.fontSize.s,
            marginTop: 2,
          },
          inactiveBadge: {
            position: 'absolute',
            top: 8,
            right: 8,
            backgroundColor: colors.errorContainer,
            paddingHorizontal: 8,
            paddingVertical: 4,
            borderRadius: 4,
          },
          inactiveBadgeText: {
            fontSize: 12,
            color: colors.onErrorContainer,
            fontWeight: '600',
          },
          warningMessage: {
            backgroundColor: colors.warningContainer || colors.errorContainer,
            paddingHorizontal: responsive.spacing.s,
            paddingVertical: responsive.spacing.xs,
            marginTop: responsive.spacing.xs,
          },
          warningMessageText: {
            fontSize: responsive.fontSize.xs,
            color: colors.onWarningContainer || colors.onErrorContainer,
            textAlign: 'center',
            lineHeight: responsive.fontSize.xs * 1.3,
          },
        }),
      [colors, fonts, theme, responsive],
    );

    // Determinar si el item está activo
    const isActive = item.isActive !== false;

    // Verificar si es un producto sin pantalla de preparación
    const isProductWithoutScreen =
      navigationLevel === 'products' &&
      'preparationScreenId' in item &&
      !item.preparationScreenId;

    // Determinar si el card está deshabilitado
    const isDisabled = disabled || !isActive || isProductWithoutScreen;

    // Obtener la URL de la imagen
    const imageSource = item.photo ? item.photo.path : null;

    // Determinar si mostrar el precio
    const shouldShowPrice = () => {
      if (!showPrice) return false;
      if (
        navigationLevel === 'products' &&
        'price' in item &&
        'hasVariants' in item
      ) {
        const productItem = item as Product;
        return (
          !productItem.hasVariants &&
          productItem.price !== null &&
          productItem.price !== undefined
        );
      }
      return false;
    };

    // Determinar si mostrar el botón de información
    const shouldShowInfoButton = () => {
      return (
        navigationLevel === 'products' &&
        'price' in item &&
        'description' in item &&
        (item as Product).description &&
        (item as Product).description.trim() !== '' &&
        onInfoPress
      );
    };

    // Obtener el texto del badge
    const getBadgeText = () => {
      if (!isActive) return 'INACTIVO';
      if (isProductWithoutScreen) return 'NO DISPONIBLE';
      return null;
    };

    const badgeText = getBadgeText();

    return (
      <Card
        style={[styles.cardItem, isDisabled && styles.cardItemInactive]}
        onPress={isDisabled ? undefined : onPress}
        onLongPress={isDisabled ? undefined : onLongPress}
        disabled={isDisabled}
      >
        <AutoImage
          source={imageSource}
          style={[styles.itemImage, isDisabled && styles.imageInactive]}
          contentFit="cover"
          placeholder={blurhash}
          transition={300}
          placeholderIcon="image-outline"
        />

        {badgeText && (
          <View style={styles.inactiveBadge}>
            <Text style={styles.inactiveBadgeText}>{badgeText}</Text>
          </View>
        )}

        <View style={styles.cardContent}>
          {shouldShowInfoButton() ? (
            <View style={styles.cardHeader}>
              <Title style={[styles.cardTitle, { flex: 1 }]}>{item.name}</Title>
              <IconButton
                icon="information-outline"
                size={20}
                onPress={onInfoPress}
                style={styles.infoButton}
              />
            </View>
          ) : (
            <Title style={styles.cardTitle}>{item.name}</Title>
          )}

          {shouldShowPrice() && (
            <Text style={styles.priceText}>
              ${Number((item as Product).price).toFixed(2)}
            </Text>
          )}

          {isProductWithoutScreen && (
            <View style={styles.warningMessage}>
              <Text style={styles.warningMessageText}>
                Sin pantalla de preparación
              </Text>
            </View>
          )}
        </View>
      </Card>
    );
  },
);

MenuItemCard.displayName = 'MenuItemCard';

export default MenuItemCard;

================
File: app/src/modules/orders/components/OrderHeader.tsx
================
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Text, IconButton } from 'react-native-paper';
import CartButton from './CartButton';
import { useAppTheme } from '@/app/styles/theme';

interface OrderHeaderProps {
  title: string;
  itemCount: number;
  onBackPress?: () => void;
  onCartPress: () => void;
  isCartVisible: boolean;
}

const OrderHeader = ({
  title,
  itemCount,
  onBackPress,
  onCartPress,
  isCartVisible,
}: OrderHeaderProps) => {
  const theme = useAppTheme();

  const styles = StyleSheet.create({
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 4,
      paddingVertical: 8,
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      shadowOpacity: 0,
    },
    headerTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
      flex: 1,
    },
    headerSpacer: {
      width: 48,
    },
  });

  return (
    <View style={styles.header}>
      {onBackPress ? (
        <IconButton
          icon="arrow-left"
          size={24}
          onPress={onBackPress}
          iconColor={theme.colors.onSurface}
        />
      ) : (
        <View style={styles.headerSpacer} />
      )}

      <Text style={styles.headerTitle}>{title}</Text>

      {!isCartVisible ? (
        <CartButton itemCount={itemCount} onPress={onCartPress} />
      ) : (
        <View style={styles.headerSpacer} />
      )}
    </View>
  );
};

export default OrderHeader;

================
File: app/src/modules/orders/components/SimpleProductDescriptionModal.tsx
================
import React from 'react';
import { StyleSheet, ScrollView } from 'react-native';
import { Portal, Modal, Text, Title } from 'react-native-paper';
import type { Product } from '@/app/schemas/domain/product.schema';
import { useAppTheme } from '@/app/styles/theme';

interface SimpleProductDescriptionModalProps {
  visible: boolean;
  product: Product | null;
  onDismiss: () => void;
}

const SimpleProductDescriptionModal: React.FC<
  SimpleProductDescriptionModalProps
> = ({ visible, product, onDismiss }) => {
  const theme = useAppTheme();

  const styles = StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: 20,
      padding: 20,
      borderRadius: 8,
      maxHeight: '60%',
    },
    title: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: 16,
      color: theme.colors.onBackground,
    },
    description: {
      fontSize: 16,
      lineHeight: 24,
      color: theme.colors.onSurfaceVariant,
    },
  });

  if (!product || !product.description) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modal}
      >
        <ScrollView>
          <Title style={styles.title}>{product.name}</Title>
          <Text style={styles.description}>{product.description}</Text>
        </ScrollView>
      </Modal>
    </Portal>
  );
};

export default SimpleProductDescriptionModal;

================
File: app/src/modules/orders/hooks/useAdjustmentQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { adjustmentService } from '../services/adjustmentService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { OrderAdjustmentDto } from '../types/update-order.types';

export const useCreateBulkAdjustmentsMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (adjustments: OrderAdjustmentDto[]) =>
      adjustmentService.createBulkAdjustments(adjustments),
    onSuccess: (data, variables) => {
      // Invalidar queries relacionadas
      if (variables.length > 0 && variables[0].orderId) {
        queryClient.invalidateQueries({
          queryKey: ['orders', variables[0].orderId],
        });
        queryClient.invalidateQueries({
          queryKey: ['adjustments', 'order', variables[0].orderId],
        });
      }
      showSnackbar({
        message: 'Ajustes aplicados correctamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al aplicar ajustes',
        type: 'error',
      });
    },
  });
};

export const useOrderAdjustmentsQuery = (orderId: string, enabled = true) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useQuery({
    queryKey: ['adjustments', 'order', orderId],
    queryFn: () => adjustmentService.getOrderAdjustments(orderId),
    enabled: enabled && !!orderId,
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al cargar ajustes',
        type: 'error',
      });
    },
  });
};

export const useDeleteAdjustmentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (adjustmentId: string) =>
      adjustmentService.deleteAdjustment(adjustmentId),
    onSuccess: () => {
      // Invalidar todas las queries de ajustes
      queryClient.invalidateQueries({ queryKey: ['adjustments'] });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Ajuste eliminado correctamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al eliminar ajuste',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/orders/hooks/usePaymentQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { paymentService } from '../services/paymentService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type {
  CreatePaymentDto,
  UpdatePaymentDto,
  PaymentMethod,
  PaymentStatus,
} from '../types/payment.types';

// Query Keys
export const paymentKeys = {
  all: ['payments'] as const,
  lists: () => [...paymentKeys.all, 'list'] as const,
  list: (filters?: {
    orderId?: string;
    paymentMethod?: PaymentMethod;
    paymentStatus?: PaymentStatus;
  }) => [...paymentKeys.lists(), filters] as const,
  details: () => [...paymentKeys.all, 'detail'] as const,
  detail: (id: string) => [...paymentKeys.details(), id] as const,
  byOrder: (orderId: string) => [...paymentKeys.all, 'order', orderId] as const,
};

// Queries
export const useGetPaymentsQuery = (filters?: {
  orderId?: string;
  paymentMethod?: PaymentMethod;
  paymentStatus?: PaymentStatus;
}) => {
  return useQuery({
    queryKey: paymentKeys.list(filters),
    queryFn: () => paymentService.getPayments(filters),
  });
};

export const useGetPaymentByIdQuery = (id: string) => {
  return useQuery({
    queryKey: paymentKeys.detail(id),
    queryFn: () => paymentService.getPaymentById(id),
    enabled: !!id,
  });
};

export const useGetPaymentsByOrderIdQuery = (
  orderId: string,
  options?: { enabled?: boolean },
) => {
  return useQuery({
    queryKey: paymentKeys.byOrder(orderId),
    queryFn: () => paymentService.getPaymentsByOrderId(orderId),
    enabled: options?.enabled !== undefined ? options.enabled : !!orderId,
    initialData: [],
  });
};

// Mutations
export const useCreatePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (dto: CreatePaymentDto) => paymentService.createPayment(dto),
    onSuccess: (data) => {
      // Invalidar queries relacionadas
      queryClient.invalidateQueries({ queryKey: paymentKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: paymentKeys.byOrder(data.orderId),
      });
      // Invalidar también las queries de órdenes para que se actualice el estado de pago
      queryClient.invalidateQueries({ queryKey: ['orders'] });

      showSnackbar({
        message: 'Pago registrado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al registrar el pago',
        type: 'error',
      });
    },
  });
};

export const useUpdatePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, dto }: { id: string; dto: UpdatePaymentDto }) =>
      paymentService.updatePayment(id, dto),
    onSuccess: (data) => {
      // Invalidar queries relacionadas
      queryClient.invalidateQueries({ queryKey: paymentKeys.lists() });
      queryClient.invalidateQueries({ queryKey: paymentKeys.detail(data.id) });
      queryClient.invalidateQueries({
        queryKey: paymentKeys.byOrder(data.orderId),
      });
      // Invalidar también las queries de órdenes para que se actualice el estado de pago
      queryClient.invalidateQueries({ queryKey: ['orders'] });

      showSnackbar({
        message: 'Pago actualizado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al actualizar el pago',
        type: 'error',
      });
    },
  });
};

export const useDeletePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (id: string) => paymentService.deletePayment(id),
    onSuccess: () => {
      // Invalidar todas las queries de pagos
      queryClient.invalidateQueries({ queryKey: paymentKeys.all });
      // Invalidar también las queries de órdenes para que se actualice el estado de pago
      queryClient.invalidateQueries({ queryKey: ['orders'] });

      showSnackbar({
        message: 'Pago eliminado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al eliminar el pago',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/orders/stores/useCartStore.ts
================
import { create } from 'zustand';
import type { Product } from '../types/orders.types';
import type { SelectedPizzaCustomization } from '../../../app/schemas/domain/order.schema';
import { useOrderFormStore } from './useOrderFormStore';

const generateId = () => {
  const timestamp = Date.now().toString();
  const random1 = Math.floor(Math.random() * 1000000).toString();
  const random2 = Math.floor(Math.random() * 1000000).toString();
  return `${timestamp}-${random1}-${random2}`;
};

export interface CartItemModifier {
  id: string;
  modifierGroupId: string;
  name: string;
  price: number;
}

export interface CartItem {
  id: string;
  productId: string;
  productName: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  modifiers: CartItemModifier[];
  variantId?: string;
  variantName?: string;
  preparationNotes?: string;
  notes?: string;
  preparationStatus?:
    | 'NEW'
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'CANCELLED';
  selectedPizzaCustomizations?: SelectedPizzaCustomization[];
  pizzaExtraCost?: number;
}

interface CartStore {
  items: CartItem[];
  isCartVisible: boolean;
  
  // Actions
  addItem: (
    product: Product,
    quantity?: number,
    variantId?: string,
    modifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  removeItem: (itemId: string) => void;
  updateItemQuantity: (itemId: string, quantity: number) => void;
  updateItem: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  clearCart: () => void;
  setItems: (items: CartItem[]) => void;
  showCart: () => void;
  hideCart: () => void;
}

// Selectores para valores computados
export const useCartSubtotal = () => useCartStore((state) => 
  state.items.reduce((sum, item) => sum + item.totalPrice, 0)
);

export const useCartTotal = () => useCartSubtotal();

export const useCartItemsCount = () => useCartStore((state) => 
  state.items.reduce((sum, item) => sum + item.quantity, 0)
);

export const useIsCartEmpty = () => useCartStore((state) => state.items.length === 0);

// Función para limpiar tanto el cart como el formulario
export const useClearAll = () => {
  const clearCart = useCartStore((state) => state.clearCart);
  const clearForm = useOrderFormStore((state) => state.clearForm);
  
  return () => {
    clearCart();
    clearForm();
  };
};

export const useCartStore = create<CartStore>((set, get) => ({
  items: [],
  isCartVisible: false,
  
  // Actions
  addItem: (
    product: Product,
    quantity: number = 1,
    variantId?: string,
    modifiers: CartItemModifier[] = [],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost: number = 0,
  ) => {
    const { items } = get();
    
    const variantToAdd = variantId
      ? product.variants?.find((v) => v.id === variantId)
      : undefined;

    // Validar y sanitizar precios
    const safeParsePrice = (price: any): number => {
      const parsed = Number(price);
      if (isNaN(parsed) || !isFinite(parsed) || parsed < 0) {
        return 0;
      }
      return Math.min(Math.round(parsed * 100) / 100, 999999.99);
    };

    const unitPrice = variantToAdd
      ? safeParsePrice(variantToAdd.price)
      : safeParsePrice(product.price);

    const modifiersPrice = modifiers.reduce(
      (sum, mod) => sum + safeParsePrice(mod.price || 0),
      0,
    );

    // Buscar si existe un item idéntico
    const existingItemIndex = items.findIndex((item) => {
      if (item.productId !== product.id) return false;
      if (item.variantId !== variantId) return false;
      if (item.preparationNotes !== preparationNotes) return false;
      if (item.modifiers.length !== modifiers.length) return false;

      // Comparar modifiers
      const sortedExistingModifiers = [...item.modifiers].sort((a, b) =>
        a.id.localeCompare(b.id),
      );
      const sortedNewModifiers = [...modifiers].sort((a, b) =>
        a.id.localeCompare(b.id),
      );

      for (let i = 0; i < sortedExistingModifiers.length; i++) {
        if (
          sortedExistingModifiers[i].id !== sortedNewModifiers[i].id ||
          sortedExistingModifiers[i].name !== sortedNewModifiers[i].name ||
          sortedExistingModifiers[i].price !== sortedNewModifiers[i].price
        ) {
          return false;
        }
      }

      // Comparar pizza customizations
      const existingCustomizations = item.selectedPizzaCustomizations || [];
      const newCustomizations = selectedPizzaCustomizations || [];

      if (existingCustomizations.length !== newCustomizations.length)
        return false;

      const sortedExistingCustomizations = [...existingCustomizations].sort(
        (a, b) =>
          `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
            `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
          ),
      );
      const sortedNewCustomizations = [...newCustomizations].sort((a, b) =>
        `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
          `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
        ),
      );

      for (let i = 0; i < sortedExistingCustomizations.length; i++) {
        if (
          sortedExistingCustomizations[i].pizzaCustomizationId !==
            sortedNewCustomizations[i].pizzaCustomizationId ||
          sortedExistingCustomizations[i].half !==
            sortedNewCustomizations[i].half ||
          sortedExistingCustomizations[i].action !==
            sortedNewCustomizations[i].action
        ) {
          return false;
        }
      }

      return true;
    });

    if (existingItemIndex !== -1) {
      // Si existe un item idéntico, actualizar la cantidad
      const updatedItems = [...items];
      const existingItem = updatedItems[existingItemIndex];
      const newQuantity = existingItem.quantity + quantity;
      const newTotalPrice =
        (existingItem.unitPrice + modifiersPrice + pizzaExtraCost) *
        newQuantity;

      updatedItems[existingItemIndex] = {
        ...existingItem,
        quantity: newQuantity,
        totalPrice: newTotalPrice,
        pizzaExtraCost,
      };

      set({ items: updatedItems });
    } else {
      // Si no existe, crear un nuevo item
      const newItem: CartItem = {
        id: generateId(),
        productId: product.id,
        productName: product.name,
        quantity,
        unitPrice: unitPrice as number,
        totalPrice:
          ((unitPrice as number) + modifiersPrice + pizzaExtraCost) *
          quantity,
        modifiers,
        variantId,
        variantName: variantToAdd?.name,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      };

      set({ items: [...items, newItem] });
    }
  },

  removeItem: (itemId: string) => {
    const { items } = get();
    set({ items: items.filter((item) => item.id !== itemId) });
  },

  updateItemQuantity: (itemId: string, quantity: number) => {
    const { items, removeItem } = get();
    
    // Validar y sanitizar cantidad
    const safeQuantity = Math.round(quantity);

    if (safeQuantity <= 0 || isNaN(safeQuantity)) {
      removeItem(itemId);
      return;
    }

    // Límite máximo razonable
    const MAX_QUANTITY = 9999;
    const finalQuantity = Math.min(safeQuantity, MAX_QUANTITY);

    const updatedItems = items.map((item) => {
      if (item.id === itemId) {
        const modifiersPrice = item.modifiers.reduce(
          (sum, mod) => sum + Number(mod.price || 0),
          0,
        );
        const pizzaExtraCost = item.pizzaExtraCost || 0;
        const newTotalPrice =
          (item.unitPrice + modifiersPrice + pizzaExtraCost) *
          finalQuantity;
        return {
          ...item,
          quantity: finalQuantity,
          totalPrice: newTotalPrice,
        };
      }
      return item;
    });

    set({ items: updatedItems });
  },

  updateItem: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost: number = 0,
  ) => {
    const { items } = get();
    
    const updatedItems = items.map((item) => {
      if (item.id === itemId) {
        const modifiersPrice = modifiers.reduce(
          (sum, mod) => sum + Number(mod.price || 0),
          0,
        );
        const finalUnitPrice =
          unitPrice !== undefined ? unitPrice : item.unitPrice;
        const newTotalPrice =
          (finalUnitPrice + modifiersPrice + pizzaExtraCost) * quantity;
        return {
          ...item,
          quantity,
          modifiers,
          preparationNotes:
            preparationNotes !== undefined
              ? preparationNotes
              : item.preparationNotes,
          variantId: variantId !== undefined ? variantId : item.variantId,
          variantName:
            variantName !== undefined ? variantName : item.variantName,
          unitPrice: finalUnitPrice,
          totalPrice: newTotalPrice,
          selectedPizzaCustomizations:
            selectedPizzaCustomizations !== undefined
              ? selectedPizzaCustomizations
              : item.selectedPizzaCustomizations,
          pizzaExtraCost,
        };
      }
      return item;
    });

    set({ items: updatedItems });
  },

  clearCart: () => {
    set({ items: [] });
  },

  setItems: (items: CartItem[]) => {
    set({ items });
  },

  showCart: () => {
    set({ isCartVisible: true });
  },

  hideCart: () => {
    set({ isCartVisible: false });
  },
}));

================
File: app/src/modules/orders/stores/useOrderFormStore.ts
================
import { create } from 'zustand';
import { OrderTypeEnum, type OrderType } from '../types/orders.types';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';

interface OrderFormStore {
  // Estado del formulario de la orden
  orderType: OrderType;
  selectedAreaId: string | null;
  selectedTableId: string | null;
  isTemporaryTable: boolean;
  temporaryTableName: string;
  scheduledTime: Date | null;
  deliveryInfo: DeliveryInfo;
  orderNotes: string;

  // Estado del prepago
  prepaymentId: string | null;
  prepaymentAmount: string;
  prepaymentMethod: 'CASH' | 'CARD' | 'TRANSFER' | null;

  // Actions
  setOrderType: (type: OrderType) => void;
  setSelectedAreaId: (id: string | null) => void;
  setSelectedTableId: (id: string | null) => void;
  setIsTemporaryTable: (isTemp: boolean) => void;
  setTemporaryTableName: (name: string) => void;
  setScheduledTime: (time: Date | null) => void;
  setDeliveryInfo: (info: DeliveryInfo) => void;
  setOrderNotes: (notes: string) => void;
  setPrepaymentId: (id: string | null) => void;
  setPrepaymentAmount: (amount: string) => void;
  setPrepaymentMethod: (method: 'CASH' | 'CARD' | 'TRANSFER' | null) => void;
  clearForm: () => void;
}

export const useOrderFormStore = create<OrderFormStore>((set) => ({
  // Estado inicial del formulario
  orderType: OrderTypeEnum.DINE_IN,
  selectedAreaId: null,
  selectedTableId: null,
  isTemporaryTable: false,
  temporaryTableName: '',
  scheduledTime: null,
  deliveryInfo: {},
  orderNotes: '',

  // Estado inicial del prepago
  prepaymentId: null,
  prepaymentAmount: '',
  prepaymentMethod: null,

  // Actions
  setOrderType: (type: OrderType) => {
    set({ orderType: type });
  },

  setSelectedAreaId: (id: string | null) => {
    set({ selectedAreaId: id });
  },

  setSelectedTableId: (id: string | null) => {
    set({ selectedTableId: id });
  },

  setIsTemporaryTable: (isTemp: boolean) => {
    set({ isTemporaryTable: isTemp });
  },

  setTemporaryTableName: (name: string) => {
    set({ temporaryTableName: name });
  },

  setScheduledTime: (time: Date | null) => {
    set({ scheduledTime: time });
  },

  setDeliveryInfo: (info: DeliveryInfo) => {
    set({ deliveryInfo: info });
  },

  setOrderNotes: (notes: string) => {
    set({ orderNotes: notes });
  },

  setPrepaymentId: (id: string | null) => {
    set({ prepaymentId: id });
  },

  setPrepaymentAmount: (amount: string) => {
    set({ prepaymentAmount: amount });
  },

  setPrepaymentMethod: (method: 'CASH' | 'CARD' | 'TRANSFER' | null) => {
    set({ prepaymentMethod: method });
  },

  clearForm: () => {
    set({
      orderType: OrderTypeEnum.DINE_IN,
      selectedAreaId: null,
      selectedTableId: null,
      isTemporaryTable: false,
      temporaryTableName: '',
      scheduledTime: null,
      deliveryInfo: {},
      orderNotes: '',
      prepaymentId: null,
      prepaymentAmount: '',
      prepaymentMethod: null,
    });
  },
}));

================
File: app/src/modules/orders/types/adjustments.types.ts
================
export interface OrderAdjustment {
  id?: string;
  name: string;
  isPercentage: boolean;
  value?: number; // Porcentaje (0-100) si isPercentage es true
  amount?: number; // Monto fijo si isPercentage es false (puede ser negativo para descuentos)
  // Para UI local
  isNew?: boolean;
  isDeleted?: boolean;
}

export interface AdjustmentFormData {
  name: string;
  isPercentage: boolean;
  value?: number;
  amount?: number;
}

================
File: app/src/modules/orders/types/update-order.types.ts
================
import type { OrderType } from './orders.types';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';

// Interfaz para modificadores de producto
export interface ProductModifierDto {
  modifierId: string;
}

// Interfaz para personalizaciones de pizza seleccionadas
export interface SelectedPizzaCustomizationDto {
  pizzaCustomizationId: string;
  half: 'FULL' | 'HALF_1' | 'HALF_2';
  action: 'ADD' | 'REMOVE';
}

// Interfaz para items en el DTO de actualización
export interface OrderItemDtoForBackend {
  id?: string;
  productId: string;
  productVariantId?: string | null;
  quantity: number; // NOTA: Siempre será 1, el backend ya no maneja cantidades
  basePrice: number;
  finalPrice: number;
  preparationNotes?: string | null;
  productModifiers?: ProductModifierDto[]; // Array de objetos con modifierId
  selectedPizzaCustomizations?: SelectedPizzaCustomizationDto[]; // Personalizaciones de pizza
}

// Interfaz para ajustes en el DTO
export interface OrderAdjustmentDto {
  orderId?: string;
  name: string;
  isPercentage: boolean;
  value?: number;
  amount?: number;
}

// Interfaz para el payload de actualización de orden
export interface UpdateOrderPayload {
  orderType?: OrderType;
  items?: OrderItemDtoForBackend[];
  tableId?: string | null;
  scheduledAt?: Date | null;
  deliveryInfo?: DeliveryInfo;
  notes?: string | null;
  status?: Order['orderStatus'];
  total?: number;
  subtotal?: number;
  adjustments?: OrderAdjustmentDto[];
}

================
File: app/src/modules/pizzaCustomizations/components/index.ts
================
// Componentes principales usados en screens
export { PizzaProductsTab } from './PizzaProductsTab';
export { PizzaCustomizationsTab } from './PizzaCustomizationsTab';
export { PizzaCustomizationFormModal } from './PizzaCustomizationFormModal';

// Los siguientes componentes son internos y no necesitan ser exportados
// PizzaCustomizationCard - usado solo en PizzaCustomizationsTab
// PizzaConfigurationModal - usado solo en PizzaProductsTab
// AssociatePizzaToppingsModal - usado solo en PizzaProductsTab
// PizzaCustomizationDetailModal - usado solo en PizzaCustomizationsTab

================
File: app/src/modules/pizzaCustomizations/components/PizzaProductsTab.tsx
================
import React, { useState, useMemo } from 'react';
import { View, StyleSheet, FlatList, RefreshControl } from 'react-native';
import {
  Surface,
  Text,
  IconButton,
  Chip,
  ActivityIndicator,
  Menu,
  Searchbar,
  Badge,
  Avatar,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import { productsService } from '@/modules/menu/services/productsService';
import EmptyState from '@/app/components/common/EmptyState';
import { Product } from '@/modules/menu/schema/products.schema';
import { getImageUrl } from '@/app/lib/imageUtils';
import { PizzaConfigurationModal } from './PizzaConfigurationModal';
import { AssociatePizzaToppingsModal } from './AssociatePizzaToppingsModal';

export function PizzaProductsTab() {
  const theme = useAppTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const [filter, setFilter] = useState<'all' | 'configured' | 'not_configured'>(
    'all',
  );
  const [configModalVisible, setConfigModalVisible] = useState(false);
  const [ingredientsModalVisible, setIngredientsModalVisible] = useState(false);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);

  const { data, isLoading, refetch, isRefetching } = useQuery({
    queryKey: ['pizza-products', filter],
    queryFn: async () => {
      const pizzaProducts = await productsService.findAllPizzas();
      return pizzaProducts;
    },
  });

  const filteredProducts = useMemo(() => {
    if (!data) return [];

    let filtered = data.filter((product) =>
      product.name.toLowerCase().includes(searchQuery.toLowerCase()),
    );

    if (filter === 'configured') {
      filtered = filtered.filter((product) => product.pizzaConfiguration);
    } else if (filter === 'not_configured') {
      filtered = filtered.filter((product) => !product.pizzaConfiguration);
    }

    return filtered;
  }, [data, searchQuery, filter]);

  const renderProductItem = ({ item }: { item: Product }) => {
    const isConfigured = !!item.pizzaConfiguration;
    const customizations = item.pizzaCustomizations || [];
    const flavorsCount = customizations.filter(
      (c: any) => c.type === 'FLAVOR',
    ).length;
    const ingredientsCount = customizations.filter(
      (c: any) => c.type === 'INGREDIENT',
    ).length;
    const imageUrl = item.photo?.path ? getImageUrl(item.photo.path) : null;
    const variantsCount = item.variants?.length || 0;

    return (
      <Surface style={styles.productCard} elevation={2}>
        <View style={styles.productHeader}>
          <View style={styles.productTitleRow}>
            {imageUrl ? (
              <Avatar.Image
                size={48}
                source={{ uri: imageUrl }}
                style={styles.productImage}
              />
            ) : (
              <Avatar.Icon
                size={48}
                icon="pizza"
                style={[
                  styles.productImage,
                  { backgroundColor: theme.colors.primaryContainer },
                ]}
              />
            )}

            <View style={styles.productInfo}>
              <Text
                variant="titleMedium"
                style={styles.productName}
                numberOfLines={1}
              >
                {item.name}
              </Text>
              <Text variant="bodySmall" style={styles.variantText}>
                {variantsCount > 0
                  ? `${variantsCount} variantes`
                  : 'Sin variantes'}
              </Text>
            </View>

            <View style={styles.productActions}>
              <IconButton
                icon="cog"
                mode="contained-tonal"
                size={28}
                onPress={() => {
                  setSelectedProduct(item);
                  setConfigModalVisible(true);
                }}
                style={styles.actionButton}
              />
              <IconButton
                icon="cheese"
                mode="contained-tonal"
                size={28}
                onPress={() => {
                  setSelectedProduct(item);
                  setIngredientsModalVisible(true);
                }}
                style={styles.actionButton}
              />
            </View>
          </View>
        </View>

        <View style={styles.productStatus}>
          <Chip
            mode="flat"
            compact
            icon={isConfigured ? 'check-circle' : 'alert-circle'}
            style={[
              styles.statusChip,
              {
                backgroundColor: isConfigured
                  ? theme.colors.primaryContainer
                  : theme.colors.errorContainer,
              },
            ]}
            textStyle={styles.chipText}
          >
            {isConfigured ? 'Configurada' : 'Sin configurar'}
          </Chip>

          <View style={styles.countsContainer}>
            <Text variant="bodySmall" style={styles.countText}>
              {flavorsCount} sabores
            </Text>
            <Text variant="bodySmall" style={styles.countDivider}>
              •
            </Text>
            <Text variant="bodySmall" style={styles.countText}>
              {ingredientsCount} ingredientes
            </Text>
          </View>
        </View>
      </Surface>
    );
  };

  const hasActiveFilter = filter !== 'all';

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      padding: theme.spacing.m,
      backgroundColor: theme.colors.background,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: theme.spacing.xs,
    },
    content: {
      flex: 1,
    },
    listContent: {
      paddingVertical: theme.spacing.m,
    },
    productCard: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      overflow: 'hidden',
      elevation: 1,
    },
    productHeader: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    productTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    productImage: {
      marginRight: theme.spacing.m,
    },
    productInfo: {
      flex: 1,
    },
    productName: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: 2,
    },
    variantText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    productStatus: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: theme.spacing.m,
      paddingBottom: theme.spacing.m,
    },
    statusChip: {
      height: 28,
    },
    chipText: {
      fontSize: 12,
      marginHorizontal: theme.spacing.xs,
      marginVertical: 2,
    },
    ingredientCount: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    countsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    countText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    countDivider: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginHorizontal: 2,
    },
    productActions: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      marginLeft: theme.spacing.s,
    },
    actionButton: {
      margin: 0,
      width: 48,
      height: 48,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
  });

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder="Buscar pizzas..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={hasActiveFilter ? 'filter-check' : 'filter-variant'}
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                  iconColor={
                    hasActiveFilter
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setFilter('all');
                  setFilterMenuVisible(false);
                }}
                title="Todas"
                leadingIcon="filter-variant"
                trailingIcon={filter === 'all' ? 'check' : undefined}
                titleStyle={
                  filter === 'all'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setFilter('configured');
                  setFilterMenuVisible(false);
                }}
                title="Configuradas"
                leadingIcon="check-circle"
                trailingIcon={filter === 'configured' ? 'check' : undefined}
                titleStyle={
                  filter === 'configured'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setFilter('not_configured');
                  setFilterMenuVisible(false);
                }}
                title="Sin Configurar"
                leadingIcon="alert-circle"
                trailingIcon={filter === 'not_configured' ? 'check' : undefined}
                titleStyle={
                  filter === 'not_configured'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
            </Menu>
            {hasActiveFilter && <Badge style={styles.filterBadge} size={8} />}
          </View>
        </View>
      </View>

      <FlatList
        data={filteredProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={refetch}
            colors={[theme.colors.primary]}
          />
        }
        ListEmptyComponent={
          <EmptyState
            title="No hay pizzas"
            message={
              filter === 'not_configured'
                ? 'No hay pizzas sin configurar'
                : filter === 'configured'
                  ? 'No hay pizzas configuradas'
                  : 'No hay productos tipo pizza creados'
            }
            icon="pizza"
          />
        }
      />

      <PizzaConfigurationModal
        visible={configModalVisible}
        onDismiss={() => {
          setConfigModalVisible(false);
          setSelectedProduct(null);
        }}
        product={selectedProduct}
      />

      <AssociatePizzaToppingsModal
        visible={ingredientsModalVisible}
        onDismiss={() => {
          setIngredientsModalVisible(false);
          setSelectedProduct(null);
        }}
        product={selectedProduct}
      />
    </View>
  );
}

================
File: app/src/modules/pizzaCustomizations/hooks/usePizzaCustomizationsQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { pizzaCustomizationsService } from '../services/pizzaCustomizationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { FindAllPizzaCustomizationsQuery } from '../schema/pizzaCustomization.schema';

const PIZZA_CUSTOMIZATIONS_QUERY_KEYS = {
  all: ['pizzaCustomizations'] as const,
  lists: () => [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.all, 'list'] as const,
  list: (params?: FindAllPizzaCustomizationsQuery) =>
    [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(), params] as const,
  details: () => [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.all, 'detail'] as const,
  detail: (id: string) =>
    [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.details(), id] as const,
};

export function usePizzaCustomizationsList(
  params?: FindAllPizzaCustomizationsQuery,
) {
  return useQuery({
    queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.list(params),
    queryFn: () => pizzaCustomizationsService.findAll(params),
  });
}

export function usePizzaCustomization(id: string) {
  return useQuery({
    queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.detail(id),
    queryFn: () => pizzaCustomizationsService.findOne(id),
    enabled: !!id,
  });
}

export function useCreatePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: pizzaCustomizationsService.create,
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      showSnackbar({
        message: 'Personalización creada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al crear personalización',
        type: 'error',
      });
    },
  });
}

export function useUpdatePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({
      id,
      data,
    }: {
      id: string;
      data: Parameters<typeof pizzaCustomizationsService.update>[1];
    }) => pizzaCustomizationsService.update(id, data),
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.detail(variables.id),
      });
      showSnackbar({
        message: 'Personalización actualizada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al actualizar personalización',
        type: 'error',
      });
    },
  });
}

export function useDeletePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: pizzaCustomizationsService.remove,
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      showSnackbar({
        message: 'Personalización eliminada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al eliminar personalización',
        type: 'error',
      });
    },
  });
}

================
File: app/src/modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PizzaManagementScreen } from '../screens/PizzaManagementScreen';
import type { PizzaCustomizationsStackParamList } from './types';

const Stack = createNativeStackNavigator<PizzaCustomizationsStackParamList>();

export function PizzaCustomizationsStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="PizzaCustomizationsList"
        component={PizzaManagementScreen}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/pizzaCustomizations/navigation/types.ts
================
export type PizzaCustomizationsStackParamList = {
  PizzaCustomizationsList: undefined;
};

================
File: app/src/modules/pizzaCustomizations/schema/pizzaConfiguration.schema.ts
================
import { z } from 'zod';

export const pizzaConfigurationFormSchema = z.object({
  productId: z.string().min(1, 'El producto es requerido'),
  includedToppings: z
    .number()
    .min(0, 'Los toppings incluidos deben ser mayor o igual a 0')
    .default(4),
  extraToppingCost: z
    .number()
    .min(0, 'El costo extra debe ser mayor o igual a 0')
    .default(20),
});

export type PizzaConfigurationFormInputs = z.infer<
  typeof pizzaConfigurationFormSchema
>;

export const updatePizzaConfigurationSchema = z.object({
  includedToppings: z.number().min(0).optional(),
  extraToppingCost: z.number().min(0).optional(),
});

export type UpdatePizzaConfigurationInputs = z.infer<
  typeof updatePizzaConfigurationSchema
>;

================
File: app/src/modules/pizzaCustomizations/schema/pizzaCustomization.schema.ts
================
import { z } from 'zod';
import { CustomizationType } from '../types/pizzaCustomization.types';

export const pizzaCustomizationFormSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  type: z.nativeEnum(CustomizationType),
  ingredients: z.string().optional().nullable(),
  toppingValue: z
    .number()
    .min(0, 'El valor debe ser mayor o igual a 0')
    .default(1),
  isActive: z.boolean().default(true),
  sortOrder: z.number().default(0),
});

export type PizzaCustomizationFormInputs = z.infer<
  typeof pizzaCustomizationFormSchema
>;

export const findAllPizzaCustomizationsQuerySchema = z.object({
  page: z.number().optional(),
  limit: z.number().optional(),
  search: z.string().optional(),
  type: z.nativeEnum(CustomizationType).optional(),
  isActive: z.boolean().optional(),
});

export type FindAllPizzaCustomizationsQuery = z.infer<
  typeof findAllPizzaCustomizationsQuerySchema
>;

================
File: app/src/modules/pizzaCustomizations/types/pizzaConfiguration.types.ts
================
export interface PizzaConfiguration {
  id: string;
  productId: string;
  includedToppings: number;
  extraToppingCost: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreatePizzaConfigurationInput {
  productId: string;
  includedToppings: number;
  extraToppingCost: number;
}

export interface UpdatePizzaConfigurationInput {
  includedToppings?: number;
  extraToppingCost?: number;
}

================
File: app/src/modules/pizzaCustomizations/types/pizzaCustomization.types.ts
================
export enum CustomizationType {
  FLAVOR = 'FLAVOR',
  INGREDIENT = 'INGREDIENT',
}

export enum PizzaHalf {
  FULL = 'FULL',
  HALF_1 = 'HALF_1',
  HALF_2 = 'HALF_2',
}

export enum CustomizationAction {
  ADD = 'ADD',
  REMOVE = 'REMOVE',
}

export interface PizzaCustomization {
  id: string;
  name: string;
  type: CustomizationType;
  ingredients?: string | null;
  toppingValue: number;
  isActive: boolean;
  sortOrder: number;
  productIds?: string[];
  products?: { id: string; name: string }[];
  createdAt: string;
  updatedAt: string;
}

export interface SelectedPizzaCustomization {
  id: string;
  orderItemId: string;
  pizzaCustomizationId: string;
  pizzaCustomization?: PizzaCustomization;
  half: PizzaHalf;
  action: CustomizationAction;
  createdAt: string;
  updatedAt: string;
}

================
File: app/src/modules/preparationScreens/navigation/PreparationScreensStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PreparationScreensStackParamList } from './types';
import PreparationScreensScreen from '../screens/PreparationScreensScreen';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';

const Stack = createNativeStackNavigator<PreparationScreensStackParamList>();

const PreparationScreensStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="PreparationScreensList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="PreparationScreensList"
        component={PreparationScreensScreen}
        options={{
          title: 'Pantallas de Preparación',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

export default PreparationScreensStackNavigator;

================
File: app/src/modules/preparationScreens/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '../../../app/navigation/types';

// Definir los parámetros para cada pantalla dentro de este Stack Navigator
export type PreparationScreensStackParamList = {
  PreparationScreensList: undefined; // La pantalla de lista no recibe parámetros
};

// Tipos específicos para las props de cada pantalla del Stack
export type PreparationScreensListScreenProps = NativeStackScreenProps<
  PreparationScreensStackParamList,
  'PreparationScreensList'
>;

// Tipo para las props de este Stack cuando se usa dentro del Drawer principal
export type PreparationScreensDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'PreparationScreensStack'
>;

================
File: app/src/modules/printers/navigation/PrintersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PrintersStackParamList } from './types';
import PrintersScreen from '../screens/PrintersScreen'; // Importar la pantalla creada
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';

const Stack = createNativeStackNavigator<PrintersStackParamList>();

const PrintersStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="PrintersList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="PrintersList"
        component={PrintersScreen}
        options={{
          title: 'Impresoras', // Título para la pantalla de lista
        }}
      />
    </Stack.Navigator>
  );
};

export default PrintersStackNavigator;

================
File: app/src/modules/printers/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '@/app/navigation/types'; // Importar tipos del Drawer principal

export type PrintersStackParamList = {
  PrintersList: undefined; // La pantalla de lista no recibe parámetros
};

export type PrintersListScreenProps = NativeStackScreenProps<
  PrintersStackParamList,
  'PrintersList'
>;

export type PrintersDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'PrintersStack' // El nombre que le daremos en el Drawer Navigator
>;

================
File: app/src/modules/printers/types/printer.types.ts
================
import { z } from 'zod'; // Importar z para inferir tipos si es necesario
// Importar tipos y esquemas Zod desde el nuevo archivo
import {
  thermalPrinterSchema,
  createThermalPrinterDtoSchema,
  updateThermalPrinterDtoSchema,
  findAllThermalPrintersFilterSchema,
  discoveredPrinterSchema,
  PrinterConnectionTypeSchema,
} from '../schema/printer.schema';
import type { BaseListQueryDto } from '../../../app/types/api.types';

// Exportar tipos inferidos de Zod
export type ThermalPrinter = z.infer<typeof thermalPrinterSchema>;
export type CreateThermalPrinterDto = z.infer<
  typeof createThermalPrinterDtoSchema
>;
export type UpdateThermalPrinterDto = z.infer<
  typeof updateThermalPrinterDtoSchema
>;
export type FindAllThermalPrintersDto = z.infer<
  typeof findAllThermalPrintersFilterSchema
> &
  BaseListQueryDto; // Combinar con paginación base
export type DiscoveredPrinter = z.infer<typeof discoveredPrinterSchema>;
export type PrinterConnectionType = z.infer<typeof PrinterConnectionTypeSchema>;

// Las interfaces originales se comentan o eliminan ya que los tipos Zod son la fuente de verdad
// export interface DiscoveredPrinter { ... }
// export interface ThermalPrinter { ... }

================
File: app/src/modules/receipts/navigation/ReceiptsStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ReceiptsScreen } from '../screens/ReceiptsScreen';
import { getStackHeaderOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';

export type ReceiptsStackParamList = {
  ReceiptsList: undefined;
};

const Stack = createNativeStackNavigator<ReceiptsStackParamList>();

export const ReceiptsStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="ReceiptsList"
        component={ReceiptsScreen}
        options={{
          title: 'Recibos',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/receipts/navigation/types.ts
================
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RouteProp } from '@react-navigation/native';

export type ReceiptsStackParamList = {
  ReceiptsList: undefined;
};

export type ReceiptsListScreenNavigationProp = NativeStackNavigationProp<
  ReceiptsStackParamList,
  'ReceiptsList'
>;

export type ReceiptsListScreenRouteProp = RouteProp<
  ReceiptsStackParamList,
  'ReceiptsList'
>;

================
File: app/src/modules/restaurantConfig/hooks/useRestaurantConfigQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { restaurantConfigService } from '../services/restaurantConfigService';
import { UpdateRestaurantConfigDto } from '../types/restaurantConfig.types';
import { useSnackbarStore } from '@/app/store/snackbarStore';

const QUERY_KEYS = {
  config: ['restaurantConfig'],
};

export const useRestaurantConfigQueries = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const useGetConfig = () => {
    return useQuery({
      queryKey: QUERY_KEYS.config,
      queryFn: restaurantConfigService.getConfig,
    });
  };

  const useUpdateConfig = (options?: { successMessage?: string }) => {
    return useMutation({
      mutationFn: (data: UpdateRestaurantConfigDto) =>
        restaurantConfigService.updateConfig(data),
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: QUERY_KEYS.config });
        showSnackbar({
          message:
            options?.successMessage || 'Configuración actualizada exitosamente',
          type: 'success',
        });
      },
      onError: (error: any) => {
        showSnackbar({
          message:
            error.response?.data?.message ||
            'Error al actualizar la configuración',
          type: 'error',
        });
      },
    });
  };

  return {
    useGetConfig,
    useUpdateConfig,
  };
};

================
File: app/src/modules/restaurantConfig/navigation/RestaurantConfigStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';
import RestaurantConfigScreen from '../screens/RestaurantConfigScreen';
import { RestaurantConfigStackParamList } from './types';

const Stack = createNativeStackNavigator<RestaurantConfigStackParamList>();

export const RestaurantConfigStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="RestaurantConfig"
        component={RestaurantConfigScreen}
        options={{
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/restaurantConfig/navigation/types.ts
================
export type RestaurantConfigStackParamList = {
  RestaurantConfig: undefined;
};

================
File: app/src/modules/restaurantConfig/services/restaurantConfigService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  RestaurantConfig,
  UpdateRestaurantConfigDto,
} from '../types/restaurantConfig.types';

export const restaurantConfigService = {
  getConfig: async (): Promise<RestaurantConfig> => {
    const response = await apiClient.get<RestaurantConfig>(
      API_PATHS.RESTAURANT_CONFIG,
    );
    if (!response.data) {
      throw new Error('No se pudo obtener la configuración del restaurante');
    }
    return response.data;
  },

  updateConfig: async (
    data: UpdateRestaurantConfigDto,
  ): Promise<RestaurantConfig> => {
    const response = await apiClient.put<RestaurantConfig>(
      API_PATHS.RESTAURANT_CONFIG,
      data,
    );
    if (!response.data) {
      throw new Error('No se pudo actualizar la configuración del restaurante');
    }
    return response.data;
  },
};

================
File: app/src/modules/users/components/index.ts
================
export * from './UserFormModal';
export * from './UserDetailModal';

================
File: app/src/modules/users/hooks/index.ts
================
export * from './useUsers';

================
File: app/src/modules/users/hooks/useUsers.tsx
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { usersApiService } from '../services';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { CreateUserDto, UpdateUserDto, UsersQuery } from '../types';

const USERS_QUERY_KEY = 'users';

export function useGetUsers(params?: UsersQuery) {
  return useQuery({
    queryKey: [USERS_QUERY_KEY, params],
    queryFn: () => usersApiService.findAll(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useGetUser(id?: string) {
  return useQuery({
    queryKey: [USERS_QUERY_KEY, id],
    queryFn: () => (id ? usersApiService.findOne(id) : Promise.resolve(null)),
    enabled: !!id,
    staleTime: 5 * 60 * 1000,
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (data: CreateUserDto) => usersApiService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      showSnackbar({
        message: 'Usuario creado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al crear usuario',
        type: 'error',
      });
    },
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateUserDto }) =>
      usersApiService.update(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      queryClient.invalidateQueries({
        queryKey: [USERS_QUERY_KEY, variables.id],
      });
      showSnackbar({
        message: 'Usuario actualizado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al actualizar usuario',
        type: 'error',
      });
    },
  });
}

export function useDeleteUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: async (id: string) => {
      await usersApiService.remove(id);
      return id;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      showSnackbar({
        message: 'Usuario eliminado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al eliminar usuario',
        type: 'error',
      });
    },
  });
}

export function useResetPassword() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, password }: { id: string; password: string }) =>
      usersApiService.resetPassword(id, password),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: [USERS_QUERY_KEY, variables.id],
      });
      showSnackbar({
        message: 'Contraseña actualizada exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al cambiar contraseña',
        type: 'error',
      });
    },
  });
}

export function useToggleUserActive() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, isActive }: { id: string; isActive: boolean }) =>
      usersApiService.toggleActive(id, isActive),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      queryClient.invalidateQueries({
        queryKey: [USERS_QUERY_KEY, variables.id],
      });
      showSnackbar({
        message: `Usuario ${variables.isActive ? 'activado' : 'desactivado'} exitosamente`,
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message:
          error.response?.data?.message ||
          'Error al cambiar estado del usuario',
        type: 'error',
      });
    },
  });
}

================
File: app/src/modules/users/navigation/UsersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { UsersListScreen } from '../screens';

export type UsersStackParamList = {
  UsersList: undefined;
};

const Stack = createNativeStackNavigator<UsersStackParamList>();

export function UsersStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="UsersList"
        component={UsersListScreen}
        options={{
          title: 'Usuarios',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/users/screens/index.ts
================
export * from './UsersListScreen';

================
File: app/src/modules/users/services/index.ts
================
export * from './usersApi.service';

================
File: app/src/modules/users/types/index.ts
================
export * from './user.types';

================
File: app/src/modules/users/types/user.types.ts
================
export enum GenderEnum {
  MALE = 'male',
  FEMALE = 'female',
  OTHER = 'other',
}

export interface User {
  id: string;
  email?: string | null;
  username: string;
  firstName?: string | null;
  lastName?: string | null;
  birthDate?: string | null;
  gender?: GenderEnum | null;
  phoneNumber?: string | null;
  address?: string | null;
  city?: string | null;
  state?: string | null;
  country?: string | null;
  zipCode?: string | null;
  emergencyContact?: {
    name?: string;
    phone?: string;
    relationship?: string;
  } | null;
  isActive: boolean;
  role?: Role;
  preparationScreen?: {
    id: string;
    name: string;
    description?: string | null;
  } | null;
  createdAt: string;
  updatedAt: string;
}

export interface Role {
  id: number;
  name: string;
}

export enum RoleEnum {
  ADMIN = 1,
  MANAGER = 2,
  CASHIER = 3,
  WAITER = 4,
  KITCHEN = 5,
  DELIVERY = 6,
}

export interface CreateUserDto {
  email?: string;
  username: string;
  password: string;
  firstName: string;
  lastName: string;
  birthDate?: string;
  gender?: GenderEnum;
  phoneNumber?: string;
  address?: string;
  city?: string;
  state?: string;
  country?: string;
  zipCode?: string;
  emergencyContact?: {
    name?: string;
    phone?: string;
    relationship?: string;
  };
  role: {
    id: number;
  };
}

export interface UpdateUserDto {
  email?: string;
  username?: string;
  password?: string;
  firstName?: string;
  lastName?: string;
  birthDate?: string;
  gender?: GenderEnum;
  phoneNumber?: string;
  address?: string;
  city?: string;
  state?: string;
  country?: string;
  zipCode?: string;
  emergencyContact?: {
    name?: string;
    phone?: string;
    relationship?: string;
  };
  isActive?: boolean;
  role?: {
    id: number;
  };
}

export interface UsersQuery {
  page?: number;
  limit?: number;
  filters?: {
    isActive?: boolean;
    roles?: { id: number }[];
  };
  search?: string;
  sortBy?: string;
  sortOrder?: 'ASC' | 'DESC';
}

export interface UsersResponse {
  data: User[];
  hasNextPage: boolean;
}

================
File: app/src/services/reconnectionSnackbarService.ts
================
import { autoReconnectService } from './autoReconnectService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useAuthStore } from '@/app/store/authStore';

class ReconnectionSnackbarService {
  private unsubscribe: (() => void) | null = null;
  private lastLogCount = 0;
  private lastStatus: string | null = null;
  private snackbarTimeouts: Map<string, NodeJS.Timeout> = new Map();

  start() {
    // Detener si ya está corriendo
    this.stop();

    // Suscribirse a los cambios del servicio de reconexión
    this.unsubscribe = autoReconnectService.subscribe((state) => {
      // Solo mostrar snackbars si el usuario está logueado
      const isLoggedIn = !!useAuthStore.getState().user;
      if (!isLoggedIn) return;

      // Si no está reconectando, limpiar y salir
      if (!state.isReconnecting && state.status !== 'connected') {
        this.clearAllSnackbars();
        return;
      }

      // Detectar cambios de estado importantes
      if (state.status !== this.lastStatus) {
        this.lastStatus = state.status;
        this.showStatusSnackbar(state.status, state.attempts);
      }

      // Mostrar nuevos logs importantes
      if (state.logs.length > this.lastLogCount) {
        const newLogs = state.logs.slice(
          0,
          state.logs.length - this.lastLogCount,
        );
        this.processNewLogs(newLogs);
      }

      this.lastLogCount = state.logs.length;
    });
  }

  stop() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }
    this.clearAllSnackbars();
    this.lastLogCount = 0;
    this.lastStatus = null;
  }

  private showStatusSnackbar(status: string, attempts: number) {
    const { showSnackbar } = useSnackbarStore.getState();

    // Limpiar snackbar anterior del mismo tipo
    this.clearSnackbar('status');

    let message = '';
    let type: 'info' | 'error' | 'success' | 'warning' = 'info';
    let duration = 3000;

    switch (status) {
      case 'checking-network':
        message = '📡 Verificando conexión WiFi...';
        type = 'info';
        break;
      case 'checking-health':
        message = `🏥 Verificando servidor (intento #${attempts})`;
        type = 'info';
        break;
      case 'running-discovery':
        message = '🔍 Buscando servidor en la red...';
        type = 'warning';
        duration = 5000;
        break;
      case 'no-wifi':
        message = '📡 Sin conexión WiFi';
        type = 'error';
        duration = 5000;
        break;
      case 'failed':
        message = `❌ Reconexión fallida (intento #${attempts})`;
        type = 'error';
        break;
      case 'connected':
        message = '✅ ¡Conexión restablecida!';
        type = 'success';
        duration = 4000;
        break;
    }

    if (message) {
      showSnackbar({ message, type, duration });

      // Programar limpieza
      const timeout = setTimeout(() => {
        this.snackbarTimeouts.delete('status');
      }, duration);

      this.snackbarTimeouts.set('status', timeout);
    }
  }

  private processNewLogs(logs: string[]) {
    const { showSnackbar } = useSnackbarStore.getState();

    // Solo procesar los logs más importantes
    logs.forEach((log) => {
      // Filtrar logs que ya se muestran en el estado
      if (
        log.includes('CICLO DE RECONEXIÓN') ||
        log.includes('════════') ||
        log.includes('PASO 1:') ||
        log.includes('PASO 2:') ||
        log.includes('PASO 3:')
      ) {
        return;
      }

      // Mostrar logs de error importantes
      if (
        log.includes('ERROR:') &&
        (log.includes('Health check falló') ||
          log.includes('No se encontró servidor') ||
          log.includes('Ciclo fallido'))
      ) {
        showSnackbar({
          message: this.cleanLogMessage(log),
          type: 'error',
          duration: 4000,
        });
      }

      // Mostrar logs de éxito
      else if (
        log.includes('SUCCESS:') &&
        (log.includes('WiFi conectado') ||
          log.includes('Health check exitoso') ||
          log.includes('Servidor encontrado') ||
          log.includes('RECONEXIÓN EXITOSA'))
      ) {
        showSnackbar({
          message: this.cleanLogMessage(log),
          type: 'success',
          duration: 3000,
        });
      }
    });
  }

  private cleanLogMessage(log: string): string {
    // Remover timestamp y tipo de log
    return log
      .replace(/\[[^\]]+\]\s*(INFO|ERROR|SUCCESS):\s*/, '')
      .replace(/\s*→\s*/, ' ')
      .trim();
  }

  private clearSnackbar(key: string) {
    const timeout = this.snackbarTimeouts.get(key);
    if (timeout) {
      clearTimeout(timeout);
      this.snackbarTimeouts.delete(key);
    }
  }

  private clearAllSnackbars() {
    this.snackbarTimeouts.forEach((timeout) => clearTimeout(timeout));
    this.snackbarTimeouts.clear();
  }
}

// Singleton
export const reconnectionSnackbarService = new ReconnectionSnackbarService();

================
File: app/tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true, // Report errors on unused local variables
    "noUnusedParameters": true, // Report errors on unused parameters
    "moduleResolution": "bundler", // Añadido para resolver tipos de navegación
    "baseUrl": ".", // O "./" - Directorio base para los paths
    "paths": {
      "@/*": ["src/*"] // Define el alias @/ para apuntar a src/
    }
  }
}

================
File: app/.eslintrc.js
================
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2021,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true,
    },
    project: './tsconfig.json',
  },
  plugins: [
    '@typescript-eslint',
    'react',
    'react-hooks',
    'react-native',
    'prettier',
  ],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:react-native/all',
    'prettier',
  ],
  env: {
    'react-native/react-native': true,
    node: true,
    es2021: true,
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
  rules: {
    // TypeScript
    '@typescript-eslint/no-unused-vars': ['error', { 
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^_',
      ignoreRestSiblings: true
    }],
    '@typescript-eslint/no-explicit-any': 'off', // Too many to fix now
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-namespace': 'off',

    // React
    'react/react-in-jsx-scope': 'off', // Not needed with React 17+
    'react/prop-types': 'off', // Using TypeScript
    'react/display-name': 'off',

    // React Native
    'react-native/no-inline-styles': 'error', // Refactored to use StyleSheet
    'react-native/no-color-literals': 'off',
    'react-native/no-raw-text': 'off',
    'react-native/sort-styles': 'off',
    'react-native/no-unused-styles': 'off', // Disabled - too many false positives

    // React Hooks
    'react-hooks/exhaustive-deps': 'warn',
    'react-hooks/rules-of-hooks': 'error',

    // General
    'no-console': ['warn', { allow: ['warn', 'error', 'info'] }],
    'prettier/prettier': 'error',
    'no-empty': ['error', { allowEmptyCatch: true }],
    'no-prototype-builtins': 'off',
  },
  ignorePatterns: [
    'node_modules/',
    'android/',
    'ios/',
    '.expo/',
    'babel.config.js',
    'metro.config.js',
    '*.config.js',
    '.eslintrc.js',
  ],
};

================
File: app/App.tsx
================
import React from 'react';
import { ActivityIndicator, View } from 'react-native';
import { Provider as PaperProvider } from 'react-native-paper';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import {
  useThemeStore,
  useSystemThemeDetector,
} from './src/app/store/themeStore';
import { AppNavigator } from './src/app/navigation/AppNavigator';
import GlobalSnackbar from './src/app/components/common/GlobalSnackbar';
import { useInitializeAuth } from './src/app/hooks/useInitializeAuth';
import { useServerConnection } from './src/app/hooks/useServerConnection';
import { es, registerTranslation } from 'react-native-paper-dates';

registerTranslation('es', es);

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      gcTime: 10 * 60 * 1000,
      refetchOnMount: false,
      refetchOnWindowFocus: false,
      refetchOnReconnect: 'always',
      retry: 0,
      refetchInterval: false,
    },
    mutations: {
      retry: 0,
    },
  },
});

function AppContent() {
  const isInitializingAuth = useInitializeAuth();
  useServerConnection();
  const activeTheme = useThemeStore((state) => state.activeTheme);

  if (isInitializingAuth) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: activeTheme.colors.background,
        }}
      >
        <ActivityIndicator size="large" color={activeTheme.colors.primary} />
      </View>
    );
  }

  return (
    <>
      <AppNavigator />
      <GlobalSnackbar />
    </>
  );
}

export default function App() {
  useSystemThemeDetector();
  const activeTheme = useThemeStore((state) => state.activeTheme);

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <QueryClientProvider client={queryClient}>
          <PaperProvider theme={activeTheme}>
            <AppContent />
          </PaperProvider>
        </QueryClientProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}

================
File: app/babel.config.js
================
module.exports = function (api) {
  api.cache(true);
  
  const isWeb = process.env.WEBPACK_DEV_SERVER === 'true' || process.env.PLATFORM === 'web';
  
  const plugins = [
    [
      "module-resolver",
      {
        root: ["./"],
        alias: {
          "@": "./src",
        },
      },
    ],
    'react-native-reanimated/plugin',
  ];

  if (isWeb) {
    plugins.push([
      function() {
        return {
          visitor: {
            MetaProperty(path) {
              if (path.node.meta.name === 'import' && path.node.property.name === 'meta') {
                path.replaceWith(
                  require('@babel/types').objectExpression([
                    require('@babel/types').objectProperty(
                      require('@babel/types').identifier('url'),
                      require('@babel/types').stringLiteral('')
                    )
                  ])
                );
              }
            }
          }
        };
      }
    ]);
  }

  return {
    presets: ["babel-preset-expo"],
    plugins,
  };
};

================
File: app/eas.json
================
{
  "cli": {
    "version": ">= 16.3.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      }
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      },
      "env": {
        "NODE_ENV": "production"
      }
    },
    "production": {
      "autoIncrement": true,
      "android": {
        "buildType": "app-bundle"
      },
      "env": {
        "NODE_ENV": "production"
      }
    },
    "release": {
      "android": {
        "buildType": "apk"
      }
    },
    "production-apk": {
      "autoIncrement": true,
      "android": {
        "buildType": "apk"
      },
      "env": {
        "NODE_ENV": "production"
      }
    }
  },
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "./google-play-service-account.json",
        "track": "internal",
        "releaseStatus": "draft",
        "changesNotSentForReview": false
      }
    }
  }
}

================
File: app/scripts/check-new-arch-compatibility.js
================
const fs = require('fs');
const path = require('path');

const checkCompatibility = (packageName) => {
  const packagePath = path.join(__dirname, '../node_modules', packageName);
  
  if (!fs.existsSync(packagePath)) {
    return { status: 'not-found', packageName };
  }

  // Buscar indicadores de Nueva Arquitectura
  const indicators = {
    turboModules: false,
    fabric: false,
    codegen: false,
    reactNativeConfig: false
  };

  // Verificar package.json
  const packageJsonPath = path.join(packagePath, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    
    // Buscar configuración de codegen
    if (packageJson.codegenConfig) {
      indicators.codegen = true;
    }
  }

  // Verificar react-native.config.js
  const rnConfigPath = path.join(packagePath, 'react-native.config.js');
  if (fs.existsSync(rnConfigPath)) {
    indicators.reactNativeConfig = true;
  }

  // Buscar archivos indicadores (limitado para evitar búsquedas muy largas)
  const searchFiles = (dir, depth = 0) => {
    if (!fs.existsSync(dir) || depth > 3) return;
    
    try {
      const files = fs.readdirSync(dir);
      for (const file of files) {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isDirectory() && !file.includes('node_modules') && !file.startsWith('.')) {
          searchFiles(filePath, depth + 1);
        } else if ((file.endsWith('.js') || file.endsWith('.ts') || file.endsWith('.tsx')) && stat.size < 100000) {
          try {
            const content = fs.readFileSync(filePath, 'utf8');
            if (content.includes('TurboModule')) indicators.turboModules = true;
            if (content.includes('codegenNativeComponent')) indicators.fabric = true;
          } catch (e) {
            // Ignorar errores de lectura
          }
        }
      }
    } catch (e) {
      // Ignorar errores de directorio
    }
  };

  searchFiles(packagePath);

  const isCompatible = indicators.turboModules || indicators.fabric || indicators.codegen;
  
  return {
    packageName,
    status: isCompatible ? 'compatible' : 'unknown',
    indicators
  };
};

// Leer todas las dependencias del package.json
const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8'));
const allDependencies = {
  ...packageJson.dependencies,
  ...packageJson.devDependencies
};

// Filtrar solo las que empiezan con react-native o expo
const nativeDependencies = Object.keys(allDependencies).filter(dep => 
  dep.startsWith('react-native') || 
  dep.startsWith('expo') || 
  dep.startsWith('@react-native') ||
  dep.includes('react-native') ||
  dep === '@shopify/flash-list'
);

console.log('🔍 Verificando compatibilidad con Nueva Arquitectura...\n');
console.log(`📦 Total de dependencias nativas encontradas: ${nativeDependencies.length}\n`);

const results = {
  compatible: [],
  unknown: [],
  notFound: []
};

nativeDependencies.forEach(dep => {
  const result = checkCompatibility(dep);
  const emoji = result.status === 'compatible' ? '✅' : '⚠️';
  
  if (result.status === 'compatible') {
    results.compatible.push(dep);
    console.log(`${emoji} ${result.packageName}: Compatible`);
    const indicators = Object.entries(result.indicators)
      .filter(([_, value]) => value)
      .map(([key]) => key);
    if (indicators.length > 0) {
      console.log(`   Indicadores encontrados: ${indicators.join(', ')}`);
    }
  } else if (result.status === 'unknown') {
    results.unknown.push(dep);
    console.log(`${emoji} ${result.packageName}: Compatibilidad desconocida`);
  } else {
    results.notFound.push(dep);
    console.log(`❌ ${result.packageName}: No encontrado`);
  }
});

console.log('\n📊 Resumen:');
console.log(`✅ Compatibles: ${results.compatible.length}`);
console.log(`⚠️  Desconocidas: ${results.unknown.length}`);
console.log(`❌ No encontradas: ${results.notFound.length}`);

console.log('\n💡 Recomendaciones:');
if (results.unknown.length > 0) {
  console.log('- Las bibliotecas con compatibilidad desconocida pueden funcionar con el Interop Layer');
  console.log('- Verifica la documentación oficial de cada biblioteca');
  console.log('- Considera buscar alternativas para bibliotecas críticas sin soporte');
}

console.log('\n📚 Para más información, consulta NEW_ARCHITECTURE_COMPATIBILITY.md');

================
File: app/src/app/components/ConnectionIndicator.tsx
================
import React, { useMemo, useState, useEffect } from 'react';
import { View } from 'react-native';
import { IconButton, Surface, Badge } from 'react-native-paper';
import { useAppTheme } from '../styles/theme';
import { useServerConnection } from '../hooks/useServerConnection';
import { useSnackbarStore } from '../store/snackbarStore';
import { healthMonitoringService } from '@/services/healthMonitoringService';
import { autoReconnectService } from '@/services/autoReconnectService';

export function ConnectionIndicator() {
  const theme = useAppTheme();
  const { hasWifi, isConnected, isSearching, isHealthy, error } =
    useServerConnection();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [isChecking, setIsChecking] = useState(false);
  const [isReconnecting, setIsReconnecting] = useState(false);

  useEffect(() => {
    const unsubscribe = autoReconnectService.subscribe((state) => {
      setIsReconnecting(state.isReconnecting && state.attempts > 0);
    });

    return () => {
      unsubscribe();
    };
  }, []);

  const getConnectionStatus = () => {
    if (!hasWifi) {
      return {
        icon: 'wifi-off',
        color: theme.colors.error,
        backgroundColor: theme.colors.errorContainer,
        message: 'Sin conexión WiFi',
      };
    }

    if (isSearching || isChecking) {
      return {
        icon: 'wifi-sync',
        color: theme.colors.warning || theme.colors.tertiary,
        backgroundColor:
          theme.colors.warningContainer || theme.colors.tertiaryContainer,
        message: isChecking
          ? 'Verificando conexión...'
          : 'Buscando servidor...',
      };
    }

    if (!isConnected) {
      return {
        icon: 'wifi-alert',
        color: theme.colors.error,
        backgroundColor: theme.colors.errorContainer,
        message: error || 'Sin conexión al servidor',
      };
    }

    if (!isHealthy) {
      return {
        icon: 'wifi-strength-2-alert',
        color: theme.colors.warning || theme.colors.tertiary,
        backgroundColor:
          theme.colors.warningContainer || theme.colors.tertiaryContainer,
        message: error || 'Servidor no responde',
      };
    }

    return {
      icon: 'wifi',
      color: theme.colors.onSurfaceVariant,
      backgroundColor: 'transparent',
      message: 'Conectado',
    };
  };

  const status = getConnectionStatus();

  const handlePress = async () => {
    const iconExplanation = getIconExplanation();
    showSnackbar({
      message: iconExplanation,
      type:
        !hasWifi || !isConnected ? 'error' : !isHealthy ? 'warning' : 'info',
      duration: 4000,
    });

    if (isReconnecting) {
      const reconnectState = autoReconnectService.getState();
      setTimeout(() => {
        showSnackbar({
          message: `Reconexión en progreso - Intento #${reconnectState.attempts}`,
          type: 'info',
          duration: 3000,
        });
      }, 500);
    }

    if (isConnected && !isChecking && !isReconnecting) {
      setIsChecking(true);

      setTimeout(async () => {
        try {
          const isHealthyNow = await healthMonitoringService.forceCheck();

          showSnackbar({
            message: isHealthyNow
              ? 'Servidor funcionando correctamente ✓'
              : 'El servidor no responde ✗',
            type: isHealthyNow ? 'success' : 'error',
            duration: 3000,
          });
        } catch (error) {
          showSnackbar({
            message: 'Error al verificar el servidor',
            type: 'error',
            duration: 3000,
          });
        } finally {
          setIsChecking(false);
        }
      }, 1000);
    }

    if (!isConnected && !isReconnecting && hasWifi) {
      showSnackbar({
        message: 'Iniciando proceso de reconexión...',
        type: 'info',
        duration: 2000,
      });

      setTimeout(() => {
        autoReconnectService.startAutoReconnect();
      }, 500);
    }
  };

  const getIconExplanation = () => {
    const reconnectInfo = isReconnecting
      ? '\n🔄 Reconectando automáticamente...'
      : '';

    switch (status.icon) {
      case 'wifi-off':
        return (
          '📡 Sin WiFi - Activa el WiFi y conéctate a la red' + reconnectInfo
        );
      case 'wifi-sync':
        return '🔄 Buscando servidor en la red...' + reconnectInfo;
      case 'wifi-alert':
        return '⚠️ Sin conexión al servidor' + reconnectInfo;
      case 'wifi-strength-2-alert':
        return '⚠️ Servidor no responde' + reconnectInfo;
      case 'wifi':
        return '✅ Conectado al servidor';
      default:
        return status.message + reconnectInfo;
    }
  };

  const containerStyle = useMemo(
    () => ({
      marginRight: 8,
      borderRadius: 20,
      overflow: 'hidden',
    }),
    [],
  );

  const surfaceStyle = useMemo(
    () => ({
      borderRadius: 20,
      backgroundColor: status.backgroundColor,
    }),
    [status.backgroundColor],
  );

  const iconButtonStyle = useMemo(
    () => ({
      margin: 0,
    }),
    [],
  );

  const showBackground =
    !hasWifi || !isConnected || isSearching || !isHealthy || isChecking;

  if (showBackground) {
    return (
      <View style={containerStyle}>
        <Surface style={surfaceStyle} elevation={0}>
          <IconButton
            icon={status.icon}
            iconColor={status.color}
            size={24}
            animated={isSearching || isChecking}
            onPress={handlePress}
            style={iconButtonStyle}
          />
        </Surface>
        {isReconnecting && !isSearching && (
          <Badge
            size={8}
            style={{
              position: 'absolute',
              top: 4,
              right: 4,
              backgroundColor: theme.colors.warning || theme.colors.tertiary,
            }}
          />
        )}
      </View>
    );
  }

  return (
    <View style={{ marginRight: 8, position: 'relative' }}>
      <IconButton
        icon={status.icon}
        iconColor={theme.colors.onPrimary}
        size={24}
        onPress={handlePress}
      />
      {isReconnecting && (
        <Badge
          size={8}
          style={{
            position: 'absolute',
            top: 8,
            right: 8,
            backgroundColor: theme.colors.warning || theme.colors.tertiary,
          }}
        />
      )}
    </View>
  );
}

================
File: app/src/app/components/DateTimePickerSafe.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import { Modal, Portal, Text, Button, Surface } from 'react-native-paper';
import DateTimePicker from '@react-native-community/datetimepicker';

interface DateTimePickerSafeProps {
  visible: boolean;
  mode: 'date' | 'time' | 'datetime';
  value: Date | null;
  onConfirm: (date: Date) => void;
  onCancel: () => void;
  minimumDate?: Date;
  maximumDate?: Date;
  minuteInterval?: number;
  title?: string;
  allowManualInput?: boolean;
}

export const DateTimePickerSafe: React.FC<DateTimePickerSafeProps> = ({
  visible,
  mode,
  value,
  onConfirm,
  onCancel,
  minimumDate,
  maximumDate,
  minuteInterval = 1,
  title,
  allowManualInput = false,
}) => {
  const [tempDate, setTempDate] = useState<Date>(() => {
    if (value) return new Date(value);
    const now = new Date();
    if (mode === 'time' && minuteInterval && minuteInterval > 1) {
      const minutes = now.getMinutes();
      const roundedMinutes =
        Math.round(minutes / minuteInterval) * minuteInterval;
      const roundedDate = new Date(now);
      roundedDate.setMinutes(roundedMinutes, 0, 0);
      return roundedDate;
    }
    return now;
  });

  useEffect(() => {
    if (visible && value) {
      setTempDate(new Date(value));
    }
  }, [visible, value]);

  const handleChange = (_event: any, selectedDate?: Date) => {
    if (selectedDate) {
      setTempDate(new Date(selectedDate));
    }
  };

  const handleConfirm = () => {
    onConfirm(new Date(tempDate));
  };

  const getTitle = () => {
    if (title) return title;
    switch (mode) {
      case 'date':
        return 'Seleccionar Fecha';
      case 'time':
        return 'Seleccionar Hora';
      case 'datetime':
        return 'Seleccionar Fecha y Hora';
      default:
        return '';
    }
  };

  if (Platform.OS === 'ios') {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onCancel}
          contentContainerStyle={styles.modalIOS}
        >
          <Surface style={styles.containerIOS}>
            <View style={styles.header}>
              <Button mode="text" onPress={onCancel}>
                Cancelar
              </Button>
              <Text variant="titleMedium">{getTitle()}</Text>
              <Button mode="text" onPress={handleConfirm}>
                Confirmar
              </Button>
            </View>
            <DateTimePicker
              testID="dateTimePicker"
              value={tempDate}
              mode={mode}
              is24Hour={false}
              display="spinner"
              onChange={handleChange}
              minimumDate={minimumDate}
              maximumDate={maximumDate}
              minuteInterval={minuteInterval as any}
              locale="es_ES"
            />
          </Surface>
        </Modal>
      </Portal>
    );
  }

  return (
    <>
      {visible && (
        <DateTimePicker
          testID="dateTimePicker"
          value={tempDate}
          mode={mode}
          is24Hour={false}
          display="default"
          onChange={(event, selectedDate) => {
            onCancel();
            if (event.type === 'set' && selectedDate) {
              onConfirm(new Date(selectedDate));
            }
          }}
          minimumDate={minimumDate}
          maximumDate={maximumDate}
          minuteInterval={minuteInterval as any}
          {...(allowManualInput && Platform.OS === 'android' && mode === 'time'
            ? {
                display: 'clock' as any,
              }
            : {})}
        />
      )}
    </>
  );
};

const styles = StyleSheet.create({
  modalIOS: {
    justifyContent: 'flex-end',
    margin: 0,
  },
  containerIOS: {
    backgroundColor: 'white',
    paddingBottom: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
});

export default DateTimePickerSafe;

================
File: app/src/app/components/responsive/ResponsiveGrid.tsx
================
import React, { ReactNode, useMemo, Children } from 'react';
import { View, ViewStyle, StyleProp, DimensionValue } from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ResponsiveGridProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;

  // Configuración de columnas
  columns?: number;
  columnsTablet?: number;
  columnsLandscape?: number;
  minItemWidth?: number;

  // Configuración de filas
  rows?: number;
  minItemHeight?: number;

  // Espaciado
  gap?: number;
  gapTablet?: number;
  rowGap?: number;
  columnGap?: number;
  padding?: number;

  // Alineación
  alignItems?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justifyContent?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';

  // Comportamiento
  fillLastRow?: boolean;
  equalHeight?: boolean;

  // Estilos de items
  itemStyle?: StyleProp<ViewStyle>;
  itemPadding?: number;
}

interface GridItemProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;
  span?: number;
  spanTablet?: number;
}

// Componente para items del grid
export const GridItem: React.FC<GridItemProps> = ({
  children,
  style,
  span = 1,
  spanTablet,
}) => {
  const responsive = useResponsive();
  const actualSpan = responsive.isTablet && spanTablet ? spanTablet : span;

  return <View style={[{ flex: actualSpan }, style]}>{children}</View>;
};

export const ResponsiveGrid: React.FC<ResponsiveGridProps> = ({
  children,
  style,

  // Columnas
  columns = 1,
  columnsTablet,
  columnsLandscape,
  minItemWidth,

  // Filas
  rows,
  minItemHeight,

  // Espaciado
  gap = 16,
  gapTablet,
  rowGap,
  columnGap,
  padding = 0,

  // Alineación
  alignItems = 'stretch',
  justifyContent = 'flex-start',

  // Comportamiento
  fillLastRow = false,
  equalHeight = false,

  // Estilos
  itemStyle,
  itemPadding = 0,
}) => {
  const responsive = useResponsive();

  // Calcular número de columnas
  const calculateColumns = useMemo(() => {
    // Si hay un ancho mínimo definido, calcular columnas dinámicamente
    if (minItemWidth) {
      return responsive.getGridColumns(minItemWidth, gap, padding);
    }

    // Si estamos en landscape y hay columnas específicas para landscape
    if (responsive.isLandscape && columnsLandscape) {
      return columnsLandscape;
    }

    // Si es tablet y hay columnas específicas para tablet
    if (responsive.isTablet && columnsTablet) {
      return columnsTablet;
    }

    // Columnas por defecto
    return columns;
  }, [
    columns,
    columnsTablet,
    columnsLandscape,
    minItemWidth,
    gap,
    padding,
    responsive,
  ]);

  // Calcular gap responsive
  const actualGap =
    responsive.isTablet && gapTablet !== undefined ? gapTablet : gap;
  const scaledGap = responsive.scaleWidth(actualGap);
  const actualRowGap =
    rowGap !== undefined ? responsive.scaleHeight(rowGap) : scaledGap;
  const actualColumnGap =
    columnGap !== undefined ? responsive.scaleWidth(columnGap) : scaledGap;

  // Procesar children en filas
  const processedChildren = useMemo(() => {
    const childArray = Children.toArray(children);
    const gridRows: ReactNode[][] = [];

    // Agrupar children en filas
    for (let i = 0; i < childArray.length; i += calculateColumns) {
      const row = childArray.slice(i, i + calculateColumns);

      // Si fillLastRow está activo y es la última fila incompleta
      if (
        fillLastRow &&
        row.length < calculateColumns &&
        i + calculateColumns >= childArray.length
      ) {
        // Agregar elementos vacíos para completar la fila
        while (row.length < calculateColumns) {
          row.push(
            <View key={`empty-${i}-${row.length}`} style={{ flex: 1 }} />,
          );
        }
      }

      gridRows.push(row);
    }

    return gridRows;
  }, [children, calculateColumns, fillLastRow]);

  // Estilos del contenedor
  const containerStyle = useMemo(() => {
    const baseStyle: ViewStyle = {
      padding: responsive.scaleWidth(padding),
    };

    // Si se especifica un número de filas, establecer altura
    if (rows && minItemHeight) {
      baseStyle.height =
        rows * (minItemHeight + actualRowGap) - actualRowGap + padding * 2;
    }

    return [baseStyle, style];
  }, [padding, rows, minItemHeight, actualRowGap, responsive, style]);

  // Estilos de fila
  const rowStyle = useMemo(() => {
    const style: ViewStyle = {
      flexDirection: 'row',
      justifyContent,
      alignItems,
    };

    if (equalHeight) {
      style.alignItems = 'stretch';
    }

    return style;
  }, [justifyContent, alignItems, equalHeight]);

  // Estilos de item
  const gridItemStyle = useMemo(() => {
    const style: ViewStyle = {
      flex: 1,
      padding: responsive.scaleWidth(itemPadding),
    };

    if (minItemHeight) {
      style.minHeight = responsive.scaleHeight(minItemHeight);
    }

    return [style, itemStyle];
  }, [itemPadding, minItemHeight, responsive, itemStyle]);

  return (
    <View style={containerStyle}>
      {processedChildren.map((row, rowIndex) => (
        <View
          key={`row-${rowIndex}`}
          style={[
            rowStyle,
            rowIndex < processedChildren.length - 1 && {
              marginBottom: actualRowGap,
            },
          ]}
        >
          {row.map((child, colIndex) => (
            <View
              key={`item-${rowIndex}-${colIndex}`}
              style={[
                gridItemStyle,
                colIndex < row.length - 1 && { marginRight: actualColumnGap },
              ]}
            >
              {child}
            </View>
          ))}
        </View>
      ))}
    </View>
  );
};

// Componente alternativo usando flexWrap para grids más simples
export const ResponsiveFlexGrid: React.FC<ResponsiveGridProps> = ({
  children,
  style,
  columns = 2,
  columnsTablet,
  minItemWidth,
  gap = 16,
  gapTablet,
  padding = 0,
  alignItems = 'stretch',
  justifyContent = 'flex-start',
  itemStyle,
}) => {
  const responsive = useResponsive();

  // Calcular columnas
  const calculateColumns = minItemWidth
    ? responsive.getGridColumns(minItemWidth, gap, padding)
    : responsive.isTablet && columnsTablet
      ? columnsTablet
      : columns;

  // Calcular ancho de cada item
  const itemWidth = `${100 / calculateColumns - (gap * (calculateColumns - 1)) / calculateColumns}%`;
  const actualGap =
    responsive.isTablet && gapTablet !== undefined ? gapTablet : gap;

  const containerStyle: ViewStyle = {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent,
    alignItems,
    padding: responsive.scaleWidth(padding),
    gap: responsive.scaleWidth(actualGap),
  };

  const flexItemStyle: ViewStyle = {
    width: itemWidth as DimensionValue,
    minWidth: minItemWidth || 0,
  };

  return (
    <View style={[containerStyle, style]}>
      {Children.map(children, (child, index) => (
        <View key={index} style={[flexItemStyle, itemStyle]}>
          {child}
        </View>
      ))}
    </View>
  );
};

================
File: app/src/app/lib/imageUploadService.ts
================
import {
  uploadFile,
  FileUploadResponse,
} from '../../modules/menu/services/fileService';
import { ApiError } from './errors';
import { getImageUrl } from './imageUtils';

export interface ImageUploadResult {
  success: boolean;
  photoId?: string;
  error?: string;
}

export interface FileObject {
  uri: string;
  name: string;
  type: string;
}

export interface EntityWithOptionalPhoto {
  photo?: {
    id: string;
    path: string;
  } | null;
}

export class ImageUploadService {
  /**
   * Sube una imagen usando el fileService.
   * @param imageFile El objeto FileObject con uri, name, type.
   * @returns Un objeto ImageUploadResult indicando éxito/fallo y el ID de la foto.
   */
  static async uploadImage(imageFile: FileObject): Promise<ImageUploadResult> {
    if (!imageFile || !imageFile.uri) {
      // Intento de subir imagen inválida
      return {
        success: false,
        error: 'No se proporcionó ninguna imagen válida',
      };
    }

    try {
      const uploadResult: FileUploadResponse = await uploadFile(imageFile);

      if (!uploadResult || !uploadResult.file || !uploadResult.file.id) {
        // Respuesta inválida del fileService
        return {
          success: false,
          error: 'Respuesta inválida del servidor al subir imagen.',
        };
      }

      return {
        success: true,
        photoId: uploadResult.file.id,
      };
    } catch (error) {
      // Error en ImageUploadService.uploadImage
      let errorMessage = 'Error desconocido al subir la imagen.';
      if (error instanceof ApiError) {
        errorMessage = `Error al subir: ${error.originalMessage || error.code}`;
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Determina el valor de photoId a enviar al backend basado en el estado actual del formulario y la entidad existente.
   * @param formImageUri La URI de la imagen actual en el formulario (puede ser 'file://...', una URL remota, o null).
   * @param existingEntity La entidad actual (ej. Category) que podría tener una propiedad 'photo' con 'id' y 'path'.
   * @returns
   *   - `undefined`: No hay cambios en la foto O se va a subir una nueva. El DTO NO debe incluir `photoId`.
   *   - `null`: Se debe eliminar la foto existente en el backend. El DTO DEBE incluir `photoId: null`.
   */
  static async determinePhotoId(
    formImageUri: string | null | undefined,
    existingEntity?: EntityWithOptionalPhoto,
  ): Promise<undefined | null> {
    const existingPhotoPath = existingEntity?.photo?.path;
    const existingPhotoFullUrl = existingPhotoPath
      ? await getImageUrl(existingPhotoPath)
      : null;

    if (formImageUri && formImageUri.startsWith('file://')) {
      return undefined;
    } else if (
      (formImageUri === null || formImageUri === undefined) &&
      existingEntity?.photo
    ) {
      return null;
    } else if (
      formImageUri &&
      !formImageUri.startsWith('file://') &&
      formImageUri === existingPhotoFullUrl
    ) {
      return undefined;
    } else if (
      formImageUri &&
      !formImageUri.startsWith('file://') &&
      formImageUri !== existingPhotoFullUrl
    ) {
      return undefined;
    } else if (
      (formImageUri === null || formImageUri === undefined) &&
      !existingEntity?.photo
    ) {
      return undefined;
    }

    return undefined;
  }
}

================
File: app/src/app/navigation/AuthStack.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '../styles/theme';

import LoginScreen from '../../modules/auth/screens/LoginScreen';
import type { AuthStackParamList } from './types';

const Stack = createNativeStackNavigator<AuthStackParamList>();

export function AuthStack() {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.primary,
        },
        headerTintColor: theme.colors.onPrimary,
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
        },
      }}
    >
      <Stack.Screen
        name="Login"
        component={LoginScreen}
        options={{
          title: 'Iniciar Sesión',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/app/navigation/ConditionalAppNavigator.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { View, ActivityIndicator } from 'react-native';
import { Portal, Dialog, Button, Text } from 'react-native-paper';
import { useAuthStore } from '../store/authStore';
import { AppDrawerNavigator } from './AppDrawerNavigator';
import { KitchenOnlyNavigator } from './KitchenOnlyNavigator';
import { useAppTheme } from '../styles/theme';

export function ConditionalAppNavigator() {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const logout = useAuthStore((state) => state.logout);
  const [loading, setLoading] = useState(true);
  const [showNoScreenAlert, setShowNoScreenAlert] = useState(false);
  const [isKitchenUser, setIsKitchenUser] = useState(false);

  const checkUserAccess = useCallback(async () => {
    if (!user) {
      setLoading(false);
      return;
    }

    try {
      // Obtener el ID del rol
      const roleId = typeof user.role === 'object' ? user.role?.id : null;

      // Solo verificar pantalla para usuarios con rol kitchen (ID 5)
      if (roleId === 5) {
        setIsKitchenUser(true);
        // La información de la pantalla ya viene en el objeto user
        const hasScreen = !!user.preparationScreen;

        if (!hasScreen) {
          // Usuario de cocina sin pantalla asignada
          setShowNoScreenAlert(true);
        }
      } else {
        setIsKitchenUser(false);
      }
    } catch (error) {
      setIsKitchenUser(false);
    } finally {
      setLoading(false);
    }
  }, [user]);

  useEffect(() => {
    checkUserAccess();
  }, [checkUserAccess]);

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: theme.colors.background,
        }}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  // Usuarios de cocina usan un navegador especial, otros usan el drawer normal
  return (
    <>
      {isKitchenUser ? <KitchenOnlyNavigator /> : <AppDrawerNavigator />}
      <Portal>
        <Dialog
          visible={showNoScreenAlert}
          onDismiss={() => setShowNoScreenAlert(false)}
          style={{ backgroundColor: theme.colors.surface }}
        >
          <Dialog.Icon
            icon="alert-circle"
            size={64}
            color={theme.colors.error}
          />
          <Dialog.Title style={{ textAlign: 'center' }}>
            Sin Pantalla Asignada
          </Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyLarge" style={{ textAlign: 'center' }}>
              Tu usuario de cocina no tiene una pantalla de preparación
              asignada.
            </Text>
            <Text
              variant="bodyMedium"
              style={{ textAlign: 'center', marginTop: 8 }}
            >
              Por favor, contacta a tu administrador para que te asigne una
              pantalla de preparación.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowNoScreenAlert(false)}>
              Entendido
            </Button>
            <Button
              mode="contained"
              onPress={async () => {
                setShowNoScreenAlert(false);
                await logout();
              }}
            >
              Cerrar Sesión
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </>
  );
}

================
File: app/src/app/navigation/helpers/navigationHelpers.ts
================
import { CommonActions } from '@react-navigation/native';
import { DrawerSection, hasPermission } from '@/app/constants/rolePermissions';

// Todas las rutas disponibles en el drawer en orden
export const ALL_DRAWER_ROUTES: DrawerSection[] = [
  'OrdersStack',
  'ReceiptsStack',
  'OrderFinalizationStack',
  'MenuStack',
  'AvailabilityStack',
  'ModifiersStack',
  'PizzaCustomizationsStack',
  'PreparationScreensStack',
  'AreasTablesStack',
  'PrintersStack',
  'RestaurantConfigStack',
  'CustomersStack',
  'SyncStack',
  'UsersStack',
  'ShiftAuditStack',
  'KitchenStack',
];

// Mapa de rutas a sus pantallas iniciales
export const ROUTE_INITIAL_SCREENS: Record<DrawerSection, string> = {
  OrdersStack: 'Orders',
  ReceiptsStack: 'ReceiptsList',
  OrderFinalizationStack: 'OrderFinalizationScreen',
  MenuStack: 'CategoriesScreen',
  AvailabilityStack: 'AvailabilityScreen',
  ModifiersStack: 'ModifierGroupsScreen',
  PizzaCustomizationsStack: 'PizzaCustomizationsList',
  PreparationScreensStack: 'PreparationScreensList',
  AreasTablesStack: 'AreasList',
  PrintersStack: 'PrintersList',
  RestaurantConfigStack: 'RestaurantConfig',
  CustomersStack: 'Customers',
  SyncStack: 'SyncStatus',
  UsersStack: 'UsersList',
  ShiftAuditStack: 'ShiftsList',
  KitchenStack: 'KitchenOrders',
};

// Helper para generar la acción de navegación
export const generateNavigationAction = (
  targetRoute: DrawerSection,
  userRoleId: number | undefined,
) => {
  // Filtrar rutas basándose en permisos
  const allowedRoutes = ALL_DRAWER_ROUTES.filter((route) =>
    hasPermission(userRoleId, route),
  );

  // Encontrar el índice de la ruta objetivo
  const targetIndex = allowedRoutes.indexOf(targetRoute);

  if (targetIndex === -1) {
    return null;
  }

  // Construir las rutas con sus estados iniciales
  const routes = allowedRoutes.map((route, index) => {
    const baseRoute = { name: route };

    // Solo agregar state a la ruta activa
    if (index === targetIndex) {
      return {
        ...baseRoute,
        state: {
          routes: [{ name: ROUTE_INITIAL_SCREENS[route] }],
        },
      };
    }

    return baseRoute;
  });

  return CommonActions.reset({
    index: targetIndex,
    routes,
  });
};

================
File: app/src/app/navigation/options.ts
================
import { NativeStackNavigationOptions } from '@react-navigation/native-stack';
import { DrawerNavigationOptions } from '@react-navigation/drawer';
import { AppTheme } from '../styles/theme';
import { ResponsiveInfo } from '../hooks/useResponsive';

export const getDrawerHeaderOptions = (
  theme: AppTheme,
  responsive?: ResponsiveInfo,
): DrawerNavigationOptions => ({
  headerStyle: {
    backgroundColor: theme.colors.primary,
    height: responsive?.dimensions.headerHeight,
  },
  headerTintColor: theme.colors.onPrimary,
  headerTitleStyle: {
    ...theme.fonts.titleLarge,
    color: theme.colors.onPrimary,
    fontWeight: 'bold',
    fontSize: responsive?.fontSize.xl,
  },
  headerShadowVisible: false,
});

export const getStackHeaderOptions = (
  theme: AppTheme,
  responsive?: ResponsiveInfo,
): NativeStackNavigationOptions => ({
  headerStyle: {
    backgroundColor: theme.colors.elevation.level2,
    height: responsive?.dimensions.headerHeight,
  },
  headerTintColor: theme.colors.onSurface,
  headerTitleStyle: {
    ...theme.fonts.titleMedium,
    color: theme.colors.onSurface,
    fontWeight: 'bold',
    fontSize: responsive?.fontSize.l,
  },
  headerTitleAlign: 'center',
  headerShadowVisible: false,
});

================
File: app/src/app/schemas/domain/preparation-screen.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para PreparationScreen simplificado para el dominio.
 * Solo incluye los campos necesarios para la referencia en productos.
 */
export const preparationScreenSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
});

export type PreparationScreen = z.infer<typeof preparationScreenSchema>;

================
File: app/src/app/types/theme.types.ts
================
import { z } from 'zod';
import { MD3Theme } from 'react-native-paper';

export const themePreferenceSchema = z.enum(['light', 'dark', 'system']);
export type ThemePreference = z.infer<typeof themePreferenceSchema>;

export const THEME_PREFERENCE_STORAGE_KEY = 'app_theme_preference';

export const THEME_MODE = {
  LIGHT: 'light',
  DARK: 'dark',
  SYSTEM: 'system',
} as const;

export interface AppTheme extends MD3Theme {}

export interface ThemeState {
  preference: ThemePreference;
  setPreference: (preference: ThemePreference) => void;
}

================
File: app/src/app/utils/__tests__/dateTimeHelpers.test.ts
================
import {
  safeTimeStringToDate,
  safeDateToTimeString,
  createScheduledDateTime as _createScheduledDateTime,
  roundMinutesToFive,
  parseDateFromBackend,
  getNextAvailableTime,
} from '../dateTimeHelpers';

describe('dateTimeHelpers', () => {
  describe('safeTimeStringToDate', () => {
    it('debe convertir string de hora a Date correctamente', () => {
      const result = safeTimeStringToDate('14:30');
      expect(result.getHours()).toBe(14);
      expect(result.getMinutes()).toBe(30);
      expect(result.getSeconds()).toBe(0);
      expect(result.getMilliseconds()).toBe(0);
    });

    it('debe lanzar error con formato inválido', () => {
      expect(() => safeTimeStringToDate('14:30:00')).toThrow();
      expect(() => safeTimeStringToDate('25:00')).toThrow();
      expect(() => safeTimeStringToDate('14:60')).toThrow();
    });

    it('debe usar fecha base si se proporciona', () => {
      const baseDate = new Date('2024-01-15');
      const result = safeTimeStringToDate('10:00', baseDate);
      expect(result.getFullYear()).toBe(2024);
      expect(result.getMonth()).toBe(0); // Enero
      expect(result.getDate()).toBe(15);
    });
  });

  describe('safeDateToTimeString', () => {
    it('debe convertir Date a string HH:mm', () => {
      const date = new Date();
      date.setHours(9, 5);
      expect(safeDateToTimeString(date)).toBe('09:05');

      date.setHours(23, 59);
      expect(safeDateToTimeString(date)).toBe('23:59');
    });

    it('debe lanzar error con fecha inválida', () => {
      expect(() => safeDateToTimeString(new Date('invalid'))).toThrow();
    });
  });

  describe('roundMinutesToFive', () => {
    it('debe redondear minutos correctamente', () => {
      expect(roundMinutesToFive(0)).toBe(0);
      expect(roundMinutesToFive(2)).toBe(0);
      expect(roundMinutesToFive(3)).toBe(5);
      expect(roundMinutesToFive(7)).toBe(5);
      expect(roundMinutesToFive(8)).toBe(10);
      expect(roundMinutesToFive(12)).toBe(10);
      expect(roundMinutesToFive(13)).toBe(15);
      expect(roundMinutesToFive(57)).toBe(55);
      expect(roundMinutesToFive(58)).toBe(60);
    });
  });

  describe('parseDateFromBackend', () => {
    it('debe parsear fechas ISO correctamente', () => {
      const isoString = '2024-01-15T14:30:00.000Z';
      const result = parseDateFromBackend(isoString);
      expect(result).toBeInstanceOf(Date);
      expect(result?.toISOString()).toBe(isoString);
    });

    it('debe retornar null para valores inválidos', () => {
      expect(parseDateFromBackend(null)).toBeNull();
      expect(parseDateFromBackend(undefined)).toBeNull();
      expect(parseDateFromBackend('')).toBeNull();
      expect(parseDateFromBackend('invalid-date')).toBeNull();
    });
  });

  describe('getNextAvailableTime', () => {
    it('debe obtener siguiente hora disponible redondeada', () => {
      const mockNow = new Date('2024-01-15T14:22:00');
      jest.spyOn(global, 'Date').mockImplementation(() => mockNow);

      const result = getNextAvailableTime(30);

      // Debe ser al menos 30 minutos en el futuro
      expect(result.getTime()).toBeGreaterThan(mockNow.getTime());

      // Los minutos deben estar redondeados a múltiplo de 5
      expect(result.getMinutes() % 5).toBe(0);

      // No debe tener segundos ni milisegundos
      expect(result.getSeconds()).toBe(0);
      expect(result.getMilliseconds()).toBe(0);

      (global.Date as any).mockRestore();
    });
  });
});

================
File: app/src/hooks/useResponsiveFontScale.ts
================
import { useWindowDimensions, PixelRatio } from 'react-native';

interface ResponsiveFontConfig {
  baseSize?: number;
  minScale?: number;
  maxScale?: number;
}

/**
 * Hook para obtener un tamaño de fuente responsive basado en las dimensiones
 * de la pantalla y la densidad de píxeles del dispositivo.
 */
export const useResponsiveFontScale = (config: ResponsiveFontConfig = {}) => {
  const { width, height } = useWindowDimensions();
  const { minScale = 0.8, maxScale = 1.2 } = config;

  // Obtener la densidad de píxeles del dispositivo
  const pixelRatio = PixelRatio.get();
  const fontScale = PixelRatio.getFontScale();

  // Calcular el tamaño base de la pantalla
  const screenSize = Math.min(width, height);

  // Referencia: 360 es un ancho típico de móvil
  const baseScreenSize = 360;

  // Calcular el factor de escala basado en el tamaño de pantalla
  let scale = screenSize / baseScreenSize;

  // Limitar el factor de escala
  scale = Math.max(minScale, Math.min(maxScale, scale));

  // Ajustar por la configuración de fuente del sistema
  scale = scale * fontScale;

  // En tablets, reducir ligeramente el escala para evitar fuentes muy grandes
  const isTablet = screenSize > 600;
  if (isTablet) {
    scale = scale * 0.85;
  }

  return {
    scale,
    fontSize: (size: number) => Math.round(size * scale),
    isTablet,
    screenSize,
    pixelRatio,
    fontScale,
  };
};

/**
 * Utilidad para obtener un tamaño de fuente responsive
 * Nota: Esta función no puede usar hooks, usar useResponsiveFontScale en su lugar
 */
export const getResponsiveFontSize = (
  baseSize: number,
  screenWidth?: number,
): number => {
  const fontScale = PixelRatio.getFontScale();

  // Si no se proporciona screenWidth, usar un valor por defecto
  const width = screenWidth || 360;

  // Referencia: 360 es un ancho típico de móvil
  const baseScreenWidth = 360;
  const scale = Math.min(1.2, Math.max(0.8, width / baseScreenWidth));

  return Math.round(baseSize * scale * fontScale);
};

================
File: app/src/modules/areasTables/hooks/useAreasQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as areaService from '../services/areaService';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  FindAllAreasDto,
} from '../schema/area.schema'; // Corregida ruta de importación
import { BaseListQuery } from '../../../app/types/query.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const areasQueryKeys = {
  all: ['areas'] as const,
  lists: () => [...areasQueryKeys.all, 'list'] as const,
  list: (filters: FindAllAreasDto & BaseListQuery) =>
    [...areasQueryKeys.lists(), filters] as const,
  details: () => [...areasQueryKeys.all, 'detail'] as const,
  detail: (id: string) => [...areasQueryKeys.details(), id] as const,
};

export const useGetAreas = (
  filters: FindAllAreasDto = {},
  pagination: BaseListQuery = { page: 1, limit: 10 },
) => {
  const queryKey = areasQueryKeys.list({ ...filters, ...pagination });
  return useQuery<Area[], Error>({
    queryKey,
    queryFn: () => areaService.getAreas(filters, pagination),
  });
};

export const useGetAreaById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = areasQueryKeys.detail(id!); // Use non-null assertion as it's enabled conditionally
  return useQuery<Area, Error>({
    queryKey,
    queryFn: () => areaService.getAreaById(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

export const useCreateArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Area, Error, CreateAreaDto>({
    mutationFn: areaService.createArea,
    onSuccess: (_newArea) => {
      // Prefijado parámetro no usado
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      showSnackbar({ message: 'Área creada con éxito', type: 'success' });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al crear área
    },
  });
};

export const useUpdateArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type UpdateAreaContext = { previousAreas?: Area[]; previousDetail?: Area };

  return useMutation<
    Area,
    Error,
    { id: string; data: UpdateAreaDto },
    UpdateAreaContext
  >({
    mutationFn: ({ id, data }) => areaService.updateArea(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const listQueryKey = areasQueryKeys.lists();
      const detailQueryKey = areasQueryKeys.detail(id);

      await queryClient.cancelQueries({ queryKey: listQueryKey });
      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousAreas = queryClient.getQueryData<Area[]>(listQueryKey);
      const previousDetail = queryClient.getQueryData<Area>(detailQueryKey);

      if (previousAreas) {
        queryClient.setQueryData<Area[]>(
          listQueryKey,
          (old) =>
            old?.map((area) =>
              area.id === id ? { ...area, ...data } : area,
            ) ?? [],
        );
      }

      if (previousDetail) {
        queryClient.setQueryData<Area>(
          detailQueryKey,
          (
            old: Area | undefined, // Añadido tipo explícito
          ) => (old ? { ...old, ...data } : undefined),
        );
      }

      return { previousAreas, previousDetail };
    },

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al actualizar área

      if (context?.previousAreas) {
        queryClient.setQueryData(areasQueryKeys.lists(), context.previousAreas);
      }
      if (context?.previousDetail) {
        queryClient.setQueryData(
          areasQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables, _context) => {
      // Prefijado parámetro no usado
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: areasQueryKeys.detail(variables.id),
      });

      if (!error && data) {
        showSnackbar({
          message: 'Área actualizada con éxito',
          type: 'success',
        });
      }
    },
  });
};

export const useDeleteArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type DeleteAreaContext = { previousDetail?: Area };

  return useMutation<void, Error, string, DeleteAreaContext>({
    mutationFn: areaService.deleteArea,

    onMutate: async (deletedId) => {
      const detailQueryKey = areasQueryKeys.detail(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Area>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al eliminar área

      if (context?.previousDetail) {
        queryClient.setQueryData(
          areasQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId) => {
      // Prefijado parámetro no usado
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      if (!error) {
        queryClient.removeQueries({
          queryKey: areasQueryKeys.detail(deletedId),
        });
        showSnackbar({ message: 'Área eliminada con éxito', type: 'success' });
      }
    },
  });
};

================
File: app/src/modules/areasTables/hooks/useTablesQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as tableService from '../services/tableService';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  FindAllTablesDto,
} from '../schema/table.schema'; // Corregida ruta de importación
import { BaseListQuery } from '../../../app/types/query.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const tablesQueryKeys = {
  all: ['tables'] as const,
  lists: () => [...tablesQueryKeys.all, 'list'] as const,
  list: (filters: FindAllTablesDto & BaseListQuery) =>
    [...tablesQueryKeys.lists(), filters] as const,
  listsByArea: (areaId: string) =>
    [...tablesQueryKeys.lists(), { areaId }] as const,
  details: () => [...tablesQueryKeys.all, 'detail'] as const,
  detail: (id: string) => [...tablesQueryKeys.details(), id] as const,
};

export const useGetTables = (
  filters: FindAllTablesDto = {},
  pagination: BaseListQuery = { page: 1, limit: 10 },
) => {
  const queryKey = tablesQueryKeys.list({ ...filters, ...pagination });
  return useQuery<Table[], Error>({
    queryKey,
    queryFn: () => tableService.getTables(filters, pagination),
  });
};

export const useGetTablesByAreaId = (
  areaId: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = tablesQueryKeys.listsByArea(areaId!);
  return useQuery<Table[], Error>({
    queryKey,
    queryFn: () => tableService.getTablesByAreaId(areaId!),
    enabled: !!areaId && (options?.enabled ?? true),
  });
};

export const useGetTableById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = tablesQueryKeys.detail(id!);
  return useQuery<Table, Error>({
    queryKey,
    queryFn: () => tableService.getTableById(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

export const useCreateTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Table, Error, CreateTableDto>({
    mutationFn: tableService.createTable,
    onSuccess: (_newTable) => {
      // Prefijado parámetro no usado
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      showSnackbar({ message: 'Mesa creada con éxito', type: 'success' });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al crear mesa
    },
  });
};

export const useUpdateTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type UpdateTableContext = { previousDetail?: Table };

  return useMutation<
    Table,
    Error,
    { id: string; data: UpdateTableDto },
    UpdateTableContext
  >({
    mutationFn: ({ id, data }) => tableService.updateTable(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = tablesQueryKeys.detail(id);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Table>(detailQueryKey);

      if (previousDetail) {
        queryClient.setQueryData<Table>(
          detailQueryKey,
          (
            old: Table | undefined, // Añadido tipo explícito
          ) => (old ? { ...old, ...data } : undefined),
        );
      }

      return { previousDetail };
    },

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al actualizar mesa

      if (context?.previousDetail) {
        queryClient.setQueryData(
          tablesQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      // Considerar invalidar listsByArea si areaId cambia
      queryClient.invalidateQueries({
        queryKey: tablesQueryKeys.detail(variables.id),
      });

      if (!error && data) {
        showSnackbar({
          message: 'Mesa actualizada con éxito',
          type: 'success',
        });
      }
    },
  });
};

export const useDeleteTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type DeleteTableContext = { previousDetail?: Table };

  return useMutation<void, Error, string, DeleteTableContext>({
    mutationFn: tableService.deleteTable,

    onMutate: async (deletedId) => {
      const detailQueryKey = tablesQueryKeys.detail(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Table>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al eliminar mesa

      if (context?.previousDetail) {
        queryClient.setQueryData(
          tablesQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId, context) => {
      // Prefijado parámetro no usado
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      if (context?.previousDetail?.areaId) {
        queryClient.invalidateQueries({
          queryKey: tablesQueryKeys.listsByArea(context.previousDetail.areaId),
        });
      }

      if (!error) {
        queryClient.removeQueries({
          queryKey: tablesQueryKeys.detail(deletedId),
        });
        showSnackbar({ message: 'Mesa eliminada con éxito', type: 'success' });
      }
    },
  });
};

================
File: app/src/modules/availability/components/AvailabilityListItem.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Surface, Text, IconButton, Switch } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface AvailabilityListItemProps {
  title: string;
  subtitle: string;
  icon: string;
  isActive: boolean;
  onToggle: (value: boolean) => void;
  isExpanded?: boolean;
  onToggleExpand?: () => void;
  children?: React.ReactNode;
}

export const AvailabilityListItem: React.FC<AvailabilityListItemProps> = ({
  title,
  subtitle,
  icon,
  isActive,
  onToggle,
  isExpanded = false,
  onToggleExpand,
  children,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  return (
    <Surface
      style={[styles.container, { backgroundColor: theme.colors.surface }]}
      elevation={1}
    >
      {/* Header */}
      <TouchableOpacity
        style={[
          styles.header,
          {
            backgroundColor: theme.colors.elevation.level2,
            opacity: isActive ? 1 : 0.7,
          },
        ]}
        onPress={onToggleExpand}
        activeOpacity={0.7}
        disabled={!onToggleExpand}
      >
        <View style={styles.left}>
          <View
            style={[
              styles.iconContainer,
              {
                backgroundColor: isActive
                  ? theme.colors.primaryContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
          >
            <IconButton
              icon={icon}
              size={20}
              iconColor={isActive ? theme.colors.primary : theme.colors.outline}
              style={{ margin: 0 }}
            />
          </View>
          <View style={styles.info}>
            <Text
              style={[styles.title, { color: theme.colors.onSurface }]}
              numberOfLines={1}
            >
              {title}
            </Text>
            <Text
              style={[
                styles.subtitle,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              {subtitle}
            </Text>
          </View>
        </View>

        <View style={styles.right}>
          <Switch
            value={isActive}
            onValueChange={onToggle}
            color={theme.colors.primary}
            style={styles.switch}
          />
          {onToggleExpand && (
            <IconButton
              icon={isExpanded ? 'chevron-up' : 'chevron-down'}
              size={20}
              iconColor={theme.colors.onSurfaceVariant}
              style={{ margin: 0 }}
            />
          )}
        </View>
      </TouchableOpacity>

      {/* Contenido expandible */}
      {isExpanded && children && (
        <View
          style={[
            styles.expandedContent,
            { backgroundColor: theme.colors.elevation.level1 },
          ]}
        >
          {children}
        </View>
      )}
    </Surface>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      borderRadius: 16,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m),
    },
    left: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    iconContainer: {
      width: responsive.isTablet ? 32 : 40,
      height: responsive.isTablet ? 32 : 40,
      borderRadius: responsive.isTablet ? 16 : 20,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: responsive.spacing(theme.spacing.m),
    },
    info: {
      flex: 1,
    },
    title: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
      marginBottom: 2,
    },
    subtitle: {
      fontSize: responsive.fontSize(12),
      opacity: 0.8,
    },
    right: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    switch: {
      marginHorizontal: responsive.spacing(theme.spacing.s),
    },
    expandedContent: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
  });

================
File: app/src/modules/availability/hooks/useOptimisticAvailability.ts
================
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { availabilityService } from '../services/availabilityService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import {
  CategoryAvailability,
  SubcategoryAvailability as _SubcategoryAvailability,
  ProductAvailability as _ProductAvailability,
  ModifierGroupAvailability,
  ModifierAvailability as _ModifierAvailability,
  PizzaCustomizationGroupAvailability,
  AvailabilityUpdatePayload,
} from '../types/availability.types';

export const useOptimisticAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const updateOptimistically = (
    type: string,
    id: string,
    isActive: boolean,
    cascade?: boolean,
  ) => {
    const menuQueryKey = ['availability', 'menu'];
    const modifierQueryKey = ['availability', 'modifierGroups'];
    const pizzaQueryKey = ['availability', 'pizzaCustomizations'];

    // Función para actualizar categorías optimisticamente
    const updateMenuOptimistically = (oldData: CategoryAvailability[]) => {
      if (!oldData) return oldData;

      return oldData.map((category) => {
        if (type === 'category' && category.id === id) {
          const updated = { ...category, isActive };
          if (cascade) {
            return {
              ...updated,
              subcategories: updated.subcategories.map((sub) => ({
                ...sub,
                isActive,
                products: sub.products.map((prod) => ({ ...prod, isActive })),
              })),
            };
          }
          return updated;
        }

        if (type === 'subcategory') {
          const updatedSubcategories = category.subcategories.map((sub) => {
            if (sub.id === id) {
              const updated = { ...sub, isActive };
              if (cascade) {
                return {
                  ...updated,
                  products: updated.products.map((prod) => ({
                    ...prod,
                    isActive,
                  })),
                };
              }
              return updated;
            }
            return sub;
          });

          return { ...category, subcategories: updatedSubcategories };
        }

        if (type === 'product') {
          const updatedSubcategories = category.subcategories.map((sub) => ({
            ...sub,
            products: sub.products.map((prod) =>
              prod.id === id ? { ...prod, isActive } : prod,
            ),
          }));

          return { ...category, subcategories: updatedSubcategories };
        }

        return category;
      });
    };

    // Función para actualizar grupos de modificadores optimisticamente
    const updateModifierGroupsOptimistically = (
      oldData: ModifierGroupAvailability[],
    ) => {
      if (!oldData) return oldData;

      return oldData.map((group) => {
        if (type === 'modifierGroup' && group.id === id) {
          const updated = { ...group, isActive };
          if (cascade) {
            return {
              ...updated,
              modifiers: updated.modifiers.map((mod) => ({ ...mod, isActive })),
            };
          }
          return updated;
        }

        if (type === 'modifier') {
          const updatedModifiers = group.modifiers.map((mod) =>
            mod.id === id ? { ...mod, isActive } : mod,
          );
          return { ...group, modifiers: updatedModifiers };
        }

        return group;
      });
    };

    // Función para actualizar pizza customizations optimisticamente
    const updatePizzaCustomizationsOptimistically = (
      oldData: PizzaCustomizationGroupAvailability[],
    ) => {
      if (!oldData) return oldData;

      return oldData.map((group) => ({
        ...group,
        items: group.items.map((item) =>
          item.id === id ? { ...item, isActive } : item,
        ),
      }));
    };

    // Actualizar el cache optimisticamente
    if (type === 'category' || type === 'subcategory' || type === 'product') {
      queryClient.setQueryData(menuQueryKey, updateMenuOptimistically);
    } else if (type === 'modifierGroup' || type === 'modifier') {
      queryClient.setQueryData(
        modifierQueryKey,
        updateModifierGroupsOptimistically,
      );
    } else if (type === 'pizzaCustomization') {
      queryClient.setQueryData(
        pizzaQueryKey,
        updatePizzaCustomizationsOptimistically,
      );
    }
  };

  const mutation = useMutation({
    mutationFn: availabilityService.updateAvailability,
    onMutate: async (variables: AvailabilityUpdatePayload) => {
      // Cancelar cualquier refetch pendiente
      await queryClient.cancelQueries({ queryKey: ['availability'] });

      // Guardar estado previo para rollback
      const previousMenuData = queryClient.getQueryData([
        'availability',
        'menu',
      ]);
      const previousModifierData = queryClient.getQueryData([
        'availability',
        'modifierGroups',
      ]);
      const previousPizzaData = queryClient.getQueryData([
        'availability',
        'pizzaCustomizations',
      ]);

      // Actualizar optimisticamente
      updateOptimistically(
        variables.type,
        variables.id,
        variables.isActive,
        variables.cascade,
      );

      // Retornar contexto para rollback
      return {
        previousMenuData,
        previousModifierData,
        previousPizzaData,
        variables,
      };
    },
    onSuccess: () => {
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: (error, variables, context) => {
      // Revertir cambios optimistas
      if (context?.previousMenuData) {
        queryClient.setQueryData(
          ['availability', 'menu'],
          context.previousMenuData,
        );
      }
      if (context?.previousModifierData) {
        queryClient.setQueryData(
          ['availability', 'modifierGroups'],
          context.previousModifierData,
        );
      }
      if (context?.previousPizzaData) {
        queryClient.setQueryData(
          ['availability', 'pizzaCustomizations'],
          context.previousPizzaData,
        );
      }

      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
    onSettled: () => {
      // Invalidar y refetch para asegurar sincronización
      queryClient.invalidateQueries({ queryKey: ['availability'] });
    },
  });

  return mutation;
};

================
File: app/src/modules/customers/components/LocationPicker.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Alert } from 'react-native';
import { Text, Button, TextInput, Chip, HelperText } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';

interface LocationPickerProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: (location: {
    latitude: number;
    longitude: number;
    geocodedAddress?: string;
  }) => void;
  initialLocation?: {
    latitude: number;
    longitude: number;
  };
  address?: string;
}

export default function LocationPicker({
  visible,
  onDismiss,
  onConfirm,
  initialLocation,
  address,
}: LocationPickerProps) {
  const theme = useAppTheme();
  const styles = getStyles(theme);

  const [latitude, setLatitude] = useState(
    initialLocation?.latitude?.toString() || '',
  );
  const [longitude, setLongitude] = useState(
    initialLocation?.longitude?.toString() || '',
  );
  const [geocodedAddress, setGeocodedAddress] = useState(address || '');
  const [latitudeError, setLatitudeError] = useState('');
  const [longitudeError, setLongitudeError] = useState('');

  const validateCoordinates = () => {
    let isValid = true;
    setLatitudeError('');
    setLongitudeError('');

    const lat = parseFloat(latitude);
    const lng = parseFloat(longitude);

    if (!latitude || isNaN(lat)) {
      setLatitudeError('Latitud inválida');
      isValid = false;
    } else if (lat < -90 || lat > 90) {
      setLatitudeError('La latitud debe estar entre -90 y 90');
      isValid = false;
    }

    if (!longitude || isNaN(lng)) {
      setLongitudeError('Longitud inválida');
      isValid = false;
    } else if (lng < -180 || lng > 180) {
      setLongitudeError('La longitud debe estar entre -180 y 180');
      isValid = false;
    }

    return isValid;
  };

  const handleConfirm = () => {
    if (validateCoordinates()) {
      onConfirm({
        latitude: parseFloat(latitude),
        longitude: parseFloat(longitude),
        geocodedAddress: geocodedAddress || undefined,
      });
    }
  };

  const handleUseCurrentLocation = () => {
    Alert.alert(
      'Función no disponible',
      'La función de mapas está temporalmente deshabilitada. Por favor, ingrese las coordenadas manualmente.',
      [{ text: 'OK' }],
    );
  };

  const footerActions = (
    <View style={styles.actions}>
      <Button mode="text" onPress={onDismiss} style={styles.button}>
        Cancelar
      </Button>
      <Button
        mode="contained"
        onPress={handleConfirm}
        disabled={!latitude || !longitude}
        style={styles.button}
      >
        Confirmar
      </Button>
    </View>
  );

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title="Ubicación"
      maxWidthTablet={400}
      scrollable={false}
      footer={footerActions}
    >
      <View style={styles.content}>
        <Text variant="bodyMedium" style={styles.helperText}>
          Ingrese las coordenadas de la ubicación o use el botón para obtener su
          ubicación actual.
        </Text>

        <View style={styles.coordinatesRow}>
          <View style={styles.coordinateInput}>
            <TextInput
              mode="outlined"
              label="Latitud"
              value={latitude}
              onChangeText={setLatitude}
              keyboardType="numeric"
              placeholder="19.4326"
              error={!!latitudeError}
            />
            {latitudeError ? (
              <HelperText type="error" visible={!!latitudeError}>
                {latitudeError}
              </HelperText>
            ) : null}
          </View>

          <View style={styles.coordinateInput}>
            <TextInput
              mode="outlined"
              label="Longitud"
              value={longitude}
              onChangeText={setLongitude}
              keyboardType="numeric"
              placeholder="-99.1332"
              error={!!longitudeError}
            />
            {longitudeError ? (
              <HelperText type="error" visible={!!longitudeError}>
                {longitudeError}
              </HelperText>
            ) : null}
          </View>
        </View>

        <Button
          mode="outlined"
          onPress={handleUseCurrentLocation}
          icon="crosshairs-gps"
          style={styles.locationButton}
        >
          Usar mi ubicación actual
        </Button>

        <TextInput
          mode="outlined"
          label="Dirección (opcional)"
          value={geocodedAddress}
          onChangeText={setGeocodedAddress}
          multiline
          numberOfLines={2}
          placeholder="Calle, número, colonia, ciudad..."
          style={styles.addressInput}
        />

        {latitude && longitude && !latitudeError && !longitudeError && (
          <View style={styles.previewContainer}>
            <Text variant="labelMedium" style={styles.previewLabel}>
              Vista previa de coordenadas:
            </Text>
            <View style={styles.chipsContainer}>
              <Chip icon="map-marker" compact mode="flat">
                {parseFloat(latitude).toFixed(6)},{' '}
                {parseFloat(longitude).toFixed(6)}
              </Chip>
            </View>
          </View>
        )}
      </View>
    </ResponsiveModal>
  );
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    content: {
      // ResponsiveModal maneja el padding
    },
    helperText: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.m,
    },
    coordinatesRow: {
      flexDirection: 'row',
      gap: theme.spacing.m,
      marginBottom: theme.spacing.m,
    },
    coordinateInput: {
      flex: 1,
    },
    locationButton: {
      marginBottom: theme.spacing.m,
    },
    addressInput: {
      marginBottom: theme.spacing.m,
    },
    previewContainer: {
      marginTop: theme.spacing.s,
    },
    previewLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.s,
    },
    chipsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.s,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      gap: theme.spacing.s,
      // ResponsiveModal maneja padding, border
    },
    button: {
      minWidth: 100,
    },
  });

================
File: app/src/modules/customers/schema/customer.schema.ts
================
import { z } from 'zod';

// Schema para dirección
export const addressSchema = z.object({
  name: z.string().min(1, 'El nombre de la dirección es requerido').max(100),
  street: z.string().min(1, 'La calle es requerida'),
  number: z.string().min(1, 'El número es requerido'),
  interiorNumber: z.string().optional(),
  neighborhood: z.string().min(1, 'La colonia es requerida'),
  city: z.string().min(1, 'La ciudad es requerida'),
  state: z.string().min(1, 'El estado es requerido'),
  zipCode: z.string().regex(/^\d{5}$/, 'El código postal debe tener 5 dígitos'),
  country: z.string().min(1, 'El país es requerido').default('México'),
  deliveryInstructions: z.string().optional(),
  latitude: z.number().min(-90).max(90).optional(),
  longitude: z.number().min(-180).max(180).optional(),
  isDefault: z.boolean().optional(),
});

// Schema para crear cliente
export const createCustomerSchema = z.object({
  firstName: z.string().min(1, 'El nombre es requerido').max(100),
  lastName: z.string().min(1, 'El apellido es requerido').max(100),
  whatsappPhoneNumber: z.string().min(1, 'El número de WhatsApp es requerido'),
  email: z
    .string()
    .email('El correo electrónico no es válido')
    .optional()
    .or(z.literal('')),
  birthDate: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'La fecha debe tener el formato YYYY-MM-DD')
    .optional()
    .or(z.literal('')),
  isActive: z.boolean().optional(),
  isBanned: z.boolean().optional(),
  addresses: z.array(addressSchema).optional(),
});

// Schema para actualizar cliente
export const updateCustomerSchema = createCustomerSchema.partial();

// Schema para formularios
export const customerFormSchema = z.object({
  firstName: z.string().min(1, 'El nombre es requerido').max(100),
  lastName: z.string().min(1, 'El apellido es requerido').max(100),
  whatsappPhoneNumber: z.string().min(1, 'El número de WhatsApp es requerido'),
  email: z
    .string()
    .email('El correo electrónico no es válido')
    .optional()
    .or(z.literal('')),
  birthDate: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'La fecha debe tener el formato YYYY-MM-DD')
    .optional()
    .or(z.literal('')),
  isActive: z.boolean(),
  isBanned: z.boolean(),
  banReason: z.string().optional().or(z.literal('')),
});

// Types derivados de los schemas
export type AddressFormInputs = z.infer<typeof addressSchema>;
export type CustomerFormInputs = z.infer<typeof customerFormSchema>;
export type CreateCustomerInput = z.infer<typeof createCustomerSchema>;
export type UpdateCustomerInput = z.infer<typeof updateCustomerSchema>;

================
File: app/src/modules/customers/services/addressesService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Address,
  CreateAddressDto,
  UpdateAddressDto,
} from '../types/customer.types';

async function create(
  customerId: string,
  data: CreateAddressDto,
): Promise<Address> {
  const response = await apiClient.post<Address>(
    API_PATHS.ADDRESSES_BY_CUSTOMER.replace(':customerId', customerId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function update(
  addressId: string,
  data: UpdateAddressDto,
): Promise<Address> {
  const response = await apiClient.patch<Address>(
    API_PATHS.ADDRESSES_BY_ID.replace(':id', addressId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function remove(addressId: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.ADDRESSES_BY_ID.replace(':id', addressId),
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

export const addressesService = {
  create,
  update,
  remove,
};

================
File: app/src/modules/customers/types/customer.types.ts
================
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
}

export interface Address {
  id: string;
  name: string;
  street: string;
  number: string;
  interiorNumber?: string;
  neighborhood: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault: boolean;
  customerId: string;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
}

export interface Customer {
  id: string;
  firstName: string;
  lastName: string;
  whatsappPhoneNumber: string;
  stripeCustomerId?: string | null;
  email?: string | null;
  birthDate?: Date | null;
  fullChatHistory?: ChatMessage[] | null;
  relevantChatHistory?: ChatMessage[] | null;
  lastInteraction?: Date | null;
  totalOrders: number;
  totalSpent: number;
  isActive: boolean;
  isBanned: boolean;
  bannedAt?: Date | null;
  banReason?: string | null;
  whatsappMessageCount: number;
  lastWhatsappMessageTime?: Date | null;
  addresses: Address[];
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
}

export interface CreateCustomerDto {
  firstName: string;
  lastName: string;
  whatsappPhoneNumber: string;
  email?: string;
  birthDate?: string;
  isActive?: boolean;
  isBanned?: boolean;
  whatsappMessageCount?: number;
  lastWhatsappMessageTime?: string;
  addresses?: CreateAddressDto[];
}

export interface UpdateCustomerDto {
  firstName?: string;
  lastName?: string;
  whatsappPhoneNumber?: string;
  email?: string | null;
  birthDate?: string | null;
  isActive?: boolean;
  isBanned?: boolean;
  bannedAt?: string;
  banReason?: string | null;
  whatsappMessageCount?: number;
  lastWhatsappMessageTime?: string;
  fullChatHistory?: ChatMessage[];
  relevantChatHistory?: ChatMessage[];
  lastInteraction?: string;
}

export interface CreateAddressDto {
  name: string;
  street: string;
  number: string;
  interiorNumber?: string;
  neighborhood: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault?: boolean;
}

export interface UpdateAddressDto {
  name?: string;
  street?: string;
  number?: string;
  interiorNumber?: string;
  neighborhood?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault?: boolean;
}

export interface FindAllCustomersQuery {
  firstName?: string;
  lastName?: string;
  email?: string;
  whatsappPhoneNumber?: string;
  isActive?: boolean;
  isBanned?: boolean;
  lastInteractionAfter?: Date;
  page?: number;
  limit?: number;
}

================
File: app/src/modules/menu/hooks/useProductsQueries.ts
================
import {
  useQuery,
  useMutation,
  useQueryClient,
  UseQueryResult,
  UseMutationResult,
} from '@tanstack/react-query';
import { productsService } from '../services/productsService';
import {
  Product,
  ProductFormInputs,
  FindAllProductsQuery,
  AssignModifierGroupsInput,
} from '../schema/products.schema';
import { PaginatedResponse } from '@/app/types/api.types';
import { ApiError } from '@/app/lib/errors';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';

const productKeys = {
  all: ['products'] as const,
  lists: (filters: FindAllProductsQuery) =>
    [...productKeys.all, 'list', filters] as const,
  details: (id: string) => [...productKeys.all, 'detail', id] as const,
  detailModifierGroups: (id: string) =>
    [...productKeys.details(id), 'modifier-groups'] as const,
};

export function useProductsQuery(
  filters: FindAllProductsQuery,
  options?: { enabled?: boolean },
): UseQueryResult<PaginatedResponse<Product>, ApiError> {
  return useQuery<PaginatedResponse<Product>, ApiError>({
    queryKey: productKeys.lists(filters),
    queryFn: () => productsService.findAll(filters),
    enabled: options?.enabled ?? true,
  });
}

export function useProductQuery(
  productId: string,
  options?: { enabled?: boolean },
): UseQueryResult<Product, ApiError> {
  return useQuery<Product, ApiError>({
    queryKey: productKeys.details(productId),
    queryFn: () => productsService.findOne(productId),
    enabled: !!productId && (options?.enabled ?? true),
  });
}

export function useCreateProductMutation(): UseMutationResult<
  Product,
  ApiError,
  ProductFormInputs
> {
  const queryClient = useQueryClient();
  return useMutation<Product, ApiError, ProductFormInputs>({
    mutationFn: (newProduct) => {
      return productsService.create(newProduct);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });
    },
    onError: () => {},
  });
}

export function useUpdateProductMutation(): UseMutationResult<
  Product,
  ApiError,
  { id: string; data: Partial<ProductFormInputs> },
  { previousProducts?: PaginatedResponse<Product>; previousDetail?: Product }
> {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type UpdateProductContext = { previousDetail?: Product };

  return useMutation<
    Product,
    ApiError,
    { id: string; data: Partial<ProductFormInputs> },
    UpdateProductContext
  >({
    mutationFn: ({ id, data }) => productsService.update(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = productKeys.details(id);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Product>(detailQueryKey);

      if (previousDetail) {
        queryClient.setQueryData<Product>(
          detailQueryKey,
          (old: Product | undefined) => {
            // Añadido tipo explícito
            if (!old) return undefined;
            const { variants, modifierGroupIds, ...restOfData } = data;
            return { ...old, ...restOfData };
          },
        );
      }

      return { previousDetail };
    },

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          productKeys.details(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, _variables) => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });

      if (!error && data) {
        showSnackbar({
          message: 'Producto actualizado con éxito',
          type: 'success',
        });
      }
    },
  });
}

export function useDeleteProductMutation(): UseMutationResult<
  void,
  ApiError,
  string,
  { previousDetail?: Product }
> {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar); // Añadir Snackbar

  type DeleteProductContext = { previousDetail?: Product };

  return useMutation<void, ApiError, string, DeleteProductContext>({
    mutationFn: (productId) => productsService.remove(productId),

    onMutate: async (deletedId) => {
      const detailQueryKey = productKeys.details(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Product>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          productKeys.details(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });

      if (!error) {
        queryClient.removeQueries({ queryKey: productKeys.details(deletedId) });
        showSnackbar({
          message: 'Producto eliminado con éxito',
          type: 'success',
        });
      }
    },
  });
}

export function useAssignModifierGroupsMutation(): UseMutationResult<
  Product,
  ApiError,
  { productId: string; data: AssignModifierGroupsInput }
> {
  const queryClient = useQueryClient();
  return useMutation<
    Product,
    ApiError,
    { productId: string; data: AssignModifierGroupsInput }
  >({
    mutationFn: ({ productId, data }) =>
      productsService.assignModifierGroups(productId, data),
    onSuccess: (updatedProduct) => {
      queryClient.invalidateQueries({
        queryKey: productKeys.details(updatedProduct.id),
      });
      queryClient.invalidateQueries({
        queryKey: productKeys.detailModifierGroups(updatedProduct.id),
      });
    },
  });
}

export function useProductModifierGroupsQuery(
  productId: string,
  options?: { enabled?: boolean },
): UseQueryResult<Product, ApiError> {
  return useQuery<Product, ApiError>({
    queryKey: productKeys.detailModifierGroups(productId),
    queryFn: () => productsService.getModifierGroups(productId),
    enabled: !!productId && (options?.enabled ?? true),
  });
}

export function useRemoveModifierGroupsMutation(): UseMutationResult<
  Product,
  ApiError,
  { productId: string; data: AssignModifierGroupsInput }
> {
  const queryClient = useQueryClient();
  return useMutation<
    Product,
    ApiError,
    { productId: string; data: AssignModifierGroupsInput }
  >({
    mutationFn: ({ productId, data }) =>
      productsService.removeModifierGroups(productId, data),
    onSuccess: (updatedProduct) => {
      queryClient.invalidateQueries({
        queryKey: productKeys.details(updatedProduct.id),
      });
      queryClient.invalidateQueries({
        queryKey: productKeys.detailModifierGroups(updatedProduct.id),
      });
    },
  });
}

================
File: app/src/modules/menu/hooks/useSubcategoriesQueries.ts
================
import {
  useQuery,
  useMutation,
  useQueryClient,
  type UseQueryResult,
  type UseMutationResult,
} from '@tanstack/react-query';
import * as subcategoriesService from '../services/subcategoriesService';
import {
  SubCategory,
  CreateSubCategoryDto,
  UpdateSubCategoryDto,
  findAllSubcategoriesDtoSchema,
} from '../schema/subcategories.schema';
import { z } from 'zod';
import { PaginatedResponse } from '../../../app/types/api.types';
import { ApiError } from '../../../app/lib/errors';
import {
  useSnackbarStore,
  type SnackbarState,
} from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

type FindAllSubcategoriesDto = z.infer<typeof findAllSubcategoriesDtoSchema>;

const subcategoryKeys = {
  all: ['subcategories'] as const,
  lists: () => [...subcategoryKeys.all, 'list'] as const,
  list: (filters: FindAllSubcategoriesDto) =>
    [...subcategoryKeys.lists(), filters] as const,
  details: () => [...subcategoryKeys.all, 'detail'] as const,
  detail: (id: string) => [...subcategoryKeys.details(), id] as const,
};

export const useFindAllSubcategories = (
  params: FindAllSubcategoriesDto = { page: 1, limit: 10 },
  enabled: boolean = true,
): UseQueryResult<PaginatedResponse<SubCategory>, ApiError> => {
  const queryKey = subcategoryKeys.list(params);
  return useQuery<PaginatedResponse<SubCategory>, ApiError>({
    queryKey: queryKey,
    queryFn: () => subcategoriesService.findAllSubcategories(params),
    enabled: enabled,
  });
};

export const useFindOneSubcategory = (
  id: string | undefined,
  enabled: boolean = true,
): UseQueryResult<SubCategory, ApiError> => {
  const queryKey = subcategoryKeys.detail(id!);
  return useQuery<SubCategory, ApiError>({
    queryKey: queryKey,
    queryFn: () => subcategoriesService.findOneSubcategory(id!),
    enabled: enabled && !!id,
  });
};

type UpdateSubcategoryContext = {
  previousDetail?: SubCategory;
};

export const useCreateSubcategory = (): UseMutationResult<
  SubCategory,
  ApiError,
  CreateSubCategoryDto
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );

  return useMutation<SubCategory, ApiError, CreateSubCategoryDto>({
    mutationFn: subcategoriesService.createSubcategory,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });
      showSnackbar({
        message: 'Subcategoría creada con éxito',
        type: 'success',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
    },
  });
};

export const useUpdateSubcategory = (): UseMutationResult<
  SubCategory,
  ApiError,
  { id: string; data: UpdateSubCategoryDto },
  UpdateSubcategoryContext
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );

  return useMutation<
    SubCategory,
    ApiError,
    { id: string; data: UpdateSubCategoryDto },
    UpdateSubcategoryContext
  >({
    mutationFn: ({ id, data }) =>
      subcategoriesService.updateSubcategory(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = subcategoryKeys.detail(id);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail =
        queryClient.getQueryData<SubCategory>(detailQueryKey);

      if (previousDetail) {
        queryClient.setQueryData<SubCategory>(
          detailQueryKey,
          (
            old: SubCategory | undefined, // Añadido tipo explícito
          ) => (old ? { ...old, ...data } : undefined),
        );
      }

      return { previousDetail };
    },

    onError: (error, variables, context) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          subcategoryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: subcategoryKeys.detail(variables.id),
      });

      if (!error && data) {
        showSnackbar({
          message: 'Subcategoría actualizada con éxito',
          type: 'success',
        });
      }
    },
  });
};

export const useRemoveSubcategory = (): UseMutationResult<
  void,
  ApiError,
  string,
  { previousDetail?: SubCategory }
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );

  type DeleteSubcategoryContext = { previousDetail?: SubCategory };

  return useMutation<void, ApiError, string, DeleteSubcategoryContext>({
    mutationFn: subcategoriesService.removeSubcategory,

    onMutate: async (deletedId) => {
      const detailQueryKey = subcategoryKeys.detail(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail =
        queryClient.getQueryData<SubCategory>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          subcategoryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });

      if (!error) {
        queryClient.removeQueries({
          queryKey: subcategoryKeys.detail(deletedId),
        });
        showSnackbar({
          message: 'Subcategoría eliminada con éxito',
          type: 'success',
        });
      }
    },
  });
};

================
File: app/src/modules/menu/services/subcategoriesService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  SubCategory,
  CreateSubCategoryDto,
  UpdateSubCategoryDto,
  findAllSubcategoriesDtoSchema,
} from '../schema/subcategories.schema';
import { z } from 'zod';
import { PaginatedResponse } from '../../../app/types/api.types';

type FindAllSubcategoriesDto = z.infer<typeof findAllSubcategoriesDtoSchema>;

export const createSubcategory = async (
  data: CreateSubCategoryDto,
): Promise<SubCategory> => {
  const response = await ApiClientWrapper.post<SubCategory>(
    API_PATHS.SUBCATEGORIES,
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
};

export const findAllSubcategories = async (
  params: FindAllSubcategoriesDto,
): Promise<PaginatedResponse<SubCategory>> => {
  const queryParams = Object.entries(params).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    },
    {} as Record<string, any>,
  );

  const response = await ApiClientWrapper.get<{
    items: SubCategory[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.SUBCATEGORIES, queryParams);

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  // Transforma la respuesta del backend a PaginatedResponse
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};

export const findOneSubcategory = async (id: string): Promise<SubCategory> => {
  const response = await ApiClientWrapper.get<SubCategory>(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
};

export const updateSubcategory = async (
  id: string,
  data: UpdateSubCategoryDto,
): Promise<SubCategory> => {
  const response = await ApiClientWrapper.patch<SubCategory>(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
};

export const removeSubcategory = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    if (response.data) {
      // Hay un cuerpo de error definido por el backend
      throw ApiError.fromApiResponse(response.data, response.status);
    } else if (response.status !== 404) {
      // No hay cuerpo de error, pero no es un 404 esperado
      throw new Error(
        `Error deleting subcategory ${id}: Status ${response.status}`,
      );
    }
    // Si es 404, no se lanza error.
  }
  // No se devuelve nada en caso de éxito (204) o 404.
};

================
File: app/src/modules/modifiers/components/ModifierFormModal.tsx
================
import React, { useMemo, useCallback } from 'react';
import { z } from 'zod';
import { useMutation, useQueryClient } from '@tanstack/react-query';

import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import GenericFormModal, {
  FormFieldConfig,
} from '@/app/components/crud/GenericFormModal';
import { modifierService } from '../services/modifierService';
import { ModifierFormInputs } from '../types/modifier.types';
import {
  Modifier,
  modifierFormValidationSchema, // Cambiado de modifierSchema
  CreateModifierInput,
  UpdateModifierInput,
} from '../schema/modifier.schema';

interface Props {
  visible: boolean;
  onDismiss: () => void;
  onSaveSuccess: () => void;
  initialData?: Modifier | null;
  groupId: string;
}

const formFields: FormFieldConfig<ModifierFormInputs>[] = [
  { name: 'name', label: 'Nombre *', type: 'text', required: true },
  {
    name: 'description',
    label: 'Descripción (Opcional)',
    type: 'textarea',
    numberOfLines: 3,
  },
  {
    name: 'price',
    label: 'Precio Adicional (Opcional)',
    type: 'number',
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'sortOrder',
    label: 'Orden de Visualización',
    type: 'number',
    defaultValue: 0,
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'isDefault',
    label: 'Seleccionado por Defecto',
    type: 'switch',
    defaultValue: false,
  },
  { name: 'isActive', label: 'Activo', type: 'switch', defaultValue: true },
];

const formSchema = modifierFormValidationSchema;

const ModifierFormModal: React.FC<Props> = ({
  visible,
  onDismiss,
  onSaveSuccess,
  initialData,
  groupId,
}) => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const isEditing = !!initialData;
  const QUERY_KEY_TO_INVALIDATE = ['modifiers', groupId];

  const mutation = useMutation<
    Modifier,
    Error,
    CreateModifierInput | UpdateModifierInput
  >({
    mutationFn: (data) => {
      if (isEditing && initialData) {
        return modifierService.update(
          initialData.id,
          data as UpdateModifierInput,
        );
      } else {
        return modifierService.create(data as CreateModifierInput);
      }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEY_TO_INVALIDATE });
      showSnackbar({
        message: `Modificador "${data.name}" ${isEditing ? 'actualizado' : 'creado'} correctamente`,
        type: 'success',
      });
      onSaveSuccess();
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      // Error al guardar modificador
    },
  });

  const handleFormSubmit = useCallback(
    async (formData: ModifierFormInputs) => {
      const dataToSend: CreateModifierInput | UpdateModifierInput = {
        ...formData,
        price:
          formData.price === undefined || isNaN(Number(formData.price))
            ? null
            : Number(formData.price),
        description:
          formData.description === undefined ? null : formData.description,
        sortOrder: formData.sortOrder ?? 0,
        isDefault: formData.isDefault ?? false,
        isActive: formData.isActive ?? true,
        modifierGroupId: groupId,
      };

      try {
        await mutation.mutateAsync(dataToSend);
      } catch (error) {
        // Fallo en la mutación al enviar el formulario
      }
    },
    [
      mutation,
      groupId,
      isEditing,
      initialData?.id,
      onSaveSuccess,
      queryClient,
      showSnackbar,
    ],
  );

  return (
    <GenericFormModal<ModifierFormInputs, Modifier>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={handleFormSubmit}
      formSchema={formSchema as z.ZodSchema<ModifierFormInputs>}
      formFields={formFields}
      editingItem={initialData ?? null}
      isSubmitting={mutation.isPending}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Modificador' : 'Crear Nuevo Modificador'
      }
      initialValues={useMemo(
        () =>
          initialData
            ? {
                name: initialData.name,
                description: initialData.description,
                price: initialData.price,
                sortOrder: initialData.sortOrder,
                isDefault: initialData.isDefault,
                isActive: initialData.isActive,
              }
            : {
                name: '',
                description: null,
                price: null,
                sortOrder: 0,
                isDefault: false,
                isActive: true,
              },
        [initialData],
      )}
    />
  );
};

export default ModifierFormModal;

================
File: app/src/modules/orders/hooks/useMenuQueries.ts
================
import { useQuery } from '@tanstack/react-query';
import { useEffect } from 'react';
// Importar desde el servicio de categorías
import { getOrderMenu } from '@/modules/menu/services/categoryService';
// Importar el tipo de menú completo con relaciones anidadas
import type { FullMenuCategory } from '@/modules/orders/types/orders.types';
import { ApiError } from '@/app/lib/errors';
import { prefetchMenuImages } from '@/app/lib/imageCache';

// Define clave única para la query
const orderMenuQueryKey = ['orderMenu'];

/**
 * Hook para obtener el menú en pantallas de creación y edición de órdenes.
 * Devuelve solo los campos necesarios para mejorar el rendimiento.
 */
export function useGetOrderMenu() {
  const query = useQuery<FullMenuCategory[], ApiError>({
    queryKey: orderMenuQueryKey,
    queryFn: getOrderMenu,
    refetchInterval: 10000, // Actualizar cada 10 segundos
    refetchIntervalInBackground: false, // No actualizar cuando la app está en background
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000, // Los datos se consideran frescos por 5 segundos
    // IMPORTANTE: Mantener datos previos durante refetch para evitar parpadeos
    keepPreviousData: true,
    // No mostrar loading en refetch para mantener la UI estable
    notifyOnChangeProps: ['data', 'error'],
  });

  // Prefetch de imágenes cuando se cargan los datos del menú
  useEffect(() => {
    if (query.data && query.data.length > 0) {
      // Prefetch en background sin bloquear la UI
      prefetchMenuImages(query.data, {
        maxConcurrent: 3, // Limitar concurrencia para no saturar la red
      }).catch(() => {
        // Silenciar errores de prefetch para no afectar la UX
      });
    }
  }, [query.data]);

  return query;
}

================
File: app/src/modules/orders/services/adjustmentService.ts
================
import apiClient from '@/app/services/apiClient';
import { handleApiResponse } from '@/app/lib/apiHelpers';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Adjustment } from '@/app/schemas/domain/adjustment.schema';
import type { OrderAdjustmentDto } from '../types/update-order.types';

export const adjustmentService = {
  /**
   * Crea múltiples ajustes para una orden
   */
  createBulkAdjustments: async (
    adjustments: OrderAdjustmentDto[],
  ): Promise<Adjustment[]> => {
    const response = await apiClient.post<Adjustment[]>(
      API_PATHS.ADJUSTMENTS + '/bulk',
      adjustments,
    );
    return handleApiResponse(response);
  },

  /**
   * Obtiene los ajustes de una orden
   */
  getOrderAdjustments: async (orderId: string): Promise<Adjustment[]> => {
    const response = await apiClient.get<Adjustment[]>(
      API_PATHS.ADJUSTMENTS + '/order/' + orderId,
    );
    return handleApiResponse(response);
  },

  /**
   * Elimina un ajuste (solo admin)
   */
  deleteAdjustment: async (adjustmentId: string): Promise<void> => {
    const response = await apiClient.delete<void>(
      API_PATHS.ADJUSTMENTS_BY_ID.replace(':id', adjustmentId),
    );
    return handleApiResponse(response);
  },

  /**
   * Obtiene el total de ajustes de una orden
   */
  getOrderAdjustmentsTotal: async (
    orderId: string,
  ): Promise<{ total: number }> => {
    const response = await apiClient.get<{ total: number }>(
      API_PATHS.ADJUSTMENTS + '/order/' + orderId + '/total',
    );
    return handleApiResponse(response);
  },
};

================
File: app/src/modules/orders/types/payment.types.ts
================
export enum PaymentMethodEnum {
  CASH = 'CASH',
  CARD = 'CARD', // Fusionado crédito y débito
  TRANSFER = 'TRANSFER',
}

export enum PaymentStatusEnum {
  PENDING = 'PENDING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED',
  CANCELLED = 'CANCELLED',
}

export type PaymentMethod = keyof typeof PaymentMethodEnum;
export type PaymentStatus = keyof typeof PaymentStatusEnum;

export interface Payment {
  id: string;
  orderId: string;
  paymentMethod: PaymentMethod;
  amount: number;
  paymentStatus: PaymentStatus;
  createdAt: string;
  updatedAt: string;
  order?: {
    id: string;
    shiftOrderNumber: number;
    total: number;
  };
}

export interface CreatePaymentDto {
  orderId: string;
  paymentMethod: PaymentMethod;
  amount: number;
}

export interface UpdatePaymentDto {
  paymentMethod?: PaymentMethod;
  amount?: number;
  paymentStatus?: PaymentStatus;
}

================
File: app/src/modules/pizzaCustomizations/components/AssociatePizzaToppingsModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  Checkbox,
  Button,
  IconButton,
  Chip,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { productsService } from '@/modules/menu/services/productsService';
import { pizzaCustomizationsService } from '../services/pizzaCustomizationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { CustomizationType } from '../types/pizzaCustomization.types';
import type { Product } from '@/modules/menu/schema/products.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

interface AssociatePizzaToppingsModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product | null;
}

export function AssociatePizzaToppingsModal({
  visible,
  onDismiss,
  product,
}: AssociatePizzaToppingsModalProps) {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [selectedToppings, setSelectedToppings] = useState<Set<string>>(
    new Set(),
  );
  const [hasChanges, setHasChanges] = useState(false);
  const [filterType, setFilterType] = useState<
    'all' | 'flavors' | 'ingredients'
  >('all');
  const [showConfirmation, setShowConfirmation] = useState(false);

  // Query para obtener todos los toppings (sabores e ingredientes)
  const { data: allToppings, isLoading: isLoadingToppings } = useQuery({
    queryKey: ['pizza-toppings-modal'],
    queryFn: async () => {
      const response = await pizzaCustomizationsService.findAll({
        page: 1,
        limit: 100,
        isActive: true,
      });
      return response.data || [];
    },
    enabled: visible,
  });

  // Query para obtener los toppings asociados al producto
  const { data: associatedToppings, isLoading: isLoadingAssociated } = useQuery(
    {
      queryKey: ['product-pizza-toppings', product?.id],
      queryFn: async () => {
        if (!product?.id) return [];
        const result = await productsService.getPizzaCustomizations(product.id);
        return result || [];
      },
      enabled: !!product?.id && visible,
    },
  );

  // Inicializar selecciones cuando se cargan los datos
  useEffect(() => {
    if (associatedToppings && visible && product) {
      const associatedIds = new Set(associatedToppings.map((t) => t.id));
      setSelectedToppings(associatedIds);
      setHasChanges(false);
    }
  }, [associatedToppings, visible, product]);

  // Mutation para actualizar asociaciones
  const updateMutation = useMutation({
    mutationFn: async () => {
      if (!product) throw new Error('No hay producto seleccionado');

      await productsService.updatePizzaCustomizations(
        product.id,
        Array.from(selectedToppings),
      );
    },
    onSuccess: () => {
      showSnackbar({
        message: 'Sabores e ingredientes actualizados exitosamente',
        type: 'success',
      });
      queryClient.invalidateQueries({
        queryKey: ['product-pizza-toppings', product?.id],
      });
      queryClient.invalidateQueries({ queryKey: ['pizza-products'] });
      queryClient.invalidateQueries({ queryKey: ['pizza-configurations'] });
      setHasChanges(false);
      onDismiss();
    },
    onError: (error) => {
      showSnackbar({
        message: error instanceof Error ? error.message : 'Error al actualizar',
        type: 'error',
      });
    },
  });

  const toggleTopping = (toppingId: string) => {
    setSelectedToppings((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(toppingId)) {
        newSet.delete(toppingId);
      } else {
        newSet.add(toppingId);
      }
      return newSet;
    });
    setHasChanges(true);
  };

  const toggleAll = () => {
    if (!allToppings) return;

    if (selectedToppings.size === allToppings.length) {
      setSelectedToppings(new Set());
    } else {
      setSelectedToppings(new Set(allToppings.map((t) => t.id)));
    }
    setHasChanges(true);
  };

  const filteredToppings = useMemo(() => {
    if (!allToppings || !Array.isArray(allToppings)) {
      return {
        flavors: [],
        ingredients: [],
        displayFlavors: [],
        displayIngredients: [],
      };
    }

    const flavors = allToppings.filter(
      (t) => t.type === CustomizationType.FLAVOR,
    );
    const ingredients = allToppings.filter(
      (t) => t.type === CustomizationType.INGREDIENT,
    );

    return {
      flavors,
      ingredients,
      displayFlavors: filterType === 'ingredients' ? [] : flavors,
      displayIngredients: filterType === 'flavors' ? [] : ingredients,
    };
  }, [allToppings, filterType]);

  const isLoading = isLoadingToppings || isLoadingAssociated;

  const styles = StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: theme.spacing.m,
      marginTop: theme.spacing.xl * 2,
      borderRadius: theme.roundness * 2,
      height: '90%',
      maxHeight: '90%',
    },
    header: {
      backgroundColor: theme.colors.elevation.level1,
      borderTopLeftRadius: theme.roundness * 2,
      borderTopRightRadius: theme.roundness * 2,
      paddingHorizontal: theme.spacing.m,
      paddingTop: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    titleIcon: {
      margin: 0,
      marginRight: theme.spacing.xs,
    },
    title: {
      fontSize: 20,
      fontWeight: '700',
      color: theme.colors.onSurface,
    },
    subtitle: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      marginLeft: theme.spacing.xl + theme.spacing.m,
    },
    closeButton: {
      margin: 0,
    },
    filterContainer: {
      backgroundColor: theme.colors.background,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.m,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    filterButtons: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      justifyContent: 'space-between',
    },
    filterChip: {
      flex: 1,
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.outlineVariant,
      height: 32,
    },
    filterChipActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    filterChipText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    filterChipTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    content: {
      flex: 1,
      minHeight: 200,
    },
    scrollContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2,
    },
    selectAllContainer: {
      marginBottom: theme.spacing.l,
      paddingTop: theme.spacing.s,
    },
    selectAllButton: {
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    selectAllContent: {
      paddingVertical: theme.spacing.xs,
    },
    selectionCount: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      textAlign: 'center',
      marginTop: theme.spacing.xs,
    },
    section: {
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      fontSize: 14,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.m,
      textTransform: 'uppercase',
      letterSpacing: 1,
    },
    toppingItem: {
      marginBottom: theme.spacing.xs,
    },
    checkbox: {
      paddingVertical: theme.spacing.s,
      paddingHorizontal: 0,
      marginHorizontal: 0,
    },
    checkboxLabel: {
      textAlign: 'left',
      marginLeft: theme.spacing.xs,
    },
    ingredientsText: {
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginLeft: theme.spacing.xl * 2,
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
      fontSize: 12,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: 200,
    },
    emptyState: {
      padding: theme.spacing.xl,
      alignItems: 'center',
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.m,
      gap: theme.spacing.m,
    },
    actionButton: {
      flex: 1,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    cancelButton: {
      borderColor: theme.colors.outlineVariant,
    },
    saveButton: {
      borderWidth: 0,
    },
  });

  if (!product) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (hasChanges) {
            setShowConfirmation(true);
          } else {
            onDismiss();
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={true}
      >
        <View style={styles.header}>
          <View style={styles.headerContent}>
            <View style={styles.titleContainer}>
              <IconButton
                icon="food-variant"
                size={20}
                iconColor={theme.colors.primary}
                style={styles.titleIcon}
              />
              <Text style={styles.title}>Personalizar Producto</Text>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={() => {
                if (hasChanges) {
                  setShowConfirmation(true);
                } else {
                  onDismiss();
                }
              }}
              style={styles.closeButton}
            />
          </View>
          <Text style={styles.subtitle}>{product.name}</Text>
        </View>

        <View style={styles.filterContainer}>
          <View style={styles.filterButtons}>
            <Chip
              mode={filterType === 'all' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('all')}
              style={[
                styles.filterChip,
                filterType === 'all' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'all' && styles.filterChipTextActive,
              ]}
              icon="format-list-bulleted"
              compact
            >
              Todos
            </Chip>
            <Chip
              mode={filterType === 'flavors' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('flavors')}
              style={[
                styles.filterChip,
                filterType === 'flavors' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'flavors' && styles.filterChipTextActive,
              ]}
              icon="pizza"
              compact
            >
              Sabores
            </Chip>
            <Chip
              mode={filterType === 'ingredients' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('ingredients')}
              style={[
                styles.filterChip,
                filterType === 'ingredients' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'ingredients' && styles.filterChipTextActive,
              ]}
              icon="food-variant"
              compact
            >
              Ingredientes
            </Chip>
          </View>
        </View>

        <View style={styles.content}>
          {isLoading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
            </View>
          ) : (
            <ScrollView
              contentContainerStyle={styles.scrollContent}
              showsVerticalScrollIndicator={true}
            >
              <View style={styles.selectAllContainer}>
                <Button
                  mode="contained-tonal"
                  onPress={toggleAll}
                  style={styles.selectAllButton}
                  icon={
                    selectedToppings.size === allToppings?.length
                      ? 'checkbox-marked'
                      : 'checkbox-blank-outline'
                  }
                  contentStyle={styles.selectAllContent}
                >
                  {selectedToppings.size === allToppings?.length
                    ? 'Quitar selección'
                    : 'Seleccionar todo'}
                </Button>
                <Text style={styles.selectionCount}>
                  {selectedToppings.size} de {allToppings?.length || 0}{' '}
                  seleccionados
                </Text>
              </View>

              {filteredToppings.displayFlavors.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>
                    Sabores ({filteredToppings.displayFlavors.length})
                  </Text>
                  {filteredToppings.displayFlavors.map((flavor) => (
                    <View key={flavor.id} style={styles.toppingItem}>
                      <Checkbox.Item
                        label={flavor.name}
                        status={
                          selectedToppings.has(flavor.id)
                            ? 'checked'
                            : 'unchecked'
                        }
                        onPress={() => toggleTopping(flavor.id)}
                        labelStyle={styles.checkboxLabel}
                        style={styles.checkbox}
                        position="leading"
                      />
                      {flavor.ingredients && (
                        <Text style={styles.ingredientsText}>
                          {flavor.ingredients}
                        </Text>
                      )}
                    </View>
                  ))}
                </View>
              )}

              {filteredToppings.displayIngredients.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>
                    Ingredientes ({filteredToppings.displayIngredients.length})
                  </Text>
                  {filteredToppings.displayIngredients.map((ingredient) => (
                    <View key={ingredient.id} style={styles.toppingItem}>
                      <Checkbox.Item
                        label={ingredient.name}
                        status={
                          selectedToppings.has(ingredient.id)
                            ? 'checked'
                            : 'unchecked'
                        }
                        onPress={() => toggleTopping(ingredient.id)}
                        labelStyle={styles.checkboxLabel}
                        style={styles.checkbox}
                        position="leading"
                      />
                    </View>
                  ))}
                </View>
              )}

              {filteredToppings.displayFlavors.length === 0 &&
                filteredToppings.displayIngredients.length === 0 && (
                  <View style={styles.emptyState}>
                    <Text style={styles.emptyText}>
                      No hay sabores ni ingredientes disponibles
                    </Text>
                  </View>
                )}
            </ScrollView>
          )}
        </View>

        <Divider />

        <View>
          <View style={styles.actions}>
            <Button
              mode="outlined"
              onPress={() => {
                if (hasChanges) {
                  setShowConfirmation(true);
                } else {
                  onDismiss();
                }
              }}
              style={[styles.actionButton, styles.cancelButton]}
              contentStyle={{ paddingVertical: 6 }}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={() => updateMutation.mutate()}
              loading={updateMutation.isPending}
              disabled={!hasChanges}
              style={[styles.actionButton, styles.saveButton]}
              contentStyle={{ paddingVertical: 6 }}
            >
              Guardar
            </Button>
          </View>
        </View>
      </Modal>

      <ConfirmationModal
        visible={showConfirmation}
        title="¿Salir sin guardar?"
        message="Los cambios se perderán"
        confirmText="Salir"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={() => {
          setShowConfirmation(false);
          setHasChanges(false);
          onDismiss();
        }}
        onCancel={() => setShowConfirmation(false)}
        onDismiss={() => setShowConfirmation(false)}
      />
    </Portal>
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationCard.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Card, Text, Chip } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import {
  CustomizationType,
  type PizzaCustomization,
} from '../types/pizzaCustomization.types';

interface PizzaCustomizationCardProps {
  customization: PizzaCustomization;
  onPress: () => void;
}

export function PizzaCustomizationCard({
  customization,
  onPress,
}: PizzaCustomizationCardProps) {
  const theme = useAppTheme();

  const styles = StyleSheet.create({
    card: {
      marginBottom: theme.spacing.s,
    },
    content: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: -4,
    },
    info: {
      flex: 1,
    },
    name: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      marginBottom: 2,
    },
    ingredients: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      lineHeight: 16,
    },
    chip: {
      marginRight: theme.spacing.xs,
      height: 24,
    },
    rightSection: {
      alignItems: 'flex-end',
      marginLeft: theme.spacing.s,
    },
    toppingValue: {
      ...theme.fonts.titleLarge,
      color: theme.colors.primary,
      fontWeight: 'bold',
    },
    toppingLabel: {
      ...theme.fonts.labelSmall,
      color: theme.colors.onSurfaceVariant,
      marginTop: -2,
    },
  });

  const getTypeLabel = (type: CustomizationType) => {
    return type === CustomizationType.FLAVOR ? 'Sabor' : 'Ingrediente';
  };

  const getTypeIcon = (type: CustomizationType) => {
    return type === CustomizationType.FLAVOR ? 'pizza' : 'food-variant';
  };

  return (
    <Card style={styles.card} onPress={onPress} mode="contained">
      <Card.Content style={{ paddingVertical: 12, paddingHorizontal: 16 }}>
        <View style={styles.content}>
          <View style={styles.info}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginBottom: 4,
              }}
            >
              <Text style={styles.name}>{customization.name}</Text>
              <Chip
                icon={getTypeIcon(customization.type)}
                style={[styles.chip, { marginLeft: theme.spacing.s }]}
                compact
                textStyle={{ fontSize: 11 }}
              >
                {getTypeLabel(customization.type)}
              </Chip>
              {!customization.isActive && (
                <Chip
                  icon="eye-off"
                  style={[styles.chip, { marginLeft: theme.spacing.xs }]}
                  compact
                  mode="outlined"
                  textStyle={{ fontSize: 11 }}
                >
                  Inactivo
                </Chip>
              )}
            </View>

            {customization.ingredients && (
              <Text style={styles.ingredients} numberOfLines={1}>
                {customization.ingredients}
              </Text>
            )}
          </View>

          <View style={styles.rightSection}>
            <Text style={styles.toppingValue}>
              {customization.toppingValue}
            </Text>
            <Text style={styles.toppingLabel}>
              topping{customization.toppingValue !== 1 ? 's' : ''}
            </Text>
          </View>
        </View>
      </Card.Content>
    </Card>
  );
}

================
File: app/src/modules/pizzaCustomizations/screens/PizzaManagementScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { FAB, Text, Icon } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useAppTheme } from '@/app/styles/theme';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

// Importar las tabs
import {
  PizzaProductsTab,
  PizzaCustomizationsTab,
  PizzaCustomizationFormModal,
} from '../components';

export function PizzaManagementScreen() {
  const theme = useAppTheme();
  const [selectedTab, setSelectedTab] = useState('products');
  const [formModalVisible, setFormModalVisible] = useState(false);

  // Refrescar datos de pizzas cuando la pantalla recibe foco
  useRefreshModuleOnFocus('pizza-products');
  useRefreshModuleOnFocus('pizza-customizations');

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    tabsContainer: {
      flexDirection: 'row',
      height: 48,
    },
    tab: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: theme.spacing.m,
      gap: theme.spacing.xs,
    },
    tabActive: {
      borderBottomWidth: 2,
      borderBottomColor: theme.colors.primary,
    },
    tabText: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    tabTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    tabIcon: {
      marginRight: 4,
    },
    content: {
      flex: 1,
    },
    fab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 0,
      backgroundColor: theme.colors.primary,
    },
  });

  // Renderizar contenido según tab seleccionada
  const renderContent = () => {
    switch (selectedTab) {
      case 'products':
        return <PizzaProductsTab />;
      case 'customizations':
        return <PizzaCustomizationsTab />;
      default:
        return null;
    }
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.header}>
        <View style={styles.tabsContainer}>
          <Pressable
            style={[styles.tab, selectedTab === 'products' && styles.tabActive]}
            onPress={() => setSelectedTab('products')}
          >
            <Icon
              source="pizza"
              size={20}
              color={
                selectedTab === 'products'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                selectedTab === 'products' && styles.tabTextActive,
              ]}
            >
              Productos
            </Text>
          </Pressable>

          <Pressable
            style={[
              styles.tab,
              selectedTab === 'customizations' && styles.tabActive,
            ]}
            onPress={() => setSelectedTab('customizations')}
          >
            <Icon
              source="cheese"
              size={20}
              color={
                selectedTab === 'customizations'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                selectedTab === 'customizations' && styles.tabTextActive,
              ]}
            >
              Ingredientes
            </Text>
          </Pressable>
        </View>
      </View>

      <View style={styles.content}>{renderContent()}</View>

      {selectedTab === 'customizations' && (
        <FAB
          icon="plus"
          style={styles.fab}
          onPress={() => setFormModalVisible(true)}
          color={theme.colors.onPrimary}
        />
      )}

      <PizzaCustomizationFormModal
        visible={formModalVisible}
        onDismiss={() => setFormModalVisible(false)}
        onSuccess={() => {
          // La tab se actualizará automáticamente cuando reciba el foco
        }}
      />
    </SafeAreaView>
  );
}

================
File: app/src/modules/pizzaCustomizations/services/pizzaConfigurationsService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { PizzaConfiguration } from '../types/pizzaConfiguration.types';
import type {
  PizzaConfigurationFormInputs,
  UpdatePizzaConfigurationInputs,
} from '../schema/pizzaConfiguration.schema';

async function findByProductId(
  productId: string,
): Promise<PizzaConfiguration | null> {
  const response = await apiClient.get<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS + '/product/' + productId,
  );

  if (response.status === 404) {
    return null;
  }

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function create(
  data: PizzaConfigurationFormInputs,
): Promise<PizzaConfiguration> {
  const response = await apiClient.post<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS,
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function update(
  id: string,
  data: UpdatePizzaConfigurationInputs,
): Promise<PizzaConfiguration> {
  const response = await apiClient.patch<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.PIZZA_CONFIGURATIONS_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

export const pizzaConfigurationsService = {
  findByProductId,
  create,
  update,
  remove,
};

================
File: app/src/modules/pizzaCustomizations/services/pizzaCustomizationsService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { PaginatedResponse } from '@/app/types/api.types';
import type { PizzaCustomization } from '../types/pizzaCustomization.types';
import type {
  PizzaCustomizationFormInputs,
  FindAllPizzaCustomizationsQuery,
} from '../schema/pizzaCustomization.schema';

async function findAll(
  params?: FindAllPizzaCustomizationsQuery,
): Promise<PaginatedResponse<PizzaCustomization>> {
  const response = await apiClient.get<{
    items: PizzaCustomization[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.PIZZA_CUSTOMIZATIONS, params);

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
}

async function findOne(id: string): Promise<PizzaCustomization> {
  const response = await apiClient.get<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function create(
  data: PizzaCustomizationFormInputs,
): Promise<PizzaCustomization> {
  const response = await apiClient.post<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS,
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function update(
  id: string,
  data: Partial<PizzaCustomizationFormInputs>,
): Promise<PizzaCustomization> {
  const response = await apiClient.patch<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

async function updateSortOrder(
  updates: { id: string; sortOrder: number }[],
): Promise<void> {
  const response = await apiClient.patch(
    API_PATHS.PIZZA_CUSTOMIZATIONS_SORT_ORDER,
    { updates },
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

export const pizzaCustomizationsService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  updateSortOrder,
};

================
File: app/src/modules/preparationScreens/components/PreparationScreenDetailModalSimple.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Text,
  Button,
  Chip,
  ActivityIndicator,
  IconButton,
  Divider,
} from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PreparationScreen } from '../schema/preparationScreen.schema';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';

interface PreparationScreenDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  item: PreparationScreen | null;
  onEdit?: (item: PreparationScreen) => void;
  onDelete?: (id: string) => void;
  onManageProducts?: (item: PreparationScreen) => void;
  isDeleting?: boolean;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    descriptionContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      paddingBottom: theme.spacing.m,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    iconContainer: {
      width: 48,
      height: 48,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: theme.spacing.m,
    },
    description: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
      marginLeft: theme.spacing.m,
    },
    statusChip: {
      marginLeft: theme.spacing.s,
    },
    section: {
      padding: theme.spacing.m,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
      color: theme.colors.onSurface,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    infoIcon: {
      marginRight: theme.spacing.m,
    },
    infoText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    userChip: {
      marginRight: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    userChipsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      marginTop: theme.spacing.s,
    },
    productCard: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.s,
    },
    productInfo: {
      flex: 1,
    },
    productCount: {
      fontSize: 24,
      fontWeight: 'bold',
      color: theme.colors.primary,
    },
    productLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    emptyState: {
      alignItems: 'center',
      paddingVertical: theme.spacing.l,
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 14,
      marginTop: theme.spacing.s,
    },
    actionContainer: {
      // ResponsiveModal maneja padding y background
    },
    actionButtons: {
      flexDirection: 'row',
      gap: theme.spacing.m,
    },
    actionButton: {
      flex: 1,
      borderRadius: theme.roundness,
    },
    loadingContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl * 2,
    },
  });

const PreparationScreenDetailModal: React.FC<
  PreparationScreenDetailModalProps
> = ({
  visible,
  onDismiss,
  item,
  onEdit,
  onDelete,
  onManageProducts,
  isDeleting = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);

  const handleEdit = () => {
    if (onEdit && item) {
      onEdit(item);
    }
  };

  const handleDelete = () => {
    if (onDelete && item) {
      onDelete(item.id);
    }
  };

  // Get color based on screen name
  const getColor = () => {
    if (!item) return theme.colors.primary;
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return '#FF6B6B';
    if (name.includes('hamburguesa')) return '#4ECDC4';
    if (name.includes('bar')) return '#667EEA';
    return theme.colors.primary;
  };

  // Get icon based on screen name
  const getIcon = () => {
    if (!item) return 'monitor-dashboard';
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return 'pizza';
    if (name.includes('hamburguesa')) return 'hamburger';
    if (name.includes('bar')) return 'glass-cocktail';
    return 'monitor-dashboard';
  };

  const renderContent = () => {
    if (!item) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator
            animating={true}
            size="large"
            color={theme.colors.primary}
          />
        </View>
      );
    }

    const userCount = item.users?.length || 0;
    const productCount = item.products?.length || 0;
    const color = getColor();

    return (
      <>
        {/* Información adicional del header */}
        {item.description && (
          <View style={styles.descriptionContainer}>
            <View
              style={[styles.iconContainer, { backgroundColor: `${color}20` }]}
            >
              <Icon name={getIcon()} size={24} color={color} />
            </View>
            <Text style={styles.description} numberOfLines={2}>
              {item.description}
            </Text>
          </View>
        )}

        {/* Sección de usuarios */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            <Icon name="account-group" size={16} /> Usuarios Asignados (
            {userCount})
          </Text>

          {userCount > 0 ? (
            <View style={styles.userChipsContainer}>
              {item.users?.map((user: any) => (
                <Chip
                  key={user.id}
                  style={styles.userChip}
                  icon="account"
                  compact
                  mode="outlined"
                >
                  {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username}
                </Chip>
              ))}
            </View>
          ) : (
            <View style={styles.emptyState}>
              <Icon
                name="account-off-outline"
                size={32}
                color={theme.colors.onSurfaceVariant}
              />
              <Text style={styles.emptyText}>Sin usuarios asignados</Text>
            </View>
          )}
        </View>

        <Divider />

        {/* Sección de productos */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            <Icon name="food" size={16} /> Productos Asociados
          </Text>

          <View style={styles.productCard}>
            <View style={styles.productInfo}>
              <Text style={styles.productCount}>{productCount}</Text>
              <Text style={styles.productLabel}>
                {productCount === 1 ? 'Producto' : 'Productos'}
              </Text>
            </View>

            {onManageProducts && (
              <Button
                mode="contained-tonal"
                onPress={() => onManageProducts(item)}
                icon="link-variant"
                compact
              >
                Gestionar
              </Button>
            )}
          </View>
        </View>
      </>
    );
  };

  const headerActions = item && (
    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
      <Chip
        mode="flat"
        compact
        style={styles.statusChip}
        textStyle={{ fontSize: 12 }}
        selected={item.isActive}
      >
        {item.isActive ? 'Activa' : 'Inactiva'}
      </Chip>
    </View>
  );

  const footerActions = item && (
    <View style={styles.actionContainer}>
      <View style={styles.actionButtons}>
        {onEdit && (
          <Button
            icon="pencil"
            mode="contained"
            onPress={() => onEdit(item)}
            disabled={isDeleting}
            style={styles.actionButton}
            buttonColor={theme.colors.primary}
          >
            Editar
          </Button>
        )}
        {onDelete && (
          <Button
            icon="delete"
            mode="contained-tonal"
            onPress={() => onDelete(item.id)}
            loading={isDeleting}
            disabled={isDeleting}
            style={styles.actionButton}
            buttonColor={theme.colors.errorContainer}
            textColor={theme.colors.error}
          >
            Eliminar
          </Button>
        )}
      </View>
    </View>
  );

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title={item?.name}
      headerActions={headerActions}
      hideCloseButton={isDeleting}
      dismissable={!isDeleting}
      maxHeightTablet="90%"
      scrollable={true}
      footer={footerActions}
    >
      {renderContent()}
    </ResponsiveModal>
  );
};

export default PreparationScreenDetailModal;

================
File: app/src/modules/preparationScreens/components/PreparationScreenListItem.tsx
================
import React from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Chip, IconButton, Surface } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PreparationScreen } from '../schema/preparationScreen.schema';

interface PreparationScreenListItemProps {
  item: PreparationScreen;
  onPress: (item: PreparationScreen) => void;
  onManageProducts?: (item: PreparationScreen) => void;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      elevation: 2,
      backgroundColor: theme.colors.surface,
    },
    pressable: {
      borderRadius: theme.roundness * 2,
    },
    colorBar: {
      position: 'absolute',
      left: 0,
      right: 0,
      top: 0,
      height: 6,
    },
    content: {
      padding: theme.spacing.m,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.s,
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    iconContainer: {
      width: 48,
      height: 48,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: theme.spacing.m,
    },
    title: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    statusChip: {
      paddingHorizontal: theme.spacing.s,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.m,
      lineHeight: 20,
    },
    footer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingTop: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    statsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.l,
    },
    stat: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    statIcon: {
      opacity: 0.7,
    },
    statText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    actionButton: {
      margin: -8,
    },
  });

const PreparationScreenListItem: React.FC<PreparationScreenListItemProps> = ({
  item,
  onPress,
  onManageProducts,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);

  const userCount = item.users?.length || 0;
  const productCount = item.products?.length || 0;
  const isActive = item.isActive ?? true;

  // Get gradient colors based on screen name
  const getGradientColors = () => {
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) {
      return ['#FF6B6B', '#FF8E53'];
    } else if (name.includes('hamburguesa')) {
      return ['#4ECDC4', '#44A08D'];
    } else if (name.includes('bar')) {
      return ['#667EEA', '#764BA2'];
    }
    return [theme.colors.primary, theme.colors.secondary];
  };

  // Get icon based on screen name
  const getIcon = () => {
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return 'pizza';
    if (name.includes('hamburguesa')) return 'hamburger';
    if (name.includes('bar')) return 'glass-cocktail';
    return 'monitor-dashboard';
  };

  const gradientColors = getGradientColors();

  return (
    <Surface style={styles.container}>
      <Pressable
        style={styles.pressable}
        onPress={() => onPress(item)}
        android_ripple={{ borderless: false }}
      >
        <View
          style={[styles.colorBar, { backgroundColor: gradientColors[0] }]}
        />

        <View style={styles.content}>
          <View style={styles.header}>
            <View style={styles.titleContainer}>
              <View
                style={[
                  styles.iconContainer,
                  { backgroundColor: `${gradientColors[0]}20` },
                ]}
              >
                <Icon name={getIcon()} size={24} color={gradientColors[0]} />
              </View>
              <Text style={styles.title} numberOfLines={1}>
                {item.name}
              </Text>
            </View>

            <Chip
              mode="flat"
              compact
              style={[
                styles.statusChip,
                {
                  backgroundColor: isActive
                    ? theme.colors.successContainer
                    : theme.colors.surfaceVariant,
                },
              ]}
              textStyle={{
                color: isActive
                  ? theme.colors.onSuccessContainer
                  : theme.colors.onSurfaceVariant,
                fontSize: 12,
              }}
            >
              {isActive ? 'Activa' : 'Inactiva'}
            </Chip>
          </View>

          {item.description && (
            <Text style={styles.description} numberOfLines={2}>
              {item.description}
            </Text>
          )}

          <View style={styles.footer}>
            <View style={styles.statsContainer}>
              <View style={styles.stat}>
                <Icon
                  name="account-group"
                  size={16}
                  color={theme.colors.onSurfaceVariant}
                  style={styles.statIcon}
                />
                <Text style={styles.statText}>
                  {userCount} {userCount === 1 ? 'usuario' : 'usuarios'}
                </Text>
              </View>

              <View style={styles.stat}>
                <Icon
                  name="food"
                  size={16}
                  color={theme.colors.onSurfaceVariant}
                  style={styles.statIcon}
                />
                <Text style={styles.statText}>
                  {productCount} {productCount === 1 ? 'producto' : 'productos'}
                </Text>
              </View>
            </View>

            {onManageProducts && (
              <IconButton
                icon="link-variant"
                size={20}
                onPress={() => onManageProducts(item)}
                style={styles.actionButton}
              />
            )}
          </View>
        </View>
      </Pressable>
    </Surface>
  );
};

export default PreparationScreenListItem;

================
File: app/src/modules/printers/components/PrinterDiscoveryModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet } from 'react-native'; // FlatList eliminado
import { FlashList, ListRenderItemInfo } from '@shopify/flash-list'; // Importar FlashList y tipo
import {
  Modal,
  Portal,
  Text,
  ActivityIndicator,
  List,
  Icon, // Añadir Icon a la importación
  Divider,
  IconButton,
  Appbar, // Importar Appbar
} from 'react-native-paper';
import {
  useDiscoverPrinters,
  useTestPrintDiscoveredPrinter,
} from '../hooks/usePrintersQueries';
import { DiscoveredPrinter } from '../types/printer.types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';

interface PrinterDiscoveryModalProps {
  visible: boolean;
  onDismiss: () => void;
  onPrinterSelect: (printer: DiscoveredPrinter) => void; // Callback cuando se selecciona una impresora
}

const PrinterDiscoveryModal: React.FC<PrinterDiscoveryModalProps> = ({
  visible,
  onDismiss,
  onPrinterSelect,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const discoverMutation = useDiscoverPrinters();
  const testPrintMutation = useTestPrintDiscoveredPrinter();

  useEffect(() => {
    if (visible) {
      discoverMutation.mutate(undefined, {
        // undefined para usar la duración por defecto
        onError: (error) => {
          showSnackbar({
            message: `Error descubriendo impresoras: ${getApiErrorMessage(error)}`,
            type: 'error',
          });
        },
      });
    }
  }, [visible, discoverMutation, showSnackbar]); // Ejecutar solo cuando 'visible' cambia

  const handleRescan = () => {
    discoverMutation.mutate(undefined); // Volver a escanear con duración por defecto
  };

  const handleTestPrint = (printer: DiscoveredPrinter) => {
    testPrintMutation.mutate(printer);
  };

  const renderPrinterItem = (
    { item }: ListRenderItemInfo<DiscoveredPrinter>, // Añadir tipo
  ) => (
    <List.Item
      title={item.name || item.ip} // Mostrar nombre o IP si no hay nombre
      description={`IP: ${item.ip}:${item.port}${item.mac ? ` | MAC: ${item.mac}` : ''}${item.model ? ` (${item.model})` : ''}`}
      left={(props) => <List.Icon {...props} icon="printer" />}
      right={(props) => (
        <View style={styles.itemActions}>
          <IconButton
            {...props}
            icon="printer-check"
            size={24}
            onPress={() => handleTestPrint(item)}
            disabled={testPrintMutation.isPending}
            loading={
              testPrintMutation.isPending &&
              testPrintMutation.variables?.ip === item.ip
            }
            tooltip="Imprimir prueba"
          />
          <IconButton
            {...props}
            icon="plus"
            size={24}
            onPress={() => onPrinterSelect(item)}
            disabled={testPrintMutation.isPending}
            tooltip="Agregar impresora"
          />
        </View>
      )}
      style={styles.listItem}
      titleStyle={styles.itemTitle}
      descriptionStyle={styles.itemDescription}
    />
  );

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
        dismissable={
          !discoverMutation.isPending && !testPrintMutation.isPending
        } // No permitir cerrar mientras busca o imprime
      >
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction
            onPress={onDismiss}
            disabled={discoverMutation.isPending || testPrintMutation.isPending}
          />
          <Appbar.Content
            title="Descubrir Impresoras"
            titleStyle={styles.appBarTitle}
          />
          {/* Botón de Refrescar/Re-escanear */}
          <Appbar.Action
            icon="refresh"
            size={32} // <-- Aumentar tamaño del icono
            onPress={handleRescan}
            disabled={discoverMutation.isPending || testPrintMutation.isPending}
            color={theme.colors.primary} // Color distintivo
          />
        </Appbar.Header>

        <View style={styles.contentContainer}>
          {discoverMutation.isPending && (
            <View style={styles.centeredView}>
              <ActivityIndicator animating={true} size="large" />
              <Text style={styles.statusText}>
                Buscando impresoras en la red...
              </Text>
              <Text style={styles.statusSubText}>
                (Esto puede tardar unos segundos)
              </Text>
            </View>
          )}

          {discoverMutation.isError && !discoverMutation.isPending && (
            <View style={styles.centeredView}>
              <Icon
                source="alert-circle-outline"
                color={theme.colors.error}
                size={48}
              />
              <Text style={styles.errorText}>
                Error al buscar impresoras:{' '}
                {getApiErrorMessage(discoverMutation.error)}
              </Text>
              {/* Botón eliminado, se usa el icono en Appbar */}
            </View>
          )}

          {discoverMutation.isSuccess && !discoverMutation.isPending && (
            <>
              {discoverMutation.data.length === 0 ? (
                <View style={styles.centeredView}>
                  <Icon
                    source="printer-off"
                    color={theme.colors.onSurfaceVariant}
                    size={48}
                  />
                  <Text style={styles.statusText}>
                    No se encontraron impresoras.
                  </Text>
                  <Text style={styles.statusSubText}>
                    Asegúrate de que estén encendidas y en la misma red.
                  </Text>
                  {/* Botón eliminado, se usa el icono en Appbar */}
                </View>
              ) : (
                <>
                  {/* Texto estilizado */}
                  <Text style={styles.foundText}>Impresoras encontradas:</Text>
                  <FlashList
                    data={discoverMutation.data}
                    renderItem={renderPrinterItem}
                    keyExtractor={(item: DiscoveredPrinter) =>
                      `${item.ip}:${item.port}`
                    } // Añadir tipo y clave única
                    estimatedItemSize={70} // Añadir tamaño estimado
                    ItemSeparatorComponent={() => (
                      <Divider style={styles.divider} />
                    )}
                  />
                  {/* Botón eliminado, se usa el icono en Appbar */}
                </>
              )}
            </>
          )}
        </View>

        {/* Footer eliminado, se usa Appbar.BackAction */}
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,

      width: '100%',
      height: '100%',
      margin: 0,

      justifyContent: 'flex-start', // Alinear contenido arriba
    },
    appBar: {
      backgroundColor: theme.colors.elevation.level2,
    },
    appBarTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center', // Centrar título
    },
    contentContainer: {
      flex: 1, // Ocupar espacio restante
      padding: theme.spacing.m,
    },
    centeredView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    statusText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      textAlign: 'center',
      color: theme.colors.onSurface,
    },
    statusSubText: {
      marginTop: theme.spacing.xs,
      fontSize: 14,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      marginTop: theme.spacing.m,
      color: theme.colors.error,
      textAlign: 'center',
      marginBottom: theme.spacing.m,
    },
    foundText: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.m,
      color: theme.colors.primary, // Color primario para destacar
    },
    list: {
      flex: 1, // Permitir que la lista ocupe espacio
      marginBottom: theme.spacing.m, // Espacio antes del botón de re-escanear
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    itemTitle: {
      fontWeight: '500',
    },
    itemDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    itemActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    divider: {
      height: 0, // Ocultar divider si no se desea
    },
    button: {
      marginTop: theme.spacing.m,
      minWidth: 150, // Ancho mínimo para botones
    },
    // Estilo footer eliminado
  });

export default PrinterDiscoveryModal;

================
File: app/src/modules/printers/components/PrinterListItem.tsx
================
import React from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Surface, Icon, Chip } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { ThermalPrinter } from '../types/printer.types';

interface PrinterListItemProps {
  printer: ThermalPrinter;
  onPress: () => void;
  renderActions?: React.ReactNode;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      elevation: 2,
    },
    pressable: {
      padding: theme.spacing.m,
    },
    content: {
      gap: theme.spacing.s,
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    titleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      flex: 1,
      marginRight: 60, // Espacio reservado para el botón de ping (52px + margen)
    },
    printerIcon: {
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: theme.roundness,
      padding: theme.spacing.xs,
    },
    titleContainer: {
      flex: 1,
    },
    title: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    connectionInfo: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    statusBadge: {
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
    },
    activeBadge: {
      borderColor: theme.colors.primary,
    },
    inactiveBadge: {
      borderColor: theme.colors.error,
    },
    detailsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.xs,
      marginTop: theme.spacing.xs,
      marginRight: 60, // Espacio reservado para el botón de ping
    },
    detailChip: {
      height: 24,
      backgroundColor: theme.colors.surfaceVariant,
    },
    detailChipLabel: {
      fontSize: 11,
      marginHorizontal: 8,
      marginVertical: 0,
    },
    featuresRow: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      marginTop: theme.spacing.xs,
      marginRight: 60, // Espacio reservado para el botón de ping
    },
    featureChip: {
      height: 28,
      backgroundColor: theme.colors.secondaryContainer,
    },
    featureChipLabel: {
      fontSize: 12,
      marginHorizontal: 10,
      marginVertical: 0,
      color: theme.colors.onSecondaryContainer,
    },
    actionsContainer: {
      position: 'absolute',
      right: theme.spacing.m,
      top: theme.spacing.m,
    },
  });

const PrinterListItem: React.FC<PrinterListItemProps> = ({
  printer,
  onPress,
  renderActions,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);

  const getConnectionDisplay = () => {
    if (printer.connectionType === 'NETWORK' && printer.ipAddress) {
      return `${printer.ipAddress}:${printer.port || 9100}`;
    }
    return printer.connectionType;
  };

  const hasAutoPrintFeatures =
    printer.autoDeliveryPrint || printer.autoPickupPrint;

  return (
    <Surface style={styles.container}>
      <Pressable
        style={styles.pressable}
        onPress={onPress}
        android_ripple={{ color: theme.colors.primary + '20' }}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <View style={styles.titleRow}>
              <View style={styles.printerIcon}>
                <Icon
                  source="printer"
                  size={20}
                  color={theme.colors.onPrimaryContainer}
                />
              </View>
              <View style={styles.titleContainer}>
                <Text style={styles.title}>{printer.name}</Text>
                <Text style={styles.connectionInfo}>
                  {getConnectionDisplay()}
                </Text>
              </View>
            </View>
            {renderActions && (
              <View style={styles.actionsContainer}>{renderActions}</View>
            )}
          </View>

          <View style={styles.detailsContainer}>
            <Chip
              mode="flat"
              style={[
                styles.statusBadge,
                printer.isActive ? styles.activeBadge : styles.inactiveBadge,
              ]}
              textStyle={[
                styles.detailChipLabel,
                {
                  color: printer.isActive
                    ? theme.colors.primary
                    : theme.colors.error,
                },
              ]}
            >
              {printer.isActive ? 'Activa' : 'Inactiva'}
            </Chip>

            {printer.isDefaultPrinter && (
              <Chip
                mode="flat"
                style={styles.detailChip}
                textStyle={styles.detailChipLabel}
                icon="star"
              >
                Predeterminada
              </Chip>
            )}

            <Chip
              mode="flat"
              style={styles.detailChip}
              textStyle={styles.detailChipLabel}
              icon="file-document-outline"
            >
              {printer.paperWidth}mm
            </Chip>
          </View>

          {hasAutoPrintFeatures && (
            <View style={styles.featuresRow}>
              {printer.autoDeliveryPrint && (
                <Chip
                  mode="flat"
                  style={styles.featureChip}
                  textStyle={styles.featureChipLabel}
                  icon="home-export-outline"
                >
                  Auto Domicilio
                </Chip>
              )}
              {printer.autoPickupPrint && (
                <Chip
                  mode="flat"
                  style={styles.featureChip}
                  textStyle={styles.featureChipLabel}
                  icon="bag-checked"
                >
                  Auto Para Llevar
                </Chip>
              )}
            </View>
          )}
        </View>
      </Pressable>
    </Surface>
  );
};

export default PrinterListItem;

================
File: app/src/modules/shared/components/OrderHistoryModal.tsx
================
import React, { useCallback, useMemo, useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  Platform,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Divider,
  Chip,
  Button,
  Avatar,
  Surface,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

interface HistoryItem {
  id: string | number;
  orderId: string;
  orderItemId?: string;
  operation: 'INSERT' | 'UPDATE' | 'DELETE' | 'BATCH';
  changedBy: string;
  changedAt: string;
  diff?: Record<string, any> | null;
  snapshot?: Record<string, any>;
  productId?: string;
  preparationStatus?: string;
  changedByUser?: {
    id?: string;
    firstName: string;
    lastName: string;
  };
  user?: {
    firstName: string;
    lastName: string;
  };
  itemDescription?: string;
  formattedChanges?: Record<string, any>;
  batchOperations?: any[];
  type: 'order' | 'item';
}

interface OrderHistoryModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId: string | null;
  orderNumber?: number;
}

// Helper para obtener el icono de la operación
const getOperationIcon = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    return 'receipt';
  }
  switch (operation) {
    case 'INSERT':
      return 'plus-circle';
    case 'UPDATE':
      return 'pencil';
    case 'DELETE':
      return 'delete';
    case 'BATCH':
      return 'folder-multiple';
    default:
      return 'information';
  }
};

// Helper para obtener el label de la operación
const getOperationLabel = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    const orderOperationMap: Record<string, string> = {
      INSERT: 'Orden creada',
      UPDATE: 'Orden modificada',
      DELETE: 'Orden eliminada',
    };
    return orderOperationMap[operation] || operation;
  }

  const operationMap: Record<string, string> = {
    INSERT: 'Item agregado',
    UPDATE: 'Item modificado',
    DELETE: 'Item eliminado',
    BATCH: 'Cambios múltiples',
  };
  return operationMap[operation] || operation;
};

// Helper para obtener el color del status
const getStatusColor = (status: string, theme: any) => {
  switch (status) {
    case 'PENDING':
      return theme.colors.error;
    case 'IN_PROGRESS':
    case 'IN_PREPARATION':
      return theme.colors.warning;
    case 'READY':
    case 'DELIVERED':
    case 'COMPLETED':
      return theme.colors.success;
    case 'CANCELLED':
      return theme.colors.onSurfaceVariant;
    default:
      return theme.colors.onSurface;
  }
};

// Helper para formatear nombres de campos
const formatFieldName = (field: string): string => {
  const fieldMap: Record<string, string> = {
    orderStatus: 'Estado de la orden',
    orderType: 'Tipo de orden',
    tableId: 'Mesa',
    table: 'Mesa',
    notes: 'Notas',
    deliveryInfo: 'Información de entrega',
    scheduledAt: 'Programado para',
    customerId: 'Cliente',
    isFromWhatsApp: 'Orden de WhatsApp',
    // Campos dentro de deliveryInfo
    recipientName: 'Destinatario',
    recipientPhone: 'Teléfono',
    fullAddress: 'Dirección completa',
    deliveryInstructions: 'Instrucciones de entrega',
    street: 'Calle',
    number: 'Número',
    neighborhood: 'Colonia',
    city: 'Ciudad',
    state: 'Estado',
    zipCode: 'Código postal',
  };
  return fieldMap[field] || field;
};

// Helper para formatear valores
const formatValue = (field: string, value: any): string => {
  if (value === null || value === undefined) return 'Sin valor';

  if (field === 'orderStatus' || field === 'preparationStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Progreso',
      IN_PREPARATION: 'En Preparación',
      READY: 'Lista',
      DELIVERED: 'Entregada',
      COMPLETED: 'Completada',
      CANCELLED: 'Cancelada',
    };
    return statusMap[value] || value;
  }

  if (field === 'orderType') {
    const typeMap: Record<string, string> = {
      DINE_IN: 'Para Comer Aquí',
      TAKE_AWAY: 'Para Llevar',
      DELIVERY: 'Domicilio',
    };
    return typeMap[value] || value;
  }

  if (field === 'table' || field === 'tableId') {
    if (typeof value === 'object' && value !== null) {
      return value.name || 'Sin mesa';
    }
    return value || 'Sin mesa';
  }

  // Para datos de entrega
  if (field === 'recipientName') {
    return value || 'Sin nombre';
  }

  if (field === 'recipientPhone') {
    return value || 'Sin teléfono';
  }

  if (field === 'fullAddress') {
    return value || 'Sin dirección';
  }

  if (field === 'isFromWhatsApp') {
    return value ? 'Sí' : 'No';
  }

  if (field === 'customerId') {
    return value || 'Sin cliente registrado';
  }

  if (field === 'scheduledAt') {
    return value
      ? format(new Date(value), 'dd/MM/yyyy HH:mm', { locale: es })
      : 'No programado';
  }

  return String(value);
};

// Componente para cada item del historial
const HistoryItemComponent: React.FC<{
  item: HistoryItem;
  theme: ReturnType<typeof useAppTheme>;
}> = ({ item, theme }) => {
  const [expanded, setExpanded] = useState(false);
  const styles = useMemo(() => createStyles(theme), [theme]);

  const renderChangeDetail = (change: any, fieldName?: string) => {
    if (
      change &&
      typeof change === 'object' &&
      change.anterior !== undefined &&
      change.nuevo !== undefined
    ) {
      // Para descripción del item, mostrar en formato vertical si es muy largo
      if (
        (fieldName === 'Descripción del Item' || fieldName === 'Descripción') &&
        (String(change.anterior).length > 30 ||
          String(change.nuevo).length > 30)
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {String(change.anterior)}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Después:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {String(change.nuevo)}
              </Text>
            </View>
          </View>
        );
      }

      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {String(change.anterior)}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {String(change.nuevo)}
            </Text>
          </View>
        </View>
      );
    } else if (Array.isArray(change) && change.length === 2) {
      // Para el formato de array [antes, después] - usado en cambios de orden
      const oldVal = formatValue(fieldName || '', change[0]);
      const newVal = formatValue(fieldName || '', change[1]);

      // Para campos largos o especiales, usar formato vertical
      if (
        fieldName &&
        ['notes', 'deliveryInfo', 'customerName', 'deliveryAddress'].includes(
          fieldName,
        )
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {oldVal}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Después:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {newVal}
              </Text>
            </View>
          </View>
        );
      }

      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {oldVal}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {newVal}
            </Text>
          </View>
        </View>
      );
    }
    return null;
  };

  return (
    <Surface
      style={[
        styles.historyItem,
        { backgroundColor: theme.colors.surfaceVariant },
      ]}
      elevation={1}
    >
      <TouchableOpacity
        onPress={() => setExpanded(!expanded)}
        activeOpacity={0.7}
      >
        <View style={styles.historyHeader}>
          <View style={{ flex: 1, marginRight: 12 }}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginBottom: 4,
              }}
            >
              <Avatar.Icon
                size={24}
                icon={getOperationIcon(item.operation, item.type)}
                style={{
                  backgroundColor:
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary,
                  marginRight: 6,
                }}
              />
              <Text
                variant="bodySmall"
                style={{ fontWeight: '600', flex: 1 }}
                numberOfLines={1}
              >
                {item.changedByUser
                  ? `${item.changedByUser.firstName} ${item.changedByUser.lastName}`
                  : item.user
                    ? `${item.user.firstName} ${item.user.lastName}`
                    : 'Sistema'}
              </Text>
              <View
                style={{
                  width: 32,
                  height: 32,
                  borderRadius: 16,
                  backgroundColor: theme.colors.surfaceVariant,
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Icon
                  name={expanded ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>

            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                flexWrap: 'wrap',
                gap: 4,
              }}
            >
              <View
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor:
                    (item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary) + '15',
                  paddingHorizontal: 5,
                  paddingVertical: 1,
                  borderRadius: 10,
                }}
              >
                <Icon
                  name={getOperationIcon(item.operation, item.type)}
                  size={10}
                  color={
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary
                  }
                  style={{ marginRight: 3 }}
                />
                <Text
                  style={{
                    color:
                      item.type === 'order'
                        ? theme.colors.primary
                        : theme.colors.secondary,
                    fontSize: 9,
                    fontWeight: '600',
                  }}
                >
                  {getOperationLabel(item.operation, item.type)}
                </Text>
              </View>

              {item.preparationStatus && (
                <Chip
                  mode="flat"
                  textStyle={{ fontSize: 9 }}
                  style={{
                    backgroundColor:
                      getStatusColor(item.preparationStatus, theme) + '20',
                    transform: [{ scale: 0.8 }],
                    height: 20,
                  }}
                  compact
                >
                  {formatValue('preparationStatus', item.preparationStatus)}
                </Chip>
              )}

              <Text variant="labelSmall" style={{ opacity: 0.6, fontSize: 10 }}>
                {format(new Date(item.changedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          </View>
        </View>
      </TouchableOpacity>

      {expanded && (
        <View style={styles.expandedContent}>
          <Divider style={{ marginBottom: 8 }} />

          {/* Contenido para órdenes */}
          {item.type === 'order' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <>
                  {/* Si hay diff consolidado para INSERT, usarlo */}
                  {item.diff && (item.diff.order || item.diff.items) ? (
                    <>
                      {item.diff.summary && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.primary,
                            fontWeight: '600',
                            marginBottom: 8,
                            fontStyle: 'italic',
                          }}
                        >
                          {item.diff.summary}
                        </Text>
                      )}

                      {/* Información de la orden */}
                      {item.diff.order && (
                        <View
                          style={{
                            backgroundColor: theme.colors.surface,
                            padding: 8,
                            borderRadius: 6,
                            marginBottom: 8,
                          }}
                        >
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.primary,
                              fontWeight: '600',
                              marginBottom: 6,
                            }}
                          >
                            Detalles de la orden:
                          </Text>

                          {item.diff.order.fields?.orderType && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.diff.order.fields.orderType[1],
                              )}
                            </Text>
                          )}
                          {item.diff.order.fields?.tableId && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Mesa:</Text>{' '}
                              {item.snapshot?.table?.name ||
                                `Mesa ${item.diff.order.fields.tableId[1]}`}
                            </Text>
                          )}
                          {item.diff.order.fields?.notes && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Notas:</Text>{' '}
                              {item.diff.order.fields.notes[1]}
                            </Text>
                          )}

                          {/* Información de entrega */}
                          {item.diff.order.deliveryInfo && (
                            <>
                              {item.diff.order.deliveryInfo.recipientName && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Cliente:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientName[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.recipientPhone && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Teléfono:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientPhone[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.fullAddress && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Dirección:
                                  </Text>{' '}
                                  {item.diff.order.deliveryInfo.fullAddress[1]}
                                </Text>
                              )}
                            </>
                          )}
                        </View>
                      )}

                      {/* Productos agregados */}
                      {item.diff.items?.added &&
                        item.diff.items.added.length > 0 && (
                          <>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                marginTop: 8,
                              }}
                            >
                              Productos incluidos en la orden:
                            </Text>
                            {item.diff.items.added.map(
                              (addedItem: any, idx: number) => (
                                <View
                                  key={`added-${idx}`}
                                  style={{
                                    marginBottom: 8,
                                    paddingLeft: 8,
                                    borderLeftWidth: 2,
                                    borderLeftColor:
                                      theme.colors.primary + '50',
                                    backgroundColor: theme.colors.surface,
                                    padding: 8,
                                    marginLeft: 4,
                                    borderRadius: 4,
                                  }}
                                >
                                  <Text
                                    variant="bodySmall"
                                    style={{ fontWeight: '600' }}
                                  >
                                    {addedItem.productName}
                                    {addedItem.variantName
                                      ? ` - ${addedItem.variantName}`
                                      : ''}
                                  </Text>
                                  {addedItem.modifiers?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Modificadores:{' '}
                                      {addedItem.modifiers.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.customizations?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Personalizaciones:{' '}
                                      {addedItem.customizations.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.notes && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        fontStyle: 'italic',
                                      }}
                                    >
                                      Notas: {addedItem.notes}
                                    </Text>
                                  )}
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      marginTop: 2,
                                      fontWeight: '600',
                                      color: theme.colors.primary,
                                    }}
                                  >
                                    Precio: ${addedItem.price}
                                  </Text>
                                </View>
                              ),
                            )}
                          </>
                        )}
                    </>
                  ) : (
                    // Fallback al formato anterior si no hay diff
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Nueva orden creada
                      </Text>
                      {item.snapshot && (
                        <View
                          style={{
                            backgroundColor: theme.colors.surface,
                            padding: 8,
                            borderRadius: 6,
                          }}
                        >
                          {item.snapshot.orderType && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.snapshot.orderType,
                              )}
                            </Text>
                          )}
                          {item.snapshot.tableId && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Mesa:</Text>{' '}
                              {item.snapshot.table?.name ||
                                'Mesa ' + item.snapshot.tableId}
                            </Text>
                          )}
                          {item.snapshot.notes && (
                            <Text variant="bodySmall">
                              <Text style={{ fontWeight: '600' }}>Notas:</Text>{' '}
                              {item.snapshot.notes}
                            </Text>
                          )}
                        </View>
                      )}
                    </>
                  )}
                </>
              )}

              {item.operation === 'UPDATE' &&
                item.diff &&
                (() => {
                  const relevantChanges = Object.entries(item.diff)
                    .filter(([field]) => {
                      // Solo mostrar campos que rastreamos en el backend
                      const allowedFields = [
                        'orderStatus',
                        'orderType',
                        'notes',
                        'tableId',
                        'customerId',
                        'scheduledAt',
                        'deliveryInfo',
                        'isFromWhatsApp',
                      ];
                      return allowedFields.includes(field);
                    })
                    .flatMap(([field, change]) => {
                      // Si es deliveryInfo y es un objeto, expandir sus propiedades
                      if (
                        field === 'deliveryInfo' &&
                        change &&
                        typeof change === 'object' &&
                        !Array.isArray(change)
                      ) {
                        return Object.entries(change).map(
                          ([subField, subChange]) => ({
                            field: subField,
                            change: subChange,
                          }),
                        );
                      }
                      return [{ field, change }];
                    });

                  if (relevantChanges.length === 0) {
                    return (
                      <Text
                        variant="bodySmall"
                        style={{ color: theme.colors.onSurfaceVariant }}
                      >
                        Actualización de productos de la orden
                      </Text>
                    );
                  }

                  return (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en la orden:
                      </Text>
                      {relevantChanges.map(({ field, change }) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ))}
                    </>
                  );
                })()}

              {item.operation === 'DELETE' && (
                <Text variant="bodySmall" style={{ color: theme.colors.error }}>
                  La orden fue eliminada
                </Text>
              )}
            </View>
          )}

          {/* Contenido consolidado nuevo formato */}
          {item.diff &&
            (item.diff.order || item.diff.items || item.diff.summary) && (
              <View style={styles.changesContainer}>
                {/* Resumen de cambios */}
                {item.diff.summary && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                      fontStyle: 'italic',
                    }}
                  >
                    {item.diff.summary}
                  </Text>
                )}

                {/* Cambios en la orden */}
                {item.diff.order?.fields && (
                  <>
                    <Text
                      variant="bodySmall"
                      style={{
                        color: theme.colors.primary,
                        fontWeight: '600',
                        marginBottom: 8,
                      }}
                    >
                      Cambios en la orden:
                    </Text>
                    {Object.entries(item.diff.order.fields).map(
                      ([field, change]) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ),
                    )}
                  </>
                )}

                {/* Cambios en información de entrega */}
                {item.diff.order?.deliveryInfo && (
                  <>
                    <Text
                      variant="bodySmall"
                      style={{
                        color: theme.colors.primary,
                        fontWeight: '600',
                        marginBottom: 8,
                      }}
                    >
                      Cambios en información de entrega:
                    </Text>
                    {Object.entries(item.diff.order.deliveryInfo).map(
                      ([field, change]) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ),
                    )}
                  </>
                )}

                {/* Usar formattedChanges si está disponible para mostrar cambios simplificados */}
                {item.formattedChanges &&
                  item.formattedChanges['Cambios en productos'] && (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en productos:
                      </Text>

                      {/* Productos modificados - diseño mejorado */}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos modificados'
                      ] && (
                        <View style={{ marginTop: 8 }}>
                          {item.formattedChanges['Cambios en productos'][
                            'Productos modificados'
                          ].map((modItem: any, idx: number) => (
                            <View
                              key={`mod-${idx}`}
                              style={{
                                marginBottom: 12,
                                backgroundColor: theme.colors.surfaceVariant,
                                borderRadius: theme.roundness * 2,
                                overflow: 'hidden',
                              }}
                            >
                              {/* Header del cambio */}
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  backgroundColor: theme.colors.warning + '20',
                                  paddingHorizontal: 12,
                                  paddingVertical: 8,
                                  borderBottomWidth: 1,
                                  borderBottomColor:
                                    theme.colors.warning + '30',
                                }}
                              >
                                <Icon
                                  name="pencil"
                                  size={16}
                                  color={theme.colors.warning}
                                  style={{ marginRight: 8 }}
                                />
                                <Text
                                  variant="labelMedium"
                                  style={{
                                    color: theme.colors.warning,
                                    fontWeight: '600',
                                    flex: 1,
                                  }}
                                >
                                  Producto modificado
                                </Text>
                              </View>

                              {/* Contenido del cambio */}
                              <View style={{ padding: 12 }}>
                                <View
                                  style={{
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    backgroundColor: theme.colors.surface,
                                    borderRadius: theme.roundness,
                                    padding: 10,
                                  }}
                                >
                                  {/* Antes */}
                                  <View
                                    style={{
                                      flex: 1,
                                      paddingRight: 8,
                                    }}
                                  >
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        color: theme.colors.error,
                                        marginBottom: 4,
                                        opacity: 0.8,
                                      }}
                                    >
                                      Antes
                                    </Text>
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.onSurfaceVariant,
                                        textDecorationLine: 'line-through',
                                        opacity: 0.7,
                                      }}
                                    >
                                      {modItem.antes}
                                    </Text>
                                  </View>

                                  {/* Flecha */}
                                  <View
                                    style={{
                                      paddingHorizontal: 8,
                                    }}
                                  >
                                    <Icon
                                      name="arrow-right-thick"
                                      size={24}
                                      color={theme.colors.primary}
                                    />
                                  </View>

                                  {/* Después */}
                                  <View
                                    style={{
                                      flex: 1,
                                      paddingLeft: 8,
                                    }}
                                  >
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        color: theme.colors.primary,
                                        marginBottom: 4,
                                      }}
                                    >
                                      Después
                                    </Text>
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.primary,
                                        fontWeight: '600',
                                      }}
                                    >
                                      {modItem.después}
                                    </Text>
                                  </View>
                                </View>
                              </View>
                            </View>
                          ))}
                        </View>
                      )}

                      {/* Productos agregados - formato simplificado */}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos agregados'
                      ] && (
                        <>
                          {item.formattedChanges['Cambios en productos'][
                            'Productos agregados'
                          ].map((product: string, idx: number) => (
                            <View
                              key={`added-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.success + '50',
                              }}
                            >
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'flex-start',
                                }}
                              >
                                <Icon
                                  name="plus-circle"
                                  size={14}
                                  color={theme.colors.success}
                                  style={{ marginRight: 6, marginTop: 2 }}
                                />
                                <View style={{ flex: 1 }}>
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.success,
                                      fontWeight: '600',
                                    }}
                                  >
                                    Producto agregado
                                  </Text>
                                  <Text
                                    variant="bodySmall"
                                    style={{ marginTop: 2 }}
                                  >
                                    {product}
                                  </Text>
                                </View>
                              </View>
                            </View>
                          ))}
                        </>
                      )}

                      {/* Productos eliminados - formato simplificado */}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos eliminados'
                      ] && (
                        <>
                          {item.formattedChanges['Cambios en productos'][
                            'Productos eliminados'
                          ].map((product: string, idx: number) => (
                            <View
                              key={`removed-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.error + '50',
                              }}
                            >
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'flex-start',
                                }}
                              >
                                <Icon
                                  name="delete"
                                  size={14}
                                  color={theme.colors.error}
                                  style={{ marginRight: 6, marginTop: 2 }}
                                />
                                <View style={{ flex: 1 }}>
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.error,
                                      fontWeight: '600',
                                    }}
                                  >
                                    Producto eliminado
                                  </Text>
                                  <Text
                                    variant="bodySmall"
                                    style={{ marginTop: 2 }}
                                  >
                                    {product}
                                  </Text>
                                </View>
                              </View>
                            </View>
                          ))}
                        </>
                      )}
                    </>
                  )}

                {/* Cambios en items - formato JSON crudo (fallback si no hay formattedChanges) */}
                {item.diff.items &&
                  !item.formattedChanges?.['Cambios en productos'] && (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en productos:
                      </Text>

                      {/* Items agregados */}
                      {item.diff.items.added?.map(
                        (addedItem: any, idx: number) => (
                          <View
                            key={`added-${idx}`}
                            style={{
                              marginBottom: 8,
                              paddingLeft: 8,
                              borderLeftWidth: 2,
                              borderLeftColor: theme.colors.success + '50',
                            }}
                          >
                            <View
                              style={{
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                              }}
                            >
                              <Icon
                                name="plus-circle"
                                size={14}
                                color={theme.colors.success}
                                style={{ marginRight: 6, marginTop: 2 }}
                              />
                              <View style={{ flex: 1 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.success,
                                    fontWeight: '600',
                                  }}
                                >
                                  Producto agregado
                                </Text>
                                <Text
                                  variant="bodySmall"
                                  style={{ marginTop: 2 }}
                                >
                                  {addedItem.productName}
                                  {addedItem.variantName
                                    ? ` - ${addedItem.variantName}`
                                    : ''}
                                </Text>
                                {addedItem.modifiers?.length > 0 && (
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      marginTop: 2,
                                      color: theme.colors.onSurfaceVariant,
                                    }}
                                  >
                                    Modificadores:{' '}
                                    {addedItem.modifiers.join(', ')}
                                  </Text>
                                )}
                                {addedItem.price && (
                                  <Text
                                    variant="labelSmall"
                                    style={{ marginTop: 2, fontWeight: '600' }}
                                  >
                                    Precio: ${addedItem.price}
                                  </Text>
                                )}
                              </View>
                            </View>
                          </View>
                        ),
                      )}

                      {/* Items modificados - Solo mostrar antes y después */}
                      {item.diff.items.modified?.map(
                        (modItem: any, idx: number) => (
                          <View
                            key={`mod-${idx}`}
                            style={{
                              marginBottom: 8,
                              paddingLeft: 8,
                              borderLeftWidth: 2,
                              borderLeftColor: theme.colors.warning + '50',
                            }}
                          >
                            <View
                              style={{
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                              }}
                            >
                              <Icon
                                name="pencil"
                                size={14}
                                color={theme.colors.warning}
                                style={{ marginRight: 6, marginTop: 2 }}
                              />
                              <View style={{ flex: 1 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.warning,
                                    fontWeight: '600',
                                  }}
                                >
                                  Producto modificado
                                </Text>
                                <View
                                  style={{
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    flexWrap: 'wrap',
                                    marginTop: 4,
                                  }}
                                >
                                  <View
                                    style={{
                                      backgroundColor:
                                        theme.colors.errorContainer,
                                      paddingHorizontal: 8,
                                      paddingVertical: 4,
                                      borderRadius: 4,
                                      marginRight: 6,
                                      marginTop: 4,
                                    }}
                                  >
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.onErrorContainer,
                                      }}
                                    >
                                      {modItem.before.productName}
                                      {modItem.before.variantName
                                        ? ` - ${modItem.before.variantName}`
                                        : ''}
                                    </Text>
                                  </View>
                                  <Icon
                                    name="arrow-right"
                                    size={16}
                                    color={theme.colors.onSurfaceVariant}
                                    style={{
                                      marginHorizontal: 4,
                                      marginTop: 4,
                                    }}
                                  />
                                  <View
                                    style={{
                                      backgroundColor:
                                        theme.colors.primaryContainer,
                                      paddingHorizontal: 8,
                                      paddingVertical: 4,
                                      borderRadius: 4,
                                      marginTop: 4,
                                    }}
                                  >
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.onPrimaryContainer,
                                      }}
                                    >
                                      {modItem.after.productName}
                                      {modItem.after.variantName
                                        ? ` - ${modItem.after.variantName}`
                                        : ''}
                                    </Text>
                                  </View>
                                </View>
                              </View>
                            </View>
                          </View>
                        ),
                      )}

                      {/* Items eliminados */}
                      {item.diff.items.removed?.map(
                        (removedItem: any, idx: number) => (
                          <View
                            key={`removed-${idx}`}
                            style={{
                              marginBottom: 8,
                              paddingLeft: 8,
                              borderLeftWidth: 2,
                              borderLeftColor: theme.colors.error + '50',
                            }}
                          >
                            <View
                              style={{
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                              }}
                            >
                              <Icon
                                name="delete"
                                size={14}
                                color={theme.colors.error}
                                style={{ marginRight: 6, marginTop: 2 }}
                              />
                              <View style={{ flex: 1 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.error,
                                    fontWeight: '600',
                                  }}
                                >
                                  Producto eliminado
                                </Text>
                                <Text
                                  variant="bodySmall"
                                  style={{ marginTop: 2 }}
                                >
                                  {removedItem.productName}
                                  {removedItem.variantName
                                    ? ` - ${removedItem.variantName}`
                                    : ''}
                                </Text>
                                {removedItem.price && (
                                  <Text
                                    variant="labelSmall"
                                    style={{ marginTop: 2, fontWeight: '600' }}
                                  >
                                    Precio: ${removedItem.price}
                                  </Text>
                                )}
                              </View>
                            </View>
                          </View>
                        ),
                      )}
                    </>
                  )}
              </View>
            )}

          {/* Contenido para items individuales (legacy) */}
          {item.type === 'item' && item.operation !== 'BATCH' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <Text
                  variant="bodySmall"
                  style={{
                    color: theme.colors.primary,
                    fontWeight: '600',
                    marginBottom: 8,
                  }}
                >
                  Nuevo item agregado:
                </Text>
              )}
              {item.operation === 'UPDATE' && item.formattedChanges && (
                <>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                    }}
                  >
                    Item modificado:
                  </Text>
                  {Object.entries(item.formattedChanges)
                    .filter(([fieldName]) => {
                      // Solo mostrar campos relevantes (no precios)
                      const allowedFields = [
                        'Descripción del Item',
                        'Estado',
                        'Notas de preparación',
                        'Producto',
                        'Variante',
                        'Modificadores',
                      ];
                      return allowedFields.includes(fieldName);
                    })
                    .map(([fieldName, change]) => (
                      <View key={fieldName} style={{ marginBottom: 8 }}>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.onSurfaceVariant,
                            fontWeight: '600',
                            marginBottom: 4,
                          }}
                        >
                          {fieldName}:
                        </Text>
                        {renderChangeDetail(change, fieldName)}
                      </View>
                    ))}
                </>
              )}
              {item.operation === 'DELETE' && (
                <Text
                  variant="bodySmall"
                  style={{ color: theme.colors.error, marginBottom: 8 }}
                >
                  Item eliminado:
                </Text>
              )}
              {/* Mostrar la descripción del item para INSERT y DELETE */}
              {(item.operation === 'INSERT' || item.operation === 'DELETE') &&
                item.itemDescription && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.onSurface,
                      backgroundColor: theme.colors.surface,
                      padding: 8,
                      borderRadius: 6,
                    }}
                  >
                    {item.itemDescription}
                  </Text>
                )}
            </View>
          )}

          {/* Contenido para batch de items */}
          {item.operation === 'BATCH' && item.batchOperations && (
            <View style={styles.changesContainer}>
              <Text
                variant="bodySmall"
                style={{
                  color: theme.colors.primary,
                  fontWeight: '600',
                  marginBottom: 8,
                }}
              >
                Cambios realizados en una sola edición:
              </Text>
              {item.batchOperations.map((op: any, idx: number) => (
                <View
                  key={idx}
                  style={{
                    marginBottom:
                      idx < item.batchOperations!.length - 1 ? 12 : 0,
                    paddingLeft: 8,
                    borderLeftWidth: 2,
                    borderLeftColor: theme.colors.primary + '30',
                    marginLeft: 4,
                  }}
                >
                  <View
                    style={{
                      flexDirection: 'row',
                      alignItems: 'flex-start',
                      marginBottom: 4,
                    }}
                  >
                    <Icon
                      name={getOperationIcon(op.operation)}
                      size={14}
                      color={theme.colors.primary}
                      style={{ marginRight: 6, marginTop: 2 }}
                    />
                    <View style={{ flex: 1 }}>
                      <Text
                        variant="labelSmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '500',
                          marginBottom: 4,
                        }}
                      >
                        {getOperationLabel(op.operation)}
                      </Text>

                      {/* Mostrar descripción del item */}
                      {(op.itemDescription || op.snapshot?.itemDescription) && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.onSurface,
                            backgroundColor: theme.colors.surface,
                            padding: 6,
                            borderRadius: 4,
                          }}
                        >
                          {op.itemDescription || op.snapshot?.itemDescription}
                        </Text>
                      )}

                      {/* Para UPDATE, mostrar el cambio */}
                      {op.operation === 'UPDATE' && op.formattedChanges && (
                        <View style={{ marginTop: 4 }}>
                          {Object.entries(op.formattedChanges)
                            .filter(([fieldName]) => {
                              // Solo mostrar campos relevantes (no precios)
                              const allowedFields = [
                                'Descripción del Item',
                                'Descripción',
                                'Estado',
                                'Notas de preparación',
                                'Producto',
                                'Variante',
                                'Modificadores',
                                'Estado de preparación',
                              ];
                              return allowedFields.includes(fieldName);
                            })
                            .map(([fieldName, change]) => (
                              <View key={fieldName} style={{ marginBottom: 4 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.onSurfaceVariant,
                                    fontWeight: '500',
                                    fontSize: 11,
                                  }}
                                >
                                  {fieldName}:
                                </Text>
                                {renderChangeDetail(change, fieldName)}
                              </View>
                            ))}
                        </View>
                      )}
                    </View>
                  </View>
                </View>
              ))}
            </View>
          )}
        </View>
      )}
    </Surface>
  );
};

export const OrderHistoryModal: React.FC<OrderHistoryModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderNumber,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  // Query combinado para obtener ambos historiales
  const {
    data: historyData,
    isError,
    refetch,
    isLoading,
  } = useQuery({
    queryKey: ['combinedHistory', orderId],
    queryFn: async () => {
      if (!orderId) throw new Error('No order ID');

      // Obtener historial consolidado de la orden
      const orderHistoryResponse = await apiClient.get(
        API_PATHS.ORDERS_HISTORY.replace(':orderId', orderId),
        {
          page: 1,
          limit: 100,
        },
      );

      const orderHistory =
        orderHistoryResponse.ok && orderHistoryResponse.data?.data
          ? orderHistoryResponse.data.data.map((item: any) => ({
              ...item,
              type: 'order' as const,
            }))
          : [];

      // Ya no necesitamos consultar el historial de items por separado
      // Todo está consolidado en el historial de la orden

      // No es necesario agrupar ya que cada registro ya contiene cambios consolidados
      return orderHistory;
    },
    enabled: visible && !!orderId,
    staleTime: 30000,
  });

  // Refrescar cuando se abre el modal
  useEffect(() => {
    if (visible && orderId) {
      refetch();
    }
  }, [visible, orderId, refetch]);

  const renderHistoryItem = useCallback(
    ({ item }: { item: HistoryItem }) => {
      return <HistoryItemComponent item={item} theme={theme} />;
    },
    [theme],
  );

  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Icon
        name="history"
        size={48}
        color={theme.colors.onSurfaceVariant}
        style={{ opacity: 0.5 }}
      />
      <Text
        variant="bodyLarge"
        style={{
          color: theme.colors.onSurfaceVariant,
          marginTop: theme.spacing.m,
        }}
      >
        No hay historial disponible
      </Text>
    </View>
  );

  return (
    <Modal
      visible={visible}
      onDismiss={onDismiss}
      contentContainerStyle={styles.modalContainer}
      dismissable={true}
      dismissableBackButton={false}
    >
      <View style={styles.header}>
        <View style={{ flex: 1 }}>
          <Text
            variant="titleMedium"
            style={{
              color: theme.colors.onSurface,
              fontSize: 18,
              fontWeight: '600',
            }}
            numberOfLines={1}
          >
            Historial de Orden #{orderNumber || ''}
          </Text>
          <Text
            variant="bodySmall"
            style={{
              color: theme.colors.onSurfaceVariant,
              marginTop: 2,
            }}
          >
            {historyData?.length || 0} cambios registrados
          </Text>
        </View>
        <TouchableOpacity
          onPress={onDismiss}
          style={{
            width: 44,
            height: 44,
            borderRadius: 22,
            backgroundColor: theme.colors.errorContainer,
            alignItems: 'center',
            justifyContent: 'center',
            elevation: 2,
            shadowColor: '#000',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 0.1,
            shadowRadius: 4,
          }}
          activeOpacity={0.8}
        >
          <Icon name="close" size={24} color={theme.colors.onErrorContainer} />
        </TouchableOpacity>
      </View>

      <Divider />

      <View style={{ flex: 1 }}>
        {isError ? (
          <View style={styles.emptyContainer}>
            <Icon
              name="alert-circle"
              size={48}
              color={theme.colors.error}
              style={{ opacity: 0.7 }}
            />
            <Text
              variant="bodyLarge"
              style={{
                color: theme.colors.error,
                marginTop: theme.spacing.m,
                textAlign: 'center',
              }}
            >
              Error al cargar el historial
            </Text>
            <Button
              onPress={() => refetch()}
              mode="text"
              style={{ marginTop: 16 }}
            >
              Reintentar
            </Button>
          </View>
        ) : isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando historial...</Text>
          </View>
        ) : (
          <FlatList
            data={historyData || []}
            renderItem={renderHistoryItem}
            keyExtractor={(item) => item.id.toString()}
            contentContainerStyle={styles.listContent}
            ListEmptyComponent={renderEmpty}
            showsVerticalScrollIndicator={false}
          />
        )}
      </View>
    </Modal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) => {
  return StyleSheet.create({
    modalContainer: {
      backgroundColor: theme.colors.surface,
      margin: 20,
      marginVertical: Platform.OS === 'ios' ? 60 : 40,
      borderRadius: theme.roundness * 3,
      height: '80%',
      maxHeight: 600,
      width: '90%',
      maxWidth: 500,
      alignSelf: 'center',
      elevation: 24,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 12 },
      shadowOpacity: 0.58,
      shadowRadius: 16.0,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.l,
      paddingVertical: theme.spacing.m,
      backgroundColor: theme.colors.elevation.level2,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      minHeight: 64,
    },
    scrollView: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2, // Más espacio al final para evitar superposición
    },
    loadingContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    historyItem: {
      padding: theme.spacing.s,
      marginBottom: theme.spacing.s,
      marginHorizontal: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 2,
    },
    historyHeader: {
      // Cambio a estructura vertical para evitar encimamiento
    },
    userInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
      minWidth: 0,
    },
    userDetails: {
      marginLeft: theme.spacing.s,
      flex: 1,
      minWidth: 0,
    },
    expandedContent: {
      marginTop: theme.spacing.m,
      backgroundColor: theme.colors.background,
      marginHorizontal: -theme.spacing.s,
      padding: theme.spacing.m,
      borderBottomLeftRadius: theme.roundness,
      borderBottomRightRadius: theme.roundness,
    },
    changesContainer: {
      paddingTop: theme.spacing.xs,
    },
    changeDetail: {
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
      marginBottom: 4,
    },
    emptyContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
  });
};

export default OrderHistoryModal;

================
File: app/src/modules/shared/components/OrderSummaryCard.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Chip, Card, Icon } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { getPaymentStatus } from '@/app/utils/orderFormatters';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { OrderTypeEnum } from '@/modules/orders/types/orders.types';
import { formatOrderTypeShort } from '@/app/utils/orderFormatters';

interface OrderSummaryCardProps {
  item: any; // Union type for ReceiptList | Order
  onPress: () => void;
  renderActions?: (item: any) => React.ReactNode;
  getStatusColor?: (status: string) => string;
  getStatusLabel?: (status: string) => string;
}

const OrderSummaryCard: React.FC<OrderSummaryCardProps> = ({
  item,
  onPress,
  renderActions,
  getStatusColor,
  getStatusLabel,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  // Construir el título según el tipo de orden
  let orderTitle = `#${item.shiftOrderNumber || item.orderNumber} • ${formatOrderTypeShort(item.orderType)}`;

  if (item.orderType === OrderTypeEnum.DINE_IN && item.table) {
    // Para mesas temporales, mostrar solo el nombre sin prefijo "Mesa"
    const tableDisplay = item.table.isTemporary
      ? item.table.name
      : `Mesa ${item.table.name || item.table.number || 'N/A'}`;
    orderTitle += ` • ${item.table.area?.name || item.area?.name || 'Sin área'} • ${tableDisplay}`;
  } else if (item.orderType === OrderTypeEnum.TAKE_AWAY) {
    if (item.deliveryInfo?.recipientName || item.deliveryInfo?.customerName) {
      orderTitle += ` • ${item.deliveryInfo.recipientName || item.deliveryInfo.customerName}`;
    }
    if (item.deliveryInfo?.recipientPhone || item.deliveryInfo?.customerPhone) {
      orderTitle += ` • ${item.deliveryInfo.recipientPhone || item.deliveryInfo.customerPhone}`;
    }
  } else if (item.orderType === OrderTypeEnum.DELIVERY) {
    if (item.deliveryInfo?.fullAddress || item.deliveryInfo?.address) {
      orderTitle += ` • ${item.deliveryInfo.fullAddress || item.deliveryInfo.address}`;
    }
    if (item.deliveryInfo?.recipientPhone || item.deliveryInfo?.customerPhone) {
      orderTitle += ` • ${item.deliveryInfo.recipientPhone || item.deliveryInfo.customerPhone}`;
    }
  }

  const totalAmount =
    typeof item.total === 'string' ? parseFloat(item.total) : item.total;
  const totalPaid =
    item.paymentsSummary?.totalPaid ||
    item.payments?.reduce((sum: number, p: any) => sum + (p.amount || 0), 0) ||
    0;
  const pendingAmount = totalAmount - totalPaid;

  // Determinar colores y íconos de estado de pago
  const paymentStatus = getPaymentStatus(item as any);
  const paymentColor =
    paymentStatus === 'paid'
      ? '#10B981'
      : paymentStatus === 'partial'
        ? '#F59E0B'
        : '#EF4444';
  const paymentIcon =
    paymentStatus === 'paid' ? '✓' : paymentStatus === 'partial' ? '½' : '•';

  // Colores de estado por defecto si no se proporcionan
  const defaultGetStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return '#4CAF50';
      case 'CANCELLED':
        return '#F44336';
      case 'IN_PROGRESS':
        return '#FF9800';
      default:
        return theme.colors.surfaceVariant;
    }
  };

  const defaultGetStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      case 'IN_PROGRESS':
        return 'En proceso';
      default:
        return status;
    }
  };

  const statusColor = getStatusColor
    ? getStatusColor(item.orderStatus)
    : defaultGetStatusColor(item.orderStatus);
  const statusLabel = getStatusLabel
    ? getStatusLabel(item.orderStatus)
    : defaultGetStatusLabel(item.orderStatus);

  return (
    <TouchableOpacity activeOpacity={0.95} onPress={onPress}>
      <Card
        style={[
          styles.orderCard,
          {
            backgroundColor: theme.colors.surface,
          },
        ]}
        mode="elevated"
      >
        <Card.Content style={styles.cardContent}>
          <View style={styles.mainContainer}>
            <View style={styles.leftContainer}>
              <Text
                style={[styles.orderNumber, { color: theme.colors.onSurface }]}
              >
                {orderTitle}
                <Text
                  style={[
                    styles.orderPrice,
                    {
                      color: pendingAmount > 0 ? theme.colors.error : '#10B981',
                    },
                  ]}
                >
                  {' • '}
                  {pendingAmount > 0
                    ? `Por pagar: $${pendingAmount.toFixed(2)}`
                    : `Pagado: $${totalAmount.toFixed(2)}`}
                </Text>
                {item.notes && (
                  <Text
                    style={[
                      styles.notesInline,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                    numberOfLines={1}
                  >
                    {' • '}
                    {item.notes}
                  </Text>
                )}
              </Text>
              <View style={styles.timeAndPaymentRow}>
                <Text
                  style={[styles.orderTime, { color: theme.colors.primary }]}
                >
                  {format(new Date(item.createdAt), 'p', { locale: es })}
                </Text>

                {/* Badge de estado de pago */}
                <View
                  style={[
                    styles.miniPaymentBadge,
                    { backgroundColor: paymentColor },
                  ]}
                >
                  <Text style={styles.miniPaymentText}>{paymentIcon}</Text>
                </View>

                {/* Badge de WhatsApp */}
                {item.isFromWhatsApp && (
                  <View
                    style={[
                      styles.inlinePreparationBadge,
                      {
                        backgroundColor: '#25D366',
                        borderColor: '#25D366',
                      },
                    ]}
                  >
                    <Icon source="whatsapp" size={12} color="#FFFFFF" />
                  </View>
                )}

                {/* Badges de pantallas de preparación */}
                {item.preparationScreenStatuses &&
                  item.preparationScreenStatuses.length > 0 && (
                    <>
                      {item.preparationScreenStatuses.map(
                        (screen: any, index: number) => {
                          const backgroundColor =
                            screen.status === 'READY'
                              ? '#4CAF50'
                              : screen.status === 'IN_PROGRESS'
                                ? '#FFA000'
                                : theme.colors.surfaceVariant;

                          const textColor =
                            screen.status === 'READY' ||
                            screen.status === 'IN_PROGRESS'
                              ? '#FFFFFF'
                              : theme.colors.onSurfaceVariant;

                          return (
                            <View
                              key={`${item.id}-screen-${index}`}
                              style={[
                                styles.inlinePreparationBadge,
                                {
                                  backgroundColor,
                                  borderColor:
                                    backgroundColor ===
                                    theme.colors.surfaceVariant
                                      ? theme.colors.outline
                                      : backgroundColor,
                                },
                              ]}
                            >
                              <Text
                                style={[
                                  styles.inlinePreparationText,
                                  { color: textColor },
                                ]}
                              >
                                {screen.status === 'READY'
                                  ? '✓ '
                                  : screen.status === 'IN_PROGRESS'
                                    ? '⏳'
                                    : ''}
                                🍳 {screen.name}
                              </Text>
                            </View>
                          );
                        },
                      )}
                    </>
                  )}
              </View>
            </View>

            <View style={styles.rightContainer}>
              {item.createdBy && (
                <Text style={styles.createdByText} numberOfLines={1}>
                  {item.createdBy.firstName && item.createdBy.lastName
                    ? `${item.createdBy.firstName} ${item.createdBy.lastName}`
                    : item.createdBy.username}
                </Text>
              )}
              <Chip
                mode="flat"
                compact
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: statusColor,
                  },
                ]}
                textStyle={styles.statusChipText}
              >
                {statusLabel}
              </Chip>

              {/* Contenedor de acciones personalizables */}
              {renderActions && (
                <View style={styles.actionsContainer}>
                  {renderActions(item)}
                </View>
              )}
            </View>
          </View>
        </Card.Content>
      </Card>
    </TouchableOpacity>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      marginRight: 12,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minHeight: 60,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: '600',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 14,
      fontWeight: '500',
    },
    notesInline: {
      fontSize: 13,
      fontStyle: 'italic',
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
      flexWrap: 'wrap',
    },
    orderTime: {
      fontSize: 13,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: 16,
      height: 16,
      borderRadius: 8,
      justifyContent: 'center',
      alignItems: 'center',
    },
    miniPaymentText: {
      color: '#FFFFFF',
      fontSize: 10,
      fontWeight: 'bold',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 1,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    createdByText: {
      fontSize: 12,
      color: '#666',
      marginBottom: 4,
      maxWidth: 120,
    },
    statusChip: {
      marginBottom: 8,
    },
    statusChipText: {
      fontSize: 11,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    actionsContainer: {
      alignItems: 'center',
    },
  });

export default OrderSummaryCard;

================
File: app/src/modules/sync/navigation/SyncStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { SyncStatusScreen } from '../screens/SyncStatusScreen';

export type SyncStackParamList = {
  SyncStatus: undefined;
};

const Stack = createNativeStackNavigator<SyncStackParamList>();

export const SyncStackNavigator: React.FC = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="SyncStatus"
        component={SyncStatusScreen}
        options={{ title: 'Estado de Sincronización' }}
      />
    </Stack.Navigator>
  );
};

================
File: app/metro.config.js
================
const { getDefaultConfig } = require('expo/metro-config');

const config = getDefaultConfig(__dirname);

// Configuración para asegurar que las peticiones HTTP funcionen en producción
config.resolver.resolverMainFields = ['react-native', 'browser', 'main'];

// Configuración adicional para web
config.resolver.sourceExts = [...config.resolver.sourceExts, 'mjs'];

module.exports = config;

================
File: app/src/app/components/common/AnimatedLabelSelector.tsx
================
import React, { useRef, useEffect } from 'react';
import {
  View,
  TouchableOpacity,
  Animated,
  StyleSheet,
  Text,
  StyleProp,
  ViewStyle,
  TextStyle,
  ActivityIndicator,
} from 'react-native';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Icon, IconButton } from 'react-native-paper';

interface AnimatedLabelSelectorProps {
  label: string;
  value: string | null | undefined;
  onPress: () => void;
  onClear?: () => void;
  containerStyle?: StyleProp<ViewStyle>;
  valueStyle?: StyleProp<TextStyle>;
  labelStyle?: StyleProp<TextStyle>;
  activeLabelColor?: string;
  inactiveLabelColor?: string;
  borderColor?: string;
  activeBorderColor?: string;
  disabled?: boolean;
  isLoading?: boolean;
  error?: boolean;
  errorColor?: string;
}

const AnimatedLabelSelector: React.FC<AnimatedLabelSelectorProps> = ({
  label,
  value,
  onPress,
  onClear,
  containerStyle,
  valueStyle,
  labelStyle,
  activeLabelColor,
  inactiveLabelColor,
  borderColor: defaultBorderColor,
  activeBorderColor: focusedBorderColor,
  disabled = false,
  isLoading = false,
  error = false,
  errorColor: customErrorColor,
  ...rest
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();

  const isActive = value != null && value !== '';
  const animation = useRef(new Animated.Value(isActive ? 1 : 0)).current;

  const finalActiveLabelColor = activeLabelColor || theme.colors.primary;
  const finalInactiveLabelColor =
    inactiveLabelColor || theme.colors.onSurfaceVariant;
  const finalBorderColor = defaultBorderColor || theme.colors.outline;
  const finalActiveBorderColor = focusedBorderColor || theme.colors.primary;
  const finalErrorColor = customErrorColor || theme.colors.error;

  const currentBorderColor = disabled
    ? theme.colors.surfaceVariant
    : error
      ? finalErrorColor
      : isActive
        ? finalActiveBorderColor
        : finalBorderColor;

  useEffect(() => {
    Animated.timing(animation, {
      toValue: isActive ? 1 : 0,
      duration: 200,
      useNativeDriver: false,
    }).start();
  }, [isActive, animation]);

  const labelTranslateY = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -26],
  });

  const labelScale = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 0.8],
  });

  const labelColor = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [finalInactiveLabelColor, finalActiveLabelColor],
  });

  const styles = React.useMemo(
    () =>
      createStyles(theme, responsive, {
        disabled,
        finalInactiveLabelColor,
      }),
    [theme, responsive, disabled, finalInactiveLabelColor],
  );

  const animatedLabelStyle = {
    transform: [{ translateY: labelTranslateY }, { scale: labelScale }],
    color: labelColor,
    backgroundColor: animation.interpolate({
      inputRange: [0, 1],
      outputRange: ['transparent', theme.colors.background],
    }),
  };

  // Estilos estáticos que no deben ser animados
  const staticLabelStyle = {
    paddingHorizontal: isActive ? 4 : 0,
    zIndex: isActive ? 2 : 0,
  };

  return (
    <View style={styles.outerContainer}>
      <TouchableOpacity
        onPress={onPress}
        disabled={disabled || isLoading}
        style={[
          styles.container,
          { borderColor: currentBorderColor },
          containerStyle,
        ]}
        activeOpacity={0.7}
        {...rest}
      >
        <Animated.Text
          style={[
            styles.label,
            staticLabelStyle,
            labelStyle,
            animatedLabelStyle,
          ]}
          numberOfLines={1}
        >
          {label}
        </Animated.Text>
        <View style={styles.valueContainer}>
          <Text style={[styles.valueText, valueStyle]} numberOfLines={1}>
            {!isLoading ? value || ' ' : ' '}
          </Text>
          <View style={styles.iconsContainer}>
            {isLoading ? (
              <ActivityIndicator
                size="small"
                color={theme.colors.primary}
                style={styles.loader}
              />
            ) : (
              <Icon
                source="chevron-down"
                size={20}
                color={
                  disabled
                    ? theme.colors.onSurfaceDisabled
                    : theme.colors.onSurfaceVariant
                }
              />
            )}
          </View>
        </View>

        {disabled && <View style={styles.disabledOverlay} />}
      </TouchableOpacity>

      {isActive && !disabled && !isLoading && onClear && (
        <View style={styles.clearButtonContainer}>
          <IconButton
            icon="close-circle"
            size={24}
            onPress={onClear}
            iconColor={theme.colors.onSurfaceVariant}
            style={styles.clearButton}
            rippleColor="rgba(0, 0, 0, .1)"
          />
        </View>
      )}
    </View>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
  props: {
    disabled: boolean;
    finalInactiveLabelColor: string;
  },
) =>
  StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.isTablet ? 16 : 18,
      paddingBottom: responsive.isTablet ? 4 : 6,
      position: 'relative',
      backgroundColor: theme.colors.background,
      minHeight: responsive.isTablet ? 52 : 58,
      justifyContent: 'center',
      flex: 1,
    },
    outerContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    label: {
      position: 'absolute',
      left: responsive.spacing(theme.spacing.m),
      top: responsive.isTablet ? 16 : 18,
      fontSize: responsive.fontSize(16),
      color: props.finalInactiveLabelColor,
      zIndex: 1,
    },
    valueContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      minHeight: responsive.isTablet ? 20 : 24,
    },
    valueText: {
      fontSize: responsive.fontSize(16),
      color: props.disabled
        ? theme.colors.onSurfaceDisabled
        : theme.colors.onSurface,
      flex: 1,
      marginRight: responsive.spacing(theme.spacing.xs),
    },
    loader: {},
    iconsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    clearButtonContainer: {
      marginLeft: responsive.spacing(theme.spacing.s),
      height: responsive.isTablet ? 52 : 58,
      justifyContent: 'center',
    },
    clearButton: {
      margin: 0,
    },
    icon: {},
    disabledOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: theme.dark
        ? 'rgba(0, 0, 0, 0.2)'
        : 'rgba(0, 0, 0, 0.05)',
      zIndex: 3,
      borderRadius: theme.roundness,
    },
  });

export default AnimatedLabelSelector;

================
File: app/src/app/components/common/AutoImage.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import {
  StyleSheet,
  Platform,
  View,
  ActivityIndicator,
  StyleProp,
  ViewStyle,
  DimensionValue,
} from 'react-native';
import { Image, ImageProps as ExpoImageProps } from 'expo-image';
import { Icon } from 'react-native-paper';
import { getCachedImageUri } from '../../lib/imageCache';
import { getImageUrl } from '../../lib/imageUtils';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';

export interface AutoImageProps
  extends Omit<ExpoImageProps, 'source' | 'style'> {
  source: string | null | undefined;
  maxWidth?: number;
  maxHeight?: number;
  useCache?: boolean;
  placeholder?: ExpoImageProps['placeholder'];
  placeholderIcon?: string;
  contentFit?: ExpoImageProps['contentFit'];
  transition?: ExpoImageProps['transition'];
  style?: StyleProp<ViewStyle>;
}

function useAutoImageSize(
  maxWidth?: number,
  maxHeight?: number,
): { width?: number | string; height?: number | string } {
  return {
    width: maxWidth ?? '100%',
    height: maxHeight ?? '100%',
  };
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      overflow: 'hidden',
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.surfaceVariant,
    },
    loadingIndicator: {
      position: 'absolute',
    },
    image: {
      width: '100%',
      height: '100%',
    },
  });

export const AutoImage: React.FC<AutoImageProps> = ({
  source: originalSourceProp,
  maxWidth,
  maxHeight,
  useCache = true,
  style,
  placeholder,
  placeholderIcon = 'image-off-outline',
  contentFit = 'cover',
  transition = 300,
  ...restExpoImageProps
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const [processedUri, setProcessedUri] = useState<string | null>(null);
  const [isLoadingUri, setIsLoadingUri] = useState(true);

  const { width, height } = useAutoImageSize(maxWidth, maxHeight); // Eliminado argumento uri no usado

  useEffect(() => {
    let isMounted = true;
    setIsLoadingUri(true);
    setProcessedUri(null);

    if (!originalSourceProp) {
      if (isMounted) {
        setIsLoadingUri(false);
      }
      return;
    }

    const processSource = async () => {
      const fullRemoteUrl = await getImageUrl(originalSourceProp);

      if (!fullRemoteUrl) {
        if (isMounted) setIsLoadingUri(false);
        return;
      }

      // Si NO se usa caché, o es web, o es una URI local, usar la URL construida directamente
      if (
        !useCache ||
        Platform.OS === 'web' ||
        fullRemoteUrl.startsWith('file://')
      ) {
        if (isMounted) {
          setProcessedUri(fullRemoteUrl);
          setIsLoadingUri(false);
        }
        return;
      }

      try {
        const cachedUri = await getCachedImageUri(fullRemoteUrl);
        if (isMounted) {
          setProcessedUri(cachedUri ?? fullRemoteUrl);
          setIsLoadingUri(false);
        }
      } catch (error) {
        if (isMounted) {
          setProcessedUri(fullRemoteUrl);
          setIsLoadingUri(false);
        }
      }
    };

    processSource();

    return () => {
      isMounted = false;
    };
  }, [originalSourceProp, useCache]);

  const styles = useMemo(() => createStyles(theme), [theme]);

  const containerStyle: StyleProp<ViewStyle> = useMemo(
    () => [
      styles.container,
      { width: width as DimensionValue, height: height as DimensionValue },
      style,
    ],
    [styles, width, height, style],
  );

  const iconSize = useMemo(() => {
    if (typeof width === 'number' && typeof height === 'number') {
      return Math.min(width, height) * 0.4;
    }
    return responsive.dimensions.iconSize.large;
  }, [width, height, responsive.dimensions.iconSize.large]);

  return (
    <View style={containerStyle}>
      {processedUri ? (
        <>
          <Image
            source={{ uri: processedUri }}
            style={styles.image}
            placeholder={placeholder}
            contentFit={contentFit}
            transition={transition}
            cachePolicy="memory-disk"
            {...restExpoImageProps}
          />
          {isLoadingUri && originalSourceProp && (
            <ActivityIndicator
              style={styles.loadingIndicator}
              animating={true}
              color={theme.colors.primary}
              size="small"
            />
          )}
        </>
      ) : (
        !isLoadingUri && (
          <Icon
            source={placeholderIcon}
            size={iconSize}
            color={theme.colors.onSurfaceVariant}
          />
        )
      )}
    </View>
  );
};

export default AutoImage;

================
File: app/src/app/components/common/EmptyState.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Button, Icon } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';

interface EmptyStateProps {
  icon?: string;
  title: string;
  message?: string;
  actionLabel?: string;
  onAction?: () => void;
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.isTablet ? responsive.spacing.l : theme.spacing.xl,
    },
    iconContainer: {
      marginBottom: responsive.isTablet
        ? responsive.spacing.m
        : theme.spacing.l,
    },
    title: {
      textAlign: 'center',
      marginBottom: theme.spacing.s,
      color: theme.colors.onSurface,
    },
    message: {
      textAlign: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing.m
        : theme.spacing.l,
      color: theme.colors.onSurfaceVariant,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing.l
        : theme.spacing.xl,
      fontSize: responsive.isTablet ? 14 : 16,
      lineHeight: responsive.isTablet ? 20 : 24,
    },
    button: {
      marginTop: responsive.isTablet ? responsive.spacing.s : theme.spacing.m,
    },
  });

const EmptyState: React.FC<EmptyStateProps> = ({
  icon = 'folder-open',
  title,
  message,
  actionLabel,
  onAction,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);

  return (
    <View style={styles.container}>
      <View style={styles.iconContainer}>
        <Icon
          source={icon}
          size={responsive.isTablet ? 56 : 64}
          color={theme.colors.onSurfaceVariant}
        />
      </View>
      <Text variant="headlineSmall" style={styles.title}>
        {title}
      </Text>
      {message && (
        <Text variant="bodyLarge" style={styles.message}>
          {message}
        </Text>
      )}
      {actionLabel && onAction && (
        <Button mode="contained" onPress={onAction} style={styles.button}>
          {actionLabel}
        </Button>
      )}
    </View>
  );
};

export default EmptyState;

================
File: app/src/app/components/OrientationTransition.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { View, ActivityIndicator, StyleSheet, Platform } from 'react-native';
import { Text } from 'react-native-paper';
import * as ScreenOrientation from 'expo-screen-orientation';
import { useAppTheme } from '../styles/theme';

interface OrientationTransitionProps {
  children: React.ReactNode;
  targetOrientation?: ScreenOrientation.OrientationLock;
}

const TRANSITION_DELAYS = {
  UNLOCK: 100,
  LOCK: 300,
} as const;

export const OrientationTransition: React.FC<OrientationTransitionProps> = ({
  children,
  targetOrientation = ScreenOrientation.OrientationLock.PORTRAIT_UP,
}) => {
  const theme = useAppTheme();
  const [isTransitioning, setIsTransitioning] = useState(Platform.OS !== 'web');

  const handleOrientationChange = useCallback(async () => {
    if (Platform.OS === 'web') {
      return;
    }

    setIsTransitioning(true);

    try {
      await ScreenOrientation.unlockAsync();
      await new Promise((resolve) =>
        setTimeout(resolve, TRANSITION_DELAYS.UNLOCK),
      );
      await ScreenOrientation.lockAsync(targetOrientation);
      await new Promise((resolve) =>
        setTimeout(resolve, TRANSITION_DELAYS.LOCK),
      );
    } catch (error) {
    } finally {
      setIsTransitioning(false);
    }
  }, [targetOrientation]);

  useEffect(() => {
    handleOrientationChange();
  }, [handleOrientationChange]);

  if (isTransitioning && Platform.OS !== 'web') {
    return (
      <View
        style={[styles.container, { backgroundColor: theme.colors.background }]}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={[styles.text, { color: theme.colors.onBackground }]}>
          Ajustando pantalla...
        </Text>
      </View>
    );
  }

  return <>{children}</>;
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    marginTop: 16,
    fontSize: 16,
  },
});

================
File: app/src/app/components/responsive/ResponsiveImage.tsx
================
import React, { useMemo } from 'react';
import { Image } from 'expo-image';
import { ImageProps } from 'expo-image';
import { StyleProp, ImageStyle } from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ResponsiveImageProps
  extends Omit<ImageProps, 'style' | 'width' | 'height'> {
  style?: StyleProp<ImageStyle>;

  // Dimensiones base
  width?: number;
  height?: number;

  // Dimensiones responsive
  widthMobile?: number;
  widthTablet?: number;
  heightMobile?: number;
  heightTablet?: number;

  // Dimensiones por orientación
  widthPortrait?: number;
  widthLandscape?: number;
  heightPortrait?: number;
  heightLandscape?: number;

  // Escalado automático
  autoScale?: boolean;
  minScale?: number;
  maxScale?: number;

  // Aspect ratio
  aspectRatio?: number;
  maintainAspectRatio?: boolean;

  // Tamaños predefinidos
  size?: 'small' | 'medium' | 'large' | 'xlarge';
  sizeTablet?: 'small' | 'medium' | 'large' | 'xlarge';

  // Comportamiento responsive
  fillContainer?: boolean;
  maxWidth?: number | string;
  maxHeight?: number | string;
  minWidth?: number | string;
  minHeight?: number | string;

  // Optimización
  enableDPIScaling?: boolean;

  // Estilos condicionales
  mobileStyle?: StyleProp<ImageStyle>;
  tabletStyle?: StyleProp<ImageStyle>;
  portraitStyle?: StyleProp<ImageStyle>;
  landscapeStyle?: StyleProp<ImageStyle>;
}

// Tamaños predefinidos
const PREDEFINED_SIZES = {
  small: { mobile: 40, tablet: 48 },
  medium: { mobile: 80, tablet: 96 },
  large: { mobile: 120, tablet: 160 },
  xlarge: { mobile: 200, tablet: 280 },
};

export const ResponsiveImage: React.FC<ResponsiveImageProps> = ({
  style,

  // Dimensiones
  width,
  height,
  widthMobile,
  widthTablet,
  heightMobile,
  heightTablet,
  widthPortrait,
  widthLandscape,
  heightPortrait,
  heightLandscape,

  // Escalado
  autoScale = true,
  minScale = 0.8,
  maxScale = 1.5,

  // Aspect ratio
  aspectRatio,
  maintainAspectRatio = true,

  // Tamaños predefinidos
  size,
  sizeTablet,

  // Comportamiento
  fillContainer = false,
  maxWidth,
  maxHeight,
  minWidth,
  minHeight,

  // Optimización
  enableDPIScaling = true,

  // Estilos condicionales
  mobileStyle,
  tabletStyle,
  portraitStyle,
  landscapeStyle,

  ...imageProps
}) => {
  const responsive = useResponsive();

  // Calcular dimensiones responsive
  const { responsiveWidth, responsiveHeight } = useMemo(() => {
    let finalWidth: number | undefined;
    let finalHeight: number | undefined;

    // Si se usa un tamaño predefinido
    if (size || sizeTablet) {
      const currentSize = responsive.isTablet && sizeTablet ? sizeTablet : size;
      if (currentSize) {
        const sizeValue = PREDEFINED_SIZES[currentSize];
        finalWidth = responsive.isTablet ? sizeValue.tablet : sizeValue.mobile;
        finalHeight = finalWidth; // Por defecto, las imágenes predefinidas son cuadradas
      }
    }

    // Dimensiones específicas por dispositivo
    if (responsive.isTablet) {
      finalWidth = widthTablet || width || finalWidth;
      finalHeight = heightTablet || height || finalHeight;
    } else {
      finalWidth = widthMobile || width || finalWidth;
      finalHeight = heightMobile || height || finalHeight;
    }

    // Dimensiones por orientación (tienen prioridad)
    if (responsive.isPortrait) {
      finalWidth = widthPortrait || finalWidth;
      finalHeight = heightPortrait || finalHeight;
    } else if (responsive.isLandscape) {
      finalWidth = widthLandscape || finalWidth;
      finalHeight = heightLandscape || finalHeight;
    }

    // Aplicar escalado automático si está habilitado
    if (autoScale && finalWidth) {
      finalWidth = responsive.scaleWithLimits(finalWidth, minScale, maxScale);
    }
    if (autoScale && finalHeight) {
      finalHeight = responsive.scaleWithLimits(finalHeight, minScale, maxScale);
    }

    // Mantener aspect ratio si es necesario
    if (maintainAspectRatio && aspectRatio && finalWidth && !finalHeight) {
      finalHeight = finalWidth / aspectRatio;
    } else if (
      maintainAspectRatio &&
      aspectRatio &&
      finalHeight &&
      !finalWidth
    ) {
      finalWidth = finalHeight * aspectRatio;
    }

    // Aplicar DPI scaling si está habilitado
    if (enableDPIScaling) {
      if (finalWidth) finalWidth = responsive.normalizeDPI(finalWidth);
      if (finalHeight) finalHeight = responsive.normalizeDPI(finalHeight);
    }

    return {
      responsiveWidth: finalWidth,
      responsiveHeight: finalHeight,
    };
  }, [
    width,
    height,
    widthMobile,
    widthTablet,
    heightMobile,
    heightTablet,
    widthPortrait,
    widthLandscape,
    heightPortrait,
    heightLandscape,
    size,
    sizeTablet,
    autoScale,
    minScale,
    maxScale,
    aspectRatio,
    maintainAspectRatio,
    enableDPIScaling,
    responsive,
  ]);

  // Calcular estilos responsive
  const responsiveStyles = useMemo(() => {
    const baseStyle: ImageStyle = {};

    // Aplicar dimensiones calculadas
    if (responsiveWidth) baseStyle.width = responsiveWidth;
    if (responsiveHeight) baseStyle.height = responsiveHeight;

    // Si fillContainer está activo
    if (fillContainer) {
      baseStyle.width = '100%';
      baseStyle.height = '100%';
    }

    // Aplicar límites
    if (maxWidth) baseStyle.maxWidth = maxWidth as any;
    if (maxHeight) baseStyle.maxHeight = maxHeight as any;
    if (minWidth) baseStyle.minWidth = minWidth as any;
    if (minHeight) baseStyle.minHeight = minHeight as any;

    // Aplicar aspect ratio si no hay altura definida
    if (aspectRatio && !responsiveHeight && !fillContainer) {
      baseStyle.aspectRatio = aspectRatio;
    }

    // Estilos condicionales por dispositivo
    const deviceStyle = responsive.isTablet ? tabletStyle : mobileStyle;

    // Estilos condicionales por orientación
    const orientationStyle = responsive.isPortrait
      ? portraitStyle
      : landscapeStyle;

    // Combinar todos los estilos
    return [baseStyle, deviceStyle, orientationStyle, style].filter(Boolean);
  }, [
    responsiveWidth,
    responsiveHeight,
    fillContainer,
    maxWidth,
    maxHeight,
    minWidth,
    minHeight,
    aspectRatio,
    mobileStyle,
    tabletStyle,
    portraitStyle,
    landscapeStyle,
    style,
    responsive,
  ]);

  // Props optimizadas para Image
  const optimizedImageProps = useMemo(() => {
    const props: Partial<ImageProps> = {
      ...imageProps,
      style: responsiveStyles,
      cachePolicy: 'memory-disk',
      priority: responsive.isTablet ? 'normal' : 'high',
      contentFit: imageProps.contentFit || 'cover',
    };

    // Solo aplicar quality si la fuente es una URI
    if (
      imageProps.source &&
      typeof imageProps.source === 'object' &&
      'uri' in imageProps.source
    ) {
      props.source = {
        ...imageProps.source,
        // La API de expo-image no soporta quality directamente,
        // pero podemos usar esto para futuras optimizaciones
      };
    }

    return props;
  }, [imageProps, responsiveStyles, responsive.isTablet]);

  return <Image {...optimizedImageProps} />;
};

// Componente helper para avatares responsive
export const ResponsiveAvatar: React.FC<
  ResponsiveImageProps & { rounded?: boolean }
> = ({ rounded = true, ...props }) => {
  const style: ImageStyle = rounded ? { borderRadius: 9999 } : {};

  return (
    <ResponsiveImage
      {...props}
      style={[style, props.style]}
      contentFit="cover"
      maintainAspectRatio={true}
      aspectRatio={1}
    />
  );
};

// Componente helper para thumbnails responsive
export const ResponsiveThumbnail: React.FC<ResponsiveImageProps> = (props) => {
  return (
    <ResponsiveImage
      size="medium"
      sizeTablet="large"
      contentFit="cover"
      enableDPIScaling={true}
      {...props}
    />
  );
};

================
File: app/src/app/components/responsive/ResponsiveModal.tsx
================
import React, { ReactNode, useMemo } from 'react';
import { Modal, Portal, Text, IconButton } from 'react-native-paper';
import {
  ScrollView,
  ViewStyle,
  StyleProp,
  View,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useAppTheme } from '@/app/styles/theme';

interface ResponsiveModalProps {
  visible: boolean;
  onDismiss: () => void;
  children: ReactNode;

  // Header configuration
  title?: string;
  hideCloseButton?: boolean;
  headerActions?: ReactNode;
  headerStyle?: StyleProp<ViewStyle>;

  // Estilo
  contentContainerStyle?: StyleProp<ViewStyle>;
  style?: StyleProp<ViewStyle>;

  // Dimensiones responsive
  width?: number | string;
  widthMobile?: number | string;
  widthTablet?: number | string;

  maxWidth?: number | string;
  maxWidthMobile?: number | string;
  maxWidthTablet?: number | string;

  height?: number | string;
  heightMobile?: number | string;
  heightTablet?: number | string;

  maxHeight?: number | string;
  maxHeightMobile?: number | string;
  maxHeightTablet?: number | string;

  // Padding responsive
  padding?: number;
  paddingMobile?: number;
  paddingTablet?: number;

  // Comportamiento
  dismissable?: boolean;
  dismissableBackButton?: boolean;
  scrollable?: boolean;
  keyboardAvoiding?: boolean;
  fullScreen?: boolean;
  fullScreenMobile?: boolean;

  // Posición
  position?: 'center' | 'bottom' | 'top';
  positionMobile?: 'center' | 'bottom' | 'top';
  positionTablet?: 'center' | 'bottom' | 'top';

  // Animación
  animationType?: 'fade' | 'slide' | 'none';

  // Footer opcional
  footer?: ReactNode;
  footerStyle?: StyleProp<ViewStyle>;
  stickyFooter?: boolean;
}

export const ResponsiveModal: React.FC<ResponsiveModalProps> = ({
  visible,
  onDismiss,
  children,

  // Header
  title,
  hideCloseButton = false,
  headerActions,
  headerStyle,

  // Estilo
  contentContainerStyle,
  style,

  // Dimensiones
  width,
  widthMobile,
  widthTablet,
  maxWidth,
  maxWidthMobile,
  maxWidthTablet,
  height,
  heightMobile,
  heightTablet,
  maxHeight,
  maxHeightMobile,
  maxHeightTablet,

  // Padding
  padding,
  paddingMobile,
  paddingTablet,

  // Comportamiento
  dismissable = true,
  dismissableBackButton = true,
  scrollable = true,
  keyboardAvoiding = true,
  fullScreen = false,
  fullScreenMobile = false,

  // Posición
  position = 'center',
  positionMobile,
  positionTablet,

  // Footer
  footer,
  footerStyle,
  stickyFooter = true,
}) => {
  const responsive = useResponsive();
  const theme = useAppTheme();
  const insets = useSafeAreaInsets();

  // Determinar si debe ser fullscreen
  const isFullScreen =
    responsive.isMobile && fullScreenMobile ? true : fullScreen;

  // Calcular posición responsive
  const modalPosition = responsive.isTablet
    ? positionTablet || position
    : positionMobile || position;

  // Calcular dimensiones responsive
  const modalDimensions = useMemo(() => {
    const dims: ViewStyle = {};

    // Width
    if (responsive.isTablet) {
      dims.width = (widthTablet ||
        width ||
        responsive.dimensions.modalWidth) as any;
      dims.maxWidth = (maxWidthTablet || maxWidth || '90%') as any;
    } else {
      dims.width = (widthMobile ||
        width ||
        (isFullScreen ? '100%' : '95%')) as any;
      dims.maxWidth = (maxWidthMobile || maxWidth || '100%') as any;
    }

    // Height
    if (height || heightMobile || heightTablet) {
      dims.height = (
        responsive.isTablet ? heightTablet || height : heightMobile || height
      ) as any;
    }

    if (maxHeight || maxHeightMobile || maxHeightTablet) {
      dims.maxHeight = (
        responsive.isTablet
          ? maxHeightTablet || maxHeight || '95%'
          : maxHeightMobile || maxHeight || '92%'
      ) as any;
    } else {
      // Default max height
      dims.maxHeight = responsive.isTablet ? '95%' : '92%';
    }

    // Si es fullscreen, ajustar dimensiones
    if (isFullScreen) {
      dims.width = '100%';
      dims.height = '100%';
      dims.maxWidth = '100%';
      dims.maxHeight = '100%';
    }

    return dims;
  }, [
    responsive,
    width,
    widthMobile,
    widthTablet,
    maxWidth,
    maxWidthMobile,
    maxWidthTablet,
    height,
    heightMobile,
    heightTablet,
    maxHeight,
    maxHeightMobile,
    maxHeightTablet,
    isFullScreen,
  ]);

  // Calcular padding responsive
  const modalPadding = useMemo(() => {
    if (isFullScreen) return 0;

    if (responsive.isTablet) {
      return paddingTablet || padding || responsive.spacing.l;
    } else {
      return paddingMobile || padding || responsive.spacing.m;
    }
  }, [responsive, padding, paddingMobile, paddingTablet, isFullScreen]);

  // Estilos del modal según posición
  const positionStyles = useMemo(() => {
    const styles: ViewStyle = {};

    switch (modalPosition) {
      case 'bottom':
        styles.justifyContent = 'flex-end';
        break;
      case 'top':
        styles.justifyContent = 'flex-start';
        break;
      case 'center':
      default:
        styles.justifyContent = 'center';
        styles.alignItems = 'center';
        break;
    }

    return styles;
  }, [modalPosition]);

  // Estilos del contenedor
  const containerStyles = useMemo(() => {
    const baseStyles: ViewStyle = {
      backgroundColor: theme.colors.surface,
      borderRadius: isFullScreen ? 0 : theme.roundness * 2,
      overflow: 'hidden',
      ...modalDimensions,
    };

    // Ajustes según posición
    if (modalPosition === 'bottom' && !isFullScreen) {
      baseStyles.borderBottomLeftRadius = 0;
      baseStyles.borderBottomRightRadius = 0;
      baseStyles.width = '100%';
      baseStyles.maxWidth = '100%';
    }

    if (modalPosition === 'top' && !isFullScreen) {
      baseStyles.borderTopLeftRadius = 0;
      baseStyles.borderTopRightRadius = 0;
      baseStyles.width = '100%';
      baseStyles.maxWidth = '100%';
    }

    // Safe area para fullscreen
    if (isFullScreen) {
      baseStyles.paddingTop = insets.top;
      baseStyles.paddingBottom = insets.bottom;
    }

    return [baseStyles, contentContainerStyle];
  }, [
    theme,
    modalDimensions,
    modalPosition,
    isFullScreen,
    insets,
    contentContainerStyle,
  ]);

  // Estilos del header
  const headerStyles = useMemo(
    () => ({
      flexDirection: 'row' as const,
      alignItems: 'center' as const,
      justifyContent: 'space-between' as const,
      paddingHorizontal: modalPadding,
      paddingVertical: modalPadding * 0.75,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    }),
    [theme, modalPadding],
  );

  // Header del modal
  const modalHeader = (title || headerActions || !hideCloseButton) && (
    <View style={[headerStyles, headerStyle]}>
      {title && (
        <Text
          variant="titleLarge"
          style={{
            color: theme.colors.onSurface,
            fontWeight: '600',
            flex: 1,
          }}
          numberOfLines={1}
        >
          {title}
        </Text>
      )}
      <View
        style={{
          flexDirection: 'row',
          alignItems: 'center',
          gap: responsive.spacing.s,
        }}
      >
        {headerActions}
        {!hideCloseButton && (
          <IconButton
            icon="close"
            size={24}
            onPress={onDismiss}
            style={{ marginRight: -responsive.spacing.s }}
          />
        )}
      </View>
    </View>
  );

  // Contenido del modal
  const modalContent = (
    <View
      style={{
        flex: scrollable ? 1 : undefined,
        padding: title ? 0 : modalPadding,
      }}
    >
      {title && modalHeader}
      <View
        style={{
          flex: scrollable ? 1 : undefined,
          padding: title ? modalPadding : 0,
        }}
      >
        {scrollable ? (
          <ScrollView
            showsVerticalScrollIndicator={false}
            contentContainerStyle={{ flexGrow: 1 }}
            keyboardShouldPersistTaps="handled"
          >
            {children}
          </ScrollView>
        ) : (
          children
        )}
      </View>
    </View>
  );

  // Footer handling
  const modalFooter = footer && (
    <View
      style={[
        {
          padding: modalPadding,
          paddingTop: modalPadding / 2,
          backgroundColor: theme.colors.surface,
          borderTopWidth: 1,
          borderTopColor: theme.colors.surfaceVariant,
        },
        footerStyle,
      ]}
    >
      {footer}
    </View>
  );

  return (
    <>
      {visible && (
        <Portal>
          <Modal
            visible={visible}
            onDismiss={onDismiss}
            dismissable={dismissable}
            dismissableBackButton={dismissableBackButton}
            contentContainerStyle={[positionStyles, style]}
            style={{ margin: isFullScreen ? 0 : undefined }}
          >
            {keyboardAvoiding && Platform.OS === 'ios' ? (
              <KeyboardAvoidingView
                behavior="padding"
                style={containerStyles}
                keyboardVerticalOffset={isFullScreen ? 0 : 100}
              >
                {modalContent}
                {stickyFooter && modalFooter}
              </KeyboardAvoidingView>
            ) : (
              <View style={containerStyles}>
                {modalContent}
                {stickyFooter && modalFooter}
              </View>
            )}
          </Modal>
        </Portal>
      )}
    </>
  );
};

// Componente helper para modales de confirmación
interface ResponsiveConfirmModalProps
  extends Omit<ResponsiveModalProps, 'children'> {
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  onConfirm: () => void;
  onCancel?: () => void;
  destructive?: boolean;
}

export const ResponsiveConfirmModal: React.FC<ResponsiveConfirmModalProps> = ({
  title,
  message,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  onConfirm,
  onCancel,
  destructive = false,
  ...modalProps
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();

  const handleCancel = () => {
    onCancel?.();
    modalProps.onDismiss();
  };

  const handleConfirm = () => {
    onConfirm();
    modalProps.onDismiss();
  };

  return (
    <ResponsiveModal
      {...modalProps}
      scrollable={false}
      maxWidthTablet={400}
      position="center"
    >
      <View style={{ paddingVertical: responsive.spacing.m }}>
        <Text
          style={[
            theme.fonts.headlineSmall,
            {
              color: theme.colors.onSurface,
              marginBottom: responsive.spacing.m,
            },
          ]}
        >
          {title}
        </Text>
        <Text
          style={[
            theme.fonts.bodyMedium,
            { color: theme.colors.onSurfaceVariant },
          ]}
        >
          {message}
        </Text>
      </View>
      <View
        style={{
          flexDirection: 'row',
          justifyContent: 'flex-end',
          gap: responsive.spacing.s,
          marginTop: responsive.spacing.l,
        }}
      >
        <Button mode="text" onPress={handleCancel} style={{ minWidth: 80 }}>
          {cancelText}
        </Button>
        <Button
          mode="contained"
          onPress={handleConfirm}
          buttonColor={destructive ? theme.colors.error : undefined}
          style={{ minWidth: 80 }}
        >
          {confirmText}
        </Button>
      </View>
    </ResponsiveModal>
  );
};

// Imports necesarios para los componentes de React Native Paper
import { Button } from 'react-native-paper';

================
File: app/src/app/components/ServerConfigModal.tsx
================
import React, { useEffect, useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  Platform,
} from 'react-native';
import {
  Text,
  Modal,
  Portal,
  Surface,
  RadioButton,
  TextInput,
  Button,
  HelperText,
  Chip,
  IconButton,
  useTheme,
} from 'react-native-paper';
import { useSnackbar } from '@/hooks/useSnackbar';
import {
  serverConnectionService,
  ConnectionMode,
} from '@/services/serverConnectionService';
import { discoveryService } from '@/app/services/discoveryService';
import EncryptedStorage from '@/app/services/secureStorageService';
import axios from 'axios';

const STORAGE_KEYS = {
  CONNECTION_MODE: 'connection_mode',
  MANUAL_URL: 'manual_server_url',
};

interface ServerConfigModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSuccess?: () => void;
}

export function ServerConfigModal({
  visible,
  onDismiss,
  onSuccess,
}: ServerConfigModalProps) {
  const theme = useTheme();
  const { showSnackbar } = useSnackbar();

  const [mode, setMode] = useState<ConnectionMode>('auto');
  const [manualUrl, setManualUrl] = useState('');
  const [currentUrl, setCurrentUrl] = useState<string | null>(null);
  const [testing, setTesting] = useState(false);
  const [loading, setLoading] = useState(true);
  const [remoteUrlAvailable, setRemoteUrlAvailable] = useState<string | null>(
    null,
  );

  useEffect(() => {
    if (visible) {
      loadSettings();
    }
  }, [visible]);

  const loadSettings = async () => {
    try {
      setLoading(true);
      const savedMode = (await EncryptedStorage.getItem(
        STORAGE_KEYS.CONNECTION_MODE,
      )) as ConnectionMode;
      const savedUrl = await EncryptedStorage.getItem(STORAGE_KEYS.MANUAL_URL);
      const currentApiUrl = await discoveryService.getApiUrl();

      if (savedMode) setMode(savedMode);
      if (savedUrl) setManualUrl(savedUrl);
      if (currentApiUrl) setCurrentUrl(currentApiUrl);

      if (currentApiUrl) {
        try {
          const response = await axios.get(`${currentApiUrl}/api/v1/discovery`);
          if (response.data.remoteUrl) {
            setRemoteUrlAvailable(response.data.remoteUrl);
          }
        } catch (error) {
        }
      }
    } catch (error) {
      console.error('Error loading settings:', error);
    } finally {
      setLoading(false);
    }
  };

  const normalizeUrl = (url: string): string => {
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'http://' + url;
    }

    try {
      const parsed = new URL(url);
      if (
        !parsed.port &&
        (parsed.hostname.startsWith('192.168.') ||
          parsed.hostname.startsWith('10.') ||
          parsed.hostname.startsWith('172.') ||
          parsed.hostname === 'localhost' ||
          /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(parsed.hostname))
      ) {
        parsed.port = '3737';
      }
      return `${parsed.protocol}//${parsed.host}`;
    } catch {
      return url;
    }
  };

  const validateUrl = (url: string): boolean => {
    try {
      const normalized = normalizeUrl(url);
      const parsed = new URL(normalized);
      return ['http:', 'https:'].includes(parsed.protocol);
    } catch {
      return false;
    }
  };

  const testConnection = async () => {
    if (mode === 'manual' && !validateUrl(manualUrl)) {
      showSnackbar('Por favor ingresa una URL válida', 'error');
      return;
    }

    setTesting(true);
    try {
      let urlToTest = '';

      if (mode === 'auto') {
        // Probar auto-descubrimiento
        const discovered = await discoveryService.discoverServer();
        if (!discovered) {
          throw new Error('No se pudo encontrar el servidor en la red local');
        }
        urlToTest = discovered;
      } else if (mode === 'remote' && remoteUrlAvailable) {
        urlToTest = remoteUrlAvailable;
      } else {
        urlToTest = normalizeUrl(manualUrl);
      }

      // Verificar conexión
      const response = await axios.get(`${urlToTest}/api/v1/discovery`, {
        timeout: 5000,
      });

      if (response.data.type !== 'cloudbite-api') {
        throw new Error('El servidor no es compatible');
      }

      showSnackbar('Conexión exitosa', 'success');
      setCurrentUrl(urlToTest);
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al conectar con el servidor',
        'error',
      );
    } finally {
      setTesting(false);
    }
  };

  const saveSettings = async () => {
    try {
      // Guardar modo de conexión
      await EncryptedStorage.setItem(STORAGE_KEYS.CONNECTION_MODE, mode);

      // Guardar URL manual si aplica
      if (mode === 'manual') {
        if (!validateUrl(manualUrl)) {
          showSnackbar('Por favor ingresa una URL válida', 'error');
          return;
        }
        const normalizedUrl = normalizeUrl(manualUrl);
        await EncryptedStorage.setItem(STORAGE_KEYS.MANUAL_URL, normalizedUrl);
        await discoveryService.setServerUrl(normalizedUrl, true);

        // En web, verificar la conexión inmediatamente
        if (Platform.OS === 'web') {
          try {
            const response = await axios.get(
              `${normalizedUrl}/api/v1/discovery`,
              {
                timeout: 5000,
              },
            );
            if (response.data.type === 'cloudbite-api') {
              // El servicio detectará automáticamente el cambio de URL
            }
          } catch (error) {
            console.error(
              'Error verificando conexión después de guardar:',
              error,
            );
          }
        }
      } else if (mode === 'remote' && remoteUrlAvailable) {
        await discoveryService.setServerUrl(remoteUrlAvailable, true);
      } else {
        // Modo automático - limpiar URL manual
        await discoveryService.setServerUrl(null, true);
      }

      // La reconexión se manejará en el onSuccess callback

      showSnackbar('Configuración guardada', 'success');
      onSuccess?.();
      onDismiss();
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al guardar la configuración',
        'error',
      );
    }
  };

  const styles = StyleSheet.create({
    modal: {
      justifyContent: 'center',
      alignItems: 'center',
      margin: 20,
    },
    container: {
      width: '100%',
      maxWidth: 500,
      maxHeight: '90%',
      backgroundColor: theme.colors.surface,
      borderRadius: 16,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    title: {
      fontSize: 20,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    content: {
      padding: 16,
    },
    loadingContainer: {
      padding: 40,
      alignItems: 'center',
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      marginBottom: 16,
    },
    successChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    errorChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    urlText: {
      flex: 1,
      marginLeft: 8,
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    section: {
      marginBottom: 16,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      marginBottom: 8,
      color: theme.colors.onSurface,
    },
    manualConfig: {
      marginTop: 8,
      marginLeft: 32,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      gap: 8,
      padding: 16,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modal}
        dismissable={!testing}
      >
        <Surface style={styles.container}>
          <View style={styles.header}>
            <Text style={styles.title}>Configuración del Servidor</Text>
            <IconButton
              icon="close"
              size={24}
              onPress={onDismiss}
              disabled={testing}
            />
          </View>

          <ScrollView style={styles.content}>
            {loading ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" />
              </View>
            ) : (
              <>
                {/* Estado actual */}
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Estado de Conexión</Text>
                  {currentUrl ? (
                    <View style={styles.statusContainer}>
                      <Chip
                        icon="check-circle"
                        mode="flat"
                        style={styles.successChip}
                      >
                        Conectado
                      </Chip>
                      <Text
                        variant="bodySmall"
                        style={styles.urlText}
                        numberOfLines={1}
                      >
                        {currentUrl}
                      </Text>
                    </View>
                  ) : (
                    <View style={styles.statusContainer}>
                      <Chip
                        icon="alert-circle"
                        mode="flat"
                        style={styles.errorChip}
                      >
                        Sin conexión
                      </Chip>
                    </View>
                  )}
                </View>

                {/* Modo de conexión */}
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Modo de Conexión</Text>
                  <RadioButton.Group
                    onValueChange={(value) => setMode(value as ConnectionMode)}
                    value={mode}
                  >
                    <RadioButton.Item
                      label="Automático (Red Local)"
                      value="auto"
                      status={mode === 'auto' ? 'checked' : 'unchecked'}
                    />
                    <HelperText type="info" visible={mode === 'auto'}>
                      Busca automáticamente el servidor en tu red local
                    </HelperText>

                    {remoteUrlAvailable && (
                      <>
                        <RadioButton.Item
                          label="Remoto (Internet)"
                          value="remote"
                          status={mode === 'remote' ? 'checked' : 'unchecked'}
                        />
                        <HelperText type="info" visible={mode === 'remote'}>
                          Usa el servidor remoto: {remoteUrlAvailable}
                        </HelperText>
                      </>
                    )}

                    <RadioButton.Item
                      label="Manual"
                      value="manual"
                      status={mode === 'manual' ? 'checked' : 'unchecked'}
                    />

                    {mode === 'manual' && (
                      <View style={styles.manualConfig}>
                        <TextInput
                          label="URL del Servidor"
                          value={manualUrl}
                          onChangeText={setManualUrl}
                          placeholder="192.168.1.230 o http://192.168.1.230:3737"
                          mode="outlined"
                          autoCapitalize="none"
                          autoCorrect={false}
                          keyboardType="url"
                          error={manualUrl !== '' && !validateUrl(manualUrl)}
                        />
                        <HelperText
                          type="info"
                          visible={mode === 'manual' && manualUrl === ''}
                        >
                          Puedes ingresar solo la IP. El puerto 3737 se agregará
                          automáticamente.
                        </HelperText>
                        <HelperText
                          type="error"
                          visible={manualUrl !== '' && !validateUrl(manualUrl)}
                        >
                          URL inválida
                        </HelperText>
                      </View>
                    )}
                  </RadioButton.Group>
                </View>
              </>
            )}
          </ScrollView>

          <View style={styles.actions}>
            <Button mode="text" onPress={onDismiss} disabled={testing}>
              Cancelar
            </Button>
            <Button
              mode="outlined"
              onPress={testConnection}
              loading={testing}
              disabled={testing || loading}
              icon="connection"
            >
              Probar
            </Button>
            <Button
              mode="contained"
              onPress={saveSettings}
              disabled={testing || loading}
              icon="content-save"
            >
              Guardar
            </Button>
          </View>
        </Surface>
      </Modal>
    </Portal>
  );
}

================
File: app/src/app/constants/navigationPaths.ts
================
export const NAVIGATION_PATHS = {
  LOGIN: 'Login',

  MAIN_DRAWER: 'MainDrawer',

  ORDERS_STACK: 'OrdersStack',
  ORDERS: 'Orders',
  CREATE_ORDER: 'CreateOrder',
  OPEN_ORDERS: 'OpenOrders',
  ADD_PRODUCTS_TO_ORDER: 'AddProductsToOrder',

  MENU_STACK: 'MenuStack',
  CATEGORIES: 'CategoriesScreen',
  SUBCATEGORIES: 'SubcategoriesScreen',
  PRODUCTS: 'Products',

  AREAS_TABLES_STACK: 'AreasTablesStack',
  AREAS_LIST: 'AreasList',
  TABLES_LIST: 'TablesList',

  MODIFIERS_STACK: 'ModifiersStack',
  MODIFIER_GROUPS: 'ModifierGroupsScreen',
  MODIFIERS: 'ModifiersScreen',

  KITCHEN_STACK: 'KitchenStack',
  KITCHEN_ORDERS: 'KitchenOrders',
  KITCHEN: 'Kitchen',

  RECEIPTS_STACK: 'ReceiptsStack',
  RECEIPTS_LIST: 'ReceiptsList',

  ORDER_FINALIZATION_STACK: 'OrderFinalizationStack',
  ORDER_FINALIZATION: 'OrderFinalizationScreen',

  AVAILABILITY_STACK: 'AvailabilityStack',
  AVAILABILITY: 'AvailabilityScreen',

  RESTAURANT_CONFIG_STACK: 'RestaurantConfigStack',
  RESTAURANT_CONFIG: 'RestaurantConfig',

  CUSTOMERS_STACK: 'CustomersStack',
  CUSTOMERS: 'Customers',

  PIZZA_CUSTOMIZATIONS_STACK: 'PizzaCustomizationsStack',
  PIZZA_CUSTOMIZATIONS_LIST: 'PizzaCustomizationsList',

  SYNC_STACK: 'SyncStack',
  SYNC_STATUS: 'SyncStatus',

  USERS_STACK: 'UsersStack',
  USERS_LIST: 'UsersList',

  SHIFT_AUDIT_STACK: 'ShiftAuditStack',
  SHIFTS_LIST: 'ShiftsList',

  PRINTERS_STACK: 'PrintersStack',
  PRINTERS_LIST: 'PrintersList',

  PREPARATION_SCREENS_STACK: 'PreparationScreensStack',
  PREPARATION_SCREENS_LIST: 'PreparationScreensList',
} as const;

export type RootStackParamList = {
  [NAVIGATION_PATHS.LOGIN]: undefined;
  [NAVIGATION_PATHS.MAIN_DRAWER]: undefined;
};

export type OrdersStackParamList = {
  [NAVIGATION_PATHS.ORDERS]: undefined;
  [NAVIGATION_PATHS.CREATE_ORDER]: undefined;
  [NAVIGATION_PATHS.OPEN_ORDERS]: undefined;
  [NAVIGATION_PATHS.ADD_PRODUCTS_TO_ORDER]: {
    orderId: number;
    orderNumber: string;
    existingOrderItemsCount: number;
    existingTempProducts?: any[];
    onProductsAdded?: () => void;
  };
};

export type MenuStackParamList = {
  [NAVIGATION_PATHS.CATEGORIES]: undefined;
  [NAVIGATION_PATHS.SUBCATEGORIES]: {
    categoryId: number;
    categoryName: string;
  };
  [NAVIGATION_PATHS.PRODUCTS]: {
    subcategoryId: number;
    subCategoryName: string;
  };
};

export type AreasTablesStackParamList = {
  [NAVIGATION_PATHS.AREAS_LIST]: undefined;
  [NAVIGATION_PATHS.TABLES_LIST]: {
    areaId: number;
    areaName: string;
  };
};

export type ModifiersStackParamList = {
  [NAVIGATION_PATHS.MODIFIER_GROUPS]: undefined;
  [NAVIGATION_PATHS.MODIFIERS]: {
    groupId: number;
    groupName: string;
  };
};

export type KitchenStackParamList = {
  [NAVIGATION_PATHS.KITCHEN_ORDERS]: undefined;
};

================
File: app/src/app/constants/network.ts
================
export const NETWORK_CONFIG = {
  DISCOVERY_PORT: 3737,

  DISCOVERY_TIMEOUT: 1000,
  HEALTH_CHECK_TIMEOUT: 3000,
  API_TIMEOUT: 5000,

  HEALTH_CHECK_INTERVAL: 30000,
  HEALTH_RETRY_INTERVALS: [5000, 10000, 20000, 30000],

  MIN_DISCOVERY_INTERVAL: 10000,
  RECONNECT_CYCLE_DELAY: 10000,
  HEALTH_CHECK_ATTEMPTS: 3,

  MAX_CONCURRENT_REQUESTS: 50,

  COMMON_SUBNETS: ['192.168.1', '192.168.0', '10.0.0'],
} as const;

================
File: app/src/app/constants/rolePermissions.ts
================
import { RoleEnum } from '@/modules/users/types/user.types';

export type DrawerSection =
  | 'OrdersStack'
  | 'ReceiptsStack'
  | 'OrderFinalizationStack'
  | 'MenuStack'
  | 'AvailabilityStack'
  | 'ModifiersStack'
  | 'PizzaCustomizationsStack'
  | 'PreparationScreensStack'
  | 'AreasTablesStack'
  | 'PrintersStack'
  | 'RestaurantConfigStack'
  | 'CustomersStack'
  | 'SyncStack'
  | 'UsersStack'
  | 'KitchenStack'
  | 'ShiftAuditStack';

// Definir permisos por rol
export const ROLE_PERMISSIONS: Record<RoleEnum, DrawerSection[]> = {
  // Admin - Acceso completo
  [RoleEnum.ADMIN]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityStack',
    'ModifiersStack',
    'PizzaCustomizationsStack',
    'PreparationScreensStack',
    'AreasTablesStack',
    'PrintersStack',
    'RestaurantConfigStack',
    'CustomersStack',
    'SyncStack',
    'UsersStack',
    'ShiftAuditStack',
  ],

  // Manager - Acceso completo excepto usuarios
  [RoleEnum.MANAGER]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityStack',
    'ModifiersStack',
    'PizzaCustomizationsStack',
    'PreparationScreensStack',
    'AreasTablesStack',
    'PrintersStack',
    'RestaurantConfigStack',
    'CustomersStack',
    'SyncStack',
    'ShiftAuditStack',
  ],

  // Cashier - Ventas, clientes y configuración básica
  [RoleEnum.CASHIER]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityStack',
    'AreasTablesStack',
    'CustomersStack',
  ],

  // Waiter - Órdenes, mesas y disponibilidad
  [RoleEnum.WAITER]: [
    'OrdersStack',
    'MenuStack',
    'AvailabilityStack',
    'AreasTablesStack',
    'CustomersStack',
  ],

  // Kitchen - Solo acceso a pantalla de preparación
  // Los usuarios con pantalla asignada van directo a KitchenStack
  [RoleEnum.KITCHEN]: ['KitchenStack'],

  // Delivery - Órdenes, clientes y áreas
  [RoleEnum.DELIVERY]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'CustomersStack',
    'AreasTablesStack',
  ],
};

// Helper para verificar si un rol tiene permiso para una sección
export const hasPermission = (
  roleId: number | undefined,
  section: DrawerSection,
): boolean => {
  if (!roleId) return false;

  const permissions = ROLE_PERMISSIONS[roleId as RoleEnum];
  return permissions ? permissions.includes(section) : false;
};

// Agrupar secciones por categoría para facilitar el renderizado
export const DRAWER_SECTIONS = {
  sales: {
    title: 'Ventas',
    items: [
      {
        route: 'OrdersStack',
        label: 'Órdenes',
        icon: 'clipboard-list-outline',
      },
      {
        route: 'OrderFinalizationStack',
        label: 'Finalización',
        icon: 'clipboard-check-outline',
      },
      { route: 'ReceiptsStack', label: 'Recibos', icon: 'receipt' },
    ],
  },
  configuration: {
    title: 'Configuración',
    items: [
      { route: 'MenuStack', label: 'Menú', icon: 'menu' },
      {
        route: 'AvailabilityStack',
        label: 'Disponibilidad',
        icon: 'eye-off-outline',
      },
      { route: 'ModifiersStack', label: 'Modificadores', icon: 'tune' },
      {
        route: 'PizzaCustomizationsStack',
        label: 'Personalización Pizzas',
        icon: 'pizza',
      },
      {
        route: 'PreparationScreensStack',
        label: 'Pantallas Preparación',
        icon: 'monitor-dashboard',
      },
      {
        route: 'AreasTablesStack',
        label: 'Áreas y Mesas',
        icon: 'map-marker-radius-outline',
      },
      { route: 'PrintersStack', label: 'Impresoras', icon: 'printer' },
      {
        route: 'RestaurantConfigStack',
        label: 'Configuración',
        icon: 'cog-outline',
      },
      {
        route: 'CustomersStack',
        label: 'Clientes',
        icon: 'account-group-outline',
      },
      { route: 'SyncStack', label: 'Sincronización', icon: 'sync' },
    ],
  },
  administration: {
    title: 'Administración',
    items: [
      { route: 'UsersStack', label: 'Usuarios', icon: 'account-multiple' },
      {
        route: 'ShiftAuditStack',
        label: 'Historial de Turnos',
        icon: 'history',
      },
    ],
  },
} as const;

================
File: app/src/app/hooks/useInitializeAuth.ts
================
import { useEffect, useState } from 'react';
import { initializeAuthStore } from '../store/authStore';
import { verifyStoredToken } from '../utils/tokenVerification';

export function useInitializeAuth() {
  const [isInitializing, setIsInitializing] = useState(true);

  useEffect(() => {
    const initialize = async () => {
      try {
        await initializeAuthStore();
        // Verificar el token después de inicializar el store
        await verifyStoredToken();
      } catch (error) {
        // Error al inicializar auth store
      } finally {
        setIsInitializing(false);
      }
    };

    initialize();
  }, []);

  return isInitializing;
}

================
File: app/src/app/hooks/useNativeDriver.ts
================
import { Platform } from 'react-native';

/**
 * Hook para determinar si usar el driver nativo para animaciones
 * En web, siempre devuelve false para evitar advertencias
 */
export function useNativeDriver(): boolean {
  return Platform.OS !== 'web';
}

================
File: app/src/app/lib/apiResponseHelper.ts
================
import { ApiResponse } from 'apisauce';
import { ApiError } from './errors';
import { BackendErrorResponse } from '../types/api.types';

/**
 * Helper function to handle API error responses consistently
 * If the interceptor already created an ApiError, use it directly
 * Otherwise, create a new one from the response data
 */
export function handleApiError(response: ApiResponse<any>): never {
  // Si hay un apiError ya procesado por el interceptor, usarlo directamente
  if ((response as any).apiError instanceof ApiError) {
    throw (response as any).apiError;
  }

  // Si no, crear uno nuevo (fallback)
  throw ApiError.fromApiResponse(
    response.data as BackendErrorResponse | undefined,
    response.status,
  );
}

================
File: app/src/app/lib/errorMapping.ts
================
import { ApiError } from './errors';
import { ERROR_CODES, ApiErrorCode } from '../constants/apiErrorCodes';
import { AxiosError } from 'axios';

const errorCodeMessages: { [key in ApiErrorCode | string]?: string } = {
  // Errores de autenticación
  [ERROR_CODES.AUTH_INVALID_CREDENTIALS]:
    'El correo/usuario o la contraseña son incorrectos.',
  [ERROR_CODES.AUTH_INCORRECT_PASSWORD]: 'La contraseña es incorrecta.',
  [ERROR_CODES.AUTH_DUPLICATE_EMAIL]:
    'Este correo electrónico ya está registrado. Intenta iniciar sesión.',
  [ERROR_CODES.AUTH_DUPLICATE_USERNAME]:
    'Este nombre de usuario ya está en uso. Elige otro.',
  [ERROR_CODES.AUTH_UNAUTHORIZED]:
    'No autorizado. Por favor, inicia sesión de nuevo.',
  [ERROR_CODES.AUTH_FORBIDDEN]: 'No tienes permiso para realizar esta acción.',
  [ERROR_CODES.REFRESH_FAILED]:
    'Tu sesión ha expirado. Por favor, inicia sesión nuevamente.',

  // Errores de validación
  [ERROR_CODES.VALIDATION_ERROR]: 'Por favor, revisa la información ingresada.',

  // Errores de recursos
  [ERROR_CODES.RESOURCE_NOT_FOUND]: 'El recurso solicitado no se encontró.',
  [ERROR_CODES.CONFLICT_ERROR]: 'Hubo un conflicto al procesar tu solicitud.',
  [ERROR_CODES.PRODUCT_NAME_EXISTS]:
    'Ya existe un producto con ese nombre. Por favor, elige otro nombre.',

  // Errores de red y servidor
  [ERROR_CODES.NETWORK_ERROR]:
    'Error de red. Verifica tu conexión e inténtalo de nuevo.',
  [ERROR_CODES.API_CLIENT_ERROR]: 'Error al comunicar con el servidor.',
  [ERROR_CODES.INTERNAL_SERVER_ERROR]:
    'Ocurrió un error en el servidor. Inténtalo de nuevo más tarde.',
  [ERROR_CODES.UNKNOWN_API_ERROR]:
    'Ocurrió un error inesperado al procesar tu solicitud.',
  [ERROR_CODES.UNKNOWN_ERROR]: 'Ocurrió un error desconocido.',

  // Mensajes por código de estado HTTP
  [`status_400`]: 'La solicitud contiene datos inválidos.',
  [`status_401`]: 'No autorizado. Por favor, inicia sesión de nuevo.',
  [`status_403`]: 'No tienes permiso para realizar esta acción.',
  [`status_404`]: 'El recurso solicitado no se encontró.',
  [`status_409`]: 'Existe un conflicto con el estado actual del recurso.',
  [`status_422`]: 'Los datos enviados son inválidos o incompletos.',
  [`status_500`]: 'Error interno del servidor. Por favor, intenta más tarde.',
  [`status_502`]: 'Error de conexión con el servidor.',
  [`status_503`]: 'El servicio no está disponible temporalmente.',

  // Códigos específicos del backend - Autenticación
  AUTH_USER_NOT_FOUND: 'Usuario no encontrado.',
  AUTH_EMAIL_NOT_CONFIRMED:
    'Por favor, confirma tu correo electrónico antes de iniciar sesión.',
  AUTH_ACCOUNT_LOCKED:
    'Tu cuenta ha sido bloqueada. Contacta al administrador.',
  AUTH_SESSION_EXPIRED:
    'Tu sesión ha expirado. Por favor, inicia sesión nuevamente.',

  // Códigos específicos del backend - Validación
  VALIDATION_FAILED: 'Error de validación. Revisa los datos ingresados.',
  DUPLICATE_ENTRY: 'Ya existe un registro con estos datos.',
  INVALID_INPUT: 'Los datos ingresados no son válidos.',
  MISSING_REQUIRED_FIELD: 'Faltan campos obligatorios.',

  // Códigos específicos del backend - Permisos
  INSUFFICIENT_PERMISSIONS:
    'No tienes permisos suficientes para realizar esta acción.',
  RATE_LIMIT_EXCEEDED:
    'Has realizado demasiadas solicitudes. Intenta más tarde.',

  // Códigos específicos del backend - Órdenes
  ORDER_NOT_FOUND: 'La orden no fue encontrada.',
  ORDER_ALREADY_COMPLETED: 'Esta orden ya fue completada.',
  ORDER_CANNOT_BE_MODIFIED:
    'Esta orden no puede ser modificada en su estado actual.',
  TABLE_ALREADY_OCCUPIED: 'La mesa seleccionada ya está ocupada.',
  INVALID_ORDER_TYPE: 'Tipo de orden inválido.',
  NO_ITEMS_IN_ORDER: 'La orden debe contener al menos un producto.',

  // Códigos específicos del backend - Productos
  PRODUCT_NOT_FOUND: 'El producto no fue encontrado.',
  PRODUCT_NOT_AVAILABLE: 'El producto no está disponible en este momento.',
  PRODUCT_OUT_OF_STOCK: 'El producto está agotado.',
  INVALID_PRODUCT_VARIANT: 'La variante del producto no es válida.',
  INVALID_MODIFIER: 'El modificador seleccionado no es válido.',

  // Códigos específicos del backend - Mesas y Áreas
  TABLE_NOT_FOUND: 'La mesa no fue encontrada.',
  AREA_NOT_FOUND: 'El área no fue encontrada.',
  TABLE_IN_USE: 'La mesa está siendo utilizada en otra orden.',

  // Códigos específicos del backend - Impresoras
  PRINTER_NOT_FOUND: 'La impresora no fue encontrada.',
  PRINTER_OFFLINE: 'La impresora no está disponible.',
  PRINT_FAILED: 'Error al imprimir. Verifica la conexión de la impresora.',
  THERMAL_PRINTER_DUPLICATE_FIELD: 'Ya existe una impresora con ese nombre.',

  // Códigos específicos del backend - Categorías
  CATEGORY_NOT_FOUND: 'La categoría no fue encontrada.',
  SUBCATEGORY_NOT_FOUND: 'La subcategoría no fue encontrada.',
  CATEGORY_HAS_PRODUCTS:
    'No se puede eliminar la categoría porque tiene productos asociados.',

  // Errores de archivos
  [ERROR_CODES.UPLOAD_FAILED]:
    'Error al subir el archivo. Por favor, intenta nuevamente.',
  [ERROR_CODES.FILE_TOO_LARGE]:
    'El archivo es demasiado grande. El tamaño máximo permitido es 10MB.',
  cantUploadFileType:
    'El tipo de archivo no está permitido. Solo se permiten imágenes (JPG, JPEG, PNG, GIF).',
};

export function getApiErrorMessage(error: unknown): string {
  const defaultMessage = 'Ocurrió un error inesperado.';

  if (error instanceof ApiError) {
    // Si tenemos un mensaje específico del backend y no es un mensaje genérico,
    // usarlo siempre, independientemente del código
    if (
      error.originalMessage &&
      error.originalMessage !== 'Error desconocido de la API.' &&
      error.originalMessage !== 'Not Found' &&
      error.originalMessage !== 'Internal Server Error' &&
      error.originalMessage !==
        'Ocurrió un error inesperado al procesar tu solicitud.' &&
      !error.originalMessage.includes('<!DOCTYPE') // Evitar HTML de errores
    ) {
      return error.originalMessage;
    }

    // Si no, intentamos con el código específico
    let message = errorCodeMessages[error.code];

    // Si no hay mensaje para el código, intentamos con el código de estado
    if (!message) {
      message = errorCodeMessages[`status_${error.status}`];
    }

    // Si encontramos un mensaje genérico pero tenemos detalles específicos, usar los detalles
    if (message === errorCodeMessages[`status_409`] && error.details?.message) {
      return error.details.message;
    }

    return message || defaultMessage;
  } else if (error instanceof AxiosError) {
    if (error.message === 'Network Error' || !error.response) {
      return errorCodeMessages[ERROR_CODES.NETWORK_ERROR] || 'Error de red.';
    }
    if (error.response?.status) {
      const statusMessage =
        errorCodeMessages[`status_${error.response.status}`];
      if (statusMessage) return statusMessage;
    }
    return errorCodeMessages[ERROR_CODES.UNKNOWN_API_ERROR] || defaultMessage;
  } else if (error instanceof Error) {
    if (
      error.message.toLowerCase().includes('network request failed') ||
      error.message.toLowerCase().includes('failed to fetch')
    ) {
      return errorCodeMessages[ERROR_CODES.NETWORK_ERROR] || 'Error de red.';
    }
    return error.message && !error.message.toLowerCase().includes('undefined')
      ? error.message
      : defaultMessage;
  } else {
    return defaultMessage;
  }
}

================
File: app/src/app/lib/formatters.ts
================
/**
 * Formatea un número como moneda
 * @param amount - Cantidad a formatear
 * @param currency - Código de moneda (por defecto MXN)
 * @returns String formateado como moneda
 */
export function formatCurrency(
  amount: number | null | undefined,
  currency = 'MXN',
): string {
  // Si el valor es null, undefined o NaN, devolver $0.00
  if (amount === null || amount === undefined || isNaN(amount)) {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(0);
  }

  return new Intl.NumberFormat('es-MX', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
}

/**
 * Formatea un número de teléfono
 * @param phoneNumber - Número de teléfono
 * @returns String formateado
 */
export function formatPhoneNumber(phoneNumber: string): string {
  // Remover todo excepto números
  const cleaned = phoneNumber.replace(/\D/g, '');

  // Formato mexicano: +52 55 1234 5678
  if (cleaned.length === 10) {
    return `${cleaned.slice(0, 2)} ${cleaned.slice(2, 6)} ${cleaned.slice(6)}`;
  } else if (cleaned.length === 12 && cleaned.startsWith('52')) {
    return `+${cleaned.slice(0, 2)} ${cleaned.slice(2, 4)} ${cleaned.slice(4, 8)} ${cleaned.slice(8)}`;
  }

  return phoneNumber;
}

================
File: app/src/app/lib/imageUtils.ts
================
import { serverConnectionService } from '@/services/serverConnectionService';

/**
 * Construye la URL completa de una imagen a partir de su ruta relativa o absoluta.
 * Si la ruta ya es una URL completa (http/https) o URI local (file://), la devuelve tal cual.
 * Si es una ruta relativa, la prefija con la URL del API obtenida dinámicamente.
 * @param imagePath - La ruta relativa (ej. 'uploads/imagen.jpg') o URL completa de la imagen.
 * @returns Promise con la URL completa y lista para usar, o null si la entrada es inválida.
 */
export const getImageUrl = async (
  imagePath: string | null | undefined,
): Promise<string | null> => {
  if (!imagePath || typeof imagePath !== 'string') {
    return null;
  }

  try {
    // Obtener la URL del servicio de conexión sin provocar discovery
    const connectionState = serverConnectionService.getState();
    if (!connectionState.serverUrl || !connectionState.isConnected) {
      return null;
    }

    const apiUrl = connectionState.serverUrl;
    const normalizedApiUrl = apiUrl.endsWith('/')
      ? apiUrl.slice(0, -1)
      : apiUrl;
    const normalizedPath = imagePath.replace(/\\/g, '/');

    if (normalizedPath.startsWith('http')) {
      const urlObj = new URL(normalizedPath);
      const pathPart = urlObj.pathname;

      return `${normalizedApiUrl}${pathPart}`;
    }
    const formattedPath = normalizedPath.startsWith('/')
      ? normalizedPath
      : `/${normalizedPath}`;

    return `${normalizedApiUrl}${formattedPath}`;
  } catch (error) {
    return null;
  }
};

/**
 * Versión síncrona que usa una URL base proporcionada.
 * Útil cuando ya tienes la URL del API disponible.
 * @param imagePath - La ruta relativa o URL completa de la imagen.
 * @param apiUrl - La URL base del API.
 * @returns La URL completa y lista para usar, o null si la entrada es inválida.
 */
export const getImageUrlSync = (
  imagePath: string | null | undefined,
  apiUrl: string,
): string | null => {
  if (!imagePath || typeof imagePath !== 'string') {
    return null;
  }

  const normalizedApiUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
  const normalizedPath = imagePath.replace(/\\/g, '/');

  if (normalizedPath.startsWith('http')) {
    const urlObj = new URL(normalizedPath);
    const pathPart = urlObj.pathname;

    return `${normalizedApiUrl}${pathPart}`;
  }
  const formattedPath = normalizedPath.startsWith('/')
    ? normalizedPath
    : `/${normalizedPath}`;

  return `${normalizedApiUrl}${formattedPath}`;
};

/**
 * Limpia el cache de la URL del API.
 * Útil cuando se necesita forzar una nueva búsqueda del servidor.
 */
export const clearApiUrlCache = () => {
  cachedApiUrl = null;
  cacheTimestamp = 0;
};

================
File: app/src/app/lib/zodResolver.ts
================
import type { FieldErrors, FieldValues, ResolverResult } from 'react-hook-form';
import type { ZodSchema, ZodError } from 'zod';

export function zodResolver<T extends FieldValues>(schema: ZodSchema<T>) {
  return async (data: T): Promise<ResolverResult<T>> => {
    try {
      const validatedData = await schema.parseAsync(data);
      return {
        values: validatedData,
        errors: {},
      };
    } catch (error) {
      if (error instanceof Error && 'errors' in error) {
        const zodError = error as ZodError;
        const fieldErrors: FieldErrors<T> = {};

        zodError.errors.forEach((err) => {
          const path = err.path.join('.');
          if (path) {
            fieldErrors[path as keyof T] = {
              type: err.code,
              message: err.message,
            };
          }
        });

        return {
          values: {} as T,
          errors: fieldErrors,
        };
      }
      throw error;
    }
  };
}

================
File: app/src/app/navigation/components/WebDrawer.tsx
================
import React, { useEffect } from 'react';
import {
  View,
  StyleSheet,
  Pressable,
  Animated,
  Platform,
  ScrollView,
} from 'react-native';
import { Portal } from 'react-native-paper';
import { useAppTheme } from '../../styles/theme';

interface WebDrawerProps {
  open: boolean;
  onClose: () => void;
  children: React.ReactNode;
  drawerContent: React.ReactNode;
  drawerWidth?: number;
}

export function WebDrawer({
  open,
  onClose,
  children,
  drawerContent,
  drawerWidth = 320,
}: WebDrawerProps) {
  const theme = useAppTheme();
  const slideAnim = React.useRef(new Animated.Value(-drawerWidth)).current;
  const fadeAnim = React.useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (open) {
      // Abrir drawer
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      // Cerrar drawer
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: -drawerWidth,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [open, slideAnim, fadeAnim, drawerWidth]);

  // Manejar ESC para cerrar
  useEffect(() => {
    if (Platform.OS === 'web' && open) {
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          onClose();
        }
      };
      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }
  }, [open, onClose]);

  const styles = StyleSheet.create({
    container: {
      flex: 1,
    },
    overlay: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      zIndex: 998,
    },
    drawer: {
      position: 'absolute',
      top: 0,
      left: 0,
      bottom: 0,
      width: drawerWidth,
      backgroundColor: theme.colors.surface,
      elevation: 16,
      shadowColor: '#000',
      shadowOffset: { width: 2, height: 0 },
      shadowOpacity: 0.25,
      shadowRadius: 10,
      zIndex: 999,
      borderRightWidth: 1,
      borderRightColor: theme.colors.outlineVariant,
    },
  });

  // Solo mostrar el drawer personalizado en web
  if (Platform.OS !== 'web') {
    return <>{children}</>;
  }

  return (
    <View style={styles.container}>
      {children}
      {open && (
        <Portal>
          <Animated.View
            style={[
              styles.overlay,
              {
                opacity: fadeAnim,
              },
            ]}
          >
            <Pressable style={StyleSheet.absoluteFill} onPress={onClose} />
          </Animated.View>
          <Animated.View
            style={[
              styles.drawer,
              {
                transform: [{ translateX: slideAnim }],
              },
            ]}
          >
            <ScrollView
              contentContainerStyle={{ flexGrow: 1 }}
              showsVerticalScrollIndicator={false}
            >
              {drawerContent}
            </ScrollView>
          </Animated.View>
        </Portal>
      )}
    </View>
  );
}

================
File: app/src/app/navigation/components/WebDrawerContent.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { ScrollView } from 'react-native';
import {
  Drawer as PaperDrawer,
  Text,
  Divider,
  Switch,
  TouchableRipple,
  Icon,
  Surface,
  Portal,
  Dialog,
  Button,
} from 'react-native-paper';
import { useThemeStore } from '../../store/themeStore';
import { THEME_MODE } from '../../types/theme.types';
import { useAuthStore } from '../../store/authStore';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
import { clearImageCache } from '../../lib/imageCache';
import { useSnackbarStore } from '../../store/snackbarStore';
import { RoleEnum } from '@/modules/users/types/user.types';

interface WebDrawerContentProps {
  onClose: () => void;
}

// Traducciones de roles
const ROLE_TRANSLATIONS: Record<number, string> = {
  [RoleEnum.ADMIN]: 'Administrador',
  [RoleEnum.MANAGER]: 'Gerente',
  [RoleEnum.CASHIER]: 'Cajero',
  [RoleEnum.WAITER]: 'Mesero',
  [RoleEnum.KITCHEN]: 'Cocina',
  [RoleEnum.DELIVERY]: 'Repartidor',
};

const getRoleTranslation = (roleId?: number): string => {
  if (!roleId) return 'Desconocido';
  return ROLE_TRANSLATIONS[roleId] || 'Desconocido';
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    userInfoSection: {
      padding: responsive.spacing(theme.spacing.m),
    },
    title: {
      ...theme.fonts.titleMedium,
      fontSize: responsive.fontSize(theme.fonts.titleMedium.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(4),
    },
    caption: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(2),
    },
    drawerSection: {
      marginTop: responsive.spacing(theme.spacing.s),
    },
    bottomDrawerSection: {
      marginBottom: responsive.spacing(theme.spacing.m),
      marginTop: 'auto',
      borderTopColor: theme.colors.outlineVariant,
      borderTopWidth: StyleSheet.hairlineWidth,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    preference: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
    },
    drawerItemLabel: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
    },
    drawerItemContainer: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      flexDirection: 'row',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xxs),
    },
    drawerItemIconContainer: {
      marginRight: responsive.spacing(theme.spacing.l),
      width: responsive.isTablet ? 20 : theme.spacing.l,
      alignItems: 'center',
    },
    divider: {
      marginVertical: responsive.spacing(theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m),
    },
    configSubheader: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
      color: theme.colors.onSurfaceVariant,
      paddingLeft: responsive.spacing(theme.spacing.l),
      paddingRight: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xxs),
    },
  });

export function WebDrawerContent({ onClose }: WebDrawerContentProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const logout = useAuthStore((state) => state.logout);
  const setThemePreference = useThemeStore((state) => state.setThemePreference);
  const user = useAuthStore((state) => state.user);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [showServerSettings, setShowServerSettings] = React.useState(false);

  // Efecto para cerrar con ESC
  React.useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [onClose]);

  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  const handleClearCache = async () => {
    try {
      await clearImageCache();
      showSnackbar({
        message: 'Caché de imágenes limpiado exitosamente',
        type: 'success',
      });
    } catch (error) {
      showSnackbar({
        message: 'Error al limpiar el caché',
        type: 'error',
      });
    }
  };

  return (
    <Surface style={styles.container} elevation={0}>
      <ScrollView
        contentContainerStyle={{ paddingTop: 0 }}
        showsVerticalScrollIndicator={false}
      >
        <View style={{ flex: 1 }}>
          <Surface style={styles.userInfoSection} elevation={0}>
            {user ? (
              <>
                <Text style={styles.title} numberOfLines={1}>
                  {`${user.firstName ?? ''} ${user.lastName ?? ''}`.trim() ||
                    user.username ||
                    'Usuario'}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  Rol: {getRoleTranslation(user.role?.id)}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  {user.email ?? ''}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  @{user.username ?? 'username'}
                </Text>
              </>
            ) : (
              <Text style={styles.title}>Invitado</Text>
            )}
          </Surface>
          <Divider style={styles.divider} />

          {/* Sección de Cocina */}
          {user?.role?.id === 5 && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>Cocina</Text>
              <TouchableRipple
                onPress={() => {
                  // No need to navigate for kitchen users
                  onClose();
                }}
                style={styles.drawerItemContainer}
                rippleColor={`${theme.colors.primary}20`}
              >
                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                  <View style={styles.drawerItemIconContainer}>
                    <Icon
                      source="chef-hat"
                      size={responsive.isTablet ? 20 : 24}
                      color={theme.colors.primary}
                    />
                  </View>
                  <Text
                    style={[
                      styles.drawerItemLabel,
                      { color: theme.colors.primary },
                    ]}
                  >
                    Pantalla de Preparación
                  </Text>
                </View>
              </TouchableRipple>
            </PaperDrawer.Section>
          )}
        </View>
      </ScrollView>

      <PaperDrawer.Section style={styles.bottomDrawerSection}>
        <TouchableRipple
          onPress={() => {
            const newPreference = theme.dark
              ? THEME_MODE.LIGHT
              : THEME_MODE.DARK;
            setThemePreference(newPreference);
          }}
          style={styles.preference}
        >
          <View
            style={{
              flexDirection: 'row',
              alignItems: 'center',
              justifyContent: 'space-between',
              width: '100%',
            }}
          >
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              <View style={styles.drawerItemIconContainer}>
                <Icon
                  source={theme.dark ? 'weather-night' : 'white-balance-sunny'}
                  size={responsive.isTablet ? 20 : 24}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
              <Text
                style={[
                  styles.drawerItemLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                Modo Oscuro
              </Text>
            </View>
            <View style={{ pointerEvents: 'none' }}>
              <Switch value={theme.dark} color={theme.colors.primary} />
            </View>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={handleClearCache}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="broom"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Limpiar Caché
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            setShowServerSettings(true);
            onClose();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="server-network"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Configuración del Servidor
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            logout();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.error}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="logout"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.error}
              />
            </View>
            <Text
              style={[styles.drawerItemLabel, { color: theme.colors.error }]}
            >
              Cerrar Sesión
            </Text>
          </View>
        </TouchableRipple>
      </PaperDrawer.Section>

      {/* Modal de configuración del servidor */}
      {showServerSettings && (
        <Portal>
          <Dialog
            visible={showServerSettings}
            onDismiss={() => setShowServerSettings(false)}
            style={{ maxWidth: 600, alignSelf: 'center' }}
          >
            <Dialog.Title>Configuración del Servidor</Dialog.Title>
            <Dialog.ScrollArea style={{ maxHeight: 400 }}>
              <Text style={{ marginBottom: 16 }}>
                Para configurar el servidor en la versión web, utiliza la
                aplicación móvil.
              </Text>
              <Text style={{ marginBottom: 8 }}>
                La configuración del servidor incluye:
              </Text>
              <Text style={{ marginLeft: 16 }}>
                • Modo de conexión (Auto/Manual)
              </Text>
              <Text style={{ marginLeft: 16 }}>• URL del servidor</Text>
              <Text style={{ marginLeft: 16 }}>• Prueba de conexión</Text>
            </Dialog.ScrollArea>
            <Dialog.Actions>
              <Button onPress={() => setShowServerSettings(false)}>
                Cerrar
              </Button>
            </Dialog.Actions>
          </Dialog>
        </Portal>
      )}
    </Surface>
  );
}

================
File: app/src/app/navigation/KitchenWebNavigator.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Text,
} from 'react-native';
import { Icon, Surface, Checkbox } from 'react-native-paper';
import { WebDrawer } from './components/WebDrawer';
import { WebDrawerContent } from './components/WebDrawerContent';
import KitchenNavigator from '../../modules/kitchen/navigation/KitchenNavigator';
import { useAppTheme } from '../styles/theme';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { RefreshButton } from '../../modules/kitchen/components/RefreshButton';
import { useAuthStore } from '../store/authStore';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderType } from '../../modules/kitchen/types/kitchen.types';
import { KitchenProvider } from '../../modules/kitchen/context/KitchenContext';

export function KitchenWebNavigator() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const screenName = user?.preparationScreen?.name || 'Pantalla de Preparación';
  const [drawerOpen, setDrawerOpen] = useState(false);

  // Obtener el texto del filtro activo
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderType.DINE_IN:
        return ' • Mesa';
      case OrderType.TAKE_AWAY:
        return ' • Llevar';
      case OrderType.DELIVERY:
        return ' • Domicilio';
      default:
        return '';
    }
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.primary,
      height: responsive.isWeb ? 80 : responsive.dimensions.headerHeight,
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: responsive.spacing.m,
      elevation: 2,
    },
    drawerButtonContainer: {
      width: 56,
      height: 56,
      justifyContent: 'center',
      alignItems: 'center',
      marginLeft: 0,
      borderRadius: 28,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    headerTitle: {
      ...theme.fonts.titleLarge,
      color: theme.colors.onPrimary,
      fontWeight: 'bold',
      fontSize: responsive.isWeb ? 26 : 22,
    },
    filterIndicator: {
      ...theme.fonts.titleMedium,
      fontWeight: '500',
      opacity: 0.9,
      color: theme.colors.onPrimary,
    },
    content: {
      flex: 1,
    },
  });

  return (
    <KitchenProvider>
      <View style={styles.container}>
        <StatusBar
          backgroundColor={theme.colors.primary}
          barStyle={theme.dark ? 'light-content' : 'dark-content'}
        />

        <WebDrawer
          open={drawerOpen}
          onClose={() => setDrawerOpen(false)}
          drawerWidth={
            responsive.isWeb ? 320 : responsive.dimensions.drawerWidth
          }
          drawerContent={
            <WebDrawerContent onClose={() => setDrawerOpen(false)} />
          }
        >
          <View style={styles.container}>
            {/* Header */}
            <View style={styles.header}>
              <TouchableOpacity
                style={styles.drawerButtonContainer}
                onPress={() => setDrawerOpen(true)}
                hitSlop={{ top: 30, bottom: 30, left: 30, right: 30 }}
              >
                <Icon
                  source="menu"
                  size={responsive.isWeb ? 36 : 32}
                  color={theme.colors.onPrimary}
                />
              </TouchableOpacity>

              <View style={styles.headerContent}>
                <Surface
                  elevation={0}
                  style={{
                    backgroundColor: 'transparent',
                  }}
                >
                  <View style={styles.titleContainer}>
                    <Text style={styles.headerTitle}>{screenName}</Text>
                    {filters.orderType && (
                      <Text style={styles.filterIndicator}>
                        {getFilterText()}
                      </Text>
                    )}
                  </View>
                </Surface>

                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                  {/* Checkbox para mostrar/ocultar ordenes listas */}
                  <TouchableOpacity
                    style={{
                      flexDirection: 'row',
                      alignItems: 'center',
                      paddingHorizontal: 12,
                      paddingVertical: 8,
                      marginRight: 8,
                      backgroundColor: filters.showPrepared
                        ? 'rgba(255,255,255,0.2)'
                        : 'transparent',
                      borderRadius: 20,
                    }}
                    onPress={() =>
                      setFilters({
                        ...filters,
                        showPrepared: !filters.showPrepared,
                      })
                    }
                  >
                    <Checkbox
                      status={filters.showPrepared ? 'checked' : 'unchecked'}
                      onPress={() =>
                        setFilters({
                          ...filters,
                          showPrepared: !filters.showPrepared,
                        })
                      }
                      color={theme.colors.onPrimary}
                      uncheckedColor={theme.colors.onPrimary}
                    />
                    <Text
                      style={{
                        color: theme.colors.onPrimary,
                        fontSize: responsive.isWeb ? 16 : 14,
                        marginLeft: 4,
                        fontWeight: filters.showPrepared ? 'bold' : 'normal',
                      }}
                    >
                      Mostrar Listas
                    </Text>
                  </TouchableOpacity>
                  <KitchenFilterButton />
                  <RefreshButton />
                  <ConnectionIndicator />
                </View>
              </View>
            </View>

            {/* Content */}
            <View style={styles.content}>
              <KitchenNavigator />
            </View>
          </View>
        </WebDrawer>
      </View>
    </KitchenProvider>
  );
}

================
File: app/src/app/schemas/domain/table.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto Table completo.
 * Fuente de verdad centralizada.
 */
export const tableSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  areaId: z.string().uuid(),
  capacity: z.number().int().nullable().optional(),
  isActive: z.boolean(),
  isAvailable: z.boolean(), // Incluido desde el schema original
  isTemporary: z.boolean(), // Incluido desde el schema original
  temporaryIdentifier: z.string().nullable().optional(), // Incluido desde el schema original
  area: z
    .object({
      id: z.string().uuid(),
      name: z.string(),
    })
    .optional(), // El área puede venir incluida opcionalmente
  createdAt: z.union([z.string().datetime(), z.date()]).optional(), // Permitir string o Date
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(), // Permitir string o Date
});

// Tipo TypeScript inferido y exportado centralmente
export type Table = z.infer<typeof tableSchema>;

================
File: app/src/app/services/apiClientWrapper.ts
================
import {
  getApiClient,
  reinitializeApiClient,
  getAxiosInstance,
} from './apiClient';
import { ApiResponse } from 'apisauce';
import { AxiosResponse } from 'axios';

/**
 * Wrapper que maneja la inicialización asíncrona del cliente API
 * Todos los servicios deben usar este wrapper en lugar de importar apiClient directamente
 */
export class ApiClientWrapper {
  private static async request<T>(
    method: 'get' | 'post' | 'put' | 'patch' | 'delete',
    url: string,
    dataOrParams?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    try {
      const axios = await getAxiosInstance();

      const requestConfig =
        method === 'get' || method === 'delete'
          ? { params: dataOrParams, ...config }
          : config;

      const response: AxiosResponse<T> = await axios[method](
        url,
        method === 'get' || method === 'delete' ? requestConfig : dataOrParams,
        method === 'get' || method === 'delete' ? undefined : requestConfig,
      );

      return {
        ok: true,
        problem: null,
        data: response.data,
        status: response.status,
        headers: response.headers,
        config: response.config,
        duration: 0,
      } as ApiResponse<T>;
    } catch (error: any) {
      return {
        ok: false,
        problem:
          error.response?.status === 401 ? 'CLIENT_ERROR' : 'NETWORK_ERROR',
        data: error.response?.data,
        status: error.response?.status,
        headers: error.response?.headers,
        config: error.config,
        duration: 0,
      } as ApiResponse<T>;
    }
  }

  static async get<T>(url: string, params?: any): Promise<ApiResponse<T>> {
    return this.request<T>('get', url, params);
  }

  static async post<T>(
    url: string,
    data?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    return this.request<T>('post', url, data, config);
  }

  static async put<T>(
    url: string,
    data?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    return this.request<T>('put', url, data, config);
  }

  static async patch<T>(
    url: string,
    data?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    return this.request<T>('patch', url, data, config);
  }

  static async delete<T>(
    url: string,
    params?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    return this.request<T>('delete', url, params, config);
  }

  static async reinitialize(): Promise<void> {
    await reinitializeApiClient();
  }
}

// Exportar también como default para compatibilidad
export default ApiClientWrapper;

================
File: app/src/app/services/certificateValidator.ts
================
import { Platform } from 'react-native';

/**
 * Servicio para validación de certificados SSL
 * En producción, valida que las conexiones HTTPS usen certificados válidos
 */
export class CertificateValidator {
  private static instance: CertificateValidator;
  private isProduction: boolean;

  private constructor() {
    // Determinar si estamos en producción basándonos en __DEV__
    this.isProduction = !__DEV__;
  }

  static getInstance(): CertificateValidator {
    if (!CertificateValidator.instance) {
      CertificateValidator.instance = new CertificateValidator();
    }
    return CertificateValidator.instance;
  }

  /**
   * Valida si una URL es segura para conectarse
   * @param url URL a validar
   * @returns true si la URL es segura o estamos en desarrollo
   */
  isSecureUrl(url: string): boolean {
    // En desarrollo, permitir cualquier URL
    if (!this.isProduction) {
      return true;
    }

    try {
      const urlObj = new URL(url);

      // En producción, solo permitir HTTPS para dominios externos
      if (this.isExternalDomain(urlObj.hostname)) {
        return urlObj.protocol === 'https:';
      }

      // Para IPs locales, permitir HTTP (necesario para discovery)
      return this.isLocalNetwork(urlObj.hostname);
    } catch {
      return false;
    }
  }

  /**
   * Determina si un hostname es una red local
   */
  private isLocalNetwork(hostname: string): boolean {
    // Localhost
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return true;
    }

    // Redes privadas IPv4 (RFC 1918)
    const parts = hostname.split('.');
    if (parts.length === 4) {
      const firstOctet = parseInt(parts[0]);
      const secondOctet = parseInt(parts[1]);

      // 10.0.0.0/8
      if (firstOctet === 10) return true;

      // 172.16.0.0/12
      if (firstOctet === 172 && secondOctet >= 16 && secondOctet <= 31)
        return true;

      // 192.168.0.0/16
      if (firstOctet === 192 && secondOctet === 168) return true;
    }

    return false;
  }

  /**
   * Determina si un hostname es un dominio externo
   */
  private isExternalDomain(hostname: string): boolean {
    // Si no es IP local y no es localhost, es externo
    return (
      !this.isLocalNetwork(hostname) &&
      !hostname.includes('.local') &&
      !hostname.includes('.internal')
    );
  }

  /**
   * Obtiene configuración de seguridad para axios
   */
  getAxiosSecurityConfig() {
    if (Platform.OS === 'android' && this.isProduction) {
      return {
        // En producción, validar certificados
        httpsAgent: {
          rejectUnauthorized: true,
        },
      };
    }

    return {};
  }

  /**
   * Valida si se debe permitir una conexión
   * @throws Error si la conexión no es segura en producción
   */
  validateConnection(url: string): void {
    if (!this.isSecureUrl(url)) {
      throw new Error(
        `Conexión insegura bloqueada: ${url}. ` +
          'En producción solo se permiten conexiones HTTPS a dominios externos.',
      );
    }
  }
}

export const certificateValidator = CertificateValidator.getInstance();

================
File: app/src/app/store/themeStore.ts
================
import React from 'react';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useColorScheme, Appearance } from 'react-native';

import {
  ThemePreference,
  THEME_PREFERENCE_STORAGE_KEY,
  THEME_MODE,
} from '../types/theme.types';
import { lightTheme, darkTheme } from '../styles/theme';

interface ThemeState {
  themePreference: ThemePreference;
  activeTheme: typeof lightTheme | typeof darkTheme;
  isSystemDarkMode: boolean | null;
  setThemePreference: (preference: ThemePreference) => void;
  setSystemDarkMode: (isDark: boolean | null) => void;
}

export const useThemeStore = create<ThemeState>()(
  persist(
    (set, get) => ({
      themePreference: THEME_MODE.SYSTEM,
      activeTheme: lightTheme,
      isSystemDarkMode: null,

      setThemePreference: (preference: ThemePreference) => {
        const { isSystemDarkMode } = get();
        set({ themePreference: preference });

        if (preference === THEME_MODE.SYSTEM) {
          if (isSystemDarkMode !== null) {
            set({ activeTheme: isSystemDarkMode ? darkTheme : lightTheme });
          }
        } else {
          set({
            activeTheme:
              preference === THEME_MODE.DARK ? darkTheme : lightTheme,
          });
        }
      },

      setSystemDarkMode: (isDark: boolean | null) => {
        const { themePreference } = get();
        set({ isSystemDarkMode: isDark });

        if (themePreference === THEME_MODE.SYSTEM && isDark !== null) {
          set({ activeTheme: isDark ? darkTheme : lightTheme });
        }
      },
    }),

    {
      name: THEME_PREFERENCE_STORAGE_KEY,
      storage: createJSONStorage(() => EncryptedStorage),
      partialize: (state) => ({ themePreference: state.themePreference }),
      onRehydrateStorage: () => {
        return (state, error) => {
          if (error) {
            // Error rehydrating theme store
            return;
          }
          if (!state) {
            // State not available during theme rehydration callback
            return;
          }

          const preference = state.themePreference;

          if (preference === THEME_MODE.LIGHT) {
            state.activeTheme = lightTheme;
            state.isSystemDarkMode = Appearance.getColorScheme() === 'dark';
          } else if (preference === THEME_MODE.DARK) {
            state.activeTheme = darkTheme;
            state.isSystemDarkMode = Appearance.getColorScheme() === 'dark';
          } else {
            const systemScheme = Appearance.getColorScheme();
            const isSystemDark = systemScheme === 'dark';
            state.isSystemDarkMode = isSystemDark;
            state.activeTheme = isSystemDark ? darkTheme : lightTheme;
          }
        };
      },
    },
  ),
);

export function useSystemThemeDetector() {
  const systemColorScheme = useColorScheme();
  const setSystemDarkMode = useThemeStore((state) => state.setSystemDarkMode);

  React.useEffect(() => {
    const isDarkMode = systemColorScheme === 'dark';
    if (useThemeStore.getState().isSystemDarkMode !== isDarkMode) {
      setSystemDarkMode(isDarkMode);
    }
  }, [systemColorScheme, setSystemDarkMode]);
}

================
File: app/src/app/utils/orderFormatters.ts
================
import type {
  OrderStatus,
  OrderType,
  Order,
} from '@/modules/orders/types/orders.types';
import {
  OrderStatusEnum,
  OrderTypeEnum,
} from '@/modules/orders/types/orders.types';
import type { OrderOpenList } from '@/modules/orders/types/orders.types';
import type { OrderForFinalizationList } from '@/modules/orderFinalization/types/orderFinalization.types';

/**
 * Formatea el tipo de orden con emojis y texto completo
 * @param type - Tipo de orden
 * @returns String formateado con emoji y texto
 */
export const formatOrderType = (type: OrderType): string => {
  switch (type) {
    case OrderTypeEnum.DINE_IN:
      return '🍽️ Para Comer Aquí';
    case OrderTypeEnum.TAKE_AWAY:
      return '🥡 Para Llevar';
    case OrderTypeEnum.DELIVERY:
      return '🚚 Domicilio';
    default:
      return type;
  }
};

/**
 * Formatea el tipo de orden con versión corta
 * @param type - Tipo de orden
 * @returns String formateado con emoji y texto corto
 */
export const formatOrderTypeShort = (type: OrderType | string): string => {
  switch (type) {
    case OrderTypeEnum.DINE_IN:
    case 'DINE_IN':
      return '🍽️ Local';
    case OrderTypeEnum.TAKE_AWAY:
    case 'TAKE_AWAY':
    case 'TAKEOUT': // Para compatibilidad
      return '🥡 Llevar';
    case OrderTypeEnum.DELIVERY:
    case 'DELIVERY':
      return '🚚 Envío';
    default:
      return type;
  }
};

/**
 * Formatea el estado de la orden
 * @param status - Estado de la orden
 * @returns String formateado en español
 */
export const formatOrderStatus = (status: OrderStatus | string): string => {
  switch (status) {
    case OrderStatusEnum.PENDING:
    case 'PENDING':
      return 'Pendiente';
    case OrderStatusEnum.IN_PROGRESS:
    case 'IN_PROGRESS':
      return 'En Progreso';
    case OrderStatusEnum.IN_PREPARATION:
    case 'IN_PREPARATION':
      return 'En Preparación';
    case OrderStatusEnum.READY:
    case 'READY':
      return 'Lista';
    case OrderStatusEnum.DELIVERED:
    case 'DELIVERED':
      return 'Entregada';
    case OrderStatusEnum.COMPLETED:
    case 'COMPLETED':
      return 'Completada';
    case OrderStatusEnum.CANCELLED:
    case 'CANCELLED':
      return 'Cancelada';
    default:
      return status;
  }
};

/**
 * Formatea el estado de la orden (versión alternativa para compatibilidad)
 * Esta versión usa textos ligeramente diferentes
 * @param status - Estado de la orden
 * @returns String formateado en español
 */
export const formatOrderStatusAlt = (status: string): string => {
  switch (status) {
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En preparación';
    case 'READY':
      return 'Listo';
    case 'DELIVERED':
      return 'Entregado';
    default:
      return status;
  }
};

/**
 * Obtiene el color para el estado de la orden
 * @param status - Estado de la orden
 * @param theme - Tema de la aplicación (opcional, para algunos colores)
 * @returns Color hex o referencia al tema
 */
export const getStatusColor = (
  status: OrderStatus | string,
  theme?: any,
): string => {
  switch (status) {
    case OrderStatusEnum.PENDING:
    case 'PENDING':
      return '#FFA000'; // Orange
    case OrderStatusEnum.IN_PROGRESS:
    case 'IN_PROGRESS':
      return theme?.colors?.primary || '#6200EE';
    case OrderStatusEnum.READY:
    case 'READY':
      return '#4CAF50'; // Green
    case OrderStatusEnum.DELIVERED:
    case 'DELIVERED':
      return theme?.colors?.tertiary || '#9C27B0'; // Purple
    default:
      return theme?.colors?.onSurfaceVariant || '#757575';
  }
};

/**
 * Determina el estado de pago de una orden
 * @param order - Orden completa o de lista
 * @returns Estado del pago: 'unpaid' | 'partial' | 'paid'
 */
export const getPaymentStatus = (
  order: Order | OrderOpenList | OrderForFinalizationList,
): 'unpaid' | 'partial' | 'paid' => {
  // Verificar que order existe
  if (!order) {
    return 'unpaid';
  }

  // Si es OrderOpenList o OrderForFinalizationList, usar paymentsSummary
  if ('paymentsSummary' in order) {
    const totalPaid = order.paymentsSummary?.totalPaid || 0;
    const orderTotal =
      typeof order.total === 'string'
        ? parseFloat(order.total)
        : order.total || 0;

    if (totalPaid >= orderTotal) {
      return 'paid';
    } else if (totalPaid > 0) {
      return 'partial';
    } else {
      return 'unpaid';
    }
  }

  // Si es Order completa, usar payments
  if (!order.payments || order.payments.length === 0) {
    return 'unpaid';
  }

  // Sumar todos los pagos completados
  const totalPaid = order.payments
    .filter((payment: any) => payment.paymentStatus === 'COMPLETED')
    .reduce((sum: number, payment: any) => sum + (payment.amount || 0), 0);

  const orderTotal =
    typeof order.total === 'string'
      ? parseFloat(order.total)
      : order.total || 0;

  if (totalPaid === 0) {
    return 'unpaid';
  } else if (totalPaid >= orderTotal) {
    return 'paid';
  } else {
    return 'partial';
  }
};

/**
 * Obtiene el color para el estado de pago
 * @param paymentStatus - Estado del pago
 * @returns Color hex
 */
export const getPaymentStatusColor = (
  paymentStatus: 'unpaid' | 'partial' | 'paid',
): string => {
  switch (paymentStatus) {
    case 'paid':
      return '#10B981'; // Green
    case 'partial':
      return '#F59E0B'; // Amber
    case 'unpaid':
      return '#EF4444'; // Red
    default:
      return '#757575'; // Gray
  }
};

/**
 * Formatea el texto del estado de pago
 * @param paymentStatus - Estado del pago
 * @returns Texto formateado con emoji
 */
export const formatPaymentStatus = (
  paymentStatus: 'unpaid' | 'partial' | 'paid',
): string => {
  switch (paymentStatus) {
    case 'paid':
      return '💵 Pagado';
    case 'partial':
      return '💵 Parcial';
    case 'unpaid':
      return '💵 Pendiente';
    default:
      return '💵 Desconocido';
  }
};

================
File: app/src/app/utils/shadowStyles.ts
================
import { Platform, ViewStyle } from 'react-native';

interface ShadowOptions {
  shadowColor?: string;
  shadowOffset?: { width: number; height: number };
  shadowOpacity?: number;
  shadowRadius?: number;
  elevation?: number;
}

/**
 * Genera estilos de sombra compatibles con web y móvil
 * @param options Opciones de sombra para React Native
 * @returns Estilos de sombra apropiados para la plataforma
 */
export function createShadowStyle(options: ShadowOptions): ViewStyle {
  const {
    shadowColor = '#000',
    shadowOffset = { width: 0, height: 2 },
    shadowOpacity = 0.25,
    shadowRadius = 3.84,
    elevation = 5,
  } = options;

  if (Platform.OS === 'web') {
    // Convertir valores de React Native a CSS box-shadow
    const offsetX = shadowOffset.width;
    const offsetY = shadowOffset.height;
    const blur = shadowRadius;

    // Convertir color hex a rgba con opacidad
    const color =
      shadowColor === '#000' || shadowColor === '#000000'
        ? `rgba(0, 0, 0, ${shadowOpacity})`
        : shadowColor.includes('rgba')
          ? shadowColor
          : `${shadowColor}${Math.round(shadowOpacity * 255)
              .toString(16)
              .padStart(2, '0')}`;

    return {
      boxShadow: `${offsetX}px ${offsetY}px ${blur}px ${color}`,
    } as any;
  }

  // Para móvil, devolver las propiedades nativas
  return {
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius,
    elevation,
  };
}

/**
 * Estilos de sombra predefinidos
 */
export const shadowPresets = {
  small: createShadowStyle({
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.18,
    shadowRadius: 1.0,
    elevation: 1,
  }),

  medium: createShadowStyle({
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  }),

  large: createShadowStyle({
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 4.65,
    elevation: 8,
  }),

  none: Platform.select({
    web: { boxShadow: 'none' },
    default: {
      shadowColor: 'transparent',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0,
      shadowRadius: 0,
      elevation: 0,
    },
  }) as ViewStyle,
};

================
File: app/src/app/utils/tokenVerification.ts
================
import { authService } from '@/modules/auth/services/authService';
import { useAuthStore } from '@/app/store/authStore';
import EncryptedStorage from '@/app/services/secureStorageService';

const AUTH_TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';
const USER_INFO_KEY = 'user_info';

/**
 * Verifica si el token almacenado es válido con el backend
 * Esta función está separada para evitar ciclos de dependencias
 */
export async function verifyStoredToken(): Promise<boolean> {
  try {
    const { accessToken } = useAuthStore.getState();

    if (!accessToken) {
      return false;
    }

    const isTokenValid = await authService.verifyToken();

    if (!isTokenValid) {
      // Si el token no es válido, limpiamos todo
      await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
      await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
      await EncryptedStorage.removeItem(USER_INFO_KEY);

      useAuthStore.setState({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });

      return false;
    }

    return true;
  } catch (error) {
    console.error('Error verificando token:', error);
    return false;
  }
}

================
File: app/src/hooks/useAudioRecorder.ts
================
import { useState, useCallback, useRef, useEffect } from 'react';
import {
  useAudioRecorder as useExpoAudioRecorder,
  AudioModule,
  RecordingPresets,
} from 'expo-audio';
import {
  ExpoSpeechRecognitionModule,
  useSpeechRecognitionEvent,
} from 'expo-speech-recognition';

interface UseAudioRecorderReturn {
  isRecording: boolean;
  isPreparing: boolean;
  isProcessing: boolean;
  audioUri: string | null;
  transcription: string | null;
  startRecording: () => Promise<void>;
  stopRecording: () => Promise<void>;
  resetRecording: () => void;
  error: string | null;
}

export const useAudioRecorder = (): UseAudioRecorderReturn => {
  const [isRecording, setIsRecording] = useState(false);
  const [isPreparing, setIsPreparing] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [audioUri, setAudioUri] = useState<string | null>(null);
  const [transcription, setTranscription] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  // Usar el hook de expo-audio con configuración de alta calidad para voz
  const audioRecorder = useExpoAudioRecorder({
    ...RecordingPresets.HIGH_QUALITY,
    android: {
      ...RecordingPresets.HIGH_QUALITY.android,
      extension: '.mp4',
      outputFormat: 'mpeg4',
      audioEncoder: 'aac',
      sampleRate: 16000, // Optimizado para reconocimiento de voz
      numberOfChannels: 1,
      bitRate: 64000,
    },
    ios: {
      ...RecordingPresets.HIGH_QUALITY.ios,
      extension: '.m4a',
      sampleRate: 16000,
      numberOfChannels: 1,
      bitRate: 64000,
    },
  });

  const [currentTranscription, setCurrentTranscription] = useState<string>('');
  const currentTranscriptionRef = useRef<string>('');
  const isTranscribing = useRef(false);
  const isMounted = useRef(true);

  // Verificar que el audio recorder esté listo
  useEffect(() => {
    if (audioRecorder && typeof audioRecorder.record === 'function') {
      setIsInitialized(true);
    }
  }, [audioRecorder]);

  // Estado interno para rastrear si estamos en proceso de detener
  const isStopping = useRef(false);

  // Eventos de reconocimiento de voz
  useSpeechRecognitionEvent('result', (event) => {
    if (!isMounted.current) return;

    const results = event.results;
    if (results && results.length > 0) {
      const bestResult = results[0];
      if (bestResult && bestResult.transcript) {
        const newTranscript = bestResult.transcript;
        currentTranscriptionRef.current = newTranscript;
        setCurrentTranscription(newTranscript);

        if (event.isFinal || bestResult.isFinal) {
          setTranscription(newTranscript);
        }
      }
    }
  });

  useSpeechRecognitionEvent('end', () => {
    if (!isMounted.current) return;
    isTranscribing.current = false;
  });

  const startRecording = useCallback(async () => {
    if (!isMounted.current) return;
    if (!isInitialized || !audioRecorder) {
      setError('El grabador de audio no está listo');
      return;
    }

    try {
      setError(null);
      setIsPreparing(true);
      setCurrentTranscription('');
      currentTranscriptionRef.current = '';
      setTranscription('');

      // Solicitar permisos de audio
      const audioPermission =
        await AudioModule.requestRecordingPermissionsAsync();
      if (!audioPermission.granted) {
        throw new Error('Se requiere permiso para grabar audio');
      }

      // Solicitar permisos de reconocimiento de voz
      const speechPermissions =
        await ExpoSpeechRecognitionModule.requestPermissionsAsync();
      if (!speechPermissions.granted) {
        throw new Error('Se requiere permiso para reconocimiento de voz');
      }

      // Iniciar reconocimiento de voz ANTES de la grabación
      isTranscribing.current = true;
      setCurrentTranscription('');

      try {
        await ExpoSpeechRecognitionModule.start({
          lang: 'es-MX',
          interimResults: true,
          continuous: true,
          maxAlternatives: 1,
        });
      } catch (speechError) {
        // Continuar sin reconocimiento si falla
      }

      // Esperar un momento para que se establezca el reconocimiento
      await new Promise((resolve) => setTimeout(resolve, 300));

      // Preparar y comenzar la grabación de audio
      await audioRecorder.prepareToRecordAsync();
      await audioRecorder.record();

      if (isMounted.current) {
        setIsRecording(true);
        setIsPreparing(false);
      }
    } catch (err) {
      if (isMounted.current) {
        setIsPreparing(false);
        const errorMessage =
          err instanceof Error ? err.message : 'Error al iniciar grabación';
        setError(errorMessage);
      }
    }
  }, [audioRecorder, isInitialized]);

  const stopRecording = useCallback(async () => {
    if (!isMounted.current) return;

    // Prevenir múltiples llamadas simultáneas
    if (isStopping.current) {
      return;
    }

    try {
      // Verificar si realmente está grabando
      const isCurrentlyRecording = audioRecorder.isRecording;
      if (!isCurrentlyRecording) {
        return;
      }

      isStopping.current = true;

      setIsProcessing(true);
      setIsRecording(false);

      // Primero detener el reconocimiento de voz
      if (isTranscribing.current) {
        try {
          await ExpoSpeechRecognitionModule.stop();
          // Esperar un momento para asegurar que se capture la transcripción final
          await new Promise((resolve) => setTimeout(resolve, 500));
        } catch (error) {
          // Error al detener reconocimiento de voz
        } finally {
          isTranscribing.current = false;
        }
      }

      // Detener grabación de audio
      let uri: string | undefined;
      try {
        await audioRecorder.stop();
        uri = audioRecorder.uri;
      } catch (audioError) {
        // Si el error es "stop failed", intentar obtener el URI de todas formas
        if (audioError?.message?.includes('stop failed')) {
          uri = audioRecorder.uri;
        } else {
          throw audioError;
        }
      }

      if (!uri) {
        throw new Error('No se pudo obtener el archivo de audio');
      }

      if (isMounted.current) {
        // Usar la transcripción que se capturó durante la grabación
        const finalTranscription =
          currentTranscriptionRef.current ||
          currentTranscription ||
          transcription ||
          '';

        if (finalTranscription) {
          setTranscription(finalTranscription);
        } else {
          setTranscription('');
        }

        // Establecer el URI del audio al final
        setAudioUri(uri);
        setIsProcessing(false);
      }
    } catch (err) {
      if (isMounted.current) {
        setIsProcessing(false);
        const errorMessage =
          err instanceof Error ? err.message : 'Error al detener grabación';
        setError(errorMessage);
      }
    } finally {
      isStopping.current = false;
    }
  }, [audioRecorder, currentTranscription, transcription]);

  const resetRecording = useCallback(() => {
    if (!isMounted.current) return;

    // Detener reconocimiento si está activo
    if (isTranscribing.current) {
      try {
        const stopPromise = ExpoSpeechRecognitionModule.stop();
        if (stopPromise && typeof stopPromise.catch === 'function') {
          stopPromise.catch((_err) => {});
        }
      } catch (_err) {}
      isTranscribing.current = false;
    }

    // Detener grabación si está activa
    if (audioRecorder && audioRecorder.isRecording) {
      try {
        const stopPromise = audioRecorder.stop();
        if (stopPromise && typeof stopPromise.catch === 'function') {
          stopPromise.catch((_err) => {
            // Ignorar el error "stop failed" ya que es esperado cuando se resetea rápidamente
          });
        }
      } catch (err) {
        // Ignorar el error "stop failed"
      }
    }

    // Limpiar estados
    setAudioUri(null);
    setTranscription(null);
    setCurrentTranscription('');
    currentTranscriptionRef.current = '';
    setError(null);
    setIsRecording(false);
    setIsProcessing(false);
    setIsPreparing(false);
    isStopping.current = false;
  }, [audioRecorder]);

  // Limpiar al desmontar
  useEffect(() => {
    isMounted.current = true;

    return () => {
      isMounted.current = false;

      // Limpiar el reconocimiento de voz
      if (isTranscribing.current) {
        isTranscribing.current = false;
        try {
          const stopPromise = ExpoSpeechRecognitionModule.stop();
          if (stopPromise && typeof stopPromise.catch === 'function') {
            stopPromise.catch(() => {});
          }
        } catch (err) {
          // Ignorar errores en cleanup
        }
      }

      // No intentar detener el audio recorder aquí porque puede causar el error
      // El hook de expo-audio maneja su propia limpieza
    };
  }, []);

  return {
    isRecording,
    isPreparing,
    isProcessing,
    audioUri,
    transcription,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  };
};

================
File: app/src/hooks/useGoogleMapsConfig.ts
================
import { useState, useEffect } from 'react';
import { appConfigService } from '@/services/appConfig';
import { GOOGLE_MAPS_CONFIG } from '@/modules/customers/constants/maps.config';

export interface GoogleMapsConfigWithApiKey {
  apiKey: string;
  defaultCenter: {
    lat: number;
    lng: number;
  };
  defaultZoom: number;
  locationZoom: number;
  mapOptions: {
    disableDefaultUI: boolean;
    zoomControl: boolean;
    mapTypeControl: boolean;
    scaleControl: boolean;
    streetViewControl: boolean;
    rotateControl: boolean;
    fullscreenControl: boolean;
    clickableIcons: boolean;
  };
}

export function useGoogleMapsConfig() {
  const [config, setConfig] = useState<GoogleMapsConfigWithApiKey | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function loadConfig() {
      try {
        const apiKey = await appConfigService.getMapsApiKey();
        setConfig({
          ...GOOGLE_MAPS_CONFIG,
          apiKey,
        });
      } catch (err) {
        setError('No se pudo cargar la configuración de mapas');
      } finally {
        setLoading(false);
      }
    }

    loadConfig();
  }, []);

  return { config, loading, error };
}

================
File: app/src/modules/areasTables/services/tableService.ts
================
import { useQuery } from '@tanstack/react-query';
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { BackendErrorResponse } from '../../../app/types/api.types';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  FindAllTablesDto,
} from '../schema/table.schema';

export const getTables = async (
  filterOptions: FindAllTablesDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 10 },
): Promise<Table[]> => {
  const response = await ApiClientWrapper.get<{
    items: Table[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.TABLES, {
    ...filterOptions,
    page: paginationOptions.page,
    limit: paginationOptions.limit,
  });

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data.items;
};

export const getTablesByAreaId = async (areaId: string): Promise<Table[]> => {
  const response = await ApiClientWrapper.get<{
    items: Table[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.TABLES_BY_AREA.replace(':areaId', areaId));

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data.items;
};

export const getTableById = async (id: string): Promise<Table> => {
  const response = await ApiClientWrapper.get<Table>(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const createTable = async (data: CreateTableDto): Promise<Table> => {
  const response = await ApiClientWrapper.post<Table>(API_PATHS.TABLES, data);

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const updateTable = async (
  id: string,
  data: UpdateTableDto,
): Promise<Table> => {
  const response = await ApiClientWrapper.patch<Table>(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const deleteTable = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
};

// Claves de Query para tablas relacionadas con áreas
const tableQueryKeys = {
  base: ['tables'] as const, // Clave base para todas las tablas
  byArea: (areaId: string | null | undefined) =>
    [...tableQueryKeys.base, 'area', areaId] as const,
};

export function useGetTablesByArea(areaId: string | null | undefined) {
  return useQuery<Table[], ApiError>({
    queryKey: tableQueryKeys.byArea(areaId),
    queryFn: () => {
      if (!areaId) {
        return Promise.resolve([]);
      }
      return getTablesByAreaId(areaId);
    },
    enabled: !!areaId,
    // Sin staleTime, se usará la configuración global (0)
  });
}

================
File: app/src/modules/auth/services/authService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import {
  handleApiResponse,
  handleApiResponseVoid,
} from '../../../app/lib/apiHelpers';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  AuthEmailLoginDto,
  LoginResponseDto,
  LoginFormInputs,
  RegisterFormInputs,
} from '../schema/auth.schema';

class AuthService {
  async login(loginData: LoginFormInputs): Promise<LoginResponseDto> {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const isEmail = emailRegex.test(loginData.emailOrUsername);
    const sanitizedInput = loginData.emailOrUsername.trim().toLowerCase();

    const payload: AuthEmailLoginDto = {
      password: loginData.password,
      ...(isEmail ? { email: sanitizedInput } : { username: sanitizedInput }),
    };

    const response = await ApiClientWrapper.post<LoginResponseDto>(
      API_PATHS.AUTH_EMAIL_LOGIN,
      payload,
    );

    return handleApiResponse(response);
  }

  async register(data: RegisterFormInputs): Promise<void> {
    const response = await ApiClientWrapper.post<{ message?: string }>(
      API_PATHS.AUTH_EMAIL_REGISTER,
      data,
    );

    handleApiResponseVoid(response);
  }

  async verifyToken(): Promise<boolean> {
    try {
      const response = await ApiClientWrapper.get(API_PATHS.AUTH_ME);
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }
}

export const authService = new AuthService();

================
File: app/src/modules/availability/components/ModifierGroupAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch } from 'react-native-paper';
import { ModifierGroupAvailability } from '../types/availability.types';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';

interface ModifierGroupAvailabilityItemProps {
  modifierGroup: ModifierGroupAvailability;
  onRefresh?: () => void;
}

export const ModifierGroupAvailabilityItem: React.FC<
  ModifierGroupAvailabilityItemProps
> = ({ modifierGroup, onRefresh: _onRefresh }) => {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();

  const handleGroupToggle = (value: boolean) => {
    updateAvailability.mutate({
      type: 'modifierGroup',
      id: modifierGroup.id,
      isActive: value,
      cascade: true,
    });
  };

  const handleModifierToggle = (modifierId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'modifier',
      id: modifierId,
      isActive: value,
    });
  };

  const totalModifiers = modifierGroup.modifiers.length;
  const activeModifiers = modifierGroup.modifiers.filter(
    (m) => m.isActive,
  ).length;

  return (
    <AvailabilityListItem
      title={modifierGroup.name}
      subtitle={`${activeModifiers}/${totalModifiers} modificadores activos`}
      icon="tune-variant"
      isActive={modifierGroup.isActive}
      onToggle={handleGroupToggle}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      <View style={styles.modifiersContainer}>
        {modifierGroup.modifiers.map((modifier) => (
          <View
            key={modifier.id}
            style={[
              styles.modifierItem,
              { opacity: !modifier.isActive ? 0.5 : 1 },
            ]}
          >
            <Text
              style={[
                styles.modifierTitle,
                !modifier.isActive && styles.strikethrough,
                { color: theme.colors.onSurface },
              ]}
            >
              {modifier.name}
            </Text>
            <Switch
              value={modifier.isActive}
              onValueChange={(value) =>
                handleModifierToggle(modifier.id, value)
              }
              disabled={!modifierGroup.isActive}
            />
          </View>
        ))}
      </View>
    </AvailabilityListItem>
  );
};

const styles = StyleSheet.create({
  modifiersContainer: {
    paddingLeft: 16,
  },
  modifierItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  modifierTitle: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
});

================
File: app/src/modules/customers/constants/maps.config.ts
================
// Configuración para Google Maps
export const GOOGLE_MAPS_CONFIG = {
  
  // Centro por defecto para México
  defaultCenter: {
    lat: 23.6345,
    lng: -102.5528,
  },
  
  // Configuración de zoom
  defaultZoom: 5,
  locationZoom: 16,
  
  // Opciones del mapa
  mapOptions: {
    disableDefaultUI: false,
    zoomControl: true,
    mapTypeControl: false,
    scaleControl: false,
    streetViewControl: false,
    rotateControl: false,
    fullscreenControl: false,
    clickableIcons: false,
  },
};

================
File: app/src/modules/customers/hooks/useCustomersQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { customersService } from '../services/customersService';
import {
  CreateCustomerDto,
  UpdateCustomerDto,
  FindAllCustomersQuery,
  ChatMessage,
  Address,
} from '../types/customer.types';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

// Keys para React Query
export const customerKeys = {
  all: ['customers'] as const,
  lists: () => [...customerKeys.all, 'list'] as const,
  list: (filters?: FindAllCustomersQuery) =>
    [...customerKeys.lists(), filters] as const,
  details: () => [...customerKeys.all, 'detail'] as const,
  detail: (id: string) => [...customerKeys.details(), id] as const,
  activeRecent: (daysAgo: number) =>
    [...customerKeys.all, 'active-recent', daysAgo] as const,
  addresses: (customerId: string) =>
    [...customerKeys.all, 'addresses', customerId] as const,
};

// Hook para obtener todos los clientes
export function useCustomers(filters?: FindAllCustomersQuery) {
  return useQuery({
    queryKey: customerKeys.list(filters),
    queryFn: () => customersService.findAll(filters),
  });
}

// Hook para obtener un cliente específico
export function useCustomer(id: string, enabled = true) {
  return useQuery({
    queryKey: customerKeys.detail(id),
    queryFn: () => customersService.findOne(id),
    enabled: enabled && !!id,
  });
}

// Hook para crear un cliente
export function useCreateCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateCustomerDto) => customersService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

// Hook para actualizar un cliente
export function useUpdateCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateCustomerDto }) =>
      customersService.update(id, data),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

// Hook para eliminar un cliente
export function useDeleteCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => customersService.remove(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

// Hook para agregar mensaje al chat
export function useAppendChatMessage() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      customerId,
      message,
    }: {
      customerId: string;
      message: Omit<ChatMessage, 'timestamp'>;
    }) => customersService.appendChatMessage(customerId, message),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
    },
  });
}

// Hook para actualizar historial relevante
export function useUpdateRelevantChatHistory() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      customerId,
      relevantHistory,
    }: {
      customerId: string;
      relevantHistory: ChatMessage[];
    }) =>
      customersService.updateRelevantChatHistory(customerId, relevantHistory),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
    },
  });
}

// Hook para actualizar estadísticas
export function useUpdateCustomerStats() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      customerId,
      stats,
    }: {
      customerId: string;
      stats: { totalOrders?: number; totalSpent?: number };
    }) => customersService.updateCustomerStats(customerId, stats),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

// Hook para obtener clientes activos con interacción reciente
export function useActiveCustomersWithRecentInteraction(daysAgo = 30) {
  return useQuery({
    queryKey: customerKeys.activeRecent(daysAgo),
    queryFn: () => customersService.getActiveWithRecentInteraction(daysAgo),
  });
}

// Hook para obtener direcciones de un cliente
export function useGetAddressesByCustomer(
  customerId: string,
  options?: { enabled?: boolean },
) {
  return useQuery({
    queryKey: customerKeys.addresses(customerId),
    queryFn: async () => {
      const response = await apiClient.get<Address[]>(
        `${API_PATHS.CUSTOMERS}/${customerId}/addresses`,
      );
      if (!response.ok || !response.data) {
        return [];
      }
      return response.data;
    },
    enabled: options?.enabled ?? true,
  });
}

================
File: app/src/modules/customers/services/customersService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Customer,
  CreateCustomerDto,
  UpdateCustomerDto,
  FindAllCustomersQuery,
  ChatMessage,
} from '../types/customer.types';

async function findAll(params?: FindAllCustomersQuery): Promise<Customer[]> {
  const response = await apiClient.get<Customer[]>(API_PATHS.CUSTOMERS, params);
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function findOne(id: string): Promise<Customer> {
  const response = await apiClient.get<Customer>(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function create(data: CreateCustomerDto): Promise<Customer> {
  const response = await apiClient.post<Customer>(API_PATHS.CUSTOMERS, data);
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function update(id: string, data: UpdateCustomerDto): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

// Métodos específicos para chat history
async function appendChatMessage(
  customerId: string,
  message: Omit<ChatMessage, 'timestamp'>,
): Promise<Customer> {
  const response = await apiClient.post<Customer>(
    API_PATHS.CUSTOMERS_CHAT_MESSAGE.replace(':customerId', customerId),
    message,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function updateRelevantChatHistory(
  customerId: string,
  relevantHistory: ChatMessage[],
): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_CHAT_HISTORY.replace(':customerId', customerId),
    { relevantHistory },
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function updateCustomerStats(
  customerId: string,
  stats: { totalOrders?: number; totalSpent?: number },
): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_STATS.replace(':customerId', customerId),
    stats,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function getActiveWithRecentInteraction(
  daysAgo: number = 30,
): Promise<Customer[]> {
  const response = await apiClient.get<Customer[]>(
    API_PATHS.CUSTOMERS_ACTIVE_RECENT,
    { daysAgo },
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

export const customersService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  appendChatMessage,
  updateRelevantChatHistory,
  updateCustomerStats,
  getActiveWithRecentInteraction,
};

================
File: app/src/modules/kitchen/hooks/useKitchenSnackbar.ts
================
import { useSnackbar } from '@/hooks/useSnackbar';

export function useKitchenSnackbar() {
  const { showSnackbar } = useSnackbar();

  const showError = (message: string) => {
    // Mostrar errores de forma más discreta con duración más corta
    showSnackbar(message, 'error', 2000); // 2 segundos en lugar del default
  };

  return {
    showError,
  };
}

================
File: app/src/modules/menu/components/VariantFormModal.tsx
================
import React, { useEffect, useMemo, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Portal,
  Modal,
  Card,
  TextInput,
  Button,
  Switch,
  Text,
  HelperText,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { ProductVariant } from '../schema/products.schema';
import { z } from 'zod';
import { useAppTheme } from '@/app/styles/theme';

// Schema local para el formulario de variantes
const variantFormSchema = z.object({
  id: z.string().optional(),
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce
    .number({
      invalid_type_error: 'El precio debe ser un número',
      required_error: 'El precio es requerido',
    })
    .positive('El precio debe ser mayor a 0'),
  isActive: z.boolean(),
  sortOrder: z.number().optional().default(0),
});

type VariantFormData = z.infer<typeof variantFormSchema>;

interface VariantFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: ProductVariant) => void;
  initialData?: Partial<ProductVariant>;
}

function VariantFormModal({
  visible,
  onDismiss,
  onSubmit,
  initialData,
}: VariantFormModalProps): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const isEditing = !!initialData?.name;
  const [priceInputValue, setPriceInputValue] = useState<string>('');

  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors, isSubmitting },
  } = useForm<VariantFormData>({
    resolver: zodResolver(variantFormSchema),
    defaultValues: {
      name: initialData?.name ?? '',
      price: initialData?.price ?? 0,
      isActive: initialData?.isActive ?? true,
      sortOrder: initialData?.sortOrder ?? 0,
      id: initialData?.id,
    },
  });

  const priceValue = watch('price');

  useEffect(() => {
    if (visible) {
      reset({
        name: initialData?.name ?? '',
        price: initialData?.price ?? 0,
        isActive: initialData?.isActive ?? true,
        sortOrder: initialData?.sortOrder ?? 0,
        id: initialData?.id,
      });
    }
  }, [visible, initialData, reset]);

  useEffect(() => {
    setPriceInputValue(
      priceValue !== undefined && priceValue !== null ? String(priceValue) : '',
    );
  }, [priceValue]);

  const handleFormSubmit = (data: VariantFormData) => {
    const finalData: ProductVariant = {
      ...data,
      ...(initialData?.id && { id: initialData.id }),
    } as ProductVariant;
    onSubmit(finalData);
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Card style={styles.card}>
          <Card.Title
            title={isEditing ? 'Editar Variante' : 'Nueva Variante'}
          />
          <Card.Content style={styles.content}>
            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="name"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Nombre Variante *"
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.name}
                    style={styles.input}
                    autoFocus={!isEditing}
                  />
                )}
              />
              {errors.name && (
                <HelperText type="error" visible={!!errors.name}>
                  {errors.name.message}
                </HelperText>
              )}
            </View>

            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="price"
                render={({ field }) => (
                  <TextInput
                    label="Precio *"
                    value={priceInputValue}
                    onChangeText={(text) => {
                      const formattedText = text.replace(/,/g, '.');
                      if (/^(\d*\.?\d*)$/.test(formattedText)) {
                        setPriceInputValue(formattedText);
                        if (formattedText === '') {
                          field.onChange(undefined);
                        } else if (formattedText !== '.') {
                          const numericValue = parseFloat(formattedText);
                          if (!isNaN(numericValue)) {
                            field.onChange(numericValue);
                          }
                        }
                      }
                    }}
                    onBlur={field.onBlur}
                    error={!!errors.price}
                    style={styles.input}
                    keyboardType="decimal-pad"
                  />
                )}
              />
              {errors.price && (
                <HelperText type="error" visible={!!errors.price}>
                  {errors.price.message}
                </HelperText>
              )}
            </View>

            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="sortOrder"
                render={({ field }) => (
                  <TextInput
                    mode="outlined"
                    label="Orden de visualización"
                    value={String(field.value || 0)}
                    onChangeText={(text) => {
                      const value = parseInt(text, 10);
                      field.onChange(isNaN(value) ? 0 : value);
                    }}
                    onBlur={field.onBlur}
                    error={!!errors.sortOrder}
                    style={styles.input}
                    keyboardType="numeric"
                  />
                )}
              />
              {errors.sortOrder && (
                <HelperText type="error" visible={!!errors.sortOrder}>
                  {errors.sortOrder.message}
                </HelperText>
              )}
            </View>

            <View style={[styles.fieldContainer, styles.switchContainer]}>
              <Text style={styles.label}>Variante Activa</Text>
              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <Switch value={!!value} onValueChange={onChange} />
                )}
              />
            </View>
          </Card.Content>
          <Card.Actions style={styles.actions}>
            <Button onPress={onDismiss} disabled={isSubmitting}>
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(handleFormSubmit)}
              loading={isSubmitting}
              disabled={isSubmitting}
            >
              Guardar
            </Button>
          </Card.Actions>
        </Card>
      </Modal>
    </Portal>
  );
}

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      padding: theme.spacing.l, // Más padding exterior
    },
    card: {
      backgroundColor: theme.colors.inverseOnSurface,
      borderRadius: theme.roundness * 3, // Un poco más redondeado
    },
    content: {
      paddingHorizontal: theme.spacing.m, // Padding horizontal para el contenido
      paddingBottom: theme.spacing.s, // Pequeño padding inferior antes de las acciones
    },
    fieldContainer: {
      marginBottom: theme.spacing.m, // Espacio uniforme debajo de cada campo/grupo
    },
    input: {},
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    label: {
      color: theme.colors.onSurfaceVariant,
    },
    actions: {
      justifyContent: 'flex-end',
      padding: theme.spacing.m, // Padding uniforme para las acciones
    },
  });

export default VariantFormModal;

================
File: app/src/modules/menu/schema/products.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/query.types';
// Importar tipos de dominio centralizados
import {
  photoSchema,
  type Photo,
} from '../../../app/schemas/domain/photo.schema';
import {
  productVariantSchema,
  type ProductVariant,
} from '../../../app/schemas/domain/product-variant.schema';
import { modifierGroupSchema } from '../../../app/schemas/domain/modifier-group.schema';
// Importar el schema y tipo Product centralizado del dominio
import {
  productSchema as domainProductSchema,
  type Product,
} from '../../../app/schemas/domain/product.schema';

// --- Schemas Zod ---

// Schema para variantes en el formulario (sin requerir ID) - derivado del dominio
const productVariantFormSchema = productVariantSchema
  .omit({ id: true })
  .extend({
    id: z.string().optional(),
    sortOrder: z.number().optional().default(0),
  });

// Schema base para formularios - compose desde el dominio con campos adicionales específicos del formulario
const productFormBaseSchema = domainProductSchema
  .omit({
    id: true,
    photo: true,
    variants: true,
    modifierGroups: true,
    pizzaCustomizations: true,
    pizzaConfiguration: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend({
    id: z.string().optional(), // ID opcional para creación/formulario
    photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(), // ID de la foto guardada en backend
    imageUri: z // Campo temporal para el formulario
      .string()
      .url()
      .or(z.string().startsWith('file://'))
      .optional()
      .nullable(),
    variants: z.array(productVariantFormSchema).optional(), // Usa el schema del formulario
    variantsToDelete: z.array(z.string()).optional(), // Para manejar eliminación en edición
    modifierGroupIds: z.array(z.string()).optional(), // IDs para asignar/actualizar
  });

// Esquema para el formulario, con la validación condicional
export const productSchema = productFormBaseSchema.superRefine((data, ctx) => {
  if (data.hasVariants) {
    if (!data.variants || data.variants.length === 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Debe añadir al menos una variante si marca esta opción.',
        path: ['variants'],
      });
    }
    if (data.price !== null && data.price !== undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'El precio principal debe estar vacío si el producto tiene variantes.',
        path: ['price'],
      });
    }
  } else {
    if (data.price === null || data.price === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El precio es requerido si el producto no tiene variantes.',
        path: ['price'],
      });
    }
    if (data.variants && data.variants.length > 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'No debe haber variantes si el producto no está marcado como "Tiene Variantes".',
        path: ['variants'],
      });
    }
  }
});

// Tipo inferido para los inputs del formulario
export type ProductFormInputs = z.infer<typeof productSchema>;

// Schema para actualización de productos
export const updateProductSchema = productFormBaseSchema
  .partial()
  .superRefine((data, ctx) => {
    if (data.hasVariants !== undefined) {
      if (data.hasVariants) {
        if (data.variants !== undefined && data.variants.length === 0) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: 'Debe añadir al menos una variante si marca esta opción.',
            path: ['variants'],
          });
        }
        if (data.price !== null && data.price !== undefined) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message:
              'El precio principal debe estar vacío si el producto tiene variantes.',
            path: ['price'],
          });
        }
      } else {
        if (data.price === null || data.price === undefined) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message:
              'El precio es requerido si el producto no tiene variantes.',
            path: ['price'],
          });
        }
        if (data.variants && data.variants.length > 0) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message:
              'No debe haber variantes si el producto no está marcado como "Tiene Variantes".',
            path: ['variants'],
          });
        }
      }
    }
  });

export type UpdateProductFormInputs = z.infer<typeof updateProductSchema>;

// Esquema para la respuesta de la API - usa directamente el schema de dominio
// Este schema representa la estructura que devuelve el backend.
export const productResponseSchema = domainProductSchema;
// Si se necesita el tipo específico inferido de esta respuesta:
// export type ProductApiResponse = z.infer<typeof productResponseSchema>;

// Esquema para la respuesta de lista paginada (si aplica)
export const productsListResponseSchema = z.tuple([
  z.array(productResponseSchema), // Usa el schema de respuesta definido arriba
  z.number(), // Count
]);
export type ProductsListResponse = z.infer<typeof productsListResponseSchema>;

// Esquema para los parámetros de query de búsqueda
export const findAllProductsQuerySchema = baseListQuerySchema.extend({
  subcategoryId: z.string().optional(),
  hasVariants: z.boolean().optional(),
  isActive: z.boolean().optional(),
  search: z.string().optional(),
});
export type FindAllProductsQuery = z.infer<typeof findAllProductsQuerySchema>;

// Esquema para asignar/desasignar grupos de modificadores
export const assignModifierGroupsSchema = z.object({
  modifierGroupIds: z
    .array(z.string())
    .min(1, 'Se requiere al menos un ID de grupo'),
});
export type AssignModifierGroupsInput = z.infer<
  typeof assignModifierGroupsSchema
>;

// Re-exportar los tipos de dominio centralizados
export type { Photo, ProductVariant, Product }; // Añadir Product

================
File: app/src/modules/menu/services/categoryService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import type {
  Category,
  CreateCategoryDto,
  UpdateCategoryDto,
} from '../schema/category.schema';
import { PaginatedResponse } from '../../../app/types/api.types';

export const getCategories = async (params?: {
  isActive?: boolean;
  page?: number;
  limit?: number;
}): Promise<PaginatedResponse<Category>> => {
  const response = await ApiClientWrapper.get<{
    items: Category[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.CATEGORIES, params);

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }

  // Transforma la respuesta del backend a PaginatedResponse
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};

export const getCategory = async (id: string): Promise<Category> => {
  const response = await ApiClientWrapper.get<Category>(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }
  return response.data;
};

export const createCategory = async (
  data: CreateCategoryDto,
): Promise<Category> => {
  const response = await ApiClientWrapper.post<Category>(
    API_PATHS.CATEGORIES,
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }
  return response.data;
};

export const updateCategory = async (
  id: string,
  data: UpdateCategoryDto,
): Promise<Category> => {
  const response = await ApiClientWrapper.patch<Category>(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }

  return response.data;
};

export const deleteCategory = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }
};

// Menú para pantallas de creación de órdenes
export async function getOrderMenu(): Promise<Category[]> {
  const response = await ApiClientWrapper.get<Category[]>(
    API_PATHS.CATEGORIES_ORDER_MENU,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }

  return response.data;
}

const categoryService = {
  getCategories,
  getCategory,
  createCategory,
  updateCategory,
  deleteCategory,
  getOrderMenu,
};

export default categoryService;

================
File: app/src/modules/menu/services/productsService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Product,
  ProductFormInputs,
  FindAllProductsQuery,
  AssignModifierGroupsInput,
} from '../schema/products.schema'; // Corregida ruta de importación
import { PaginatedResponse } from '@/app/types/api.types';

async function findAll(
  params: FindAllProductsQuery,
): Promise<PaginatedResponse<Product>> {
  const response = await apiClient.get<{
    items: Product[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.PRODUCTS, params);
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  // Transforma la respuesta del backend a PaginatedResponse
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
}

async function findOne(id: string): Promise<Product> {
  const response = await apiClient.get<Product>(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function create(data: ProductFormInputs): Promise<Product> {
  const response = await apiClient.post<Product>(API_PATHS.PRODUCTS, data);

  if (!response.ok) {
    // Verificar si tenemos un ApiError preservado
    if ((response as any).apiError instanceof ApiError) {
      throw (response as any).apiError;
    }

    // Verificar si el error original del interceptor es un ApiError
    if (response.originalError instanceof ApiError) {
      throw response.originalError;
    }

    // Si no hay originalError, crear uno desde la respuesta
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data!;
}

async function update(
  id: string,
  data: Partial<ProductFormInputs>,
): Promise<Product> {
  const response = await apiClient.patch<Product>(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok) {
    // Verificar si tenemos un ApiError preservado
    if ((response as any).apiError instanceof ApiError) {
      throw (response as any).apiError;
    }

    // Verificar si el error original del interceptor es un ApiError
    if (response.originalError instanceof ApiError) {
      throw response.originalError;
    }

    // Si no hay originalError, crear uno desde la respuesta
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data!;
}

async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    // No esperamos 'data' en un 204 No Content, pero sí puede haber error
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  // No se retorna nada en caso de éxito (204 No Content)
}

async function assignModifierGroups(
  productId: string,
  data: AssignModifierGroupsInput,
): Promise<Product> {
  const response = await apiClient.post<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function getModifierGroups(productId: string): Promise<Product> {
  const response = await apiClient.get<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function removeModifierGroups(
  productId: string,
  data: AssignModifierGroupsInput,
): Promise<Product> {
  const response = await apiClient.delete<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function findAllPizzas(): Promise<Product[]> {
  const response = await apiClient.get<Product[]>(API_PATHS.PRODUCTS_PIZZAS);
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function getPizzaCustomizations(productId: string): Promise<any[]> {
  const response = await apiClient.get<any[]>(
    API_PATHS.PRODUCTS_PIZZA_CUSTOMIZATIONS.replace(':productId', productId),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function updatePizzaCustomizations(
  productId: string,
  pizzaCustomizationIds: string[],
): Promise<Product> {
  const response = await apiClient.put<Product>(
    API_PATHS.PRODUCTS_PIZZA_CUSTOMIZATIONS.replace(':productId', productId),
    pizzaCustomizationIds, // Enviar el array directamente
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function bulkUpdatePizzaCustomizations(
  updates: Array<{ productId: string; customizationIds: string[] }>,
): Promise<void> {
  const response = await apiClient.put(
    API_PATHS.PRODUCTS_PIZZAS_CUSTOMIZATIONS_BULK,
    { updates },
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

export const productsService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  assignModifierGroups,
  getModifierGroups,
  removeModifierGroups,
  findAllPizzas,
  // Pizza customizations methods
  getPizzaCustomizations,
  updatePizzaCustomizations,
  bulkUpdatePizzaCustomizations,
};

================
File: app/src/modules/modifiers/components/ModifierGroupFormModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  Switch,
  HelperText,
  ActivityIndicator,
} from 'react-native-paper';
import { useForm, Controller, SubmitHandler } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useMutation, useQueryClient } from '@tanstack/react-query';

import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { modifierGroupService } from '../services/modifierGroupService';
import {
  ModifierGroup,
  ModifierGroupFormInputs,
  modifierGroupSchema,
  createModifierGroupSchema,
  CreateModifierGroupInput,
  UpdateModifierGroupInput,
} from '../schema/modifierGroup.schema';

interface Props {
  visible: boolean;
  onDismiss: () => void;
  onSaveSuccess: () => void;
  initialData?: ModifierGroup | null;
}

const QUERY_KEY_TO_INVALIDATE = ['modifierGroups'];

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: theme.spacing.l,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
      fontSize: 20,
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.xl,
    },
    input: {
      marginBottom: theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
    },
    row: {
      flexDirection: 'row',
      marginHorizontal: -theme.spacing.xs,
      marginBottom: theme.spacing.m,
    },
    column: {
      flex: 1,
      paddingHorizontal: theme.spacing.xs,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
      flexShrink: 1,
      marginRight: theme.spacing.m,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: theme.spacing.m,
    },
    cancelButton: {
      marginRight: theme.spacing.m,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 10,
      borderRadius: theme.roundness * 2,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    divider: {
      marginVertical: theme.spacing.m,
      backgroundColor: theme.colors.outlineVariant,
    },
  });

const ModifierGroupFormModal: React.FC<Props> = ({
  visible,
  onDismiss,
  onSaveSuccess,
  initialData,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const isEditing = !!initialData;

  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors, isSubmitting },
    // setValue, // No se usa actualmente
  } = useForm<ModifierGroupFormInputs>({
    resolver: zodResolver(modifierGroupSchema),
    defaultValues: {
      name: '',
      description: null,
      minSelections: 0,
      maxSelections: 2,
      isRequired: false,
      allowMultipleSelections: false,
      isActive: true,
      sortOrder: 0,
    },
  });

  const watchedAllowMultipleSelections = watch('allowMultipleSelections');

  useEffect(() => {
    if (visible) {
      if (initialData) {
        reset({
          name: initialData.name,
          description: initialData.description,
          minSelections: initialData.minSelections ?? 0,
          maxSelections: initialData.maxSelections ?? 1,
          isRequired: initialData.isRequired ?? false,
          allowMultipleSelections: initialData.allowMultipleSelections ?? false,
          isActive: initialData.isActive ?? true,
          sortOrder: initialData.sortOrder ?? 0,
        });
      } else {
        reset({
          name: '',
          description: null,
          minSelections: 0,
          maxSelections: 2,
          isRequired: false,
          allowMultipleSelections: false,
          isActive: true,
          sortOrder: 0,
        });
      }
    }
  }, [initialData, visible, reset]);

  const mutation = useMutation<
    ModifierGroup,
    Error,
    CreateModifierGroupInput | UpdateModifierGroupInput
  >({
    mutationFn: (data) => {
      if (isEditing && initialData) {
        return modifierGroupService.update(
          initialData.id,
          data as UpdateModifierGroupInput,
        );
      } else {
        const createData = createModifierGroupSchema.parse(
          data as ModifierGroupFormInputs,
        );
        return modifierGroupService.create(createData);
      }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEY_TO_INVALIDATE });
      showSnackbar({
        message: `Grupo "${data.name}" ${
          isEditing ? 'actualizado' : 'creado'
        } correctamente`,
        type: 'success',
      });
      onSaveSuccess();
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      // Error al guardar grupo de modificadores
    },
  });

  const onSubmit: SubmitHandler<ModifierGroupFormInputs> = (formData) => {
    mutation.mutate(formData);
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting}
      >
        <View style={styles.formContainer}>
          <View style={styles.modalHeader}>
            <Text variant="titleLarge" style={styles.modalTitle}>
              {isEditing
                ? 'Editar Grupo de Modificadores'
                : 'Crear Nuevo Grupo'}
            </Text>
          </View>

          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            <Controller
              name="name"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Nombre *"
                  value={value}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.name}
                  style={styles.input}
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.name && (
              <HelperText
                type="error"
                visible={!!errors.name}
                style={styles.helperText}
              >
                {errors.name.message}
              </HelperText>
            )}

            <Controller
              name="description"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Descripción (Opcional)"
                  value={value ?? ''}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.description}
                  style={styles.input}
                  multiline
                  numberOfLines={3}
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.description && (
              <HelperText
                type="error"
                visible={!!errors.description}
                style={styles.helperText}
              >
                {errors.description.message}
              </HelperText>
            )}

            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>
                Permitir Múltiples Selecciones
              </Text>
              <Controller
                name="allowMultipleSelections"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.allowMultipleSelections && (
              <HelperText
                type="error"
                visible={!!errors.allowMultipleSelections}
                style={styles.helperText}
              >
                {errors.allowMultipleSelections.message}
              </HelperText>
            )}

            <View
              style={[
                styles.row,
                !watchedAllowMultipleSelections ? { opacity: 0.5 } : {},
              ]}
            >
              <View style={styles.column}>
                <Controller
                  name="minSelections"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Mín. Selecciones"
                      value={String(value ?? 0)}
                      onChangeText={(text) => onChange(parseInt(text, 10) || 0)}
                      onBlur={onBlur}
                      error={!!errors.minSelections}
                      style={styles.input}
                      keyboardType="numeric"
                      disabled={!watchedAllowMultipleSelections || isSubmitting}
                      mode="outlined"
                    />
                  )}
                />
                {errors.minSelections && (
                  <HelperText
                    type="error"
                    visible={!!errors.minSelections}
                    style={styles.helperText}
                  >
                    {errors.minSelections.message}
                  </HelperText>
                )}
              </View>
              <View style={styles.column}>
                <Controller
                  name="maxSelections"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Máx. Selecciones *"
                      value={String(value ?? 1)}
                      onChangeText={(text) => onChange(parseInt(text, 10) || 1)}
                      onBlur={onBlur}
                      error={!!errors.maxSelections}
                      style={styles.input}
                      keyboardType="numeric"
                      disabled={!watchedAllowMultipleSelections || isSubmitting}
                      mode="outlined"
                    />
                  )}
                />
                {errors.maxSelections && (
                  <HelperText
                    type="error"
                    visible={!!errors.maxSelections}
                    style={styles.helperText}
                  >
                    {errors.maxSelections.message}
                  </HelperText>
                )}
              </View>
            </View>

            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>Es Requerido</Text>
              <Controller
                name="isRequired"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isRequired && (
              <HelperText
                type="error"
                visible={!!errors.isRequired}
                style={styles.helperText}
              >
                {errors.isRequired.message}
              </HelperText>
            )}

            <Controller
              name="sortOrder"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Orden de visualización"
                  value={String(value ?? 0)}
                  onChangeText={(text) => onChange(parseInt(text, 10) || 0)}
                  onBlur={onBlur}
                  error={!!errors.sortOrder}
                  style={styles.input}
                  keyboardType="numeric"
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.sortOrder && (
              <HelperText
                type="error"
                visible={!!errors.sortOrder}
                style={styles.helperText}
              >
                {errors.sortOrder.message}
              </HelperText>
            )}

            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>Está Activo</Text>
              <Controller
                name="isActive"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isActive && (
              <HelperText
                type="error"
                visible={!!errors.isActive}
                style={styles.helperText}
              >
                {errors.isActive.message}
              </HelperText>
            )}
          </ScrollView>

          {isSubmitting && (
            <View style={styles.loadingOverlay}>
              <ActivityIndicator
                animating={true}
                size="large"
                color={theme.colors.primary}
              />
            </View>
          )}

          <View style={styles.modalActions}>
            <Button
              mode="outlined"
              onPress={onDismiss}
              style={[styles.formButton, styles.cancelButton]}
              disabled={isSubmitting}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              style={styles.formButton}
              loading={isSubmitting}
              disabled={isSubmitting}
            >
              {isEditing ? 'Actualizar' : 'Crear'}
            </Button>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};

export default ModifierGroupFormModal;

================
File: app/src/modules/modifiers/hooks/useModifierGroupsQuery.ts
================
import {
  useQuery,
  type UseQueryOptions,
  type UseQueryResult,
} from '@tanstack/react-query';
import { modifierGroupService } from '../services/modifierGroupService';
import { ModifierGroup } from '../schema/modifierGroup.schema';
import { ApiError } from '@/app/lib/errors';
import { PaginatedResponse } from '@/app/types/api.types';

const modifierGroupKeys = {
  all: ['modifierGroups'] as const,
  lists: () => [...modifierGroupKeys.all, 'list'] as const,
  list: (filters: FindAllModifierGroupsQuery) =>
    [...modifierGroupKeys.lists(), filters] as const,
};

interface FindAllModifierGroupsQuery {
  page?: number;
  limit?: number;
  isActive?: boolean;
  search?: string;
}

export const useModifierGroupsQuery = (
  filters: FindAllModifierGroupsQuery = {},
  options?: Omit<
    UseQueryOptions<PaginatedResponse<ModifierGroup>, ApiError>,
    'queryKey' | 'queryFn'
  >,
): UseQueryResult<PaginatedResponse<ModifierGroup>, ApiError> => {
  const queryKey = modifierGroupKeys.list(filters);
  return useQuery<PaginatedResponse<ModifierGroup>, ApiError>({
    queryKey: queryKey,
    queryFn: () => modifierGroupService.findAll(filters),
    ...options,
  });
};

================
File: app/src/modules/orders/components/AdjustmentFormModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Chip,
  IconButton,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import type {
  OrderAdjustment,
  AdjustmentFormData,
} from '../types/adjustments.types';

interface AdjustmentFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSave: (adjustment: OrderAdjustment) => void;
  adjustment?: OrderAdjustment | null;
  orderSubtotal: number;
}

export const AdjustmentFormModal: React.FC<AdjustmentFormModalProps> = ({
  visible,
  onDismiss,
  onSave,
  adjustment,
  orderSubtotal,
}) => {
  const theme = useAppTheme();

  // Estado del formulario
  const [formData, setFormData] = useState<AdjustmentFormData>({
    name: '',
    isPercentage: true,
    value: 0,
    amount: 0,
  });

  // Estados separados para los campos de texto
  const [percentageText, setPercentageText] = useState('');
  const [amountText, setAmountText] = useState('');
  const [isDiscount, setIsDiscount] = useState(false);
  const [nameWasEdited, setNameWasEdited] = useState(false);

  const [errors, setErrors] = useState<{
    name?: string;
    value?: string;
    amount?: string;
  }>({});

  // Inicializar formulario cuando se abre o cambia el ajuste
  useEffect(() => {
    if (visible) {
      if (adjustment) {
        setFormData({
          name: adjustment.name,
          isPercentage: adjustment.isPercentage,
          value: adjustment.value || 0,
          amount: adjustment.amount || 0,
        });
        setPercentageText(Math.abs(adjustment.value || 0).toString());
        setAmountText(Math.abs(adjustment.amount || 0).toString());
        setIsDiscount((adjustment.value || adjustment.amount || 0) < 0);
        setNameWasEdited(true); // Si es edición, asumimos que el nombre fue editado
      } else {
        setFormData({
          name: 'Cargo adicional', // Por defecto cargo
          isPercentage: true,
          value: 0,
          amount: 0,
        });
        setPercentageText('');
        setAmountText('');
        setIsDiscount(false);
        setNameWasEdited(false);
      }
      setErrors({});
    }
  }, [visible, adjustment]);

  // Calcular el monto cuando cambia el valor o tipo
  useEffect(() => {
    if (formData.isPercentage && formData.value !== undefined) {
      const calculatedAmount = (orderSubtotal * formData.value) / 100;
      setFormData((prev) => ({ ...prev, amount: calculatedAmount }));
    }
  }, [formData.isPercentage, formData.value, orderSubtotal]);

  const handleTypeChange = (isPercentage: boolean) => {
    setFormData((prev) => ({
      ...prev,
      isPercentage,
      value: isPercentage ? 0 : undefined,
      amount: isPercentage ? 0 : prev.amount,
    }));
    if (isPercentage) {
      setPercentageText('');
    } else {
      setAmountText('');
    }
  };

  const validateForm = (): boolean => {
    const newErrors: typeof errors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'El nombre es requerido';
    }

    if (formData.isPercentage) {
      if (formData.value === undefined || formData.value === null) {
        newErrors.value = 'El porcentaje es requerido';
      } else if (formData.value === 0) {
        newErrors.value = 'El porcentaje no puede ser 0';
      } else if (formData.value < -100 || formData.value > 100) {
        newErrors.value = 'El porcentaje debe estar entre -100 y 100';
      }
    } else {
      if (formData.amount === undefined || formData.amount === null) {
        newErrors.amount = 'El monto es requerido';
      } else if (formData.amount === 0) {
        newErrors.amount = 'El monto no puede ser 0';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSave = () => {
    if (!validateForm()) return;

    const adjustmentData: OrderAdjustment = {
      id: adjustment?.id || undefined,
      name: formData.name.trim(),
      isPercentage: formData.isPercentage,
      value: formData.isPercentage ? formData.value : undefined,
      amount: formData.amount,
      isNew: !adjustment?.id,
    };

    onSave(adjustmentData);
    onDismiss();
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modal,
          { backgroundColor: theme.colors.surface },
        ]}
      >
        {/* Header simplificado */}
        <View
          style={[styles.header, { backgroundColor: theme.colors.primary }]}
        >
          <Text
            variant="titleLarge"
            style={[styles.title, { color: theme.colors.onPrimary }]}
          >
            {adjustment ? 'Editar Ajuste' : 'Nuevo Ajuste'}
          </Text>
          <IconButton
            icon="close"
            size={20}
            onPress={onDismiss}
            style={styles.closeButton}
            iconColor={theme.colors.onPrimary}
          />
        </View>

        {/* Contenido */}
        <View style={styles.content}>
          {/* Nombre del ajuste */}
          <TextInput
            label="Nombre"
            value={formData.name}
            onChangeText={(text) => {
              setFormData((prev) => ({ ...prev, name: text }));
              // Detectar si el usuario editó manualmente el nombre
              setNameWasEdited(
                text !== 'Descuento' && text !== 'Cargo adicional',
              );
            }}
            mode="outlined"
            error={!!errors.name}
            placeholder="Ej: Descuento especial"
            style={styles.input}
          />
          {errors.name && (
            <HelperText type="error" visible={true}>
              {errors.name}
            </HelperText>
          )}

          {/* Tipo de ajuste con chips */}
          <View style={styles.typeContainer}>
            <Text
              variant="labelLarge"
              style={[styles.label, { color: theme.colors.onSurface }]}
            >
              Tipo de ajuste
            </Text>
            <View style={styles.chipGroup}>
              <Chip
                mode={formData.isPercentage ? 'flat' : 'outlined'}
                onPress={() => handleTypeChange(true)}
                selected={formData.isPercentage}
                style={[
                  styles.chip,
                  formData.isPercentage && {
                    backgroundColor: theme.colors.primaryContainer,
                  },
                ]}
                textStyle={
                  formData.isPercentage && {
                    color: theme.colors.onPrimaryContainer,
                  }
                }
              >
                Porcentaje
              </Chip>
              <Chip
                mode={!formData.isPercentage ? 'flat' : 'outlined'}
                onPress={() => handleTypeChange(false)}
                selected={!formData.isPercentage}
                style={[
                  styles.chip,
                  !formData.isPercentage && {
                    backgroundColor: theme.colors.primaryContainer,
                  },
                ]}
                textStyle={
                  !formData.isPercentage && {
                    color: theme.colors.onPrimaryContainer,
                  }
                }
              >
                Monto fijo
              </Chip>
            </View>
          </View>

          {/* Tipo de operación (descuento o cargo) */}
          <View style={styles.operationContainer}>
            <Text
              variant="labelLarge"
              style={[styles.label, { color: theme.colors.onSurface }]}
            >
              Tipo de operación
            </Text>
            <View style={styles.operationButtons}>
              <Button
                mode={isDiscount ? 'contained' : 'outlined'}
                onPress={() => {
                  setIsDiscount(true);
                  // Siempre actualizar el nombre si no fue editado manualmente
                  if (!nameWasEdited) {
                    setFormData((prev) => ({ ...prev, name: 'Descuento' }));
                  }
                  if (formData.isPercentage) {
                    const absValue = Math.abs(parseFloat(percentageText) || 0);
                    setFormData((prev) => ({ ...prev, value: -absValue }));
                  } else {
                    const absValue = Math.abs(parseFloat(amountText) || 0);
                    setFormData((prev) => ({ ...prev, amount: -absValue }));
                  }
                }}
                style={[
                  styles.operationButton,
                  isDiscount && {
                    backgroundColor: theme.colors.errorContainer,
                    borderColor: theme.colors.error,
                  },
                ]}
                labelStyle={{
                  color: isDiscount
                    ? theme.colors.onErrorContainer
                    : theme.colors.error,
                }}
                icon="minus"
              >
                Descuento
              </Button>
              <Button
                mode={!isDiscount ? 'contained' : 'outlined'}
                onPress={() => {
                  setIsDiscount(false);
                  // Siempre actualizar el nombre si no fue editado manualmente
                  if (!nameWasEdited) {
                    setFormData((prev) => ({
                      ...prev,
                      name: 'Cargo adicional',
                    }));
                  }
                  if (formData.isPercentage) {
                    const absValue = Math.abs(parseFloat(percentageText) || 0);
                    setFormData((prev) => ({ ...prev, value: absValue }));
                  } else {
                    const absValue = Math.abs(parseFloat(amountText) || 0);
                    setFormData((prev) => ({ ...prev, amount: absValue }));
                  }
                }}
                style={[
                  styles.operationButton,
                  !isDiscount && {
                    backgroundColor: theme.colors.primaryContainer,
                    borderColor: theme.colors.primary,
                  },
                ]}
                labelStyle={{
                  color: !isDiscount
                    ? theme.colors.onPrimaryContainer
                    : theme.colors.primary,
                }}
                icon="plus"
              >
                Cargo
              </Button>
            </View>
          </View>

          {/* Campo de valor */}
          {formData.isPercentage ? (
            <TextInput
              label="Porcentaje"
              value={percentageText}
              onChangeText={(text) => {
                // Solo permitir números positivos
                const regex = /^\d*\.?\d*$/;
                if (regex.test(text) || text === '') {
                  setPercentageText(text);
                  const value = parseFloat(text) || 0;
                  setFormData((prev) => ({
                    ...prev,
                    value: isDiscount ? -value : value,
                  }));
                }
              }}
              mode="outlined"
              keyboardType="numeric"
              error={!!errors.value}
              right={<TextInput.Affix text="%" />}
              style={styles.input}
            />
          ) : (
            <TextInput
              label="Monto"
              value={amountText}
              onChangeText={(text) => {
                // Solo permitir números positivos
                const regex = /^\d*\.?\d*$/;
                if (regex.test(text) || text === '') {
                  setAmountText(text);
                  const amount = parseFloat(text) || 0;
                  setFormData((prev) => ({
                    ...prev,
                    amount: isDiscount ? -amount : amount,
                  }));
                }
              }}
              mode="outlined"
              keyboardType="numeric"
              error={!!errors.amount}
              left={<TextInput.Affix text="$" />}
              style={styles.input}
            />
          )}
          {(errors.value || errors.amount) && (
            <HelperText type="error" visible={true}>
              {errors.value || errors.amount}
            </HelperText>
          )}
        </View>

        {/* Botones de acción */}
        <View
          style={[
            styles.actions,
            { borderTopColor: theme.colors.outlineVariant },
          ]}
        >
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[
              styles.actionButton,
              {
                borderColor: theme.colors.outline,
                backgroundColor: theme.colors.secondaryContainer,
              },
            ]}
            textColor={theme.colors.onSecondaryContainer}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSave}
            style={[styles.actionButton, styles.saveButton]}
            buttonColor={theme.colors.primary}
          >
            {adjustment ? 'Actualizar' : 'Guardar'}
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};

const styles = StyleSheet.create({
  modal: {
    borderRadius: 16,
    margin: 20,
    maxWidth: 400,
    width: '90%',
    maxHeight: '80%',
    alignSelf: 'center',
    elevation: 5,
    ...Platform.select({
      web: {
        boxShadow: '0px 2px 3.84px rgba(0, 0, 0, 0.25)',
      },
      default: {
        shadowColor: '#000',
        shadowOffset: {
          width: 0,
          height: 2,
        },
        shadowOpacity: 0.25,
        shadowRadius: 3.84,
      },
    }),
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    minHeight: 48,
  },
  title: {
    flex: 1,
    fontWeight: '500',
  },
  closeButton: {
    margin: -4,
  },
  content: {
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 16,
  },
  input: {
    marginBottom: 16,
  },
  typeContainer: {
    marginBottom: 16,
  },
  label: {
    marginBottom: 8,
    fontWeight: '500',
  },
  chipGroup: {
    flexDirection: 'row',
    gap: 12,
  },
  chip: {
    flex: 1,
  },
  operationContainer: {
    marginBottom: 16,
  },
  operationButtons: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 8,
  },
  operationButton: {
    flex: 1,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderTopWidth: 1,
    gap: 12,
  },
  actionButton: {
    minWidth: 100,
  },
  saveButton: {
    marginLeft: 4,
  },
});

================
File: app/src/modules/orders/components/PizzaCustomizationSection.tsx
================
import React, { useState, useMemo, useCallback, memo } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Text,
  Checkbox,
  Card,
  ActivityIndicator,
  Surface,
  Switch,
  IconButton,
  TouchableRipple,
  RadioButton,
} from 'react-native-paper';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import type {
  PizzaCustomization,
  PizzaConfiguration,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import {
  PizzaHalf,
  CustomizationAction,
  CustomizationType,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import { useAppTheme } from '@/app/styles/theme';

interface PizzaCustomizationSectionProps {
  pizzaCustomizations: PizzaCustomization[];
  pizzaConfiguration: PizzaConfiguration | null;
  selectedPizzaCustomizations: SelectedPizzaCustomization[];
  onCustomizationChange: (customizations: SelectedPizzaCustomization[]) => void;
  loading?: boolean;
}

interface FlavorItemProps {
  flavor: PizzaCustomization;
  isSelected: boolean;
  isDisabled: boolean;
  onToggle: (flavorId: string) => void;
  styles: any;
  theme: any;
}

const FlavorItem = memo<FlavorItemProps>(
  ({ flavor, isSelected, isDisabled, onToggle, styles, theme }) => (
    <Surface
      style={[
        styles.flavorChip,
        isSelected && styles.flavorChipSelected,
        isDisabled && styles.flavorChipDisabled,
      ]}
      elevation={isSelected ? 2 : 0}
    >
      <TouchableRipple
        onPress={() => !isDisabled && onToggle(flavor.id)}
        disabled={isDisabled}
        style={{
          paddingVertical: 12,
          paddingHorizontal: 16,
          borderRadius: 8,
        }}
      >
        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
          <RadioButton
            value={flavor.id}
            status={isSelected ? 'checked' : 'unchecked'}
            disabled={isDisabled}
            onPress={() => !isDisabled && onToggle(flavor.id)}
          />
          <View style={{ flex: 1, marginLeft: 8 }}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                gap: 8,
              }}
            >
              <Text
                style={[
                  styles.flavorLabel,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                {flavor.name}
              </Text>
              <Text
                style={[
                  styles.toppingValue,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                ({flavor.toppingValue})
              </Text>
            </View>
            {flavor.ingredients && (
              <Text
                style={[
                  styles.ingredientsText,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                {flavor.ingredients}
              </Text>
            )}
          </View>
        </View>
      </TouchableRipple>
    </Surface>
  ),
);

const PizzaCustomizationSection = memo<PizzaCustomizationSectionProps>(
  ({
    pizzaCustomizations,
    pizzaConfiguration,
    selectedPizzaCustomizations,
    onCustomizationChange,
    loading = false,
  }) => {
    const theme = useAppTheme();
    const styles = useMemo(() => createStyles(theme), [theme]);
    const [manualHalvesMode, setManualHalvesMode] = useState(false);
    const [expandedIngredients, setExpandedIngredients] = useState<{
      full: boolean;
      half1: boolean;
      half2: boolean;
    }>({
      full: false,
      half1: false,
      half2: false,
    });
    const [expandedFlavors, setExpandedFlavors] = useState(true);

    // Separar sabores e ingredientes
    const flavors = useMemo(
      () =>
        pizzaCustomizations.filter((c) => c.type === CustomizationType.FLAVOR),
      [pizzaCustomizations],
    );

    const ingredients = useMemo(
      () =>
        pizzaCustomizations.filter(
          (c) => c.type === CustomizationType.INGREDIENT,
        ),
      [pizzaCustomizations],
    );

    // Obtener sabores seleccionados
    const selectedFlavors = useMemo(
      () =>
        selectedPizzaCustomizations.filter(
          (sc) =>
            sc.action === CustomizationAction.ADD &&
            flavors.some((f) => f.id === sc.pizzaCustomizationId),
        ),
      [selectedPizzaCustomizations, flavors],
    );

    // Obtener el nombre del sabor por ID
    const getFlavorName = useCallback(
      (flavorId: string) => {
        const flavor = flavors.find((f) => f.id === flavorId);
        return flavor?.name || '';
      },
      [flavors],
    );

    const handleFlavorToggle = useCallback(
      (flavorId: string) => {
        const isSelected = selectedPizzaCustomizations.some(
          (sc) =>
            sc.pizzaCustomizationId === flavorId &&
            sc.action === CustomizationAction.ADD,
        );

        if (isSelected) {
          // Deseleccionar
          const remainingFlavorSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !(
                sc.pizzaCustomizationId === flavorId &&
                sc.action === CustomizationAction.ADD
              ),
          );

          // Si queda solo un sabor después de deseleccionar, cambiar su half a FULL
          const remainingFlavors = remainingFlavorSelections.filter(
            (sc) =>
              sc.action === CustomizationAction.ADD &&
              flavors.some((f) => f.id === sc.pizzaCustomizationId),
          );

          if (remainingFlavors.length === 1) {
            const otherFlavorId = remainingFlavors[0].pizzaCustomizationId;
            const nonFlavorSelections = remainingFlavorSelections.filter(
              (sc) =>
                !flavors.some((f) => f.id === sc.pizzaCustomizationId) ||
                sc.action !== CustomizationAction.ADD,
            );

            onCustomizationChange([
              ...nonFlavorSelections,
              {
                pizzaCustomizationId: otherFlavorId,
                half: PizzaHalf.FULL,
                action: CustomizationAction.ADD,
              },
            ]);
          } else {
            onCustomizationChange(remainingFlavorSelections);
          }
        } else {
          // Seleccionar
          const currentFlavors = selectedPizzaCustomizations.filter(
            (sc) =>
              sc.action === CustomizationAction.ADD &&
              flavors.some((f) => f.id === sc.pizzaCustomizationId),
          );

          if (currentFlavors.length >= 2) {
            return; // No permitir más de 2
          }

          const nonFlavorSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !flavors.some((f) => f.id === sc.pizzaCustomizationId) ||
              sc.action !== CustomizationAction.ADD,
          );

          if (currentFlavors.length === 0) {
            // Primer sabor - va completo o a mitad 1 si está el modo manual
            if (manualHalvesMode) {
              onCustomizationChange([
                ...nonFlavorSelections,
                {
                  pizzaCustomizationId: flavorId,
                  half: PizzaHalf.HALF_1,
                  action: CustomizationAction.ADD,
                },
              ]);
            } else {
              onCustomizationChange([
                ...nonFlavorSelections,
                {
                  pizzaCustomizationId: flavorId,
                  half: PizzaHalf.FULL,
                  action: CustomizationAction.ADD,
                },
              ]);
            }
          } else if (currentFlavors.length === 1) {
            // Segundo sabor - convertir a mitades
            const existingFlavor = currentFlavors[0];

            // Cambiar el sabor existente a mitad 1
            nonFlavorSelections.push({
              pizzaCustomizationId: existingFlavor.pizzaCustomizationId,
              half: PizzaHalf.HALF_1,
              action: CustomizationAction.ADD,
            });

            // Agregar el nuevo sabor a mitad 2
            nonFlavorSelections.push({
              pizzaCustomizationId: flavorId,
              half: PizzaHalf.HALF_2,
              action: CustomizationAction.ADD,
            });

            onCustomizationChange(nonFlavorSelections);
          }
        }
      },
      [
        selectedPizzaCustomizations,
        flavors,
        onCustomizationChange,
        manualHalvesMode,
      ],
    );

    const toggleIngredient = useCallback(
      (ingredientId: string, half: PizzaHalf, action: CustomizationAction) => {
        const existingIndex = selectedPizzaCustomizations.findIndex(
          (sc) =>
            sc.pizzaCustomizationId === ingredientId &&
            sc.half === half &&
            sc.action === action,
        );

        let newSelections: SelectedPizzaCustomization[];

        if (existingIndex >= 0) {
          newSelections = selectedPizzaCustomizations.filter(
            (_, index) => index !== existingIndex,
          );
        } else {
          // Remover cualquier acción previa del mismo ingrediente en la misma mitad
          newSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !(sc.pizzaCustomizationId === ingredientId && sc.half === half),
          );

          newSelections.push({
            pizzaCustomizationId: ingredientId,
            half,
            action,
          });
        }

        onCustomizationChange(newSelections);
      },
      [selectedPizzaCustomizations, onCustomizationChange],
    );

    const isIngredientSelected = useCallback(
      (
        ingredientId: string,
        half: PizzaHalf,
        action: CustomizationAction,
      ): boolean => {
        return selectedPizzaCustomizations.some(
          (sc) =>
            sc.pizzaCustomizationId === ingredientId &&
            sc.half === half &&
            sc.action === action,
        );
      },
      [selectedPizzaCustomizations],
    );

    // Determinar si mostrar modo mitades (2 sabores o modo manual activado)
    const showHalvesMode =
      selectedFlavors.length === 2 ||
      (manualHalvesMode && selectedFlavors.length <= 1);

    // Returns condicionales al final, después de todos los hooks
    if (loading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator animating size="large" />
          <Text style={styles.loadingText}>Cargando opciones de pizza...</Text>
        </View>
      );
    }

    if (!pizzaConfiguration || pizzaCustomizations.length === 0) {
      return null;
    }

    // Renderizar sección de personalización
    const renderCustomizationSection = (
      half: PizzaHalf,
      sectionTitle: string,
      flavorName?: string,
    ) => {
      const sectionKey =
        half === PizzaHalf.FULL
          ? 'full'
          : half === PizzaHalf.HALF_1
            ? 'half1'
            : 'half2';
      const isExpanded = expandedIngredients[sectionKey];

      // Construir el título dinámico con el formato completo
      const getDynamicTitle = () => {
        const customizationsForHalf = selectedPizzaCustomizations.filter(
          (sc) => sc.half === half,
        );

        const parts: string[] = [];

        // Agregar el sabor si existe
        if (flavorName) {
          parts.push(flavorName);
        } else if (half !== PizzaHalf.FULL) {
          // Para mitades sin sabor
          parts.push('Sin sabor');
        }

        // Filtrar ingredientes
        const addedIngredients: string[] = [];
        const removedIngredients: string[] = [];

        customizationsForHalf.forEach((sc) => {
          const customization = ingredients.find(
            (c) => c.id === sc.pizzaCustomizationId,
          );
          if (customization) {
            if (sc.action === CustomizationAction.ADD) {
              addedIngredients.push(customization.name);
            } else {
              removedIngredients.push(customization.name);
            }
          }
        });

        if (addedIngredients.length > 0) {
          parts.push(`con: ${addedIngredients.join(', ')}`);
        }
        if (removedIngredients.length > 0) {
          parts.push(`sin: ${removedIngredients.join(', ')}`);
        }

        return parts.length > 0
          ? parts.join(' - ')
          : flavorName || 'Sin personalizar';
      };

      return (
        <Card style={styles.optionCard}>
          <Card.Content style={{ paddingVertical: 16, paddingHorizontal: 16 }}>
            <View style={styles.sectionHeader}>
              <Text style={styles.sectionTitle}>
                {sectionTitle}:{' '}
                <Text style={styles.pizzaFormat}>{getDynamicTitle()}</Text>
              </Text>
            </View>

            <Surface style={styles.subsectionSurface} elevation={1}>
              <TouchableRipple
                onPress={() =>
                  setExpandedIngredients((prev) => ({
                    ...prev,
                    [sectionKey]: !prev[sectionKey],
                  }))
                }
                style={{ paddingVertical: 12, paddingHorizontal: 16 }}
              >
                <View style={styles.subsectionHeader}>
                  <Text style={styles.subsectionTitle}>
                    Personalizar Ingredientes
                  </Text>
                  <IconButton
                    icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                    size={20}
                    style={{ margin: -8 }}
                  />
                </View>
              </TouchableRipple>

              {isExpanded && (
                <View style={{ paddingHorizontal: 16, paddingBottom: 12 }}>
                  {ingredients.map((ingredient) => {
                    const isAddSelected = isIngredientSelected(
                      ingredient.id,
                      half,
                      CustomizationAction.ADD,
                    );
                    const isRemoveSelected = isIngredientSelected(
                      ingredient.id,
                      half,
                      CustomizationAction.REMOVE,
                    );
                    const isSelected = isAddSelected || isRemoveSelected;
                    const currentAction = isAddSelected
                      ? CustomizationAction.ADD
                      : CustomizationAction.REMOVE;

                    return (
                      <Surface
                        key={ingredient.id}
                        style={styles.ingredientItem}
                        elevation={0}
                      >
                        <TouchableRipple
                          onPress={() => {
                            if (isSelected) {
                              toggleIngredient(
                                ingredient.id,
                                half,
                                currentAction,
                              );
                            } else {
                              toggleIngredient(
                                ingredient.id,
                                half,
                                CustomizationAction.ADD,
                              );
                            }
                          }}
                          style={{ paddingVertical: 8, paddingHorizontal: 8 }}
                        >
                          <View
                            style={{
                              flexDirection: 'row',
                              alignItems: 'center',
                            }}
                          >
                            <View style={{ flex: 1 }}>
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  gap: 6,
                                }}
                              >
                                <Text style={styles.ingredientLabel}>
                                  {ingredient.name}
                                </Text>
                                <Text style={styles.toppingValueSmall}>
                                  ({ingredient.toppingValue})
                                </Text>
                              </View>
                            </View>
                            {isSelected && (
                              <View style={styles.actionToggle}>
                                <Text
                                  style={[
                                    styles.toggleLabel,
                                    currentAction === CustomizationAction.ADD &&
                                      styles.activeLabel,
                                  ]}
                                >
                                  Agregar
                                </Text>
                                <Switch
                                  value={
                                    currentAction === CustomizationAction.REMOVE
                                  }
                                  onValueChange={(value) => {
                                    const newAction = value
                                      ? CustomizationAction.REMOVE
                                      : CustomizationAction.ADD;
                                    toggleIngredient(
                                      ingredient.id,
                                      half,
                                      newAction,
                                    );
                                  }}
                                  style={styles.switch}
                                />
                                <Text
                                  style={[
                                    styles.toggleLabel,
                                    currentAction ===
                                      CustomizationAction.REMOVE &&
                                      styles.activeLabel,
                                  ]}
                                >
                                  Quitar
                                </Text>
                              </View>
                            )}
                            <RadioButton
                              value={ingredient.id}
                              status={isSelected ? 'checked' : 'unchecked'}
                              onPress={() => {
                                if (isSelected) {
                                  toggleIngredient(
                                    ingredient.id,
                                    half,
                                    currentAction,
                                  );
                                } else {
                                  toggleIngredient(
                                    ingredient.id,
                                    half,
                                    CustomizationAction.ADD,
                                  );
                                }
                              }}
                            />
                          </View>
                        </TouchableRipple>
                      </Surface>
                    );
                  })}
                </View>
              )}
            </Surface>
          </Card.Content>
        </Card>
      );
    };

    return (
      <View style={styles.container}>
        {/* Selección de Sabores */}
        <Card style={styles.optionCard}>
          <Card.Content style={{ paddingVertical: 16, paddingHorizontal: 16 }}>
            <TouchableRipple
              onPress={() => setExpandedFlavors(!expandedFlavors)}
              style={{ marginBottom: expandedFlavors ? 12 : 0 }}
            >
              <View style={styles.sectionHeaderWithSwitch}>
                <View style={{ flex: 1 }}>
                  <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                    <Text style={styles.sectionTitle}>
                      Sabores
                      {selectedFlavors.length > 0 && (
                        <Text style={styles.pizzaFormat}>
                          {' - '}
                          {selectedFlavors
                            .map((sf) => {
                              const flavor = flavors.find(
                                (f) => f.id === sf.pizzaCustomizationId,
                              );
                              return flavor?.name || '';
                            })
                            .join(' / ')}
                        </Text>
                      )}
                    </Text>
                    <IconButton
                      icon={expandedFlavors ? 'chevron-up' : 'chevron-down'}
                      size={20}
                      style={{ margin: -8 }}
                    />
                  </View>
                  {expandedFlavors && (
                    <Text style={styles.helperText}>
                      Selecciona hasta 2 sabores
                    </Text>
                  )}
                </View>
                {expandedFlavors && selectedFlavors.length <= 1 && (
                  <View style={styles.halvesSwitch}>
                    <Text style={styles.switchLabel}>Dividir mitades</Text>
                    <Switch
                      value={manualHalvesMode}
                      onValueChange={(value) => {
                        setManualHalvesMode(value);

                        // Si se activa el modo mitades, convertir las personalizaciones de FULL a HALF_1
                        if (value && selectedFlavors.length <= 1) {
                          const updatedCustomizations =
                            selectedPizzaCustomizations.map((sc) => {
                              if (sc.half === PizzaHalf.FULL) {
                                return { ...sc, half: PizzaHalf.HALF_1 };
                              }
                              return sc;
                            });
                          onCustomizationChange(updatedCustomizations);
                        }
                        // Si se desactiva el modo mitades y solo hay un sabor, convertir todo a FULL
                        else if (!value && selectedFlavors.length === 1) {
                          const updatedCustomizations =
                            selectedPizzaCustomizations.map((sc) => {
                              if (
                                sc.half === PizzaHalf.HALF_1 ||
                                sc.half === PizzaHalf.HALF_2
                              ) {
                                return { ...sc, half: PizzaHalf.FULL };
                              }
                              return sc;
                            });
                          onCustomizationChange(updatedCustomizations);
                        }
                      }}
                    />
                  </View>
                )}
              </View>
            </TouchableRipple>
            {expandedFlavors && (
              <View style={styles.flavorsGrid}>
                {flavors.map((flavor) => {
                  const isSelected = selectedFlavors.some(
                    (sf) => sf.pizzaCustomizationId === flavor.id,
                  );
                  const isDisabled = selectedFlavors.length >= 2 && !isSelected;

                  return (
                    <FlavorItem
                      key={flavor.id}
                      flavor={flavor}
                      isSelected={isSelected}
                      isDisabled={isDisabled}
                      onToggle={handleFlavorToggle}
                      styles={styles}
                      theme={theme}
                    />
                  );
                })}
              </View>
            )}
          </Card.Content>
        </Card>

        {/* Secciones de Personalización */}
        {showHalvesMode ? (
          // Modo mitades (2 sabores o modo manual)
          <>
            {renderCustomizationSection(
              PizzaHalf.HALF_1,
              'Mitad 1',
              selectedFlavors[0]
                ? getFlavorName(selectedFlavors[0].pizzaCustomizationId)
                : undefined,
            )}
            {renderCustomizationSection(
              PizzaHalf.HALF_2,
              'Mitad 2',
              selectedFlavors[1]
                ? getFlavorName(selectedFlavors[1].pizzaCustomizationId)
                : undefined,
            )}
          </>
        ) : (
          // Modo completo (sin sabores o 1 sabor)
          renderCustomizationSection(
            PizzaHalf.FULL,
            'Pizza Completa',
            selectedFlavors[0]
              ? getFlavorName(selectedFlavors[0].pizzaCustomizationId)
              : undefined,
          )
        )}
      </View>
    );
  },
);

const createStyles = (theme: any) =>
  StyleSheet.create({
    container: {
      gap: 8,
    },
    loadingContainer: {
      padding: 32,
      alignItems: 'center',
    },
    loadingText: {
      marginTop: 16,
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    optionCard: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      elevation: 1,
    },
    pizzaFormat: {
      fontSize: 16,
      fontWeight: 'normal',
      color: theme.colors.primary,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 12,
    },
    sectionHeaderWithSwitch: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    halvesSwitch: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    switchLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    sectionTitle: {
      fontSize: 18,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    flavorInline: {
      fontSize: 16,
      fontWeight: 'normal',
      color: theme.colors.primary,
    },
    helperText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 12,
    },
    flavorsGrid: {
      gap: 8,
    },
    flavorChip: {
      backgroundColor: theme.colors.surface,
      borderRadius: 8,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      elevation: 0,
      overflow: 'hidden',
    },
    flavorChipSelected: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    flavorChipDisabled: {
      opacity: 0.5,
    },
    flavorLabel: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    flavorLabelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    ingredientsText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    toppingValue: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
    },
    toppingValueSmall: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.5,
    },
    subsectionSurface: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 8,
      marginTop: 8,
    },
    subsectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    subsectionTitle: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    ingredientItem: {
      backgroundColor: 'transparent',
      marginTop: 4,
    },
    ingredientLabel: {
      fontSize: 14,
      color: theme.colors.onSurface,
    },
    actionToggle: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    toggleLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
    },
    activeLabel: {
      color: theme.colors.primary,
      fontWeight: 'bold',
    },
    switch: {
      marginHorizontal: 8,
      transform: [{ scale: 1.2 }],
    },
    priceInfoText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
  });

PizzaCustomizationSection.displayName = 'PizzaCustomizationSection';

export default PizzaCustomizationSection;

================
File: app/src/modules/orders/components/PrinterSelectionModal.tsx
================
import React, { useMemo } from 'react';
import { StyleSheet, FlatList, ListRenderItemInfo } from 'react-native';
import { Modal, Portal, List, Divider, Appbar } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { usePrintersQuery } from '../../printers/hooks/usePrintersQueries';
import type { ThermalPrinter } from '../../printers/types/printer.types';
import { useListState } from '../../../app/hooks/useListState';

interface PrinterSelectionModalProps {
  visible: boolean;
  onDismiss: () => void;
  onPrinterSelect: (printer: ThermalPrinter) => void;
  title?: string;
}

const PrinterSelectionModal: React.FC<PrinterSelectionModalProps> = ({
  visible,
  onDismiss,
  onPrinterSelect,
  title = 'Seleccionar Impresora',
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  const {
    data: printersResponse,
    isLoading,
    isError,
    error: _error,
    refetch: _refetch,
  } = usePrintersQuery(
    { isActive: true, limit: 100, page: 1 },
    { enabled: visible },
  );

  const printers = useMemo(
    () => printersResponse?.data ?? [],
    [printersResponse],
  );

  const renderPrinterItem = ({ item }: ListRenderItemInfo<ThermalPrinter>) => (
    <List.Item
      title={item.name}
      description={`Tipo: ${item.connectionType}${item.ipAddress ? ` - IP: ${item.ipAddress}` : ''}`}
      left={(props) => <List.Icon {...props} icon="printer" />}
      onPress={() => onPrinterSelect(item)}
      style={styles.listItem}
      titleStyle={styles.itemTitle}
      descriptionStyle={styles.itemDescription}
    />
  );

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: printers,
    emptyConfig: {
      title: 'No hay impresoras activas',
      message: 'No hay impresoras activas configuradas.',
      icon: 'printer-off',
    },
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
      >
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction
            onPress={onDismiss}
            color={theme.colors.onSurface}
          />
          <Appbar.Content title={title} titleStyle={styles.appBarTitle} />
        </Appbar.Header>

        <FlatList
          data={printers}
          renderItem={renderPrinterItem}
          keyExtractor={(item: ThermalPrinter) => item.id}
          ItemSeparatorComponent={() => <Divider style={styles.divider} />}
          contentContainerStyle={styles.listContentContainer}
          ListEmptyComponent={ListEmptyComponent}
        />
      </Modal>
    </Portal>
  );
};

// --- Estilos ---
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '90%',
      maxHeight: '70%',
      alignSelf: 'center',
      borderRadius: theme.roundness * 2,
      elevation: 5,
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column',
    },
    appBar: {
      backgroundColor: theme.colors.elevation.level2,
    },
    appBarTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
    },
    listContentContainer: {
      paddingBottom: theme.spacing.m,
    },
    centeredView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
      minHeight: 150,
    },
    statusText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      marginTop: theme.spacing.m,
      color: theme.colors.error,
      textAlign: 'center',
      marginBottom: theme.spacing.m,
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      paddingHorizontal: theme.spacing.m,
    },
    itemTitle: {
      fontWeight: '500',
    },
    itemDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    divider: {
      height: StyleSheet.hairlineWidth,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: theme.spacing.m,
    },
  });

export default PrinterSelectionModal;

================
File: app/src/modules/orders/components/ProductCustomizationModal.tsx
================
import React, { useState, useEffect, useMemo, useCallback, memo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  RadioButton,
  Divider,
  Appbar, // Importar Appbar
  TouchableRipple,
  IconButton,
  Card,
  Chip,
  Surface,
} from 'react-native-paper';
import { useForm, Controller, FieldValues } from 'react-hook-form';
import { useAppTheme } from '@/app/styles/theme';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput'; // Importar SpeechRecognitionInput
import {
  FullMenuProduct as Product,
  ProductVariant,
  Modifier,
  FullMenuModifierGroup,
} from '../types/orders.types';
import { CartItemModifier, CartItem } from '../stores/useCartStore';
import { AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import type {
  PizzaCustomization,
  PizzaConfiguration,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import {
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import PizzaCustomizationSection from './PizzaCustomizationSection';

interface ProductCustomizationModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product;
  editingItem?: CartItem | null;
  onAddToCart: (
    product: Product,
    quantity: number,
    variantId?: string,
    modifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  onUpdateItem?: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
}

interface NotesFormData extends FieldValues {
  preparationNotes: string;
}

const ProductCustomizationModal = memo<ProductCustomizationModalProps>(
  ({ visible, onDismiss, product, editingItem, onAddToCart, onUpdateItem }) => {
    const theme = useAppTheme();
    const styles = useMemo(() => createStyles(theme), [theme]);
    const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

    const { control, reset, watch } = useForm<NotesFormData>({
      defaultValues: { preparationNotes: '' },
    });
    const watchedPreparationNotes = watch('preparationNotes');

    const [selectedVariantId, setSelectedVariantId] = useState<
      string | undefined
    >(
      product &&
        product.variants &&
        Array.isArray(product.variants) &&
        product.variants.length > 0
        ? product.variants[0].id
        : undefined,
    );
    const [selectedModifiersByGroup, setSelectedModifiersByGroup] = useState<
      Record<string, CartItemModifier[]>
    >({});

    const selectedModifiers = useMemo(() => {
      return Object.values(selectedModifiersByGroup).flat();
    }, [selectedModifiersByGroup]);

    // Pre-calcular si el producto tiene variantes o modificadores
    const hasVariants = useMemo(
      () =>
        product?.variants &&
        Array.isArray(product.variants) &&
        product.variants.length > 0,
      [product?.variants],
    );

    const [quantity, setQuantity] = useState(1);
    const [showExitConfirmation, setShowExitConfirmation] = useState(false);
    const [hasChanges, setHasChanges] = useState(false);
    const [validationErrors, setValidationErrors] = useState<
      Record<string, string>
    >({});

    // Estados para pizzas
    const [pizzaCustomizations, setPizzaCustomizations] = useState<
      PizzaCustomization[]
    >([]);
    const [pizzaConfiguration, setPizzaConfiguration] =
      useState<PizzaConfiguration | null>(null);
    const [selectedPizzaCustomizations, setSelectedPizzaCustomizations] =
      useState<SelectedPizzaCustomization[]>([]);

    // Función para calcular el precio extra de las pizzas
    const calculatePizzaExtraCost = useCallback(() => {
      if (!product.isPizza || !pizzaConfiguration) return 0;

      let totalToppingValue = 0;

      // Solo contar customizaciones con action = ADD
      const addedCustomizations = selectedPizzaCustomizations.filter(
        (c) => c.action === CustomizationAction.ADD,
      );

      for (const selected of addedCustomizations) {
        const customization = pizzaCustomizations.find(
          (c) => c.id === selected.pizzaCustomizationId,
        );
        if (!customization) continue;

        if (selected.half === PizzaHalf.FULL) {
          // Pizza completa suma el toppingValue completo
          totalToppingValue += customization.toppingValue;
        } else {
          // Media pizza suma la mitad del toppingValue
          totalToppingValue += customization.toppingValue / 2;
        }
      }

      // Solo cobrar por toppings que excedan los incluidos
      if (totalToppingValue > pizzaConfiguration.includedToppings) {
        const extraToppings =
          totalToppingValue - pizzaConfiguration.includedToppings;
        return extraToppings * Number(pizzaConfiguration.extraToppingCost);
      }

      return 0;
    }, [
      product.isPizza,
      pizzaConfiguration,
      selectedPizzaCustomizations,
      pizzaCustomizations,
    ]);

    // Función para verificar si hay cambios
    const checkForChanges = useCallback(() => {
      if (!editingItem) return false;

      // Comparar cantidad
      if (quantity !== editingItem.quantity) return true;

      // Comparar variante
      if (selectedVariantId !== editingItem.variantId) return true;

      // Comparar notas
      if (watchedPreparationNotes !== (editingItem.preparationNotes || ''))
        return true;

      // Comparar modificadores
      const currentModifierIds = selectedModifiers.map((m) => m.id).sort();
      const originalModifierIds = editingItem.modifiers.map((m) => m.id).sort();

      if (currentModifierIds.length !== originalModifierIds.length) return true;

      for (let i = 0; i < currentModifierIds.length; i++) {
        if (currentModifierIds[i] !== originalModifierIds[i]) return true;
      }

      return false;
    }, [
      editingItem,
      quantity,
      selectedVariantId,
      watchedPreparationNotes,
      selectedModifiers,
    ]);

    useEffect(() => {
      if (!product) return;

      if (editingItem) {
        // Si estamos editando, usar los valores del item
        setSelectedVariantId(editingItem.variantId);
        setQuantity(editingItem.quantity);
        reset({ preparationNotes: editingItem.preparationNotes || '' });

        // Reconstruir los modificadores por grupo
        const modifiersByGroup: Record<string, CartItemModifier[]> = {};
        if (editingItem.modifiers && product.modifierGroups) {
          editingItem.modifiers.forEach((mod) => {
            // Encontrar a qué grupo pertenece este modificador
            const group = product.modifierGroups?.find((g) =>
              g.productModifiers?.some((pm) => pm.id === mod.id),
            );
            if (group) {
              if (!modifiersByGroup[group.id]) {
                modifiersByGroup[group.id] = [];
              }
              modifiersByGroup[group.id].push(mod);
            }
          });
        }
        setSelectedModifiersByGroup(modifiersByGroup);
      } else {
        // Si es un nuevo item, valores por defecto
        if (
          product.variants &&
          Array.isArray(product.variants) &&
          product.variants.length > 0
        ) {
          setSelectedVariantId(product.variants[0].id);
        } else {
          setSelectedVariantId(undefined);
        }

        // Aplicar modificadores por defecto
        const defaultModifiersByGroup: Record<string, CartItemModifier[]> = {};

        if (product.modifierGroups) {
          product.modifierGroups.forEach((group) => {
            const defaultModifiers: CartItemModifier[] = [];

            if (group.productModifiers) {
              group.productModifiers.forEach((modifier) => {
                if (modifier.isDefault && modifier.isActive) {
                  defaultModifiers.push({
                    id: modifier.id,
                    modifierGroupId: group.id,
                    name: modifier.name,
                    price: Number(modifier.price) || 0,
                  });
                }
              });
            }

            if (defaultModifiers.length > 0) {
              // Respetar el límite máximo de selecciones
              const maxSelections =
                group.maxSelections || defaultModifiers.length;
              defaultModifiersByGroup[group.id] = defaultModifiers.slice(
                0,
                maxSelections,
              );
            }
          });
        }

        setSelectedModifiersByGroup(defaultModifiersByGroup);
        setQuantity(1);
        reset({ preparationNotes: '' });
      }
    }, [product, editingItem, reset]);

    // Usar datos de pizza que ya vienen con el producto
    useEffect(() => {
      if (!product || !visible) return;

      // Si es una pizza, usar los datos que ya vienen con el producto
      if (product.isPizza) {
        if (product.pizzaConfiguration) {
          setPizzaConfiguration(product.pizzaConfiguration);
        }
        if (product.pizzaCustomizations) {
          setPizzaCustomizations(product.pizzaCustomizations);
        }

        // Si estamos editando, cargar las personalizaciones seleccionadas
        if (editingItem && editingItem.selectedPizzaCustomizations) {
          setSelectedPizzaCustomizations(
            editingItem.selectedPizzaCustomizations,
          );
        }
      }
    }, [product, visible, editingItem]);

    // Detectar cambios
    useEffect(() => {
      if (editingItem) {
        setHasChanges(checkForChanges());
      }
    }, [editingItem, checkForChanges]);

    // Validar en tiempo real
    useEffect(() => {
      const errors: Record<string, string> = {};

      if (product.modifierGroups) {
        product.modifierGroups.forEach((group) => {
          const selectedInGroup = selectedModifiersByGroup[group.id] || [];
          const selectedCount = selectedInGroup.length;
          const minRequired = Math.max(
            group.minSelections || 0,
            group.isRequired ? 1 : 0,
          );

          if (selectedCount < minRequired) {
            if (group.isRequired && minRequired === 1) {
              errors[group.id] = 'Requerido';
            } else {
              errors[group.id] = `Mínimo ${minRequired}`;
            }
          }
        });
      }

      setValidationErrors(errors);
    }, [product, selectedModifiersByGroup]);

    const handleVariantSelect = useCallback((variantId: string) => {
      setSelectedVariantId(variantId);
    }, []);

    const handleModifierToggle = (
      modifier: Modifier,
      group: FullMenuModifierGroup,
    ) => {
      const currentGroupModifiers = selectedModifiersByGroup[group.id] || [];
      const isSelected = currentGroupModifiers.some(
        (mod) => mod.id === modifier.id,
      );

      const updatedModifiersByGroup = { ...selectedModifiersByGroup };

      if (isSelected) {
        // Verificar si al deseleccionar quedaríamos por debajo del mínimo
        const newCount = currentGroupModifiers.length - 1;
        const minRequired = Math.max(
          group.minSelections || 0,
          group.isRequired ? 1 : 0,
        );

        if (newCount < minRequired) {
          showSnackbar({
            message: `No puedes deseleccionar. "${group.name}" requiere al menos ${minRequired} ${minRequired === 1 ? 'opción seleccionada' : 'opciones seleccionadas'}.`,
            type: 'warning',
          });
          return;
        }

        updatedModifiersByGroup[group.id] = currentGroupModifiers.filter(
          (mod) => mod.id !== modifier.id,
        );
      } else {
        const newModifier: CartItemModifier = {
          id: modifier.id,
          modifierGroupId: group.id,
          name: modifier.name,
          price: Number(modifier.price) || 0,
        };

        if (!group.allowMultipleSelections) {
          updatedModifiersByGroup[group.id] = [newModifier];
        } else {
          if (currentGroupModifiers.length < (group.maxSelections || 0)) {
            updatedModifiersByGroup[group.id] = [
              ...currentGroupModifiers,
              newModifier,
            ];
          } else {
            showSnackbar({
              message: `Solo puedes seleccionar hasta ${group.maxSelections || 0} opciones en ${group.name}`,
              type: 'warning',
            });
            return;
          }
        }
      }

      setSelectedModifiersByGroup(updatedModifiersByGroup);
    };

    const handleAddToCart = () => {
      // Validar grupos requeridos y límites de selección
      if (product.modifierGroups) {
        for (const group of product.modifierGroups) {
          const selectedInGroup = selectedModifiersByGroup[group.id] || [];
          const selectedCount = selectedInGroup.length;

          // Validar grupos requeridos y mínimo de selecciones
          if (
            group.isRequired ||
            (group.minSelections && group.minSelections > 0)
          ) {
            const minRequired = Math.max(
              group.minSelections || 0,
              group.isRequired ? 1 : 0,
            );

            if (selectedCount < minRequired) {
              let message = '';
              if (group.isRequired && minRequired === 1) {
                message = `"${group.name}" es requerido. Debes seleccionar al menos una opción.`;
              } else if (minRequired > 1) {
                message = `Debes seleccionar al menos ${minRequired} ${minRequired === 1 ? 'opción' : 'opciones'} en "${group.name}"`;
              } else {
                message = `Debes seleccionar al menos una opción en "${group.name}"`;
              }

              showSnackbar({
                message,
                type: 'error',
              });
              return;
            }
          }

          // Validar máximo de selecciones (esto ya se valida en handleModifierToggle, pero por si acaso)
          if (group.maxSelections && selectedCount > group.maxSelections) {
            showSnackbar({
              message: `No puedes seleccionar más de ${group.maxSelections} ${group.maxSelections === 1 ? 'opción' : 'opciones'} en "${group.name}"`,
              type: 'error',
            });
            return;
          }
        }
      }

      if (editingItem && onUpdateItem) {
        // Si estamos editando, actualizar el item existente
        const variant = product.variants?.find(
          (v) => v.id === selectedVariantId,
        );
        const unitPrice = variant
          ? Number(variant.price)
          : Number(product.price) || 0;

        onUpdateItem(
          editingItem.id,
          quantity,
          selectedModifiers,
          watchedPreparationNotes,
          selectedVariantId,
          variant?.name,
          unitPrice,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
      } else {
        // Si es un nuevo item, agregarlo al carrito
        onAddToCart(
          product,
          quantity,
          selectedVariantId,
          selectedModifiers,
          watchedPreparationNotes,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
      }
      onDismiss();
    };

    const increaseQuantity = useCallback(
      () => setQuantity((prev) => prev + 1),
      [],
    );
    const decreaseQuantity = useCallback(
      () => setQuantity((prev) => (prev > 1 ? prev - 1 : 1)),
      [],
    );

    const handleDismiss = useCallback(() => {
      if (editingItem && hasChanges) {
        setShowExitConfirmation(true);
      } else {
        onDismiss();
      }
    }, [editingItem, hasChanges, onDismiss]);

    const handleConfirmExit = useCallback(() => {
      setShowExitConfirmation(false);
      onDismiss();
    }, [onDismiss]);

    const handleCancelExit = useCallback(() => {
      setShowExitConfirmation(false);
    }, []);

    if (!product || !visible) {
      return null;
    }

    const selectedVariant = useMemo(
      () =>
        hasVariants
          ? product.variants.find(
              (variant: ProductVariant) => variant.id === selectedVariantId,
            )
          : undefined,
      [hasVariants, product?.variants, selectedVariantId],
    );

    const basePrice = selectedVariant
      ? Number(selectedVariant.price)
      : Number(product.price) || 0;
    const modifiersPrice = selectedModifiers.reduce(
      (sum, mod) => sum + Number(mod.price || 0),
      0,
    );
    const pizzaExtraCost = calculatePizzaExtraCost();
    const totalPrice = (basePrice + modifiersPrice + pizzaExtraCost) * quantity;

    if (!visible) {
      return null;
    }

    return (
      <>
        <Portal>
          <Modal
            visible={visible}
            onDismiss={handleDismiss}
            contentContainerStyle={styles.modalContent}
          >
            {/* Encabezado Refactorizado con Appbar */}
            <Appbar.Header style={styles.appBar} elevated>
              <Appbar.BackAction
                onPress={handleDismiss}
                color={theme.colors.onSurface}
              />
              <Appbar.Content
                title={product?.name || 'Producto'}
                titleStyle={styles.appBarTitle}
                style={styles.appBarContent}
              />
              {/* Espaciador si no hay acción a la derecha */}
              <View style={styles.appBarSpacer} />
            </Appbar.Header>

            <ScrollView
              style={styles.scrollView}
              contentContainerStyle={{ paddingBottom: 20 }}
              showsVerticalScrollIndicator={true}
              keyboardShouldPersistTaps="handled"
              nestedScrollEnabled={true}
            >
              {product.hasVariants &&
                product.variants &&
                Array.isArray(product.variants) &&
                product.variants.length > 0 && (
                  <Card style={styles.sectionCard}>
                    <Card.Content>
                      <View style={styles.sectionHeader}>
                        <Text style={styles.sectionTitle}>Variantes</Text>
                        <Chip mode="flat" compact style={styles.requiredChip}>
                          Requerido
                        </Chip>
                      </View>
                      <RadioButton.Group
                        onValueChange={(value) => handleVariantSelect(value)}
                        value={selectedVariantId || ''}
                      >
                        {product.variants.map((variant: ProductVariant) => (
                          <Surface
                            key={variant.id}
                            style={[
                              styles.variantSurface,
                              selectedVariantId === variant.id &&
                                styles.variantSurfaceSelected,
                              !variant.isActive &&
                                styles.inactiveVariantSurface,
                            ]}
                            elevation={
                              selectedVariantId === variant.id &&
                              variant.isActive
                                ? 2
                                : 0
                            }
                          >
                            <TouchableRipple
                              onPress={() =>
                                variant.isActive &&
                                handleVariantSelect(variant.id)
                              }
                              disabled={!variant.isActive}
                              style={styles.variantTouchable}
                            >
                              <View style={styles.variantRow}>
                                <RadioButton
                                  value={variant.id}
                                  status={
                                    selectedVariantId === variant.id
                                      ? 'checked'
                                      : 'unchecked'
                                  }
                                  onPress={() =>
                                    variant.isActive &&
                                    handleVariantSelect(variant.id)
                                  }
                                  disabled={!variant.isActive}
                                />
                                <Text
                                  style={[
                                    styles.variantName,
                                    !variant.isActive && styles.inactiveText,
                                  ]}
                                >
                                  {variant.name}
                                  {!variant.isActive && ' (No disponible)'}
                                </Text>
                                <Text
                                  style={[
                                    styles.variantPrice,
                                    !variant.isActive && styles.inactiveText,
                                  ]}
                                >
                                  ${Number(variant.price).toFixed(2)}
                                </Text>
                              </View>
                            </TouchableRipple>
                          </Surface>
                        ))}
                      </RadioButton.Group>
                    </Card.Content>
                  </Card>
                )}

              {/* Sección de Personalización de Pizza - Después de variantes */}
              {product.isPizza && (
                <PizzaCustomizationSection
                  pizzaCustomizations={pizzaCustomizations}
                  pizzaConfiguration={pizzaConfiguration}
                  selectedPizzaCustomizations={selectedPizzaCustomizations}
                  onCustomizationChange={setSelectedPizzaCustomizations}
                  loading={false}
                />
              )}

              {product.modifierGroups &&
                Array.isArray(product.modifierGroups) &&
                product.modifierGroups.length > 0 &&
                product.modifierGroups.map((group: FullMenuModifierGroup) => (
                  <Card key={group.id} style={styles.sectionCard}>
                    <Card.Content>
                      <View style={styles.sectionHeader}>
                        <View style={styles.groupTitleContainer}>
                          <Text style={styles.groupTitle}>{group.name}</Text>
                          <View style={styles.selectionInfo}>
                            {group.minSelections !== undefined &&
                              group.maxSelections !== undefined && (
                                <Text style={styles.selectionRules}>
                                  {(group.minSelections || 0) === 0 &&
                                  group.maxSelections === 1
                                    ? 'Hasta 1 opción'
                                    : (group.minSelections || 0) ===
                                        group.maxSelections
                                      ? `Elegir ${group.maxSelections}`
                                      : `${group.minSelections || 0}-${group.maxSelections} opciones`}
                                </Text>
                              )}
                            {group.allowMultipleSelections && (
                              <Text style={styles.selectedCount}>
                                (
                                {
                                  (selectedModifiersByGroup[group.id] || [])
                                    .length
                                }{' '}
                                seleccionadas)
                              </Text>
                            )}
                          </View>
                        </View>
                        <View style={styles.chipContainer}>
                          {validationErrors[group.id] && (
                            <Chip
                              mode="flat"
                              compact
                              style={styles.errorChip}
                              icon="alert-circle"
                            >
                              {validationErrors[group.id]}
                            </Chip>
                          )}
                          <Chip
                            mode="flat"
                            compact
                            style={
                              group.isRequired
                                ? styles.requiredChip
                                : styles.optionalChip
                            }
                          >
                            {group.isRequired ? 'Requerido' : 'Opcional'}
                          </Chip>
                        </View>
                      </View>

                      {group.allowMultipleSelections ? (
                        <View style={styles.modifiersContainer}>
                          {Array.isArray(group.productModifiers) &&
                            group.productModifiers.map((modifier: Modifier) => {
                              const groupModifiers =
                                selectedModifiersByGroup[group.id] || [];
                              const isSelected = groupModifiers.some(
                                (mod) => mod.id === modifier.id,
                              );

                              return (
                                <Surface
                                  key={modifier.id}
                                  style={[
                                    styles.modifierSurface,
                                    isSelected &&
                                      styles.modifierSurfaceSelected,
                                    !modifier.isActive &&
                                      styles.inactiveModifierSurface,
                                  ]}
                                  elevation={
                                    isSelected && modifier.isActive ? 1 : 0
                                  }
                                >
                                  <TouchableRipple
                                    onPress={() =>
                                      modifier.isActive &&
                                      handleModifierToggle(modifier, group)
                                    }
                                    disabled={!modifier.isActive}
                                    style={styles.modifierTouchable}
                                  >
                                    <View style={styles.modifierRow}>
                                      <RadioButton
                                        value={modifier.id}
                                        status={
                                          isSelected ? 'checked' : 'unchecked'
                                        }
                                        disabled={!modifier.isActive}
                                        onPress={() =>
                                          modifier.isActive &&
                                          handleModifierToggle(modifier, group)
                                        }
                                      />
                                      <Text
                                        style={[
                                          styles.modifierName,
                                          !modifier.isActive &&
                                            styles.inactiveText,
                                        ]}
                                      >
                                        {modifier.name}
                                        {!modifier.isActive &&
                                          ' (No disponible)'}
                                      </Text>
                                      {Number(modifier.price) > 0 && (
                                        <Text
                                          style={[
                                            styles.modifierPrice,
                                            !modifier.isActive &&
                                              styles.inactiveText,
                                          ]}
                                        >
                                          +${Number(modifier.price).toFixed(2)}
                                        </Text>
                                      )}
                                    </View>
                                  </TouchableRipple>
                                </Surface>
                              );
                            })}
                        </View>
                      ) : (
                        <RadioButton.Group
                          onValueChange={(value) => {
                            const modifier = group.productModifiers?.find(
                              (m: Modifier) => m.id === value,
                            );
                            if (modifier) {
                              handleModifierToggle(modifier, group);
                            }
                          }}
                          value={
                            selectedModifiersByGroup[group.id]?.[0]?.id || ''
                          }
                        >
                          <View style={styles.modifiersContainer}>
                            {Array.isArray(group.productModifiers) &&
                              group.productModifiers.map(
                                (modifier: Modifier) => {
                                  const isSelected =
                                    selectedModifiersByGroup[group.id]?.[0]
                                      ?.id === modifier.id;

                                  return (
                                    <Surface
                                      key={modifier.id}
                                      style={[
                                        styles.modifierSurface,
                                        isSelected &&
                                          styles.modifierSurfaceSelected,
                                        !modifier.isActive &&
                                          styles.inactiveModifierSurface,
                                      ]}
                                      elevation={
                                        isSelected && modifier.isActive ? 1 : 0
                                      }
                                    >
                                      <TouchableRipple
                                        onPress={() =>
                                          modifier.isActive &&
                                          handleModifierToggle(modifier, group)
                                        }
                                        disabled={!modifier.isActive}
                                        style={styles.modifierTouchable}
                                      >
                                        <View style={styles.modifierRow}>
                                          <RadioButton
                                            value={modifier.id}
                                            status={
                                              isSelected
                                                ? 'checked'
                                                : 'unchecked'
                                            }
                                            disabled={!modifier.isActive}
                                            onPress={() =>
                                              modifier.isActive &&
                                              handleModifierToggle(
                                                modifier,
                                                group,
                                              )
                                            }
                                          />
                                          <Text
                                            style={[
                                              styles.modifierName,
                                              !modifier.isActive &&
                                                styles.inactiveText,
                                            ]}
                                          >
                                            {modifier.name}
                                            {!modifier.isActive &&
                                              ' (No disponible)'}
                                          </Text>
                                          {Number(modifier.price) > 0 && (
                                            <Text
                                              style={[
                                                styles.modifierPrice,
                                                !modifier.isActive &&
                                                  styles.inactiveText,
                                              ]}
                                            >
                                              +$
                                              {Number(modifier.price).toFixed(
                                                2,
                                              )}
                                            </Text>
                                          )}
                                        </View>
                                      </TouchableRipple>
                                    </Surface>
                                  );
                                },
                              )}
                          </View>
                        </RadioButton.Group>
                      )}
                    </Card.Content>
                  </Card>
                ))}

              {/* Sección Cantidad - Mejorada */}
              <Card style={styles.sectionCard}>
                <Card.Content>
                  <Text style={styles.sectionTitle}>Cantidad</Text>
                  <View style={styles.quantityContainer}>
                    <IconButton
                      icon="minus-circle-outline"
                      size={36}
                      onPress={decreaseQuantity}
                      style={[
                        styles.quantityIconButton,
                        quantity <= 1 && styles.quantityIconButtonDisabled,
                      ]}
                      iconColor={
                        quantity <= 1
                          ? theme.colors.onSurfaceDisabled
                          : theme.colors.primary
                      }
                      disabled={quantity <= 1}
                    />
                    <Surface style={styles.quantityBadge} elevation={1}>
                      <Text style={styles.quantityText}>{quantity}</Text>
                    </Surface>
                    <IconButton
                      icon="plus-circle-outline"
                      size={36}
                      onPress={increaseQuantity}
                      style={styles.quantityIconButton}
                      iconColor={theme.colors.primary}
                    />
                  </View>
                </Card.Content>
              </Card>

              {/* Sección Notas de Preparación - Mejorada */}
              <Card style={styles.sectionCard}>
                <Card.Content>
                  <Controller
                    control={control}
                    name="preparationNotes"
                    render={({ field: { onChange, value } }) => (
                      <SpeechRecognitionInput
                        key="preparation-notes-input"
                        label="Notas de Preparación"
                        value={value}
                        onChangeText={onChange}
                        multiline
                        numberOfLines={2}
                        style={styles.preparationInput}
                        speechLang="es-MX"
                      />
                    )}
                  />
                </Card.Content>
              </Card>

              {/* Sección Resumen - Mejorada */}
              <Card style={[styles.sectionCard, styles.summaryCard]}>
                <Card.Content>
                  <Text style={styles.sectionTitle}>Resumen del pedido</Text>
                  <View style={styles.summaryContent}>
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Precio base:</Text>
                      <Text style={styles.summaryValue}>
                        ${basePrice.toFixed(2)}
                      </Text>
                    </View>
                    {selectedModifiers.length > 0 && (
                      <View style={styles.summaryRow}>
                        <Text style={styles.summaryLabel}>Adicionales:</Text>
                        <Text style={styles.summaryValue}>
                          +${modifiersPrice.toFixed(2)}
                        </Text>
                      </View>
                    )}
                    {pizzaExtraCost > 0 && (
                      <View style={styles.summaryRow}>
                        <Text style={styles.summaryLabel}>Toppings extra:</Text>
                        <Text style={styles.summaryValue}>
                          +${pizzaExtraCost.toFixed(2)}
                        </Text>
                      </View>
                    )}
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Cantidad:</Text>
                      <Text style={styles.summaryValue}>×{quantity}</Text>
                    </View>
                    <Divider style={styles.summaryDivider} />
                    <View style={[styles.summaryRow, styles.totalRow]}>
                      <Text style={styles.totalLabel}>Total:</Text>
                      <Text style={styles.totalValue}>
                        ${totalPrice.toFixed(2)}
                      </Text>
                    </View>
                  </View>
                </Card.Content>
              </Card>
            </ScrollView>

            {/* Footer Button - Estilo OrderCartDetail */}
            <View style={styles.footer}>
              <Button
                mode="contained"
                onPress={handleAddToCart}
                style={styles.confirmButton}
                icon={editingItem ? 'cart-check' : 'cart-plus'}
              >
                {editingItem
                  ? `Actualizar Item - $${totalPrice.toFixed(2)}`
                  : `Agregar al Carrito - $${totalPrice.toFixed(2)}`}
              </Button>
            </View>
          </Modal>
        </Portal>

        {/* ConfirmationModal fuera del Portal principal */}
        <Portal>
          <ConfirmationModal
            visible={showExitConfirmation}
            onDismiss={handleCancelExit}
            onConfirm={handleConfirmExit}
            title="¿Descartar cambios?"
            message="Tienes cambios sin guardar. ¿Estás seguro de que quieres salir?"
            confirmText="Descartar"
            cancelText="Cancelar"
            confirmButtonColor={theme.colors.error}
          />
        </Portal>
      </>
    );
  },
);

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '100%',
      height: '100%',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0,
    },
    // Estilos del Appbar
    appBar: {
      backgroundColor: theme.colors.elevation.level2, // Coincidir con OrderHeader
    },
    appBarTitle: {
      // Estilo para el TÍTULO dentro de Appbar.Content
      ...theme.fonts.titleMedium, // Fuente consistente con OrderHeader
      color: theme.colors.onSurface,
      fontWeight: 'bold', // Añadir negritas al título
      // textAlign: 'center', // El centrado lo maneja appBarContent
      // flex: 1, // Quitar flex para permitir centrado vertical por appBarContent
    },
    appBarContent: {
      // Contenedor del título
      flex: 1, // Ocupar espacio disponible para centrar
      justifyContent: 'center', // Centrar verticalmente el contenido (título)
      alignItems: 'center', // Centrar horizontalmente el contenido (título)
      // marginLeft: -48, // Compensar el botón de back si es necesario (ajustar)
    },
    appBarSpacer: {
      // Espaciador para equilibrar el botón de retroceso
      width: 48, // Ancho estándar de IconButton
    },
    // --- Fin estilos Appbar ---
    modifierGroup: {
      marginBottom: theme.spacing.s,
    },
    modifierGroupHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    groupTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    groupDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    requiredText: {
      fontSize: 12,
      color: theme.colors.error,
      fontWeight: '500',
    },
    optionalText: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '500',
    },
    selectionRules: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.xs,
      fontStyle: 'italic',
    },
    selectionInfo: {
      marginTop: 2,
    },
    selectedCount: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '500',
      marginTop: 2,
    },
    productImage: {
      height: 150,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.m,
    },
    imagePlaceholder: {
      backgroundColor: theme.colors.surfaceVariant,
      justifyContent: 'center',
      alignItems: 'center',
    },
    placeholderText: {
      fontSize: 50,
      color: theme.colors.onSurfaceVariant,
    },
    scrollView: {
      flex: 1,
      padding: theme.spacing.m,
    },
    section: {
      marginBottom: theme.spacing.s,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    // Nuevos estilos para Cards
    sectionCard: {
      marginBottom: theme.spacing.m,
      borderRadius: theme.roundness * 2,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    groupTitleContainer: {
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
      marginLeft: theme.spacing.s,
    },
    optionalChip: {
      backgroundColor: theme.colors.secondaryContainer,
      marginLeft: theme.spacing.s,
    },
    chipContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    errorChip: {
      backgroundColor: theme.colors.errorContainer,
      marginRight: theme.spacing.xs,
    },
    // Estilos para variantes
    variantSurface: {
      marginBottom: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    variantSurfaceSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    variantTouchable: {
      padding: 0,
    },
    variantRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    variantName: {
      flex: 1,
      fontSize: 16,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    // Estilos para modificadores
    modifiersContainer: {
      marginTop: theme.spacing.xs,
    },
    modifierSurface: {
      marginBottom: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    modifierSurfaceSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    modifierTouchable: {
      padding: 0,
    },
    modifierRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    modifierName: {
      flex: 1,
      fontSize: 15,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    // Estilos de cantidad mejorados
    quantityBadge: {
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.primaryContainer,
    },
    quantityIconButtonDisabled: {
      opacity: 0.5,
    },
    // Estilos de resumen mejorados
    summaryCard: {
      backgroundColor: theme.dark
        ? theme.colors.elevation.level3
        : theme.colors.secondaryContainer,
      borderWidth: theme.dark ? 1 : 0,
      borderColor: theme.dark ? theme.colors.outlineVariant : undefined,
    },
    summaryContent: {
      marginTop: theme.spacing.xs,
    },
    summaryLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    summaryValue: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    summaryDivider: {
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.onSurfaceVariant,
      opacity: 0.3,
    },
    optionContainer: {
      marginBottom: 2,
    },
    optionTouchable: {
      paddingVertical: 4,
    },
    optionRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 8,
      paddingVertical: 8,
    },
    optionContent: {
      // Contenedor solo para el título del modificador (Checkbox)
      flex: 1, // Ocupa el espacio restante
      justifyContent: 'center', // Centra verticalmente el texto si es necesario
      // Quitar justifyContent: 'space-between'
      // alignItems: "center", // Ya está en optionRow
      // paddingRight: 8, // No necesario si el precio está fuera
    },
    checkbox: {
      marginRight: 8,
    },
    optionDivider: {
      height: 1,
      backgroundColor: theme.colors.outlineVariant,
    },
    radioItem: {
      flex: 1,
      paddingVertical: 4,
    },
    modifierTitle: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface, // Color estándar para texto
    },
    variantPrice: {
      // Estilo específico para precio de variante
      fontSize: 14,
      fontWeight: 'bold',
      color: theme.colors.onSurfaceVariant, // Color secundario consistente
      marginLeft: 'auto',
      marginRight: 8,
    },
    inactiveVariantSurface: {
      opacity: 0.6,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    inactiveModifierSurface: {
      opacity: 0.6,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    inactiveText: {
      color: theme.colors.onSurfaceDisabled,
      textDecorationLine: 'line-through',
    },
    modifierPrice: {
      // Estilo para precio de modificador (Checkbox y Radio)
      fontSize: 14,
      fontWeight: 'bold',
      color: theme.colors.onSurfaceVariant, // Color secundario consistente
      marginLeft: 'auto', // Empujar a la derecha
      paddingHorizontal: 8, // Añadir padding similar a variantPrice
    },
    quantityContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      marginVertical: theme.spacing.s,
    },
    quantityIconButton: {
      margin: 0,
      borderRadius: 18,
    },
    quantityText: {
      fontSize: 18,
      fontWeight: 'bold',
      minWidth: 40,
      textAlign: 'center',
      marginHorizontal: theme.spacing.s,
      color: theme.colors.onSurface,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs, // Añadir padding horizontal
    },
    totalRow: {
      // Estilo adicional para la fila del total
      marginTop: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingTop: theme.spacing.s,
    },
    totalLabel: {
      // Estilo consistente con OrderCartDetail
      fontWeight: 'bold',
      fontSize: 18,
      color: theme.colors.onSurface,
    },
    totalValue: {
      // Estilo consistente con OrderCartDetail para el TOTAL FINAL
      fontWeight: 'bold',
      fontSize: 18,
      color: theme.colors.primary, // Color primario para el total final
    },
    // Estilos de Footer y Botón - Consistentes con OrderCartDetail
    footer: {
      padding: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface, // Fondo consistente
    },
    confirmButton: {
      // Reemplaza addButton
      paddingVertical: theme.spacing.s, // Padding consistente
      // width: "100%", // Ya es el comportamiento por defecto del botón en un View
    },
    // Estilo para SpeechRecognitionInput (una sola línea)
    preparationInput: {
      // backgroundColor: theme.colors.surfaceVariant, // Opcional: mantener fondo
      marginVertical: theme.spacing.xs,
      textAlignVertical: 'center', // Intentar centrar verticalmente el placeholder/texto
      // minHeight: 80, // Eliminar altura mínima, ya no es multilínea
    },
    // Eliminar estilos no usados
    // sectionTitleContainer: { ... },
    // sectionTitleOptional: { ... },
    divider: {
      // Estilo de Divider si se usa
      marginVertical: theme.spacing.s,
      backgroundColor: theme.colors.outlineVariant,
    },
  });

ProductCustomizationModal.displayName = 'ProductCustomizationModal';

export default ProductCustomizationModal;

================
File: app/src/modules/orders/services/orderPrintService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

interface PrintTicketPayload {
  printerId: string;
  ticketType: 'GENERAL' | 'BILLING';
}

export const orderPrintService = {
  /**
   * Imprime un ticket para una orden
   */
  printTicket: async (orderId: string, payload: PrintTicketPayload) => {
    const response = await apiClient.post(
      API_PATHS.ORDERS_PRINT_TICKET.replace(':orderId', orderId),
      payload,
    );
    return response.data;
  },
};

================
File: app/src/modules/orders/services/paymentService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { API_PATHS } from '../../../app/constants/apiPaths';
import type {
  Payment,
  CreatePaymentDto,
  UpdatePaymentDto,
  PaymentMethod,
  PaymentStatus,
} from '../types/payment.types';

class PaymentService {
  async createPayment(dto: CreatePaymentDto): Promise<Payment> {
    const { data } = await ApiClientWrapper.post<Payment>(
      API_PATHS.PAYMENTS,
      dto,
    );
    return data;
  }

  async getPayments(filters?: {
    orderId?: string;
    paymentMethod?: PaymentMethod;
    paymentStatus?: PaymentStatus;
  }): Promise<Payment[]> {
    const { data } = await ApiClientWrapper.get<Payment[]>(API_PATHS.PAYMENTS, {
      params: filters,
    });
    return data;
  }

  async getPaymentById(id: string): Promise<Payment> {
    const { data } = await ApiClientWrapper.get<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
    );
    return data;
  }

  async getPaymentsByOrderId(orderId: string): Promise<Payment[]> {
    const { data } = await ApiClientWrapper.get<Payment[]>(
      API_PATHS.PAYMENTS_BY_ORDER.replace(':orderId', orderId),
    );
    return data;
  }

  async updatePayment(id: string, dto: UpdatePaymentDto): Promise<Payment> {
    const { data } = await ApiClientWrapper.patch<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
      dto,
    );
    return data;
  }

  async deletePayment(id: string): Promise<void> {
    await ApiClientWrapper.delete(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
    );
  }
}

export const paymentService = new PaymentService();

================
File: app/src/modules/payments/services/prepaymentService.ts
================
import apiClient from '@/app/services/apiClient';
import { handleApiResponse, handleApiResponseVoid } from '@/app/lib/apiHelpers';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Payment } from '../types/payment.types';

interface CreatePrepaymentDto {
  paymentMethod: 'CASH' | 'CARD' | 'TRANSFER';
  amount: number;
}

interface UpdatePrepaymentDto {
  paymentMethod?: 'CASH' | 'CARD' | 'TRANSFER';
  amount?: number;
}

export const prepaymentService = {
  /**
   * Crear un pre-pago (pago sin orden asociada)
   */
  createPrepayment: async (data: CreatePrepaymentDto): Promise<Payment> => {
    const response = await apiClient.post<Payment>(
      API_PATHS.PAYMENTS_PREPAYMENT,
      data,
    );
    return handleApiResponse(response);
  },

  /**
   * Actualizar un pre-pago existente
   */
  updatePrepayment: async (
    paymentId: string,
    data: UpdatePrepaymentDto,
  ): Promise<Payment> => {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', paymentId),
      data,
    );
    return handleApiResponse(response);
  },

  /**
   * Asociar un pre-pago a una orden
   */
  associateToOrder: async (
    paymentId: string,
    orderId: string,
  ): Promise<Payment> => {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_ASSOCIATE.replace(':paymentId', paymentId).replace(
        ':orderId',
        orderId,
      ),
    );
    return handleApiResponse(response);
  },

  /**
   * Eliminar un pre-pago
   */
  deletePrepayment: async (paymentId: string): Promise<void> => {
    const response = await apiClient.delete(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', paymentId),
    );
    handleApiResponseVoid(response);
  },
};

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationDetailModal.tsx
================
import React from 'react';
import GenericDetailModal from '@/app/components/crud/GenericDetailModal';
import {
  CustomizationType,
  PizzaCustomization,
} from '../types/pizzaCustomization.types';

interface PizzaCustomizationDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  customization: PizzaCustomization | null;
  onEdit?: (customization: PizzaCustomization) => void;
  onDelete?: (customization: PizzaCustomization) => void;
  isDeleting?: boolean;
}

export function PizzaCustomizationDetailModal({
  visible,
  onDismiss,
  customization,
  onEdit,
  onDelete,
  isDeleting = false,
}: PizzaCustomizationDetailModalProps) {
  if (!customization) return null;

  const handleEdit = () => {
    if (onEdit) {
      onEdit(customization);
    }
  };

  const handleDelete = () => {
    if (onDelete) {
      onDelete(customization);
    }
  };

  // Configurar campos dinámicamente según el tipo
  const fieldsToDisplay = [
    {
      field: 'type',
      label: 'Tipo',
      render: (type) =>
        type === CustomizationType.FLAVOR ? 'Sabor' : 'Ingrediente',
    },
    // Solo mostrar ingredientes si es tipo FLAVOR
    ...(customization.type === CustomizationType.FLAVOR
      ? [
          {
            field: 'ingredients',
            label: 'Ingredientes',
            render: (ingredients) => ingredients || 'Sin ingredientes',
          },
        ]
      : []),
    {
      field: 'toppingValue',
      label: 'Valor de topping',
      render: (value) => value?.toString() || '0',
    },
    {
      field: 'sortOrder',
      label: 'Orden de visualización',
      render: (value) => value?.toString() || '0',
    },
    {
      field: 'products',
      label: 'Asociado a productos',
      render: (products) => {
        if (!products || products.length === 0) {
          return 'No asociado a ningún producto';
        }
        const productNames = products.map((p) => p.name).join(', ');
        return `${products.length} producto${products.length > 1 ? 's' : ''}: ${productNames}`;
      },
    },
  ];

  return (
    <GenericDetailModal
      visible={visible}
      onDismiss={onDismiss}
      item={customization}
      titleField="name"
      statusConfig={{
        field: 'isActive',
        activeValue: true,
        activeLabel: 'Activo',
        inactiveLabel: 'Inactivo',
      }}
      fieldsToDisplay={fieldsToDisplay}
      onEdit={onEdit ? handleEdit : undefined}
      onDelete={onDelete ? handleDelete : undefined}
      isDeleting={isDeleting}
    />
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationsTab.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Text,
  Searchbar,
  ActivityIndicator,
  Menu,
  IconButton,
  Badge,
  Chip,
  Surface,
} from 'react-native-paper';
import { FlashList } from '@shopify/flash-list';
import { useAppTheme } from '@/app/styles/theme';
import {
  usePizzaCustomizationsList,
  useDeletePizzaCustomization,
} from '../hooks/usePizzaCustomizationsQueries';
import { PizzaCustomizationDetailModal } from './PizzaCustomizationDetailModal';
import { PizzaCustomizationFormModal } from './PizzaCustomizationFormModal';
import {
  CustomizationType,
  PizzaCustomization,
} from '../types/pizzaCustomization.types';
import EmptyState from '@/app/components/common/EmptyState';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

export function PizzaCustomizationsTab() {
  const theme = useAppTheme();

  const [searchQuery, setSearchQuery] = useState('');
  const [selectedType, setSelectedType] = useState<CustomizationType | 'all'>(
    'all',
  );
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const [selectedCustomization, setSelectedCustomization] =
    useState<PizzaCustomization | null>(null);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [deleteConfirmVisible, setDeleteConfirmVisible] = useState(false);
  const [customizationToDelete, setCustomizationToDelete] =
    useState<PizzaCustomization | null>(null);
  const [formModalVisible, setFormModalVisible] = useState(false);
  const [editingCustomizationId, setEditingCustomizationId] = useState<
    string | undefined
  >();

  const deleteMutation = useDeletePizzaCustomization();

  const {
    data,
    isLoading,
    isError: _isError,
    refetch,
  } = usePizzaCustomizationsList({
    search: searchQuery || undefined,
    type: selectedType === 'all' ? undefined : selectedType,
    limit: 100, // Aumentar el límite para obtener todos los registros
  });

  const filteredData = data?.data || [];
  const hasActiveFilter = selectedType !== 'all';

  const handleItemPress = (item: PizzaCustomization) => {
    setSelectedCustomization(item);
    setDetailModalVisible(true);
  };

  const handleEdit = (customization: PizzaCustomization) => {
    setDetailModalVisible(false);
    setEditingCustomizationId(customization.id);
    setFormModalVisible(true);
  };

  const handleDelete = (customization: PizzaCustomization) => {
    setCustomizationToDelete(customization);
    setDetailModalVisible(false);
    setDeleteConfirmVisible(true);
  };

  const confirmDelete = async () => {
    if (customizationToDelete) {
      await deleteMutation.mutateAsync(customizationToDelete.id);
      setDeleteConfirmVisible(false);
      setCustomizationToDelete(null);
    }
  };

  const renderItem = ({ item }: { item: any }) => (
    <TouchableOpacity onPress={() => handleItemPress(item)}>
      <Surface
        style={[
          styles.cardWrapper,
          !item.isActive && styles.cardWrapperInactive,
        ]}
        elevation={1}
      >
        <View style={styles.cardContent}>
          <View style={styles.cardHeader}>
            <View style={styles.titleRow}>
              <View style={styles.titleContainer}>
                <Text
                  variant="titleMedium"
                  style={[
                    styles.cardTitle,
                    !item.isActive && styles.textInactive,
                  ]}
                  numberOfLines={1}
                >
                  {item.name}
                </Text>
                {!item.isActive && (
                  <Badge style={styles.inactiveBadge} size={16}>
                    Inactivo
                  </Badge>
                )}
              </View>
              <Chip
                mode="flat"
                compact
                icon={
                  item.type === CustomizationType.FLAVOR ? 'pizza' : 'cheese'
                }
                style={[
                  styles.typeChip,
                  {
                    backgroundColor:
                      item.type === CustomizationType.FLAVOR
                        ? theme.colors.errorContainer
                        : theme.colors.secondaryContainer,
                  },
                  !item.isActive && styles.chipInactive,
                ]}
                textStyle={styles.chipText}
              >
                {item.type === CustomizationType.FLAVOR
                  ? 'Sabor'
                  : 'Ingrediente'}
              </Chip>
            </View>
            <View style={styles.statsContainer}>
              <View
                style={[
                  styles.statusIndicator,
                  item.isActive ? styles.statusActive : styles.statusInactive,
                ]}
              />
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                Orden: {item.sortOrder || 0}
              </Text>
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                • Valor: {item.toppingValue || 0}
              </Text>
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                • {item.products?.length || 0} pizzas
              </Text>
            </View>
          </View>

          {item.ingredients && (
            <Text
              variant="bodySmall"
              style={[
                styles.ingredientsText,
                !item.isActive && styles.textInactive,
              ]}
              numberOfLines={1}
            >
              {item.ingredients}
            </Text>
          )}
        </View>
      </Surface>
    </TouchableOpacity>
  );

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      padding: theme.spacing.m,
      backgroundColor: theme.colors.background,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: theme.spacing.xs,
    },
    content: {
      flex: 1,
    },
    listContainer: {
      padding: theme.spacing.s,
    },
    cardWrapper: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    cardWrapperInactive: {
      opacity: 0.7,
    },
    cardContent: {
      padding: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
    },
    cardHeader: {
      marginBottom: theme.spacing.xs,
    },
    titleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      gap: theme.spacing.s,
    },
    titleContainer: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    cardTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 16,
    },
    textInactive: {
      color: theme.colors.onSurfaceVariant,
    },
    inactiveBadge: {
      backgroundColor: theme.colors.errorContainer,
      color: theme.colors.onErrorContainer,
      fontSize: 10,
      fontWeight: '600',
    },
    typeChip: {
      height: 24,
    },
    chipInactive: {
      opacity: 0.6,
    },
    chipText: {
      fontSize: 11,
      marginHorizontal: theme.spacing.xs,
      marginVertical: 0,
    },
    statsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      marginTop: theme.spacing.xs,
    },
    statusIndicator: {
      width: 8,
      height: 8,
      borderRadius: 4,
    },
    statusActive: {
      backgroundColor: theme.colors.primary,
    },
    statusInactive: {
      backgroundColor: theme.colors.error,
    },
    statText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    ingredientsText: {
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      fontSize: 12,
      marginTop: theme.spacing.xs,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
  });

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder="Buscar personalización..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={
                    selectedType === 'all'
                      ? 'filter-variant'
                      : selectedType === CustomizationType.FLAVOR
                        ? 'pizza'
                        : 'cheese'
                  }
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                  iconColor={
                    selectedType !== 'all'
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setSelectedType('all');
                  setFilterMenuVisible(false);
                }}
                title="Todas"
                leadingIcon="filter-variant"
                trailingIcon={selectedType === 'all' ? 'check' : undefined}
                titleStyle={
                  selectedType === 'all'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setSelectedType(CustomizationType.FLAVOR);
                  setFilterMenuVisible(false);
                }}
                title="Sabores"
                leadingIcon="pizza"
                trailingIcon={
                  selectedType === CustomizationType.FLAVOR
                    ? 'check'
                    : undefined
                }
                titleStyle={
                  selectedType === CustomizationType.FLAVOR
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setSelectedType(CustomizationType.INGREDIENT);
                  setFilterMenuVisible(false);
                }}
                title="Ingredientes"
                leadingIcon="cheese"
                trailingIcon={
                  selectedType === CustomizationType.INGREDIENT
                    ? 'check'
                    : undefined
                }
                titleStyle={
                  selectedType === CustomizationType.INGREDIENT
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
            </Menu>
            {hasActiveFilter && <Badge style={styles.filterBadge} size={8} />}
          </View>
        </View>
      </View>

      <View style={styles.content}>
        <FlashList
          data={filteredData}
          renderItem={renderItem}
          estimatedItemSize={120}
          ListEmptyComponent={
            <EmptyState
              title="No hay personalizaciones"
              message={
                selectedType === CustomizationType.FLAVOR
                  ? 'No hay sabores disponibles'
                  : selectedType === CustomizationType.INGREDIENT
                    ? 'No hay ingredientes disponibles'
                    : 'No hay personalizaciones disponibles'
              }
              icon="cheese"
            />
          }
          contentContainerStyle={styles.listContainer}
          keyExtractor={(item) => item.id}
          refreshing={isLoading}
          onRefresh={refetch}
        />
      </View>

      <PizzaCustomizationDetailModal
        visible={detailModalVisible}
        onDismiss={() => {
          setDetailModalVisible(false);
          setSelectedCustomization(null);
        }}
        customization={selectedCustomization}
        onEdit={handleEdit}
        onDelete={handleDelete}
        isDeleting={deleteMutation.isPending}
      />

      <ConfirmationModal
        visible={deleteConfirmVisible}
        title="Eliminar personalización"
        message={`¿Estás seguro de que quieres eliminar "${customizationToDelete?.name}"?`}
        confirmText="Eliminar"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={confirmDelete}
        onCancel={() => {
          setDeleteConfirmVisible(false);
          setCustomizationToDelete(null);
        }}
        onDismiss={() => {
          setDeleteConfirmVisible(false);
          setCustomizationToDelete(null);
        }}
      />

      <PizzaCustomizationFormModal
        visible={formModalVisible}
        onDismiss={() => {
          setFormModalVisible(false);
          setEditingCustomizationId(undefined);
        }}
        customizationId={editingCustomizationId}
        onSuccess={() => {
          refetch();
        }}
      />
    </View>
  );
}

================
File: app/src/modules/preparationScreens/schema/preparationScreen.schema.ts
================
import { z } from 'zod';
// Importar el schema y tipo de dominio centralizado
import {
  preparationScreenSchema as domainPreparationScreenSchema,
  type PreparationScreen as DomainPreparationScreen,
} from '../../../app/schemas/domain/preparation-screen.schema';

// Esquema principal extendido desde el dominio para incluir relaciones
export const PreparationScreenSchema = domainPreparationScreenSchema.extend({
  id: z.string().uuid(), // Refinar el ID para ser UUID específicamente
  products: z
    .array(
      z.object({
        id: z.string(),
        name: z.string(),
      }),
    )
    .optional(),
  users: z
    .array(
      z.object({
        id: z.string(),
        username: z.string(),
        firstName: z.string().nullable().optional(),
        lastName: z.string().nullable().optional(),
      }),
    )
    .nullable()
    .optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});

// Esquema para crear una nueva pantalla de preparación - compuesto desde el dominio
export const CreatePreparationScreenSchema = domainPreparationScreenSchema
  .omit({ id: true })
  .extend({
    name: z
      .string()
      .min(1, 'El nombre es requerido')
      .max(100, 'El nombre no puede exceder los 100 caracteres'),
    description: z
      .string()
      .max(255, 'La descripción no puede exceder los 255 caracteres')
      .nullable()
      .optional(),
    isActive: z.boolean().optional().default(true),
    productIds: z.array(z.string().uuid()).optional(), // IDs de productos asociados (opcional)
    userId: z
      .string()
      .min(1, 'Debe seleccionar un usuario de cocina')
      .uuid({ message: 'Debe seleccionar un usuario de cocina válido' }), // ID del usuario asignado (requerido)
  });

// Esquema para actualizar una pantalla de preparación existente - basado en el de creación
export const UpdatePreparationScreenSchema = CreatePreparationScreenSchema.omit(
  { userId: true },
).extend({
  name: z
    .string()
    .min(1, 'El nombre es requerido')
    .max(100, 'El nombre no puede exceder los 100 caracteres')
    .optional(),
  description: z
    .string()
    .max(255, 'La descripción no puede exceder los 255 caracteres')
    .nullable()
    .optional(),
  isActive: z.boolean().optional(),
  userId: z
    .string()
    .min(1, 'Debe seleccionar un usuario de cocina')
    .uuid({ message: 'Debe seleccionar un usuario de cocina válido' })
    .optional(), // Opcional en actualización
});

// Tipos inferidos de los esquemas Zod
export type PreparationScreen = z.infer<typeof PreparationScreenSchema>;
export type CreatePreparationScreenDto = z.infer<
  typeof CreatePreparationScreenSchema
>;
export type UpdatePreparationScreenDto = z.infer<
  typeof UpdatePreparationScreenSchema
>;

// Re-exportar tipo de dominio para conveniencia
export type { DomainPreparationScreen };

// Esquema para los filtros de búsqueda/listado
export const FindAllPreparationScreensSchema = z.object({
  name: z.string().optional(),
  isActive: z.boolean().optional(),
  // Añadir otros filtros si son necesarios, ej: productId
});

// Tipo inferido para los filtros de búsqueda/listado
export type FindAllPreparationScreensDto = z.infer<
  typeof FindAllPreparationScreensSchema
>;

================
File: app/src/modules/preparationScreens/services/preparationScreenService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  BackendErrorResponse,
  PaginatedResponse,
} from '../../../app/types/api.types';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  FindAllPreparationScreensDto,
} from '../schema/preparationScreen.schema';

/**
 * Fetches a list of preparation screens based on filter and pagination options.
 * @param filterOptions - Options to filter the results (e.g., by name, isActive).
 * @param paginationOptions - Options for pagination (page number, limit).
 * @returns A promise that resolves to a paginated response of PreparationScreen objects.
 * @throws {ApiError} If the API request fails.
 */
export const getPreparationScreens = async (
  filterOptions: FindAllPreparationScreensDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 15 }, // Default limit 15
): Promise<PaginatedResponse<PreparationScreen>> => {
  const response = await ApiClientWrapper.get<
    PaginatedResponse<PreparationScreen>
  >(API_PATHS.PREPARATION_SCREENS, {
    ...filterOptions,
    page: paginationOptions.page,
    limit: paginationOptions.limit,
  });

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }

  // Verificar que la respuesta tenga la estructura esperada del backend paginado
  if (
    typeof response.data === 'object' &&
    'items' in response.data &&
    Array.isArray(response.data.items) &&
    'total' in response.data &&
    'page' in response.data &&
    'limit' in response.data
  ) {
    // Convertir de la estructura del backend a PaginatedResponse
    return {
      data: response.data.items,
      total: response.data.total,
      page: response.data.page,
      limit: response.data.limit,
      totalPages: Math.ceil(response.data.total / response.data.limit),
    };
  } else {
    throw new Error('Invalid response format from API');
  }
};

/**
 * Fetches a single preparation screen by its ID.
 * @param id - The UUID of the preparation screen.
 * @returns A promise that resolves to the PreparationScreen object.
 * @throws {ApiError} If the API request fails or the screen is not found.
 */
export const getPreparationScreenById = async (
  id: string,
): Promise<PreparationScreen> => {
  const response = await ApiClientWrapper.get<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Creates a new preparation screen.
 * @param data - The data for the new preparation screen (CreatePreparationScreenDto).
 * @returns A promise that resolves to the newly created PreparationScreen object.
 * @throws {ApiError} If the API request fails.
 */
export const createPreparationScreen = async (
  data: CreatePreparationScreenDto,
): Promise<PreparationScreen> => {
  const response = await ApiClientWrapper.post<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS,
    data,
  );

  if (!response.ok || !response.data) {
    // Si hay un ApiError original del interceptor, usarlo directamente
    if ((response as any).apiError instanceof ApiError) {
      throw (response as any).apiError;
    }

    // Si no, crear uno nuevo desde la respuesta
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Updates an existing preparation screen.
 * @param id - The UUID of the preparation screen to update.
 * @param data - The data to update (UpdatePreparationScreenDto).
 * @returns A promise that resolves to the updated PreparationScreen object.
 * @throws {ApiError} If the API request fails or the screen is not found.
 */
export const updatePreparationScreen = async (
  id: string,
  data: UpdatePreparationScreenDto,
): Promise<PreparationScreen> => {
  const response = await ApiClientWrapper.patch<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Deletes a preparation screen by its ID (soft delete likely).
 * @param id - The UUID of the preparation screen to delete.
 * @returns A promise that resolves when the deletion is successful.
 * @throws {ApiError} If the API request fails.
 */
export const deletePreparationScreen = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
};

/**
 * Gets products associated with a preparation screen.
 * @param id - The UUID of the preparation screen.
 * @returns A promise that resolves to an array of products.
 * @throws {ApiError} If the API request fails.
 */
export const getPreparationScreenProducts = async (
  id: string,
): Promise<any[]> => {
  const response = await ApiClientWrapper.get<any[]>(
    API_PATHS.PREPARATION_SCREENS_PRODUCTS.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Gets the complete menu with association information for a preparation screen.
 * @param id - The UUID of the preparation screen.
 * @returns A promise that resolves to the menu data with associations.
 * @throws {ApiError} If the API request fails.
 */
export const getMenuWithAssociations = async (id: string): Promise<any> => {
  const response = await ApiClientWrapper.get<any>(
    API_PATHS.PREPARATION_SCREENS_MENU_WITH_ASSOCIATIONS.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Associates products with a preparation screen.
 * @param id - The UUID of the preparation screen.
 * @param productIds - Array of product IDs to associate.
 * @returns A promise that resolves to the updated preparation screen.
 * @throws {ApiError} If the API request fails.
 */
export const associateProducts = async (
  id: string,
  productIds: string[],
): Promise<PreparationScreen> => {
  const response = await ApiClientWrapper.post<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_PRODUCTS.replace(':id', id),
    { productIds },
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

================
File: app/src/modules/printers/components/NumericField.tsx
================
import React, { useState, useEffect } from 'react';
import AnimatedLabelInput from '../../../app/components/common/AnimatedLabelInput';

interface NumericFieldProps {
  label: string;
  value: number | undefined;
  onChange: (value: number | undefined) => void;
  onBlur: () => void;
  error?: boolean;
  disabled?: boolean;
  defaultValue: number;
}

const NumericField: React.FC<NumericFieldProps> = ({
  label,
  value,
  onChange,
  onBlur,
  error,
  disabled,
  defaultValue,
}) => {
  const [displayValue, setDisplayValue] = useState(() =>
    value !== undefined ? String(value) : '',
  );
  const [isFocused, setIsFocused] = useState(false);

  // Sincronizar valor externo con display solo cuando no está enfocado
  useEffect(() => {
    if (!isFocused && value !== undefined) {
      setDisplayValue(String(value));
    }
  }, [value, isFocused]);

  const handleChangeText = (text: string) => {
    // Permitir solo números
    const numericText = text.replace(/[^0-9]/g, '');
    setDisplayValue(numericText);

    if (numericText === '') {
      onChange(undefined);
    } else {
      const numValue = parseInt(numericText, 10);
      if (!isNaN(numValue)) {
        onChange(numValue);
      }
    }
  };

  const handleBlur = () => {
    setIsFocused(false);
    // Si no hay valor válido, restaurar valor por defecto
    if (value === undefined || isNaN(Number(value))) {
      onChange(defaultValue);
      setDisplayValue(String(defaultValue));
    }
    onBlur();
  };

  const handleFocus = () => {
    setIsFocused(true);
  };

  return (
    <AnimatedLabelInput
      label={label}
      value={displayValue}
      onChangeText={handleChangeText}
      onBlur={handleBlur}
      onFocus={handleFocus}
      error={error}
      disabled={disabled}
      keyboardType="number-pad"
      containerStyle={{ marginBottom: 12 }}
    />
  );
};

export default NumericField;

================
File: app/src/modules/printers/components/PrinterAdvancedConfig.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Text,
  SegmentedButtons,
  HelperText,
  Switch,
  Card,
  Chip,
} from 'react-native-paper';
import { Controller, Control, FieldErrors } from 'react-hook-form';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PrinterFormData } from '../schema/printer.schema';
import NumericField from './NumericField';

interface PrinterAdvancedConfigProps {
  control: Control<PrinterFormData>;
  errors: FieldErrors<PrinterFormData>;
  isSubmitting: boolean;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginTop: theme.spacing.m,
    },
    sectionTitle: {
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.l,
      color: theme.colors.primary,
      fontWeight: '600',
    },
    input: {
      marginBottom: theme.spacing.m,
    },
    switchContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: theme.spacing.m,
      fontSize: 16,
      flexShrink: 1,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    segmentedButtons: {
      marginBottom: theme.spacing.m,
    },
    recommendationCard: {
      marginBottom: theme.spacing.m,
      padding: theme.spacing.m,
      backgroundColor: theme.colors.primaryContainer,
    },
    recommendationTitle: {
      fontWeight: '600',
      marginBottom: theme.spacing.xs,
      color: theme.colors.onPrimaryContainer,
    },
    recommendationRow: {
      flexDirection: 'row',
      alignItems: 'center',
      marginVertical: theme.spacing.xs,
    },
    recommendationText: {
      marginLeft: theme.spacing.s,
      color: theme.colors.onPrimaryContainer,
    },
    chip: {
      marginRight: theme.spacing.xs,
    },
  });

const PrinterAdvancedConfig: React.FC<PrinterAdvancedConfigProps> = ({
  control,
  errors,
  isSubmitting,
}) => {
  const theme = useAppTheme();
  const styles = getStyles(theme);

  return (
    <View style={styles.container}>
      <Text variant="titleMedium" style={styles.sectionTitle}>
        Configuración del Papel
      </Text>

      {/* Recomendaciones */}
      <Card style={styles.recommendationCard}>
        <Card.Content>
          <Text variant="bodyMedium" style={styles.recommendationTitle}>
            Recomendaciones de configuración:
          </Text>
          <View style={styles.recommendationRow}>
            <Chip compact style={styles.chip}>
              80mm
            </Chip>
            <Text variant="bodySmall" style={styles.recommendationText}>
              48 caracteres (normal) • 64 (comprimido)
            </Text>
          </View>
          <View style={styles.recommendationRow}>
            <Chip compact style={styles.chip}>
              58mm
            </Chip>
            <Text variant="bodySmall" style={styles.recommendationText}>
              32 caracteres (normal) • 42 (comprimido)
            </Text>
          </View>
        </Card.Content>
      </Card>

      {/* Ancho del papel */}
      <Controller
        name="paperWidth"
        control={control}
        render={({ field: { onChange, value } }) => (
          <View>
            <Text variant="bodyMedium" style={{ marginBottom: 8 }}>
              Ancho del papel
            </Text>
            <SegmentedButtons
              value={String(value)}
              onValueChange={(val) => onChange(Number(val))}
              buttons={[
                {
                  value: '58',
                  label: '58mm',
                  disabled: isSubmitting,
                },
                {
                  value: '80',
                  label: '80mm',
                  disabled: isSubmitting,
                },
              ]}
              style={styles.segmentedButtons}
            />
          </View>
        )}
      />

      {/* Caracteres por línea */}
      <Controller
        name="charactersPerLine"
        control={control}
        render={({ field: { onChange, onBlur, value } }) => (
          <NumericField
            label="Caracteres por línea"
            value={value}
            onChange={onChange}
            onBlur={onBlur}
            error={!!errors.charactersPerLine}
            disabled={isSubmitting}
            defaultValue={48}
          />
        )}
      />
      {errors.charactersPerLine && (
        <HelperText
          type="error"
          visible={!!errors.charactersPerLine}
          style={styles.helperText}
        >
          {errors.charactersPerLine.message}
        </HelperText>
      )}

      <HelperText type="info" visible={true} style={styles.helperText}>
        Ajusta según el ancho real de impresión de tu impresora
      </HelperText>

      <Text variant="titleMedium" style={styles.sectionTitle}>
        Configuración de Corte
      </Text>

      {/* Cortar papel */}
      <View style={styles.switchContainer}>
        <Text variant="bodyLarge" style={styles.switchLabel}>
          Cortar papel automáticamente
        </Text>
        <Controller
          name="cutPaper"
          control={control}
          render={({ field: { onChange, value } }) => (
            <Switch
              value={value}
              onValueChange={onChange}
              disabled={isSubmitting}
            />
          )}
        />
      </View>

      {/* Líneas de avance */}
      <Controller
        name="feedLines"
        control={control}
        render={({ field: { onChange, onBlur, value } }) => (
          <NumericField
            label="Líneas de avance antes del corte"
            value={value}
            onChange={onChange}
            onBlur={onBlur}
            error={!!errors.feedLines}
            disabled={isSubmitting}
            defaultValue={3}
          />
        )}
      />
      {errors.feedLines && (
        <HelperText
          type="error"
          visible={!!errors.feedLines}
          style={styles.helperText}
        >
          {errors.feedLines.message}
        </HelperText>
      )}

      <HelperText type="info" visible={true} style={styles.helperText}>
        Líneas en blanco para que el ticket salga completamente (0-50)
      </HelperText>
    </View>
  );
};

export default PrinterAdvancedConfig;

================
File: app/src/modules/printers/components/PrinterDetailModal.tsx
================
import React from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Surface,
  IconButton,
  Divider,
  Button,
  Chip,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { ThermalPrinter } from '../types/printer.types';

interface PrinterDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  printer: ThermalPrinter | null;
  onEdit?: () => void;
  onDelete?: () => void;
  onTestPrint?: () => void;
  isDeleting?: boolean;
  isTestPrinting?: boolean;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      borderRadius: theme.roundness * 3,
      margin: theme.spacing.l,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    header: {
      backgroundColor: theme.colors.primary,
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.m,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    headerTextContainer: {
      flex: 1,
    },
    headerTitle: {
      color: theme.colors.onPrimary,
      fontSize: 20,
      fontWeight: '700',
    },
    headerSubtitle: {
      color: theme.colors.onPrimary,
      opacity: 0.8,
      fontSize: 14,
      marginTop: 4,
    },
    closeButton: {
      margin: -theme.spacing.xs,
    },
    scrollView: {
      maxHeight: 400,
    },
    scrollContent: {
      padding: theme.spacing.l,
    },
    section: {
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.primary,
      marginBottom: theme.spacing.s,
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    infoLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    infoValue: {
      fontSize: 14,
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
      flex: 1,
      marginLeft: theme.spacing.m,
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.m,
    },
    statusChip: {
      paddingHorizontal: theme.spacing.xs,
    },
    activeChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    inactiveChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    featuresGrid: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.s,
      marginTop: theme.spacing.s,
    },
    featureCard: {
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surfaceVariant,
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      minWidth: '45%',
      flex: 1,
    },
    featureIcon: {
      backgroundColor: theme.colors.secondaryContainer,
      borderRadius: theme.roundness,
      padding: theme.spacing.xs,
    },
    featureText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    divider: {
      marginVertical: theme.spacing.m,
    },
    testPrintButton: {
      marginBottom: theme.spacing.m,
      borderColor: theme.colors.primary,
    },
    footer: {
      padding: theme.spacing.l,
      paddingTop: 0,
      gap: theme.spacing.s,
    },
    footerButtons: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    footerButton: {
      flex: 1,
    },
    deleteButton: {
      borderColor: theme.colors.error,
    },
    emptyState: {
      padding: theme.spacing.xl,
      alignItems: 'center',
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
    },
  });

const PrinterDetailModal: React.FC<PrinterDetailModalProps> = ({
  visible,
  onDismiss,
  printer,
  onEdit,
  onDelete,
  onTestPrint,
  isDeleting = false,
  isTestPrinting = false,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);

  if (!printer && visible) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContent}
        >
          <View style={styles.emptyState}>
            <Text style={styles.emptyText}>No se encontró la impresora</Text>
          </View>
        </Modal>
      </Portal>
    );
  }

  if (!printer) return null;

  const getConnectionInfo = () => {
    if (printer.connectionType === 'NETWORK') {
      return `${printer.ipAddress || 'N/A'}:${printer.port || 9100}`;
    }
    return printer.path || 'N/A';
  };

  const formatDate = (dateString?: string) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString('es-ES', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
      >
        <View>
          <Surface style={styles.header}>
            <View style={styles.headerContent}>
              <View style={styles.headerTextContainer}>
                <Text style={styles.headerTitle}>{printer.name}</Text>
                <Text style={styles.headerSubtitle}>
                  {printer.connectionType} • {getConnectionInfo()}
                </Text>
              </View>
              <IconButton
                icon="close"
                size={24}
                iconColor={theme.colors.onPrimary}
                onPress={onDismiss}
                style={styles.closeButton}
              />
            </View>
          </Surface>

          <ScrollView
            style={styles.scrollView}
            contentContainerStyle={styles.scrollContent}
          >
            {/* Estado y características principales */}
            <View style={styles.section}>
              <View style={styles.statusContainer}>
                <Chip
                  mode="flat"
                  style={[
                    styles.statusChip,
                    printer.isActive ? styles.activeChip : styles.inactiveChip,
                  ]}
                  textStyle={{
                    color: printer.isActive
                      ? theme.colors.onPrimaryContainer
                      : theme.colors.onErrorContainer,
                  }}
                >
                  {printer.isActive ? 'Activa' : 'Inactiva'}
                </Chip>
                {printer.isDefaultPrinter && (
                  <Chip
                    mode="flat"
                    style={[styles.statusChip, styles.activeChip]}
                    icon="star"
                    textStyle={{ color: theme.colors.onPrimaryContainer }}
                  >
                    Predeterminada
                  </Chip>
                )}
              </View>

              <View style={styles.featuresGrid}>
                {printer.autoDeliveryPrint && (
                  <Surface style={styles.featureCard}>
                    <View style={styles.featureIcon}>
                      <IconButton
                        icon="home-export-outline"
                        size={16}
                        iconColor={theme.colors.onSecondaryContainer}
                        style={{ margin: 0 }}
                      />
                    </View>
                    <Text style={styles.featureText}>
                      Impresión automática para domicilio
                    </Text>
                  </Surface>
                )}
                {printer.autoPickupPrint && (
                  <Surface style={styles.featureCard}>
                    <View style={styles.featureIcon}>
                      <IconButton
                        icon="bag-checked"
                        size={16}
                        iconColor={theme.colors.onSecondaryContainer}
                        style={{ margin: 0 }}
                      />
                    </View>
                    <Text style={styles.featureText}>
                      Impresión automática para llevar
                    </Text>
                  </Surface>
                )}
              </View>
            </View>

            <Divider style={styles.divider} />

            {/* Información de conexión */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Información de Conexión</Text>

              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Tipo de conexión</Text>
                <Text style={styles.infoValue}>{printer.connectionType}</Text>
              </View>

              {printer.connectionType === 'NETWORK' && (
                <>
                  <View style={styles.infoRow}>
                    <Text style={styles.infoLabel}>Dirección IP</Text>
                    <Text style={styles.infoValue}>
                      {printer.ipAddress || 'N/A'}
                    </Text>
                  </View>
                  <View style={styles.infoRow}>
                    <Text style={styles.infoLabel}>Puerto</Text>
                    <Text style={styles.infoValue}>
                      {printer.port || 'N/A'}
                    </Text>
                  </View>
                  {printer.macAddress && (
                    <View style={styles.infoRow}>
                      <Text style={styles.infoLabel}>Dirección MAC</Text>
                      <Text style={styles.infoValue}>{printer.macAddress}</Text>
                    </View>
                  )}
                </>
              )}

              {printer.connectionType !== 'NETWORK' && printer.path && (
                <View style={styles.infoRow}>
                  <Text style={styles.infoLabel}>Ruta/ID</Text>
                  <Text style={styles.infoValue}>{printer.path}</Text>
                </View>
              )}
            </View>

            <Divider style={styles.divider} />

            {/* Configuración del papel */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Configuración del Papel</Text>

              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Ancho del papel</Text>
                <Text style={styles.infoValue}>{printer.paperWidth}mm</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Caracteres por línea</Text>
                <Text style={styles.infoValue}>
                  {printer.charactersPerLine}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Corte automático</Text>
                <Text style={styles.infoValue}>
                  {printer.cutPaper ? 'Sí' : 'No'}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Líneas de avance</Text>
                <Text style={styles.infoValue}>{printer.feedLines}</Text>
              </View>
            </View>

            <Divider style={styles.divider} />

            {/* Información adicional */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Información Adicional</Text>

              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Creada</Text>
                <Text style={styles.infoValue}>
                  {formatDate(printer.createdAt)}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Última actualización</Text>
                <Text style={styles.infoValue}>
                  {formatDate(printer.updatedAt)}
                </Text>
              </View>
            </View>
          </ScrollView>

          <View style={styles.footer}>
            {onTestPrint && (
              <Button
                mode="outlined"
                icon="printer-check"
                onPress={onTestPrint}
                loading={isTestPrinting}
                disabled={isTestPrinting || isDeleting}
                style={styles.testPrintButton}
              >
                Imprimir Ticket de Prueba
              </Button>
            )}

            <View style={styles.footerButtons}>
              {onEdit && (
                <Button
                  mode="contained-tonal"
                  onPress={onEdit}
                  disabled={isDeleting || isTestPrinting}
                  style={styles.footerButton}
                >
                  Editar
                </Button>
              )}
              {onDelete && (
                <Button
                  mode="outlined"
                  onPress={onDelete}
                  loading={isDeleting}
                  disabled={isDeleting || isTestPrinting}
                  style={[styles.footerButton, styles.deleteButton]}
                  textColor={theme.colors.error}
                >
                  Eliminar
                </Button>
              )}
            </View>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};

export default PrinterDetailModal;

================
File: app/src/modules/printers/components/PrinterFormModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Switch,
  HelperText,
  ActivityIndicator,
  RadioButton,
} from 'react-native-paper';
import { useForm, Controller, SubmitHandler } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';

import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import {
  PrinterFormData,
  printerFormSchema,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
} from '../schema/printer.schema';
import {
  useCreatePrinterMutation,
  useUpdatePrinterMutation,
} from '../hooks/usePrintersQueries';
import AnimatedLabelInput from '../../../app/components/common/AnimatedLabelInput';
import PrinterAdvancedConfig from './PrinterAdvancedConfig';

interface PrinterFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  editingItem: ThermalPrinter | null;
  initialDataFromDiscovery?: Partial<PrinterFormData>;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: theme.spacing.l,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.xl,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
    },
    input: {
      marginBottom: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: theme.spacing.m,
      fontSize: 16,
      flexShrink: 1,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    radioGroupContainer: {
      marginBottom: theme.spacing.m,
    },
    radioGroupLabel: {
      marginBottom: theme.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    radioGroupHorizontal: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      flexWrap: 'wrap',
    },
    radioButtonItem: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: theme.spacing.s,
      paddingVertical: 0,
    },
    radioLabel: {
      fontSize: 14,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: theme.spacing.m,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: theme.spacing.xs,
      flex: 1,
      maxWidth: 200,
    },
    cancelButton: {},
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      zIndex: 10,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
  });

const PrinterFormModal: React.FC<PrinterFormModalProps> = ({
  visible,
  onDismiss,
  editingItem,
  initialDataFromDiscovery,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const isEditing = !!editingItem;

  const createMutation = useCreatePrinterMutation();
  const updateMutation = useUpdatePrinterMutation();

  const isSubmitting = createMutation.isPending || updateMutation.isPending;

  const defaultValues = useMemo((): PrinterFormData => {
    const baseDefaults: PrinterFormData = {
      name: '',
      connectionType: 'NETWORK',
      ipAddress: undefined,
      port: undefined,
      path: undefined,
      isActive: true,
      macAddress: undefined,
      isDefaultPrinter: false,
      autoDeliveryPrint: false,
      autoPickupPrint: false,
      paperWidth: 80,
      charactersPerLine: 48,
      cutPaper: true,
      feedLines: 3,
    };
    // Aplicar valores iniciales si se está editando
    if (isEditing && editingItem) {
      return {
        name: editingItem.name,
        connectionType: editingItem.connectionType,
        ipAddress: editingItem.ipAddress ?? undefined,
        port: editingItem.port ?? undefined,
        path: editingItem.path ?? undefined,
        isActive: editingItem.isActive,
        macAddress: editingItem.macAddress ?? undefined,
        isDefaultPrinter: editingItem.isDefaultPrinter ?? false,
        autoDeliveryPrint: editingItem.autoDeliveryPrint ?? false,
        autoPickupPrint: editingItem.autoPickupPrint ?? false,
        paperWidth: editingItem.paperWidth ?? 80,
        charactersPerLine: editingItem.charactersPerLine ?? 48,
        cutPaper: editingItem.cutPaper ?? true,
        feedLines: editingItem.feedLines ?? 3,
      };
    }
    // Aplicar valores desde descubrimiento si se está creando y existen
    if (!isEditing && initialDataFromDiscovery) {
      return {
        ...baseDefaults,
        name:
          initialDataFromDiscovery.name ||
          `Impresora ${initialDataFromDiscovery.ipAddress}`,
        connectionType: 'NETWORK',
        ipAddress: initialDataFromDiscovery.ipAddress,
        port: initialDataFromDiscovery.port,
        macAddress: initialDataFromDiscovery.macAddress,
      };
    }
    return baseDefaults;
  }, [editingItem, isEditing, initialDataFromDiscovery]);

  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors },
  } = useForm<PrinterFormData>({
    resolver: zodResolver(printerFormSchema),
    defaultValues: defaultValues,
  });

  const connectionType = watch('connectionType');

  useEffect(() => {
    if (visible) {
      reset(defaultValues);
    }
  }, [visible, editingItem, initialDataFromDiscovery, reset, defaultValues]);

  const onSubmit: SubmitHandler<PrinterFormData> = async (formData) => {
    const dataToSend = { ...formData };
    if (dataToSend.connectionType === 'NETWORK') {
      dataToSend.path = undefined;
    } else {
      dataToSend.ipAddress = undefined;
      dataToSend.port = undefined;
    }
    if (dataToSend.port && typeof dataToSend.port === 'string') {
      dataToSend.port = parseInt(dataToSend.port, 10);
      if (isNaN(dataToSend.port)) {
        dataToSend.port = undefined;
      }
    }

    try {
      if (isEditing && editingItem) {
        await updateMutation.mutateAsync({
          id: editingItem.id,
          data: dataToSend as UpdateThermalPrinterDto,
        });
      } else {
        await createMutation.mutateAsync(dataToSend as CreateThermalPrinterDto);
      }
      onDismiss();
    } catch (error) {}
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting}
      >
        <View style={styles.formContainer}>
          <View style={styles.modalHeader}>
            <Text variant="titleLarge" style={styles.modalTitle}>
              {isEditing ? 'Editar Impresora' : 'Nueva Impresora'}
            </Text>
          </View>

          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            {/* Nombre */}
            <Controller
              name="name"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <AnimatedLabelInput
                  label="Nombre *"
                  value={value}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.name}
                  disabled={isSubmitting}
                  containerStyle={styles.input}
                />
              )}
            />
            {errors.name && (
              <HelperText
                type="error"
                visible={!!errors.name}
                style={styles.helperText}
              >
                {errors.name.message}
              </HelperText>
            )}

            {/* Tipo de Conexión */}
            <View style={styles.radioGroupContainer}>
              <Text style={styles.radioGroupLabel}>Tipo de Conexión *</Text>
              <Controller
                name="connectionType"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <RadioButton.Group onValueChange={onChange} value={value}>
                    <View style={styles.radioGroupHorizontal}>
                      <RadioButton.Item
                        label="Red"
                        value="NETWORK"
                        style={styles.radioButtonItem}
                        labelStyle={styles.radioLabel}
                        position="leading"
                        disabled={isSubmitting}
                      />
                      <RadioButton.Item
                        label="USB"
                        value="USB"
                        style={styles.radioButtonItem}
                        labelStyle={styles.radioLabel}
                        position="leading"
                        disabled={true}
                      />
                    </View>
                  </RadioButton.Group>
                )}
              />
              {errors.connectionType && (
                <HelperText
                  type="error"
                  visible={!!errors.connectionType}
                  style={styles.helperText}
                >
                  {errors.connectionType.message}
                </HelperText>
              )}
            </View>

            {/* Campos Condicionales */}
            {connectionType === 'NETWORK' && (
              <>
                <Controller
                  name="ipAddress"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Dirección IP *"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.ipAddress}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      keyboardType="decimal-pad"
                    />
                  )}
                />
                {errors.ipAddress && (
                  <HelperText
                    type="error"
                    visible={!!errors.ipAddress}
                    style={styles.helperText}
                  >
                    {errors.ipAddress.message}
                  </HelperText>
                )}

                <Controller
                  name="port"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Puerto *"
                      value={
                        value !== undefined && value !== null
                          ? String(value)
                          : ''
                      }
                      onChangeText={(text) => {
                        if (!text) {
                          onChange(undefined);
                          return;
                        }
                        const parsedPort = parseInt(text, 10);
                        onChange(isNaN(parsedPort) ? undefined : parsedPort);
                      }}
                      onBlur={onBlur}
                      error={!!errors.port}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      keyboardType="number-pad"
                    />
                  )}
                />
                {errors.port && (
                  <HelperText
                    type="error"
                    visible={!!errors.port}
                    style={styles.helperText}
                  >
                    {errors.port.message}
                  </HelperText>
                )}

                <Controller
                  name="macAddress"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Dirección MAC (Opcional)"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.macAddress}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      autoCapitalize="characters"
                    />
                  )}
                />
                {errors.macAddress && (
                  <HelperText
                    type="error"
                    visible={!!errors.macAddress}
                    style={styles.helperText}
                  >
                    {errors.macAddress.message}
                  </HelperText>
                )}
              </>
            )}

            {connectionType !== 'NETWORK' && (
              <>
                <Controller
                  name="path"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Ruta / Identificador *"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.path}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      placeholder={
                        connectionType === 'USB'
                          ? '/dev/usb/lp0'
                          : connectionType === 'SERIAL'
                            ? '/dev/ttyS0'
                            : 'Dirección BT'
                      }
                    />
                  )}
                />
                {errors.path && (
                  <HelperText
                    type="error"
                    visible={!!errors.path}
                    style={styles.helperText}
                  >
                    {errors.path.message}
                  </HelperText>
                )}
              </>
            )}

            {/* Estado Activo */}
            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Activa
              </Text>
              <Controller
                name="isActive"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isActive && (
              <HelperText
                type="error"
                visible={!!errors.isActive}
                style={styles.helperText}
              >
                {errors.isActive.message}
              </HelperText>
            )}

            {/* Configuración de Impresión Automática */}
            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Impresora Predeterminada
              </Text>
              <Controller
                name="isDefaultPrinter"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>

            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Imprimir Automáticamente Domicilio
              </Text>
              <Controller
                name="autoDeliveryPrint"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>

            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Imprimir Automáticamente Para Llevar
              </Text>
              <Controller
                name="autoPickupPrint"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>

            {/* Configuración avanzada */}
            <PrinterAdvancedConfig
              control={control}
              errors={errors}
              isSubmitting={isSubmitting}
            />
          </ScrollView>

          {isSubmitting && (
            <View style={styles.loadingOverlay}>
              <ActivityIndicator
                animating={true}
                size="large"
                color={theme.colors.primary}
              />
            </View>
          )}

          <View style={styles.modalActions}>
            <Button
              mode="outlined"
              onPress={onDismiss}
              style={[styles.formButton, styles.cancelButton]}
              disabled={isSubmitting}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              loading={isSubmitting}
              disabled={isSubmitting}
              style={styles.formButton}
            >
              {isEditing ? 'Guardar' : 'Crear'}
            </Button>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};

export default PrinterFormModal;

================
File: app/src/modules/printers/schema/printer.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/query.types';

export const PrinterConnectionTypeSchema = z.enum([
  'NETWORK',
  'USB',
  'SERIAL',
  'BLUETOOTH',
]);
export type PrinterConnectionType = z.infer<typeof PrinterConnectionTypeSchema>;

const macRegex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/i;

export const thermalPrinterSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  connectionType: PrinterConnectionTypeSchema,
  ipAddress: z.string().ip({ version: 'v4' }).nullable(),
  port: z.number().int().positive().nullable(),
  path: z.string().nullable(),
  isActive: z.boolean(),
  macAddress: z.string().regex(macRegex, 'MAC inválida').nullable().optional(),
  isDefaultPrinter: z.boolean().optional().default(false),
  autoDeliveryPrint: z.boolean().optional().default(false),
  autoPickupPrint: z.boolean().optional().default(false),
  paperWidth: z.number().optional().default(80),
  charactersPerLine: z.number().optional().default(48),
  cutPaper: z.boolean().optional().default(true),
  feedLines: z.number().optional().default(3),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
  deletedAt: z.string().datetime().nullable().optional(),
});

export type ThermalPrinter = z.infer<typeof thermalPrinterSchema>;

const thermalPrinterDtoObjectSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  connectionType: PrinterConnectionTypeSchema,
  ipAddress: z
    .string()
    .ip({ version: 'v4', message: 'IP inválida' })
    .optional(),
  port: z.coerce
    .number()
    .int()
    .positive('El puerto debe ser un número positivo')
    .optional(),
  path: z.string().optional(),
  isActive: z.boolean().optional().default(true),
  macAddress: z.string().regex(macRegex, 'MAC inválida').optional(),
  isDefaultPrinter: z.boolean().optional().default(false),
  autoDeliveryPrint: z.boolean().optional().default(false),
  autoPickupPrint: z.boolean().optional().default(false),
  paperWidth: z
    .number()
    .min(58, 'El ancho del papel debe ser de al menos 58mm')
    .optional()
    .default(80),
  charactersPerLine: z
    .number()
    .min(32, 'Debe tener al menos 32 caracteres por línea')
    .optional()
    .default(48),
  cutPaper: z.boolean().optional().default(true),
  feedLines: z
    .number()
    .min(0, 'No puede ser menor a 0 líneas')
    .max(50, 'No puede ser mayor a 50 líneas')
    .optional()
    .default(3),
});

const refinePrinterDto = (
  data: Partial<z.infer<typeof thermalPrinterDtoObjectSchema>>,
  ctx: z.RefinementCtx,
) => {
  if (data.connectionType === undefined) return;

  if (data.connectionType === 'NETWORK') {
    if (!data.ipAddress) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La dirección IP es requerida para conexión NETWORK',
        path: ['ipAddress'],
      });
    }
    if (!data.port) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El puerto es requerido para conexión NETWORK',
        path: ['port'],
      });
    }
    if (data.path !== undefined && data.path !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La ruta debe estar vacía para conexión NETWORK',
        path: ['path'],
      });
    }
  } else {
    if (!data.path) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'La ruta/identificador es requerido para este tipo de conexión',
        path: ['path'],
      });
    }
    if (data.ipAddress !== undefined && data.ipAddress !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La IP debe estar vacía para este tipo de conexión',
        path: ['ipAddress'],
      });
    }
    if (data.port !== undefined && data.port !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El puerto debe estar vacío para este tipo de conexión',
        path: ['port'],
      });
    }
  }
};

export const createThermalPrinterDtoSchema =
  thermalPrinterDtoObjectSchema.superRefine(refinePrinterDto);

export type CreateThermalPrinterDto = z.infer<
  typeof createThermalPrinterDtoSchema
>;

export const updateThermalPrinterDtoSchema = thermalPrinterDtoObjectSchema
  .partial()
  .superRefine(refinePrinterDto);

export type UpdateThermalPrinterDto = z.infer<
  typeof updateThermalPrinterDtoSchema
>;

export const findAllThermalPrintersFilterSchema = baseListQuerySchema.extend({
  name: z.string().optional(),
  connectionType: PrinterConnectionTypeSchema.optional(),
  isActive: z.boolean().optional(),
});

export type FindAllThermalPrintersDto = z.infer<
  typeof findAllThermalPrintersFilterSchema
>;

export const printerFormSchema = createThermalPrinterDtoSchema;
export type PrinterFormData = z.input<typeof printerFormSchema>;

export const discoveredPrinterSchema = z.object({
  ip: z.string().ip({ version: 'v4' }),
  port: z.number().int().positive(),
  name: z.string().optional(),
  model: z.string().optional(),
  type: z.string(),
  mac: z.string().regex(macRegex, 'MAC inválida').optional(),
});

export type DiscoveredPrinter = z.infer<typeof discoveredPrinterSchema>;

================
File: app/src/modules/receipts/hooks/useReceiptsQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import {
  receiptService,
  receiptQueryOptions,
} from '../services/receiptService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

export const useReceipts = (filters?: {
  startDate?: string;
  endDate?: string;
  orderType?: string;
}) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const query = useQuery({
    ...receiptQueryOptions.receipts(filters || {}),
  });

  // Manejar errores
  if (query.error) {
    showSnackbar({
      message: query.error.message || 'Error al cargar los recibos',
      type: 'error',
    });
  }

  return query;
};

export const useReceipt = (id: string) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const query = useQuery({
    ...receiptQueryOptions.receipt(id),
  });

  // Manejar errores
  if (query.error) {
    showSnackbar({
      message: query.error.message || 'Error al cargar el recibo',
      type: 'error',
    });
  }

  return query;
};

export const useRecoverOrder = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (orderId: string) => receiptService.recoverOrder(orderId),
    onSuccess: () => {
      // Invalidar todas las queries relacionadas
      queryClient.invalidateQueries({ queryKey: ['receipts'] });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Orden recuperada exitosamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al recuperar la orden',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/restaurantConfig/components/BusinessHoursForm.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Switch, Chip, Card } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import {
  BusinessHours,
  CreateBusinessHoursDto,
} from '../types/restaurantConfig.types';

interface BusinessHoursFormProps {
  businessHours: BusinessHours[] | CreateBusinessHoursDto[];
  isEditing: boolean;
  onChange: (businessHours: CreateBusinessHoursDto[]) => void;
}

const DAYS_OF_WEEK = [
  'Domingo',
  'Lunes',
  'Martes',
  'Miércoles',
  'Jueves',
  'Viernes',
  'Sábado',
];

const BusinessHoursForm: React.FC<BusinessHoursFormProps> = ({
  businessHours,
  isEditing,
  onChange,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const [showTimePicker, setShowTimePicker] = React.useState(false);
  const [currentPickerConfig, setCurrentPickerConfig] = React.useState<{
    dayIndex: number;
    type: 'opening' | 'closing';
    currentDate: Date;
  } | null>(null);

  // Initialize business hours if empty
  const initializedHours = React.useMemo(() => {
    if (businessHours.length === 0) {
      return DAYS_OF_WEEK.map((_, index) => ({
        dayOfWeek: index,
        openingTime: '09:00',
        closingTime: '22:00',
        isClosed: false,
        closesNextDay: false,
      }));
    }

    // Asegurar que closesNextDay esté calculado para cada horario
    return businessHours.map((hour) => {
      if (hour.openingTime && hour.closingTime && !hour.isClosed) {
        const [openHour, openMin] = hour.openingTime.split(':').map(Number);
        const [closeHour, closeMin] = hour.closingTime.split(':').map(Number);

        const closesNextDay =
          closeHour < openHour ||
          (closeHour === openHour && closeMin < openMin);

        return { ...hour, closesNextDay };
      }
      return { ...hour, closesNextDay: false };
    });
  }, [businessHours]);

  // Función para detectar conflictos de horarios
  const checkScheduleConflict = (dayIndex: number): string | null => {
    const currentDay = initializedHours.find((h) => h.dayOfWeek === dayIndex);
    if (!currentDay || currentDay.isClosed || !currentDay.openingTime) {
      return null;
    }

    // Verificar si el día anterior cierra después de medianoche
    const previousDayIndex = dayIndex === 0 ? 6 : dayIndex - 1;
    const previousDay = initializedHours.find(
      (h) => h.dayOfWeek === previousDayIndex,
    );

    if (
      !previousDay ||
      previousDay.isClosed ||
      !previousDay.closesNextDay ||
      !previousDay.closingTime
    ) {
      return null;
    }

    // Comparar horarios
    const [currentOpenHour, currentOpenMin] = currentDay.openingTime
      .split(':')
      .map(Number);
    const [prevCloseHour, prevCloseMin] = previousDay.closingTime
      .split(':')
      .map(Number);

    const currentOpenMinutes = currentOpenHour * 60 + currentOpenMin;
    const prevCloseMinutes = prevCloseHour * 60 + prevCloseMin;

    // Si el día actual abre antes o exactamente cuando cierre el día anterior
    if (currentOpenMinutes <= prevCloseMinutes) {
      return `Conflicto: ${DAYS_OF_WEEK[previousDayIndex]} cierra a las ${previousDay.closingTime}. Debe haber al menos 1 minuto de diferencia`;
    }

    return null;
  };

  const handleTimeChange = (
    dayIndex: number,
    type: 'opening' | 'closing',
    time: string | null,
  ) => {
    if (!onChange || !isEditing) return;

    const updatedHours = [...initializedHours];
    const hourIndex = updatedHours.findIndex((h) => h.dayOfWeek === dayIndex);

    if (hourIndex !== -1 && time !== null) {
      if (type === 'opening') {
        updatedHours[hourIndex].openingTime = time;
      } else {
        updatedHours[hourIndex].closingTime = time;
      }

      // Detectar automáticamente si cierra al día siguiente
      const hour = updatedHours[hourIndex];
      if (hour.openingTime && hour.closingTime) {
        const [openHour, openMin] = hour.openingTime.split(':').map(Number);
        const [closeHour, closeMin] = hour.closingTime.split(':').map(Number);

        // Si la hora de cierre es menor que la de apertura, cierra al día siguiente
        hour.closesNextDay =
          closeHour < openHour ||
          (closeHour === openHour && closeMin < openMin);
      } else {
        hour.closesNextDay = false;
      }

      onChange(updatedHours as CreateBusinessHoursDto[]);
    }
  };

  const handleClosedChange = (dayIndex: number, isClosed: boolean) => {
    if (!onChange || !isEditing) return;

    const updatedHours = [...initializedHours];
    const hourIndex = updatedHours.findIndex((h) => h.dayOfWeek === dayIndex);

    if (hourIndex !== -1) {
      updatedHours[hourIndex].isClosed = isClosed;
      if (isClosed) {
        updatedHours[hourIndex].openingTime = null;
        updatedHours[hourIndex].closingTime = null;
      }
      onChange(updatedHours as CreateBusinessHoursDto[]);
    }
  };

  const formatTimeForDisplay = (
    timeString: string | null | undefined,
  ): string => {
    if (!timeString) return '';
    // Si el string tiene segundos (formato HH:MM:SS), mostrar solo HH:MM
    if (timeString.length > 5) {
      return timeString.substring(0, 5);
    }
    return timeString;
  };

  const openTimePicker = (dayIndex: number, type: 'opening' | 'closing') => {
    if (!isEditing) return;

    const dayHours = initializedHours.find((h) => h.dayOfWeek === dayIndex);
    const currentTimeString =
      dayHours?.[type === 'opening' ? 'openingTime' : 'closingTime'];

    const date = new Date();
    if (currentTimeString) {
      const [hours, minutes] = currentTimeString.split(':').map(Number);
      date.setHours(hours, minutes, 0, 0);
    } else {
      // Default times
      date.setHours(type === 'opening' ? 9 : 22, 0, 0, 0);
    }

    setCurrentPickerConfig({ dayIndex, type, currentDate: date });
    setShowTimePicker(true);
  };

  const handleTimeConfirm = (date: Date) => {
    setShowTimePicker(false);

    if (currentPickerConfig && onChange) {
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const timeString = `${hours}:${minutes}`;

      handleTimeChange(
        currentPickerConfig.dayIndex,
        currentPickerConfig.type,
        timeString,
      );
    }
    setCurrentPickerConfig(null);
  };

  const handleTimeCancel = () => {
    setShowTimePicker(false);
    setCurrentPickerConfig(null);
  };

  return (
    <>
      <View style={styles.container}>
        {DAYS_OF_WEEK.map((day, index) => {
          const dayHours = initializedHours.find(
            (h) => h.dayOfWeek === index,
          ) || {
            dayOfWeek: index,
            openingTime: null,
            closingTime: null,
            isClosed: false,
          };

          return (
            <Card key={index} style={styles.dayCard} mode="elevated">
              <View style={styles.dayHeader}>
                <Text style={styles.dayName}>{day}</Text>
                <View style={styles.dayActions}>
                  <Switch
                    value={!dayHours.isClosed}
                    onValueChange={(value) => {
                      if (isEditing && onChange) {
                        handleClosedChange(index, !value);
                      }
                    }}
                    disabled={!isEditing}
                    color={theme.colors.primary}
                  />
                </View>
              </View>

              {!dayHours.isClosed ? (
                <View style={styles.timeContainer}>
                  <TouchableOpacity
                    style={[
                      styles.timeButton,
                      !isEditing && styles.timeButtonDisabled,
                    ]}
                    onPress={() =>
                      isEditing && openTimePicker(index, 'opening')
                    }
                    disabled={!isEditing}
                  >
                    <View style={styles.timeButtonContent}>
                      <MaterialCommunityIcons
                        name="clock-outline"
                        size={20}
                        color={
                          !isEditing
                            ? theme.colors.onSurfaceDisabled
                            : theme.colors.primary
                        }
                      />
                      <View style={styles.timeTextContainer}>
                        <Text
                          style={[
                            styles.timeLabel,
                            !isEditing && styles.timeLabelDisabled,
                          ]}
                        >
                          Apertura
                        </Text>
                        <Text
                          style={[
                            styles.timeValue,
                            !isEditing && styles.timeValueDisabled,
                          ]}
                        >
                          {formatTimeForDisplay(dayHours.openingTime) ||
                            '--:--'}
                        </Text>
                      </View>
                    </View>
                  </TouchableOpacity>

                  <MaterialCommunityIcons
                    name="arrow-right"
                    size={24}
                    color={
                      !isEditing
                        ? theme.colors.onSurfaceDisabled
                        : theme.colors.onSurfaceVariant
                    }
                    style={styles.arrow}
                  />

                  <TouchableOpacity
                    style={[
                      styles.timeButton,
                      !isEditing && styles.timeButtonDisabled,
                    ]}
                    onPress={() =>
                      isEditing && openTimePicker(index, 'closing')
                    }
                    disabled={!isEditing}
                  >
                    <View style={styles.timeButtonContent}>
                      <MaterialCommunityIcons
                        name="clock-check-outline"
                        size={20}
                        color={
                          !isEditing
                            ? theme.colors.onSurfaceDisabled
                            : theme.colors.primary
                        }
                      />
                      <View style={styles.timeTextContainer}>
                        <Text
                          style={[
                            styles.timeLabel,
                            !isEditing && styles.timeLabelDisabled,
                          ]}
                        >
                          Cierre
                        </Text>
                        <Text
                          style={[
                            styles.timeValue,
                            !isEditing && styles.timeValueDisabled,
                          ]}
                        >
                          {formatTimeForDisplay(dayHours.closingTime) ||
                            '--:--'}
                        </Text>
                      </View>
                      {dayHours.closesNextDay && (
                        <View style={styles.nextDayBadge}>
                          <MaterialCommunityIcons
                            name="moon-waning-crescent"
                            size={12}
                            color={theme.colors.onPrimaryContainer}
                          />
                        </View>
                      )}
                    </View>
                  </TouchableOpacity>
                </View>
              ) : (
                <View style={styles.closedContainer}>
                  <Chip
                    icon="store-off"
                    mode="flat"
                    style={styles.closedChip}
                    textStyle={styles.closedChipText}
                  >
                    Cerrado
                  </Chip>
                </View>
              )}

              {/* Mostrar advertencia de conflicto */}
              {(() => {
                const conflict = checkScheduleConflict(index);
                if (conflict && !dayHours.isClosed) {
                  return (
                    <View style={styles.conflictWarning}>
                      <MaterialCommunityIcons
                        name="alert-circle"
                        size={16}
                        color={theme.colors.error}
                      />
                      <Text style={styles.conflictText}>{conflict}</Text>
                    </View>
                  );
                }
                return null;
              })()}
            </Card>
          );
        })}
      </View>

      <DateTimePickerSafe
        visible={showTimePicker}
        mode="time"
        value={currentPickerConfig?.currentDate || new Date()}
        onConfirm={handleTimeConfirm}
        onCancel={handleTimeCancel}
        minuteInterval={1}
        title={
          currentPickerConfig?.type === 'opening'
            ? `${DAYS_OF_WEEK[currentPickerConfig.dayIndex || 0]} - Apertura`
            : currentPickerConfig?.type === 'closing'
              ? `${DAYS_OF_WEEK[currentPickerConfig.dayIndex || 0]} - Cierre`
              : 'Seleccionar Hora'
        }
        allowManualInput={true}
      />
    </>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      gap: theme.spacing.s,
    },
    dayCard: {
      marginBottom: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      overflow: 'hidden',
      padding: theme.spacing.m,
    },
    dayHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    dayName: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    dayActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    copyButton: {
      margin: 0,
    },
    timeContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    timeButton: {
      flex: 1,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 12,
      padding: theme.spacing.m,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      overflow: 'visible',
    },
    timeButtonDisabled: {
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.surfaceVariant,
    },
    timeButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      position: 'relative',
    },
    timeTextContainer: {
      flex: 1,
    },
    timeLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    timeLabelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    timeValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    timeValueDisabled: {
      color: theme.colors.onSurfaceDisabled,
      fontWeight: '500',
    },
    arrow: {
      marginHorizontal: theme.spacing.xs,
    },
    closedContainer: {
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    closedChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    closedChipText: {
      fontSize: 12,
      color: theme.colors.onErrorContainer,
    },
    nextDayBadge: {
      position: 'absolute',
      top: -4,
      right: -4,
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: 10,
      width: 20,
      height: 20,
      justifyContent: 'center',
      alignItems: 'center',
      borderWidth: 2,
      borderColor: theme.colors.surface,
    },
    conflictWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.errorContainer,
      padding: theme.spacing.s,
      marginTop: theme.spacing.s,
      borderRadius: 8,
      gap: theme.spacing.xs,
    },
    conflictText: {
      flex: 1,
      fontSize: 12,
      color: theme.colors.onErrorContainer,
      lineHeight: 16,
    },
  });

export default BusinessHoursForm;

================
File: app/src/modules/restaurantConfig/components/TimeZoneSelector.tsx
================
import React, { useState, useMemo } from 'react';
import { View, StyleSheet, TouchableOpacity, FlatList } from 'react-native';
import {
  Text,
  Portal,
  Modal,
  Searchbar,
  List,
  Divider,
  Surface,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '@/app/styles/theme';

interface TimeZoneSelectorProps {
  value: string;
  onChange: (timezone: string) => void;
  disabled?: boolean;
}

// Lista de zonas horarias comunes en América
const TIMEZONES = [
  // México
  { value: 'America/Mexico_City', label: 'Ciudad de México', offset: 'UTC-6' },
  { value: 'America/Tijuana', label: 'Tijuana', offset: 'UTC-8' },
  { value: 'America/Cancun', label: 'Cancún', offset: 'UTC-5' },
  { value: 'America/Hermosillo', label: 'Hermosillo', offset: 'UTC-7' },
  { value: 'America/Monterrey', label: 'Monterrey', offset: 'UTC-6' },
  { value: 'America/Mazatlan', label: 'Mazatlán', offset: 'UTC-7' },
  { value: 'America/Chihuahua', label: 'Chihuahua', offset: 'UTC-7' },

  // Estados Unidos
  { value: 'America/New_York', label: 'Nueva York', offset: 'UTC-5' },
  { value: 'America/Chicago', label: 'Chicago', offset: 'UTC-6' },
  { value: 'America/Denver', label: 'Denver', offset: 'UTC-7' },
  { value: 'America/Los_Angeles', label: 'Los Ángeles', offset: 'UTC-8' },
  { value: 'America/Phoenix', label: 'Phoenix', offset: 'UTC-7' },

  // Centroamérica
  { value: 'America/Guatemala', label: 'Guatemala', offset: 'UTC-6' },
  { value: 'America/El_Salvador', label: 'El Salvador', offset: 'UTC-6' },
  { value: 'America/Tegucigalpa', label: 'Honduras', offset: 'UTC-6' },
  { value: 'America/Managua', label: 'Nicaragua', offset: 'UTC-6' },
  { value: 'America/Costa_Rica', label: 'Costa Rica', offset: 'UTC-6' },
  { value: 'America/Panama', label: 'Panamá', offset: 'UTC-5' },

  // Sudamérica
  { value: 'America/Bogota', label: 'Bogotá', offset: 'UTC-5' },
  { value: 'America/Lima', label: 'Lima', offset: 'UTC-5' },
  { value: 'America/Quito', label: 'Quito', offset: 'UTC-5' },
  { value: 'America/Caracas', label: 'Caracas', offset: 'UTC-4' },
  { value: 'America/La_Paz', label: 'La Paz', offset: 'UTC-4' },
  { value: 'America/Santiago', label: 'Santiago', offset: 'UTC-3' },
  { value: 'America/Buenos_Aires', label: 'Buenos Aires', offset: 'UTC-3' },
  { value: 'America/Sao_Paulo', label: 'São Paulo', offset: 'UTC-3' },
  { value: 'America/Montevideo', label: 'Montevideo', offset: 'UTC-3' },
  { value: 'America/Asuncion', label: 'Asunción', offset: 'UTC-3' },

  // Caribe
  { value: 'America/Havana', label: 'La Habana', offset: 'UTC-5' },
  { value: 'America/Santo_Domingo', label: 'Santo Domingo', offset: 'UTC-4' },
  { value: 'America/Puerto_Rico', label: 'Puerto Rico', offset: 'UTC-4' },
];

const TimeZoneSelector: React.FC<TimeZoneSelectorProps> = ({
  value,
  onChange,
  disabled = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const [visible, setVisible] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');

  const selectedTimeZone = useMemo(
    () => TIMEZONES.find((tz) => tz.value === value) || TIMEZONES[0],
    [value],
  );

  const filteredTimeZones = useMemo(() => {
    if (!searchQuery.trim()) return TIMEZONES;

    const query = searchQuery.toLowerCase();
    return TIMEZONES.filter(
      (tz) =>
        tz.label.toLowerCase().includes(query) ||
        tz.value.toLowerCase().includes(query) ||
        tz.offset.toLowerCase().includes(query),
    );
  }, [searchQuery]);

  const handleSelect = (timezone: string) => {
    onChange(timezone);
    setVisible(false);
    setSearchQuery('');
  };

  const renderTimeZoneItem = ({ item }: { item: (typeof TIMEZONES)[0] }) => (
    <>
      <List.Item
        title={item.label}
        description={`${item.value} (${item.offset})`}
        onPress={() => handleSelect(item.value)}
        left={(props) => <List.Icon {...props} icon="clock-outline" />}
        right={(props) =>
          item.value === value ? (
            <List.Icon {...props} icon="check" color={theme.colors.primary} />
          ) : null
        }
        style={[styles.listItem, item.value === value && styles.selectedItem]}
        titleStyle={[
          styles.listItemTitle,
          item.value === value && styles.selectedItemText,
        ]}
        descriptionStyle={styles.listItemDescription}
      />
      <Divider />
    </>
  );

  return (
    <>
      <TouchableOpacity
        style={[styles.selector, disabled && styles.selectorDisabled]}
        onPress={() => !disabled && setVisible(true)}
        disabled={disabled}
      >
        <View style={styles.selectorContent}>
          <MaterialCommunityIcons
            name="earth"
            size={24}
            color={
              disabled ? theme.colors.onSurfaceDisabled : theme.colors.primary
            }
          />
          <View style={styles.textContainer}>
            <Text style={[styles.label, disabled && styles.labelDisabled]}>
              Zona Horaria
            </Text>
            <Text style={[styles.value, disabled && styles.valueDisabled]}>
              {selectedTimeZone.label}
            </Text>
            <Text style={[styles.offset, disabled && styles.offsetDisabled]}>
              {selectedTimeZone.offset}
            </Text>
          </View>
          <MaterialCommunityIcons
            name="chevron-down"
            size={24}
            color={
              disabled
                ? theme.colors.onSurfaceDisabled
                : theme.colors.onSurfaceVariant
            }
          />
        </View>
      </TouchableOpacity>

      <Portal>
        <Modal
          visible={visible}
          onDismiss={() => {
            setVisible(false);
            setSearchQuery('');
          }}
          contentContainerStyle={styles.modal}
        >
          <Surface style={styles.modalContent} elevation={3}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Seleccionar Zona Horaria</Text>
              <IconButton
                icon="close"
                size={24}
                onPress={() => {
                  setVisible(false);
                  setSearchQuery('');
                }}
              />
            </View>

            <Searchbar
              placeholder="Buscar zona horaria..."
              onChangeText={setSearchQuery}
              value={searchQuery}
              style={styles.searchbar}
              inputStyle={styles.searchbarInput}
              icon="magnify"
              clearIcon="close"
            />

            <FlatList
              data={filteredTimeZones}
              renderItem={renderTimeZoneItem}
              keyExtractor={(item) => item.value}
              style={styles.list}
              contentContainerStyle={styles.listContent}
              showsVerticalScrollIndicator={true}
              ListEmptyComponent={
                <View style={styles.emptyContainer}>
                  <MaterialCommunityIcons
                    name="magnify-close"
                    size={48}
                    color={theme.colors.onSurfaceVariant}
                  />
                  <Text style={styles.emptyText}>
                    No se encontraron zonas horarias
                  </Text>
                </View>
              }
            />
          </Surface>
        </Modal>
      </Portal>
    </>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    selector: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 12,
      padding: theme.spacing.m,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    selectorDisabled: {
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.surfaceVariant,
    },
    selectorContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    textContainer: {
      flex: 1,
    },
    label: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    labelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    value: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    valueDisabled: {
      color: theme.colors.onSurfaceDisabled,
      fontWeight: '500',
    },
    offset: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    offsetDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    modal: {
      margin: theme.spacing.l,
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: 16,
      maxHeight: '80%',
      backgroundColor: theme.colors.surface,
    },
    modalHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: theme.spacing.l,
      paddingTop: theme.spacing.l,
      paddingBottom: theme.spacing.s,
    },
    modalTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    searchbar: {
      marginHorizontal: theme.spacing.l,
      marginBottom: theme.spacing.m,
      elevation: 0,
      backgroundColor: theme.colors.surfaceVariant,
    },
    searchbarInput: {
      fontSize: 14,
    },
    list: {
      maxHeight: 400,
    },
    listContent: {
      paddingBottom: theme.spacing.m,
    },
    listItem: {
      paddingHorizontal: theme.spacing.l,
    },
    selectedItem: {
      backgroundColor: theme.colors.primaryContainer,
    },
    listItemTitle: {
      fontSize: 16,
      color: theme.colors.onSurface,
    },
    selectedItemText: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    listItemDescription: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    emptyContainer: {
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl * 2,
    },
    emptyText: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.m,
    },
  });

export default TimeZoneSelector;

================
File: app/src/modules/settings/navigation/SettingsStackNavigator.tsx
================
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { ServerSettingsScreen } from '../screens/ServerSettingsScreen';
import { getDefaultScreenOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';
import type { SettingsStackParamList } from './types';

const Stack = createStackNavigator<SettingsStackParamList>();

export function SettingsStackNavigator() {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        ...getDefaultScreenOptions(theme),
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="ServerSettings"
        component={ServerSettingsScreen}
        options={{
          title: 'Configuración del Servidor',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/settings/navigation/types.ts
================
export type SettingsStackParamList = {
  ServerSettings: undefined;
};

================
File: app/src/modules/settings/screens/ServerSettingsScreen.tsx
================
import React, { useEffect, useState } from 'react';
import {
  ScrollView,
  View,
  StyleSheet,
  ActivityIndicator,
  Platform,
} from 'react-native';
import {
  Text,
  Card,
  RadioButton,
  TextInput,
  Button,
  HelperText,
  Portal,
  Dialog,
  Paragraph,
  IconButton,
  Chip,
  Surface,
  Icon,
  TouchableRipple,
  ProgressBar,
} from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import { useSnackbar } from '@/hooks/useSnackbar';
import {
  serverConnectionService,
  ConnectionMode,
} from '@/services/serverConnectionService';
import { discoveryService } from '@/app/services/discoveryService';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useServerConnection } from '@/app/hooks/useServerConnection';
import axios from 'axios';

const STORAGE_KEYS = {
  CONNECTION_MODE: 'connection_mode',
  MANUAL_URL: 'manual_server_url',
};

export function ServerSettingsScreen() {
  const navigation = useNavigation();
  const { showSnackbar } = useSnackbar();
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { isConnected, isHealthy, serverUrl, isSearching } =
    useServerConnection();

  const [mode, setMode] = useState<ConnectionMode>('auto');
  const [manualUrl, setManualUrl] = useState('');
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [showInfo, setShowInfo] = useState(false);
  const [isDiscovering, setIsDiscovering] = useState(false);
  const [discoveryProgress, setDiscoveryProgress] = useState({
    current: 0,
    total: 0,
    message: '',
  });

  useEffect(() => {
    loadSettings();
  }, []);

  useEffect(() => {
    // Actualizar el campo manual cuando cambie serverUrl
    if (serverUrl && !loading) {
      try {
        const url = new URL(serverUrl);
        setManualUrl(url.hostname);
      } catch {
        // Si no es una URL válida, intentar extraer la IP
        const cleanUrl = serverUrl.replace(/^https?:\/\//, '').split(':')[0];
        setManualUrl(cleanUrl);
      }
    }
  }, [serverUrl, loading]);

  const loadSettings = async () => {
    try {
      const [savedMode, savedUrl] = await Promise.all([
        EncryptedStorage.getItem(
          STORAGE_KEYS.CONNECTION_MODE,
        ) as Promise<ConnectionMode>,
        EncryptedStorage.getItem(STORAGE_KEYS.MANUAL_URL),
      ]);

      if (savedMode) setMode(savedMode);

      // Si hay una URL de servidor actual (de cualquier fuente), usarla para el campo manual
      if (serverUrl) {
        try {
          const url = new URL(serverUrl);
          setManualUrl(url.hostname);
        } catch {
          // Si no es una URL válida, intentar extraer la IP
          const cleanUrl = serverUrl.replace(/^https?:\/\//, '').split(':')[0];
          setManualUrl(cleanUrl);
        }
      } else if (savedUrl) {
        // Si no hay servidor actual pero sí una URL manual guardada, usarla
        try {
          const url = new URL(savedUrl);
          setManualUrl(url.hostname);
        } catch {
          // Si no es una URL válida, usar como está
          setManualUrl(savedUrl);
        }
      }
    } catch (error) {
    } finally {
      setLoading(false);
    }
  };

  const validateUrl = (url: string): boolean => {
    // Validar que sea una IP válida o un dominio
    const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const domainRegex =
      /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9](?:\.[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])*$/;

    // Quitar espacios
    const trimmed = url.trim();

    // No debe incluir protocolo ni puerto
    if (
      trimmed.includes('http://') ||
      trimmed.includes('https://') ||
      trimmed.includes(':')
    ) {
      return false;
    }

    return ipRegex.test(trimmed) || domainRegex.test(trimmed);
  };

  const saveSettings = async () => {
    setSaving(true);
    try {
      // Validar primero si es manual
      if (mode === 'manual') {
        if (!validateUrl(manualUrl)) {
          showSnackbar('Por favor ingresa una URL válida', 'error');
          setSaving(false);
          return;
        }
      }

      // Guardar la configuración
      await EncryptedStorage.setItem(STORAGE_KEYS.CONNECTION_MODE, mode);

      if (mode === 'manual') {
        // Guardar la URL completa, no solo la IP
        const fullUrl = `http://${manualUrl.trim()}:3737`;
        await EncryptedStorage.setItem(STORAGE_KEYS.MANUAL_URL, fullUrl);
      }

      // Primero establecer la URL si es necesario
      let urlToCheck: string | null = null;

      if (mode === 'manual') {
        // Construir la URL completa con http y el puerto estándar
        const fullUrl = `http://${manualUrl.trim()}:3737`;
        await discoveryService.setServerUrl(fullUrl, true);
        urlToCheck = fullUrl;
      } else if (mode === 'auto') {
        // En modo auto, limpiar cualquier URL manual
        await discoveryService.setServerUrl(null, true);
      }

      // Luego establecer el modo (esto actualizará la URL mostrada)
      await serverConnectionService.setConnectionMode(mode);

      // Comportamiento diferente según el modo
      if (mode === 'auto') {
        // En modo automático, hacer discovery
        setIsDiscovering(true);
        showSnackbar('Iniciando búsqueda de servidor...', 'info');

        try {
          // Limpiar cualquier URL manual previa
          await discoveryService.setServerUrl(null, true);

          // Configurar callback de progreso
          discoveryService.setProgressCallback((progress) => {
            setDiscoveryProgress(progress);
          });

          // Hacer discovery
          const discoveredUrl = await discoveryService.discoverServer();

          if (discoveredUrl) {
            showSnackbar('Servidor encontrado ✓', 'success');
            // El discovery ya actualiza el estado, solo necesitamos iniciar el monitoreo
            const { healthMonitoringService } = await import(
              '@/services/healthMonitoringService'
            );
            healthMonitoringService.startMonitoring();
          } else {
            showSnackbar('No se encontró servidor en la red', 'error');
          }
        } catch (error) {
          showSnackbar('Error al buscar servidor', 'error');
        } finally {
          setIsDiscovering(false);
          discoveryService.setProgressCallback(null);
          setDiscoveryProgress({ current: 0, total: 0, message: '' });
        }
      } else {
        // Para manual, hacer reconnect para aplicar la nueva configuración
        showSnackbar('Aplicando configuración...', 'info');

        try {
          // Hacer reconnect que reinicializará todo con la nueva URL
          await serverConnectionService.reconnect();

          showSnackbar('Configuración guardada - Conectado ✓', 'success');
        } catch (error) {
          showSnackbar('Verificando conexión...', 'info');

          // Si el reconnect falla, intentar un health check directo
          const { healthMonitoringService } = await import(
            '@/services/healthMonitoringService'
          );

          try {
            const isHealthy = await healthMonitoringService.forceCheck();

            if (isHealthy) {
              showSnackbar(
                'Configuración guardada - Servidor accesible ✓',
                'success',
              );
              healthMonitoringService.startMonitoring();
            } else {
              showSnackbar(
                'Configuración guardada - El servidor no responde ✗',
                'warning',
              );
            }
          } catch (error) {
            showSnackbar(
              'Configuración guardada - Error al verificar servidor',
              'warning',
            );
          }
        }
      }
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al guardar la configuración',
        'error',
      );
    } finally {
      setSaving(false);
    }
  };

  const renderConnectionStatus = () => {
    let chipIcon = 'alert-circle';
    let chipText = 'Sin conexión';
    let chipColor = theme.colors.error;
    let chipBgColor = theme.dark
      ? 'rgba(244, 67, 54, 0.2)'
      : 'rgba(244, 67, 54, 0.1)';

    if (isSearching) {
      chipIcon = 'wifi-sync';
      chipText = 'Buscando...';
      chipColor = theme.colors.warning || '#FF9800';
      chipBgColor = theme.dark
        ? 'rgba(255, 152, 0, 0.2)'
        : 'rgba(255, 152, 0, 0.1)';
    } else if (isConnected && isHealthy) {
      chipIcon = 'check-circle';
      chipText = 'Conectado';
      chipColor = theme.colors.success || '#4CAF50';
      chipBgColor = theme.dark
        ? 'rgba(76, 175, 80, 0.2)'
        : 'rgba(76, 175, 80, 0.1)';
    }

    return (
      <Chip
        icon={chipIcon}
        mode="flat"
        compact
        style={{
          backgroundColor: chipBgColor,
          transform: [{ scale: 0.85 }],
        }}
        textStyle={{ color: chipColor, fontSize: 12 }}
      >
        {chipText}
      </Chip>
    );
  };

  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.scrollContent}
    >
      {/* Estado de Conexión */}
      <View style={styles.section}>
        <View style={styles.sectionHeader}>
          <Text style={styles.sectionTitle}>Estado de Conexión</Text>
          {renderConnectionStatus()}
          <View style={{ flex: 1 }} />
          <IconButton
            icon="information"
            size={20}
            onPress={() => setShowInfo(true)}
            iconColor={theme.colors.onSurfaceVariant}
          />
        </View>

        <View>
          <Surface style={styles.infoCard} elevation={0}>
            <View style={styles.infoRow}>
              <View style={styles.infoItem}>
                <Icon
                  source="server"
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
                <View style={styles.infoContent}>
                  <Text variant="labelSmall" style={styles.infoLabel}>
                    Servidor
                  </Text>
                  <Text variant="bodyMedium" style={styles.infoValue}>
                    {serverUrl
                      ? serverUrl.replace(/^https?:\/\//, '').split(':')[0]
                      : '-'}
                  </Text>
                </View>
              </View>

              <View style={styles.infoDivider} />

              <View style={styles.infoItem}>
                <Icon
                  source="ethernet-cable"
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
                <View style={styles.infoContent}>
                  <Text variant="labelSmall" style={styles.infoLabel}>
                    Puerto
                  </Text>
                  <Text variant="bodyMedium" style={styles.infoValue}>
                    {serverUrl
                      ? serverUrl.split(':').pop()?.split('/')[0] || '3737'
                      : '3737'}
                  </Text>
                </View>
              </View>
            </View>

            {serverUrl && !isHealthy && isConnected && (
              <View style={styles.healthWarning}>
                <Icon
                  source="alert"
                  size={16}
                  color={theme.colors.warning || '#FF9800'}
                />
                <Text variant="labelSmall" style={styles.healthWarningText}>
                  El servidor no responde correctamente
                </Text>
              </View>
            )}
          </Surface>
        </View>
      </View>

      {/* Modo de Conexión */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Modo de Conexión</Text>

        <RadioButton.Group
          onValueChange={(value) => setMode(value as ConnectionMode)}
          value={mode}
        >
          <TouchableRipple
            onPress={() => setMode('auto')}
            style={[
              styles.radioOption,
              mode === 'auto' && styles.radioOptionActive,
            ]}
            rippleColor={`${theme.colors.primary}20`}
          >
            <View style={styles.radioContent}>
              <Icon
                source="wifi"
                size={24}
                color={
                  mode === 'auto'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              <View style={styles.radioTextContainer}>
                <Text
                  variant="titleMedium"
                  style={[
                    styles.radioTitle,
                    mode === 'auto' && { color: theme.colors.primary },
                  ]}
                >
                  Automático
                </Text>
                <Text variant="bodySmall" style={styles.radioSubtitle}>
                  Busca el servidor en tu red local
                </Text>
              </View>
              <RadioButton
                value="auto"
                status={mode === 'auto' ? 'checked' : 'unchecked'}
              />
            </View>
          </TouchableRipple>

          <TouchableRipple
            onPress={() => setMode('manual')}
            style={[
              styles.radioOption,
              mode === 'manual' && styles.radioOptionActive,
              { marginBottom: 0 },
            ]}
            rippleColor={`${theme.colors.primary}20`}
          >
            <View>
              <View style={styles.radioContent}>
                <Icon
                  source="pencil-outline"
                  size={24}
                  color={
                    mode === 'manual'
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
                <View style={styles.radioTextContainer}>
                  <Text
                    variant="titleMedium"
                    style={[
                      styles.radioTitle,
                      mode === 'manual' && { color: theme.colors.primary },
                    ]}
                  >
                    Manual
                  </Text>
                  <Text variant="bodySmall" style={styles.radioSubtitle}>
                    Especifica la URL del servidor
                  </Text>
                </View>
                <RadioButton
                  value="manual"
                  status={mode === 'manual' ? 'checked' : 'unchecked'}
                />
              </View>
              {mode === 'manual' && (
                <View style={styles.manualInputContainer}>
                  <TextInput
                    label="Dirección IP o Dominio"
                    value={manualUrl}
                    onChangeText={setManualUrl}
                    placeholder="192.168.1.100"
                    mode="outlined"
                    autoCapitalize="none"
                    autoCorrect={false}
                    keyboardType="default"
                    error={manualUrl !== '' && !validateUrl(manualUrl)}
                    outlineColor={theme.colors.outline}
                    activeOutlineColor={theme.colors.primary}
                    style={styles.manualInput}
                  />
                  <HelperText
                    type={
                      manualUrl !== '' && !validateUrl(manualUrl)
                        ? 'error'
                        : 'info'
                    }
                    visible={true}
                  >
                    {manualUrl !== '' && !validateUrl(manualUrl)
                      ? 'Ingresa solo la IP (ej: 192.168.1.100) sin http:// ni puerto'
                      : 'Solo la dirección IP sin protocolo. El puerto 3737 se añadirá automáticamente.'}
                  </HelperText>
                </View>
              )}
            </View>
          </TouchableRipple>
        </RadioButton.Group>
      </View>

      {/* Indicador de progreso del discovery */}
      {isDiscovering && (
        <View style={styles.discoveryProgressContainer}>
          <Surface style={styles.discoveryProgressCard} elevation={1}>
            <View style={styles.discoveryHeader}>
              <Icon
                source="magnify-scan"
                size={24}
                color={theme.colors.primary}
              />
              <Text style={styles.discoveryTitle}>
                Buscando servidor en la red
              </Text>
            </View>
            <ProgressBar
              progress={
                discoveryProgress.total > 0
                  ? discoveryProgress.current / discoveryProgress.total
                  : 0
              }
              color={theme.colors.primary}
              style={styles.progressBar}
            />
            <Text style={styles.discoveryMessage}>
              {discoveryProgress.message || 'Iniciando búsqueda...'}
            </Text>
            {discoveryProgress.total > 0 && (
              <Text style={styles.discoveryStats}>
                {discoveryProgress.current} de {discoveryProgress.total} IPs
                escaneadas
              </Text>
            )}
          </Surface>
        </View>
      )}

      {/* Botón de guardar */}
      <View style={styles.actionButtons}>
        <Button
          mode="contained"
          onPress={saveSettings}
          loading={saving}
          disabled={saving || isDiscovering}
          icon="content-save"
          style={styles.saveButton}
          contentStyle={styles.buttonContent}
          labelStyle={styles.buttonLabel}
        >
          Guardar Configuración
        </Button>
      </View>

      <Portal>
        <Dialog visible={showInfo} onDismiss={() => setShowInfo(false)}>
          <Dialog.Title>Información de Conexión</Dialog.Title>
          <Dialog.Content>
            <Paragraph style={styles.infoParagraph}>
              <Text style={styles.boldText}>Modo Automático:</Text>
              {'\n'}Ideal para uso en el restaurante. La app busca el servidor
              en la red local.
            </Paragraph>

            <Paragraph style={styles.infoParagraph}>
              <Text style={styles.boldText}>Modo Manual:</Text>
              {'\n'}Configura manualmente la URL del servidor para casos
              especiales.
            </Paragraph>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowInfo(false)}>Cerrar</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </ScrollView>
  );
}

const createStyles = (theme: any, responsive: any) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: 40,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.background,
    },
    section: {
      marginHorizontal: 16,
      marginTop: 20,
      marginBottom: 16,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 16,
    },
    sectionTitle: {
      fontSize: responsive?.isWeb ? 20 : 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginRight: 12,
    },
    infoCard: {
      backgroundColor: theme.dark
        ? theme.colors.surfaceVariant
        : theme.colors.surface,
      borderRadius: 12,
      padding: 20,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-around',
    },
    infoItem: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
      gap: 8,
    },
    infoContent: {
      flex: 1,
    },
    infoLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
      fontSize: responsive?.isWeb ? 12 : 11,
    },
    infoValue: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      fontSize: responsive?.isWeb ? 16 : 14,
    },
    infoDivider: {
      width: 1,
      height: 40,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: 12,
    },
    healthWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 4,
      marginTop: 12,
      paddingTop: 12,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    healthWarningText: {
      color: theme.colors.warning || '#FF9800',
      flex: 1,
    },
    radioOption: {
      marginBottom: 12,
      borderRadius: 12,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      overflow: 'hidden',
    },
    radioOptionActive: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.dark
        ? 'rgba(103, 80, 164, 0.08)'
        : 'rgba(103, 80, 164, 0.05)',
    },
    radioContent: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: 16,
      gap: 12,
    },
    radioTextContainer: {
      flex: 1,
    },
    radioTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    radioSubtitle: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    radioDetails: {
      marginTop: 8,
      marginLeft: 48,
      marginRight: 16,
      marginBottom: 12,
      padding: 8,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 8,
    },
    radioDetailsText: {
      color: theme.colors.onSurfaceVariant,
      fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    },
    manualInputContainer: {
      paddingTop: 8,
      paddingHorizontal: 16,
      paddingBottom: 12,
    },
    manualInput: {
      backgroundColor: theme.colors.surface,
    },
    actionButtons: {
      marginHorizontal: 16,
      marginTop: 12,
      marginBottom: 20,
    },
    saveButton: {
      backgroundColor: theme.colors.primary,
    },
    buttonContent: {
      paddingVertical: 8,
    },
    buttonLabel: {
      fontSize: responsive?.isWeb ? 16 : 14,
    },
    infoParagraph: {
      marginBottom: 12,
      color: theme.colors.onSurfaceVariant,
      lineHeight: responsive?.isWeb ? 24 : 20,
    },
    boldText: {
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    discoveryProgressContainer: {
      marginHorizontal: 16,
      marginTop: 16,
      marginBottom: 8,
    },
    discoveryProgressCard: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      padding: 16,
      borderWidth: 1,
      borderColor: theme.colors.primary,
    },
    discoveryHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      marginBottom: 12,
    },
    discoveryTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    progressBar: {
      height: 6,
      borderRadius: 3,
      marginBottom: 12,
    },
    discoveryMessage: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
    },
    discoveryStats: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
  });

================
File: app/src/modules/shared/components/PrintTicketModal.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  TouchableOpacity,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  RadioButton,
  Button,
  Surface,
  IconButton,
  Divider,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { usePrintersQuery } from '@/modules/printers/hooks/usePrintersQueries';

// Interfaz mínima que requiere el componente
interface OrderBasicInfo {
  shiftOrderNumber: number;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN' | 'TAKEOUT';
}

interface PrintTicketModalProps {
  visible: boolean;
  onDismiss: () => void;
  order: OrderBasicInfo | null;
  onPrint: (
    printerId: string,
    ticketType: 'GENERAL' | 'BILLING',
  ) => Promise<void>;
}

export const PrintTicketModal: React.FC<PrintTicketModalProps> = ({
  visible,
  onDismiss,
  order,
  onPrint,
}) => {
  const theme = useAppTheme();
  const { data: printersResponse, isLoading: isLoadingPrinters } =
    usePrintersQuery({ page: 1, limit: 100 });
  const [selectedTicketType, setSelectedTicketType] = useState<
    'GENERAL' | 'BILLING'
  >('GENERAL');
  const [selectedPrinterId, setSelectedPrinterId] = useState<string>('');
  const [isPrinting, setIsPrinting] = useState(false);

  // Extraer impresoras del response paginado y filtrar solo las activas
  const printers = printersResponse?.data || [];
  const activePrinters = printers.filter((printer) => printer.isActive);

  // Seleccionar la primera impresora activa por defecto
  useEffect(() => {
    if (activePrinters.length > 0 && !selectedPrinterId) {
      setSelectedPrinterId(activePrinters[0].id);
    }
  }, [activePrinters, selectedPrinterId]);

  // Seleccionar tipo de ticket según el tipo de orden
  useEffect(() => {
    if (order) {
      // Para órdenes DINE_IN, usar BILLING (ticket de cuenta)
      // Para TAKE_AWAY, TAKEOUT, DELIVERY, usar GENERAL
      if (order.orderType === 'DINE_IN') {
        setSelectedTicketType('BILLING');
      } else {
        setSelectedTicketType('GENERAL');
      }
    }
  }, [order]);

  const handlePrint = async () => {
    if (!selectedPrinterId || !order) return;

    setIsPrinting(true);
    try {
      await onPrint(selectedPrinterId, selectedTicketType);
      onDismiss();
    } catch (error) {
      // Error al imprimir ticket
    } finally {
      setIsPrinting(false);
    }
  };

  if (!order) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContent,
          { backgroundColor: theme.colors.background },
        ]}
      >
        <View style={styles.header}>
          <Text style={[styles.title, { color: theme.colors.onSurface }]}>
            Imprimir Ticket - Orden #{order.shiftOrderNumber}
          </Text>
          <IconButton
            icon="close"
            size={24}
            onPress={onDismiss}
            style={styles.closeButton}
          />
        </View>

        <Divider />

        <ScrollView style={styles.content}>
          {/* Tipo de Ticket */}
          <View style={styles.section}>
            <Text
              style={[styles.sectionTitle, { color: theme.colors.primary }]}
            >
              Tipo de Ticket
            </Text>
            <RadioButton.Group
              onValueChange={(value) =>
                setSelectedTicketType(value as 'GENERAL' | 'BILLING')
              }
              value={selectedTicketType}
            >
              <TouchableOpacity
                activeOpacity={0.7}
                onPress={() => setSelectedTicketType('GENERAL')}
              >
                <Surface
                  style={[
                    styles.radioItem,
                    {
                      backgroundColor: theme.colors.surface,
                      borderColor:
                        selectedTicketType === 'GENERAL'
                          ? theme.colors.primary
                          : 'transparent',
                      borderWidth: selectedTicketType === 'GENERAL' ? 2 : 0,
                    },
                  ]}
                >
                  <View style={styles.radioContent}>
                    <RadioButton value="GENERAL" color={theme.colors.primary} />
                    <View style={styles.radioTextContainer}>
                      <Text
                        style={[
                          styles.radioLabel,
                          { color: theme.colors.onSurface },
                        ]}
                      >
                        📋 Ticket General
                      </Text>
                      <Text
                        style={[
                          styles.radioDescription,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        Para cocina y delivery (letras grandes)
                      </Text>
                    </View>
                  </View>
                </Surface>
              </TouchableOpacity>
              <TouchableOpacity
                activeOpacity={0.7}
                onPress={() => setSelectedTicketType('BILLING')}
              >
                <Surface
                  style={[
                    styles.radioItem,
                    {
                      backgroundColor: theme.colors.surface,
                      borderColor:
                        selectedTicketType === 'BILLING'
                          ? theme.colors.primary
                          : 'transparent',
                      borderWidth: selectedTicketType === 'BILLING' ? 2 : 0,
                    },
                  ]}
                >
                  <View style={styles.radioContent}>
                    <RadioButton value="BILLING" color={theme.colors.primary} />
                    <View style={styles.radioTextContainer}>
                      <Text
                        style={[
                          styles.radioLabel,
                          { color: theme.colors.onSurface },
                        ]}
                      >
                        💵 Ticket de Cuenta
                      </Text>
                      <Text
                        style={[
                          styles.radioDescription,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        Para cobro al cliente (formato cuenta)
                      </Text>
                    </View>
                  </View>
                </Surface>
              </TouchableOpacity>
            </RadioButton.Group>
          </View>

          {/* Selección de Impresora */}
          <View style={styles.section}>
            <Text
              style={[styles.sectionTitle, { color: theme.colors.primary }]}
            >
              Seleccionar Impresora
            </Text>
            {isLoadingPrinters ? (
              <ActivityIndicator size="small" color={theme.colors.primary} />
            ) : activePrinters.length === 0 ? (
              <Text
                style={[styles.noPrintersText, { color: theme.colors.error }]}
              >
                No hay impresoras activas disponibles
              </Text>
            ) : (
              <RadioButton.Group
                onValueChange={(value) => setSelectedPrinterId(value)}
                value={selectedPrinterId}
              >
                {activePrinters.map((printer) => (
                  <TouchableOpacity
                    key={printer.id}
                    activeOpacity={0.7}
                    onPress={() => setSelectedPrinterId(printer.id)}
                  >
                    <Surface
                      style={[
                        styles.radioItem,
                        {
                          backgroundColor: theme.colors.surface,
                          borderColor:
                            selectedPrinterId === printer.id
                              ? theme.colors.primary
                              : 'transparent',
                          borderWidth: selectedPrinterId === printer.id ? 2 : 0,
                        },
                      ]}
                    >
                      <View style={styles.radioContent}>
                        <RadioButton
                          value={printer.id}
                          color={theme.colors.primary}
                        />
                        <View style={styles.radioTextContainer}>
                          <Text
                            style={[
                              styles.radioLabel,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            🖨️ {printer.name}
                          </Text>
                          <Text
                            style={[
                              styles.radioDescription,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {printer.ipAddress} - Puerto {printer.port}
                          </Text>
                        </View>
                      </View>
                    </Surface>
                  </TouchableOpacity>
                ))}
              </RadioButton.Group>
            )}
          </View>
        </ScrollView>

        <Divider />

        <View style={styles.footer}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            textColor={theme.colors.error}
            style={[styles.footerButton, { borderColor: theme.colors.error }]}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handlePrint}
            loading={isPrinting}
            disabled={
              !selectedPrinterId || activePrinters.length === 0 || isPrinting
            }
            style={[styles.footerButton, styles.printButton]}
            buttonColor={theme.colors.primary}
          >
            Imprimir
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};

const styles = StyleSheet.create({
  modalContent: {
    margin: 16,
    borderRadius: 16,
    maxHeight: '85%',
    overflow: 'hidden',
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  title: {
    fontSize: 18,
    fontWeight: '700',
    flex: 1,
  },
  closeButton: {
    margin: -8,
  },
  content: {
    maxHeight: 400,
  },
  section: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 8,
  },
  radioItem: {
    marginBottom: 6,
    borderRadius: 10,
    elevation: 1,
    padding: 2,
  },
  radioContent: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  radioTextContainer: {
    flex: 1,
    marginLeft: 8,
  },
  radioLabel: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 2,
  },
  radioDescription: {
    fontSize: 11,
    opacity: 0.7,
  },
  noPrintersText: {
    fontSize: 13,
    textAlign: 'center',
    padding: 12,
    fontWeight: '500',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    gap: 12,
  },
  footerButton: {
    minWidth: 100,
    borderRadius: 8,
  },
  printButton: {
    paddingHorizontal: 4,
  },
});

================
File: app/src/modules/shiftAudit/components/index.ts
================
export { ShiftOrdersModal } from './ShiftOrdersModal';
export { OrderDetailsView } from './OrderDetailsView';
export { OrderHistoryView } from './OrderHistoryView';
export { ShiftSalesSummaryView } from './ShiftSalesSummaryView';

================
File: app/src/modules/shiftAudit/components/OrderDetailsView.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Surface,
  Text,
  Divider,
  Appbar,
  ActivityIndicator,
  IconButton,
  Chip,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import type { Receipt } from '@/modules/receipts/types/receipt.types';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';

interface OrderDetailsViewProps {
  order: Receipt | null;
  onBack: () => void;
  onShowHistory?: () => void;
  isLoading?: boolean;
}

const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';

  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalf.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalf.HALF_2
            ? 'HALF_2'
            : 'FULL';

      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }

      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;

      if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationType.INGREDIENT
      ) {
        if (curr.action === CustomizationAction.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }

      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );

  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };

    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';

    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }

  return '';
};

export const OrderDetailsView: React.FC<OrderDetailsViewProps> = ({
  order,
  onBack,
  onShowHistory,
  isLoading = false,
}) => {
  const theme = useAppTheme();
  const [showPrintHistory, setShowPrintHistory] = useState(false);

  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return '🍽️ Local';
      case 'TAKE_AWAY':
        return '🥡 Llevar';
      case 'DELIVERY':
        return '🚚 Envío';
      default:
        return type;
    }
  };

  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparación';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      case 'COMPLETED':
        return 'Completado';
      case 'CANCELLED':
        return 'Cancelado';
      default:
        return status;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0';
      case 'COMPLETED':
        return '#10B981';
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getPaymentStatus = () => {
    if (order?.payments && order.payments.length > 0) {
      const totalPaid = order.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof order.total === 'string'
          ? parseFloat(order.total)
          : order.total || 0;

      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };

  const paymentStatus = order
    ? getPaymentStatus()
    : { label: 'Pendiente', color: '#EF4444' };

  const renderItem = (item: any) => {
    const quantity = item.quantity || 1;
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;

    return (
      <Surface
        key={`${item.id}`}
        style={[
          styles.itemCard,
          { backgroundColor: theme.colors.elevation.level1, marginBottom: 8 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}

            {item.productModifiers && item.productModifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.productModifiers.map((modifier: any) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      • {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}

            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📝 {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total ×{quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };

  if (isLoading) {
    return (
      <View style={styles.container}>
        <Appbar.Header style={styles.appbarHeader}>
          <Appbar.BackAction onPress={onBack} />
          <Appbar.Content title="Cargando..." />
        </Appbar.Header>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text
            style={[
              styles.loadingText,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Cargando detalles del recibo...
          </Text>
        </View>
      </View>
    );
  }

  if (!order) {
    return null;
  }

  return (
    <View
      style={[styles.container, { backgroundColor: theme.colors.background }]}
    >
      <Appbar.Header style={styles.appbarHeader}>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content title={`Recibo #${order?.shiftOrderNumber || ''}`} />
        <Appbar.Action
          icon="history"
          size={28}
          onPress={onShowHistory}
          disabled={!onShowHistory}
        />
      </Appbar.Header>

      <View style={styles.header}>
        <View style={styles.headerInfo}>
          <View style={styles.headerTopRow}>
            <View style={styles.headerLeft}>
              <Text style={[styles.orderType, { color: theme.colors.primary }]}>
                {order ? getOrderTypeLabel(order.orderType) : ''}
              </Text>
            </View>
          </View>
          <View style={styles.headerBottomRow}>
            <View style={styles.chipsRow}>
              <View
                style={[
                  styles.headerStatusChip,
                  {
                    backgroundColor: order
                      ? getStatusColor(order.orderStatus)
                      : theme.colors.surfaceVariant,
                  },
                ]}
              >
                <Text style={styles.headerStatusChipText}>
                  {order ? getOrderStatusLabel(order.orderStatus) : ''}
                </Text>
              </View>
              {order?.preparationScreens &&
                order.preparationScreens.map((screen, index) => (
                  <Chip
                    key={index}
                    mode="outlined"
                    compact
                    style={styles.screenChip}
                    textStyle={styles.screenChipText}
                  >
                    🍳 {screen}
                  </Chip>
                ))}
            </View>
          </View>
          <View style={styles.headerDatesRow}>
            <Text
              style={[
                styles.headerDate,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Creado:{' '}
              {order?.createdAt
                ? format(new Date(order.createdAt), 'dd/MM/yyyy HH:mm', {
                    locale: es,
                  })
                : ''}
            </Text>
            {order?.finalizedAt && (
              <Text
                style={[styles.headerDate, { color: theme.colors.primary }]}
              >
                Finalizado:{' '}
                {format(new Date(order.finalizedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            )}
          </View>
        </View>
      </View>

      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.scrollContent}
      >
        <View style={styles.infoSection}>
          {order?.deliveryInfo?.recipientName && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                👤 Nombre del Cliente: {order.deliveryInfo.recipientName}
              </Text>
            </View>
          )}

          {order?.deliveryInfo?.recipientPhone && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                📞 Teléfono: {order.deliveryInfo.recipientPhone}
              </Text>
            </View>
          )}

          {order?.orderType === 'DELIVERY' &&
            order?.deliveryInfo?.fullAddress && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.addressText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📦 Dirección de Entrega: {order.deliveryInfo.fullAddress}
                </Text>
              </View>
            )}

          {order?.orderType === 'DINE_IN' && order?.table && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.tableText, { color: theme.colors.onSurface }]}
              >
                🏛️ Mesa: {order.table.area?.name || 'Sin área'} -{' '}
                {order.table.number}
              </Text>
            </View>
          )}

          {order?.scheduledAt && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.primary, fontWeight: '600' },
                ]}
              >
                ⏰ Hora de Entrega Programada:{' '}
                {format(new Date(order.scheduledAt), 'HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          )}

          {order?.user && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                👨‍💼 Atendido por: {order.user.firstName} {order.user.lastName}
              </Text>
            </View>
          )}

          {order?.notes && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.notesText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                📋 Notas: {order.notes}
              </Text>
            </View>
          )}
        </View>

        <Divider style={styles.divider} />

        <View style={styles.itemsList}>
          {order?.orderItems?.map((item) => renderItem(item)) || []}
        </View>

        <Divider style={styles.divider} />

        {order?.payments && order.payments.length > 0 && (
          <>
            <View style={styles.paymentsSection}>
              <View style={styles.paymentSummaryCompact}>
                <View style={styles.summaryCompactRow}>
                  <Text
                    style={[
                      styles.summaryCompactLabel,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    Total: $
                    {typeof order.total === 'string'
                      ? parseFloat(order.total).toFixed(2)
                      : (order.total || 0).toFixed(2)}
                  </Text>
                  <Text
                    style={[styles.summaryCompactLabel, { color: '#10B981' }]}
                  >
                    Pagado: $
                    {order.payments
                      .reduce((sum, p) => sum + p.amount, 0)
                      .toFixed(2)}
                  </Text>
                  {(() => {
                    const totalAmount =
                      typeof order.total === 'string'
                        ? parseFloat(order.total)
                        : order.total || 0;
                    const totalPaid = order.payments.reduce(
                      (sum, p) => sum + p.amount,
                      0,
                    );
                    const remaining = totalAmount - totalPaid;
                    if (remaining > 0) {
                      return (
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            {
                              color: theme.colors.error,
                              fontWeight: '600',
                            },
                          ]}
                        >
                          Resta: ${remaining.toFixed(2)}
                        </Text>
                      );
                    }
                    return null;
                  })()}
                </View>
              </View>

              {order.payments.map((payment, index) => {
                const getPaymentMethodLabel = (method: string) => {
                  switch (method) {
                    case 'CASH':
                    case 'cash':
                      return 'Efectivo';
                    case 'CREDIT_CARD':
                    case 'card':
                      return 'Tarjeta de Crédito';
                    case 'DEBIT_CARD':
                      return 'Tarjeta de Débito';
                    case 'TRANSFER':
                    case 'transfer':
                      return 'Transferencia';
                    case 'OTHER':
                      return 'Otro';
                    default:
                      return method;
                  }
                };

                const getPaymentStatusColor = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return '#10B981';
                    case 'PENDING':
                      return '#F59E0B';
                    case 'FAILED':
                      return theme.colors.error;
                    case 'REFUNDED':
                      return '#6B7280';
                    case 'CANCELLED':
                      return theme.colors.error;
                    default:
                      return theme.colors.onSurfaceVariant;
                  }
                };

                const getPaymentStatusLabel = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return 'Completado';
                    case 'PENDING':
                      return 'Pendiente';
                    case 'FAILED':
                      return 'Fallido';
                    case 'REFUNDED':
                      return 'Reembolsado';
                    case 'CANCELLED':
                      return 'Cancelado';
                    default:
                      return status;
                  }
                };

                return (
                  <View
                    key={payment.id || index}
                    style={styles.paymentRowCompact}
                  >
                    <Text
                      style={[
                        styles.paymentMethodCompact,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      💳 {getPaymentMethodLabel(payment.paymentMethod)}
                    </Text>
                    <Text
                      style={[
                        styles.paymentDateCompact,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {format(new Date(payment.createdAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                    <View
                      style={[
                        styles.paymentStatusBadgeCompact,
                        {
                          backgroundColor:
                            getPaymentStatusColor(payment.paymentStatus) + '20',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.paymentStatusTextCompact,
                          {
                            color: getPaymentStatusColor(payment.paymentStatus),
                          },
                        ]}
                      >
                        {getPaymentStatusLabel(payment.paymentStatus)}
                      </Text>
                    </View>
                    <Text
                      style={[
                        styles.paymentAmountCompact,
                        { color: theme.colors.primary },
                      ]}
                    >
                      ${payment.amount.toFixed(2)}
                    </Text>
                  </View>
                );
              })}
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {order?.ticketImpressions && order.ticketImpressions.length > 0 && (
          <>
            <View style={styles.ticketImpressionsSection}>
              <TouchableOpacity
                style={styles.collapsibleHeader}
                onPress={() => setShowPrintHistory(!showPrintHistory)}
                activeOpacity={0.7}
              >
                <Text
                  style={[styles.sectionTitle, { color: theme.colors.primary }]}
                >
                  🖨️ Historial de Impresiones ({order.ticketImpressions.length})
                </Text>
                <IconButton
                  icon={showPrintHistory ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  style={styles.collapseIcon}
                />
              </TouchableOpacity>

              {showPrintHistory && (
                <View style={styles.collapsibleContent}>
                  {order.ticketImpressions.map((impression, index) => {
                    const getTicketTypeLabel = (type: string) => {
                      switch (type) {
                        case 'KITCHEN':
                          return '🍳 Cocina';
                        case 'BAR':
                          return '🍺 Barra';
                        case 'BILLING':
                          return '💵 Cuenta';
                        case 'CUSTOMER_COPY':
                          return '📄 Copia Cliente';
                        case 'GENERAL':
                          return '📋 General';
                        default:
                          return type;
                      }
                    };

                    return (
                      <View
                        key={impression.id || index}
                        style={styles.impressionRow}
                      >
                        <View style={styles.impressionLeft}>
                          <Text
                            style={[
                              styles.impressionType,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            {getTicketTypeLabel(impression.ticketType)}
                          </Text>
                          <View style={styles.impressionDetails}>
                            {impression.user && (
                              <Text
                                style={[
                                  styles.impressionUser,
                                  { color: theme.colors.onSurfaceVariant },
                                ]}
                              >
                                por {impression.user.firstName || ''}{' '}
                                {impression.user.lastName || ''}
                              </Text>
                            )}
                            {impression.printer && (
                              <Text
                                style={[
                                  styles.impressionPrinter,
                                  { color: theme.colors.onSurfaceVariant },
                                ]}
                              >
                                🖨️ {impression.printer.name}
                              </Text>
                            )}
                          </View>
                        </View>
                        <Text
                          style={[
                            styles.impressionTime,
                            { color: theme.colors.onSurfaceVariant },
                          ]}
                        >
                          {format(
                            new Date(impression.impressionTime),
                            'HH:mm:ss',
                            { locale: es },
                          )}
                        </Text>
                      </View>
                    );
                  })}
                </View>
              )}
            </View>
          </>
        )}
      </ScrollView>

      <Divider style={styles.divider} />

      <View style={styles.footer}>
        <View style={styles.footerLeft}>
          <Text
            style={[
              styles.totalLabel,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Total:
          </Text>
          <Text style={[styles.totalAmount, { color: theme.colors.primary }]}>
            $
            {order
              ? typeof order.total === 'string'
                ? parseFloat(order.total).toFixed(2)
                : (order.total || 0).toFixed(2)
              : '0.00'}
          </Text>
        </View>
        <View
          style={[
            styles.paymentBadge,
            { backgroundColor: paymentStatus.color },
          ]}
        >
          <Text style={styles.paymentBadgeText}>💵 {paymentStatus.label}</Text>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  appbarHeader: {
    elevation: 0,
  },
  header: {
    paddingHorizontal: 16,
    paddingTop: 10,
    paddingBottom: 6,
  },
  headerTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  headerLeft: {
    flex: 1,
  },
  headerBottomRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  headerDatesRow: {
    gap: 8,
    marginTop: 4,
  },
  chipsRow: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    flexWrap: 'wrap',
  },
  headerSeparator: {
    fontSize: 14,
    marginHorizontal: 6,
  },
  orderType: {
    fontSize: 15,
    fontWeight: '600',
  },
  headerDate: {
    fontSize: 13,
  },
  headerInfo: {
    // Contenedor para toda la información del header
  },
  infoSection: {
    paddingHorizontal: 16,
    paddingTop: 4,
    paddingBottom: 6,
    gap: 4,
  },
  infoRow: {
    marginVertical: 2,
  },
  contactText: {
    fontSize: 14,
  },
  addressText: {
    fontSize: 14,
    lineHeight: 18,
  },
  tableText: {
    fontSize: 14,
  },
  screenChip: {
    height: 24,
  },
  screenChipText: {
    fontSize: 12,
    marginVertical: -2,
  },
  paymentBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  paymentBadgeText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },
  totalAmount: {
    fontSize: 18,
    fontWeight: '700',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.08)',
    backgroundColor: 'inherit',
  },
  footerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  totalLabel: {
    fontSize: 16,
    fontWeight: '600',
  },
  divider: {
    marginVertical: 2,
  },
  headerStatusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  headerStatusChipText: {
    color: 'white',
    fontSize: 13,
    fontWeight: '600',
  },
  scrollView: {
    flexGrow: 0,
    flexShrink: 1,
    maxHeight: '70%',
  },
  scrollContent: {
    paddingBottom: 8,
  },
  itemsList: {
    padding: 12,
    paddingBottom: 16,
  },
  itemCard: {
    borderRadius: 8,
    overflow: 'hidden',
  },
  itemContent: {
    padding: 10,
  },
  itemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  nameContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  itemQuantity: {
    fontSize: 16,
    fontWeight: '700',
    marginRight: 6,
  },
  itemName: {
    fontSize: 15,
    fontWeight: '600',
    flex: 1,
    lineHeight: 18,
  },
  statusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusChipText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  itemDetailsContainer: {
    marginBottom: 6,
  },
  customizationContainer: {
    marginBottom: 4,
  },
  pizzaCustomizationText: {
    fontSize: 13,
    fontStyle: 'italic',
    lineHeight: 16,
  },
  modifiersContainer: {
    marginTop: 2,
  },
  modifierRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 1,
  },
  modifierText: {
    fontSize: 13,
    flex: 1,
    lineHeight: 16,
  },
  modifierPrice: {
    fontSize: 13,
    fontWeight: '500',
    marginLeft: 4,
  },
  notesContainer: {
    marginTop: 4,
    paddingTop: 4,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  notesText: {
    fontSize: 13,
    fontStyle: 'italic',
    lineHeight: 16,
  },
  priceContainer: {
    marginTop: 6,
    paddingTop: 6,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  priceLabel: {
    fontSize: 13,
    opacity: 0.7,
  },
  priceValue: {
    fontSize: 14,
    fontWeight: '600',
  },
  totalPrice: {
    fontSize: 16,
    fontWeight: '700',
  },
  paymentsSection: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  paymentSummaryCompact: {
    marginBottom: 8,
  },
  summaryCompactRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  summaryCompactLabel: {
    fontSize: 14,
    fontWeight: '500',
  },
  paymentRowCompact: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
    gap: 8,
  },
  paymentMethodCompact: {
    fontSize: 13,
    fontWeight: '500',
    flex: 1,
  },
  paymentDateCompact: {
    fontSize: 12,
  },
  paymentAmountCompact: {
    fontSize: 14,
    fontWeight: '600',
    minWidth: 50,
    textAlign: 'right',
  },
  paymentStatusBadgeCompact: {
    paddingHorizontal: 6,
    paddingVertical: 1,
    borderRadius: 10,
  },
  paymentStatusTextCompact: {
    fontSize: 11,
    fontWeight: '600',
  },
  ticketImpressionsSection: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  collapsibleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingRight: 4,
  },
  collapseIcon: {
    margin: -8,
  },
  collapsibleContent: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 0,
  },
  impressionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
    paddingLeft: 8,
  },
  impressionLeft: {
    flex: 1,
    gap: 2,
  },
  impressionType: {
    fontSize: 14,
    fontWeight: '500',
  },
  impressionDetails: {
    gap: 2,
  },
  impressionUser: {
    fontSize: 13,
    opacity: 0.7,
  },
  impressionPrinter: {
    fontSize: 13,
    opacity: 0.7,
    fontStyle: 'italic',
  },
  impressionTime: {
    fontSize: 13,
    opacity: 0.7,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
});

================
File: app/src/modules/shiftAudit/components/ShiftSalesSummaryView.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Text,
  IconButton,
  Divider,
  ActivityIndicator,
  DataTable,
  ProgressBar,
  Appbar,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { formatCurrency } from '@/app/lib/formatters';
import { useShiftSalesSummary } from '../hooks/useShiftSalesSummary';
import type {
  CategorySalesSummary,
  SubcategorySalesSummary,
} from '../hooks/useShiftSalesSummary';

interface Props {
  shiftId: string;
  shiftNumber?: number;
  onBack: () => void;
}

export function ShiftSalesSummaryView({ shiftId, shiftNumber, onBack }: Props) {
  const theme = useAppTheme();
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set(),
  );
  const [expandedSubcategories, setExpandedSubcategories] = useState<
    Set<string>
  >(new Set());

  const { data: summary, isLoading, error } = useShiftSalesSummary(shiftId);

  const toggleCategory = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };

  const toggleSubcategory = (subcategoryId: string) => {
    const newExpanded = new Set(expandedSubcategories);
    if (newExpanded.has(subcategoryId)) {
      newExpanded.delete(subcategoryId);
    } else {
      newExpanded.add(subcategoryId);
    }
    setExpandedSubcategories(newExpanded);
  };

  const renderHeader = () => (
    <Appbar.Header elevated>
      <Appbar.BackAction onPress={onBack} />
      <Appbar.Content
        title={`Resumen de Ventas - Turno #${shiftNumber || summary?.shiftNumber || 'N/A'}`}
        titleStyle={{ fontSize: 18 }}
      />
    </Appbar.Header>
  );

  const renderSummaryCards = () => {
    if (!summary) return null;

    return (
      <View style={styles.summaryCardsContainer}>
        <View style={styles.summaryRow}>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>VENTAS</Text>
            <Text style={styles.summaryCardValue}>
              {formatCurrency(summary.totalSales)}
            </Text>
          </View>

          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>ÓRDENES</Text>
            <Text style={styles.summaryCardValue}>
              {summary.completedOrders}
            </Text>
          </View>
        </View>

        <View style={styles.summaryRow}>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>PRODUCTOS</Text>
            <Text style={styles.summaryCardValue}>{summary.totalQuantity}</Text>
          </View>

          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>PROMEDIO</Text>
            <Text style={styles.summaryCardValue}>
              {formatCurrency(summary.averageTicket)}
            </Text>
          </View>
        </View>

        <Text style={styles.adjustmentNote}>
          * Los totales incluyen ajustes aplicados (descuentos y cargos)
        </Text>
      </View>
    );
  };

  const renderCategoryItem = (category: CategorySalesSummary) => {
    const isExpanded = expandedCategories.has(category.categoryId);

    return (
      <View key={category.categoryId}>
        <TouchableOpacity
          onPress={() => toggleCategory(category.categoryId)}
          activeOpacity={0.7}
        >
          <View style={styles.categoryItem}>
            <View style={styles.categoryHeader}>
              <View style={styles.categoryInfo}>
                <View style={styles.categoryTitleRow}>
                  <Text style={styles.categoryName}>
                    {category.categoryName}
                  </Text>
                  <Text style={styles.categoryPercentage}>
                    {category.percentage.toFixed(1)}%
                  </Text>
                </View>
                <View style={styles.categoryStatsRow}>
                  <Text style={styles.categoryQuantity}>
                    {category.quantity} productos vendidos
                  </Text>
                  <Text style={styles.categoryAmount}>
                    {formatCurrency(category.totalAmount)}
                  </Text>
                </View>
                <ProgressBar
                  progress={category.percentage / 100}
                  style={styles.progressBar}
                  color={theme.colors.primary}
                />
              </View>
              <IconButton
                icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                size={24}
                iconColor={theme.colors.onSurfaceVariant}
                style={styles.expandIcon}
              />
            </View>
          </View>
        </TouchableOpacity>

        {isExpanded && category.subcategories.length > 0 && (
          <View style={styles.subcategoriesContainer}>
            {category.subcategories.map((subcategory) =>
              renderSubcategoryItem(subcategory),
            )}
          </View>
        )}
      </View>
    );
  };

  const renderSubcategoryItem = (subcategory: SubcategorySalesSummary) => {
    const isExpanded = expandedSubcategories.has(subcategory.subcategoryId);

    return (
      <View key={subcategory.subcategoryId}>
        <TouchableOpacity
          onPress={() => toggleSubcategory(subcategory.subcategoryId)}
          activeOpacity={0.7}
        >
          <View style={styles.subcategoryItem}>
            <View style={styles.subcategoryHeader}>
              <View style={styles.subcategoryInfo}>
                <Text style={styles.subcategoryName}>
                  {subcategory.subcategoryName}
                </Text>
                <Text style={styles.subcategoryStats}>
                  {subcategory.quantity} productos •{' '}
                  {formatCurrency(subcategory.totalAmount)}
                </Text>
              </View>
              <IconButton
                icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                size={18}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>
          </View>
        </TouchableOpacity>

        {isExpanded && subcategory.products.length > 0 && (
          <View style={styles.productsContainer}>
            {subcategory.products.map((product) => (
              <View key={product.productId} style={styles.productItem}>
                <Text style={styles.productName}>{product.productName}</Text>
                <View style={styles.productStats}>
                  <Text style={styles.productQuantity}>
                    {product.quantity}x
                  </Text>
                  <Text style={styles.productAmount}>
                    {formatCurrency(product.totalAmount)}
                  </Text>
                </View>
              </View>
            ))}
          </View>
        )}
      </View>
    );
  };

  const renderTopProducts = () => {
    if (!summary || !summary.topProducts || summary.topProducts.length === 0) {
      return null;
    }

    return (
      <View style={styles.topProductsSection}>
        <Text style={styles.sectionTitle}>Top 10 Productos Más Vendidos</Text>
        <View style={styles.topProductsTable}>
          <DataTable>
            <DataTable.Header>
              <DataTable.Title style={styles.rankColumn}>#</DataTable.Title>
              <DataTable.Title style={styles.productColumn}>
                Producto
              </DataTable.Title>
              <DataTable.Title numeric style={styles.quantityColumn}>
                Cant.
              </DataTable.Title>
              <DataTable.Title numeric style={styles.amountColumn}>
                Total
              </DataTable.Title>
            </DataTable.Header>

            {summary.topProducts.slice(0, 10).map((product, index) => (
              <DataTable.Row key={product.productId}>
                <DataTable.Cell style={styles.rankColumn}>
                  <Text style={styles.rankNumber}>{index + 1}</Text>
                </DataTable.Cell>
                <DataTable.Cell style={styles.productColumn}>
                  <Text style={styles.topProductName} numberOfLines={2}>
                    {product.productName}
                  </Text>
                </DataTable.Cell>
                <DataTable.Cell numeric style={styles.quantityColumn}>
                  {product.quantity}
                </DataTable.Cell>
                <DataTable.Cell numeric style={styles.amountColumn}>
                  {formatCurrency(product.totalAmount)}
                </DataTable.Cell>
              </DataTable.Row>
            ))}
          </DataTable>
        </View>
      </View>
    );
  };

  const renderContent = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
          <Text style={styles.loadingText}>Cargando resumen de ventas...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>
            Error al cargar el resumen de ventas
          </Text>
        </View>
      );
    }

    if (!summary) {
      return (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>No hay datos disponibles</Text>
        </View>
      );
    }

    return (
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {renderSummaryCards()}

        <Divider style={styles.sectionDivider} />

        <View style={styles.categoriesSection}>
          <Text style={styles.sectionTitle}>Ventas por Categoría</Text>
          {summary.categories.map(renderCategoryItem)}
        </View>

        <Divider style={styles.sectionDivider} />

        {renderTopProducts()}
      </ScrollView>
    );
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: theme.spacing.xl,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    errorText: {
      color: theme.colors.error,
      fontSize: 16,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
    },
    summaryCardsContainer: {
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    summaryRow: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    summaryCard: {
      flex: 1,
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
    },
    summaryCardLabel: {
      fontSize: 10,
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 0.3,
    },
    summaryCardValue: {
      fontSize: 16,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginTop: 2,
    },
    adjustmentNote: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      textAlign: 'center',
      marginTop: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
    },
    sectionDivider: {
      marginVertical: theme.spacing.s,
      marginHorizontal: theme.spacing.m,
    },
    categoriesSection: {
      paddingHorizontal: theme.spacing.m,
    },
    sectionTitle: {
      fontSize: 18,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.m,
    },
    categoryItem: {
      marginBottom: theme.spacing.s,
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      elevation: 1,
    },
    categoryHeader: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    categoryInfo: {
      flex: 1,
    },
    categoryTitleRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    categoryName: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    categoryPercentage: {
      fontSize: 18,
      fontWeight: '700',
      color: theme.colors.primary,
    },
    categoryStatsRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    categoryQuantity: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    categoryAmount: {
      fontSize: 15,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    expandIcon: {
      marginLeft: theme.spacing.xs,
    },
    progressBar: {
      height: 4,
      borderRadius: 2,
      backgroundColor: theme.colors.surfaceVariant,
    },
    subcategoriesContainer: {
      paddingLeft: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    subcategoryItem: {
      marginBottom: theme.spacing.xs,
      marginHorizontal: theme.spacing.xs,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.background,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    subcategoryHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    subcategoryInfo: {
      flex: 1,
    },
    subcategoryName: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    subcategoryStats: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 4,
    },
    productsContainer: {
      paddingLeft: theme.spacing.m,
      paddingTop: theme.spacing.xs,
    },
    productItem: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
      marginHorizontal: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    productName: {
      flex: 1,
      fontSize: 12,
      color: theme.colors.onSurface,
    },
    productStats: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    productQuantity: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
      minWidth: 30,
      textAlign: 'right',
    },
    productAmount: {
      fontSize: 12,
      fontWeight: '600',
      color: theme.colors.primary,
      minWidth: 60,
      textAlign: 'right',
    },
    topProductsSection: {
      paddingHorizontal: theme.spacing.m,
      paddingBottom: theme.spacing.m,
    },
    topProductsTable: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    rankColumn: {
      flex: 0.5,
    },
    productColumn: {
      flex: 3,
    },
    quantityColumn: {
      flex: 1,
    },
    amountColumn: {
      flex: 1.5,
    },
    rankNumber: {
      fontWeight: '700',
      color: theme.colors.primary,
    },
    topProductName: {
      fontSize: 13,
      color: theme.colors.onSurface,
    },
  });

  return (
    <View style={styles.container}>
      {renderHeader()}
      {renderContent()}
    </View>
  );
}

================
File: app/src/modules/shiftAudit/hooks/useShiftOrders.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService } from '@/services/shifts';
import type { Order } from '@/app/schemas/domain/order.schema';
import type { Shift, ShiftSummary } from '../types';

export const useShiftOrders = (shiftId: string | undefined) => {
  return useQuery<Order[], Error>({
    queryKey: ['shifts', shiftId, 'orders'],
    queryFn: () => shiftsService.getOrdersByShift(shiftId!),
    enabled: !!shiftId,
    staleTime: 300000, // 5 minutos
  });
};

export const useShiftSummary = (shiftId: string | undefined) => {
  const shiftQuery = useQuery<Shift, Error>({
    queryKey: ['shifts', shiftId],
    queryFn: () => shiftsService.getById(shiftId!),
    enabled: !!shiftId,
  });

  const ordersQuery = useQuery<Order[], Error>({
    queryKey: ['shifts', shiftId, 'orders'],
    queryFn: () => shiftsService.getOrdersByShift(shiftId!),
    enabled: !!shiftId && shiftQuery.isSuccess,
  });

  const summary: ShiftSummary | undefined =
    shiftQuery.data && ordersQuery.data
      ? shiftsService.calculateShiftSummary(shiftQuery.data, ordersQuery.data)
      : undefined;

  return {
    summary,
    isLoading: shiftQuery.isLoading || ordersQuery.isLoading,
    error: shiftQuery.error || ordersQuery.error,
  };
};

================
File: app/src/modules/shiftAudit/navigation/ShiftAuditStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ShiftsListScreen } from '../screens/ShiftsListScreen';
import type { ShiftAuditStackParamList } from './types';

const Stack = createNativeStackNavigator<ShiftAuditStackParamList>();

export function ShiftAuditStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="ShiftsList"
        component={ShiftsListScreen}
        options={{
          title: 'Historial de Turnos',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/shiftAudit/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { CompositeScreenProps } from '@react-navigation/native';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import type { DrawerNavigatorParamList } from '@/app/navigation/types';

export type ShiftAuditStackParamList = {
  ShiftsList: undefined;
};

export type ShiftAuditStackScreenProps<
  T extends keyof ShiftAuditStackParamList,
> = CompositeScreenProps<
  NativeStackScreenProps<ShiftAuditStackParamList, T>,
  DrawerScreenProps<DrawerNavigatorParamList>
>;

export type ShiftsListScreenNavigationProp =
  ShiftAuditStackScreenProps<'ShiftsList'>['navigation'];
export type ShiftsListScreenRouteProp =
  ShiftAuditStackScreenProps<'ShiftsList'>['route'];

export type ShiftAuditStackNavigationProp = ShiftsListScreenNavigationProp;

================
File: app/src/modules/shiftAudit/screens/index.ts
================
export { ShiftsListScreen } from './ShiftsListScreen';

================
File: app/src/modules/shiftAudit/types/index.ts
================
export interface Shift {
  id: string;
  date: string;
  globalShiftNumber: number;
  shiftNumber: number;
  status: 'open' | 'closed';
  openedAt: string;
  closedAt: string | null;
  openedBy: User;
  closedBy: User | null;
  initialCash: number;
  finalCash: number | null;
  totalSales: number | null;
  totalOrders: number | null;
  cashDifference: number | null;
  expectedCash?: number | null;
  notes: string | null;
  closeNotes: string | null;
  createdAt?: string;
  updatedAt?: string;
}

export interface User {
  id: string;
  email?: string;
  firstName: string;
  lastName: string;
}

export interface ShiftSummary {
  shift: Shift;
  ordersCount: number;
  totalSales: number;
  paymentMethodsSummary: PaymentMethodSummary[];
  productsSummary: ProductSummary[];
}

export interface PaymentMethodSummary {
  method: string;
  count: number;
  total: number;
}

export interface ProductSummary {
  productName: string;
  quantity: number;
  total: number;
}

export interface ShiftOrder {
  id: string;
  orderNumber: string;
  total: number;
  status: string;
  paymentMethod: string;
  customerName: string | null;
  createdAt: string;
  items: OrderItem[];
}

export interface OrderItem {
  id: string;
  productName: string;
  quantity: number;
  unitPrice: number;
  total: number;
  modifiers?: string[];
}

================
File: app/src/modules/sync/screens/SyncStatusScreen.tsx
================
import React, { useState } from 'react';
import {
  ScrollView,
  RefreshControl,
  View,
  useWindowDimensions,
} from 'react-native';
import {
  Card,
  List,
  Text,
  ActivityIndicator,
  Divider,
  Icon,
  Chip,
  Surface,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useQuery } from '@tanstack/react-query';
import { formatDistanceToNow } from 'date-fns';
import { es } from 'date-fns/locale';
import { syncService } from '../services/syncService';
import {
  SyncActivity,
  SyncStatus,
  SyncActivityType,
  SYNC_TYPE_LABELS,
  SYNC_DIRECTION_LABELS,
} from '../types/sync.types';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { StyleSheet } from 'react-native';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

export function SyncStatusScreen() {
  const theme = useAppTheme();
  const { width: screenWidth } = useWindowDimensions();
  const { isTablet, deviceType } = useResponsive();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [refreshing, setRefreshing] = useState(false);

  // Ajustar padding según el dispositivo
  const contentPadding = isTablet ? theme.spacing.l : theme.spacing.m;

  // Query para el estado del servicio
  const {
    data: syncStatus,
    isLoading: isLoadingStatus,
    error: statusError,
    refetch: refetchStatus,
  } = useQuery({
    queryKey: ['sync-status'],
    queryFn: () => syncService.getSyncStatus(),
    refetchInterval: 30000, // Actualizar cada 30 segundos
  });

  // Query para la actividad reciente
  const {
    data: syncActivity,
    isLoading: isLoadingActivity,
    error: activityError,
    refetch: refetchActivity,
  } = useQuery({
    queryKey: ['sync-activity'],
    queryFn: () => syncService.getSyncActivity(20),
    refetchInterval: 30000,
  });

  const handleRefresh = async () => {
    setRefreshing(true);
    try {
      await Promise.all([refetchStatus(), refetchActivity()]);
    } catch (error) {
      showSnackbar('Error al actualizar información', 'error');
    } finally {
      setRefreshing(false);
    }
  };

  const formatTimestamp = (timestamp: string) => {
    try {
      return formatDistanceToNow(new Date(timestamp), {
        addSuffix: true,
        locale: es,
      });
    } catch {
      return 'Fecha inválida';
    }
  };

  const getActivityIcon = (type: SyncActivityType) => {
    switch (type) {
      case SyncActivityType.PULL_CHANGES:
        return 'cloud-download';
      case SyncActivityType.RESTAURANT_DATA:
        return 'store';
      case SyncActivityType.ORDER_STATUS:
        return 'check-circle';
      default:
        return 'sync';
    }
  };

  const getStatusColor = (success: boolean) => {
    return success ? theme.colors.success : theme.colors.error;
  };

  // Crear estilos dinámicos con el tema
  const styles = React.useMemo(
    () => createStyles(theme, isTablet),
    [theme, isTablet],
  );

  if (isLoadingStatus || isLoadingActivity) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>Cargando información...</Text>
        </View>
      </SafeAreaView>
    );
  }

  if (statusError || activityError) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.errorContainer}>
          <Icon source="alert-circle" size={48} color={theme.colors.error} />
          <Text style={styles.errorText}>
            Error al cargar información de sincronización
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={[
          styles.scrollContent,
          { padding: contentPadding },
          isTablet && styles.scrollContentTablet,
        ]}
      >
        {/* Estado del Servicio */}
        <Card style={styles.card} mode="elevated">
          <Card.Title
            title="Estado del Servicio"
            titleVariant="headlineSmall"
            left={(props) => <Icon {...props} source="information" />}
          />
          <Card.Content>
            <List.Item
              title="Sincronización"
              titleStyle={styles.listItemTitle}
              description={syncStatus?.enabled ? 'Habilitada' : 'Deshabilitada'}
              descriptionStyle={styles.listItemDescription}
              left={(props) => (
                <List.Icon
                  {...props}
                  icon={syncStatus?.enabled ? 'check-circle' : 'close-circle'}
                  color={
                    syncStatus?.enabled
                      ? theme.colors.success
                      : theme.colors.error
                  }
                />
              )}
            />
            <List.Item
              title="WebSocket"
              titleStyle={styles.listItemTitle}
              description={
                syncStatus?.webSocketEnabled
                  ? syncStatus?.webSocketConnected
                    ? 'Conectado'
                    : syncStatus?.webSocketFailed
                      ? 'Conexión fallida'
                      : 'Intentando conectar...'
                  : 'Deshabilitado'
              }
              descriptionStyle={[
                styles.listItemDescription,
                syncStatus?.webSocketFailed && { color: theme.colors.error },
              ]}
              left={(props) => (
                <List.Icon
                  {...props}
                  icon={
                    syncStatus?.webSocketFailed
                      ? 'access-point-off'
                      : 'access-point'
                  }
                  color={
                    syncStatus?.webSocketConnected
                      ? theme.colors.success
                      : syncStatus?.webSocketFailed
                        ? theme.colors.error
                        : syncStatus?.webSocketEnabled
                          ? theme.colors.warning
                          : theme.colors.outline
                  }
                />
              )}
            />
            {syncStatus?.remoteUrl && (
              <List.Item
                title="Servidor Remoto"
                titleStyle={styles.listItemTitle}
                description={syncStatus.remoteUrl}
                descriptionStyle={styles.listItemDescription}
                left={(props) => <List.Icon {...props} icon="server" />}
              />
            )}
            <List.Item
              title="Modo"
              titleStyle={styles.listItemTitle}
              description="Pull (bajo demanda)"
              descriptionStyle={styles.listItemDescription}
              left={(props) => <List.Icon {...props} icon="download" />}
            />
          </Card.Content>
        </Card>

        {/* Actividad Reciente */}
        <Card style={styles.card} mode="elevated">
          <Card.Title
            title="Actividad Reciente"
            titleVariant="headlineSmall"
            subtitle={`Últimas ${syncActivity?.length || 0} sincronizaciones`}
            left={(props) => <Icon {...props} source="history" />}
          />
          <Card.Content>
            {syncActivity && syncActivity.length > 0 ? (
              syncActivity.map((activity, index) => (
                <React.Fragment key={activity.id}>
                  <Surface
                    style={[
                      styles.activityItem,
                      !activity.success && styles.activityItemError,
                    ]}
                    elevation={0}
                  >
                    <View style={styles.activityHeader}>
                      <View style={styles.activityLeft}>
                        <Icon
                          source={getActivityIcon(activity.type)}
                          size={24}
                          color={getStatusColor(activity.success)}
                        />
                        <View style={styles.activityInfo}>
                          <Text
                            variant="bodyMedium"
                            style={styles.activityType}
                          >
                            {SYNC_TYPE_LABELS[activity.type]}
                          </Text>
                          <Text variant="bodySmall" style={styles.activityTime}>
                            {formatTimestamp(activity.timestamp)}
                          </Text>
                        </View>
                      </View>
                      <View style={styles.activityRight}>
                        <Chip
                          compact
                          mode="flat"
                          textStyle={[
                            styles.chipText,
                            {
                              color:
                                activity.direction === 'IN'
                                  ? theme.colors.onInfoContainer
                                  : theme.colors.onSuccessContainer,
                            },
                          ]}
                          style={[
                            styles.directionChip,
                            activity.direction === 'IN'
                              ? styles.chipIn
                              : styles.chipOut,
                          ]}
                        >
                          {SYNC_DIRECTION_LABELS[activity.direction]}
                        </Chip>
                        <Icon
                          source={activity.success ? 'check' : 'close'}
                          size={20}
                          color={getStatusColor(activity.success)}
                        />
                      </View>
                    </View>
                  </Surface>
                  {index < syncActivity.length - 1 && (
                    <Divider style={styles.divider} />
                  )}
                </React.Fragment>
              ))
            ) : (
              <View style={styles.emptyState}>
                <Icon
                  source="cloud-off-outline"
                  size={48}
                  color={theme.colors.outline}
                />
                <Text
                  variant="bodyMedium"
                  style={[styles.emptyText, { color: theme.colors.outline }]}
                >
                  No hay actividad reciente
                </Text>
              </View>
            )}
          </Card.Content>
        </Card>

        {/* Información adicional */}
        <Card style={[styles.card, styles.infoCard]} mode="contained">
          <Card.Content>
            <View style={styles.infoRow}>
              <Icon
                source="information-outline"
                size={20}
                color={theme.colors.onInfoContainer}
              />
              <Text variant="bodySmall" style={styles.infoText}>
                La sincronización se ejecuta automáticamente cuando hay cambios
                pendientes. No es necesaria ninguna acción manual.
              </Text>
            </View>
          </Card.Content>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
}

const createStyles = (
  theme: ReturnType<typeof useAppTheme>,
  isTablet: boolean,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: theme.spacing.xl,
    },
    scrollContentTablet: {
      maxWidth: 800,
      alignSelf: 'center',
      width: '100%',
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    errorText: {
      marginTop: theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    card: {
      marginBottom: theme.spacing.m,
      elevation: 2,
    },
    listItemTitle: {
      fontSize: isTablet ? 16 : 14,
      color: theme.colors.onSurface,
    },
    listItemDescription: {
      fontSize: isTablet ? 14 : 12,
      color: theme.colors.onSurfaceVariant,
    },
    activityItem: {
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.surfaceVariant,
    },
    activityItemError: {
      backgroundColor: theme.colors.errorContainer,
    },
    activityHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    activityLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    activityInfo: {
      marginLeft: theme.spacing.m,
      flex: 1,
    },
    activityType: {
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    activityTime: {
      opacity: 0.7,
      marginTop: 2,
      color: theme.colors.onSurfaceVariant,
    },
    activityRight: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    directionChip: {
      height: 24,
    },
    chipText: {
      fontSize: isTablet ? 12 : 11,
      marginVertical: 0,
      marginHorizontal: theme.spacing.s,
    },
    chipIn: {
      backgroundColor: theme.colors.infoContainer,
    },
    chipOut: {
      backgroundColor: theme.colors.successContainer,
    },
    divider: {
      marginVertical: theme.spacing.xs,
    },
    emptyState: {
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    emptyText: {
      marginTop: theme.spacing.m,
    },
    infoCard: {
      backgroundColor: theme.colors.infoContainer,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    infoText: {
      marginLeft: theme.spacing.s,
      flex: 1,
      lineHeight: 20,
      color: theme.colors.onInfoContainer,
    },
  });

================
File: app/src/modules/sync/types/sync.types.ts
================
// Tipos simplificados para el nuevo sistema de sincronización

export enum SyncActivityType {
  PULL_CHANGES = 'PULL_CHANGES',
  RESTAURANT_DATA = 'RESTAURANT_DATA',
  ORDER_STATUS = 'ORDER_STATUS',
}

export type SyncDirection = 'IN' | 'OUT';

export interface SyncActivity {
  id: string;
  type: SyncActivityType;
  direction: SyncDirection;
  success: boolean;
  timestamp: string;
}

export interface SyncStatus {
  enabled: boolean;
  webSocketEnabled: boolean;
  webSocketConnected?: boolean;
  webSocketFailed?: boolean;
  remoteUrl: string | null;
  mode: string;
}

// Mapeo de tipos para mostrar en la UI
export const SYNC_TYPE_LABELS: Record<SyncActivityType, string> = {
  [SyncActivityType.PULL_CHANGES]: 'Órdenes y Clientes',
  [SyncActivityType.RESTAURANT_DATA]: 'Menú y Configuración',
  [SyncActivityType.ORDER_STATUS]: 'Estado de Orden',
};

export const SYNC_DIRECTION_LABELS: Record<SyncDirection, string> = {
  IN: 'Desde la nube',
  OUT: 'Hacia la nube',
};

================
File: app/src/modules/users/services/usersApi.service.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import type {
  User,
  CreateUserDto,
  UpdateUserDto,
  UsersQuery,
  UsersResponse,
} from '../types';

export const usersApiService = {
  async findAll(params?: UsersQuery): Promise<UsersResponse> {
    const queryParams = new URLSearchParams();

    if (params?.page) queryParams.append('page', params.page.toString());
    if (params?.limit) queryParams.append('limit', params.limit.toString());
    if (params?.search) queryParams.append('search', params.search);
    if (params?.sortBy) queryParams.append('sortBy', params.sortBy);
    if (params?.sortOrder) queryParams.append('sortOrder', params.sortOrder);

    if (params?.filters) {
      if (params.filters.isActive !== undefined) {
        queryParams.append(
          'filters[isActive]',
          params.filters.isActive.toString(),
        );
      }
      if (params.filters.roles && params.filters.roles.length > 0) {
        queryParams.append(
          'filters[roles]',
          JSON.stringify(params.filters.roles),
        );
      }
    }

    const response = await apiClient.get(
      `${API_PATHS.USERS}?${queryParams.toString()}`,
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    return response.data;
  },

  async findOne(id: string): Promise<User> {
    const response = await apiClient.get(
      API_PATHS.USERS_BY_ID.replace(':id', id),
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },

  async create(data: CreateUserDto): Promise<User> {
    const response = await apiClient.post(API_PATHS.USERS, data);
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },

  async update(id: string, data: UpdateUserDto): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      data,
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },

  async remove(id: string): Promise<void> {
    const response = await apiClient.delete(
      API_PATHS.USERS_BY_ID.replace(':id', id),
    );
    if (!response.ok) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
  },

  async resetPassword(id: string, newPassword: string): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      {
        password: newPassword,
      },
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },

  async toggleActive(id: string, isActive: boolean): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      {
        isActive,
      },
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
};

================
File: app/src/services/serverConnectionService.ts
================
import { discoveryService } from '@/app/services/discoveryService';
import { healthMonitoringService } from '@/services/healthMonitoringService';
import { autoReconnectService } from '@/services/autoReconnectService';
import EncryptedStorage from '@/app/services/secureStorageService';
import NetInfo from '@react-native-community/netinfo';

export type ConnectionMode = 'auto' | 'manual';

interface ConnectionState {
  isConnected: boolean;
  isConnecting: boolean;
  lastError: string | null;
  mode: ConnectionMode;
  currentUrl: string | null;
  hasWifi: boolean;
  isHealthy: boolean;
  isSearching: boolean;
  error: string | null;
}

class ServerConnectionService {
  private state: ConnectionState = {
    isConnected: false,
    isConnecting: false,
    lastError: null,
    mode: 'auto',
    currentUrl: null,
    hasWifi: false,
    isHealthy: false,
    isSearching: false,
    error: null,
  };

  private listeners: Array<(state: ConnectionState) => void> = [];
  private connectionPromise: Promise<void> | null = null;
  private healthUnsubscribe: (() => void) | null = null;
  private reconnectUnsubscribe: (() => void) | null = null;
  private netInfoUnsubscribe: (() => void) | null = null;

  constructor() {
    this.loadConnectionMode();
    this.initializeListeners();

    setTimeout(() => {
      if (!this.state.isConnected && !this.state.isConnecting) {
        this.connect().catch(() => {});
      }
    }, 1000);
  }

  private async loadConnectionMode() {
    try {
      const savedMode = (await EncryptedStorage.getItem(
        'connection_mode',
      )) as ConnectionMode;
      if (savedMode) {
        this.state.mode = savedMode;
      }
    } catch (error) {}
  }

  private initializeListeners() {
    this.netInfoUnsubscribe = NetInfo.addEventListener((state) => {
      const hasWifi =
        !!state.isConnected &&
        (state.type === 'wifi' || state.type === 'ethernet');

      const previousHasWifi = this.state.hasWifi;

      // Si perdemos el WiFi, también perdemos la conexión
      if (!hasWifi && previousHasWifi) {
        this.updateState({
          hasWifi: false,
          isConnected: false,
          isHealthy: false,
          error: 'Sin conexión WiFi',
        });
        // Detener el monitoreo de salud cuando no hay WiFi
        healthMonitoringService.stopMonitoring();
      }
      // Si recuperamos el WiFi y no estamos conectados, intentar reconectar
      else if (hasWifi && !previousHasWifi) {
        this.updateState({ hasWifi });
        // Intentar reconectar automáticamente
        setTimeout(() => {
          if (!this.state.isConnected && !this.state.isConnecting) {
            this.connect().catch(() => {});
          }
        }, 1000);
      } else {
        this.updateState({ hasWifi });
      }
    });

    this.healthUnsubscribe = healthMonitoringService.subscribe(
      (healthState) => {
        const previousHealthy = this.state.isHealthy;
        this.updateState({
          isHealthy: healthState.isAvailable,
          error: healthState.message || this.state.error,
        });

        if (!previousHealthy && healthState.isAvailable && this.state.hasWifi) {
          this.updateState({
            isConnected: true,
            isHealthy: true,
            error: null,
            isSearching: false,
          });
        }
      },
    );

    this.reconnectUnsubscribe = autoReconnectService.subscribe(
      (reconnectState) => {
        this.updateState({
          isSearching: reconnectState.isReconnecting,
          error: reconnectState.lastError || this.state.error,
        });
      },
    );

    autoReconnectService.on('reconnected', async () => {
      const apiUrl = await discoveryService.getApiUrl();

      // Reinicializar el API client con la nueva URL
      const { reinitializeApiClient } = await import(
        '@/app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl);

      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
        lastError: null,
        isSearching: false,
      });
      healthMonitoringService.startMonitoring();
    });

    healthMonitoringService.on('recovered', async () => {
      const apiUrl = await discoveryService.getApiUrl();

      // Reinicializar el API client con la nueva URL
      const { reinitializeApiClient } = await import(
        '@/app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl);

      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
        lastError: null,
        isSearching: false,
      });

      if (!healthMonitoringService.isMonitoring()) {
        healthMonitoringService.startMonitoring();
      }
    });

    NetInfo.fetch().then((state) => {
      const hasWifi =
        !!state.isConnected &&
        (state.type === 'wifi' || state.type === 'ethernet');
      this.updateState({ hasWifi });

      // Si tenemos WiFi pero no estamos conectados, intentar conectar
      if (hasWifi && !this.state.isConnected && !this.state.isConnecting) {
        setTimeout(() => {
          this.connect().catch(() => {});
        }, 1000);
      }
    });
  }

  async setConnectionMode(mode: ConnectionMode) {
    this.state.mode = mode;

    // Si cambiamos a manual, actualizar la URL actual inmediatamente
    if (mode === 'manual') {
      const url = await discoveryService.getApiUrl();
      if (url) {
        this.updateState({ currentUrl: url });
      }
    }

    this.notifyListeners();
  }

  getConnectionMode(): ConnectionMode {
    return this.state.mode;
  }

  async connect(): Promise<void> {
    // Si ya hay una conexión en progreso, esperarla
    if (this.connectionPromise) {
      return this.connectionPromise;
    }

    this.connectionPromise = this.performConnection();

    try {
      await this.connectionPromise;
    } finally {
      this.connectionPromise = null;
    }
  }

  private async performConnection(): Promise<void> {
    this.updateState({ isConnecting: true, lastError: null });

    try {
      let apiUrl: string | null = null;

      // Intentar conectar según el modo
      switch (this.state.mode) {
        case 'auto':
          // Primero intentar con la última URL conocida
          apiUrl = await discoveryService.getLastKnownUrl();
          if (apiUrl) {
            const isHealthy =
              await healthMonitoringService.checkHealthWithUrl(apiUrl);
            if (!isHealthy) {
              // Si falla, intentar descubrimiento
              apiUrl = await discoveryService.discoverServer();
            }
          } else {
            // No hay URL conocida, hacer descubrimiento
            apiUrl = await discoveryService.discoverServer();
          }
          break;

        case 'manual':
          // Usar la URL configurada manualmente
          apiUrl = await discoveryService.getApiUrl();
          if (!apiUrl) {
            throw new Error('No se ha configurado una URL manual');
          }
          break;
      }

      if (!apiUrl) {
        throw new Error('No se pudo establecer conexión con el servidor');
      }

      // No sobrescribir la URL si ya está configurada manualmente
      // Solo actualizar si es modo auto
      if (this.state.mode === 'auto') {
        await discoveryService.setServerUrl(apiUrl, false);
      }

      // Verificar que el servidor esté respondiendo
      const isHealthy =
        await healthMonitoringService.checkHealthWithUrl(apiUrl);
      if (!isHealthy) {
        throw new Error('El servidor no está respondiendo correctamente');
      }

      // Iniciar monitoreo de salud
      healthMonitoringService.startMonitoring();

      // Reinicializar el API client con la nueva URL
      const { reinitializeApiClient } = await import(
        '@/app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl);

      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
      });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Error desconocido';
      this.updateState({
        isConnected: false,
        isConnecting: false,
        lastError: errorMessage,
        error: errorMessage,
        isHealthy: false,
      });
      throw error;
    }
  }

  async reconnect(): Promise<void> {
    return this.connect();
  }

  retry(): void {
    // Si no está conectado y hay WiFi, iniciar reconexión automática
    if (!this.state.isConnected && this.state.hasWifi) {
      autoReconnectService.startAutoReconnect();
    } else if (!this.state.hasWifi) {
      // Si no hay WiFi, actualizar el estado de error
      this.updateState({
        error: 'Sin conexión WiFi',
        lastError: 'Sin conexión WiFi',
      });
    }
  }

  async disconnect(): void {
    healthMonitoringService.stopMonitoring();
    autoReconnectService.stopAutoReconnect();
    this.updateState({
      isConnected: false,
      isConnecting: false,
      currentUrl: null,
      isHealthy: false,
    });
  }

  destroy() {
    if (this.healthUnsubscribe) {
      this.healthUnsubscribe();
    }
    if (this.reconnectUnsubscribe) {
      this.reconnectUnsubscribe();
    }
    if (this.netInfoUnsubscribe) {
      this.netInfoUnsubscribe();
    }
    // Limpiar los listeners de eventos
    autoReconnectService.off('reconnected');
    healthMonitoringService.off('recovered');
  }

  subscribe(listener: (state: ConnectionState) => void): () => void {
    this.listeners.push(listener);
    // Notificar inmediatamente el estado actual
    listener(this.state);

    // Retornar función para desuscribirse
    return () => {
      this.listeners = this.listeners.filter((l) => l !== listener);
    };
  }

  getState(): ConnectionState {
    return { ...this.state };
  }

  isConnected(): boolean {
    return this.state.isConnected;
  }

  getCurrentUrl(): string | null {
    return this.state.currentUrl;
  }

  private updateState(updates: Partial<ConnectionState>): void {
    this.state = { ...this.state, ...updates };
    this.notifyListeners();
  }

  private notifyListeners(): void {
    this.listeners.forEach((listener) => listener(this.state));
  }
}

export const serverConnectionService = new ServerConnectionService();

================
File: app/src/utils/logging.ts
================
// Utilidad para logging completo sin truncar datos
export const logComplete = (label: string, data: any) => {
  console.log(`\n========== ${label} ==========`);

  if (typeof data === 'object' && data !== null) {
    // Para objetos y arrays, usar JSON.stringify con formato bonito
    console.log(JSON.stringify(data, null, 2));
  } else {
    // Para primitivos, mostrar directamente
    console.log(data);
  }

  console.log(`========== FIN ${label} ==========\n`);
};

// Logger específico para errores con stack trace completo
export const logError = (label: string, error: any) => {
  console.error(`\n❌ ERROR: ${label}`);

  if (error instanceof Error) {
    console.error('Mensaje:', error.message);
    console.error('Stack completo:');
    console.error(error.stack);
  } else {
    console.error('Error completo:', JSON.stringify(error, null, 2));
  }

  console.error(`❌ FIN ERROR: ${label}\n`);
};

// Logger para respuestas de API
export const logApiResponse = (endpoint: string, response: any) => {
  console.log(`\n📡 API Response: ${endpoint}`);
  console.log('Status:', response.status || 'N/A');
  console.log('Headers:', response.headers || 'N/A');
  console.log('Data completa:');
  console.log(JSON.stringify(response.data || response, null, 2));
  console.log(`📡 FIN API Response: ${endpoint}\n`);
};

// Logger para debugging con múltiples valores
export const logDebug = (label: string, ...values: any[]) => {
  console.log(`\n🔍 DEBUG: ${label}`);

  values.forEach((value, index) => {
    console.log(`Valor ${index + 1}:`);
    if (typeof value === 'object' && value !== null) {
      console.log(JSON.stringify(value, null, 2));
    } else {
      console.log(value);
    }
  });

  console.log(`🔍 FIN DEBUG: ${label}\n`);
};

================
File: app/plugins/withCustomIcons.js
================
/* eslint-disable @typescript-eslint/no-var-requires */
const { withDangerousMod } = require('@expo/config-plugins');
const fs = require('fs');
const path = require('path');
/* eslint-enable @typescript-eslint/no-var-requires */

// Plugin para generar iconos personalizados
function withCustomIcons(config) {
  return withDangerousMod(config, [
    'android',
    async (config) => {
      const projectRoot = config.modRequest.projectRoot;
      const iconPath = path.join(projectRoot, 'assets', 'icon.png');
      const adaptiveIconPath = path.join(
        projectRoot,
        'assets',
        'adaptive-icon.png',
      );
      const splashPath = path.join(projectRoot, 'assets', 'splash.png');

      console.log('🎨 CloudBite Icon Plugin - Starting icon generation...');

      // Verificar que existen los iconos
      if (!fs.existsSync(iconPath)) {
        console.error('❌ Icon not found at:', iconPath);
        return config;
      }

      console.log('✅ Icon found at:', iconPath);

      // Durante el prebuild, los iconos ya son procesados por Expo
      // Este plugin solo sirve para logging y verificación
      console.log('📱 Icons will be processed during EAS build');

      // Para splash screen
      if (fs.existsSync(splashPath)) {
        console.log('✅ Splash screen found at:', splashPath);
      }

      // Para icono adaptativo
      if (fs.existsSync(adaptiveIconPath)) {
        console.log('✅ Adaptive icon found at:', adaptiveIconPath);
      }

      return config;
    },
  ]);
}

module.exports = withCustomIcons;

================
File: app/src/app/components/common/AnimatedLabelInput.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  TextInput,
  Animated,
  StyleSheet,
  TextInputProps,
  StyleProp,
  ViewStyle,
  TextStyle,
  TouchableWithoutFeedback,
  Easing,
} from 'react-native';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface AnimatedLabelInputProps extends TextInputProps {
  label: string;
  containerStyle?: StyleProp<ViewStyle>;
  inputStyle?: StyleProp<TextStyle>;
  labelStyle?: StyleProp<TextStyle>;
  activeLabelColor?: string;
  inactiveLabelColor?: string;
  borderColor?: string;
  activeBorderColor?: string;
  error?: boolean;
  errorColor?: string;
  disabled?: boolean;
}

const AnimatedLabelInput = React.forwardRef<TextInput, AnimatedLabelInputProps>(
  (
    {
      label,
      value,
      onChangeText,
      onFocus,
      onBlur,
      style,
      containerStyle,
      inputStyle,
      labelStyle,
      activeLabelColor,
      inactiveLabelColor,
      borderColor: defaultBorderColor,
      activeBorderColor: focusedBorderColor,
      error = false,
      errorColor: customErrorColor,
      multiline,
      disabled = false, // Añadir disabled a las props destructuradas
      ...rest
    },
    ref,
  ) => {
    const theme = useAppTheme();
    const responsive = useResponsive();
    const [isFocused, setIsFocused] = useState(false);
    const animation = useRef(new Animated.Value(value ? 1 : 0)).current;

    const isActive = isFocused || (value != null && value !== '');

    const finalActiveLabelColor = activeLabelColor || theme.colors.primary;
    const finalInactiveLabelColor =
      inactiveLabelColor || theme.colors.onSurfaceVariant;
    const finalBorderColor = defaultBorderColor || theme.colors.outline;
    const finalActiveBorderColor = focusedBorderColor || theme.colors.primary;
    const finalErrorColor = customErrorColor || theme.colors.error;

    useEffect(() => {
      Animated.timing(animation, {
        toValue: isActive ? 1 : 0,
        duration: 150,
        useNativeDriver: false,
        easing: Easing.bezier(0.4, 0.0, 0.2, 1), // Material Design easing
      }).start();
    }, [isActive, animation]);

    const handleFocus = (e: any) => {
      setIsFocused(true);
      onFocus?.(e);
    };

    const handleBlur = (e: any) => {
      setIsFocused(false);
      onBlur?.(e);
    };

    // Usar ref externa o crear una nueva
    const inputRef = useRef<TextInput>(null);
    const finalRef = ref || inputRef;

    const labelScale = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [1, 0.8], // Escala más sutil
    });

    const labelColor = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [finalInactiveLabelColor, finalActiveLabelColor],
    });

    const currentBorderColor = error
      ? finalErrorColor
      : isFocused
        ? finalActiveBorderColor
        : finalBorderColor;

    const styles = React.useMemo(
      () =>
        createStyles(theme, responsive, {
          multiline,
          disabled,
          finalInactiveLabelColor,
        }),
      [theme, responsive, multiline, disabled, finalInactiveLabelColor],
    );

    const animatedTranslateY = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0, -28],
    });

    const animatedTranslateX = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0, -4],
    });

    const animatedLabelStyle = {
      position: 'absolute' as const,
      top: 20,
      left: 12,
      zIndex: 10, // Aumentar z-index para mejor visibilidad
      transform: [
        { translateX: animatedTranslateX },
        { translateY: animatedTranslateY },
        { scale: labelScale },
      ],
      color: labelColor,
      backgroundColor: theme.colors.background,
      maxWidth: isActive ? ('85%' as `${number}%`) : ('90%' as `${number}%`),
    };

    // Estilos estáticos que no deben ser animados
    const staticLabelStyle = {
      paddingHorizontal: isActive ? 4 : 0,
      paddingVertical: isActive ? 1 : 0,
    };

    const handleContainerPress = () => {
      if (
        !disabled &&
        finalRef &&
        typeof finalRef !== 'function' &&
        finalRef.current
      ) {
        finalRef.current.focus();
      }
    };

    return (
      <TouchableWithoutFeedback
        onPress={handleContainerPress}
        disabled={disabled}
      >
        <View
          style={[
            styles.container,
            { borderColor: currentBorderColor },
            containerStyle,
          ]}
        >
          {/* Línea de fondo para crear efecto de muesca en el borde */}
          <Animated.View
            style={{
              position: 'absolute',
              top: -1, // Sobre el borde superior
              left: 10,
              height: 2, // Mismo grosor que el borde
              backgroundColor: theme.colors.background,
              zIndex: 5,
              opacity: animation.interpolate({
                inputRange: [0, 0.5, 1],
                outputRange: [0, 0.8, 1],
              }),
              transform: [
                {
                  scaleX: animation.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0, 1],
                  }),
                },
              ],
              width: Math.min(label.length * 6.5 + 16, 200), // Ancho fijo basado en el texto con límite máximo
            }}
          />
          <Animated.Text
            style={[
              styles.label,
              staticLabelStyle,
              labelStyle,
              animatedLabelStyle,
            ]}
            numberOfLines={1}
            ellipsizeMode="tail"
          >
            {label}
          </Animated.Text>
          <View style={[styles.inputContainer, { pointerEvents: 'box-none' }]}>
            <TextInput
              ref={finalRef}
              value={value}
              onChangeText={onChangeText}
              onFocus={handleFocus}
              onBlur={handleBlur}
              style={[styles.input, inputStyle, style]}
              placeholder=""
              editable={!disabled}
              pointerEvents={disabled ? 'none' : 'auto'}
              underlineColorAndroid="transparent"
              placeholderTextColor={finalInactiveLabelColor}
              multiline={multiline}
              autoCorrect={false}
              keyboardAppearance={theme.dark ? 'dark' : 'light'}
              {...rest}
            />
          </View>
        </View>
      </TouchableWithoutFeedback>
    );
  },
);

AnimatedLabelInput.displayName = 'AnimatedLabelInput';

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
  props: {
    multiline?: boolean;
    disabled: boolean;
    finalInactiveLabelColor: string;
  },
) =>
  StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      position: 'relative',
      backgroundColor: theme.colors.background,
      minHeight: responsive.isTablet ? 52 : 58,
    },
    inputContainer: {
      flexDirection: 'row',
      alignItems: props.multiline ? 'flex-start' : 'center',
      paddingTop: responsive.isTablet ? 16 : 18,
      paddingBottom: responsive.isTablet ? 4 : 6,
      minHeight: responsive.isTablet ? 36 : 40,
    },
    label: {
      fontSize: responsive.fontSize(16),
      color: props.finalInactiveLabelColor,
    },
    input: {
      flex: 1,
      fontSize: responsive.fontSize(16),
      color: props.disabled
        ? theme.colors.onSurfaceDisabled
        : theme.colors.onSurface,
      paddingVertical: 0,
      paddingHorizontal: 0,
      margin: 0,
      borderWidth: 0,
      backgroundColor: 'transparent',
      textAlignVertical: props.multiline ? 'top' : 'center',
    },
  });

export default AnimatedLabelInput;

================
File: app/src/app/components/common/ConfirmationModal.tsx
================
import React from 'react';
import { ResponsiveConfirmModal } from '../responsive/ResponsiveModal';

interface ConfirmationModalProps {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel?: () => void;
  onDismiss?: () => void;
  confirmText?: string;
  cancelText?: string;
  confirmButtonColor?: string;
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  visible,
  title,
  message,
  onConfirm,
  onCancel,
  onDismiss,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  confirmButtonColor,
}) => {
  // Determinar si es destructivo basado en el color del botón
  const destructive =
    confirmButtonColor &&
    (confirmButtonColor.includes('error') ||
      confirmButtonColor === '#f44336' ||
      confirmButtonColor === '#F44336' ||
      confirmButtonColor === 'error');

  return (
    <ResponsiveConfirmModal
      visible={visible}
      onDismiss={onDismiss || (() => {})}
      title={title}
      message={message}
      onConfirm={onConfirm}
      onCancel={onCancel}
      confirmText={confirmText}
      cancelText={cancelText}
      destructive={destructive}
      maxWidth={450}
      widthTablet="70%"
      widthMobile="90%"
    />
  );
};

export default ConfirmationModal;

================
File: app/src/app/components/common/GlobalSnackbar.tsx
================
import React from 'react';
import { Snackbar, Portal, Text } from 'react-native-paper';
import { StyleSheet } from 'react-native';
import {
  useSnackbarStore,
  SnackbarType,
} from '../../../app/store/snackbarStore';
import { useAppTheme } from '../../../app/styles/theme';

const GlobalSnackbar: React.FC = () => {
  const { visible, message, type, duration, hideSnackbar } = useSnackbarStore();
  const theme = useAppTheme();

  React.useEffect(() => {
    if (visible && message) {
      const timer = setTimeout(() => {
        hideSnackbar();
      }, duration || 2500);

      return () => clearTimeout(timer);
    }
  }, [visible, message, duration, hideSnackbar]);

  const getBackgroundColor = (snackbarType: SnackbarType) => {
    switch (snackbarType) {
      case 'success':
        return theme.colors.successContainer;
      case 'error':
        return theme.colors.errorContainer;
      case 'warning':
        return theme.colors.warningContainer || theme.colors.tertiaryContainer;
      case 'info':
        return theme.colors.infoContainer || theme.colors.surfaceVariant;
      default:
        return theme.colors.inverseSurface;
    }
  };

  const getTextColor = (snackbarType: SnackbarType) => {
    const defaultTextColor = theme.dark
      ? theme.colors.surface
      : theme.colors.onSurface;

    switch (snackbarType) {
      case 'success':
        return theme.colors.onSuccessContainer || defaultTextColor;
      case 'error':
        return theme.colors.onErrorContainer;
      case 'warning':
        return (
          theme.colors.onWarningContainer || theme.colors.onTertiaryContainer
        );
      case 'info':
        return theme.colors.onInfoContainer || theme.colors.onSurfaceVariant;
      default:
        return theme.colors.inverseOnSurface;
    }
  };

  const backgroundColor = getBackgroundColor(type);
  const textColor = getTextColor(type);

  return (
    <Portal>
      <Snackbar
        visible={visible}
        onDismiss={hideSnackbar}
        duration={duration || 2500}
        style={[
          styles.snackbar,
          {
            backgroundColor,
            marginBottom: 40,
          },
        ]}
        theme={{
          ...theme,
          colors: {
            ...theme.colors,
            inversePrimary: textColor,
            inverseOnSurface: textColor,
          },
        }}
      >
        <Text style={styles.messageText}>{message || ''}</Text>
      </Snackbar>
    </Portal>
  );
};

const styles = StyleSheet.create({
  snackbar: {
    marginHorizontal: 16,
    borderRadius: 8,
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 3,
    },
    shadowOpacity: 0.27,
    shadowRadius: 4.65,
  },
  messageText: {
    textAlign: 'center',
    width: '100%',
  },
});

export default GlobalSnackbar;

================
File: app/src/app/hooks/useGlobalShift.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService, type Shift } from '@/services/shifts';

export const useGlobalShift = () => {
  return useQuery<Shift | null, Error>({
    queryKey: ['global', 'shift', 'current'],
    queryFn: () => shiftsService.getCurrentShift(),
    staleTime: 60 * 1000, // Los datos se consideran obsoletos después de 60 segundos
    cacheTime: 5 * 60 * 1000, // Mantener en caché por 5 minutos
    refetchInterval: 2 * 60 * 1000, // Actualizar cada 2 minutos automáticamente
    refetchOnWindowFocus: false, // No actualizar automáticamente al volver al foco
    refetchOnMount: 'always', // Actualizar siempre al montar el componente
    refetchOnReconnect: true, // Actualizar cuando se reconecta
    retry: 1, // Solo reintentar una vez en caso de error
    retryDelay: 1000, // Esperar 1 segundo antes de reintentar
  });
};

================
File: app/src/app/hooks/useRefreshOnFocus.ts
================
import { useEffect, useCallback } from 'react';
import { useFocusEffect } from '@react-navigation/native';
import { useQueryClient } from '@tanstack/react-query';

/**
 * Hook que refresca las queries especificadas cuando la pantalla recibe el foco
 * @param queryKeys - Array de query keys a invalidar cuando la pantalla reciba foco
 * @param options - Opciones adicionales
 */
export function useRefreshOnFocus(
  queryKeys: (string | readonly unknown[])[],
  options?: {
    enabled?: boolean;
    refetchOnMount?: boolean;
  },
) {
  const queryClient = useQueryClient();
  const { enabled = true, refetchOnMount = true } = options || {};

  // Invalidar queries cuando la pantalla recibe foco
  useFocusEffect(
    useCallback(() => {
      if (!enabled) return;

      // Invalidar todas las queries especificadas
      queryKeys.forEach((queryKey) => {
        queryClient.invalidateQueries({
          queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
        });
      });
    }, [enabled, queryKeys, queryClient]),
  );

  // También invalidar al montar si está habilitado
  useEffect(() => {
    if (!enabled || !refetchOnMount) return;

    queryKeys.forEach((queryKey) => {
      queryClient.invalidateQueries({
        queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
      });
    });
  }, [enabled, refetchOnMount, queryKeys, queryClient]);

  return {
    refetch: () => {
      queryKeys.forEach((queryKey) => {
        queryClient.invalidateQueries({
          queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
        });
      });
    },
  };
}

/**
 * Hook que refresca todas las queries de un módulo cuando la pantalla recibe foco
 * @param modulePrefix - Prefijo del módulo (ej: 'products', 'orders', etc)
 */
export function useRefreshModuleOnFocus(
  modulePrefix: string,
  options?: {
    enabled?: boolean;
  },
) {
  const queryClient = useQueryClient();
  const { enabled = true } = options || {};

  useFocusEffect(
    useCallback(() => {
      if (!enabled) return;

      // Invalidar todas las queries que empiecen con el prefijo del módulo
      queryClient.invalidateQueries({
        predicate: (query) => {
          const queryKey = query.queryKey;
          if (Array.isArray(queryKey) && queryKey.length > 0) {
            return queryKey[0] === modulePrefix;
          }
          return false;
        },
      });
    }, [enabled, modulePrefix, queryClient]),
  );
}

================
File: app/src/app/hooks/useResponsive.ts
================
import { useState, useEffect, useCallback, useMemo } from 'react';
import { Dimensions, PixelRatio, ScaledSize, Platform } from 'react-native';
import {
  BREAKPOINTS,
  DEVICE_TYPES,
  getDeviceType,
  isTablet as checkIsTablet,
  scaleWidth,
  scaleHeight,
  scaleWithLimits,
  getResponsiveDimension,
  RESPONSIVE_SPACING,
  RESPONSIVE_FONT_SIZES,
  RESPONSIVE_DIMENSIONS,
  applyResponsiveStyle,
  getGridColumns,
  getOrientation as getOrientationUtil,
  maintainAspectRatio,
  normalizeDPI,
} from '@/app/styles/responsive';

interface ResponsiveInfo {
  // Dimensiones de pantalla
  width: number;
  height: number;

  // Información del dispositivo
  deviceType: string;
  isTablet: boolean;
  isMobile: boolean;
  isSmallMobile: boolean;
  isWeb: boolean;
  isDesktop: boolean;

  // Orientación
  orientation: 'portrait' | 'landscape';
  isPortrait: boolean;
  isLandscape: boolean;

  // Densidad de píxeles
  pixelRatio: number;
  fontScale: number;

  // Funciones de escalado
  scaleWidth: (size: number) => number;
  scaleHeight: (size: number) => number;
  scaleWithLimits: (
    size: number,
    minScale?: number,
    maxScale?: number,
  ) => number;
  getResponsiveDimension: (mobile: number, tablet: number) => number;

  // Spacing responsive
  spacing: (value: number) => number;
  spacingPreset: {
    xxxs: number;
    xxs: number;
    xs: number;
    s: number;
    m: number;
    l: number;
    xl: number;
    xxl: number;
  };

  // Tamaños de fuente responsive
  fontSize: (value: number) => number;
  fontSizePreset: {
    xs: number;
    s: number;
    m: number;
    l: number;
    xl: number;
    xxl: number;
    xxxl: number;
  };

  // Dimensiones comunes
  dimensions: {
    drawerWidth: number;
    modalWidth: number;
    headerHeight: number;
    buttonHeight: number;
    iconSize: {
      small: number;
      medium: number;
      large: number;
    };
    productImageSize: number;
    cardMinWidth: number;
  };

  // Utilidades
  applyResponsiveStyle: <T>(styles: {
    xs?: T;
    sm?: T;
    md?: T;
    lg?: T;
    xl?: T;
    xxl?: T;
  }) => T | undefined;
  getGridColumns: (
    minItemWidth?: number,
    gap?: number,
    padding?: number,
  ) => number;
  maintainAspectRatio: (
    originalWidth: number,
    originalHeight: number,
    maxWidth: number,
    maxHeight: number,
  ) => { width: number; height: number };
  normalizeDPI: (size: number) => number;

  // Breakpoints
  breakpoints: typeof BREAKPOINTS;

  // Helpers de comparación
  isBreakpoint: {
    xs: boolean;
    sm: boolean;
    md: boolean;
    lg: boolean;
    xl: boolean;
    xxl: boolean;
  };
}

export const useResponsive = (): ResponsiveInfo => {
  // Estado para las dimensiones
  const [dimensions, setDimensions] = useState<ScaledSize>(() =>
    Dimensions.get('window'),
  );

  // Actualizar dimensiones cuando cambian
  useEffect(() => {
    const subscription = Dimensions.addEventListener('change', ({ window }) => {
      setDimensions(window);
    });

    return () => subscription?.remove();
  }, []);

  // Obtener información de píxeles
  const pixelRatio = PixelRatio.get();
  const fontScale = PixelRatio.getFontScale();

  // Calcular valores derivados
  const deviceType = useMemo(
    () => getDeviceType(dimensions.width),
    [dimensions.width],
  );
  const isWeb = Platform.OS === 'web';
  const isDesktop = useMemo(
    () => isWeb && dimensions.width >= BREAKPOINTS.lg,
    [isWeb, dimensions.width],
  );
  const isTablet = useMemo(
    () =>
      checkIsTablet(dimensions.width) ||
      (isWeb &&
        dimensions.width >= BREAKPOINTS.md &&
        dimensions.width < BREAKPOINTS.lg),
    [dimensions.width, isWeb],
  );
  const isMobile = useMemo(
    () => !isTablet && !isDesktop,
    [isTablet, isDesktop],
  );
  const isSmallMobile = useMemo(
    () => deviceType === DEVICE_TYPES.MOBILE_SMALL,
    [deviceType],
  );

  const orientation = useMemo(
    () => getOrientationUtil(dimensions.width, dimensions.height),
    [dimensions.width, dimensions.height],
  );
  const isPortrait = orientation === 'portrait';
  const isLandscape = orientation === 'landscape';

  // Funciones de escalado memoizadas
  const scaleWidthMemo = useCallback(
    (size: number) => scaleWidth(size, dimensions.width),
    [dimensions.width],
  );

  const scaleHeightMemo = useCallback(
    (size: number) => scaleHeight(size, dimensions.height),
    [dimensions.height],
  );

  const scaleWithLimitsMemo = useCallback(
    (size: number, minScale?: number, maxScale?: number) =>
      scaleWithLimits(size, minScale, maxScale, dimensions.width),
    [dimensions.width],
  );

  const getResponsiveDimensionMemo = useCallback(
    (mobile: number, tablet: number) =>
      getResponsiveDimension(mobile, tablet, dimensions.width),
    [dimensions.width],
  );

  // Spacing responsive
  const spacingPreset = useMemo(
    () => ({
      xxxs: RESPONSIVE_SPACING.xxxs(dimensions.width),
      xxs: RESPONSIVE_SPACING.xxs(dimensions.width),
      xs: RESPONSIVE_SPACING.xs(dimensions.width),
      s: RESPONSIVE_SPACING.s(dimensions.width),
      m: RESPONSIVE_SPACING.m(dimensions.width),
      l: RESPONSIVE_SPACING.l(dimensions.width),
      xl: RESPONSIVE_SPACING.xl(dimensions.width),
      xxl: RESPONSIVE_SPACING.xxl(dimensions.width),
    }),
    [dimensions.width],
  );

  // Función de spacing que escala valores arbitrarios
  const spacing = useCallback(
    (value: number) => {
      // Para web desktop, aumentar el spacing
      if (isDesktop) {
        return Math.round(value * 1.3); // 30% más
      }
      // Para tablets, reducir el spacing en un 25-35%
      if (isTablet) {
        return Math.round(value * 0.7); // 30% menos
      }
      return value;
    },
    [isTablet, isDesktop],
  );

  // Tamaños de fuente responsive
  const fontSizePreset = useMemo(
    () => ({
      xs: RESPONSIVE_FONT_SIZES.xs(dimensions.width),
      s: RESPONSIVE_FONT_SIZES.s(dimensions.width),
      m: RESPONSIVE_FONT_SIZES.m(dimensions.width),
      l: RESPONSIVE_FONT_SIZES.l(dimensions.width),
      xl: RESPONSIVE_FONT_SIZES.xl(dimensions.width),
      xxl: RESPONSIVE_FONT_SIZES.xxl(dimensions.width),
      xxxl: RESPONSIVE_FONT_SIZES.xxxl(dimensions.width),
    }),
    [dimensions.width],
  );

  // Función de fontSize que escala valores arbitrarios
  const fontSize = useCallback(
    (value: number) => {
      // Para web desktop, aumentar las fuentes significativamente
      if (isDesktop) {
        return Math.round(value * 1.4); // 40% más grande
      }
      // Para web tablet, aumentar un poco
      if (isWeb && isTablet) {
        return Math.round(value * 1.2); // 20% más grande
      }
      // Para tablets nativos, reducir las fuentes en un 10-15%
      if (isTablet) {
        return Math.round(value * 0.87); // 13% menos
      }
      return value;
    },
    [isTablet, isDesktop, isWeb],
  );

  // Dimensiones comunes
  const commonDimensions = useMemo(
    () => ({
      drawerWidth: RESPONSIVE_DIMENSIONS.drawerWidth(dimensions.width),
      modalWidth: RESPONSIVE_DIMENSIONS.modalWidth(dimensions.width),
      headerHeight: RESPONSIVE_DIMENSIONS.headerHeight(dimensions.width),
      buttonHeight: RESPONSIVE_DIMENSIONS.buttonHeight(dimensions.width),
      iconSize: {
        small: RESPONSIVE_DIMENSIONS.iconSize.small(dimensions.width),
        medium: RESPONSIVE_DIMENSIONS.iconSize.medium(dimensions.width),
        large: RESPONSIVE_DIMENSIONS.iconSize.large(dimensions.width),
      },
      productImageSize: RESPONSIVE_DIMENSIONS.productImageSize(
        dimensions.width,
      ),
      cardMinWidth: RESPONSIVE_DIMENSIONS.cardMinWidth(dimensions.width),
    }),
    [dimensions.width],
  );

  // Aplicar estilos responsive
  const applyResponsiveStyleMemo = useCallback(
    <T>(styles: { xs?: T; sm?: T; md?: T; lg?: T; xl?: T; xxl?: T }) =>
      applyResponsiveStyle(dimensions.width, styles),
    [dimensions.width],
  );

  // Obtener columnas de grid
  const getGridColumnsMemo = useCallback(
    (minItemWidth?: number, gap?: number, padding?: number) =>
      getGridColumns(dimensions.width, minItemWidth, gap, padding),
    [dimensions.width],
  );

  // Helpers de breakpoint
  const isBreakpoint = useMemo(
    () => ({
      xs:
        dimensions.width >= BREAKPOINTS.xs && dimensions.width < BREAKPOINTS.sm,
      sm:
        dimensions.width >= BREAKPOINTS.sm && dimensions.width < BREAKPOINTS.md,
      md:
        dimensions.width >= BREAKPOINTS.md && dimensions.width < BREAKPOINTS.lg,
      lg:
        dimensions.width >= BREAKPOINTS.lg && dimensions.width < BREAKPOINTS.xl,
      xl:
        dimensions.width >= BREAKPOINTS.xl &&
        dimensions.width < BREAKPOINTS.xxl,
      xxl: dimensions.width >= BREAKPOINTS.xxl,
    }),
    [dimensions.width],
  );

  return {
    // Dimensiones
    width: dimensions.width,
    height: dimensions.height,

    // Información del dispositivo
    deviceType,
    isTablet,
    isMobile,
    isSmallMobile,
    isWeb,
    isDesktop,

    // Orientación
    orientation,
    isPortrait,
    isLandscape,

    // Densidad de píxeles
    pixelRatio,
    fontScale,

    // Funciones de escalado
    scaleWidth: scaleWidthMemo,
    scaleHeight: scaleHeightMemo,
    scaleWithLimits: scaleWithLimitsMemo,
    getResponsiveDimension: getResponsiveDimensionMemo,

    // Spacing y dimensiones
    spacing,
    spacingPreset,
    fontSize,
    fontSizePreset,
    dimensions: commonDimensions,

    // Utilidades
    applyResponsiveStyle: applyResponsiveStyleMemo,
    getGridColumns: getGridColumnsMemo,
    maintainAspectRatio,
    normalizeDPI,

    // Breakpoints
    breakpoints: BREAKPOINTS,
    isBreakpoint,
  };
};

// Hook adicional para estilos responsive con el tema
import { useAppTheme } from '@/app/styles/theme';

export const useResponsiveStyles = <T extends Record<string, any>>(
  styleFactory: (theme: any, responsive: ResponsiveInfo) => T,
): T => {
  const theme = useAppTheme();
  const responsive = useResponsive();

  return useMemo(
    () => styleFactory(theme, responsive),
    [theme, responsive, styleFactory],
  );
};

================
File: app/src/app/hooks/useServerConnection.ts
================
import { useState, useEffect, useCallback } from 'react';
import { serverConnectionService } from '@/services/serverConnectionService';


export interface ServerConnectionState {
  isSearching: boolean;
  isConnected: boolean;
  error: string | null;
  serverUrl: string | null;
  hasWifi: boolean;
  isHealthy: boolean;
  retry: () => void;
}

export function useServerConnection(): ServerConnectionState {
  const [state, setState] = useState(() => {
    const serviceState = serverConnectionService.getState();
    return {
      isSearching: serviceState.isSearching,
      isConnected: serviceState.isConnected,
      error: serviceState.error,
      serverUrl: serviceState.currentUrl,
      hasWifi: serviceState.hasWifi,
      isHealthy: serviceState.isHealthy,
      retry: () => {},
    };
  });

  useEffect(() => {
    const serviceState = serverConnectionService.getState();
    setState({
      isSearching: serviceState.isSearching,
      isConnected: serviceState.isConnected,
      error: serviceState.error,
      serverUrl: serviceState.currentUrl,
      hasWifi: serviceState.hasWifi,
      isHealthy: serviceState.isHealthy,
      retry: () => serverConnectionService.retry(),
    });

    const unsubscribe = serverConnectionService.subscribe((newState) => {
      setState({
        isSearching: newState.isSearching,
        isConnected: newState.isConnected,
        error: newState.error,
        serverUrl: newState.currentUrl,
        hasWifi: newState.hasWifi,
        isHealthy: newState.isHealthy,
        retry: () => serverConnectionService.retry(),
      });
    });

    return () => {
      unsubscribe();
    };
  }, []);

  const retry = useCallback(() => {
    serverConnectionService.retry();
  }, []);

  return state;
}

================
File: app/src/app/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps as NavigationDrawerScreenProps } from '@react-navigation/drawer';
import type { NavigatorScreenParams } from '@react-navigation/native';
import type { MenuStackParamList } from '../../modules/menu/navigation/types';
import type { PreparationScreensStackParamList } from '../../modules/preparationScreens/navigation/types';
import type { AreasTablesStackParamList } from '../../modules/areasTables/navigation/types';
import type { PrintersStackParamList } from '../../modules/printers/navigation/types'; // Importar tipos de impresoras
import type { ReceiptsStackParamList } from '../../modules/receipts/navigation/types'; // Importar tipos de recibos
import type { AvailabilityStackParamList } from '../../modules/availability/navigation/types';
import type { OrderFinalizationStackParamList } from '../../modules/orderFinalization/navigation/types';
import type { RestaurantConfigStackParamList } from '../../modules/restaurantConfig/navigation/types';
import type { CustomersStackParamList } from '../../modules/customers/navigation/CustomersStackNavigator';
import type { PizzaCustomizationsStackParamList } from '../../modules/pizzaCustomizations/navigation/types';
import type { SyncStackParamList } from '../../modules/sync/navigation/SyncStackNavigator';
import type { UsersStackParamList } from '../../modules/users/navigation/UsersStackNavigator';
import type { KitchenStackParamList } from '../../modules/kitchen/navigation/KitchenNavigator';
import type { ShiftAuditStackParamList } from '../../modules/shiftAudit/navigation/types';
import type { SettingsStackParamList } from '../../modules/settings/navigation/types';

export type AuthStackParamList = {
  Login: undefined;
};

export type OrdersStackParamList = {
  Orders: undefined; // Pantalla principal del módulo de órdenes
  CreateOrder: undefined; // Pantalla para crear una nueva orden
  OpenOrders: undefined; // Pantalla para ver órdenes abiertas
  AddProductsToOrder: {
    orderId: string; // ID de la orden a la que se están agregando productos
    orderNumber: number; // Número de la orden
    existingOrderItemsCount?: number; // Número de items que ya están en la orden
    existingTempProducts?: import('../../modules/orders/stores/useCartStore').CartItem[]; // Productos temporales existentes
    onProductsAdded?: (
      products: import('../../modules/orders/stores/useCartStore').CartItem[],
    ) => void; // Callback cuando se añaden productos
  }; // Pantalla para añadir productos a una orden existente
};

export type OrdersStackScreenProps<T extends keyof OrdersStackParamList> =
  NativeStackScreenProps<OrdersStackParamList, T>;

export type AuthStackScreenProps<T extends keyof AuthStackParamList> =
  NativeStackScreenProps<AuthStackParamList, T>;

export type ModifiersStackParamList = {
  ModifierGroupsScreen: undefined;
  ModifiersScreen: { groupId: string; groupName: string };
};

export type ModifiersStackScreenProps<T extends keyof ModifiersStackParamList> =
  NativeStackScreenProps<ModifiersStackParamList, T>;

export type AppDrawerParamList = {
  Welcome: undefined; // Mantener si existe una pantalla de bienvenida
  MenuStack: NavigatorScreenParams<MenuStackParamList>; // Renombrado
  ModifiersStack: NavigatorScreenParams<ModifiersStackParamList>; // Renombrado
  PreparationScreensStack: NavigatorScreenParams<PreparationScreensStackParamList>; // Renombrado para consistencia
  AreasTablesStack: NavigatorScreenParams<AreasTablesStackParamList>; // Añadir el nuevo stack al Drawer
  OrdersStack: NavigatorScreenParams<OrdersStackParamList>; // Añadir el stack de órdenes al Drawer
  PrintersStack: NavigatorScreenParams<PrintersStackParamList>; // Añadir el stack de impresoras DENTRO del bloque
  ReceiptsStack: NavigatorScreenParams<ReceiptsStackParamList>; // Añadir el stack de recibos
  AvailabilityStack: NavigatorScreenParams<AvailabilityStackParamList>; // Stack de disponibilidad
  OrderFinalizationStack: NavigatorScreenParams<OrderFinalizationStackParamList>; // Stack de finalización de órdenes
  RestaurantConfigStack: NavigatorScreenParams<RestaurantConfigStackParamList>; // Stack de configuración del restaurante
  PizzaCustomizationsStack: NavigatorScreenParams<PizzaCustomizationsStackParamList>; // Stack de personalización de pizzas
  CustomersStack: NavigatorScreenParams<CustomersStackParamList>; // Stack de clientes
  SyncStack: NavigatorScreenParams<SyncStackParamList>; // Stack de sincronización
  UsersStack: NavigatorScreenParams<UsersStackParamList>; // Stack de usuarios
  KitchenStack: NavigatorScreenParams<KitchenStackParamList>; // Stack de cocina
  ShiftAuditStack: NavigatorScreenParams<ShiftAuditStackParamList>; // Stack de auditoría de turnos
  SettingsStack: NavigatorScreenParams<SettingsStackParamList>; // Stack de configuración
  ServerSettings: undefined; // Pantalla directa de configuración del servidor
};

export type DrawerScreenProps<T extends keyof AppDrawerParamList> =
  NavigationDrawerScreenProps<AppDrawerParamList, T>;

export type DrawerNavigatorParamList = AppDrawerParamList;

declare global {
  namespace ReactNavigation {
    interface RootParamList
      extends AuthStackParamList,
        AppDrawerParamList,
        KitchenStackParamList,
        ModifiersStackParamList,
        PreparationScreensStackParamList,
        AreasTablesStackParamList,
        OrdersStackParamList,
        PrintersStackParamList,
        ReceiptsStackParamList,
        AvailabilityStackParamList,
        OrderFinalizationStackParamList,
        RestaurantConfigStackParamList,
        PizzaCustomizationsStackParamList,
        CustomersStackParamList,
        SyncStackParamList,
        UsersStackParamList,
        ShiftAuditStackParamList,
        SettingsStackParamList {}
  }
}

================
File: app/src/app/services/secureStorageService.ts
================
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

/**
 * Servicio de almacenamiento seguro usando expo-secure-store
 * Reemplaza a react-native-encrypted-storage
 */
class SecureStorageService {
  private isAvailable(): boolean {
    // SecureStore no está disponible en web
    return Platform.OS !== 'web';
  }

  async setItem(key: string, value: string): Promise<void> {
    if (!this.isAvailable()) {
      // Fallback para web: usar localStorage (no seguro)
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.setItem(key, value);
      }
      return;
    }

    try {
      await SecureStore.setItemAsync(key, value);
    } catch (error) {
      console.error('Error storing secure item:', error);
      throw error;
    }
  }

  async getItem(key: string): Promise<string | null> {
    if (!this.isAvailable()) {
      // Fallback para web
      if (typeof window !== 'undefined' && window.localStorage) {
        return window.localStorage.getItem(key);
      }
      return null;
    }

    try {
      return await SecureStore.getItemAsync(key);
    } catch (error) {
      console.error('Error retrieving secure item:', error);
      return null;
    }
  }

  async removeItem(key: string): Promise<void> {
    if (!this.isAvailable()) {
      // Fallback para web
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.removeItem(key);
      }
      return;
    }

    try {
      await SecureStore.deleteItemAsync(key);
    } catch (error) {
      console.error('Error removing secure item:', error);
      throw error;
    }
  }

  async clear(): Promise<void> {
    // expo-secure-store no tiene un método clear()
    // Necesitamos eliminar las claves conocidas manualmente
    const keysToRemove = [
      'auth_token',
      'refresh_token',
      'user_info',
      'last_known_api_url',
      'kitchen_filters_preferences',
      'app_theme_preference',
      'user_credentials',
      'remember_me_preference',
      'connection_mode',
      'manual_server_url',
    ];

    for (const key of keysToRemove) {
      try {
        await this.removeItem(key);
      } catch (error) {
        console.error(`Error removing key ${key}:`, error);
      }
    }
  }
}

// Exportar una instancia única para mantener compatibilidad con EncryptedStorage
const secureStorage = new SecureStorageService();

// Exportar con el mismo nombre que EncryptedStorage para facilitar la migración
export default {
  setItem: (key: string, value: string) => secureStorage.setItem(key, value),
  getItem: (key: string) => secureStorage.getItem(key),
  removeItem: (key: string) => secureStorage.removeItem(key),
  clear: () => secureStorage.clear(),
};

// También exportar la clase por si se necesita
export { SecureStorageService };

================
File: app/src/app/styles/responsive.ts
================
import { Dimensions, PixelRatio } from 'react-native';

// Obtener dimensiones iniciales
const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

// Breakpoints estándar
export const BREAKPOINTS = {
  xs: 0, // Extra pequeño (móviles pequeños)
  sm: 360, // Pequeño (móviles estándar)
  md: 600, // Mediano (móviles grandes y tablets pequeñas)
  lg: 900, // Grande (tablets)
  xl: 1200, // Extra grande (tablets grandes)
  xxl: 1536, // Doble extra grande (tablets pro)
} as const;

// Tipos de dispositivos
export const DEVICE_TYPES = {
  MOBILE_SMALL: 'mobile_small',
  MOBILE: 'mobile',
  TABLET_SMALL: 'tablet_small',
  TABLET: 'tablet',
  TABLET_LARGE: 'tablet_large',
} as const;

// Densidades de píxeles estándar
export const PIXEL_DENSITIES = {
  MDPI: 1, // ~160 DPI
  HDPI: 1.5, // ~240 DPI
  XHDPI: 2, // ~320 DPI
  XXHDPI: 3, // ~480 DPI
  XXXHDPI: 4, // ~640 DPI
} as const;

// Dimensiones de referencia para escalado
export const REFERENCE_DIMENSIONS = {
  width: 360, // Ancho de referencia (móvil estándar)
  height: 640, // Altura de referencia
} as const;

// Función para obtener el tipo de dispositivo
export const getDeviceType = (width: number = screenWidth): string => {
  if (width < BREAKPOINTS.sm) return DEVICE_TYPES.MOBILE_SMALL;
  if (width < BREAKPOINTS.md) return DEVICE_TYPES.MOBILE;
  if (width < BREAKPOINTS.lg) return DEVICE_TYPES.TABLET_SMALL;
  if (width < BREAKPOINTS.xl) return DEVICE_TYPES.TABLET;
  return DEVICE_TYPES.TABLET_LARGE;
};

// Función para verificar si es tablet
export const isTablet = (width: number = screenWidth): boolean => {
  return width >= BREAKPOINTS.md;
};

// Función para obtener el factor de escala basado en el ancho
export const getWidthScale = (width: number = screenWidth): number => {
  return width / REFERENCE_DIMENSIONS.width;
};

// Función para obtener el factor de escala basado en la altura
export const getHeightScale = (height: number = screenHeight): number => {
  return height / REFERENCE_DIMENSIONS.height;
};

// Función para escalar un valor según el ancho de pantalla
export const scaleWidth = (
  size: number,
  width: number = screenWidth,
): number => {
  const scale = getWidthScale(width);
  return Math.round(size * scale);
};

// Función para escalar un valor según la altura de pantalla
export const scaleHeight = (
  size: number,
  height: number = screenHeight,
): number => {
  const scale = getHeightScale(height);
  return Math.round(size * scale);
};

// Función para escalar con límites
export const scaleWithLimits = (
  size: number,
  minScale: number = 0.8,
  maxScale: number = 1.5,
  width: number = screenWidth,
): number => {
  const scale = Math.max(minScale, Math.min(maxScale, getWidthScale(width)));
  return Math.round(size * scale);
};

// Función para obtener dimensiones responsive
export const getResponsiveDimension = (
  mobile: number,
  tablet: number,
  width: number = screenWidth,
): number => {
  return isTablet(width) ? tablet : mobile;
};

// Escalas de spacing responsive (más espacioso en tablets para mejor legibilidad)
export const RESPONSIVE_SPACING = {
  xxxs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(2, width) : scaleWidth(1, width),
  xxs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(4, width) : scaleWidth(2, width),
  xs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(6, width) : scaleWidth(4, width),
  s: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(10, width) : scaleWidth(8, width),
  m: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(16, width) : scaleWidth(16, width),
  l: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(24, width) : scaleWidth(24, width),
  xl: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(32, width) : scaleWidth(32, width),
  xxl: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(40, width) : scaleWidth(40, width),
} as const;

// Tamaños de fuente responsive (optimizadas para tablets)
export const RESPONSIVE_FONT_SIZES = {
  xs: (width: number = screenWidth) =>
    isTablet(width) ? 10 : scaleWithLimits(10, 0.9, 1.1, width),
  s: (width: number = screenWidth) =>
    isTablet(width) ? 12 : scaleWithLimits(12, 0.9, 1.1, width),
  m: (width: number = screenWidth) =>
    isTablet(width) ? 14 : scaleWithLimits(14, 0.9, 1.2, width),
  l: (width: number = screenWidth) =>
    isTablet(width) ? 16 : scaleWithLimits(16, 0.9, 1.2, width),
  xl: (width: number = screenWidth) =>
    isTablet(width) ? 18 : scaleWithLimits(20, 0.9, 1.3, width),
  xxl: (width: number = screenWidth) =>
    isTablet(width) ? 22 : scaleWithLimits(24, 0.9, 1.3, width),
  xxxl: (width: number = screenWidth) =>
    isTablet(width) ? 28 : scaleWithLimits(32, 0.9, 1.4, width),
} as const;

// Dimensiones comunes responsive
export const RESPONSIVE_DIMENSIONS = {
  // Drawer
  drawerWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return 280;
    if (width < BREAKPOINTS.md) return 300;
    if (width < BREAKPOINTS.lg) return 340;
    if (width < BREAKPOINTS.xl) return 360;
    return 380;
  },

  // Modales
  modalWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return width * 0.95;
    if (width < BREAKPOINTS.md) return width * 0.85;
    if (width < BREAKPOINTS.lg) return Math.min(width * 0.6, 500);
    return Math.min(width * 0.45, 550);
  },

  // Headers
  headerHeight: (width: number = screenWidth) => {
    return getResponsiveDimension(56, 64, width);
  },

  // Botones
  buttonHeight: (width: number = screenWidth) => {
    return getResponsiveDimension(48, 44, width);
  },

  // Iconos
  iconSize: {
    small: (width: number = screenWidth) =>
      getResponsiveDimension(16, 16, width),
    medium: (width: number = screenWidth) =>
      getResponsiveDimension(24, 24, width),
    large: (width: number = screenWidth) =>
      getResponsiveDimension(32, 32, width),
  },

  // Imágenes de productos
  productImageSize: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return 80;
    if (width < BREAKPOINTS.md) return 100;
    if (width < BREAKPOINTS.lg) return 90;
    return 100; // Más compacto en tablets
  },

  // Cards
  cardMinWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return width - 32;
    if (width < BREAKPOINTS.md) return 280;
    if (width < BREAKPOINTS.lg) return 320;
    return 360;
  },
} as const;

// Función helper para aplicar estilos condicionales según breakpoint
export const applyResponsiveStyle = <T>(
  width: number,
  styles: {
    xs?: T;
    sm?: T;
    md?: T;
    lg?: T;
    xl?: T;
    xxl?: T;
  },
): T | undefined => {
  const breakpoints = Object.keys(BREAKPOINTS).reverse() as Array<
    keyof typeof BREAKPOINTS
  >;

  for (const breakpoint of breakpoints) {
    if (width >= BREAKPOINTS[breakpoint] && styles[breakpoint]) {
      return styles[breakpoint];
    }
  }

  return undefined;
};

// Utilidad para calcular columnas en grids
export const getGridColumns = (
  width: number = screenWidth,
  minItemWidth: number = 150,
  gap: number = 16,
  padding: number = 16,
): number => {
  const availableWidth = width - padding * 2;
  const columns = Math.floor((availableWidth + gap) / (minItemWidth + gap));
  return Math.max(1, columns);
};

// Utilidad para obtener orientación safe
export const getOrientation = (
  width: number = screenWidth,
  height: number = screenHeight,
) => {
  return width > height ? 'landscape' : 'portrait';
};

// Utilidad para calcular aspect ratio
export const maintainAspectRatio = (
  originalWidth: number,
  originalHeight: number,
  maxWidth: number,
  maxHeight: number,
) => {
  const aspectRatio = originalWidth / originalHeight;

  let width = maxWidth;
  let height = maxWidth / aspectRatio;

  if (height > maxHeight) {
    height = maxHeight;
    width = maxHeight * aspectRatio;
  }

  return { width: Math.round(width), height: Math.round(height) };
};

// Exportar utilidad para normalizar según DPI
export const normalizeDPI = (size: number): number => {
  const pixelRatio = PixelRatio.get();
  return Math.round(size * pixelRatio) / pixelRatio;
};

// Utilidad para obtener dimensiones de pantalla actualizadas
export const getScreenDimensions = () => {
  return Dimensions.get('window');
};

// Multiplicador de densidad para tablets (más compacto)
export const TABLET_DENSITY_MULTIPLIER = 0.75;

// Helper para obtener tamaño compacto en tablets
export const getCompactSize = (
  mobileSize: number,
  width: number = screenWidth,
  compactRatio: number = TABLET_DENSITY_MULTIPLIER,
): number => {
  return isTablet(width) ? Math.round(mobileSize * compactRatio) : mobileSize;
};

// Helper para obtener tamaño de fuente compacto
export const getCompactFontSize = (
  mobileSize: number,
  width: number = screenWidth,
  compactRatio: number = 0.85,
): number => {
  return isTablet(width) ? Math.round(mobileSize * compactRatio) : mobileSize;
};

// Helper para obtener spacing compacto
export const getCompactSpacing = (
  mobileSpacing: number,
  width: number = screenWidth,
  compactRatio: number = 0.65,
): number => {
  return isTablet(width)
    ? Math.round(mobileSpacing * compactRatio)
    : mobileSpacing;
};

================
File: app/src/modules/areasTables/services/areaService.ts
================
import { useQuery } from '@tanstack/react-query';
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { BackendErrorResponse } from '../../../app/types/api.types';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  FindAllAreasDto,
} from '../schema/area.schema';

export const getAreas = async (
  filterOptions: FindAllAreasDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 10 },
): Promise<Area[]> => {
  const response = await ApiClientWrapper.get<{
    items: Area[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.AREAS, {
    ...filterOptions,
    page: paginationOptions.page,
    limit: paginationOptions.limit,
  });

  if (!response.ok || !response.data) {
    // Error al obtener áreas
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data.items;
};

export const getAreaById = async (id: string): Promise<Area> => {
  const response = await ApiClientWrapper.get<Area>(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    // Error al obtener área por ID
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const createArea = async (data: CreateAreaDto): Promise<Area> => {
  const response = await ApiClientWrapper.post<Area>(API_PATHS.AREAS, data);

  if (!response.ok || !response.data) {
    // Error al crear área
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const updateArea = async (
  id: string,
  data: UpdateAreaDto,
): Promise<Area> => {
  const response = await ApiClientWrapper.patch<Area>(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    // Error al actualizar área
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const deleteArea = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    // Error al eliminar área
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
};

// Claves de Query para áreas
const areaQueryKeys = {
  all: ['areas'] as const,
};

/**
 * Hook para obtener la lista de todas las áreas activas usando React Query.
 */
export function useGetAreas() {
  return useQuery<Area[], ApiError>({
    queryKey: areaQueryKeys.all,
    queryFn: () => getAreas(), // Llama a getAreas sin argumentos para obtener todos por defecto
    // Sin staleTime, se usará la configuración global (0)
  });
}

================
File: app/src/modules/auth/components/RegisterForm.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useMutation } from '@tanstack/react-query';
import { authService } from '../services/authService';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const registerFormSchema = z.object({
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .max(20, 'El nombre de usuario no puede exceder 20 caracteres')
    .regex(/^[a-zA-Z0-9_]+$/, 'Solo se permiten letras, números y guión bajo'),
  email: z.string().email('Email inválido'),
  password: z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
  firstName: z
    .string()
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres'),
  lastName: z
    .string()
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(50, 'El apellido no puede exceder 50 caracteres'),
  phoneNumber: z
    .union([
      z.string().regex(/^\+?[0-9\s-]+$/, 'Número de teléfono inválido'),
      z.literal(''),
    ])
    .optional(),
  role: z.number(),
});

type RegisterFormInputs = z.infer<typeof registerFormSchema>;

interface RegisterModalProps {
  visible: boolean;
  onDismiss: () => void;
  onRegisterSuccess?: (username: string, password: string) => void;
}

export function RegisterModal({
  visible,
  onDismiss,
  onRegisterSuccess,
}: RegisterModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showPassword, setShowPassword] = useState(false);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<RegisterFormInputs>({
    resolver: zodResolver(registerFormSchema),
    defaultValues: {
      username: '',
      email: '',
      password: '',
      firstName: '',
      lastName: '',
      phoneNumber: '',
      role: 4, // Default a Mesero
    },
  });

  const { mutate: register, isPending } = useMutation({
    mutationFn: (data: RegisterFormInputs) => {
      const registerData = {
        username: data.username,
        email: data.email,
        password: data.password,
        firstName: data.firstName,
        lastName: data.lastName,
        phoneNumber: data.phoneNumber || undefined,
        role: { id: data.role },
        isActive: true,
      };
      return authService.register(registerData as any);
    },
    onSuccess: (_, variables) => {
      showSnackbar({
        message: 'Registro exitoso. Ya puedes iniciar sesión.',
        type: 'success',
      });

      // Pasar los datos al formulario de login
      if (onRegisterSuccess) {
        onRegisterSuccess(variables.username, variables.password);
      }

      reset();
      onDismiss();
    },
    onError: (error: unknown) => {
      const userMessage = getApiErrorMessage(error);
      showSnackbar({
        message: userMessage,
        type: 'error',
        duration: 5000,
      });
    },
  });

  const onSubmit = (data: RegisterFormInputs) => {
    register(data);
  };

  const handleDismiss = () => {
    reset();
    setShowPassword(false);
    onDismiss();
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.modalContent} elevation={5}>
          <View
            style={[
              styles.headerContainer,
              { backgroundColor: theme.colors.primary },
            ]}
          >
            <View style={styles.headerLeft}>
              <Avatar.Icon
                size={32}
                icon="account-plus"
                style={[
                  styles.headerIcon,
                  { backgroundColor: theme.colors.onPrimary + '20' },
                ]}
                color={theme.colors.onPrimary}
              />
              <View style={styles.headerTextContainer}>
                <Text
                  style={[styles.modalTitle, { color: theme.colors.onPrimary }]}
                  variant="titleMedium"
                >
                  Crear cuenta
                </Text>
              </View>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={handleDismiss}
              disabled={isPending}
              iconColor={theme.colors.onPrimary}
            />
          </View>

          <ScrollView
            style={styles.formContainer}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-key"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información de Cuenta
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="username"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre de usuario"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.username}
                      mode="outlined"
                      placeholder="usuario123"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.username && (
                      <HelperText type="error" visible={!!errors.username}>
                        {errors.username.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="email"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Email"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.email}
                      mode="outlined"
                      placeholder="usuario@ejemplo.com"
                      keyboardType="email-address"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="email" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.email && (
                      <HelperText type="error" visible={!!errors.email}>
                        {errors.email.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="password"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Contraseña"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.password}
                      mode="outlined"
                      placeholder="••••••"
                      secureTextEntry={!showPassword}
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="lock" />}
                      right={
                        <TextInput.Icon
                          icon={showPassword ? 'eye-off' : 'eye'}
                          onPress={() => setShowPassword(!showPassword)}
                        />
                      }
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.password && (
                      <HelperText type="error" visible={!!errors.password}>
                        {errors.password.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="role"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="badge-account"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Tipo de cuenta
                      </Text>
                    </View>
                    <View style={styles.rolesContainer}>
                      {[
                        {
                          value: 4,
                          label: 'Mesero',
                          icon: 'room-service',
                          description: 'Tomar y gestionar órdenes',
                        },
                        {
                          value: 6,
                          label: 'Repartidor',
                          icon: 'moped',
                          description: 'Entregar pedidos',
                        },
                      ].map((role) => (
                        <Surface
                          key={role.value}
                          style={[
                            styles.roleCard,
                            value === role.value && styles.roleCardActive,
                          ]}
                          elevation={value === role.value ? 2 : 0}
                        >
                          <TouchableOpacity
                            onPress={() => onChange(role.value)}
                            style={styles.roleCardContent}
                          >
                            <Icon
                              source={role.icon}
                              size={24}
                              color={
                                value === role.value
                                  ? theme.colors.primary
                                  : theme.colors.onSurfaceVariant
                              }
                            />
                            <Text
                              style={[
                                styles.roleLabel,
                                value === role.value && styles.roleLabelActive,
                              ]}
                              variant="labelMedium"
                            >
                              {role.label}
                            </Text>
                            <Text
                              style={styles.roleDescription}
                              variant="bodySmall"
                              numberOfLines={2}
                            >
                              {role.description}
                            </Text>
                          </TouchableOpacity>
                        </Surface>
                      ))}
                    </View>
                  </View>
                )}
              />
            </View>

            <Divider style={styles.divider} />

            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-circle"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información Personal
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="firstName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.firstName}
                      mode="outlined"
                      placeholder="Juan"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.firstName && (
                      <HelperText type="error" visible={!!errors.firstName}>
                        {errors.firstName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="lastName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Apellido"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.lastName}
                      mode="outlined"
                      placeholder="Pérez"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.lastName && (
                      <HelperText type="error" visible={!!errors.lastName}>
                        {errors.lastName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="phoneNumber"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Teléfono (opcional)"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.phoneNumber}
                      mode="outlined"
                      placeholder="+52 55 1234 5678"
                      keyboardType="phone-pad"
                      left={<TextInput.Icon icon="phone" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.phoneNumber && (
                      <HelperText type="error" visible={!!errors.phoneNumber}>
                        {errors.phoneNumber.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
            </View>
          </ScrollView>

          <Surface style={styles.buttonContainer} elevation={2}>
            <Button
              onPress={handleDismiss}
              disabled={isPending}
              style={[styles.button, styles.cancelButton]}
              textColor={theme.colors.onSecondaryContainer}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              disabled={isPending}
              loading={isPending}
              style={[styles.button, styles.confirmButton]}
              buttonColor={theme.colors.primary}
            >
              Registrarse
            </Button>
          </Surface>
        </Surface>
      </Modal>
    </Portal>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? 20 : 12,
      maxWidth: responsive.isTablet ? 600 : '100%',
      alignSelf: 'center',
      width: responsive.isTablet ? '80%' : '94%',
    },
    modalContent: {
      borderRadius: responsive.isTablet
        ? theme.roundness * 3
        : theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      maxHeight: responsive.isTablet ? '90%' : '92%',
      minHeight: responsive.isTablet ? 600 : 550,
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing.m
        : responsive.spacing.s,
      paddingTop: responsive.isTablet
        ? responsive.spacing.s
        : responsive.spacing.xs,
      paddingBottom: responsive.spacing.xs,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.s
        : responsive.spacing.xs,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.isTablet ? theme.spacing.xs : 6,
      gap: responsive.isTablet ? theme.spacing.xs : 6,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 13,
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.primary + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '40',
    },
    requiredChipText: {
      color: theme.colors.primary,
      fontSize: responsive.isTablet ? 11 : 10,
      fontWeight: '600',
    },
    inputContainer: {
      marginBottom: responsive.isTablet ? theme.spacing.xs : 6,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
    },
    input: {
      fontSize: responsive.isTablet ? 14 : 13,
      backgroundColor: theme.colors.surface,
      height: responsive.isTablet ? 48 : 44,
    },
    inputContent: {
      paddingVertical: responsive.isTablet ? 4 : 2,
      fontSize: responsive.isTablet ? 14 : 13,
      fontFamily: 'System',
    },
    fieldLabelContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : 6,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    rolesContainer: {
      flexDirection: 'row',
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      justifyContent: 'center',
    },
    roleCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      backgroundColor: theme.colors.surface,
      minWidth: responsive.isTablet ? 140 : 125,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
      elevation: 1,
    },
    roleCardActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
      elevation: 3,
    },
    roleCardContent: {
      alignItems: 'center',
    },
    roleLabel: {
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.isTablet ? theme.spacing.xs : 4,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 14 : 13,
    },
    roleLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '700',
    },
    roleDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: responsive.isTablet ? 11 : 10,
      textAlign: 'center',
    },
    divider: {
      marginVertical: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      marginHorizontal: responsive.isTablet
        ? -theme.spacing.m
        : -theme.spacing.s,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    button: {
      flex: 1,
      maxWidth: responsive.isTablet ? 150 : 140,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
  });

================
File: app/src/modules/kitchen/components/OrderItemRow.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity, Platform } from 'react-native';
import { Text, useTheme, Chip } from 'react-native-paper';
import { KitchenOrderItem, PreparationStatus } from '../types/kitchen.types';
import { useResponsive } from '@/app/hooks/useResponsive';

interface OrderItemRowProps {
  item: KitchenOrderItem;
  onPress?: () => void;
  onTogglePrepared?: (itemId: string, currentStatus: boolean) => void;
  isOrderInPreparation?: boolean;
}

export const OrderItemRow = React.memo<OrderItemRowProps>(
  ({ item, onTogglePrepared, isOrderInPreparation }) => {
    const theme = useTheme();
    const responsive = useResponsive();

    const isPrepared = item.preparationStatus === PreparationStatus.READY;
    const isInProgress =
      item.preparationStatus === PreparationStatus.IN_PROGRESS;
    const isDisabled = !item.belongsToMyScreen;
    // Permitir toggle si la orden está en preparación, el item pertenece a esta pantalla y está IN_PROGRESS o READY
    const canToggle =
      isOrderInPreparation &&
      (isInProgress || isPrepared) &&
      item.belongsToMyScreen &&
      onTogglePrepared;

    const buildItemName = () => {
      // Si tiene variante, solo mostrar la variante
      // Si no tiene variante, mostrar el nombre del producto
      const displayName = item.variantName || item.productName;
      return `${item.quantity}x ${displayName}`;
    };

    const buildItemDetails = () => {
      const details: string[] = [];

      // Combinar mods y customizations en una línea si es posible
      const allCustoms: string[] = [];

      if (item.modifiers.length > 0) {
        allCustoms.push(...item.modifiers);
      }

      if (item.pizzaCustomizations && item.pizzaCustomizations.length > 0) {
        const customizations = item.pizzaCustomizations.map((pc) => {
          let text = pc.customizationName;
          if (pc.action) text += ` (${pc.action})`;
          if (pc.half) text += ` - ${pc.half}`;
          return text;
        });
        allCustoms.push(...customizations);
      }

      if (allCustoms.length > 0) {
        details.push(allCustoms.join(', '));
      }

      if (item.preparationNotes) {
        details.push(`📝 ${item.preparationNotes}`);
      }

      return details;
    };

    const styles = StyleSheet.create({
      container: {
        paddingHorizontal: responsive.isWeb
          ? responsive.spacing.m
          : responsive.spacing.s,
        paddingVertical: responsive.isWeb
          ? responsive.spacing.s
          : responsive.spacing.xs,
        minHeight: responsive.isWeb ? 52 : responsive.isTablet ? 40 : 36,
        display: 'flex',
        justifyContent: 'center',
      },
      disabled: {
        opacity: 0.5,
      },
      row: {
        flexDirection: 'row',
        alignItems: 'center',
        flex: 1,
      },
      content: {
        flex: 1,
      },
      withBorder: {
        borderRadius: theme.roundness / 2,
        borderWidth: 1,
        borderColor: theme.colors.outline,
        borderStyle: 'dashed',
      },
      clickable: {
        backgroundColor: 'rgba(0, 0, 0, 0.02)',
      },
      itemName: {
        fontWeight: '500',
        fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 13 : 14,
        lineHeight: responsive.isWeb ? 24 : responsive.isTablet ? 18 : 20,
      },
      detail: {
        color: theme.colors.onSurfaceVariant,
        marginTop: responsive.isWeb ? 2 : -1,
        fontSize: responsive.isWeb ? 14 : responsive.isTablet ? 11 : 12,
        lineHeight: responsive.isWeb ? 20 : responsive.isTablet ? 14 : 16,
      },
      strikethrough: {
        textDecorationLine: 'line-through',
        textDecorationStyle: 'solid',
        textDecorationColor: theme.colors.error,
        opacity: 0.7,
      },
      disabledText: {
        color: theme.colors.onSurfaceDisabled || '#999',
      },
    });

    const handlePress = () => {
      if (canToggle) {
        onTogglePrepared(item.id, isPrepared);
      }
    };

    const Container = canToggle ? TouchableOpacity : View;

    return (
      <Container
        onPress={canToggle ? handlePress : undefined}
        activeOpacity={0.7}
        style={[
          styles.container,
          styles.withBorder,
          isDisabled && styles.disabled,
          canToggle && styles.clickable,
        ]}
      >
        <View style={styles.row}>
          <View style={styles.content}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                gap: responsive.spacing.xs,
              }}
            >
              <Text
                variant="bodyMedium"
                style={[
                  styles.itemName,
                  isPrepared && styles.strikethrough,
                  isDisabled && styles.disabledText,
                ]}
              >
                {buildItemName()}
              </Text>
            </View>
            {buildItemDetails().map((detail, index) => (
              <Text
                key={index}
                variant="labelSmall"
                style={[
                  styles.detail,
                  isPrepared && styles.strikethrough,
                  isDisabled && styles.disabledText,
                ]}
              >
                {detail}
              </Text>
            ))}
          </View>
        </View>
      </Container>
    );
  },
);

OrderItemRow.displayName = 'OrderItemRow';

================
File: app/src/modules/kitchen/services/kitchenService.ts
================
import ApiClientWrapper from '@/app/services/apiClientWrapper';
import { KitchenOrder, KitchenFilters } from '../types/kitchen.types';
import { API_PATHS } from '@/app/constants/apiPaths';

interface _PaginationResponse<T> {
  data: T[];
  hasNextPage: boolean;
}

class KitchenService {
  async getKitchenOrders(
    filters: Partial<KitchenFilters> = {},
  ): Promise<KitchenOrder[]> {
    // Construir query string manualmente para evitar problemas de serialización
    const queryParams = new URLSearchParams();

    // Solo enviar orderType si tiene un valor (no es undefined)
    if (filters.orderType) {
      queryParams.append('orderType', filters.orderType);
    }
    if (filters.showPrepared !== undefined) {
      queryParams.append('showPrepared', String(filters.showPrepared));
    }
    if (filters.showAllProducts !== undefined) {
      queryParams.append('showAllProducts', String(filters.showAllProducts));
    }
    if (filters.ungroupProducts !== undefined) {
      queryParams.append('ungroupProducts', String(filters.ungroupProducts));
    }
    if (filters.screenId !== undefined) {
      queryParams.append('screenId', filters.screenId);
    }

    const queryString = queryParams.toString();
    const url = queryString
      ? `${API_PATHS.KITCHEN_ORDERS}?${queryString}`
      : API_PATHS.KITCHEN_ORDERS;

    const response = await ApiClientWrapper.get<KitchenOrder[]>(url);
    return response.data || [];
  }

  async markItemPrepared(
    itemId: string,
    isPrepared: boolean = true,
  ): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_MARK_PREPARED.replace(':itemId', itemId),
      {
        isPrepared,
      },
    );
  }

  async unmarkItemPrepared(itemId: string): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_MARK_UNPREPARED.replace(':itemId', itemId),
    );
  }

  async startOrderPreparation(orderId: string): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_ORDERS_START_PREPARATION.replace(':orderId', orderId),
    );
  }

  async cancelOrderPreparation(orderId: string): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_ORDERS_CANCEL_PREPARATION.replace(':orderId', orderId),
    );
  }

  async completeOrderPreparation(orderId: string): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_ORDERS_COMPLETE_PREPARATION.replace(
        ':orderId',
        orderId,
      ),
    );
  }
}

export const kitchenService = new KitchenService();

================
File: app/src/modules/kitchen/types/kitchen.types.ts
================
export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKE_AWAY = 'TAKE_AWAY',
  DELIVERY = 'DELIVERY',
}

export enum PreparationStatus {
  PENDING = 'PENDING',
  IN_PROGRESS = 'IN_PROGRESS',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  CANCELLED = 'CANCELLED',
}

export enum PreparationScreenStatus {
  PENDING = 'PENDING',
  IN_PREPARATION = 'IN_PREPARATION',
  READY = 'READY',
}

export interface KitchenOrderItem {
  id: string;
  productName: string;
  variantName?: string;
  modifiers: string[];
  pizzaCustomizations?: Array<{
    customizationName: string;
    action: string;
    half?: string;
  }>;
  preparationNotes?: string;
  preparationStatus: PreparationStatus;
  preparedAt?: string;
  preparedByUser?: {
    firstName: string;
    lastName: string;
  };
  quantity: number;
  belongsToMyScreen: boolean;
}

export interface PreparationScreenStatusInfo {
  screenId: string;
  screenName: string;
  status: PreparationScreenStatus;
}

export interface KitchenOrder {
  id: string;
  shiftOrderNumber: number;
  orderType: OrderType;
  orderStatus: string; // Estado real de la orden
  createdAt: string;
  orderNotes?: string;
  // Campos específicos según tipo
  deliveryAddress?: string;
  deliveryPhone?: string;
  receiptName?: string;
  customerPhone?: string;
  areaName?: string;
  tableName?: string;
  items: KitchenOrderItem[];
  hasPendingItems: boolean;
  screenStatuses: PreparationScreenStatusInfo[];
  myScreenStatus?: PreparationScreenStatus;
  isFromWhatsApp?: boolean;
}

export interface KitchenFilters {
  orderType?: OrderType;
  showPrepared: boolean;
  showAllProducts: boolean;
  ungroupProducts: boolean;
  screenId?: string;
}

export interface PreparationScreen {
  id: string;
  name: string;
  description?: string;
  isActive: boolean;
}

================
File: app/src/modules/menu/services/fileService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { Platform } from 'react-native';
import { API_PATHS } from '../../../app/constants/apiPaths';
import NetInfo from '@react-native-community/netinfo';

export interface FileUploadResponse {
  file: {
    id: string;
    path: string;
  };
  presignedUrl?: string;
}

export interface FileObject {
  uri: string;
  name: string;
  type: string;
}

// Verificar conectividad antes de intentar subir
const checkNetworkConnection = async (): Promise<boolean> => {
  const state = await NetInfo.fetch();
  return state.isConnected === true && state.isInternetReachable !== false;
};

export const uploadFile = async (
  fileToUpload: FileObject,
  maxRetries: number = 3,
): Promise<FileUploadResponse> => {
  // Verificar conexión antes de intentar
  const isConnected = await checkNetworkConnection();
  if (!isConnected) {
    throw new ApiError(
      'NETWORK_ERROR',
      'Sin conexión a internet. Verifica tu conexión e intenta nuevamente.',
      0,
    );
  }

  const formData = new FormData();
  formData.append('file', {
    uri:
      Platform.OS === 'android'
        ? fileToUpload.uri
        : fileToUpload.uri.replace('file://', ''),
    name: fileToUpload.name,
    type: fileToUpload.type,
  } as any);

  let lastError: any;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await ApiClientWrapper.post<FileUploadResponse>(
        API_PATHS.FILES_UPLOAD,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
            // Agregar header para evitar problemas de caché
            'Cache-Control': 'no-cache',
          },
          timeout: 120000, // Aumentar timeout a 2 minutos para uploads
          // Configuración adicional para mejorar la estabilidad
          maxContentLength: Infinity,
          maxBodyLength: Infinity,
        },
      );

      if (!response.ok || !response.data || !response.data.file) {
        lastError = ApiError.fromApiResponse(response.data, response.status);

        // Si no es un error de red, no reintentar
        if (response.status && response.status < 500) {
          throw lastError;
        }

        // Esperar antes de reintentar (backoff exponencial)
        if (attempt < maxRetries) {
          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
          await new Promise((resolve) => setTimeout(resolve, delay));
          continue;
        }
      }

      return response.data!;
    } catch (error) {
      lastError = error;

      // Si es un error de cliente (4xx), no reintentar
      if (
        error instanceof ApiError &&
        error.status >= 400 &&
        error.status < 500
      ) {
        throw error;
      }

      // Si es el último intento, lanzar el error
      if (attempt === maxRetries) {
        if (error instanceof ApiError) throw error;
        throw new ApiError(
          'UPLOAD_FAILED',
          `Error al subir archivo después de ${maxRetries} intentos: ${error instanceof Error ? error.message : 'Error desconocido'}`,
          500,
        );
      }

      // Esperar antes de reintentar (backoff exponencial)
      const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  // Por si acaso llegamos aquí
  throw (
    lastError ||
    new ApiError('UPLOAD_FAILED', 'Error desconocido al subir archivo', 500)
  );
};

const fileService = {
  uploadFile,
  uploadImage: uploadFile,
};

export default fileService;

================
File: app/src/modules/modifiers/services/modifierGroupService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  ModifierGroup,
  CreateModifierGroupInput,
  UpdateModifierGroupInput,
  modifierGroupApiSchema,
} from '../schema/modifierGroup.schema';
import { z } from 'zod';
import { PaginatedResponse } from '@/app/types/api.types';

const _modifierGroupsListSchema = z.array(modifierGroupApiSchema);

// Schema para respuesta paginada
const paginatedModifierGroupsSchema = z.object({
  items: z.array(modifierGroupApiSchema),
  total: z.number(),
  page: z.number(),
  limit: z.number(),
  hasNextPage: z.boolean(),
  hasPrevPage: z.boolean(),
});

interface FindAllParams {
  page?: number;
  limit?: number;
  isActive?: boolean;
  search?: string;
}

export const modifierGroupService = {
  /**
   * Obtiene todos los grupos de modificadores con paginación.
   */
  async findAll(
    params: FindAllParams = {},
  ): Promise<PaginatedResponse<ModifierGroup>> {
    const queryParams = {
      page: params.page ?? 1,
      limit: params.limit ?? 10,
      ...(params.isActive !== undefined && { isActive: params.isActive }),
      ...(params.search && { search: params.search }),
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIER_GROUPS,
      queryParams,
    );

    if (!response.ok || !response.data) {
      // Error al obtener grupos de modificadores
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    // Parsear como respuesta paginada
    const paginatedResult = paginatedModifierGroupsSchema.safeParse(
      response.data,
    );
    if (paginatedResult.success) {
      // Transformar la respuesta del backend a PaginatedResponse
      return {
        data: paginatedResult.data.items,
        total: paginatedResult.data.total,
        page: paginatedResult.data.page,
        limit: paginatedResult.data.limit,
        totalPages: Math.ceil(
          paginatedResult.data.total / paginatedResult.data.limit,
        ),
      };
    }

    // Datos inválidos recibidos para grupos de modificadores
    throw new Error('Received invalid data format for modifier groups.');
  },

  /**
   * Obtiene un grupo de modificadores por su ID.
   */
  async findOne(id: string): Promise<ModifierGroup> {
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
    );

    if (!response.ok || !response.data) {
      // Error al obtener grupo de modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inválidos recibidos para grupo de modificador
      throw new Error(`Received invalid data format for modifier group ${id}.`);
    }
    return validationResult.data;
  },

  /**
   * Crea un nuevo grupo de modificadores.
   */
  async create(data: CreateModifierGroupInput): Promise<ModifierGroup> {
    const response = await apiClient.post<unknown>(
      API_PATHS.MODIFIER_GROUPS,
      data,
    );

    if (!response.ok || !response.data) {
      // Error al crear grupo de modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inválidos recibidos después de crear grupo de modificador
      throw new Error(
        'Received invalid data format after creating modifier group.',
      );
    }
    return validationResult.data;
  },

  /**
   * Actualiza un grupo de modificadores existente.
   */
  async update(
    id: string,
    data: UpdateModifierGroupInput,
  ): Promise<ModifierGroup> {
    const response = await apiClient.patch<unknown>(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
      data,
    );

    if (!response.ok || !response.data) {
      // Error al actualizar grupo de modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inválidos recibidos después de actualizar grupo de modificador
      throw new Error(
        `Received invalid data format after updating modifier group ${id}.`,
      );
    }
    return validationResult.data;
  },

  /**
   * Elimina un grupo de modificadores.
   */
  async remove(id: string): Promise<void> {
    const response = await apiClient.delete(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
    );

    if (!response.ok) {
      // Error al eliminar grupo de modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
  },
};

================
File: app/src/modules/modifiers/services/modifierService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Modifier,
  CreateModifierInput,
  UpdateModifierInput,
  modifierApiSchema,
} from '../schema/modifier.schema';
import { z } from 'zod';
import { PaginatedResponse } from '@/app/types/api.types';

const modifiersListSchema = z.array(modifierApiSchema);

// Schema para respuesta paginada
const paginatedModifiersSchema = z.object({
  items: z.array(modifierApiSchema),
  total: z.number(),
  page: z.number(),
  limit: z.number(),
  hasNextPage: z.boolean(),
  hasPrevPage: z.boolean(),
});

interface FindAllModifiersParams {
  page?: number;
  limit?: number;
  groupId?: string;
}

export const modifierService = {
  /**
   * Obtiene todos los modificadores con paginación.
   */
  async findAll(
    params?: FindAllModifiersParams,
  ): Promise<PaginatedResponse<Modifier>> {
    const queryParams = {
      page: params?.page ?? 1,
      limit: params?.limit ?? 10,
      ...params,
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS,
      queryParams,
    );

    if (!response.ok || !response.data) {
      // Error al obtener modificadores
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    // Parsear como respuesta paginada
    const paginatedResult = paginatedModifiersSchema.safeParse(response.data);
    if (paginatedResult.success) {
      // Transformar la respuesta del backend a PaginatedResponse
      return {
        data: paginatedResult.data.items,
        total: paginatedResult.data.total,
        page: paginatedResult.data.page,
        limit: paginatedResult.data.limit,
        totalPages: Math.ceil(
          paginatedResult.data.total / paginatedResult.data.limit,
        ),
      };
    }

    // Datos inválidos recibidos para modificadores
    throw new Error('Received invalid data format for modifiers.');
  },

  /**
   * Obtiene un modificador por su ID.
   */
  async findOne(id: string): Promise<Modifier> {
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
    );

    if (!response.ok || !response.data) {
      // Error al obtener modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inválidos recibidos para modificador
      throw new Error(`Received invalid data format for modifier ${id}.`);
    }
    return validationResult.data;
  },

  /**
   * Obtiene todos los modificadores asociados a un grupo específico, con filtros opcionales.
   */
  async findByGroupId(
    modifierGroupId: string,
    params: { isActive?: boolean; search?: string } = {},
  ): Promise<Modifier[]> {
    const queryParams = {
      ...(params.isActive !== undefined && { isActive: params.isActive }),
      ...(params.search && { search: params.search }),
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS_BY_GROUP.replace(':modifierGroupId', modifierGroupId),
      queryParams,
    );

    if (!response.ok || !response.data) {
      // Error al obtener modificadores del grupo
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifiersListSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inválidos recibidos para modificadores del grupo
      throw new Error(
        `Received invalid data format for modifiers of group ${modifierGroupId}.`,
      );
    }
    return validationResult.data;
  },

  /**
   * Crea un nuevo modificador.
   */
  async create(data: CreateModifierInput): Promise<Modifier> {
    const response = await apiClient.post<unknown>(API_PATHS.MODIFIERS, data);

    if (!response.ok || !response.data) {
      // Error al crear modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inválidos recibidos después de crear modificador
      throw new Error('Received invalid data format after creating modifier.');
    }
    return validationResult.data;
  },

  /**
   * Actualiza un modificador existente.
   */
  async update(id: string, data: UpdateModifierInput): Promise<Modifier> {
    const response = await apiClient.patch<unknown>(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
      data,
    );

    if (!response.ok || !response.data) {
      // Error al actualizar modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inválidos recibidos después de actualizar modificador
      throw new Error(
        `Received invalid data format after updating modifier ${id}.`,
      );
    }
    return validationResult.data;
  },

  /**
   * Elimina un modificador.
   */
  async remove(id: string): Promise<void> {
    const response = await apiClient.delete(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
    );

    if (!response.ok) {
      // Error al eliminar modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
  },
};

================
File: app/src/modules/orderFinalization/hooks/useOrderFinalizationQueries.ts
================
import { useQuery } from '@tanstack/react-query';
import { orderFinalizationService } from '../services/orderFinalizationService';

export const useOrdersForFinalizationList = () => {
  return useQuery({
    queryKey: ['orders', 'for-finalization-list'],
    queryFn: orderFinalizationService.getOrdersForFinalizationList,
    refetchInterval: 10000,
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000,
    keepPreviousData: true,
    notifyOnChangeProps: ['data', 'error'],
  });
};

export const useOrderForFinalizationDetail = (orderId: string | null) => {
  return useQuery({
    queryKey: ['orders', 'for-finalization-detail', orderId],
    queryFn: () =>
      orderId
        ? orderFinalizationService.getOrderForFinalizationDetail(orderId)
        : null,
    enabled: !!orderId,
    staleTime: 30000,
  });
};

================
File: app/src/modules/orders/components/ChangeCalculatorModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Button, TextInput } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';

interface ChangeCalculatorModalProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: () => void;
  amountToPay: number;
}

export const ChangeCalculatorModal: React.FC<ChangeCalculatorModalProps> = ({
  visible,
  onDismiss,
  onConfirm,
  amountToPay,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  const [receivedAmount, setReceivedAmount] = useState('');

  // Calcular cambio
  const changeAmount = useMemo(() => {
    const received = parseFloat(receivedAmount);
    if (isNaN(received)) return 0;
    return Math.max(0, received - amountToPay);
  }, [receivedAmount, amountToPay]);

  // Determinar qué botones de billetes mostrar
  const availableBills = useMemo(() => {
    const bills = [50, 100, 200, 500, 1000];
    // Filtrar billetes que sean mayores o iguales al monto a pagar
    const validBills = bills.filter((bill) => bill >= amountToPay);
    // Tomar máximo 4 opciones para que quepan en una línea
    return validBills.slice(0, 4);
  }, [amountToPay]);

  // Resetear cuando se abre
  useEffect(() => {
    if (visible) {
      setReceivedAmount(amountToPay.toFixed(2));
    }
  }, [visible, amountToPay]);

  const handleConfirm = () => {
    const received = parseFloat(receivedAmount);
    if (!isNaN(received) && received >= amountToPay) {
      onConfirm();
    }
  };

  const footerActions = (
    <View style={styles.footer}>
      <Button
        mode="outlined"
        onPress={onDismiss}
        style={styles.cancelButton}
        labelStyle={styles.cancelButtonLabel}
        contentStyle={styles.footerButtonContent}
      >
        Cancelar
      </Button>
      <Button
        mode="contained"
        onPress={handleConfirm}
        disabled={
          !receivedAmount ||
          isNaN(parseFloat(receivedAmount)) ||
          parseFloat(receivedAmount) < amountToPay
        }
        style={styles.confirmButton}
        contentStyle={styles.footerButtonContent}
        labelStyle={styles.confirmButtonLabel}
      >
        Confirmar Pago
      </Button>
    </View>
  );

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title="Calcular Cambio"
      widthTablet={480}
      maxWidthMobile="95%"
      scrollable={false}
      footer={footerActions}
    >
      <View style={styles.content}>
        {/* Inputs en línea */}
        <View style={styles.inputsRow}>
          {/* Total a pagar */}
          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Total a pagar</Text>
            <TextInput
              value={`$${amountToPay.toFixed(2)}`}
              editable={false}
              mode="flat"
              style={styles.totalInput}
              dense
              theme={{
                colors: {
                  primary: theme.colors.primary,
                  background: 'rgba(255, 255, 255, 0.05)',
                  text: theme.dark ? '#FFFFFF' : '#000000',
                },
              }}
            />
          </View>

          {/* Monto recibido */}
          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Monto recibido</Text>
            <TextInput
              value={receivedAmount}
              onChangeText={setReceivedAmount}
              keyboardType="decimal-pad"
              mode="flat"
              left={<TextInput.Affix text="$" />}
              style={styles.receivedInput}
              error={
                receivedAmount !== '' &&
                (isNaN(parseFloat(receivedAmount)) ||
                  parseFloat(receivedAmount) < amountToPay)
              }
              dense
              theme={{
                colors: {
                  primary: theme.colors.primary,
                  background: 'rgba(255, 255, 255, 0.05)',
                },
              }}
            />
          </View>
        </View>

        {/* Error message */}
        {receivedAmount !== '' &&
          (isNaN(parseFloat(receivedAmount)) ||
            parseFloat(receivedAmount) < amountToPay) && (
            <Text style={styles.errorText}>Monto insuficiente</Text>
          )}

        {/* Botones de billetes comunes */}
        {availableBills.length > 0 && (
          <View style={styles.quickAmountsRow}>
            {availableBills.map((bill) => (
              <Pressable
                key={bill}
                onPress={() => setReceivedAmount(`${bill}.00`)}
                style={({ pressed }) => [
                  styles.quickAmountButton,
                  pressed && styles.quickAmountButtonPressed,
                ]}
              >
                <Text style={styles.quickAmountButtonText}>
                  ${bill >= 1000 ? '1k' : bill}
                </Text>
              </Pressable>
            ))}
          </View>
        )}

        {/* Mostrar cambio */}
        {receivedAmount !== '' &&
          !isNaN(parseFloat(receivedAmount)) &&
          parseFloat(receivedAmount) >= amountToPay && (
            <View style={styles.changeSection}>
              <Text style={styles.changeLabel}>Cambio</Text>
              <Text style={styles.changeAmount}>
                ${changeAmount.toFixed(2)}
              </Text>
            </View>
          )}
      </View>
    </ResponsiveModal>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    content: {
      // Ya no necesita padding ya que ResponsiveModal lo maneja
    },
    inputsRow: {
      flexDirection: 'row',
      gap: 16,
      marginBottom: 20,
    },
    inputContainer: {
      flex: 1,
    },
    inputLabel: {
      ...theme.fonts.bodyMedium,
      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',
      marginBottom: 8,
      fontSize: 14,
    },
    totalInput: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.08)'
        : 'rgba(0, 0, 0, 0.04)',
      borderRadius: 12,
      fontSize: 20,
      height: 56,
      paddingHorizontal: 16,
      opacity: 0.8,
    },
    receivedInput: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.08)'
        : 'rgba(0, 0, 0, 0.04)',
      borderRadius: 12,
      fontSize: 20,
      height: 56,
      paddingHorizontal: 16,
    },
    quickAmountsRow: {
      flexDirection: 'row',
      gap: 12,
      marginTop: 16,
      justifyContent: 'center',
    },
    quickAmountButton: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.1)'
        : 'rgba(0, 0, 0, 0.05)',
      paddingHorizontal: 20,
      paddingVertical: 16,
      borderRadius: 12,
      flex: 1,
      alignItems: 'center',
      minHeight: 56,
      justifyContent: 'center',
    },
    quickAmountButtonPressed: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.2)'
        : 'rgba(0, 0, 0, 0.1)',
    },
    quickAmountButtonText: {
      ...theme.fonts.labelLarge,
      color: theme.dark ? '#FFFFFF' : '#000000',
      fontWeight: '700',
      fontSize: 18,
    },
    errorText: {
      ...theme.fonts.bodyMedium,
      color: '#FF4444',
      marginTop: 4,
      marginLeft: 4,
      fontSize: 14,
    },
    changeSection: {
      backgroundColor: theme.dark
        ? 'rgba(16, 185, 129, 0.1)'
        : 'rgba(16, 185, 129, 0.08)',
      padding: 20,
      borderRadius: 16,
      alignItems: 'center',
      marginTop: 16,
    },
    changeLabel: {
      ...theme.fonts.bodyLarge,
      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',
      marginBottom: 4,
      fontSize: 16,
    },
    changeAmount: {
      ...theme.fonts.headlineMedium,
      color: '#10B981',
      fontWeight: '700',
      letterSpacing: -0.5,
      fontSize: 32,
    },
    footer: {
      flexDirection: 'row',
      gap: 16,
      // ResponsiveModal maneja padding, border y background
    },
    cancelButton: {
      flex: 1,
      borderColor: theme.colors.error,
      backgroundColor: theme.colors.errorContainer,
    },
    cancelButtonLabel: {
      fontSize: 16,
      fontWeight: '700',
      color: theme.colors.onErrorContainer,
    },
    confirmButton: {
      flex: 2,
      backgroundColor: '#10B981',
    },
    confirmButtonLabel: {
      fontSize: 16,
      fontWeight: '700',
      color: '#FFFFFF',
    },
    footerButtonContent: {
      height: 48,
    },
  });

export default ChangeCalculatorModal;

================
File: app/src/modules/orders/components/CloseShiftModal.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Surface,
  Divider,
  Card,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { shiftsService, type Shift } from '@/services/shifts';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';

interface CloseShiftModalProps {
  visible: boolean;
  onDismiss: () => void;
  onShiftClosed: () => void;
  shift: Shift | null;
}

export const CloseShiftModal: React.FC<CloseShiftModalProps> = ({
  visible,
  onDismiss,
  onShiftClosed,
  shift,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [finalCash, setFinalCash] = useState('');
  const [closeNotes, setCloseNotes] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleFinalCashChange = (text: string) => {
    // Permitir solo números y un punto decimal
    const cleaned = text.replace(/[^0-9.]/g, '');

    // Prevenir múltiples puntos decimales
    const parts = cleaned.split('.');
    if (parts.length > 2) return;

    // Limitar a 2 decimales
    if (parts[1] && parts[1].length > 2) {
      setFinalCash(parts[0] + '.' + parts[1].substring(0, 2));
    } else {
      setFinalCash(cleaned);
    }
  };

  const handleCloseShift = async () => {
    if (!finalCash) {
      setError('El efectivo final es requerido');
      return;
    }

    const cashAmount = parseFloat(finalCash);
    if (isNaN(cashAmount) || cashAmount < 0) {
      setError('Ingresa un monto válido');
      return;
    }

    setLoading(true);
    setError('');

    try {
      await shiftsService.closeShift({
        finalCash: cashAmount,
        closeNotes: closeNotes || undefined,
      });

      showSnackbar({ message: 'Turno cerrado exitosamente', type: 'success' });
      setFinalCash('');
      setCloseNotes('');
      onShiftClosed();
      onDismiss();
    } catch (error: any) {
      let errorMessage = 'Error al cerrar el turno';

      if (error?.message) {
        errorMessage = error.message;
      } else if (typeof error === 'string') {
        errorMessage = error;
      }

      setError(errorMessage);
      showSnackbar({ message: errorMessage, type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  const handleDismiss = () => {
    if (!loading) {
      setFinalCash('');
      setCloseNotes('');
      setError('');
      onDismiss();
    }
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency: 'MXN',
    }).format(amount);
  };

  const formatTime = (dateString: string) => {
    return format(new Date(dateString), 'HH:mm', { locale: es });
  };

  const calculateDifference = () => {
    if (!finalCash || !shift?.expectedCash) return null;
    const cash = parseFloat(finalCash);
    if (isNaN(cash)) return null;
    return cash - shift.expectedCash;
  };

  const difference = calculateDifference();
  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
        dismissable={!loading}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <ScrollView
            contentContainerStyle={styles.scrollViewContent}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          >
            <Surface style={styles.modal} elevation={3}>
              {/* Header */}
              <View style={styles.header}>
                <View style={styles.iconContainer}>
                  <MaterialCommunityIcons
                    name="store-off"
                    size={48}
                    color="#FF5722"
                  />
                </View>
                <Text variant="headlineMedium" style={styles.title}>
                  Cierre de Turno
                </Text>
                <Text variant="bodyLarge" style={styles.date}>
                  {todayFormatted}
                </Text>
              </View>

              <Divider style={styles.divider} />

              {/* Resumen del turno */}
              {shift && (
                <View style={styles.content}>
                  <Card style={styles.summaryCard}>
                    <Card.Content>
                      <Text variant="titleMedium" style={styles.sectionTitle}>
                        Resumen del Turno #{shift.globalShiftNumber}
                      </Text>

                      <View style={styles.summaryRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto a las:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatTime(shift.openedAt)}
                        </Text>
                      </View>

                      <View style={styles.summaryRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Efectivo inicial:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatCurrency(shift.initialCash)}
                        </Text>
                      </View>

                      {shift.totalSales !== null && (
                        <View style={styles.summaryRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Ventas del turno:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.totalSales)}
                          </Text>
                        </View>
                      )}

                      {shift.expectedCash !== null && (
                        <View style={styles.summaryRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Efectivo esperado:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.expectedCash)}
                          </Text>
                        </View>
                      )}
                    </Card.Content>
                  </Card>

                  {/* Formulario de cierre */}
                  <View style={styles.inputSection}>
                    <Text variant="titleMedium" style={styles.sectionTitle}>
                      Información de Cierre
                    </Text>

                    <TextInput
                      label="Efectivo final en caja"
                      value={finalCash}
                      onChangeText={handleFinalCashChange}
                      keyboardType="decimal-pad"
                      mode="outlined"
                      left={<TextInput.Affix text="$" />}
                      style={styles.input}
                      disabled={loading}
                      error={!!error}
                      placeholder="0.00"
                      outlineColor={
                        error ? theme.colors.error : theme.colors.outline
                      }
                      activeOutlineColor={
                        error ? theme.colors.error : theme.colors.primary
                      }
                    />

                    {difference !== null && (
                      <View
                        style={[
                          styles.differenceContainer,
                          difference < 0
                            ? styles.negativeDifference
                            : styles.positiveDifference,
                        ]}
                      >
                        <MaterialCommunityIcons
                          name={
                            difference >= 0 ? 'trending-up' : 'trending-down'
                          }
                          size={20}
                          color={difference >= 0 ? '#4CAF50' : '#FF5722'}
                        />
                        <Text
                          style={[
                            styles.differenceText,
                            { color: difference >= 0 ? '#4CAF50' : '#FF5722' },
                          ]}
                        >
                          {difference >= 0 ? 'Sobrante: ' : 'Faltante: '}
                          {formatCurrency(Math.abs(difference))}
                        </Text>
                      </View>
                    )}

                    <HelperText
                      type="error"
                      visible={!!error}
                      style={styles.errorText}
                    >
                      {error}
                    </HelperText>

                    <SpeechRecognitionInput
                      key="close-notes-input"
                      label="Notas de cierre (opcional)"
                      value={closeNotes}
                      onChangeText={setCloseNotes}
                      multiline
                      speechLang="es-MX"
                      placeholder="Ej: Observaciones del turno, incidencias..."
                      autoCapitalize="sentences"
                      autoCorrect={false}
                      disabled={loading}
                    />
                  </View>
                </View>
              )}

              {/* Footer */}
              <View style={styles.footer}>
                <Button
                  mode="text"
                  onPress={handleDismiss}
                  style={[styles.button, styles.cancelButton]}
                  labelStyle={styles.cancelButtonText}
                  disabled={loading}
                >
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleCloseShift}
                  style={[styles.button, styles.confirmButton]}
                  contentStyle={styles.confirmButtonContent}
                  labelStyle={styles.confirmButtonText}
                  loading={loading}
                  disabled={loading}
                  icon="stop-circle"
                >
                  Cerrar Turno
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
    },
    scrollViewContent: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.m,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 8,
      },
      shadowOpacity: 0.25,
      shadowRadius: 16,
      elevation: 8,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surfaceVariant,
    },
    iconContainer: {
      width: 90,
      height: 90,
      borderRadius: 45,
      backgroundColor: theme.colors.surface,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      borderWidth: 3,
      borderColor: '#FF5722',
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 4,
      },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 4,
    },
    title: {
      color: theme.colors.onSurfaceVariant,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    summaryCard: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    value: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
    },
    highlight: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    inputSection: {
      marginTop: theme.spacing.s,
    },
    input: {
      backgroundColor: theme.colors.surface,
      marginBottom: theme.spacing.s,
    },
    differenceContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.s,
      gap: theme.spacing.s,
    },
    positiveDifference: {
      backgroundColor: 'rgba(76, 175, 80, 0.1)',
      borderWidth: 1,
      borderColor: '#4CAF50',
    },
    negativeDifference: {
      backgroundColor: 'rgba(255, 87, 34, 0.1)',
      borderWidth: 1,
      borderColor: '#FF5722',
    },
    differenceText: {
      fontWeight: '600',
    },
    errorText: {
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      borderBottomLeftRadius: theme.roundness * 3,
      borderBottomRightRadius: theme.roundness * 3,
    },
    button: {
      flex: 1,
    },
    cancelButton: {
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    cancelButtonText: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    confirmButton: {
      backgroundColor: '#FF5722',
      borderWidth: 2,
      borderColor: '#FF5722',
      borderRadius: theme.roundness * 2,
    },
    confirmButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    confirmButtonText: {
      color: '#FFFFFF',
      fontWeight: '600',
    },
  });

================
File: app/src/modules/orders/components/OpenShiftModal.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  TextInput as _RNTextInput,
  Platform,
  KeyboardAvoidingView,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Surface,
  Divider,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { shiftsService } from '@/services/shifts';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';

interface OpenShiftModalProps {
  visible: boolean;
  onDismiss: () => void;
  onShiftOpened: () => void;
}

export const OpenShiftModal: React.FC<OpenShiftModalProps> = ({
  visible,
  onDismiss,
  onShiftOpened,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [initialCash, setInitialCash] = useState('');
  const [notes, setNotes] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleInitialCashChange = (text: string) => {
    // Permitir solo números y un punto decimal
    const cleaned = text.replace(/[^0-9.]/g, '');

    // Prevenir múltiples puntos decimales
    const parts = cleaned.split('.');
    if (parts.length > 2) return;

    // Limitar a 2 decimales
    if (parts[1] && parts[1].length > 2) {
      setInitialCash(parts[0] + '.' + parts[1].substring(0, 2));
    } else {
      setInitialCash(cleaned);
    }
  };

  const handleOpenShift = async () => {
    if (!initialCash) {
      setError('El monto inicial es requerido');
      return;
    }

    const cashAmount = parseFloat(initialCash);
    if (isNaN(cashAmount) || cashAmount < 0) {
      setError('Ingresa un monto válido');
      return;
    }

    setLoading(true);
    setError('');

    try {
      await shiftsService.openShift({
        initialCash: cashAmount,
        notes: notes || undefined,
      });

      showSnackbar({ message: 'Turno abierto exitosamente', type: 'success' });
      setInitialCash('');
      setNotes('');
      onShiftOpened();
      onDismiss();
    } catch (error: any) {
      const errorMessage =
        error.response?.data?.message || 'Error al abrir el turno';
      setError(errorMessage);
      showSnackbar({ message: errorMessage, type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  const handleDismiss = () => {
    if (!loading) {
      setInitialCash('');
      setNotes('');
      setError('');
      onDismiss();
    }
  };

  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
        dismissable={!loading}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <ScrollView
            contentContainerStyle={styles.scrollViewContent}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          >
            <Surface style={styles.modal} elevation={3}>
              {/* Header */}
              <View style={styles.header}>
                <View style={styles.iconContainer}>
                  <MaterialCommunityIcons
                    name="store-check"
                    size={48}
                    color={theme.colors.primary}
                  />
                </View>
                <Text variant="headlineMedium" style={styles.title}>
                  Apertura de Turno
                </Text>
                <Text variant="bodyLarge" style={styles.date}>
                  {todayFormatted}
                </Text>
              </View>

              <Divider style={styles.divider} />

              {/* Content */}
              <View style={styles.content}>
                <View style={styles.infoCard}>
                  <MaterialCommunityIcons
                    name="information"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text variant="bodyMedium" style={styles.infoText}>
                    Registra el monto inicial para comenzar las operaciones del
                    turno.
                  </Text>
                </View>

                <View style={styles.inputSection}>
                  <Text variant="titleMedium" style={styles.sectionTitle}>
                    Información de Apertura
                  </Text>

                  <TextInput
                    label="Monto inicial en caja"
                    value={initialCash}
                    onChangeText={handleInitialCashChange}
                    keyboardType="decimal-pad"
                    mode="outlined"
                    left={<TextInput.Affix text="$" />}
                    style={styles.input}
                    disabled={loading}
                    error={!!error}
                    placeholder="0.00"
                    outlineColor={
                      error ? theme.colors.error : theme.colors.outline
                    }
                    activeOutlineColor={
                      error ? theme.colors.error : theme.colors.primary
                    }
                  />

                  <HelperText
                    type="error"
                    visible={!!error}
                    style={styles.errorText}
                  >
                    {error}
                  </HelperText>

                  <SpeechRecognitionInput
                    key="notes-input-shift"
                    label="Notas adicionales (opcional)"
                    value={notes}
                    onChangeText={setNotes}
                    multiline
                    speechLang="es-MX"
                    placeholder="Ej: Estado de la caja, observaciones..."
                    autoCapitalize="sentences"
                    autoCorrect={false}
                    disabled={loading}
                  />
                </View>
              </View>

              {/* Footer */}
              <View style={styles.footer}>
                <Button
                  mode="text"
                  onPress={handleDismiss}
                  style={[styles.button, styles.cancelButton]}
                  labelStyle={styles.cancelButtonText}
                  disabled={loading}
                >
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleOpenShift}
                  style={[styles.button, styles.confirmButton]}
                  contentStyle={styles.confirmButtonContent}
                  labelStyle={styles.confirmButtonText}
                  loading={loading}
                  disabled={loading}
                  icon="play-circle"
                >
                  Abrir Turno
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
    },
    scrollViewContent: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 2,
      marginHorizontal: theme.spacing.m,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
    },
    iconContainer: {
      width: 80,
      height: 80,
      borderRadius: 40,
      backgroundColor: theme.colors.primaryContainer,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    title: {
      color: theme.colors.onSurface,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    infoCard: {
      flexDirection: 'row',
      backgroundColor: theme.colors.primaryContainer,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.l,
      gap: theme.spacing.s,
    },
    infoText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
      lineHeight: 20,
    },
    inputSection: {
      marginTop: theme.spacing.s,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    input: {
      backgroundColor: theme.colors.surface,
    },
    errorText: {
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
    },
    button: {
      flex: 1,
    },
    cancelButton: {
      borderColor: theme.colors.outline,
      borderWidth: 1,
    },
    cancelButtonText: {
      color: theme.colors.onSurfaceVariant,
    },
    confirmButton: {
      backgroundColor: theme.colors.primary,
      elevation: 0,
    },
    confirmButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    confirmButtonText: {
      color: theme.colors.onPrimary,
      fontWeight: '600',
    },
  });

================
File: app/src/modules/orders/components/ShiftStatusBanner.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Button, ActivityIndicator, Card } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import type { Shift } from '@/services/shifts';

interface ShiftStatusBannerProps {
  shift: Shift | null;
  loading: boolean;
  onOpenShift: () => void;
  canOpenShift: boolean;
}

export const ShiftStatusBanner: React.FC<ShiftStatusBannerProps> = ({
  shift,
  loading,
  onOpenShift,
  canOpenShift,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="small" />
      </View>
    );
  }

  if (!shift || shift.status !== 'OPEN') {
    return (
      <Card style={styles.statusCard} mode="elevated">
        <Card.Content style={styles.closedShiftContent}>
          <View style={styles.iconContainer}>
            <MaterialCommunityIcons
              name="store-clock"
              size={64}
              color={theme.colors.primary}
            />
          </View>

          <Text variant="headlineSmall" style={styles.closedTitle}>
            {canOpenShift ? '¡Bienvenido!' : 'Turno Cerrado'}
          </Text>

          <Text variant="bodyLarge" style={styles.closedDescription}>
            {canOpenShift
              ? 'Para comenzar a operar, necesitas abrir el turno.'
              : 'El restaurante aún no ha abierto operaciones.'}
          </Text>

          {canOpenShift && (
            <View style={styles.adminInfo}>
              <MaterialCommunityIcons
                name="shield-crown"
                size={20}
                color={theme.colors.primary}
              />
              <Text variant="labelMedium" style={styles.adminText}>
                Como administrador, puedes iniciar las operaciones del turno
              </Text>
            </View>
          )}

          {canOpenShift && (
            <Button
              mode="contained"
              onPress={onOpenShift}
              style={styles.openShiftButton}
              icon="play-circle"
              contentStyle={styles.openShiftButtonContent}
            >
              Abrir Turno
            </Button>
          )}

          {!canOpenShift && (
            <View style={styles.contactInfo}>
              <MaterialCommunityIcons
                name="information"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
              <Text variant="bodyMedium" style={styles.contactText}>
                Contacta a tu administrador o gerente para iniciar operaciones
              </Text>
            </View>
          )}
        </Card.Content>
      </Card>
    );
  }

  return (
    <Card style={styles.openStatusCard} mode="elevated">
      <Card.Content>
        <View style={styles.statusHeader}>
          <View style={styles.openIconContainer}>
            <MaterialCommunityIcons
              name="store-check"
              size={28}
              color={theme.colors.primary}
            />
          </View>
          <View style={styles.statusHeaderText}>
            <Text variant="titleMedium" style={styles.statusTitle}>
              Turno Activo
            </Text>
            <Text variant="labelMedium" style={styles.statusSubtitle}>
              {format(new Date(shift.date), "EEEE, d 'de' MMMM", {
                locale: es,
              })}
            </Text>
          </View>
        </View>

        <View style={styles.statusInfoGrid}>
          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="counter"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Turno Global
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              #{shift.globalShiftNumber}
            </Text>
          </View>

          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="calendar-today"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Turno de Hoy
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              #{shift.shiftNumber}
            </Text>
          </View>

          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="account-clock"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Abierto desde
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              {format(new Date(shift.openedAt), 'HH:mm', {
                locale: es,
              })}
            </Text>
          </View>
        </View>

        <View style={styles.openedByInfo}>
          <MaterialCommunityIcons
            name="account-circle"
            size={16}
            color={theme.colors.onSurfaceVariant}
          />
          <Text variant="bodySmall" style={styles.openedByText}>
            Abierto por {shift.openedBy.firstName} {shift.openedBy.lastName}
          </Text>
        </View>
      </Card.Content>
    </Card>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    loadingContainer: {
      padding: theme.spacing.m,
      alignItems: 'center',
    },
    statusCard: {
      margin: theme.spacing.m,
      marginBottom: theme.spacing.l,
      backgroundColor: theme.colors.surface,
      elevation: 4,
    },
    closedShiftContent: {
      alignItems: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
    },
    iconContainer: {
      marginBottom: theme.spacing.l,
      padding: theme.spacing.m,
      borderRadius: 100,
      backgroundColor: theme.colors.primaryContainer,
    },
    closedTitle: {
      color: theme.colors.onSurface,
      fontWeight: '700',
      marginBottom: theme.spacing.s,
      textAlign: 'center',
    },
    closedDescription: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: theme.spacing.l,
      paddingHorizontal: theme.spacing.m,
    },
    adminInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      marginBottom: theme.spacing.l,
    },
    adminText: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '500',
    },
    openShiftButton: {
      marginTop: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    openShiftButtonContent: {
      paddingVertical: theme.spacing.s,
    },
    contactInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      backgroundColor: theme.colors.surfaceVariant,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.m,
    },
    contactText: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    openStatusCard: {
      margin: theme.spacing.m,
      marginBottom: theme.spacing.l,
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    statusHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
      marginBottom: theme.spacing.l,
    },
    openIconContainer: {
      padding: theme.spacing.s,
      borderRadius: 50,
      backgroundColor: theme.colors.primaryContainer,
    },
    statusHeaderText: {
      flex: 1,
    },
    statusTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    statusSubtitle: {
      color: theme.colors.onSurfaceVariant,
      textTransform: 'capitalize',
    },
    statusInfoGrid: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.m,
    },
    infoCard: {
      flex: 1,
      backgroundColor: theme.colors.surfaceVariant,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    infoCardLabel: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    infoCardValue: {
      color: theme.colors.primary,
      fontWeight: '700',
      textAlign: 'center',
    },
    openedByInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      paddingTop: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    openedByText: {
      color: theme.colors.onSurfaceVariant,
    },
  });

================
File: app/src/modules/orders/screens/AddProductsToOrderScreen.tsx
================
import React, {
  useState,
  useMemo,
  useRef,
  useCallback,
  useEffect,
} from 'react';
import { StyleSheet, View, FlatList } from 'react-native';
import {
  Text,
  Portal,
  ActivityIndicator,
  Card,
  Title,
  Appbar,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation, useRoute } from '@react-navigation/native';
import { useGetOrderMenu } from '../hooks/useMenuQueries';
import { Product, Category, SubCategory } from '../types/orders.types';
import { AutoImage } from '@/app/components/common/AutoImage';
import ProductCustomizationModal from '../components/ProductCustomizationModal';
import SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';
import CartButton from '../components/CartButton';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import type { OrdersStackScreenProps } from '@/app/navigation/types';
import { CartItem, CartItemModifier } from '../context/CartContext';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';

// Props de navegación
type AddProductsRouteProps = {
  orderId: string;
  orderNumber: number;
  existingOrderItemsCount?: number; // Número de items que ya están en la orden
  existingTempProducts?: CartItem[]; // Productos temporales existentes
  onProductsAdded?: (products: CartItem[]) => void;
};

interface CartButtonHandle {
  animate: () => void;
}

const AddProductsToOrderScreen = () => {
  const theme = useAppTheme();
  const { colors, fonts } = theme;
  const responsive = useResponsive();
  const navigation = useNavigation();
  const route =
    useRoute<OrdersStackScreenProps<'AddProductsToOrder'>['route']>();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const cartButtonRef = useRef<CartButtonHandle>(null);

  // Obtener parámetros de navegación
  const {
    orderId: _orderId,
    orderNumber,
    existingTempProducts,
    existingOrderItemsCount,
    onProductsAdded,
  } = route.params as AddProductsRouteProps;

  // Estados para navegación y selección
  const [navigationLevel, setNavigationLevel] = useState<
    'categories' | 'subcategories' | 'products'
  >('categories');
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null,
  );
  const [selectedSubcategoryId, setSelectedSubcategoryId] = useState<
    string | null
  >(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [selectedProductForDescription, setSelectedProductForDescription] =
    useState<Product | null>(null);
  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =
    useState(false);

  // Estado local para productos seleccionados - inicializar con productos existentes si los hay
  const [selectedProducts, setSelectedProducts] = useState<CartItem[]>(
    existingTempProducts || [],
  );

  const { data: menu, isLoading } = useGetOrderMenu();

  // Calcular total de items (incluir items existentes de la orden)
  const totalItemsCount = useMemo(() => {
    const newItemsCount = selectedProducts.reduce(
      (sum, item) => sum + item.quantity,
      0,
    );
    const existingItemsCount = existingOrderItemsCount || 0;
    return newItemsCount + existingItemsCount;
  }, [selectedProducts, existingOrderItemsCount]);

  // Mostrar mensaje si hay productos existentes al entrar
  useEffect(() => {
    if (existingTempProducts && existingTempProducts.length > 0) {
      const totalItems = existingTempProducts.reduce(
        (sum, item) => sum + item.quantity,
        0,
      );
      showSnackbar({
        message: `${totalItems} producto${totalItems > 1 ? 's' : ''} recuperado${totalItems > 1 ? 's' : ''}`,
        type: 'info',
      });
    }
  }, []);

  const handleCategorySelect = useCallback((categoryId: string) => {
    setSelectedCategoryId(categoryId);
    setSelectedSubcategoryId(null);
    setNavigationLevel('subcategories');
  }, []);

  const handleSubCategorySelect = useCallback((subcategoryId: string) => {
    setSelectedSubcategoryId(subcategoryId);
    setNavigationLevel('products');
  }, []);

  const productNeedsCustomization = useCallback((product: Product): boolean => {
    if (!product) return false;
    const hasVariants =
      product.hasVariants &&
      product.variants &&
      Array.isArray(product.variants) &&
      product.variants.length > 0;
    const hasModifiers =
      product.modifierGroups &&
      Array.isArray(product.modifierGroups) &&
      product.modifierGroups.length > 0;
    return hasVariants || hasModifiers;
  }, []);

  const handleProductSelect = useCallback(
    (product: Product) => {
      if (productNeedsCustomization(product)) {
        setSelectedProduct(product);
      } else {
        // Añadir producto directamente sin personalización
        addItemToSelection(product, 1);
      }
    },
    [productNeedsCustomization, addItemToSelection],
  );

  const addItemToSelection = (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    const selectedVariant = product.variants?.find(
      (v) => v.id === selectedVariantId,
    );
    const variantPrice = selectedVariant?.price || product.price;
    const modifiersPrice =
      selectedModifiers?.reduce((sum, mod) => sum + (mod.price || 0), 0) || 0;
    const pizzaCost = pizzaExtraCost || 0;
    const unitPrice = variantPrice + modifiersPrice + pizzaCost;

    // Buscar si ya existe un item idéntico en la selección actual
    const existingIndex = selectedProducts.findIndex((item) => {
      // Verificar si es el mismo producto, variante, modificadores y notas
      if (item.productId !== product.id) return false;
      if (item.variantId !== selectedVariantId) return false;
      if (item.preparationNotes !== preparationNotes) return false;

      // Comparar modificadores
      const itemModifierIds = item.modifiers
        .map((m) => m.id)
        .sort()
        .join(',');
      const newModifierIds = (selectedModifiers || [])
        .map((m) => m.id)
        .sort()
        .join(',');

      if (itemModifierIds !== newModifierIds) return false;

      // Comparar pizza customizations
      const existingCustomizations = item.selectedPizzaCustomizations || [];
      const newCustomizations = selectedPizzaCustomizations || [];

      if (existingCustomizations.length !== newCustomizations.length)
        return false;

      const sortedExistingCustomizations = [...existingCustomizations].sort(
        (a, b) =>
          `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
            `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
          ),
      );
      const sortedNewCustomizations = [...newCustomizations].sort((a, b) =>
        `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
          `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
        ),
      );

      for (let i = 0; i < sortedExistingCustomizations.length; i++) {
        if (
          sortedExistingCustomizations[i].pizzaCustomizationId !==
            sortedNewCustomizations[i].pizzaCustomizationId ||
          sortedExistingCustomizations[i].half !==
            sortedNewCustomizations[i].half ||
          sortedExistingCustomizations[i].action !==
            sortedNewCustomizations[i].action
        ) {
          return false;
        }
      }

      return true;
    });

    if (existingIndex !== -1) {
      // Si existe, actualizar la cantidad
      setSelectedProducts((prev) => {
        const updated = [...prev];
        const existingItem = updated[existingIndex];
        const newQuantity = existingItem.quantity + quantity;

        // Recalcular el precio total correctamente
        const modifiersTotal = existingItem.modifiers.reduce(
          (sum, mod) => sum + Number(mod.price || 0),
          0,
        );
        const pizzaCostTotal = existingItem.pizzaExtraCost || 0;
        const unitPriceWithModifiers =
          Number(existingItem.unitPrice || 0) + modifiersTotal + pizzaCostTotal;

        updated[existingIndex] = {
          ...existingItem,
          quantity: newQuantity,
          totalPrice: unitPriceWithModifiers * newQuantity,
        };
        return updated;
      });
    } else {
      // Si no existe, agregar nuevo item
      const newItem: CartItem = {
        id: `temp-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
        productId: product.id,
        productName: product.name,
        quantity,
        unitPrice: variantPrice,
        totalPrice: unitPrice * quantity,
        modifiers: selectedModifiers || [],
        variantId: selectedVariantId,
        variantName: selectedVariant?.name,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      };

      setSelectedProducts((prev) => [...prev, newItem]);
    }

    // Animar el carrito
    cartButtonRef.current?.animate();

    showSnackbar({
      message: `${product.name} añadido`,
      type: 'success',
    });
  };

  const updateItemInSelection = (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    setSelectedProducts((prev) =>
      prev.map((item) => {
        if (item.id === itemId) {
          const modifiersPrice = modifiers.reduce(
            (sum, mod) => sum + Number(mod.price || 0),
            0,
          );
          const pizzaCost = pizzaExtraCost || 0;
          const finalUnitPrice =
            unitPrice !== undefined ? unitPrice : item.unitPrice;
          const newTotalPrice =
            (finalUnitPrice + modifiersPrice + pizzaCost) * quantity;

          return {
            ...item,
            quantity,
            modifiers,
            preparationNotes:
              preparationNotes !== undefined
                ? preparationNotes
                : item.preparationNotes,
            variantId: variantId !== undefined ? variantId : item.variantId,
            variantName:
              variantName !== undefined ? variantName : item.variantName,
            unitPrice: finalUnitPrice,
            totalPrice: newTotalPrice,
            selectedPizzaCustomizations:
              selectedPizzaCustomizations !== undefined
                ? selectedPizzaCustomizations
                : item.selectedPizzaCustomizations,
            pizzaExtraCost,
          };
        }
        return item;
      }),
    );
  };

  const handleAddToCart = (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    if (editingItem) {
      // Si estamos editando, actualizar el item existente
      updateItemInSelection(
        editingItem.id,
        quantity,
        selectedModifiers || [],
        preparationNotes,
        selectedVariantId,
        product.variants?.find((v) => v.id === selectedVariantId)?.name,
        selectedVariantId
          ? product.variants?.find((v) => v.id === selectedVariantId)?.price
          : product.price,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      );
      setEditingItem(null);
    } else {
      // Si es nuevo, añadir a la selección
      addItemToSelection(
        product,
        quantity,
        selectedVariantId,
        selectedModifiers,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      );
    }
    setSelectedProduct(null);
  };

  const handleCloseProductModal = useCallback(() => {
    setSelectedProduct(null);
    setEditingItem(null);
  }, []);

  const handleConfirmSelection = () => {
    // No mostrar mensaje si no hay productos nuevos seleccionados
    // pero permitir salir igualmente

    // Llamar callback con todos los productos (existentes + nuevos)
    if (onProductsAdded) {
      onProductsAdded(selectedProducts);
    }

    // Navegar de vuelta al resumen de orden
    navigation.goBack();
  };

  const handleBack = () => {
    if (selectedProduct) {
      setSelectedProduct(null);
    } else if (navigationLevel === 'products') {
      setNavigationLevel('subcategories');
      setSelectedSubcategoryId(null);
    } else if (navigationLevel === 'subcategories') {
      setNavigationLevel('categories');
      setSelectedCategoryId(null);
    } else {
      // Al salir, guardar los productos seleccionados
      if (onProductsAdded) {
        onProductsAdded(selectedProducts);
      }
      navigation.goBack();
    }
  };

  const getCategories = () => {
    if (!menu || !Array.isArray(menu)) return [];
    return menu;
  };

  const getSubcategories = () => {
    if (!selectedCategory || !Array.isArray(selectedCategory.subcategories))
      return [];
    return selectedCategory.subcategories;
  };

  const getProducts = () => {
    if (!selectedSubCategory || !Array.isArray(selectedSubCategory.products))
      return [];
    return selectedSubCategory.products;
  };

  const selectedCategory = menu?.find(
    (cat: Category) => cat.id === selectedCategoryId,
  );
  const selectedSubCategory = selectedCategory?.subcategories?.find(
    (sub: SubCategory) => sub.id === selectedSubcategoryId,
  );

  const getNavTitle = useCallback(() => {
    if (selectedProduct) {
      return selectedProduct.name;
    }
    switch (navigationLevel) {
      case 'categories':
        return `Añadir a Orden #${orderNumber}`;
      case 'subcategories':
        return selectedCategory?.name || 'Subcategorías';
      case 'products':
        return selectedSubCategory?.name || 'Productos';
      default:
        return 'Categorías';
    }
  }, [
    navigationLevel,
    selectedCategory,
    selectedSubCategory,
    selectedProduct,
    orderNumber,
  ]);

  const handleShowProductDescription = (product: Product) => {
    setSelectedProductForDescription(product);
    setIsDescriptionModalVisible(true);
  };

  const handleCloseDescriptionModal = () => {
    setIsDescriptionModalVisible(false);
    setSelectedProductForDescription(null);
  };

  // Calcular número de columnas dinámicamente
  const numColumns = useMemo(() => {
    // Para tablets (ancho >= 600px)
    if (responsive.width >= 600) {
      if (responsive.width >= 1200) return 6; // Tablets muy grandes
      if (responsive.width >= 900) return 5; // Tablets grandes
      if (responsive.width >= 768) return 4; // Tablets medianas
      return 3; // Tablets pequeñas (600-768px)
    }
    // Para móviles (ancho < 600px)
    if (responsive.width >= 480) return 3; // Móviles grandes
    if (responsive.width >= 360) return 2; // Móviles estándar
    return 2; // Móviles pequeños
  }, [responsive.width]);

  // Calcular ancho de items basado en columnas
  const itemWidth = useMemo(() => {
    const padding = responsive.spacing(theme.spacing.m);
    const totalPadding = padding * 2;
    const gap = responsive.spacing(8);
    const totalGaps = gap * (numColumns - 1);
    const availableWidth = responsive.width - totalPadding - totalGaps;
    return Math.floor(availableWidth / numColumns);
  }, [responsive.width, numColumns, theme.spacing.m]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: colors.background,
        },
        container: {
          flex: 1,
        },
        content: {
          flex: 1,
        },
        gridContainer: {
          padding: responsive.spacing(theme.spacing.m),
          paddingBottom: 60,
        },
        row: {
          justifyContent: 'flex-start',
          paddingHorizontal: 0,
          marginBottom: responsive.spacing(8),
          gap: responsive.spacing(8),
        },
        cardItem: {
          width: itemWidth,
          marginHorizontal: 0,
          marginVertical: 0,
          overflow: 'hidden',
          borderRadius: theme.roundness * 2,
          elevation: 2,
          backgroundColor: colors.surface,
          aspectRatio: 0.85,
        },
        cardItemInactive: {
          opacity: 0.5,
        },
        itemImage: {
          width: '100%',
          height: itemWidth * 0.65,
        },
        imageInactive: {
          opacity: 0.6,
        },
        cardContent: {
          paddingHorizontal: responsive.spacing(theme.spacing.s),
          paddingVertical: responsive.spacing(theme.spacing.xs),
          height: itemWidth * 0.35,
          justifyContent: 'center',
        },
        cardTitle: {
          fontSize: responsive.fontSize(responsive.width >= 600 ? 16 : 15),
          fontWeight: '600',
          lineHeight:
            responsive.fontSize(responsive.width >= 600 ? 16 : 15) * 1.2,
          marginBottom: responsive.spacing(2),
        },
        cardHeader: {
          flexDirection: 'row',
          justifyContent: 'space-between',
          alignItems: 'flex-start',
        },
        infoButton: {
          margin: -8,
          marginTop: -12,
          marginRight: -12,
        },
        priceText: {
          color: theme.colors.primary,
          fontWeight: '600',
          fontSize: responsive.fontSize(responsive.width >= 600 ? 14 : 13),
          marginTop: 2,
        },
        noItemsText: {
          textAlign: 'center',
          marginTop: 40,
          fontSize: 16,
          color: '#666',
        },
        loadingContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
        },
        appBar: {
          backgroundColor: colors.elevation.level2,
          alignItems: 'center',
        },
        appBarTitle: {
          ...fonts.titleMedium,
          color: colors.onSurface,
          fontWeight: 'bold',
          textAlign: 'center',
        },
        appBarContent: {},
        spacer: {
          width: 48,
        },
        inactiveBadge: {
          position: 'absolute',
          top: 8,
          right: 8,
          backgroundColor: colors.errorContainer,
          paddingHorizontal: 8,
          paddingVertical: 4,
          borderRadius: 4,
        },
        inactiveBadgeText: {
          fontSize: 12,
          color: colors.onErrorContainer,
          fontWeight: '600',
        },
      }),
    [colors, fonts, theme, responsive, itemWidth],
  );

  const blurhash =
    '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';

  const renderItem = useCallback(
    ({ item }: { item: Category | SubCategory | Product }) => {
      const imageSource = (() => {
        const photoPath = item.photo?.path || item.photo;
        return photoPath || null;
      })();
      const isActive = item.isActive !== false;

      // Verificar si es un producto sin pantalla de preparación
      const isProductWithoutScreen =
        navigationLevel === 'products' &&
        'preparationScreenId' in item &&
        !item.preparationScreenId;

      const handlePress = () => {
        if (!isActive || isProductWithoutScreen) return;

        if (navigationLevel === 'categories') {
          handleCategorySelect(item.id);
        } else if (navigationLevel === 'subcategories') {
          handleSubCategorySelect(item.id);
        } else if ('price' in item) {
          handleProductSelect(item as Product);
        }
      };

      const handleLongPress = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          isActive &&
          'description' in item &&
          (item as Product).description &&
          (item as Product).description.trim() !== ''
        ) {
          handleShowProductDescription(item as Product);
        }
      };

      const renderPrice = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          'hasVariants' in item
        ) {
          const productItem = item as Product;
          if (
            !productItem.hasVariants &&
            productItem.price !== null &&
            productItem.price !== undefined
          ) {
            return (
              <Text style={styles.priceText}>
                ${Number(productItem.price).toFixed(2)}
              </Text>
            );
          }
        }
        return null;
      };

      return (
        <Card
          style={[
            styles.cardItem,
            (!isActive || isProductWithoutScreen) && styles.cardItemInactive,
          ]}
          onPress={handlePress}
          onLongPress={handleLongPress}
          disabled={!isActive || isProductWithoutScreen}
        >
          <AutoImage
            source={imageSource}
            style={[
              styles.itemImage,
              (!isActive || isProductWithoutScreen) && styles.imageInactive,
            ]}
            contentFit="cover"
            placeholder={blurhash}
            transition={300}
            placeholderIcon="image-outline"
          />
          <Card.Content style={styles.cardContent}>
            {navigationLevel === 'products' &&
            'price' in item &&
            (item as Product).description ? (
              <View style={styles.cardHeader}>
                <Title
                  style={[styles.cardTitle, { flex: 1 }]}
                  numberOfLines={2}
                  ellipsizeMode="tail"
                >
                  {item.name}
                </Title>
                <IconButton
                  icon="information-outline"
                  size={20}
                  onPress={() => handleShowProductDescription(item as Product)}
                  style={styles.infoButton}
                />
              </View>
            ) : (
              <Title
                style={styles.cardTitle}
                numberOfLines={2}
                ellipsizeMode="tail"
              >
                {item.name}
              </Title>
            )}
            {renderPrice()}
          </Card.Content>
          {!isActive && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>No disponible</Text>
            </View>
          )}
          {isProductWithoutScreen && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>SIN PANTALLA</Text>
            </View>
          )}
        </Card>
      );
    },
    [
      navigationLevel,
      handleCategorySelect,
      handleSubCategorySelect,
      handleProductSelect,
      handleShowProductDescription,
      styles,
      blurhash,
    ],
  );

  if (isLoading) {
    return (
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
        </View>
      </SafeAreaView>
    );
  }

  const currentData =
    navigationLevel === 'categories'
      ? getCategories()
      : navigationLevel === 'subcategories'
        ? getSubcategories()
        : getProducts();

  return (
    <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
      <View style={styles.container}>
        <Appbar.Header style={styles.appBar}>
          <Appbar.BackAction onPress={handleBack} />
          <Appbar.Content
            title={getNavTitle()}
            titleStyle={styles.appBarTitle}
            style={styles.appBarContent}
          />
          <CartButton
            ref={cartButtonRef}
            itemCount={totalItemsCount}
            onPress={handleConfirmSelection}
          />
        </Appbar.Header>

        <View style={styles.content}>
          {currentData.length === 0 ? (
            <Text style={styles.noItemsText}>
              {navigationLevel === 'categories'
                ? 'No hay categorías disponibles'
                : navigationLevel === 'subcategories'
                  ? 'No hay subcategorías disponibles'
                  : 'No hay productos disponibles'}
            </Text>
          ) : (
            <FlatList
              data={currentData}
              renderItem={renderItem}
              keyExtractor={(item) => item.id}
              numColumns={numColumns}
              key={numColumns}
              contentContainerStyle={styles.gridContainer}
              columnWrapperStyle={numColumns > 1 ? styles.row : undefined}
              showsVerticalScrollIndicator={false}
            />
          )}
        </View>

        {/* Modal de personalización de producto */}
        <Portal>
          {selectedProduct && (
            <ProductCustomizationModal
              visible={true}
              product={selectedProduct}
              editingItem={editingItem}
              onDismiss={handleCloseProductModal}
              onAddToCart={handleAddToCart}
              onUpdateItem={(
                itemId,
                quantity,
                modifiers,
                notes,
                variantId,
                variantName,
                unitPrice,
                selectedPizzaCustomizations,
                pizzaExtraCost,
              ) => {
                updateItemInSelection(
                  itemId,
                  quantity,
                  modifiers,
                  notes,
                  variantId,
                  variantName,
                  unitPrice,
                  selectedPizzaCustomizations,
                  pizzaExtraCost,
                );
                setEditingItem(null);
                setSelectedProduct(null);
              }}
            />
          )}

          {/* Modal de descripción del producto */}
          {selectedProductForDescription && (
            <SimpleProductDescriptionModal
              visible={isDescriptionModalVisible}
              product={selectedProductForDescription}
              onDismiss={handleCloseDescriptionModal}
            />
          )}
        </Portal>
      </View>
    </SafeAreaView>
  );
};

export default AddProductsToOrderScreen;

================
File: app/src/modules/preparationScreens/components/ProductSelectionModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Checkbox,
  Button,
  Searchbar,
  Divider,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from 'react-native-paper';

interface Product {
  id: string;
  name: string;
  photo: any;
  price: string | number | null | undefined;
  isAssociated: boolean;
  currentPreparationScreenId: string | null;
}

interface Subcategory {
  id: string;
  name: string;
  photo: any;
  products: Product[];
}

interface Category {
  id: string;
  name: string;
  photo: any;
  subcategories: Subcategory[];
}

interface MenuData {
  screenId: string;
  screenName: string;
  menu: Category[];
  screenAssignments?: Record<string, string>; // Mapeo de productId a nombre de pantalla
}

interface ProductSelectionModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSave: (productIds: string[]) => void;
  screenId: string;
  menuData?: MenuData;
  loading?: boolean;
}

export const ProductSelectionModal: React.FC<ProductSelectionModalProps> = ({
  visible,
  onDismiss,
  onSave,
  screenId,
  menuData,
  loading = false,
}) => {
  const theme = useTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedProducts, setSelectedProducts] = useState<Set<string>>(
    new Set(),
  );
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set(),
  );
  const [expandedSubcategories, setExpandedSubcategories] = useState<
    Set<string>
  >(new Set());
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [conflictingProducts, setConflictingProducts] = useState<
    Array<{ id: string; name: string; currentScreen: string }>
  >([]);

  // Inicializar productos seleccionados
  useEffect(() => {
    if (menuData) {
      const associatedProducts = new Set<string>();
      menuData.menu.forEach((category) => {
        category.subcategories.forEach((subcategory) => {
          subcategory.products.forEach((product) => {
            if (product.isAssociated) {
              associatedProducts.add(product.id);
            }
          });
        });
      });
      setSelectedProducts(associatedProducts);
    }
  }, [menuData]);

  // Crear mapeo de productos a nombres de pantalla para el mensaje de conflicto
  const getScreenNameForProduct = (productId: string): string => {
    // Primero intentar obtener el nombre desde screenAssignments
    if (menuData?.screenAssignments && menuData.screenAssignments[productId]) {
      return menuData.screenAssignments[productId];
    }

    // Si no está disponible, usar un nombre genérico
    return 'otra pantalla de preparación';
  };

  // Filtrar menú basado en búsqueda
  const filteredMenu = useMemo(() => {
    if (!menuData || !searchQuery) return menuData?.menu || [];

    const query = searchQuery.toLowerCase();
    return menuData.menu
      .map((category) => ({
        ...category,
        subcategories: category.subcategories
          .map((subcategory) => ({
            ...subcategory,
            products: subcategory.products.filter((product) =>
              product.name.toLowerCase().includes(query),
            ),
          }))
          .filter((subcategory) => subcategory.products.length > 0),
      }))
      .filter((category) => category.subcategories.length > 0);
  }, [menuData, searchQuery]);

  const toggleCategory = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };

  const toggleSubcategory = (subcategoryId: string) => {
    const newExpanded = new Set(expandedSubcategories);
    if (newExpanded.has(subcategoryId)) {
      newExpanded.delete(subcategoryId);
    } else {
      newExpanded.add(subcategoryId);
    }
    setExpandedSubcategories(newExpanded);
  };

  const toggleProduct = (productId: string) => {
    const newSelected = new Set(selectedProducts);
    if (newSelected.has(productId)) {
      newSelected.delete(productId);
    } else {
      newSelected.add(productId);
    }
    setSelectedProducts(newSelected);
  };

  const toggleAllInCategory = (category: Category) => {
    const newSelected = new Set(selectedProducts);
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );

    const allSelected = categoryProducts.every((id) => newSelected.has(id));

    if (allSelected) {
      categoryProducts.forEach((id) => newSelected.delete(id));
    } else {
      categoryProducts.forEach((id) => newSelected.add(id));
    }

    setSelectedProducts(newSelected);
  };

  const toggleAllInSubcategory = (subcategory: Subcategory) => {
    const newSelected = new Set(selectedProducts);
    const subcategoryProducts = subcategory.products.map((p) => p.id);

    const allSelected = subcategoryProducts.every((id) => newSelected.has(id));

    if (allSelected) {
      subcategoryProducts.forEach((id) => newSelected.delete(id));
    } else {
      subcategoryProducts.forEach((id) => newSelected.add(id));
    }

    setSelectedProducts(newSelected);
  };

  const isCategoryPartiallySelected = (category: Category) => {
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );
    const selectedCount = categoryProducts.filter((id) =>
      selectedProducts.has(id),
    ).length;
    return selectedCount > 0 && selectedCount < categoryProducts.length;
  };

  const isCategoryFullySelected = (category: Category) => {
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );
    return (
      categoryProducts.length > 0 &&
      categoryProducts.every((id) => selectedProducts.has(id))
    );
  };

  const isSubcategoryPartiallySelected = (subcategory: Subcategory) => {
    const selectedCount = subcategory.products.filter((p) =>
      selectedProducts.has(p.id),
    ).length;
    return selectedCount > 0 && selectedCount < subcategory.products.length;
  };

  const isSubcategoryFullySelected = (subcategory: Subcategory) => {
    return (
      subcategory.products.length > 0 &&
      subcategory.products.every((p) => selectedProducts.has(p.id))
    );
  };

  const handleSave = () => {
    // Verificar si hay productos seleccionados que ya están asignados a otras pantallas
    const conflicts: Array<{
      id: string;
      name: string;
      currentScreen: string;
    }> = [];

    if (menuData) {
      menuData.menu.forEach((category) => {
        category.subcategories.forEach((subcategory) => {
          subcategory.products.forEach((product) => {
            if (
              selectedProducts.has(product.id) &&
              product.currentPreparationScreenId &&
              product.currentPreparationScreenId !== screenId
            ) {
              // Buscar el nombre de la pantalla actual del producto
              const screenName = getScreenNameForProduct(product.id);
              conflicts.push({
                id: product.id,
                name: product.name,
                currentScreen: screenName,
              });
            }
          });
        });
      });
    }

    if (conflicts.length > 0) {
      setConflictingProducts(conflicts);
      setShowConfirmDialog(true);
    } else {
      onSave(Array.from(selectedProducts));
    }
  };

  const handleConfirmSave = () => {
    setShowConfirmDialog(false);
    onSave(Array.from(selectedProducts));
  };

  const handleCancelSave = () => {
    setShowConfirmDialog(false);
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContainer,
          { backgroundColor: theme.colors.surface },
        ]}
      >
        <View style={styles.header}>
          <Text variant="headlineSmall">Seleccionar Productos</Text>
        </View>

        <Searchbar
          placeholder="Buscar productos..."
          onChangeText={setSearchQuery}
          value={searchQuery}
          style={styles.searchBar}
        />

        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
          </View>
        ) : (
          <ScrollView
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
          >
            {filteredMenu.map((category) => (
              <View key={category.id} style={styles.categoryContainer}>
                <TouchableOpacity
                  style={styles.categoryHeader}
                  onPress={() => toggleCategory(category.id)}
                >
                  <View style={styles.categoryTitleContainer}>
                    <IconButton
                      icon={
                        expandedCategories.has(category.id)
                          ? 'chevron-down'
                          : 'chevron-right'
                      }
                      size={20}
                    />
                    <Text variant="titleMedium" style={styles.categoryTitle}>
                      {category.name}
                    </Text>
                  </View>
                  <Checkbox.Android
                    status={
                      isCategoryFullySelected(category)
                        ? 'checked'
                        : isCategoryPartiallySelected(category)
                          ? 'indeterminate'
                          : 'unchecked'
                    }
                    onPress={() => toggleAllInCategory(category)}
                  />
                </TouchableOpacity>

                {expandedCategories.has(category.id) && (
                  <View style={styles.subcategoriesContainer}>
                    {category.subcategories.map((subcategory) => (
                      <View
                        key={subcategory.id}
                        style={styles.subcategoryContainer}
                      >
                        <TouchableOpacity
                          style={styles.subcategoryHeader}
                          onPress={() => toggleSubcategory(subcategory.id)}
                        >
                          <View style={styles.subcategoryTitleContainer}>
                            <IconButton
                              icon={
                                expandedSubcategories.has(subcategory.id)
                                  ? 'chevron-down'
                                  : 'chevron-right'
                              }
                              size={16}
                            />
                            <Text
                              variant="titleSmall"
                              style={styles.subcategoryTitle}
                            >
                              {subcategory.name}
                            </Text>
                          </View>
                          <Checkbox.Android
                            status={
                              isSubcategoryFullySelected(subcategory)
                                ? 'checked'
                                : isSubcategoryPartiallySelected(subcategory)
                                  ? 'indeterminate'
                                  : 'unchecked'
                            }
                            onPress={() => toggleAllInSubcategory(subcategory)}
                          />
                        </TouchableOpacity>

                        {expandedSubcategories.has(subcategory.id) && (
                          <View style={styles.productsContainer}>
                            {subcategory.products.map((product) => (
                              <TouchableOpacity
                                key={product.id}
                                style={styles.productItem}
                                onPress={() => toggleProduct(product.id)}
                              >
                                <View style={styles.productInfo}>
                                  <Text variant="bodyMedium">
                                    {product.name}
                                  </Text>
                                  {product.currentPreparationScreenId &&
                                    product.currentPreparationScreenId !==
                                      screenId && (
                                      <View style={styles.warningContainer}>
                                        <MaterialCommunityIcons
                                          name="alert"
                                          size={12}
                                          color={theme.colors.error}
                                        />
                                        <Text
                                          variant="bodySmall"
                                          style={[
                                            styles.warningText,
                                            { color: theme.colors.error },
                                          ]}
                                        >
                                          Asignado a otra pantalla
                                        </Text>
                                      </View>
                                    )}
                                </View>
                                <Checkbox.Android
                                  status={
                                    selectedProducts.has(product.id)
                                      ? 'checked'
                                      : 'unchecked'
                                  }
                                  onPress={() => toggleProduct(product.id)}
                                />
                              </TouchableOpacity>
                            ))}
                          </View>
                        )}
                      </View>
                    ))}
                  </View>
                )}
                <Divider style={styles.divider} />
              </View>
            ))}
          </ScrollView>
        )}

        <View style={styles.actions}>
          <Button mode="outlined" onPress={onDismiss}>
            Cancelar
          </Button>
          <Button mode="contained" onPress={handleSave} disabled={loading}>
            Guardar
          </Button>
        </View>
      </Modal>

      {/* Modal de confirmación personalizado */}
      <Modal
        visible={showConfirmDialog}
        onDismiss={handleCancelSave}
        contentContainerStyle={{
          backgroundColor: theme.colors.surface,
          margin: 20,
          borderRadius: 16,
          maxHeight: '75%',
          elevation: 8,
        }}
      >
        {/* Header */}
        <View
          style={{
            flexDirection: 'row',
            alignItems: 'center',
            padding: 20,
            paddingBottom: 16,
            borderBottomWidth: 1,
            borderBottomColor: theme.colors.surfaceVariant,
          }}
        >
          <View
            style={{
              width: 40,
              height: 40,
              borderRadius: 20,
              backgroundColor: theme.colors.errorContainer,
              justifyContent: 'center',
              alignItems: 'center',
              marginRight: 12,
            }}
          >
            <MaterialCommunityIcons
              name="alert"
              size={24}
              color={theme.colors.error}
            />
          </View>
          <Text variant="headlineSmall" style={{ flex: 1 }}>
            Reasignar Productos
          </Text>
        </View>

        {/* Subtitle */}
        <View style={{ paddingHorizontal: 20, paddingTop: 16 }}>
          <Text
            variant="bodyLarge"
            style={{
              color: theme.colors.onSurfaceVariant,
            }}
          >
            {conflictingProducts.length === 1
              ? 'El siguiente producto será reasignado:'
              : `Los siguientes ${conflictingProducts.length} productos serán reasignados:`}
          </Text>
        </View>

        {/* Scrollable Product List */}
        <ScrollView
          style={{
            maxHeight: 250,
            marginTop: 16,
            marginHorizontal: 20,
          }}
          showsVerticalScrollIndicator={true}
        >
          {conflictingProducts.map((product, _index) => (
            <View
              key={product.id}
              style={{
                paddingVertical: 14,
                paddingHorizontal: 16,
                backgroundColor: theme.colors.surfaceVariant,
                borderRadius: 12,
                marginBottom: 8,
                borderLeftWidth: 4,
                borderLeftColor: theme.colors.error,
              }}
            >
              <Text
                variant="bodyLarge"
                style={{
                  fontWeight: '600',
                  color: theme.colors.onSurface,
                  marginBottom: 8,
                }}
              >
                {product.name}
              </Text>
              <View
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor: theme.colors.surface,
                  padding: 8,
                  borderRadius: 8,
                }}
              >
                <View style={{ flex: 1, alignItems: 'center' }}>
                  <Text
                    variant="labelSmall"
                    style={{
                      color: theme.colors.onSurfaceVariant,
                      marginBottom: 2,
                    }}
                  >
                    Desde
                  </Text>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.error,
                      fontWeight: '500',
                    }}
                  >
                    {product.currentScreen}
                  </Text>
                </View>

                <MaterialCommunityIcons
                  name="arrow-right"
                  size={20}
                  color={theme.colors.primary}
                  style={{ marginHorizontal: 8 }}
                />

                <View style={{ flex: 1, alignItems: 'center' }}>
                  <Text
                    variant="labelSmall"
                    style={{
                      color: theme.colors.onSurfaceVariant,
                      marginBottom: 2,
                    }}
                  >
                    Hacia
                  </Text>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '500',
                    }}
                  >
                    {menuData?.screenName || 'Esta pantalla'}
                  </Text>
                </View>
              </View>
            </View>
          ))}
        </ScrollView>

        {/* Info Box */}
        <View
          style={{
            margin: 20,
            marginTop: 16,
            marginBottom: 0,
            padding: 16,
            backgroundColor: theme.colors.secondaryContainer,
            borderRadius: 12,
            flexDirection: 'row',
            alignItems: 'center',
          }}
        >
          <MaterialCommunityIcons
            name="information"
            size={20}
            color={theme.colors.onSecondaryContainer}
            style={{ marginRight: 12 }}
          />
          <Text
            variant="bodySmall"
            style={{
              color: theme.colors.onSecondaryContainer,
              flex: 1,
            }}
          >
            Los productos serán removidos automáticamente de sus pantallas
            actuales al confirmar.
          </Text>
        </View>

        {/* Actions */}
        <View
          style={{
            flexDirection: 'row',
            justifyContent: 'center',
            alignItems: 'center',
            padding: 20,
            paddingTop: 16,
            gap: 16,
            borderTopWidth: 1,
            borderTopColor: theme.colors.surfaceVariant,
            marginTop: 16,
          }}
        >
          <Button
            onPress={handleCancelSave}
            mode="outlined"
            style={{
              flex: 1,
              maxWidth: 150,
              borderColor: theme.colors.outline,
            }}
            contentStyle={{ paddingVertical: 4 }}
          >
            Cancelar
          </Button>
          <Button
            onPress={handleConfirmSave}
            mode="contained"
            buttonColor={theme.colors.error}
            icon="check-circle"
            style={{
              flex: 1,
              maxWidth: 150,
            }}
            contentStyle={{ paddingVertical: 4 }}
          >
            Reasignar
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};

const styles = StyleSheet.create({
  modalContainer: {
    margin: 20,
    padding: 20,
    borderRadius: 8,
    maxHeight: '90%',
  },
  header: {
    marginBottom: 16,
  },
  searchBar: {
    marginBottom: 16,
  },
  scrollView: {
    maxHeight: 400,
  },
  loadingContainer: {
    height: 200,
    justifyContent: 'center',
    alignItems: 'center',
  },
  categoryContainer: {
    marginBottom: 8,
  },
  categoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
  },
  categoryTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  categoryTitle: {
    fontWeight: 'bold',
  },
  subcategoriesContainer: {
    paddingLeft: 20,
  },
  subcategoryContainer: {
    marginBottom: 4,
  },
  subcategoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  subcategoryTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  subcategoryTitle: {
    fontWeight: '600',
  },
  productsContainer: {
    paddingLeft: 20,
  },
  productItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    paddingLeft: 16,
  },
  productInfo: {
    flex: 1,
  },
  warningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 2,
  },
  warningText: {
    marginLeft: 4,
    fontSize: 11,
  },
  divider: {
    marginTop: 8,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
});

================
File: app/src/modules/preparationScreens/hooks/usePreparationScreensQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as preparationScreenService from '../services/preparationScreenService';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  FindAllPreparationScreensDto,
} from '../schema/preparationScreen.schema';
import { BaseListQuery } from '../../../app/types/query.types';
import { PaginatedResponse } from '../../../app/types/api.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

// --- Query Keys ---
const preparationScreensQueryKeys = {
  all: ['preparationScreens'] as const,
  lists: () => [...preparationScreensQueryKeys.all, 'list'] as const,
  list: (filters: FindAllPreparationScreensDto & BaseListQuery) =>
    [...preparationScreensQueryKeys.lists(), filters] as const,
  details: () => [...preparationScreensQueryKeys.all, 'detail'] as const,
  detail: (id: string) =>
    [...preparationScreensQueryKeys.details(), id] as const,
  products: (id: string) =>
    [...preparationScreensQueryKeys.detail(id), 'products'] as const,
  menuWithAssociations: (id: string) =>
    [
      ...preparationScreensQueryKeys.detail(id),
      'menuWithAssociations',
    ] as const,
};

// --- Hooks ---

/**
 * Hook to fetch a paginated list of preparation screens with filters.
 */
export const useGetPreparationScreens = (
  filters: FindAllPreparationScreensDto = {},
  pagination: BaseListQuery = { page: 1, limit: 15 }, // Default limit 15
) => {
  const queryKey = preparationScreensQueryKeys.list({
    ...filters,
    ...pagination,
  });
  return useQuery<PaginatedResponse<PreparationScreen>, Error>({
    queryKey,
    queryFn: () =>
      preparationScreenService.getPreparationScreens(filters, pagination),
    // Considerar placeholderData o initialData si es necesario para UX
  });
};

/**
 * Hook to fetch a single preparation screen by its ID.
 */
export const useGetPreparationScreenById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.detail(id!); // Use non-null assertion as it's enabled conditionally
  return useQuery<PreparationScreen, Error>({
    queryKey,
    queryFn: () => preparationScreenService.getPreparationScreenById(id!),
    enabled: !!id && (options?.enabled ?? true), // Only run query if id is provided and enabled
  });
};

/**
 * Hook for creating a new preparation screen.
 */
export const useCreatePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<PreparationScreen, Error, CreatePreparationScreenDto>({
    mutationFn: preparationScreenService.createPreparationScreen,
    onSuccess: () => {
      // Invalidate list queries to refetch
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      showSnackbar({
        message: 'Pantalla de preparación creada con éxito',
        type: 'success',
      });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};

/**
 * Hook for updating an existing preparation screen.
 */
export const useUpdatePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Contexto para actualización optimista
  type UpdatePreparationScreenContext = { previousDetail?: PreparationScreen };

  return useMutation<
    PreparationScreen,
    Error,
    { id: string; data: UpdatePreparationScreenDto },
    UpdatePreparationScreenContext
  >({
    mutationFn: ({ id, data }) =>
      preparationScreenService.updatePreparationScreen(id, data),

    // --- Inicio Actualización Optimista ---
    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = preparationScreensQueryKeys.detail(id);

      // 1. Cancelar query de detalle
      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      // 2. Guardar estado anterior del detalle
      const previousDetail =
        queryClient.getQueryData<PreparationScreen>(detailQueryKey);

      // 3. Actualizar caché de detalle optimistamente
      if (previousDetail) {
        // Fusionar datos antiguos y nuevos. Asumiendo que UpdatePreparationScreenDto no tiene estructuras anidadas problemáticas.
        queryClient.setQueryData<PreparationScreen>(detailQueryKey, (old) =>
          old ? { ...old, ...data } : undefined,
        );
      }

      // 4. Retornar contexto
      return { previousDetail };
    },
    // --- Fin Actualización Optimista ---

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al actualizar pantalla de preparación

      // Revertir caché de detalle
      if (context?.previousDetail) {
        queryClient.setQueryData(
          preparationScreensQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables) => {
      // Invalidar listas y detalle para consistencia final
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.detail(variables.id),
      });

      // Mostrar snackbar de éxito solo si no hubo error
      if (!error && data) {
        showSnackbar({
          message: 'Pantalla de preparación actualizada con éxito',
          type: 'success',
        });
      }
    },
  });
};

/**
 * Hook for deleting a preparation screen.
 */
export const useDeletePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Contexto para guardar el detalle eliminado
  type DeletePreparationScreenContext = { previousDetail?: PreparationScreen };

  return useMutation<void, Error, string, DeletePreparationScreenContext>({
    mutationFn: preparationScreenService.deletePreparationScreen,

    // --- Inicio Actualización Optimista ---
    onMutate: async (deletedId) => {
      const detailQueryKey = preparationScreensQueryKeys.detail(deletedId);

      // 1. Cancelar query de detalle
      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      // 2. Guardar estado anterior del detalle
      const previousDetail =
        queryClient.getQueryData<PreparationScreen>(detailQueryKey);

      // 3. Eliminar optimistamente de la caché de detalle
      queryClient.removeQueries({ queryKey: detailQueryKey });

      // 4. Retornar contexto
      return { previousDetail };
    },
    // --- Fin Actualización Optimista ---

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      // Revertir caché de detalle si hubo error
      if (context?.previousDetail) {
        queryClient.setQueryData(
          preparationScreensQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_, error, deletedId) => {
      // Invalidar listas para asegurar consistencia final
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });

      // Asegurar remoción en éxito y mostrar snackbar
      if (!error) {
        queryClient.removeQueries({
          queryKey: preparationScreensQueryKeys.detail(deletedId),
        });
        showSnackbar({
          message: 'Pantalla de preparación eliminada con éxito',
          type: 'success',
        });
      }
    },
  });
};

/**
 * Hook to fetch products associated with a preparation screen.
 */
export const useGetPreparationScreenProducts = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.products(id!);
  return useQuery<any[], Error>({
    queryKey,
    queryFn: () => preparationScreenService.getPreparationScreenProducts(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

/**
 * Hook to fetch menu with associations for a preparation screen.
 */
export const useGetMenuWithAssociations = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.menuWithAssociations(id!);
  return useQuery<any, Error>({
    queryKey,
    queryFn: () => preparationScreenService.getMenuWithAssociations(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

/**
 * Hook for associating products with a preparation screen.
 */
export const useAssociateProducts = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<
    PreparationScreen,
    Error,
    { id: string; productIds: string[] }
  >({
    mutationFn: ({ id, productIds }) =>
      preparationScreenService.associateProducts(id, productIds),
    onSuccess: (_, variables) => {
      // Invalidate related queries
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.detail(variables.id),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.products(variables.id),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.menuWithAssociations(
          variables.id,
        ),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });

      showSnackbar({
        message: 'Productos asociados con éxito',
        type: 'success',
      });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};

================
File: app/src/modules/printers/hooks/usePrintersQueries.ts
================
import {
  useMutation,
  UseMutationResult,
  useQuery,
  UseQueryResult,
  useQueryClient,
} from '@tanstack/react-query';
import { printerService } from '../services/printerService';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
  FindAllThermalPrintersDto,
} from '../types/printer.types';
import { ApiError } from '../../../app/lib/errors';
import { PaginatedResponse } from '../../../app/types/api.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

// --- Query Keys ---
const printerKeys = {
  all: ['thermalPrinters'] as const,
  lists: () => [...printerKeys.all, 'list'] as const,
  list: (filters: FindAllThermalPrintersDto) =>
    [...printerKeys.lists(), filters] as const,
  details: () => [...printerKeys.all, 'detail'] as const,
  detail: (id: string) => [...printerKeys.details(), id] as const,
  discover: ['discoverPrinters'] as const, // Clave para descubrimiento
};

/**
 * Hook para disparar el descubrimiento de impresoras.
 * Utiliza useMutation ya que es una acción iniciada por el usuario.
 */
export const useDiscoverPrinters = (): UseMutationResult<
  DiscoveredPrinter[], // Tipo de dato que devuelve la mutación en caso de éxito
  ApiError, // Tipo de error esperado
  number | undefined // Tipo del argumento que recibe la función mutate (duration o undefined)
> => {
  // No necesita invalidar caché, es una acción puntual
  return useMutation<DiscoveredPrinter[], ApiError, number | undefined>({
    mutationFn: (duration: number | undefined) =>
      printerService.discoverPrinters(duration),
    // Opcional: manejo de errores/éxito específico para descubrimiento si es necesario
  });
};

/**
 * Hook para obtener la lista paginada de impresoras registradas.
 */
export const usePrintersQuery = (
  // Proporcionar valores por defecto para page y limit si params está vacío
  params: FindAllThermalPrintersDto = { page: 1, limit: 10 },
  options?: { enabled?: boolean },
): UseQueryResult<PaginatedResponse<ThermalPrinter>, ApiError> => {
  const queryKey = printerKeys.list(params);
  return useQuery<PaginatedResponse<ThermalPrinter>, ApiError>({
    queryKey: queryKey,
    queryFn: () => printerService.findAllPrinters(params),
    enabled: options?.enabled ?? true,
  });
};

/**
 * Hook para obtener los detalles de una impresora registrada por ID.
 */
export const usePrinterQuery = (
  id: string | undefined,
  options?: { enabled?: boolean },
): UseQueryResult<ThermalPrinter, ApiError> => {
  const queryKey = printerKeys.detail(id!);
  return useQuery<ThermalPrinter, ApiError>({
    queryKey: queryKey,
    queryFn: () => printerService.findOnePrinter(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

/**
 * Hook para crear una nueva impresora registrada.
 */
export const useCreatePrinterMutation = (): UseMutationResult<
  ThermalPrinter,
  ApiError,
  CreateThermalPrinterDto
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<ThermalPrinter, ApiError, CreateThermalPrinterDto>({
    mutationFn: printerService.createPrinter,
    onSuccess: (newPrinter) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      showSnackbar({
        message: `Impresora "${newPrinter.name}" creada con éxito`,
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: getApiErrorMessage(error),
        type: 'error',
      });
    },
  });
};

/**
 * Hook para actualizar una impresora registrada existente.
 */
export const useUpdatePrinterMutation = (): UseMutationResult<
  ThermalPrinter,
  ApiError,
  { id: string; data: UpdateThermalPrinterDto }
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<
    ThermalPrinter,
    ApiError,
    { id: string; data: UpdateThermalPrinterDto }
  >({
    mutationFn: ({ id, data }) => printerService.updatePrinter(id, data),
    onSuccess: (updatedPrinter, variables) => {
      // Invalidar lista y detalle específico
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: printerKeys.detail(variables.id),
      });
      // Opcional: Actualizar caché directamente si se desea optimización
      // queryClient.setQueryData(printerKeys.detail(variables.id), updatedPrinter);
      showSnackbar({
        message: `Impresora "${updatedPrinter.name}" actualizada`,
        type: 'success',
      });
    },
    onError: (error, _variables) => {
      showSnackbar({
        message: getApiErrorMessage(error),
        type: 'error',
      });
    },
  });
};

/**
 * Hook para eliminar (soft delete) una impresora registrada.
 */
export const useDeletePrinterMutation = (): UseMutationResult<
  void,
  ApiError,
  string // ID de la impresora a eliminar
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<void, ApiError, string>({
    mutationFn: printerService.deletePrinter,
    onSuccess: (_, deletedId) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      // Opcional: Remover de la caché de detalle
      queryClient.removeQueries({ queryKey: printerKeys.detail(deletedId) });
      showSnackbar({ message: 'Impresora eliminada', type: 'success' });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al eliminar impresora: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook para realizar un ping a una impresora.
 */
export const usePingPrinterMutation = (): UseMutationResult<
  { status: string }, // Tipo de dato que devuelve la mutación en caso de éxito
  ApiError, // Tipo de error esperado
  string // Tipo del argumento que recibe la función mutate (printer ID)
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<{ status: string }, ApiError, string>({
    mutationFn: (printerId: string) => printerService.pingPrinter(printerId),
    onSuccess: (data, _printerId) => {
      const message =
        data.status === 'online'
          ? `Impresora conectada (ping exitoso).`
          : `Impresora desconectada (ping fallido).`;
      const type = data.status === 'online' ? 'success' : 'warning';
      showSnackbar({ message, type });
    },
    onError: (error, _printerId) => {
      showSnackbar({
        message: `Error al hacer ping a la impresora: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
      // Error al hacer ping a la impresora
    },
  });
};

/**
 * Hook para imprimir un ticket de prueba en una impresora descubierta.
 */
export const useTestPrintDiscoveredPrinter = (): UseMutationResult<
  { success: boolean; message?: string },
  ApiError,
  DiscoveredPrinter
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<
    { success: boolean; message?: string },
    ApiError,
    DiscoveredPrinter
  >({
    mutationFn: (printer: DiscoveredPrinter) =>
      printerService.testPrintDiscoveredPrinter(printer),
    onSuccess: (data) => {
      showSnackbar({
        message: data.message || 'Ticket de prueba impreso correctamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al imprimir ticket de prueba: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
      // Error al imprimir ticket de prueba
    },
  });
};

/**
 * Hook para imprimir un ticket de prueba en una impresora configurada.
 */
export const useTestPrintPrinter = (): UseMutationResult<
  { success: boolean; message?: string },
  ApiError,
  string
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<{ success: boolean; message?: string }, ApiError, string>({
    mutationFn: (printerId: string) =>
      printerService.testPrintPrinter(printerId),
    onSuccess: (data) => {
      showSnackbar({
        message: data.message || 'Ticket de prueba impreso correctamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al imprimir ticket de prueba: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
      // Error al imprimir ticket de prueba
    },
  });
};

================
File: app/src/modules/printers/services/printerService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { handleApiError } from '../../../app/lib/apiResponseHelper';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
  FindAllThermalPrintersDto,
} from '../types/printer.types';
import {
  PaginatedResponse,
  BaseListQueryDto,
} from '../../../app/types/api.types';

type PrinterFilterParams = Omit<
  FindAllThermalPrintersDto,
  keyof BaseListQueryDto
>;

const discoverPrinters = async (
  duration: number = 10000,
): Promise<DiscoveredPrinter[]> => {
  const response = await ApiClientWrapper.get<DiscoveredPrinter[]>(
    API_PATHS.THERMAL_PRINTERS_DISCOVER,
    { duration },
  );

  if (!response.ok || !response.data) {
    handleApiError(response);
  }

  return response.data;
};

const findAllPrinters = async (
  filters: PrinterFilterParams = {},
  pagination: BaseListQueryDto = { page: 1, limit: 10 },
): Promise<PaginatedResponse<ThermalPrinter>> => {
  const queryParams = Object.entries({ ...filters, ...pagination }).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) {
        if (key === 'isActive' && typeof value === 'boolean') {
          acc[key] = String(value);
        } else {
          acc[key] = value;
        }
      }
      return acc;
    },
    {} as Record<string, any>,
  );

  type FindAllPrintersApiResponse = {
    items: ThermalPrinter[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };

  const response = await ApiClientWrapper.get<FindAllPrintersApiResponse>(
    API_PATHS.THERMAL_PRINTERS,
    queryParams,
  );

  if (
    !response.ok ||
    !response.data ||
    typeof response.data !== 'object' ||
    !Array.isArray(response.data.items)
  ) {
    handleApiError(response);
  }

  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};

const findOnePrinter = async (id: string): Promise<ThermalPrinter> => {
  const response = await ApiClientWrapper.get<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
  );
  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

const createPrinter = async (
  data: CreateThermalPrinterDto,
): Promise<ThermalPrinter> => {
  const response = await ApiClientWrapper.post<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS,
    data,
  );
  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

const updatePrinter = async (
  id: string,
  data: UpdateThermalPrinterDto,
): Promise<ThermalPrinter> => {
  const response = await ApiClientWrapper.patch<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
    data,
  );
  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

const deletePrinter = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    handleApiError(response);
  }
};

const pingPrinter = async (id: string): Promise<{ status: string }> => {
  const response = await ApiClientWrapper.get<{ status: string }>(
    API_PATHS.THERMAL_PRINTERS_PING.replace(':id', id),
  );

  if (
    !response.ok ||
    !response.data ||
    typeof response.data.status !== 'string'
  ) {
    handleApiError(response);
  }
  return response.data;
};

const testPrintDiscoveredPrinter = async (
  printer: DiscoveredPrinter,
): Promise<{ success: boolean; message?: string }> => {
  const response = await ApiClientWrapper.post<{
    success: boolean;
    message?: string;
  }>(API_PATHS.THERMAL_PRINTERS_TEST_PRINT, {
    ip: printer.ip,
    port: printer.port,
    connectionType: 'NETWORK',
  });

  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

const testPrintPrinter = async (
  id: string,
): Promise<{ success: boolean; message?: string }> => {
  // Primero obtener la información de la impresora
  const printer = await findOnePrinter(id);

  // Preparar los datos según el tipo de conexión
  const printerInfo: any = {
    connectionType: printer.connectionType,
  };

  if (printer.connectionType === 'NETWORK') {
    printerInfo.ip = printer.ipAddress;
    printerInfo.port = printer.port;
  } else {
    // Para otros tipos de conexión, usar la ruta
    printerInfo.path = printer.path;
  }

  const response = await ApiClientWrapper.post<{
    success: boolean;
    message?: string;
  }>(API_PATHS.THERMAL_PRINTERS_TEST_PRINT, printerInfo);

  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

export const printerService = {
  discoverPrinters,
  findAllPrinters,
  findOnePrinter,
  createPrinter,
  updatePrinter,
  deletePrinter,
  pingPrinter,
  testPrintDiscoveredPrinter,
  testPrintPrinter,
};

================
File: app/src/modules/receipts/components/ReceiptDetailsModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Surface,
  Text,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
} from 'react-native-paper';
import { Receipt } from '../types/receipt.types';
import { useAppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import OrderHistoryModal from '@/modules/shared/components/OrderHistoryModal';

interface ReceiptDetailsModalProps {
  visible: boolean;
  onDismiss: () => void;
  receipt: Receipt | null;
  isLoading?: boolean;
}

const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';

  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalf.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalf.HALF_2
            ? 'HALF_2'
            : 'FULL';

      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }

      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;

      if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationType.INGREDIENT
      ) {
        if (curr.action === CustomizationAction.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }

      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );

  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };

    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';

    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }

  return '';
};

export const ReceiptDetailsModal: React.FC<ReceiptDetailsModalProps> = ({
  visible,
  onDismiss,
  receipt,
  isLoading = false,
}) => {
  const theme = useAppTheme();
  const [showPrintHistory, setShowPrintHistory] = useState(false);
  const [showOrderHistory, setShowOrderHistory] = useState(false);

  if (!receipt && !isLoading) return null;

  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return '🍽️ Local';
      case 'TAKE_AWAY':
        return '🥡 Llevar';
      case 'DELIVERY':
        return '🚚 Envío';
      default:
        return type;
    }
  };

  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparación';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      case 'COMPLETED':
        return 'Completado';
      case 'CANCELLED':
        return 'Cancelado';
      default:
        return status;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0';
      case 'COMPLETED':
        return '#10B981';
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getPaymentStatus = () => {
    if (receipt?.payments && receipt.payments.length > 0) {
      const totalPaid = receipt.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof receipt.total === 'string'
          ? parseFloat(receipt.total)
          : receipt.total || 0;

      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };

  if (isLoading || !receipt) {
    return (
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        title="Cargando..."
      >
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text
            style={[
              styles.loadingText,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Cargando detalles del recibo...
          </Text>
        </View>
      </ResponsiveModal>
    );
  }

  const paymentStatus = getPaymentStatus();

  const headerActions = (
    <IconButton
      icon="history"
      size={24}
      onPress={() => setShowOrderHistory(true)}
      style={styles.historyButton}
    />
  );

  const modalTitle = `Recibo #${receipt?.shiftOrderNumber || ''} · ${getOrderTypeLabel(receipt?.orderType || '')}`;

  const footerContent = (
    <View style={styles.footer}>
      <View style={styles.footerLeft}>
        <Text
          style={[styles.totalLabel, { color: theme.colors.onSurfaceVariant }]}
        >
          Total:
        </Text>
        <Text style={[styles.totalAmount, { color: theme.colors.primary }]}>
          $
          {receipt
            ? typeof receipt.total === 'string'
              ? parseFloat(receipt.total).toFixed(2)
              : (receipt.total || 0).toFixed(2)
            : '0.00'}
        </Text>
      </View>
      <View
        style={[styles.paymentBadge, { backgroundColor: paymentStatus.color }]}
      >
        <Text style={styles.paymentBadgeText}>💵 {paymentStatus.label}</Text>
      </View>
    </View>
  );

  const renderItem = (item: any) => {
    const quantity = item.quantity || 1;
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;

    return (
      <Surface
        key={`${item.id}`}
        style={[
          styles.itemCard,
          { backgroundColor: theme.colors.elevation.level1, marginBottom: 8 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}

            {item.productModifiers && item.productModifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.productModifiers.map((modifier: any) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      • {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}

            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📝 {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {item.quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total ×{item.quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };

  return (
    <>
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        title={modalTitle}
        headerActions={headerActions}
        maxHeightTablet="90%"
        scrollable={true}
        footer={footerContent}
        footerStyle={{ paddingTop: 0 }}
      >
        {/* Header info con status y fechas */}
        <View style={styles.headerInfo}>
          <View style={styles.chipsRow}>
            <View
              style={[
                styles.headerStatusChip,
                {
                  backgroundColor: getStatusColor(receipt.orderStatus),
                },
              ]}
            >
              <Text style={styles.headerStatusChipText}>
                {getOrderStatusLabel(receipt.orderStatus)}
              </Text>
            </View>
            {receipt.preparationScreens &&
              receipt.preparationScreens.map((screen, index) => (
                <Chip
                  key={index}
                  mode="outlined"
                  compact
                  style={styles.screenChip}
                  textStyle={styles.screenChipText}
                >
                  🍳 {screen}
                </Chip>
              ))}
          </View>
          <View style={styles.headerDatesRow}>
            <Text
              style={[
                styles.headerDate,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Creado:{' '}
              {receipt.createdAt
                ? format(new Date(receipt.createdAt), 'dd/MM/yyyy HH:mm', {
                    locale: es,
                  })
                : ''}
            </Text>
            {receipt.finalizedAt && (
              <Text
                style={[styles.headerDate, { color: theme.colors.primary }]}
              >
                Finalizado:{' '}
                {format(new Date(receipt.finalizedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            )}
          </View>
        </View>

        {/* Información del recibo */}
        <View style={styles.infoSection}>
          {receipt.deliveryInfo?.recipientName && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                👤 Nombre del Cliente: {receipt.deliveryInfo.recipientName}
              </Text>
            </View>
          )}

          {receipt.deliveryInfo?.recipientPhone && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                📞 Teléfono: {receipt.deliveryInfo.recipientPhone}
              </Text>
            </View>
          )}

          {receipt.orderType === 'DELIVERY' &&
            receipt.deliveryInfo?.fullAddress && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.addressText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📦 Dirección de Entrega: {receipt.deliveryInfo.fullAddress}
                </Text>
              </View>
            )}

          {receipt.orderType === 'DINE_IN' && receipt.table && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.tableText, { color: theme.colors.onSurface }]}
              >
                🏛️ Mesa: {receipt.table.area?.name || 'Sin área'} -{' '}
                {receipt.table.number}
              </Text>
            </View>
          )}

          {receipt.scheduledAt && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.primary, fontWeight: '600' },
                ]}
              >
                ⏰ Hora de Entrega Programada:{' '}
                {format(new Date(receipt.scheduledAt), 'HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          )}

          {receipt.user && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                👨‍💼 Atendido por: {receipt.user.firstName}{' '}
                {receipt.user.lastName}
              </Text>
            </View>
          )}

          {receipt.notes && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.notesText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                📋 Notas: {receipt.notes}
              </Text>
            </View>
          )}
        </View>

        <Divider style={styles.divider} />

        {/* Lista de productos */}
        <View style={styles.itemsList}>
          {receipt.orderItems?.map((item) => renderItem(item)) || []}
        </View>

        <Divider style={styles.divider} />

        {/* Pagos */}
        {receipt.payments && receipt.payments.length > 0 && (
          <>
            <View style={styles.paymentsSection}>
              <View style={styles.paymentSummaryCompact}>
                <View style={styles.summaryCompactRow}>
                  <Text
                    style={[
                      styles.summaryCompactLabel,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    Total: $
                    {typeof receipt.total === 'string'
                      ? parseFloat(receipt.total).toFixed(2)
                      : (receipt.total || 0).toFixed(2)}
                  </Text>
                  <Text
                    style={[styles.summaryCompactLabel, { color: '#10B981' }]}
                  >
                    Pagado: $
                    {receipt.payments
                      .reduce((sum, p) => sum + p.amount, 0)
                      .toFixed(2)}
                  </Text>
                  {(() => {
                    const totalAmount =
                      typeof receipt.total === 'string'
                        ? parseFloat(receipt.total)
                        : receipt.total || 0;
                    const totalPaid = receipt.payments.reduce(
                      (sum, p) => sum + p.amount,
                      0,
                    );
                    const remaining = totalAmount - totalPaid;
                    if (remaining > 0) {
                      return (
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            {
                              color: theme.colors.error,
                              fontWeight: '600',
                            },
                          ]}
                        >
                          Resta: ${remaining.toFixed(2)}
                        </Text>
                      );
                    }
                    return null;
                  })()}
                </View>
              </View>

              {receipt.payments.map((payment, index) => {
                const getPaymentMethodLabel = (method: string) => {
                  switch (method) {
                    case 'CASH':
                    case 'cash':
                      return 'Efectivo';
                    case 'CREDIT_CARD':
                    case 'card':
                      return 'Tarjeta de Crédito';
                    case 'DEBIT_CARD':
                      return 'Tarjeta de Débito';
                    case 'TRANSFER':
                    case 'transfer':
                      return 'Transferencia';
                    case 'OTHER':
                      return 'Otro';
                    default:
                      return method;
                  }
                };

                const getPaymentStatusColor = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return '#10B981';
                    case 'PENDING':
                      return '#F59E0B';
                    case 'FAILED':
                      return theme.colors.error;
                    case 'REFUNDED':
                      return '#6B7280';
                    case 'CANCELLED':
                      return theme.colors.error;
                    default:
                      return theme.colors.onSurfaceVariant;
                  }
                };

                const getPaymentStatusLabel = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return 'Completado';
                    case 'PENDING':
                      return 'Pendiente';
                    case 'FAILED':
                      return 'Fallido';
                    case 'REFUNDED':
                      return 'Reembolsado';
                    case 'CANCELLED':
                      return 'Cancelado';
                    default:
                      return status;
                  }
                };

                return (
                  <View
                    key={payment.id || index}
                    style={styles.paymentRowCompact}
                  >
                    <Text
                      style={[
                        styles.paymentMethodCompact,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      💳 {getPaymentMethodLabel(payment.paymentMethod)}
                    </Text>
                    <Text
                      style={[
                        styles.paymentDateCompact,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {format(new Date(payment.createdAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                    <View
                      style={[
                        styles.paymentStatusBadgeCompact,
                        {
                          backgroundColor:
                            getPaymentStatusColor(payment.paymentStatus) + '20',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.paymentStatusTextCompact,
                          {
                            color: getPaymentStatusColor(payment.paymentStatus),
                          },
                        ]}
                      >
                        {getPaymentStatusLabel(payment.paymentStatus)}
                      </Text>
                    </View>
                    <Text
                      style={[
                        styles.paymentAmountCompact,
                        { color: theme.colors.primary },
                      ]}
                    >
                      ${payment.amount.toFixed(2)}
                    </Text>
                  </View>
                );
              })}
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {/* Historial de impresiones */}
        {receipt.ticketImpressions && receipt.ticketImpressions.length > 0 && (
          <>
            <View style={styles.ticketImpressionsSection}>
              <TouchableOpacity
                style={styles.collapsibleHeader}
                onPress={() => setShowPrintHistory(!showPrintHistory)}
                activeOpacity={0.7}
              >
                <Text
                  style={[styles.sectionTitle, { color: theme.colors.primary }]}
                >
                  🖨️ Historial de Impresiones (
                  {receipt.ticketImpressions.length})
                </Text>
                <IconButton
                  icon={showPrintHistory ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  style={styles.collapseIcon}
                />
              </TouchableOpacity>

              {showPrintHistory && (
                <View style={styles.collapsibleContent}>
                  {receipt.ticketImpressions.map((impression, index) => {
                    const getTicketTypeLabel = (type: string) => {
                      switch (type) {
                        case 'KITCHEN':
                          return '🍳 Cocina';
                        case 'BAR':
                          return '🍺 Barra';
                        case 'BILLING':
                          return '💵 Cuenta';
                        case 'CUSTOMER_COPY':
                          return '📄 Copia Cliente';
                        case 'GENERAL':
                          return '📋 General';
                        default:
                          return type;
                      }
                    };

                    return (
                      <View
                        key={impression.id || index}
                        style={styles.impressionRow}
                      >
                        <View style={styles.impressionLeft}>
                          <Text
                            style={[
                              styles.impressionType,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            {getTicketTypeLabel(impression.ticketType)}
                          </Text>
                          <View style={styles.impressionDetails}>
                            {impression.user && (
                              <Text
                                style={[
                                  styles.impressionUser,
                                  {
                                    color: theme.colors.onSurfaceVariant,
                                  },
                                ]}
                              >
                                por {impression.user.firstName || ''}{' '}
                                {impression.user.lastName || ''}
                              </Text>
                            )}
                            {impression.printer && (
                              <Text
                                style={[
                                  styles.impressionPrinter,
                                  {
                                    color: theme.colors.onSurfaceVariant,
                                  },
                                ]}
                              >
                                🖨️ {impression.printer.name}
                              </Text>
                            )}
                          </View>
                        </View>
                        <Text
                          style={[
                            styles.impressionTime,
                            {
                              color: theme.colors.onSurfaceVariant,
                            },
                          ]}
                        >
                          {format(
                            new Date(impression.impressionTime),
                            'HH:mm:ss',
                            { locale: es },
                          )}
                        </Text>
                      </View>
                    );
                  })}
                </View>
              )}
            </View>
          </>
        )}
      </ResponsiveModal>

      {/* Modal de historial */}
      {receipt && (
        <OrderHistoryModal
          visible={showOrderHistory}
          onDismiss={() => setShowOrderHistory(false)}
          orderId={receipt.id}
        />
      )}
    </>
  );
};

const styles = StyleSheet.create({
  loadingContainer: {
    minHeight: 200,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 14,
  },
  historyButton: {
    margin: -8,
  },
  headerInfo: {
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0,0,0,0.08)',
    marginBottom: 16,
  },
  chipsRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    flexWrap: 'wrap',
    marginBottom: 8,
  },
  headerStatusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  headerStatusChipText: {
    color: 'white',
    fontSize: 11,
    fontWeight: '600',
  },
  screenChip: {
    height: 20,
  },
  screenChipText: {
    fontSize: 10,
    marginVertical: -2,
  },
  headerDatesRow: {
    gap: 8,
  },
  headerDate: {
    fontSize: 11,
  },
  infoSection: {
    gap: 4,
    marginBottom: 16,
  },
  infoRow: {
    marginVertical: 2,
  },
  contactText: {
    fontSize: 12,
  },
  addressText: {
    fontSize: 12,
    lineHeight: 16,
  },
  tableText: {
    fontSize: 12,
  },
  divider: {
    marginVertical: 2,
  },
  itemsList: {
    marginBottom: 16,
  },
  itemCard: {
    borderRadius: 8,
    overflow: 'hidden',
  },
  itemContent: {
    padding: 10,
  },
  itemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  nameContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  itemQuantity: {
    fontSize: 14,
    fontWeight: '700',
    marginRight: 6,
  },
  itemName: {
    fontSize: 13,
    fontWeight: '600',
    flex: 1,
    lineHeight: 16,
  },
  statusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusChipText: {
    color: 'white',
    fontSize: 10,
    fontWeight: '600',
  },
  itemDetailsContainer: {
    marginBottom: 6,
  },
  customizationContainer: {
    marginBottom: 4,
  },
  pizzaCustomizationText: {
    fontSize: 11,
    fontStyle: 'italic',
    lineHeight: 14,
  },
  modifiersContainer: {
    marginTop: 2,
  },
  modifierRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 1,
  },
  modifierText: {
    fontSize: 11,
    flex: 1,
    lineHeight: 14,
  },
  modifierPrice: {
    fontSize: 11,
    fontWeight: '500',
    marginLeft: 4,
  },
  notesContainer: {
    marginTop: 4,
    paddingTop: 4,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  notesText: {
    fontSize: 11,
    fontStyle: 'italic',
    lineHeight: 14,
  },
  priceContainer: {
    marginTop: 6,
    paddingTop: 6,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  priceLabel: {
    fontSize: 11,
    opacity: 0.7,
  },
  priceValue: {
    fontSize: 12,
    fontWeight: '600',
  },
  totalPrice: {
    fontSize: 14,
    fontWeight: '700',
  },
  paymentsSection: {
    marginBottom: 16,
  },
  paymentSummaryCompact: {
    marginBottom: 8,
  },
  summaryCompactRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  summaryCompactLabel: {
    fontSize: 12,
    fontWeight: '500',
  },
  paymentRowCompact: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
    gap: 8,
  },
  paymentMethodCompact: {
    fontSize: 11,
    fontWeight: '500',
    flex: 1,
  },
  paymentDateCompact: {
    fontSize: 10,
  },
  paymentAmountCompact: {
    fontSize: 12,
    fontWeight: '600',
    minWidth: 50,
    textAlign: 'right',
  },
  paymentStatusBadgeCompact: {
    paddingHorizontal: 6,
    paddingVertical: 1,
    borderRadius: 10,
  },
  paymentStatusTextCompact: {
    fontSize: 9,
    fontWeight: '600',
  },
  ticketImpressionsSection: {
    marginBottom: 16,
  },
  collapsibleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingRight: 4,
  },
  collapseIcon: {
    margin: -8,
  },
  collapsibleContent: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 0,
  },
  impressionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
    paddingLeft: 8,
  },
  impressionLeft: {
    flex: 1,
    gap: 2,
  },
  impressionType: {
    fontSize: 12,
    fontWeight: '500',
  },
  impressionDetails: {
    gap: 2,
  },
  impressionUser: {
    fontSize: 11,
    opacity: 0.7,
  },
  impressionPrinter: {
    fontSize: 11,
    opacity: 0.7,
    fontStyle: 'italic',
  },
  impressionTime: {
    fontSize: 11,
    opacity: 0.7,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    // ResponsiveModal maneja padding y border
  },
  footerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  totalLabel: {
    fontSize: 14,
    fontWeight: '600',
  },
  totalAmount: {
    fontSize: 16,
    fontWeight: '700',
  },
  paymentBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  paymentBadgeText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
});

================
File: app/src/modules/restaurantConfig/types/restaurantConfig.types.ts
================
export interface DeliveryCoveragePoint {
  lat: number;
  lng: number;
}

export interface BusinessHours {
  id: string;
  dayOfWeek: number; // 0 = Domingo, 1 = Lunes, ... 6 = Sábado
  openingTime: string | null; // HH:mm
  closingTime: string | null; // HH:mm
  closesNextDay?: boolean; // true si cierra después de medianoche
  isClosed: boolean;
  restaurantConfigId: string;
  createdAt: string;
  updatedAt: string;
}

export interface RestaurantConfig {
  id: string;
  // Información básica
  restaurantName: string;
  phoneMain: string | null;
  phoneSecondary: string | null;
  address: string | null;
  city: string | null;
  state: string | null;
  postalCode: string | null;
  country: string | null;

  // Configuración de operación
  acceptingOrders: boolean;
  estimatedPickupTime: number;
  estimatedDeliveryTime: number;
  estimatedDineInTime: number;
  openingGracePeriod: number;
  closingGracePeriod: number;
  timeZone: string;
  scheduledOrdersLeadTime: number;

  // Configuración de delivery
  deliveryCoverageArea: DeliveryCoveragePoint[] | null;
  minimumOrderValueForDelivery: number | string; // Puede venir como string desde el backend (decimal)

  // Relaciones
  businessHours: BusinessHours[];

  createdAt: string;
  updatedAt: string;
}

export interface UpdateRestaurantConfigDto {
  // Información básica
  restaurantName?: string;
  phoneMain?: string | null;
  phoneSecondary?: string | null;
  address?: string | null;
  city?: string | null;
  state?: string | null;
  postalCode?: string | null;
  country?: string | null;

  // Configuración de operación
  acceptingOrders?: boolean;
  estimatedPickupTime?: number;
  estimatedDeliveryTime?: number;
  estimatedDineInTime?: number;
  openingGracePeriod?: number;
  closingGracePeriod?: number;
  timeZone?: string;
  scheduledOrdersLeadTime?: number;

  // Configuración de delivery
  deliveryCoverageArea?: DeliveryCoveragePoint[] | null;
  minimumOrderValueForDelivery?: number;

  // Horarios
  businessHours?: CreateBusinessHoursDto[];
}

export interface CreateBusinessHoursDto {
  dayOfWeek: number;
  openingTime?: string | null;
  closingTime?: string | null;
  closesNextDay?: boolean;
  isClosed?: boolean;
  restaurantConfigId?: string;
}

export interface UpdateBusinessHoursDto {
  openingTime?: string | null;
  closingTime?: string | null;
  closesNextDay?: boolean;
  isClosed?: boolean;
}

================
File: app/src/modules/shiftAudit/components/OrderHistoryView.tsx
================
import React, { useMemo, useState } from 'react';
import {
  View,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
} from 'react-native';
import {
  Text,
  Divider,
  Chip,
  Button,
  Avatar,
  Surface,
  Appbar,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

interface HistoryItem {
  id: string | number;
  orderId: string;
  orderItemId?: string;
  operation: 'INSERT' | 'UPDATE' | 'DELETE' | 'BATCH';
  changedBy: string;
  changedAt: string;
  diff?: Record<string, any> | null;
  snapshot?: Record<string, any>;
  productId?: string;
  preparationStatus?: string;
  changedByUser?: {
    id?: string;
    firstName: string;
    lastName: string;
  };
  user?: {
    firstName: string;
    lastName: string;
  };
  itemDescription?: string;
  formattedChanges?: Record<string, any>;
  batchOperations?: any[];
  type: 'order' | 'item';
}

interface OrderHistoryViewProps {
  orderId: string | null;
  orderNumber?: number;
  onBack: () => void;
}

// Helper para obtener el icono de la operación
const getOperationIcon = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    return 'receipt';
  }
  switch (operation) {
    case 'INSERT':
      return 'plus-circle';
    case 'UPDATE':
      return 'pencil';
    case 'DELETE':
      return 'delete';
    case 'BATCH':
      return 'folder-multiple';
    default:
      return 'information';
  }
};

// Helper para obtener el label de la operación
const getOperationLabel = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    const orderOperationMap: Record<string, string> = {
      INSERT: 'Orden creada',
      UPDATE: 'Orden modificada',
      DELETE: 'Orden eliminada',
    };
    return orderOperationMap[operation] || operation;
  }

  const operationMap: Record<string, string> = {
    INSERT: 'Item agregado',
    UPDATE: 'Item modificado',
    DELETE: 'Item eliminado',
    BATCH: 'Cambios múltiples',
  };
  return operationMap[operation] || operation;
};

// Helper para obtener color del estado
const getStatusColor = (
  status: string,
  theme: ReturnType<typeof useAppTheme>,
) => {
  const statusColors: Record<string, string> = {
    PENDING: theme.colors.onSurfaceDisabled,
    IN_PROGRESS: theme.colors.warning || '#FFA500',
    READY: theme.colors.success || '#4CAF50',
    CANCELLED: theme.colors.error,
  };
  return statusColors[status] || theme.colors.onSurfaceDisabled;
};

// Helper para formatear nombres de campos
const formatFieldName = (field: string): string => {
  const fieldMap: Record<string, string> = {
    orderStatus: 'Estado de la orden',
    orderType: 'Tipo de orden',
    tableId: 'Mesa',
    table: 'Mesa',
    notes: 'Notas',
    deliveryInfo: 'Información de entrega',
    customerName: 'Nombre del cliente',
    customerPhone: 'Teléfono del cliente',
    recipientName: 'Nombre del destinatario',
    recipientPhone: 'Teléfono del destinatario',
    deliveryAddress: 'Dirección de entrega',
    fullAddress: 'Dirección',
    estimatedDeliveryTime: 'Tiempo estimado de entrega',
    preparationStatus: 'Estado de preparación',
    preparationNotes: 'Notas de preparación',
    customerId: 'Cliente',
    scheduledAt: 'Fecha programada',
    total: 'Total',
    subtotal: 'Subtotal',
    finalizedAt: 'Finalizado',
  };
  return fieldMap[field] || field;
};

// Helper para formatear valores
const formatValue = (field: string, value: any): string => {
  if (value === null || value === undefined) {
    return 'No especificado';
  }

  if (field === 'orderStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Progreso',
      COMPLETED: 'Completada',
      CANCELLED: 'Cancelada',
      DELIVERED: 'Entregada',
    };
    return statusMap[value] || value;
  }

  if (field === 'orderType') {
    const typeMap: Record<string, string> = {
      DINE_IN: 'Para Comer Aquí',
      TAKE_AWAY: 'Para Llevar',
      DELIVERY: 'Domicilio',
    };
    return typeMap[value] || value;
  }

  if (field === 'preparationStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Preparación',
      READY: 'Listo',
      CANCELLED: 'Cancelado',
    };
    return statusMap[value] || value;
  }

  if (field === 'tableId' && typeof value === 'object' && value.name) {
    return value.name;
  }

  if (
    field === 'estimatedDeliveryTime' ||
    field === 'scheduledAt' ||
    field === 'finalizedAt'
  ) {
    try {
      return format(new Date(value), 'dd/MM/yyyy HH:mm', { locale: es });
    } catch {
      return value;
    }
  }

  if (field === 'total' || field === 'subtotal') {
    return `$${parseFloat(value).toFixed(2)}`;
  }

  if (field === 'customerId') {
    return value || 'Sin cliente registrado';
  }

  if (field === 'scheduledAt') {
    return value
      ? format(new Date(value), 'dd/MM/yyyy HH:mm', { locale: es })
      : 'No programado';
  }

  return String(value);
};

// Componente para cada item del historial (copiado de OrderHistoryModal)
const HistoryItemComponent: React.FC<{
  item: HistoryItem;
  theme: ReturnType<typeof useAppTheme>;
}> = ({ item, theme }) => {
  const [expanded, setExpanded] = useState(false);
  const styles = useMemo(() => createStyles(theme), [theme]);

  const renderChangeDetail = (change: any, fieldName?: string) => {
    if (
      change &&
      typeof change === 'object' &&
      change.anterior !== undefined &&
      change.nuevo !== undefined
    ) {
      // Para descripción del item, mostrar en formato vertical si es muy largo
      if (
        (fieldName === 'Descripción del Item' || fieldName === 'Descripción') &&
        (String(change.anterior).length > 30 ||
          String(change.nuevo).length > 30)
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {String(change.anterior)}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Después:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {String(change.nuevo)}
              </Text>
            </View>
          </View>
        );
      }
      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {String(change.anterior)}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {String(change.nuevo)}
            </Text>
          </View>
        </View>
      );
    } else if (Array.isArray(change) && change.length === 2) {
      // Para el formato de array [antes, después] - usado en cambios de orden
      const oldVal = formatValue(fieldName || '', change[0]);
      const newVal = formatValue(fieldName || '', change[1]);
      // Para campos largos o especiales, usar formato vertical
      if (
        fieldName &&
        ['notes', 'deliveryInfo', 'customerName', 'deliveryAddress'].includes(
          fieldName,
        )
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {oldVal}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Después:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {newVal}
              </Text>
            </View>
          </View>
        );
      }
      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {oldVal}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {newVal}
            </Text>
          </View>
        </View>
      );
    }
    return null;
  };

  return (
    <Surface
      style={[
        styles.historyItem,
        { backgroundColor: theme.colors.surfaceVariant },
      ]}
      elevation={1}
    >
      <TouchableOpacity
        onPress={() => setExpanded(!expanded)}
        activeOpacity={0.7}
      >
        <View style={styles.historyHeader}>
          <View style={{ flex: 1, marginRight: 12 }}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginBottom: 4,
              }}
            >
              <Avatar.Icon
                size={24}
                icon={getOperationIcon(item.operation, item.type)}
                style={{
                  backgroundColor:
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary,
                  marginRight: 6,
                }}
              />
              <Text
                variant="bodySmall"
                style={{ fontWeight: '600', flex: 1 }}
                numberOfLines={1}
              >
                {item.changedByUser
                  ? `${item.changedByUser.firstName} ${item.changedByUser.lastName}`
                  : item.user
                    ? `${item.user.firstName} ${item.user.lastName}`
                    : 'Sistema'}
              </Text>
              <View
                style={{
                  width: 32,
                  height: 32,
                  borderRadius: 16,
                  backgroundColor: theme.colors.surfaceVariant,
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Icon
                  name={expanded ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                flexWrap: 'wrap',
                gap: 4,
              }}
            >
              <View
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor:
                    (item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary) + '15',
                  paddingHorizontal: 5,
                  paddingVertical: 1,
                  borderRadius: 10,
                }}
              >
                <Icon
                  name={getOperationIcon(item.operation, item.type)}
                  size={10}
                  color={
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary
                  }
                  style={{ marginRight: 3 }}
                />
                <Text
                  style={{
                    color:
                      item.type === 'order'
                        ? theme.colors.primary
                        : theme.colors.secondary,
                    fontSize: 9,
                    fontWeight: '600',
                  }}
                >
                  {getOperationLabel(item.operation, item.type)}
                </Text>
              </View>
              {item.preparationStatus && (
                <Chip
                  mode="flat"
                  textStyle={{ fontSize: 9 }}
                  style={{
                    backgroundColor:
                      getStatusColor(item.preparationStatus, theme) + '20',
                    transform: [{ scale: 0.8 }],
                    height: 20,
                  }}
                  compact
                >
                  {formatValue('preparationStatus', item.preparationStatus)}
                </Chip>
              )}
              <Text variant="labelSmall" style={{ opacity: 0.6, fontSize: 10 }}>
                {format(new Date(item.changedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          </View>
        </View>
      </TouchableOpacity>
      {expanded && (
        <View style={styles.expandedContent}>
          <Divider style={{ marginBottom: 8 }} />
          {/* Contenido para órdenes */}
          {item.type === 'order' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <>
                  {/* Si hay diff consolidado para INSERT, usarlo */}
                  {item.diff && (item.diff.order || item.diff.items) ? (
                    <>
                      {item.diff.summary && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.primary,
                            fontWeight: '600',
                            marginBottom: 8,
                            fontStyle: 'italic',
                          }}
                        >
                          {item.diff.summary}
                        </Text>
                      )}

                      {/* Información de la orden */}
                      {item.diff.order && (
                        <View
                          style={{
                            backgroundColor: theme.colors.surface,
                            padding: 8,
                            borderRadius: 6,
                            marginBottom: 8,
                          }}
                        >
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.primary,
                              fontWeight: '600',
                              marginBottom: 6,
                            }}
                          >
                            Detalles de la orden:
                          </Text>

                          {item.diff.order.fields?.orderType && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.diff.order.fields.orderType[1],
                              )}
                            </Text>
                          )}
                          {item.diff.order.fields?.tableId && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Mesa:</Text>{' '}
                              {item.snapshot?.table?.name ||
                                `Mesa ${item.diff.order.fields.tableId[1]}`}
                            </Text>
                          )}
                          {item.diff.order.fields?.notes && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Notas:</Text>{' '}
                              {item.diff.order.fields.notes[1]}
                            </Text>
                          )}

                          {/* Información de entrega */}
                          {item.diff.order.deliveryInfo && (
                            <>
                              {item.diff.order.deliveryInfo.recipientName && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Cliente:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientName[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.recipientPhone && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Teléfono:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientPhone[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.fullAddress && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Dirección:
                                  </Text>{' '}
                                  {item.diff.order.deliveryInfo.fullAddress[1]}
                                </Text>
                              )}
                            </>
                          )}
                        </View>
                      )}

                      {/* Productos agregados */}
                      {item.diff.items?.added &&
                        item.diff.items.added.length > 0 && (
                          <>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                marginTop: 8,
                              }}
                            >
                              Productos incluidos en la orden:
                            </Text>
                            {item.diff.items.added.map(
                              (addedItem: any, idx: number) => (
                                <View
                                  key={`added-${idx}`}
                                  style={{
                                    marginBottom: 8,
                                    paddingLeft: 8,
                                    borderLeftWidth: 2,
                                    borderLeftColor:
                                      theme.colors.primary + '50',
                                    backgroundColor: theme.colors.surface,
                                    padding: 8,
                                    marginLeft: 4,
                                    borderRadius: 4,
                                  }}
                                >
                                  <Text
                                    variant="bodySmall"
                                    style={{ fontWeight: '600' }}
                                  >
                                    {addedItem.productName}
                                    {addedItem.variantName
                                      ? ` - ${addedItem.variantName}`
                                      : ''}
                                  </Text>
                                  {addedItem.modifiers?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Modificadores:{' '}
                                      {addedItem.modifiers.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.customizations?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Personalizaciones:{' '}
                                      {addedItem.customizations.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.notes && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        fontStyle: 'italic',
                                      }}
                                    >
                                      Notas: {addedItem.notes}
                                    </Text>
                                  )}
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      marginTop: 4,
                                      color: theme.colors.primary,
                                      fontWeight: '600',
                                    }}
                                  >
                                    Precio: $
                                    {addedItem.finalPrice ||
                                      addedItem.basePrice}
                                  </Text>
                                </View>
                              ),
                            )}
                          </>
                        )}
                    </>
                  ) : item.formattedChanges ? (
                    // Si hay formattedChanges (formato nuevo)
                    Object.entries(item.formattedChanges).map(
                      ([section, changes]) => {
                        if (section === 'Resumen') {
                          return (
                            <Text
                              key={section}
                              variant="bodySmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                fontStyle: 'italic',
                              }}
                            >
                              {changes as string}
                            </Text>
                          );
                        }
                        return (
                          <View key={section} style={{ marginBottom: 12 }}>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 6,
                              }}
                            >
                              {section}:
                            </Text>
                            {typeof changes === 'object' &&
                              Object.entries(changes).map(([field, change]) => (
                                <View
                                  key={field}
                                  style={{ marginBottom: 4, marginLeft: 8 }}
                                >
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.onSurfaceVariant,
                                      marginBottom: 2,
                                    }}
                                  >
                                    {field}:
                                  </Text>
                                  {renderChangeDetail(change, field)}
                                </View>
                              ))}
                          </View>
                        );
                      },
                    )
                  ) : (
                    // Formato original (legacy)
                    <Text
                      variant="bodySmall"
                      style={{ fontWeight: '600', marginBottom: 8 }}
                    >
                      Nueva orden creada
                      {item.snapshot?.orderType &&
                        ` - ${formatValue('orderType', item.snapshot.orderType)}`}
                    </Text>
                  )}
                </>
              )}

              {item.operation === 'UPDATE' &&
                (() => {
                  // Para formato nuevo con formattedChanges
                  if (item.formattedChanges) {
                    return Object.entries(item.formattedChanges).map(
                      ([section, changes]) => {
                        if (section === 'Resumen') {
                          return (
                            <Text
                              key={section}
                              variant="bodySmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                fontStyle: 'italic',
                              }}
                            >
                              {changes as string}
                            </Text>
                          );
                        }
                        return (
                          <View key={section} style={{ marginBottom: 12 }}>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 6,
                              }}
                            >
                              {section}:
                            </Text>
                            {typeof changes === 'object' &&
                              Object.entries(changes).map(([field, change]) => (
                                <View
                                  key={field}
                                  style={{ marginBottom: 4, marginLeft: 8 }}
                                >
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.onSurfaceVariant,
                                      marginBottom: 2,
                                    }}
                                  >
                                    {field}:
                                  </Text>
                                  {renderChangeDetail(change, field)}
                                </View>
                              ))}
                          </View>
                        );
                      },
                    );
                  }

                  // Para formato con diff
                  if (item.diff) {
                    return (
                      <>
                        {item.diff.summary && (
                          <Text
                            variant="bodySmall"
                            style={{
                              color: theme.colors.primary,
                              fontWeight: '600',
                              marginBottom: 8,
                              fontStyle: 'italic',
                            }}
                          >
                            {item.diff.summary}
                          </Text>
                        )}
                        {item.diff.order?.fields &&
                          Object.entries(item.diff.order.fields).map(
                            ([field, values]) => (
                              <View key={field} style={{ marginBottom: 8 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.onSurfaceVariant,
                                    fontWeight: '600',
                                    marginBottom: 4,
                                  }}
                                >
                                  {formatFieldName(field)}:
                                </Text>
                                {renderChangeDetail(values, field)}
                              </View>
                            ),
                          )}
                      </>
                    );
                  }

                  // Formato legacy
                  const relevantChanges = Object.entries(item.snapshot || {})
                    .filter(([field]) =>
                      [
                        'orderStatus',
                        'orderType',
                        'tableId',
                        'notes',
                        'deliveryInfo',
                        'estimatedDeliveryTime',
                        'scheduledAt',
                        'customerId',
                      ].includes(field),
                    )
                    .map(([field, value]) => ({ field, change: value }));

                  if (relevantChanges.length === 0) {
                    return (
                      <Text
                        variant="bodySmall"
                        style={{ color: theme.colors.onSurfaceVariant }}
                      >
                        Actualización de productos de la orden
                      </Text>
                    );
                  }

                  return (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en la orden:
                      </Text>
                      {relevantChanges.map(({ field, change }) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ))}
                    </>
                  );
                })()}

              {item.operation === 'DELETE' && (
                <Text variant="bodySmall" style={{ color: theme.colors.error }}>
                  La orden fue eliminada
                </Text>
              )}
            </View>
          )}

          {/* Contenido consolidado nuevo formato */}
          {item.diff &&
            (item.diff.order || item.diff.items || item.diff.summary) && (
              <View style={styles.changesContainer}>
                {/* Resumen de cambios */}
                {item.diff.summary && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                      fontStyle: 'italic',
                    }}
                  >
                    {item.diff.summary}
                  </Text>
                )}

                {/* Cambios en items (agregados/modificados/eliminados) */}
                {item.diff.items && (
                  <>
                    {item.diff.items.added?.length > 0 && (
                      <>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.success,
                            fontWeight: '600',
                            marginBottom: 6,
                          }}
                        >
                          Productos agregados:
                        </Text>
                        {item.diff.items.added.map(
                          (addedItem: any, idx: number) => (
                            <View
                              key={`added-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.success + '50',
                                backgroundColor: theme.colors.surface,
                                padding: 8,
                                marginLeft: 4,
                                borderRadius: 4,
                              }}
                            >
                              <Text
                                variant="bodySmall"
                                style={{ fontWeight: '600' }}
                              >
                                {addedItem.productName}
                                {addedItem.variantName
                                  ? ` - ${addedItem.variantName}`
                                  : ''}
                              </Text>
                              {(addedItem.modifiers?.length > 0 ||
                                addedItem.customizations?.length > 0 ||
                                addedItem.notes) && (
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    marginTop: 2,
                                    color: theme.colors.onSurfaceVariant,
                                  }}
                                >
                                  {[
                                    addedItem.modifiers?.length > 0 &&
                                      `Modificadores: ${addedItem.modifiers.join(', ')}`,
                                    addedItem.customizations?.length > 0 &&
                                      `Personalizaciones: ${addedItem.customizations.join(', ')}`,
                                    addedItem.notes &&
                                      `Notas: ${addedItem.notes}`,
                                  ]
                                    .filter(Boolean)
                                    .join(' • ')}
                                </Text>
                              )}
                              <Text
                                variant="labelSmall"
                                style={{
                                  marginTop: 4,
                                  color: theme.colors.primary,
                                  fontWeight: '600',
                                }}
                              >
                                Precio: $
                                {addedItem.finalPrice || addedItem.basePrice}
                              </Text>
                            </View>
                          ),
                        )}
                      </>
                    )}

                    {item.diff.items.removed?.length > 0 && (
                      <>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.error,
                            fontWeight: '600',
                            marginBottom: 6,
                            marginTop: 8,
                          }}
                        >
                          Productos eliminados:
                        </Text>
                        {item.diff.items.removed.map(
                          (removedItem: any, idx: number) => (
                            <View
                              key={`removed-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.error + '50',
                                backgroundColor: theme.colors.surface,
                                padding: 8,
                                marginLeft: 4,
                                borderRadius: 4,
                              }}
                            >
                              <Text
                                variant="bodySmall"
                                style={{
                                  textDecorationLine: 'line-through',
                                  color: theme.colors.error,
                                }}
                              >
                                {removedItem.productName}
                                {removedItem.variantName
                                  ? ` - ${removedItem.variantName}`
                                  : ''}
                              </Text>
                            </View>
                          ),
                        )}
                      </>
                    )}

                    {item.diff.items.modified?.length > 0 && (
                      <>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.warning || theme.colors.primary,
                            fontWeight: '600',
                            marginBottom: 6,
                            marginTop: 8,
                          }}
                        >
                          Productos modificados:
                        </Text>
                        {item.diff.items.modified.map(
                          (modifiedItem: any, idx: number) => (
                            <View
                              key={`modified-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor:
                                  (theme.colors.warning ||
                                    theme.colors.primary) + '50',
                                backgroundColor: theme.colors.surface,
                                padding: 8,
                                marginLeft: 4,
                                borderRadius: 4,
                              }}
                            >
                              <Text
                                variant="bodySmall"
                                style={{ fontWeight: '600' }}
                              >
                                {modifiedItem.productName}
                                {modifiedItem.variantName
                                  ? ` - ${modifiedItem.variantName}`
                                  : ''}
                              </Text>
                              {modifiedItem.changes &&
                                Object.entries(modifiedItem.changes).map(
                                  ([field, change]: [string, any]) => (
                                    <View key={field} style={{ marginTop: 4 }}>
                                      <Text
                                        variant="labelSmall"
                                        style={{
                                          color: theme.colors.onSurfaceVariant,
                                        }}
                                      >
                                        {formatFieldName(field)}:
                                      </Text>
                                      {renderChangeDetail(change, field)}
                                    </View>
                                  ),
                                )}
                            </View>
                          ),
                        )}
                      </>
                    )}
                  </>
                )}
              </View>
            )}

          {/* Contenido para items individuales */}
          {item.type === 'item' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <Text
                  variant="bodySmall"
                  style={{ color: theme.colors.success, marginBottom: 8 }}
                >
                  Item agregado:
                </Text>
              )}
              {item.operation === 'UPDATE' && item.formattedChanges && (
                <>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                    }}
                  >
                    Cambios en el item:
                  </Text>
                  {Object.entries(item.formattedChanges).map(
                    ([field, change]) => (
                      <View key={field} style={{ marginBottom: 8 }}>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.onSurfaceVariant,
                            fontWeight: '600',
                            marginBottom: 4,
                          }}
                        >
                          {field}:
                        </Text>
                        {renderChangeDetail(change, field)}
                      </View>
                    ),
                  )}
                </>
              )}
              {item.operation === 'DELETE' && (
                <Text
                  variant="bodySmall"
                  style={{ color: theme.colors.error, marginBottom: 8 }}
                >
                  Item eliminado:
                </Text>
              )}
              {/* Mostrar la descripción del item para INSERT y DELETE */}
              {(item.operation === 'INSERT' || item.operation === 'DELETE') &&
                item.itemDescription && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.onSurface,
                      backgroundColor: theme.colors.surface,
                      padding: 8,
                      borderRadius: 6,
                    }}
                  >
                    {item.itemDescription}
                  </Text>
                )}
            </View>
          )}

          {/* Contenido para batch de items */}
          {item.operation === 'BATCH' && item.batchOperations && (
            <View style={styles.changesContainer}>
              <Text
                variant="bodySmall"
                style={{
                  color: theme.colors.primary,
                  fontWeight: '600',
                  marginBottom: 8,
                }}
              >
                Cambios realizados en una sola edición:
              </Text>
              {item.batchOperations.map((op: any, idx: number) => (
                <View
                  key={idx}
                  style={{
                    marginBottom:
                      idx < item.batchOperations!.length - 1 ? 12 : 0,
                    paddingLeft: 8,
                    borderLeftWidth: 2,
                    borderLeftColor: theme.colors.primary + '30',
                    marginLeft: 4,
                  }}
                >
                  <View
                    style={{
                      flexDirection: 'row',
                      alignItems: 'flex-start',
                      marginBottom: 4,
                    }}
                  >
                    <Icon
                      name={getOperationIcon(op.operation)}
                      size={14}
                      color={theme.colors.primary}
                      style={{ marginRight: 6, marginTop: 2 }}
                    />
                    <View style={{ flex: 1 }}>
                      <Text
                        variant="labelSmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '500',
                          marginBottom: 4,
                        }}
                      >
                        {getOperationLabel(op.operation)}
                      </Text>

                      {/* Mostrar descripción del item */}
                      {(op.itemDescription || op.snapshot?.itemDescription) && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.onSurface,
                            backgroundColor: theme.colors.surface,
                            padding: 6,
                            borderRadius: 4,
                          }}
                        >
                          {op.itemDescription || op.snapshot?.itemDescription}
                        </Text>
                      )}

                      {/* Para UPDATE, mostrar el cambio */}
                      {op.operation === 'UPDATE' && op.formattedChanges && (
                        <View style={{ marginTop: 4 }}>
                          {Object.entries(op.formattedChanges)
                            .filter(([fieldName]) => {
                              // Solo mostrar campos relevantes (no precios)
                              const allowedFields = [
                                'Descripción del Item',
                                'Descripción',
                                'Estado',
                                'Notas de preparación',
                                'Estado de preparación',
                              ];
                              return allowedFields.some((allowed) =>
                                fieldName.includes(allowed),
                              );
                            })
                            .map(([field, change]) => (
                              <View key={field} style={{ marginBottom: 4 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.onSurfaceVariant,
                                    fontSize: 11,
                                  }}
                                >
                                  {field}:
                                </Text>
                                {renderChangeDetail(change, field)}
                              </View>
                            ))}
                        </View>
                      )}
                    </View>
                  </View>
                </View>
              ))}
            </View>
          )}
        </View>
      )}
    </Surface>
  );
};

export const OrderHistoryView: React.FC<OrderHistoryViewProps> = ({
  orderId,
  orderNumber,
  onBack,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  // Query combinado para obtener ambos historiales
  const {
    data: historyData,
    isError,
    refetch,
    isLoading,
  } = useQuery({
    queryKey: ['combinedHistory', orderId],
    queryFn: async () => {
      if (!orderId) throw new Error('No order ID');

      // Obtener historial consolidado de la orden
      const orderHistoryResponse = await apiClient.get(
        API_PATHS.ORDERS_HISTORY.replace(':orderId', orderId),
        {
          page: 1,
          limit: 100,
        },
      );

      const orderHistory =
        orderHistoryResponse.ok && orderHistoryResponse.data?.data
          ? orderHistoryResponse.data.data.map((item: any) => ({
              ...item,
              type: 'order' as const,
            }))
          : [];

      return orderHistory;
    },
    enabled: !!orderId,
    staleTime: 30000,
  });

  const renderHistoryItem = ({ item }: { item: HistoryItem }) => {
    return <HistoryItemComponent item={item} theme={theme} />;
  };

  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Icon
        name="history"
        size={48}
        color={theme.colors.onSurfaceDisabled}
        style={{ opacity: 0.5 }}
      />
      <Text
        variant="bodyLarge"
        style={{
          color: theme.colors.onSurfaceDisabled,
          marginTop: theme.spacing.m,
        }}
      >
        No hay historial disponible
      </Text>
      <Text
        variant="bodySmall"
        style={{
          color: theme.colors.onSurfaceVariant,
          marginTop: theme.spacing.s,
          textAlign: 'center',
        }}
      >
        Los cambios realizados en esta orden aparecerán aquí
      </Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <Appbar.Header style={styles.header}>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content
          title={`Historial de Orden #${orderNumber || ''}`}
          subtitle={`${historyData?.length || 0} cambios registrados`}
        />
      </Appbar.Header>

      <View style={styles.content}>
        {isError ? (
          <View style={styles.emptyContainer}>
            <Icon
              name="alert-circle"
              size={48}
              color={theme.colors.error}
              style={{ opacity: 0.7 }}
            />
            <Text
              variant="bodyLarge"
              style={{
                color: theme.colors.error,
                marginTop: theme.spacing.m,
                textAlign: 'center',
              }}
            >
              Error al cargar el historial
            </Text>
            <Button
              onPress={() => refetch()}
              mode="text"
              style={{ marginTop: 16 }}
            >
              Reintentar
            </Button>
          </View>
        ) : isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando historial...</Text>
          </View>
        ) : (
          <FlatList
            data={historyData || []}
            renderItem={renderHistoryItem}
            keyExtractor={(item) => item.id.toString()}
            contentContainerStyle={styles.listContent}
            ListEmptyComponent={renderEmpty}
            showsVerticalScrollIndicator={false}
          />
        )}
      </View>
    </View>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) => {
  return StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    content: {
      flex: 1,
    },
    listContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2,
    },
    loadingContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    historyItem: {
      padding: theme.spacing.s,
      marginBottom: theme.spacing.s,
      marginHorizontal: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 2,
    },
    historyHeader: {
      // Estructura vertical para evitar encimamiento
    },
    expandedContent: {
      marginTop: theme.spacing.s,
      paddingTop: theme.spacing.s,
    },
    changesContainer: {
      marginTop: theme.spacing.xs,
    },
    changeDetail: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 4,
      flexWrap: 'wrap',
    },
    emptyContainer: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      padding: theme.spacing.xl,
    },
  });
};

================
File: app/src/modules/shiftAudit/hooks/useShiftSalesSummary.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

export interface ProductSalesSummary {
  productId: string;
  productName: string;
  quantity: number;
  totalAmount: number;
  averagePrice: number;
}

export interface SubcategorySalesSummary {
  subcategoryId: string;
  subcategoryName: string;
  quantity: number;
  totalAmount: number;
  products: ProductSalesSummary[];
}

export interface CategorySalesSummary {
  categoryId: string;
  categoryName: string;
  quantity: number;
  totalAmount: number;
  percentage: number;
  subcategories: SubcategorySalesSummary[];
}

export interface ShiftSalesSummary {
  shiftId: string;
  shiftNumber: number;
  date: string;
  totalSales: number;
  totalQuantity: number;
  completedOrders: number;
  averageTicket: number;
  categories: CategorySalesSummary[];
  topProducts: ProductSalesSummary[];
  startTime: string;
  endTime: string | null;
}

export function useShiftSalesSummary(shiftId: string | null) {
  return useQuery({
    queryKey: ['shiftSalesSummary', shiftId],
    queryFn: async () => {
      if (!shiftId) return null;

      const response = await apiClient.get(
        API_PATHS.ORDERS_BY_SHIFT_SALES_SUMMARY.replace(':shiftId', shiftId),
      );

      if (!response.ok) {
        throw new Error(
          response.problem || 'Error al obtener resumen de ventas',
        );
      }

      return response.data as ShiftSalesSummary;
    },
    enabled: !!shiftId,
  });
}

================
File: app/src/modules/users/screens/UsersListScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, Chip, Text } from 'react-native-paper';
import { useDrawerStatus } from '@react-navigation/drawer';
import GenericList from '@/app/components/crud/GenericList';
import { UserFormModal } from '../components/UserFormModal';
import { UserDetailModal } from '../components/UserDetailModal';
import { useListState } from '@/app/hooks/useListState';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useGetUsers, useDeleteUser } from '../hooks';
import type { User, UsersQuery } from '../types';
import { RoleEnum } from '../types';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

export function UsersListScreen() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const drawerStatus = useDrawerStatus();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedFilter, setSelectedFilter] = useState('all');
  const [isRefreshing, setIsRefreshing] = useState(false);

  const deleteUserMutation = useDeleteUser();

  const {
    isFormModalVisible,
    isDetailModalVisible,
    selectedItem,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
  } = useCrudScreenLogic<User>({
    entityName: 'Usuario',
    queryKey: ['users'],
    deleteMutationFn: async (id) => {
      await deleteUserMutation.mutateAsync(id);
    },
  });

  const queryParams: UsersQuery = {
    page: 1,
    limit: 100,
    search: searchQuery || undefined,
    filters:
      selectedFilter === 'all'
        ? undefined
        : selectedFilter === 'active'
          ? { isActive: true }
          : selectedFilter === 'inactive'
            ? { isActive: false }
            : selectedFilter === 'admin'
              ? { roles: [{ id: RoleEnum.ADMIN }] }
              : selectedFilter === 'user'
                ? { roles: [{ id: RoleEnum.WAITER }] }
                : undefined,
    sortBy: 'createdAt',
    sortOrder: 'DESC',
  };

  const { data, isLoading, error, refetch } = useGetUsers(queryParams);

  // Recargar automáticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('users');

  // Funciones auxiliares definidas antes del useMemo
  const getStatusColor = (user: User) => {
    return user.isActive ? 'success' : 'error';
  };

  const getStatusText = (user: User) => {
    return user.isActive ? 'Activo' : 'Inactivo';
  };

  const getUserDescription = (user: User) => {
    const parts = [];

    // Mostrar username primero
    parts.push(`@${user.username}`);

    // Luego el email en una nueva línea si existe
    if (user.email) {
      parts.push(`\n${user.email}`);
    }

    // Si es usuario de cocina y tiene pantalla asignada, mostrarla
    if (user.role?.id === 5 && user.preparationScreen) {
      parts.push(`\nPantalla: ${user.preparationScreen.name}`);
    }

    return parts.join('');
  };

  // Mapear los usuarios para agregar campos calculados
  const mappedUsers = React.useMemo(() => {
    const users = data?.data || [];

    return users.map((user) => {
      const displayName =
        `${user.firstName || ''} ${user.lastName || ''}`.trim() ||
        user.username;
      const displayInfo = getUserDescription(user);

      return {
        ...user,
        displayName,
        displayInfo,
        displayNameWithRole: { name: displayName, roleId: user.role?.id },
        statusText: getStatusText(user),
        statusColor: getStatusColor(user),
      };
    });
  }, [data]);

  const handleCreateUser = () => {
    handleOpenCreateModal();
  };

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: error ? true : false,
    data: mappedUsers,
    emptyConfig: {
      title: 'No hay usuarios',
      message: 'No hay usuarios registrados en el sistema',
      icon: 'account-multiple-outline',
      actionLabel: 'Agregar usuario',
      onAction: handleCreateUser,
    },
    errorConfig: {
      title: 'Error al cargar usuarios',
      message: 'No se pudieron cargar los usuarios. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onAction: refetch,
    },
  });

  const filterOptions = [
    { label: 'Todos', value: 'all' },
    { label: 'Activos', value: 'active' },
    { label: 'Inactivos', value: 'inactive' },
    { label: 'Administradores', value: 'admin' },
    { label: 'Usuarios', value: 'user' },
  ];

  const handleEditUser = (user: User) => {
    handleOpenEditModal(user);
  };

  const handleViewUser = (user: User) => {
    handleOpenDetailModal(user);
  };

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };

  const getRoleChipProps = (roleId: number | undefined) => {
    switch (roleId) {
      case 1:
        return {
          label: 'Admin',
          icon: 'shield-account',
          color: theme.colors.error,
        };
      case 2:
        return {
          label: 'Gerente',
          icon: 'account-tie',
          color: theme.colors.primary,
        };
      case 3:
        return {
          label: 'Cajero',
          icon: 'cash-register',
          color: theme.colors.tertiary,
        };
      case 4:
        return {
          label: 'Mesero',
          icon: 'room-service',
          color: theme.colors.secondary,
        };
      case 5:
        return { label: 'Cocina', icon: 'chef-hat', color: '#FF6B6B' };
      case 6:
        return { label: 'Repartidor', icon: 'moped', color: '#4ECDC4' };
      default:
        return {
          label: 'Usuario',
          icon: 'account',
          color: theme.colors.onSurfaceVariant,
        };
    }
  };

  const renderDescription = (user: User) => {
    const roleProps = getRoleChipProps(user.role?.id);

    return (
      <View style={styles.descriptionContainer}>
        <View style={styles.userInfoRow}>
          <Text style={styles.username}>@{user.username}</Text>
          <Chip
            mode="flat"
            icon={roleProps.icon}
            style={[
              styles.roleChipInDescription,
              { backgroundColor: roleProps.color + '20' },
            ]}
            textStyle={[styles.roleChipText, { color: roleProps.color }]}
            compact
          >
            {roleProps.label}
          </Chip>
        </View>
        {user.email && (
          <Text style={styles.email} numberOfLines={1}>
            {user.email}
          </Text>
        )}
        {user.role?.id === 5 && user.preparationScreen && (
          <Text style={styles.screenInfo}>
            Pantalla: {user.preparationScreen.name}
          </Text>
        )}
      </View>
    );
  };

  const renderTitle = (user: User) => {
    const firstName = user.firstName || '';
    const lastName = user.lastName || '';
    const fullName = `${firstName} ${lastName}`.trim();
    const displayName = fullName || user.username;

    return (
      <View style={styles.titleContainer}>
        <Text style={styles.title} numberOfLines={1} ellipsizeMode="tail">
          {displayName}
        </Text>
      </View>
    );
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContainer: {
      flex: 1,
    },
    titleContainer: {
      flex: 1,
      paddingRight: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
    },
    title: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 16,
      lineHeight: responsive.isTablet ? 18 : 22,
    },
    descriptionContainer: {
      flex: 1,
      gap: responsive.isTablet ? 2 : theme.spacing.xs / 2,
      paddingTop: responsive.isTablet ? 2 : theme.spacing.xs / 2,
    },
    userInfoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
      flexWrap: 'wrap',
    },
    username: {
      fontSize: responsive.isTablet ? 12 : 14,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
    },
    email: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.8,
    },
    screenInfo: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    roleChipInDescription: {
      minHeight: responsive.isTablet ? 20 : 28,
      height: 'auto',
      borderRadius: theme.roundness * 2,
      paddingHorizontal: responsive.isTablet ? 6 : responsive.spacing.s,
      paddingVertical: responsive.isTablet ? 1 : 4,
    },
    roleChipText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '600',
      lineHeight: responsive.isTablet ? 12 : 16,
      marginVertical: 0,
      paddingVertical: 0,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        <GenericList
          items={mappedUsers}
          isLoading={isLoading}
          isRefreshing={isRefreshing}
          onRefresh={handleRefresh}
          onItemPress={handleViewUser}
          ListEmptyComponent={ListEmptyComponent}
          listItemStyle={
            responsive.isTablet
              ? {
                  marginVertical: 1,
                  marginHorizontal: responsive.spacing.xs,
                }
              : undefined
          }
          listItemContentStyle={
            responsive.isTablet
              ? {
                  paddingVertical: 2,
                  minHeight: 36,
                }
              : undefined
          }
          contentContainerStyle={
            responsive.isTablet
              ? {
                  paddingTop: 2,
                  paddingBottom: 80,
                }
              : undefined
          }
          renderConfig={{
            titleField: 'displayName' as any,
            descriptionField: 'displayInfo' as any,
            statusConfig: {
              field: 'isActive' as any,
              activeValue: true,
              activeLabel: 'Activo',
              inactiveLabel: 'Inactivo',
            },
            renderTitle: renderTitle,
            renderDescription: renderDescription,
          }}
          enableSearch={true}
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          searchPlaceholder="Buscar por nombre, email o usuario..."
          filterOptions={filterOptions}
          filterValue={selectedFilter}
          onFilterChange={(value) => setSelectedFilter(value as string)}
          showFab={true}
          onFabPress={handleCreateUser}
          fabIcon="account-plus"
          fabLabel="Nuevo Usuario"
          fabVisible={drawerStatus === 'closed'}
          showImagePlaceholder={false}
          isDrawerOpen={drawerStatus === 'open'}
        />
      </View>

      <Portal>
        {isFormModalVisible && (
          <UserFormModal
            visible={isFormModalVisible}
            onDismiss={handleCloseModals}
            user={editingItem}
          />
        )}

        {isDetailModalVisible && selectedItem && (
          <UserDetailModal
            visible={isDetailModalVisible}
            onDismiss={handleCloseModals}
            user={selectedItem}
            onEdit={handleEditUser}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
}

================
File: app/src/services/audioOrderService.ts
================
import ApiClientWrapper from '../app/services/apiClientWrapper';
import * as FileSystem from 'expo-file-system';
import { API_PATHS } from '@/app/constants/apiPaths';

export interface AIOrderItem {
  productId: string;
  productName?: string;
  variantId?: string;
  variantName?: string;
  quantity: number;
  modifiers?: string[];
  pizzaCustomizations?: Array<{
    customizationId: string;
    customizationName?: string;
    half: 'FULL' | 'HALF_1' | 'HALF_2';
    action: 'ADD' | 'REMOVE';
  }>;
}

export interface DeliveryInfoData {
  fullAddress?: string;
  recipientName?: string;
  recipientPhone?: string;
}

export interface ScheduledDeliveryData {
  time?: string;
}

export interface AudioOrderResponse {
  success: boolean;
  data?: {
    orderItems?: AIOrderItem[];
    deliveryInfo?: DeliveryInfoData;
    scheduledDelivery?: ScheduledDeliveryData;
    orderType?: 'DELIVERY' | 'TAKE_AWAY' | 'DINE_IN';
    warnings?: string;
    processingTime: number;
  };
  error?: {
    code: string;
    message: string;
    type: string;
    timestamp: string;
    requestId: string;
  };
}

class AudioOrderService {
  constructor() {
    // API URL se maneja en apiClient
  }

  async processAudioOrder(
    audioUri: string,
    transcription: string,
  ): Promise<AudioOrderResponse> {
    try {
      // Convertir audio a base64
      const audioBase64 = await FileSystem.readAsStringAsync(audioUri, {
        encoding: FileSystem.EncodingType.Base64,
      });

      // Preparar payload para el backend
      const payload = {
        audioData: audioBase64,
        transcription: transcription,
        audioFormat: 'audio/mp4',
      };

      // Enviar al backend con timeout extendido para procesamiento de audio
      const response = await ApiClientWrapper.post(
        API_PATHS.AUDIO_ORDERS_PROCESS,
        payload,
        { timeout: 60000 }, // 60 segundos para permitir procesamiento de audio
      );

      // Verificar que tengamos una respuesta válida
      if (!response || !response?.ok || !response.data) {
        throw new Error('No se recibió respuesta del servidor');
      }

      const responseData = response.data as any;

      // Adaptar la respuesta del backend al formato esperado
      if (responseData.success) {
        return {
          success: true,
          data: responseData.extractedData || {
            orderItems: [],
            deliveryInfo: {},
            scheduledDelivery: {},
            orderType: 'DELIVERY', // Valor por defecto si no hay datos
            warnings: undefined,
            processingTime: 0,
          },
        };
      } else {
        throw new Error(
          responseData.error?.message ||
            responseData.message ||
            'Error procesando audio',
        );
      }
    } catch (error: any) {
      return {
        success: false,
        error: {
          code: error.response?.data?.error?.code || 'PROCESSING_ERROR',
          message: this.getErrorMessage(error),
          type: 'error',
          timestamp: new Date().toISOString(),
          requestId: 'local-' + Date.now(),
        },
      };
    }
  }

  getErrorMessage(error: any): string {
    if (error.response?.data?.error) {
      const apiError = error.response.data.error;

      switch (apiError.code) {
        case 'BL015':
          return 'El archivo de audio es muy grande. Máximo 10MB.';
        case 'AUTH001':
          return 'Error de autenticación. Contacta al administrador.';
        case 'BL016':
          return 'No se pudo procesar el audio. Intenta de nuevo.';
        case 'BL002':
          return 'Faltan datos requeridos.';
        default:
          return apiError.message || 'Error desconocido';
      }
    }

    return error.message || 'Error al procesar la orden por voz';
  }

  // Método para validar antes de enviar
  validateBeforeSending(
    audioFileSize: number,
    transcription: string,
  ): string[] {
    const errors: string[] = [];

    // Validar tamaño (50MB máximo para audio de hasta 5 minutos)
    if (audioFileSize > 50 * 1024 * 1024) {
      errors.push('El archivo de audio es muy grande (máximo 50MB)');
    }

    // Validar transcripción
    if (!transcription || transcription.trim().length < 5) {
      errors.push('La transcripción está vacía o es muy corta');
    }

    return errors;
  }
}

export const audioOrderService = new AudioOrderService();

================
File: app/package.json
================
{
  "name": "cloudbite",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "test:ci": "jest",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
    "compile": "tsc --noEmit --skipLibCheck",
    "compile:check": "./compile-check.sh",
    "build:ios:sim": "eas build --platform ios --profile development --local",
    "build:android:sim": "eas build --platform android --profile development --local",
    "build:ios:dev": "eas build --platform ios --profile preview --local",
    "build:android:dev": "eas build --platform android --profile preview --local",
    "build:android:prod": "eas build --platform android --profile production --local",
    "build:android:prod-apk": "eas build --platform android --profile production-apk --local",
    "build:prod": "eas build --platform android --profile production",
    "submit:prod": "eas submit --platform android --profile production",
    "release:prod": "npm run build:prod && npm run submit:prod",
    "release:prod:auto": "eas build --platform android --profile production --auto-submit",
    "release:playstore": "./scripts/release-to-playstore.sh",
    "postinstall": "patch-package"
  },
  "dependencies": {
    "@expo/config-plugins": "~10.0.0",
    "@expo/metro-config": "~0.20.0",
    "@expo/metro-runtime": "~5.0.4",
    "@expo/prebuild-config": "~9.0.0",
    "@expo/vector-icons": "^14.0.4",
    "@react-native-community/datetimepicker": "^8.4.2",
    "@react-native-community/netinfo": "11.3.1",
    "@react-navigation/drawer": "^7.3.8",
    "@react-navigation/native": "^7.1.5",
    "@react-navigation/native-stack": "^7.3.9",
    "@shopify/flash-list": "1.7.6",
    "@tanstack/react-query": "^5.72.1",
    "@types/eventemitter3": "^1.2.0",
    "apisauce": "^3.1.1",
    "axios": "^1.8.4",
    "axios-retry": "^4.5.0",
    "babel-plugin-module-resolver": "^5.0.2",
    "date-fns": "^4.1.0",
    "eventemitter3": "^5.0.1",
    "expo": "^53.0.0",
    "expo-audio": "~0.4.7",
    "expo-build-properties": "^0.14.8",
    "expo-crypto": "~14.1.5",
    "expo-dev-client": "~5.2.4",
    "expo-file-system": "~18.1.10",
    "expo-image": "~2.3.0",
    "expo-image-picker": "~16.1.4",
    "expo-screen-orientation": "^8.1.7",
    "expo-secure-store": "~14.2.3",
    "expo-speech-recognition": "^0.3.2",
    "lodash.debounce": "^4.0.8",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-hook-form": "^7.55.0",
    "react-native": "0.79.4",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-paper": "^5.13.1",
    "react-native-paper-dates": "^0.22.46",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.11.1",
    "react-native-web": "^0.20.0",
    "react-native-webview": "^13.15.0",
    "zod": "^3.24.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/lodash": "^4.17.16",
    "@types/react": "~19.0.10",
    "@typescript-eslint/eslint-plugin": "^7.13.1",
    "@typescript-eslint/parser": "^7.13.1",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "eslint-plugin-react": "^7.34.3",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-native": "^4.1.0",
    "http-proxy-middleware": "^3.0.5",
    "patch-package": "^8.0.0",
    "typescript": "~5.8.3"
  },
  "private": true,
  "expo": {
    "doctor": {
      "reactNativeDirectoryCheck": {
        "exclude": [
          "@hookform/resolvers",
          "dotenv"
        ],
        "listUnknownPackages": false
      }
    }
  }
}

================
File: app/src/app/components/common/AdaptiveModal.tsx
================
import React, { ReactNode, useMemo } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Dimensions,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Modal, Portal } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface AdaptiveModalProps {
  visible: boolean;
  onDismiss: () => void;
  children: ReactNode;
  contentContainerStyle?: any;
  maxWidth?: number | string;
  minHeight?: number;
  maxHeight?: string | number;
  dismissable?: boolean;
  dismissableBackButton?: boolean;
  scrollable?: boolean;
  footer?: ReactNode;
  stickyFooter?: boolean;
}

export const AdaptiveModal: React.FC<AdaptiveModalProps> = ({
  visible,
  onDismiss,
  children,
  contentContainerStyle,
  maxWidth,
  minHeight = 200,
  maxHeight = '90%',
  dismissable = true,
  dismissableBackButton = true,
  scrollable = true,
  footer,
  stickyFooter = true,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const screenHeight = Dimensions.get('window').height;

  const maxHeightPixels = useMemo(() => {
    if (typeof maxHeight === 'string' && maxHeight.endsWith('%')) {
      const percentage = parseInt(maxHeight) / 100;
      return screenHeight * percentage;
    }
    return typeof maxHeight === 'number' ? maxHeight : screenHeight * 0.9;
  }, [maxHeight, screenHeight]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        modalContainer: {
          backgroundColor: theme.colors.surface,
          borderRadius: theme.roundness * 2,
          width: '90%',
          maxWidth: maxWidth || (responsive.isTablet ? 600 : 500),
          minHeight: minHeight,
          maxHeight: maxHeightPixels,
          alignSelf: 'center',
          overflow: 'hidden',
          elevation: 24,
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 12 },
          shadowOpacity: 0.58,
          shadowRadius: 16.0,
        },
        scrollView: {
          maxHeight: maxHeightPixels - (footer ? 100 : 20),
        },
        scrollContent: {
          padding: responsive.isTablet
            ? responsive.spacing.l
            : responsive.spacing.m,
        },
        contentPadding: {
          padding: responsive.isTablet
            ? responsive.spacing.l
            : responsive.spacing.m,
          flex: 1,
        },
        footer: {
          borderTopWidth: 1,
          borderTopColor: theme.colors.surfaceVariant,
          padding: responsive.spacing.m,
          backgroundColor: theme.colors.surface,
        },
      }),
    [theme, responsive, minHeight, maxHeightPixels, maxWidth, footer],
  );

  const modalContent = (
    <View style={styles.modalContainer}>
      {scrollable ? (
        <>
          <ScrollView
            style={styles.scrollView}
            contentContainerStyle={[
              styles.scrollContent,
              contentContainerStyle,
            ]}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            {children}
          </ScrollView>
          {stickyFooter && footer && (
            <View style={styles.footer}>{footer}</View>
          )}
        </>
      ) : (
        <>
          <View style={[styles.contentPadding, contentContainerStyle]}>
            {children}
          </View>
          {footer && <View style={styles.footer}>{footer}</View>}
        </>
      )}
    </View>
  );

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        dismissable={dismissable}
        dismissableBackButton={dismissableBackButton}
        contentContainerStyle={{
          justifyContent: 'center',
          alignItems: 'center',
          flex: 1,
        }}
      >
        {Platform.OS === 'ios' ? (
          <KeyboardAvoidingView behavior="position" keyboardVerticalOffset={20}>
            {modalContent}
          </KeyboardAvoidingView>
        ) : (
          modalContent
        )}
      </Modal>
    </Portal>
  );
};

export default AdaptiveModal;

================
File: app/src/app/components/common/PhoneNumberInput.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import { TextInput, Menu, Button, HelperText } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface Country {
  code: string;
  name: string;
  prefix: string;
  flag: string;
}

// Lista de países más comunes en América
// IMPORTANTE: Ordenados con prefijos más largos primero para evitar conflictos
const COUNTRIES: Country[] = [
  // Países con prefijos de 4 dígitos
  { code: 'DO', name: 'Rep. Dominicana', prefix: '+1809', flag: '🇩🇴' },
  { code: 'PR', name: 'Puerto Rico', prefix: '+1787', flag: '🇵🇷' },

  // Países con prefijos de 3 dígitos
  { code: 'EC', name: 'Ecuador', prefix: '+593', flag: '🇪🇨' },
  { code: 'BO', name: 'Bolivia', prefix: '+591', flag: '🇧🇴' },
  { code: 'PY', name: 'Paraguay', prefix: '+595', flag: '🇵🇾' },
  { code: 'UY', name: 'Uruguay', prefix: '+598', flag: '🇺🇾' },
  { code: 'GT', name: 'Guatemala', prefix: '+502', flag: '🇬🇹' },
  { code: 'SV', name: 'El Salvador', prefix: '+503', flag: '🇸🇻' },
  { code: 'HN', name: 'Honduras', prefix: '+504', flag: '🇭🇳' },
  { code: 'NI', name: 'Nicaragua', prefix: '+505', flag: '🇳🇮' },
  { code: 'CR', name: 'Costa Rica', prefix: '+506', flag: '🇨🇷' },
  { code: 'PA', name: 'Panamá', prefix: '+507', flag: '🇵🇦' },

  // Países con prefijos de 2 dígitos
  { code: 'MX', name: 'México', prefix: '+52', flag: '🇲🇽' },
  { code: 'AR', name: 'Argentina', prefix: '+54', flag: '🇦🇷' },
  { code: 'BR', name: 'Brasil', prefix: '+55', flag: '🇧🇷' },
  { code: 'CL', name: 'Chile', prefix: '+56', flag: '🇨🇱' },
  { code: 'CO', name: 'Colombia', prefix: '+57', flag: '🇨🇴' },
  { code: 'PE', name: 'Perú', prefix: '+51', flag: '🇵🇪' },
  { code: 'VE', name: 'Venezuela', prefix: '+58', flag: '🇻🇪' },
  { code: 'CU', name: 'Cuba', prefix: '+53', flag: '🇨🇺' },
  { code: 'ES', name: 'España', prefix: '+34', flag: '🇪🇸' },

  // Países con prefijo de 1 dígito (al final)
  { code: 'US', name: 'Estados Unidos', prefix: '+1', flag: '🇺🇸' },
  { code: 'CA', name: 'Canadá', prefix: '+1', flag: '🇨🇦' },
];

interface PhoneNumberInputProps {
  value: string;
  onChange: (fullNumber: string) => void;
  error?: boolean;
  helperText?: string;
  placeholder?: string;
}

export default function PhoneNumberInput({
  value,
  onChange,
  error,
  helperText,
  placeholder = 'Teléfono',
}: PhoneNumberInputProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );

  const [selectedCountry, setSelectedCountry] = useState<Country>(COUNTRIES[0]);
  const [phoneNumber, setPhoneNumber] = useState('');
  const [menuVisible, setMenuVisible] = useState(false);

  // Detectar país y número al recibir un valor completo
  useEffect(() => {
    if (value && value.startsWith('+')) {
      // Ordenar países por longitud de prefijo (más largos primero) para evitar coincidencias erróneas
      const sortedCountries = [...COUNTRIES].sort(
        (a, b) => b.prefix.length - a.prefix.length,
      );

      // Encontrar el país por el prefijo
      const country = sortedCountries.find((c) => value.startsWith(c.prefix));
      if (country) {
        setSelectedCountry(country);
        setPhoneNumber(value.substring(country.prefix.length));
      } else {
        // Si no encontramos el país, usar el default y mostrar todo el número
        setPhoneNumber(value);
      }
    } else {
      setPhoneNumber(value || '');
    }
  }, [value]);

  const handlePhoneChange = (text: string) => {
    // Solo permitir números y limitar a 15 dígitos (estándar internacional)
    const cleaned = text.replace(/[^\d]/g, '').slice(0, 15);
    setPhoneNumber(cleaned);

    // Actualizar el valor completo
    if (cleaned) {
      onChange(`${selectedCountry.prefix}${cleaned}`);
    } else {
      onChange('');
    }
  };

  const handleCountrySelect = (country: Country) => {
    setSelectedCountry(country);
    setMenuVisible(false);

    // Actualizar el valor completo con el nuevo país
    if (phoneNumber) {
      onChange(`${country.prefix}${phoneNumber}`);
    }
  };

  return (
    <View>
      <View style={styles.container}>
        <Menu
          visible={menuVisible}
          onDismiss={() => setMenuVisible(false)}
          anchor={
            <Button
              mode="outlined"
              onPress={() => setMenuVisible(true)}
              style={styles.countryButton}
              labelStyle={styles.countryButtonLabel}
            >
              {selectedCountry.flag} {selectedCountry.prefix}
            </Button>
          }
          contentStyle={styles.menuContent}
        >
          <ScrollView
            style={styles.menuScrollView}
            showsVerticalScrollIndicator={true}
            nestedScrollEnabled={true}
          >
            {COUNTRIES.map((country) => (
              <Menu.Item
                key={country.code}
                onPress={() => handleCountrySelect(country)}
                title={`${country.flag} ${country.name} (${country.prefix})`}
                titleStyle={styles.menuItem}
              />
            ))}
          </ScrollView>
        </Menu>

        <TextInput
          value={phoneNumber}
          onChangeText={handlePhoneChange}
          placeholder={placeholder}
          keyboardType="phone-pad"
          mode="outlined"
          error={error}
          style={styles.input}
          outlineStyle={styles.inputOutline}
          maxLength={15}
        />
      </View>

      {helperText && (
        <HelperText type="error" visible={error}>
          {helperText}
        </HelperText>
      )}
    </View>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    countryButton: {
      minWidth: responsive.isTablet ? 85 : 90,
      height: responsive.isTablet ? 48 : 56,
      justifyContent: 'center',
    },
    countryButtonLabel: {
      fontSize: responsive.fontSize(16),
    },
    menuContent: {
      maxHeight: responsive.isTablet ? 400 : 350,
      backgroundColor: theme.colors.surface,
    },
    menuScrollView: {
      maxHeight: responsive.isTablet ? 390 : 340,
    },
    menuItem: {
      fontSize: responsive.fontSize(14),
    },
    input: {
      flex: 1,
      height: responsive.isTablet ? 48 : 56,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
  });

================
File: app/src/app/components/crud/GenericFormModal.tsx
================
import React, {
  useEffect,
  useMemo,
  useState,
  useCallback,
  useRef,
} from 'react';
import {
  View,
  StyleSheet,
  Alert,
  ScrollView,
  StyleProp,
  ViewStyle,
} from 'react-native';
import {
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  ActivityIndicator,
} from 'react-native-paper';
import {
  useForm,
  Controller,
  SubmitHandler,
  FieldValues,
  Path,
  UseFormReturn,
  DeepPartial,
  DefaultValues,
  Control,
  FieldError, // Importar FieldError
} from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '../../styles/theme';
import CustomImagePicker, { FileObject } from '../common/CustomImagePicker';
import {
  ImageUploadService,
  EntityWithOptionalPhoto,
} from '../../lib/imageUploadService';
import { ResponsiveModal } from '../responsive/ResponsiveModal';
import { useResponsive } from '../../hooks/useResponsive';

type FieldType =
  | 'text'
  | 'textarea'
  | 'switch'
  | 'number'
  | 'email'
  | 'password';

export interface FormFieldConfig<TFormData extends FieldValues> {
  name: Path<TFormData>;
  label: string;
  type: FieldType;
  placeholder?: string;
  required?: boolean;
  defaultValue?: any;
  inputProps?: any;
  switchProps?: Partial<React.ComponentProps<typeof Switch>>;
  numberOfLines?: number;
  switchLabel?: string;
}

export interface ImagePickerConfig<TFormData extends FieldValues> {
  imageUriField: Path<TFormData>;
  onImageUpload: (file: FileObject) => Promise<{ id: string } | null>;
  determineFinalPhotoId?: (
    currentImageUri: string | null,
    editingItem: EntityWithOptionalPhoto | undefined,
  ) => string | null | undefined;
  imagePickerSize?: number;
  placeholderIcon?: string;
  placeholderText?: string;
}

interface GenericFormModalProps<
  TFormData extends FieldValues,
  TItem extends { id: string },
> {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: TFormData,
    photoId: string | null | undefined,
  ) => Promise<void>;
  formSchema: z.ZodType<TFormData>;
  formFields: FormFieldConfig<TFormData>[];
  imagePickerConfig?: ImagePickerConfig<TFormData>;
  initialValues?: DeepPartial<TFormData>;
  editingItem: (TItem & Partial<EntityWithOptionalPhoto>) | null;
  isSubmitting: boolean;
  modalTitle: (isEditing: boolean) => string;
  submitButtonLabel?: (isEditing: boolean) => string;
  cancelButtonLabel?: string;
  modalStyle?: StyleProp<ViewStyle>;
  formContainerStyle?: StyleProp<ViewStyle>;
  onFileSelected?: (file: FileObject | null) => void;
}

// Componente separado para manejar campos numéricos correctamente
interface NumericInputProps {
  value: number | null | undefined;
  onChange: (value: number | null) => void;
  onBlur: () => void;
  label: string;
  placeholder?: string;
  keyboardType?: any; // Permitir cualquier KeyboardTypeOptions
  error?: boolean;
  disabled?: boolean;
  inputProps?: any;
}

const NumericInput: React.FC<NumericInputProps> = ({
  value,
  onChange,
  onBlur,
  label,
  placeholder,
  keyboardType = 'decimal-pad',
  error,
  disabled,
  inputProps,
}) => {
  const [inputValue, setInputValue] = useState<string>(
    value === null || value === undefined ? '' : String(value),
  );

  useEffect(() => {
    const stringValue =
      value === null || value === undefined ? '' : String(value);
    if (stringValue !== inputValue) {
      const numericValueFromInput = parseFloat(inputValue);
      if (
        !(inputValue.endsWith('.') && numericValueFromInput === value) &&
        !(inputValue === '.' && value === null)
      ) {
        setInputValue(stringValue);
      }
    }
  }, [value, inputValue]);

  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);

  return (
    <TextInput
      label={label}
      value={inputValue}
      onChangeText={(text) => {
        const formattedText = text.replace(/,/g, '.');
        if (/^(\d*\.?\d*)$/.test(formattedText)) {
          setInputValue(formattedText);

          if (formattedText === '' || formattedText === '.') {
            if (value !== null) onChange(null);
          } else {
            const numericValue = parseFloat(formattedText);
            if (!isNaN(numericValue) && numericValue !== value) {
              onChange(numericValue);
            } else if (isNaN(numericValue) && value !== null) {
              onChange(null);
            }
          }
        }
      }}
      onBlur={onBlur}
      mode="outlined"
      style={styles.input}
      placeholder={placeholder}
      keyboardType={keyboardType}
      error={error}
      disabled={disabled}
      {...inputProps}
    />
  );
};

const getDefaultValueForType = (
  type: FieldType,
): string | number | boolean | null | undefined => {
  switch (type) {
    case 'text':
    case 'textarea':
    case 'email':
    case 'password':
      return '';
    case 'number':
      return null;
    case 'switch':
      return false;
    default:
      return undefined;
  }
};

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: responsive.spacing(20),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(40)
        : responsive.spacing(20),
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: responsive.isTablet ? '92%' : '90%',
      maxWidth: responsive.isTablet ? 600 : 500,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
    },
    input: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: responsive.spacing(theme.spacing.m),
      fontSize: responsive.isTablet ? 14 : 16,
      flexShrink: 1,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start',
      marginBottom: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    imagePickerContainer: {
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      minHeight: responsive.isTablet ? 70 : 80,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      flex: 1,
      maxWidth: 200,
      minWidth: responsive.isTablet ? 120 : 140,
    },
    cancelButton: {},
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      zIndex: 10,
    },
    helperText: {
      marginTop: -responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
  });

const GenericFormModal = <
  TFormData extends FieldValues,
  TItem extends { id: string },
>({
  visible,
  onDismiss,
  onSubmit,
  formSchema,
  formFields,
  imagePickerConfig,
  initialValues,
  editingItem,
  isSubmitting: isParentSubmitting,
  modalTitle,
  submitButtonLabel = (isEditing: boolean) => (isEditing ? 'Guardar' : 'Crear'),
  cancelButtonLabel = 'Cancelar',
  modalStyle,
  formContainerStyle,
  onFileSelected,
}: GenericFormModalProps<TFormData, TItem>) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const [isInternalImageUploading, setIsInternalImageUploading] =
    useState(false);
  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(
    null,
  );
  const prevVisibleRef = useRef(visible);
  const prevEditingItemIdRef = useRef(editingItem?.id);

  const isEditing = !!editingItem;
  const isActuallySubmitting = isParentSubmitting || isInternalImageUploading;

  const {
    control,
    handleSubmit,
    reset,
    setValue,
    watch,
    getValues: _getValues,
    formState: { errors },
  }: UseFormReturn<TFormData> = useForm<TFormData>({
    resolver: zodResolver(formSchema) as any,
    defaultValues: useMemo((): DefaultValues<TFormData> => {
      const defaults = formFields.reduce(
        (acc: DefaultValues<TFormData>, field) => {
          acc[field.name] =
            field.defaultValue ?? getDefaultValueForType(field.type);
          return acc;
        },
        {} as DefaultValues<TFormData>,
      );
      return { ...defaults, ...(initialValues as DefaultValues<TFormData>) };
    }, [formFields, initialValues]),
  });

  const watchedImageUri = imagePickerConfig
    ? watch(imagePickerConfig.imageUriField)
    : undefined;
  const currentImageUri =
    typeof watchedImageUri === 'string' ? watchedImageUri : null;

  useEffect(() => {
    const loadInitialData = async () => {
      const justOpened = visible && !prevVisibleRef.current;
      const itemChanged =
        visible && editingItem?.id !== prevEditingItemIdRef.current;

      if (visible) {
        const defaultFormValues = formFields.reduce(
          (acc: DefaultValues<TFormData>, field) => {
            acc[field.name] =
              field.defaultValue ?? getDefaultValueForType(field.type);
            return acc;
          },
          {} as DefaultValues<TFormData>,
        );

        const resetValues = {
          ...defaultFormValues,
          ...(initialValues as DefaultValues<TFormData>),
        };

        reset(resetValues, { keepDirtyValues: !justOpened && !itemChanged });

        if (justOpened || itemChanged) {
          setLocalSelectedFile(null);
          onFileSelected?.(null);
          setIsInternalImageUploading(false);
        }
      }

      prevVisibleRef.current = visible;
      prevEditingItemIdRef.current = editingItem?.id;
    };

    loadInitialData();
  }, [
    visible,
    editingItem?.id,
    reset,
    formFields,
    initialValues,
    onFileSelected,
    imagePickerConfig,
  ]);

  const handleImageSelected = useCallback(
    (uri: string, file: FileObject) => {
      if (imagePickerConfig) {
        const fieldName = imagePickerConfig.imageUriField;
        setValue(fieldName, uri as any, {
          shouldValidate: true,
          shouldDirty: true,
          shouldTouch: true,
        });
        setLocalSelectedFile(file);
        onFileSelected?.(file);
      }
    },
    [setValue, imagePickerConfig, onFileSelected],
  );

  const handleImageRemoved = useCallback(() => {
    if (imagePickerConfig) {
      setValue(imagePickerConfig.imageUriField, null as any, {
        shouldValidate: true,
      });
      setLocalSelectedFile(null);
      onFileSelected?.(null);
    }
  }, [setValue, imagePickerConfig, onFileSelected]);

  const processSubmit: SubmitHandler<TFormData> = async (formData) => {
    if (isActuallySubmitting) return;

    let finalPhotoId: string | null | undefined = undefined;

    if (imagePickerConfig) {
      const formImageUri = imagePickerConfig.imageUriField
        ? formData[imagePickerConfig.imageUriField]
        : null;

      const isNewLocalImage =
        typeof formImageUri === 'string' && formImageUri.startsWith('file://');
      if (isNewLocalImage && localSelectedFile) {
        setIsInternalImageUploading(true);
        try {
          const uploadResult =
            await imagePickerConfig.onImageUpload(localSelectedFile);
          if (uploadResult?.id) {
            finalPhotoId = uploadResult.id;
          } else {
            throw new Error('La subida de la imagen no devolvió un ID.');
          }
        } catch (error) {
          Alert.alert(
            'Error',
            `No se pudo subir la imagen: ${error instanceof Error ? error.message : 'Error desconocido'}`,
          );
          setIsInternalImageUploading(false);
          return;
        } finally {
          setIsInternalImageUploading(false);
        }
      } else {
        const determineFn =
          imagePickerConfig.determineFinalPhotoId ??
          ImageUploadService.determinePhotoId;
        const entityForPhotoCheck = editingItem ?? undefined;
        finalPhotoId = await determineFn(formImageUri, entityForPhotoCheck);
      }
    }

    await onSubmit(formData, finalPhotoId);
  };

  const renderFormField = (fieldConfig: FormFieldConfig<TFormData>) => {
    const fieldName = fieldConfig.name;
    const fieldError = errors[fieldName] as FieldError | undefined;
    const errorMessage = fieldError?.message;

    switch (fieldConfig.type) {
      case 'textarea':
      case 'text':
      case 'number':
      case 'email':
      case 'password':
        return (
          <View key={String(fieldName)}>
            {/* Controller para campos numéricos con manejo de string local y decimales */}
            <Controller
              name={fieldName}
              control={control as Control<FieldValues>}
              render={({ field: { onChange, onBlur, value } }) => {
                if (fieldConfig.type === 'number') {
                  return (
                    <NumericInput
                      value={value}
                      onChange={onChange}
                      onBlur={onBlur}
                      label={fieldConfig.label}
                      placeholder={fieldConfig.placeholder}
                      keyboardType={
                        fieldConfig.inputProps?.keyboardType ?? 'decimal-pad'
                      }
                      error={!!errorMessage}
                      disabled={isActuallySubmitting}
                      inputProps={fieldConfig.inputProps}
                    />
                  );
                } else {
                  return (
                    <TextInput
                      label={fieldConfig.label}
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      mode="outlined"
                      style={styles.input}
                      placeholder={fieldConfig.placeholder}
                      secureTextEntry={fieldConfig.type === 'password'}
                      keyboardType={
                        fieldConfig.type === 'email'
                          ? 'email-address'
                          : 'default'
                      }
                      multiline={fieldConfig.type === 'textarea'}
                      numberOfLines={
                        fieldConfig.numberOfLines ??
                        (fieldConfig.type === 'textarea' ? 3 : 1)
                      }
                      error={!!errorMessage}
                      disabled={isActuallySubmitting}
                      {...fieldConfig.inputProps}
                    />
                  );
                }
              }}
            />
            {errorMessage && (
              <HelperText
                type="error"
                visible={!!errorMessage}
                style={styles.helperText}
              >
                {errorMessage}
              </HelperText>
            )}
          </View>
        );
      case 'switch':
        return (
          <View key={String(fieldName)} style={styles.switchComponentContainer}>
            <Text variant="bodyLarge" style={styles.switchLabel}>
              {fieldConfig.switchLabel ?? fieldConfig.label}
            </Text>
            <Controller
              name={fieldName}
              control={control as Control<FieldValues>}
              render={({ field: { onChange, value } }) => (
                <Switch
                  value={value}
                  onValueChange={onChange}
                  disabled={isActuallySubmitting}
                  style={{ transform: [{ scaleX: 1.5 }, { scaleY: 1.5 }] }}
                  {...fieldConfig.switchProps}
                />
              )}
            />
            {errorMessage && (
              <HelperText
                type="error"
                visible={!!errorMessage}
                style={styles.helperText}
              >
                {errorMessage}
              </HelperText>
            )}
          </View>
        );
      default:
        return null;
    }
  };

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title={modalTitle(isEditing)}
      dismissable={!isActuallySubmitting}
      scrollable={false}
      style={modalStyle}
      contentContainerStyle={styles.modalSurface}
      footer={
        <View style={styles.modalActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[styles.formButton, styles.cancelButton]}
            disabled={isActuallySubmitting}
          >
            {cancelButtonLabel}
          </Button>
          <Button
            mode="contained"
            onPress={() => {
              handleSubmit(processSubmit)();
            }}
            loading={isActuallySubmitting}
            disabled={isActuallySubmitting}
            style={styles.formButton}
          >
            {submitButtonLabel(isEditing)}
          </Button>
        </View>
      }
    >
      <View style={[styles.formContainer, formContainerStyle]}>
        <ScrollView
          contentContainerStyle={styles.scrollViewContent}
          showsVerticalScrollIndicator={false}
        >
          {imagePickerConfig && (
            <View style={styles.imagePickerContainer}>
              <CustomImagePicker
                value={currentImageUri}
                onImageSelected={handleImageSelected}
                onImageRemoved={handleImageRemoved}
                isLoading={isInternalImageUploading}
                disabled={isParentSubmitting}
                size={
                  imagePickerConfig.imagePickerSize ??
                  responsive.getResponsiveDimension(150, 200)
                }
                placeholderIcon={imagePickerConfig.placeholderIcon}
                placeholderText={imagePickerConfig.placeholderText}
              />
              {(
                errors[imagePickerConfig.imageUriField] as
                  | FieldError
                  | undefined
              )?.message && (
                <HelperText
                  type="error"
                  visible={!!errors[imagePickerConfig.imageUriField]}
                  style={styles.helperText}
                >
                  {
                    (
                      errors[imagePickerConfig.imageUriField] as
                        | FieldError
                        | undefined
                    )?.message
                  }
                </HelperText>
              )}
            </View>
          )}

          {formFields.map(renderFormField)}
        </ScrollView>

        {isActuallySubmitting && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator
              animating={true}
              size="large"
              color={theme.colors.primary}
            />
          </View>
        )}
      </View>
    </ResponsiveModal>
  );
};

export default GenericFormModal;

================
File: app/src/app/navigation/components/CustomDrawerContent.tsx
================
import React from 'react';
import { View, StyleSheet, Platform, TouchableOpacity } from 'react-native';
import { DrawerContentScrollView } from '@react-navigation/drawer';
import {
  Drawer as PaperDrawer,
  Text,
  Divider,
  Switch,
  TouchableRipple,
  Icon,
  Surface,
  IconButton,
} from 'react-native-paper';
import { useThemeStore } from '../../store/themeStore';
import { THEME_MODE } from '../../types/theme.types';
import { useAuthStore } from '../../store/authStore';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
import { clearImageCache } from '../../lib/imageCache';
import { useSnackbarStore } from '../../store/snackbarStore';
import {
  hasPermission,
  DRAWER_SECTIONS,
  DrawerSection,
} from '../../constants/rolePermissions';
import { generateNavigationAction } from '../helpers/navigationHelpers';
import { RoleEnum } from '@/modules/users/types/user.types';
import { useNavigation, DrawerActions } from '@react-navigation/native';

import type { DrawerContentComponentProps } from '@react-navigation/drawer';

// Traducciones de roles
const ROLE_TRANSLATIONS: Record<number, string> = {
  [RoleEnum.ADMIN]: 'Administrador',
  [RoleEnum.MANAGER]: 'Gerente',
  [RoleEnum.CASHIER]: 'Cajero',
  [RoleEnum.WAITER]: 'Mesero',
  [RoleEnum.KITCHEN]: 'Cocina',
  [RoleEnum.DELIVERY]: 'Repartidor',
};

const getRoleTranslation = (roleId?: number): string => {
  if (!roleId) return 'Desconocido';
  return ROLE_TRANSLATIONS[roleId] || 'Desconocido';
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    userInfoSection: {
      padding: responsive.spacing(theme.spacing.m),
    },
    title: {
      ...theme.fonts.titleMedium,
      fontSize: responsive.fontSize(theme.fonts.titleMedium.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(4),
    },
    caption: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(2),
    },
    drawerSection: {
      marginTop: responsive.spacing(theme.spacing.s),
    },
    bottomDrawerSection: {
      marginBottom: responsive.spacing(theme.spacing.m),
      marginTop: 'auto',
      borderTopColor: theme.colors.outlineVariant,
      borderTopWidth: StyleSheet.hairlineWidth,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    preference: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
    },
    drawerItemLabel: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
    },
    drawerItemContainer: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      flexDirection: 'row',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xxs),
    },
    drawerItemActive: {
      backgroundColor: theme.colors.primaryContainer,
    },
    drawerItemIconContainer: {
      marginRight: responsive.spacing(theme.spacing.l),
      width: responsive.isTablet ? 20 : theme.spacing.l,
      alignItems: 'center',
    },
    divider: {
      marginVertical: responsive.spacing(theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m),
    },

    configSubheader: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
      color: theme.colors.onSurfaceVariant,
      paddingLeft: responsive.spacing(theme.spacing.l),
      paddingRight: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xxs),
    },
  });

export function CustomDrawerContent(props: DrawerContentComponentProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const logout = useAuthStore((state) => state.logout);
  const setThemePreference = useThemeStore((state) => state.setThemePreference);
  const user = useAuthStore((state) => state.user);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const navigation = useNavigation<any>();

  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  const getItemActive = (routeName: string) => {
    const currentRoute = props.state.routes[props.state.index];
    return currentRoute?.name === routeName;
  };

  const getItemColor = (routeName: string) => {
    return getItemActive(routeName)
      ? theme.colors.primary
      : theme.colors.onSurfaceVariant;
  };

  const renderDrawerItem = (
    routeName: string,
    label: string,
    iconName: string,
    navigateToScreen: () => void,
  ) => {
    // Verificar permisos antes de renderizar
    if (!hasPermission(user?.role?.id, routeName as DrawerSection)) {
      return null;
    }

    const isActive = getItemActive(routeName);

    return (
      <TouchableRipple
        key={routeName}
        onPress={navigateToScreen}
        style={[
          styles.drawerItemContainer,
          isActive && styles.drawerItemActive,
        ]}
        rippleColor={`${theme.colors.primary}20`}
      >
        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
          <View style={styles.drawerItemIconContainer}>
            <Icon
              source={iconName}
              size={responsive.isTablet ? 20 : 24}
              color={getItemColor(routeName)}
            />
          </View>
          <Text
            style={[styles.drawerItemLabel, { color: getItemColor(routeName) }]}
          >
            {label}
          </Text>
        </View>
      </TouchableRipple>
    );
  };

  // Helper simplificado para renderizar items del drawer
  const renderDrawerItemSimple = (
    route: DrawerSection,
    label: string,
    icon: string,
  ) => {
    return renderDrawerItem(route, label, icon, () => {
      // For kitchen users in KitchenOnlyNavigator, handle navigation differently
      const isKitchenUser = user?.role?.id === 5;
      if (isKitchenUser && route === 'KitchenStack') {
        // Simply navigate to the Kitchen screen without reset
        props.navigation.navigate('Kitchen');
      } else {
        const action = generateNavigationAction(route, user?.role?.id);
        if (action) {
          props.navigation.dispatch(action);
        }
      }
    });
  };

  const handleClearCache = async () => {
    try {
      await clearImageCache();
      showSnackbar({
        message: 'Caché de imágenes limpiado exitosamente',
        type: 'success',
      });
    } catch (error) {
      showSnackbar({
        message: 'Error al limpiar el caché',
        type: 'error',
      });
    }
  };

  return (
    <Surface
      style={{
        flex: 1,
        backgroundColor: theme.colors.surface,
      }}
      elevation={0}
    >
      <DrawerContentScrollView
        {...props}
        contentContainerStyle={{ paddingTop: 0 }}
      >
        <View style={styles.container}>
          <Surface style={styles.userInfoSection} elevation={0}>
            {user ? (
              <>
                <Text style={styles.title} numberOfLines={1}>
                  {`${user.firstName ?? ''} ${user.lastName ?? ''}`.trim() ||
                    user.username ||
                    'Usuario'}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  Rol: {getRoleTranslation(user.role?.id)}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  {user.email ?? ''}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  @{user.username ?? 'username'}
                </Text>
              </>
            ) : (
              <Text style={styles.title}>Invitado</Text>
            )}
          </Surface>
          <Divider style={styles.divider} />

          {/* Sección de Ventas - Solo visible si tiene permisos */}
          {DRAWER_SECTIONS.sales.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>
                {DRAWER_SECTIONS.sales.title}
              </Text>
              {DRAWER_SECTIONS.sales.items.map((item) =>
                renderDrawerItemSimple(
                  item.route as DrawerSection,
                  item.label,
                  item.icon,
                ),
              )}
            </PaperDrawer.Section>
          )}

          {/* Sección de Cocina - Solo para usuarios con rol kitchen */}
          {hasPermission(user?.role?.id, 'KitchenStack') && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>Cocina</Text>
              {renderDrawerItemSimple(
                'KitchenStack',
                'Pantalla de Preparación',
                'chef-hat',
              )}
            </PaperDrawer.Section>
          )}

          {/* Sección de Configuración - Solo visible si tiene permisos */}
          {DRAWER_SECTIONS.configuration.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <>
              <Divider style={styles.divider} />
              <PaperDrawer.Section style={styles.drawerSection}>
                <Text style={styles.configSubheader}>
                  {DRAWER_SECTIONS.configuration.title}
                </Text>
                {DRAWER_SECTIONS.configuration.items.map((item) =>
                  renderDrawerItemSimple(
                    item.route as DrawerSection,
                    item.label,
                    item.icon,
                  ),
                )}
              </PaperDrawer.Section>
            </>
          )}

          {/* Sección de Administración - Solo visible si tiene permisos */}
          {DRAWER_SECTIONS.administration.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <>
              <Divider style={styles.divider} />

              <PaperDrawer.Section style={styles.drawerSection}>
                <Text style={styles.configSubheader}>
                  {DRAWER_SECTIONS.administration.title}
                </Text>
                {DRAWER_SECTIONS.administration.items.map((item) =>
                  renderDrawerItemSimple(
                    item.route as DrawerSection,
                    item.label,
                    item.icon,
                  ),
                )}
              </PaperDrawer.Section>
            </>
          )}
        </View>
      </DrawerContentScrollView>

      <PaperDrawer.Section style={styles.bottomDrawerSection}>
        <TouchableRipple
          onPress={() => {
            const newPreference = theme.dark
              ? THEME_MODE.LIGHT
              : THEME_MODE.DARK;
            setThemePreference(newPreference);
          }}
          style={styles.preference}
        >
          <View
            style={{
              flexDirection: 'row',
              alignItems: 'center',
              justifyContent: 'space-between',
              width: '100%',
            }}
          >
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              <View style={styles.drawerItemIconContainer}>
                <Icon
                  source={theme.dark ? 'weather-night' : 'white-balance-sunny'}
                  size={responsive.isTablet ? 20 : 24}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
              <Text
                style={[
                  styles.drawerItemLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                Modo Oscuro
              </Text>
            </View>
            <View style={{ pointerEvents: 'none' }}>
              <Switch value={theme.dark} color={theme.colors.primary} />
            </View>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={handleClearCache}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="broom"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Limpiar Caché
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            props.navigation.navigate('ServerSettings');
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="server-network"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Configuración del Servidor
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            logout();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.error}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="logout"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.error}
              />
            </View>
            <Text
              style={[styles.drawerItemLabel, { color: theme.colors.error }]}
            >
              Cerrar Sesión
            </Text>
          </View>
        </TouchableRipple>
      </PaperDrawer.Section>
    </Surface>
  );
}

================
File: app/src/app/schemas/domain/order.schema.ts
================
import { z } from 'zod';
import { adjustmentSchema } from './adjustment.schema';
import { DeliveryInfoSchema } from './delivery-info.schema';
import { tableSchema } from './table.schema';

// Definir enums localmente para evitar dependencias circulares
enum PizzaHalf {
  FULL = 'FULL',
  HALF_1 = 'HALF_1',
  HALF_2 = 'HALF_2',
}

enum CustomizationAction {
  ADD = 'ADD',
  REMOVE = 'REMOVE',
}

// Enum para los estados de la orden
export const orderStatusSchema = z.enum([
  'PENDING',
  'IN_PROGRESS',
  'IN_PREPARATION',
  'READY',
  'DELIVERED',
  'COMPLETED',
  'CANCELLED',
]);
export type OrderStatus = z.infer<typeof orderStatusSchema>;

// Enum para los tipos de orden
export const orderTypeSchema = z.enum(['DINE_IN', 'TAKE_AWAY', 'DELIVERY']);
export type OrderType = z.infer<typeof orderTypeSchema>;

// Schema para los modificadores dentro de un ítem de orden
export const orderItemModifierSchema = z.object({
  productModifierId: z.string(),
  modifierName: z.string(),
  price: z.number(),
});
export type OrderItemModifier = z.infer<typeof orderItemModifierSchema>;

// Schema para las personalizaciones de pizza seleccionadas
export const selectedPizzaCustomizationSchema = z.object({
  pizzaCustomizationId: z.string(),
  pizzaCustomization: z
    .object({
      id: z.string(),
      name: z.string(),
      type: z.enum(['FLAVOR', 'INGREDIENT']),
      ingredients: z.string().nullable().optional(),
      toppingValue: z.number(),
      isActive: z.boolean(),
      sortOrder: z.number(),
    })
    .optional(),
  half: z.nativeEnum(PizzaHalf),
  action: z.nativeEnum(CustomizationAction),
});
export type SelectedPizzaCustomization = z.infer<
  typeof selectedPizzaCustomizationSchema
>;

// Schema para un ítem individual de la orden
export const orderItemSchema = z.object({
  id: z.string(),
  productId: z.string().uuid(),
  productName: z.string(),
  quantity: z.number().int().positive(),
  unitPrice: z.number(),
  totalPrice: z.number(),
  modifiers: z.array(orderItemModifierSchema),
  variantId: z.string().uuid().nullable().optional(),
  variantName: z.string().nullable().optional(),
  notes: z.string().nullable().optional(),
  selectedPizzaCustomizations: z
    .array(selectedPizzaCustomizationSchema)
    .optional(),
});
export type OrderItem = z.infer<typeof orderItemSchema>;

// Schema para la orden completa
export const orderSchema = z.object({
  id: z.string().uuid(),
  orderNumber: z.string().optional(),
  shiftOrderNumber: z.number().int().positive(),
  orderItems: z.array(z.any()).optional(),
  total: z.union([z.string(), z.number()]).optional(),
  orderStatus: orderStatusSchema,
  orderType: orderTypeSchema,
  createdAt: z.union([z.string().datetime(), z.date()]),
  updatedAt: z.union([z.string().datetime(), z.date()]),
  finalizedAt: z.union([z.string().datetime(), z.date()]).nullable().optional(),
  userId: z.string().uuid().nullable().optional(),
  tableId: z.string().uuid().nullable().optional(),
  notes: z.string().nullable().optional(),
  scheduledAt: z.union([z.string().datetime(), z.date()]).nullable().optional(),
  deliveryInfo: DeliveryInfoSchema,
  user: z.any().optional(),
  table: tableSchema.optional(),
  payments: z.array(z.any()).optional(),
  deletedAt: z.string().nullable().optional(),
  adjustments: z.array(adjustmentSchema).optional(),
  subtotal: z.union([z.string(), z.number()]).optional(),
  isFromWhatsApp: z.boolean().optional().default(false),
  estimatedDeliveryTime: z
    .union([z.string().datetime(), z.date()])
    .nullable()
    .optional(),
});
export type Order = z.infer<typeof orderSchema>;

================
File: app/src/app/utils/networkDiagnostics.ts
================
import axios from 'axios';
import NetInfo from '@react-native-community/netinfo';
import { serverConnectionService } from '@/services/serverConnectionService';
import { API_PATHS } from '@/app/constants/apiPaths';

interface NetworkDiagnosticResult {
  timestamp: Date;
  apiUrl: string;
  networkState: {
    isConnected: boolean | null;
    isInternetReachable: boolean | null;
    type: string;
    details: any;
  };
  apiTest: {
    success: boolean;
    responseTime?: number;
    error?: string;
    errorCode?: string;
  };
  dnsTest: {
    success: boolean;
    responseTime?: number;
    error?: string;
  };
  recommendations: string[];
}

export async function runNetworkDiagnostics(): Promise<NetworkDiagnosticResult> {
  // Obtener la URL del servicio de conexión sin provocar discovery
  const connectionState = serverConnectionService.getState();
  const apiUrl = connectionState.serverUrl || '';

  const result: NetworkDiagnosticResult = {
    timestamp: new Date(),
    apiUrl: apiUrl || 'URL no disponible',
    networkState: {
      isConnected: null,
      isInternetReachable: null,
      type: 'unknown',
      details: null,
    },
    apiTest: {
      success: false,
    },
    dnsTest: {
      success: false,
    },
    recommendations: [],
  };

  // Iniciando diagnóstico de red...

  // 1. Verificar estado de la red
  try {
    const netInfoState = await NetInfo.fetch();
    result.networkState = {
      isConnected: netInfoState.isConnected,
      isInternetReachable: netInfoState.isInternetReachable,
      type: netInfoState.type,
      details: netInfoState.details,
    };
    // Estado de red obtenido
  } catch (error: any) {
    // Error obteniendo estado de red
  }

  // 2. Probar conexión directa a la API
  const apiStartTime = Date.now();
  try {
    // Probando conexión a API
    const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
    const response = await axios.get(`${baseUrl}${API_PATHS.HEALTH}`, {
      timeout: 5000,
      validateStatus: () => true, // Aceptar cualquier status
    });
    const responseTime = Date.now() - apiStartTime;

    result.apiTest = {
      success: response.status < 500,
      responseTime,
      error: response.status >= 500 ? `Status ${response.status}` : undefined,
    };
    // Resultado API test obtenido
  } catch (error: any) {
    const responseTime = Date.now() - apiStartTime;
    result.apiTest = {
      success: false,
      responseTime,
      error: error.message,
      errorCode: error.code,
    };
    // Error en API test
  }

  // 3. Probar resolución DNS con un servicio externo
  const dnsStartTime = Date.now();
  try {
    // Probando DNS con servicio externo...
    await axios.get('https://dns.google/resolve?name=google.com', {
      timeout: 5000,
    });
    const responseTime = Date.now() - dnsStartTime;

    result.dnsTest = {
      success: true,
      responseTime,
    };
    // DNS test exitoso
  } catch (error: any) {
    const responseTime = Date.now() - dnsStartTime;
    result.dnsTest = {
      success: false,
      responseTime,
      error: error.message,
    };
    // Error en DNS test
  }

  // 4. Generar recomendaciones basadas en los resultados
  if (!result.networkState.isConnected) {
    result.recommendations.push(
      'No hay conexión de red. Verifica tu WiFi o datos móviles.',
    );
  }

  if (
    result.networkState.isConnected &&
    !result.networkState.isInternetReachable
  ) {
    result.recommendations.push(
      'Conectado a la red pero sin acceso a Internet. Verifica tu router o punto de acceso.',
    );
  }

  if (!result.apiTest.success && result.apiTest.errorCode === 'ECONNREFUSED') {
    result.recommendations.push(
      'El servidor backend no está respondiendo. Verifica que esté en ejecución.',
    );
  }

  if (!result.apiTest.success && result.apiTest.errorCode === 'ETIMEDOUT') {
    result.recommendations.push(
      'Timeout al conectar con el servidor. Posible problema de red local o firewall.',
    );
  }

  if (!result.apiTest.success && result.apiTest.errorCode === 'ENOTFOUND') {
    result.recommendations.push(
      'No se puede resolver la dirección del servidor. Verifica la configuración de API_URL.',
    );
  }

  if (result.apiTest.responseTime && result.apiTest.responseTime > 3000) {
    result.recommendations.push(
      'La latencia de red es muy alta. Considera acercarte al router o usar una conexión más estable.',
    );
  }

  if (!result.dnsTest.success) {
    result.recommendations.push(
      'Problemas con la resolución DNS. Intenta cambiar los servidores DNS de tu red.',
    );
  }

  // Recomendaciones específicas para el problema del PC
  if (
    result.apiTest.errorCode === 'ECONNRESET' ||
    result.apiTest.errorCode === 'ECONNABORTED'
  ) {
    result.recommendations.push(
      'La conexión se está interrumpiendo. Posibles causas:',
    );
    result.recommendations.push('- Firewall o antivirus interfiriendo');
    result.recommendations.push('- Problemas con el adaptador de red');
    result.recommendations.push(
      '- Configuración de ahorro de energía en el adaptador',
    );
    result.recommendations.push('- Driver de red desactualizado');
  }

  // Diagnóstico completo
  return result;
}

export function formatDiagnosticResult(
  result: NetworkDiagnosticResult,
): string {
  let output = '=== DIAGNÓSTICO DE RED ===\n\n';

  output += `Fecha: ${result.timestamp.toLocaleString()}\n`;
  output += `URL de API: ${result.apiUrl}\n\n`;

  output += '📡 ESTADO DE RED:\n';
  output += `- Conectado: ${result.networkState.isConnected ? 'Sí' : 'No'}\n`;
  output += `- Internet accesible: ${result.networkState.isInternetReachable ? 'Sí' : 'No'}\n`;
  output += `- Tipo: ${result.networkState.type}\n\n`;

  output += '🔌 TEST DE API:\n';
  output += `- Exitoso: ${result.apiTest.success ? 'Sí' : 'No'}\n`;
  if (result.apiTest.responseTime) {
    output += `- Tiempo de respuesta: ${result.apiTest.responseTime}ms\n`;
  }
  if (result.apiTest.error) {
    output += `- Error: ${result.apiTest.error}\n`;
    output += `- Código: ${result.apiTest.errorCode || 'N/A'}\n`;
  }
  output += '\n';

  output += '🌐 TEST DNS:\n';
  output += `- Exitoso: ${result.dnsTest.success ? 'Sí' : 'No'}\n`;
  if (result.dnsTest.responseTime) {
    output += `- Tiempo de respuesta: ${result.dnsTest.responseTime}ms\n`;
  }
  if (result.dnsTest.error) {
    output += `- Error: ${result.dnsTest.error}\n`;
  }
  output += '\n';

  if (result.recommendations.length > 0) {
    output += '💡 RECOMENDACIONES:\n';
    result.recommendations.forEach((rec) => {
      output += `- ${rec}\n`;
    });
  }

  return output;
}

================
File: app/src/app/utils/roleUtils.ts
================
import type { User } from '@/modules/auth/schema/auth.schema';

/**
 * Enum de roles basado en los IDs del backend
 */
export enum RoleEnum {
  ADMIN = 1,
  MANAGER = 2,
  CASHIER = 3,
  WAITER = 4,
  KITCHEN = 5,
}

/**
 * Verifica si el usuario tiene un rol específico
 */
export const hasRole = (user: User | null, roleId: RoleEnum): boolean => {
  return user?.role?.id === roleId;
};

/**
 * Verifica si el usuario tiene alguno de los roles especificados
 */
export const hasAnyRole = (user: User | null, roleIds: RoleEnum[]): boolean => {
  if (!user?.role?.id) return false;
  return roleIds.includes(user.role.id);
};

/**
 * Verificaciones de roles específicos
 */
export const isAdmin = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.ADMIN);
};

export const isManager = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.MANAGER);
};

export const isCashier = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.CASHIER);
};

export const isWaiter = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.WAITER);
};

export const isKitchen = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.KITCHEN);
};

/**
 * Permisos específicos de funcionalidad
 */
export const canOpenShift = (user: User | null): boolean => {
  return hasAnyRole(user, [RoleEnum.ADMIN, RoleEnum.MANAGER]);
};

export const canRegisterPayments = (user: User | null): boolean => {
  return hasAnyRole(user, [RoleEnum.ADMIN, RoleEnum.MANAGER, RoleEnum.CASHIER]);
};

export const canManageOrders = (user: User | null): boolean => {
  return hasAnyRole(user, [
    RoleEnum.ADMIN,
    RoleEnum.MANAGER,
    RoleEnum.WAITER,
    RoleEnum.CASHIER,
  ]);
};

export const canAccessKitchen = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.KITCHEN);
};

/**
 * Obtiene el nombre del rol para mostrar en la UI
 */
export const getRoleName = (user: User | null): string => {
  if (!user?.role) return 'Sin rol';

  // Usar el nombre del rol si está disponible
  if (user.role.name) {
    return user.role.name;
  }

  // Fallback basado en el ID
  switch (user.role.id) {
    case RoleEnum.ADMIN:
      return 'Administrador';
    case RoleEnum.MANAGER:
      return 'Gerente';
    case RoleEnum.CASHIER:
      return 'Cajero';
    case RoleEnum.WAITER:
      return 'Mesero';
    case RoleEnum.KITCHEN:
      return 'Cocina';
    default:
      return 'Usuario';
  }
};

================
File: app/src/modules/auth/components/LoginForm.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Text } from 'react-native';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import {
  TextInput,
  Button,
  HelperText,
  Checkbox,
  TouchableRipple,
} from 'react-native-paper';
import { useAppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { loginSchema, LoginFormInputs } from '../schema/auth.schema';

interface LoginFormProps {
  onSubmit: (data: LoginFormInputs, rememberMe: boolean) => void;
  isLoading: boolean;
  initialEmailOrUsername?: string;
  initialPassword?: string;
  initialRememberMe?: boolean;
}

const LoginForm: React.FC<LoginFormProps> = ({
  onSubmit,
  isLoading,
  initialEmailOrUsername = '',
  initialPassword = '',
  initialRememberMe = false,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const [secureTextEntry, setSecureTextEntry] = useState(true);
  const [rememberMe, setRememberMe] = useState(initialRememberMe);

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<LoginFormInputs>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      emailOrUsername: initialEmailOrUsername,
      password: initialPassword,
    },
  });

  React.useEffect(() => {
    if (initialEmailOrUsername || initialPassword) {
      reset({
        emailOrUsername: initialEmailOrUsername || '',
        password: initialPassword || '',
      });
    }
  }, [initialEmailOrUsername, initialPassword, reset]);

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        container: {
          width: '100%',
        },
        input: {
          marginBottom: 8,
          fontSize: responsive.fontSizePreset.m,
        },
        firstInput: {
          marginTop: responsive.spacingPreset.xs,
        },
        button: {
          marginTop: 16,
          paddingVertical: responsive.spacingPreset.xs,
        },
        helperText: {
          marginBottom: responsive.spacingPreset.xs,
          fontSize: responsive.fontSizePreset.s,
        },
        checkboxContainer: {
          flexDirection: 'row',
          alignItems: 'center',
          marginTop: 4,
          marginBottom: 8,
        },
        checkbox: {},
        checkboxLabel: {
          color: theme.colors.onSurface,
          marginLeft: responsive.spacingPreset.s,
          flex: 1,
          flexShrink: 1,
          fontSize: responsive.fontSizePreset.m,
        },
      }),
    [theme, responsive],
  );

  return (
    <View style={styles.container}>
      <Controller
        control={control}
        name="emailOrUsername"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Correo o Usuario"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              error={!!errors.emailOrUsername}
              style={[styles.input, styles.firstInput]}
              autoCapitalize="none"
              keyboardType="email-address"
              disabled={isLoading}
            />
            {errors.emailOrUsername && (
              <HelperText
                type="error"
                visible={!!errors.emailOrUsername}
                style={styles.helperText}
              >
                <Text>{errors.emailOrUsername?.message}</Text>
              </HelperText>
            )}
          </View>
        )}
      />

      <Controller
        control={control}
        name="password"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Contraseña"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              secureTextEntry={secureTextEntry}
              error={!!errors.password}
              style={styles.input}
              autoCapitalize="none"
              right={
                <TextInput.Icon
                  icon={secureTextEntry ? 'eye' : 'eye-off'}
                  onPress={toggleSecureEntry}
                  forceTextInputFocus={false}
                  color={errors.password ? theme.colors.error : undefined}
                />
              }
              disabled={isLoading}
            />
            {errors.password && (
              <HelperText
                type="error"
                visible={!!errors.password}
                style={styles.helperText}
              >
                <Text>{errors.password?.message}</Text>
              </HelperText>
            )}
          </View>
        )}
      />

      <TouchableRipple
        onPress={() => !isLoading && setRememberMe(!rememberMe)}
        style={styles.checkboxContainer}
        disabled={isLoading}
      >
        <>
          <Checkbox
            status={rememberMe ? 'checked' : 'unchecked'}
            onPress={() => setRememberMe(!rememberMe)}
            disabled={isLoading}
          />
          <Text
            style={styles.checkboxLabel}
            numberOfLines={1}
            adjustsFontSizeToFit
            minimumFontScale={0.8}
            disabled={isLoading}
          >
            Recordarme
          </Text>
        </>
      </TouchableRipple>

      <Button
        mode="contained"
        onPress={handleSubmit((data) => onSubmit(data, rememberMe))}
        loading={isLoading}
        disabled={isLoading}
        style={[
          styles.button,
          {
            backgroundColor: theme.colors.primary,
            borderRadius: 30,
          },
        ]}
        contentStyle={{
          height: 42,
          paddingHorizontal: responsive.spacingPreset.s,
        }}
        labelStyle={{
          fontSize: responsive.fontSizePreset.m,
          fontWeight: '600',
        }}
      >
        {isLoading ? 'Ingresando...' : 'Ingresar'}
      </Button>
    </View>
  );
};

export default LoginForm;

================
File: app/src/modules/availability/components/CategoryAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch, Divider, IconButton } from 'react-native-paper';
import { CategoryAvailability } from '../types/availability.types';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';

interface CategoryAvailabilityItemProps {
  category: CategoryAvailability;
  onRefresh?: () => void;
}

export const CategoryAvailabilityItem: React.FC<
  CategoryAvailabilityItemProps
> = ({ category, onRefresh: _onRefresh }) => {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();

  const handleCategoryToggle = (value: boolean) => {
    updateAvailability.mutate({
      type: 'category',
      id: category.id,
      isActive: value,
      cascade: true,
    });
  };

  const handleSubcategoryToggle = (subcategoryId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'subcategory',
      id: subcategoryId,
      isActive: value,
      cascade: true,
    });
  };

  const handleProductToggle = (productId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'product',
      id: productId,
      isActive: value,
    });
  };

  const totalProducts = category.subcategories.reduce(
    (acc, sub) => acc + sub.products.length,
    0,
  );
  const activeProducts = category.subcategories.reduce(
    (acc, sub) => acc + sub.products.filter((p) => p.isActive).length,
    0,
  );

  return (
    <AvailabilityListItem
      title={category.name}
      subtitle={`${activeProducts}/${totalProducts} productos activos`}
      icon="folder-outline"
      isActive={category.isActive}
      onToggle={handleCategoryToggle}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      {category.subcategories.map((subcategory, index) => (
        <View key={subcategory.id}>
          {index > 0 && <Divider style={styles.divider} />}
          <View
            style={[
              styles.subcategoryHeader,
              { opacity: subcategory.isActive ? 1 : 0.6 },
            ]}
          >
            <View style={styles.subcategoryLeft}>
              <IconButton
                icon="folder-open-outline"
                size={16}
                iconColor={
                  subcategory.isActive
                    ? theme.colors.primary
                    : theme.colors.outline
                }
                style={{ margin: 0, marginRight: 8 }}
              />
              <Text
                style={[
                  styles.subcategoryTitle,
                  { color: theme.colors.onSurface },
                ]}
              >
                {subcategory.name}
              </Text>
            </View>
            <Switch
              value={subcategory.isActive}
              onValueChange={(value) =>
                handleSubcategoryToggle(subcategory.id, value)
              }
              disabled={!category.isActive}
            />
          </View>
          <View style={styles.productsContainer}>
            {subcategory.products.map((product) => (
              <View
                key={product.id}
                style={[
                  styles.productItem,
                  { opacity: !product.isActive ? 0.5 : 1 },
                ]}
              >
                <Text
                  style={[
                    styles.productTitle,
                    !product.isActive && styles.strikethrough,
                    { color: theme.colors.onSurface },
                  ]}
                >
                  {product.name}
                </Text>
                <Switch
                  value={product.isActive}
                  onValueChange={(value) =>
                    handleProductToggle(product.id, value)
                  }
                  disabled={!category.isActive || !subcategory.isActive}
                />
              </View>
            ))}
          </View>
        </View>
      ))}
    </AvailabilityListItem>
  );
};

const styles = StyleSheet.create({
  divider: {
    marginVertical: 8,
  },
  subcategoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
  },
  subcategoryLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  subcategoryTitle: {
    fontSize: 14,
    fontWeight: '500',
  },
  productsContainer: {
    paddingLeft: 16,
  },
  productItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  productTitle: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
});

================
File: app/src/modules/availability/components/PizzaCustomizationAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch, Divider } from 'react-native-paper';
import { PizzaCustomizationGroupAvailability } from '../types/availability.types';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';

interface PizzaCustomizationAvailabilityItemProps {
  group: PizzaCustomizationGroupAvailability;
}

export function PizzaCustomizationAvailabilityItem({
  group,
}: PizzaCustomizationAvailabilityItemProps) {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();

  const handleToggle = (id: string, currentState: boolean) => {
    updateAvailability.mutate({
      type: 'pizzaCustomization',
      id,
      isActive: !currentState,
    });
  };

  const activeCount = group.items.filter((item) => item.isActive).length;
  const totalCount = group.items.length;
  const allActive = activeCount === totalCount;
  const someActive = activeCount > 0 && activeCount < totalCount;

  const getTypeIcon = () => {
    return group.type === 'FLAVOR' ? 'pizza' : 'cheese';
  };

  const getTypeLabel = () => {
    return group.type === 'FLAVOR' ? 'Sabores' : 'Ingredientes';
  };

  const getSubtitle = () => {
    if (allActive) return 'Todos disponibles';
    if (!allActive && !someActive) return 'Ninguno disponible';
    return `${activeCount} de ${totalCount} disponibles`;
  };

  return (
    <AvailabilityListItem
      title={getTypeLabel()}
      subtitle={getSubtitle()}
      icon={getTypeIcon()}
      isActive={allActive}
      onToggle={() => {}} // No toggle para el grupo completo en este caso
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      {group.items.map((item, index) => (
        <React.Fragment key={item.id}>
          <View style={styles.item}>
            <Text
              style={[
                styles.itemName,
                !item.isActive && styles.strikethrough,
                { color: theme.colors.onSurface },
              ]}
            >
              {item.name}
            </Text>
            <Switch
              value={item.isActive}
              onValueChange={() => handleToggle(item.id, item.isActive)}
            />
          </View>
          {index < group.items.length - 1 && <Divider style={styles.divider} />}
        </React.Fragment>
      ))}
    </AvailabilityListItem>
  );
}

const styles = StyleSheet.create({
  item: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  itemName: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
  divider: {
    marginVertical: 8,
  },
});

================
File: app/src/modules/availability/screens/AvailabilityScreen.tsx
================
import React, { useState, useMemo, useCallback } from 'react';
import { View, StyleSheet, RefreshControl, FlatList } from 'react-native';
import {
  Searchbar,
  SegmentedButtons as _SegmentedButtons,
  ActivityIndicator,
  Surface,
  Text,
  Menu,
  IconButton,
  Badge as _Badge,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { CategoryAvailabilityItem } from '../components/CategoryAvailabilityItem';
import { ModifierGroupAvailabilityItem } from '../components/ModifierGroupAvailabilityItem';
import { PizzaCustomizationAvailabilityItem } from '../components/PizzaCustomizationAvailabilityItem';
import {
  useMenuAvailability,
  useModifierGroupsAvailability,
} from '../hooks/useAvailabilityQueries';
import { usePizzaCustomizationsAvailability } from '../hooks/usePizzaCustomizationsAvailability';
import EmptyState from '@/app/components/common/EmptyState';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

export const AvailabilityScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [searchQuery, setSearchQuery] = useState('');
  const [viewMode, setViewMode] = useState<
    'menu' | 'modifiers' | 'pizzaCustomizations'
  >('menu');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);

  const {
    data: menuData,
    isLoading: isLoadingMenu,
    isError: isErrorMenu,
    refetch: refetchMenu,
  } = useMenuAvailability();

  const {
    data: modifiersData,
    isLoading: isLoadingModifiers,
    isError: isErrorModifiers,
    refetch: refetchModifiers,
  } = useModifierGroupsAvailability();

  const {
    data: pizzaCustomizationsData,
    isLoading: isLoadingPizzaCustomizations,
    isError: isErrorPizzaCustomizations,
    refetch: refetchPizzaCustomizations,
  } = usePizzaCustomizationsAvailability(searchQuery);

  // Recargar automáticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('availability');

  const handleRefresh = useCallback(() => {
    if (viewMode === 'menu') {
      refetchMenu();
    } else if (viewMode === 'modifiers') {
      refetchModifiers();
    } else {
      refetchPizzaCustomizations();
    }
  }, [viewMode, refetchMenu, refetchModifiers, refetchPizzaCustomizations]);

  const filteredMenuData = useMemo(() => {
    if (!menuData) return [];

    return menuData
      .map((category) => ({
        ...category,
        subcategories: category.subcategories
          .map((subcategory) => ({
            ...subcategory,
            products: subcategory.products.filter((product) => {
              const matchesSearch = product.name
                .toLowerCase()
                .includes(searchQuery.toLowerCase());
              return matchesSearch;
            }),
          }))
          .filter((subcategory) => subcategory.products.length > 0),
      }))
      .filter((category) => category.subcategories.length > 0);
  }, [menuData, searchQuery]);

  const filteredModifiersData = useMemo(() => {
    if (!modifiersData) return [];

    return modifiersData
      .map((group) => ({
        ...group,
        modifiers: group.modifiers.filter((modifier) => {
          const matchesSearch = modifier.name
            .toLowerCase()
            .includes(searchQuery.toLowerCase());
          return matchesSearch;
        }),
      }))
      .filter((group) => {
        const matchesSearch = group.name
          .toLowerCase()
          .includes(searchQuery.toLowerCase());
        return matchesSearch || group.modifiers.length > 0;
      });
  }, [modifiersData, searchQuery]);

  const isLoading =
    viewMode === 'menu'
      ? isLoadingMenu
      : viewMode === 'modifiers'
        ? isLoadingModifiers
        : isLoadingPizzaCustomizations;

  const isError =
    viewMode === 'menu'
      ? isErrorMenu
      : viewMode === 'modifiers'
        ? isErrorModifiers
        : isErrorPizzaCustomizations;

  const isEmpty =
    viewMode === 'menu'
      ? filteredMenuData.length === 0
      : viewMode === 'modifiers'
        ? filteredModifiersData.length === 0
        : !pizzaCustomizationsData || pizzaCustomizationsData.length === 0;

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      edges={['top']}
    >
      <Surface style={styles.header} elevation={2}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder={`Buscar ${viewMode === 'menu' ? 'productos' : viewMode === 'modifiers' ? 'modificadores' : 'ingredientes y sabores'}...`}
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            icon="magnify"
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={
                    viewMode === 'menu'
                      ? 'food'
                      : viewMode === 'modifiers'
                        ? 'tune'
                        : 'cheese'
                  }
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setViewMode('menu');
                  setFilterMenuVisible(false);
                }}
                title="Menú"
                leadingIcon="food"
                trailingIcon={viewMode === 'menu' ? 'check' : undefined}
                titleStyle={
                  viewMode === 'menu'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setViewMode('modifiers');
                  setFilterMenuVisible(false);
                }}
                title="Modificadores"
                leadingIcon="tune"
                trailingIcon={viewMode === 'modifiers' ? 'check' : undefined}
                titleStyle={
                  viewMode === 'modifiers'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setViewMode('pizzaCustomizations');
                  setFilterMenuVisible(false);
                }}
                title="Ingredientes Pizza"
                leadingIcon="cheese"
                trailingIcon={
                  viewMode === 'pizzaCustomizations' ? 'check' : undefined
                }
                titleStyle={
                  viewMode === 'pizzaCustomizations'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
            </Menu>
          </View>
        </View>
      </Surface>

      <View style={styles.content}>
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text
              style={[
                styles.loadingText,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Cargando{' '}
              {viewMode === 'menu'
                ? 'categorías'
                : viewMode === 'modifiers'
                  ? 'modificadores'
                  : 'ingredientes'}
              ...
            </Text>
          </View>
        ) : isError ? (
          <EmptyState
            title="Error al cargar datos"
            message="No se pudieron cargar los datos. Verifica tu conexión."
            icon="alert-circle-outline"
            actionLabel="Reintentar"
            onAction={handleRefresh}
          />
        ) : isEmpty ? (
          <EmptyState
            title="No se encontraron resultados"
            message={
              searchQuery
                ? 'Intenta con otros términos de búsqueda'
                : 'No hay elementos para mostrar'
            }
            icon="magnify"
          />
        ) : viewMode === 'menu' ? (
          <FlatList
            data={filteredMenuData}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => (
              <CategoryAvailabilityItem
                category={item}
                onRefresh={handleRefresh}
              />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        ) : viewMode === 'modifiers' ? (
          <FlatList
            data={filteredModifiersData}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => (
              <ModifierGroupAvailabilityItem
                modifierGroup={item}
                onRefresh={handleRefresh}
              />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        ) : (
          <FlatList
            data={pizzaCustomizationsData || []}
            keyExtractor={(item) => item.type}
            renderItem={({ item }) => (
              <PizzaCustomizationAvailabilityItem group={item} />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        )}
      </View>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
      borderBottomLeftRadius: 24,
      borderBottomRightRadius: 24,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    searchbar: {
      flex: 1,
      borderRadius: 12,
      height: responsive.isTablet ? 42 : 48,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
    },
    menuContent: {
      marginTop: responsive.spacing(4),
    },
    content: {
      flex: 1,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.spacing(theme.spacing.m),
      fontSize: responsive.fontSize(14),
    },
    listContent: {
      paddingVertical: responsive.spacing(theme.spacing.m),
    },
  });

================
File: app/src/modules/customers/screens/CustomersScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Portal, Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import debounce from 'lodash.debounce';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

import {
  useCustomers,
  useCreateCustomer,
  useUpdateCustomer,
  useDeleteCustomer,
} from '../hooks/useCustomersQueries';
import { Customer } from '../types/customer.types';
import { CustomerFormInputs } from '../schema/customer.schema';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import GenericList, { FilterOption } from '@/app/components/crud/GenericList';
import GenericDetailModal from '@/app/components/crud/GenericDetailModal';
import CustomerFormModal from '../components/CustomerFormModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useListState } from '@/app/hooks/useListState';
import { formatCurrency } from '@/app/lib/formatters';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

function CustomersScreen(): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'active' | 'inactive' | 'banned'
  >('all');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(
    null,
  );
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [customerToDelete, setCustomerToDelete] = useState<string | null>(null);

  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  const handleFilterChange = (value: string | number) => {
    if (
      value === 'all' ||
      value === 'active' ||
      value === 'inactive' ||
      value === 'banned'
    ) {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };

  const queryFilters = useMemo(() => {
    const filters: any = {};

    // Solo agregar búsqueda si hay texto
    if (debouncedSearchQuery) {
      filters.firstName = debouncedSearchQuery;
      filters.lastName = debouncedSearchQuery;
    }

    // Manejar filtros de estado
    if (statusFilter === 'active') {
      filters.isActive = true;
    } else if (statusFilter === 'inactive') {
      filters.isActive = false;
    } else if (statusFilter === 'banned') {
      filters.isBanned = true;
    }

    return filters;
  }, [debouncedSearchQuery, statusFilter]);

  const {
    data: customers,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useCustomers(queryFilters);

  const createMutation = useCreateCustomer();
  const updateMutation = useUpdateCustomer();
  const { mutateAsync: deleteCustomer } = useDeleteCustomer();

  // Refrescar clientes cuando la pantalla recibe foco
  useRefreshModuleOnFocus('customers');

  const {
    isFormModalVisible,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal: originalHandleOpenEditModal,
    handleCloseModals: originalHandleCloseModals,
  } = useCrudScreenLogic<Customer>({
    entityName: 'Cliente',
    queryKey: ['customers', queryFilters],
    deleteMutationFn: deleteCustomer,
  });

  const handleOpenEditModal = useCallback(
    (item: any) => {
      setDetailModalVisible(false);
      // Remover el fullName antes de pasar al modal de edición
      const { fullName, ...originalCustomer } = item;
      originalHandleOpenEditModal(originalCustomer as Customer);
    },
    [originalHandleOpenEditModal],
  );

  const handleCloseModals = useCallback(() => {
    originalHandleCloseModals();
    setDetailModalVisible(false);
  }, [originalHandleCloseModals]);

  const handleItemPress = useCallback((item: Customer) => {
    setSelectedCustomer(item);
    setDetailModalVisible(true);
  }, []);

  const handleDelete = useCallback((id: string) => {
    setCustomerToDelete(id);
    setShowDeleteConfirmation(true);
  }, []);

  const handleConfirmDelete = useCallback(async () => {
    if (!customerToDelete) return;

    try {
      await deleteCustomer(customerToDelete);
      showSnackbar({
        message: 'Cliente eliminado con éxito',
        type: 'success',
      });
      setDetailModalVisible(false);
      setShowDeleteConfirmation(false);
      setCustomerToDelete(null);
    } catch (error) {
      showSnackbar({
        message: 'Error al eliminar el cliente',
        type: 'error',
      });
    }
  }, [deleteCustomer, showSnackbar, customerToDelete]);

  const filterOptions: FilterOption<
    'all' | 'active' | 'inactive' | 'banned'
  >[] = [
    { label: 'Todos', value: 'all' },
    { label: 'Activos', value: 'active' },
    { label: 'Inactivos', value: 'inactive' },
    { label: 'Baneados', value: 'banned' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: !!error,
    data: customers,
    emptyConfig: {
      title: 'No hay clientes',
      message:
        statusFilter !== 'all'
          ? `No hay clientes ${
              statusFilter === 'active'
                ? 'activos'
                : statusFilter === 'inactive'
                  ? 'inactivos'
                  : 'baneados'
            }.`
          : 'No hay clientes registrados. Presiona el botón + para crear el primero.',
      icon: 'account-group-outline',
    },
    errorConfig: {
      title: 'Error al cargar clientes',
      message: 'No se pudieron cargar los clientes. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });

  // Mapear los clientes para combinar firstName y lastName
  const mappedCustomers = useMemo(() => {
    return (
      customers?.map((customer) => ({
        ...customer,
        fullName: `${customer.firstName} ${customer.lastName}`.trim(),
        displayTitle:
          `${customer.firstName} ${customer.lastName} - ${customer.whatsappPhoneNumber}`.trim(),
        displayStatus: customer.isActive ? 'active' : 'inactive',
        whatsappInfo:
          customer.whatsappMessageCount > 0
            ? `💬 ${customer.whatsappMessageCount}`
            : null,
      })) || []
    );
  }, [customers]);

  const handleSubmit = useCallback(
    async (data: CustomerFormInputs) => {
      try {
        if (editingItem) {
          await updateMutation.mutateAsync({
            id: editingItem.id,
            data,
          });
          showSnackbar({
            message: 'Cliente actualizado con éxito',
            type: 'success',
          });
        } else {
          await createMutation.mutateAsync(data);
          showSnackbar({
            message: 'Cliente creado con éxito',
            type: 'success',
          });
        }
        handleCloseModals();
      } catch (error) {
        showSnackbar({
          message: 'Error al guardar el cliente',
          type: 'error',
        });
      }
    },
    [
      editingItem,
      createMutation,
      updateMutation,
      handleCloseModals,
      showSnackbar,
    ],
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        <GenericList
          items={mappedCustomers}
          isLoading={isLoading}
          isRefreshing={isFetching}
          onRefresh={refetch}
          onItemPress={handleItemPress}
          renderConfig={{
            titleField: 'displayTitle' as keyof Customer,
            statusConfig: {
              field: 'displayStatus' as keyof Customer,
              activeValue: 'active',
              activeLabel: 'Activo',
              inactiveLabel: 'Inactivo',
            },
            renderDescription: (item: any) => (
              <View>
                {item.email && (
                  <Text variant="bodySmall" style={{ opacity: 0.7 }}>
                    {item.email}
                  </Text>
                )}
                <View style={{ flexDirection: 'row', gap: 8, marginTop: 2 }}>
                  <Text variant="bodySmall" style={{ opacity: 0.7 }}>
                    {item.isBanned ? '⛔ Baneado' : '✅ No baneado'}
                  </Text>
                  <Text variant="bodySmall" style={{ opacity: 0.7 }}>
                    • 📍 {item.addresses?.length || 0} direcciones
                  </Text>
                </View>
              </View>
            ),
          }}
          searchQuery={searchQuery}
          onSearchChange={handleSearchChange}
          searchPlaceholder="Buscar por nombre..."
          filterOptions={filterOptions}
          filterValue={statusFilter}
          onFilterChange={handleFilterChange}
          showFab={true}
          onFabPress={handleOpenCreateModal}
          ListEmptyComponent={ListEmptyComponent}
          isDrawerOpen={isDrawerOpen}
          enableSearch={true}
          showImagePlaceholder={false}
          placeholderIcon="account-group-outline"
        />
      </View>

      <Portal>
        <CustomerFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSubmit={handleSubmit}
          editingItem={editingItem}
          isSubmitting={createMutation.isPending || updateMutation.isPending}
        />

        <GenericDetailModal
          visible={detailModalVisible}
          onDismiss={() => setDetailModalVisible(false)}
          item={
            selectedCustomer
              ? {
                  ...selectedCustomer,
                  fullName:
                    `${selectedCustomer.firstName} ${selectedCustomer.lastName}`.trim(),
                }
              : null
          }
          titleField="fullName"
          descriptionField="email"
          statusConfig={{
            field: 'isActive' as keyof Customer,
            activeValue: true,
            activeLabel: 'Activo',
            inactiveLabel: 'Inactivo',
          }}
          onEdit={handleOpenEditModal}
          onDelete={handleDelete}
          isDeleting={false}
          showImage={false}
          fieldsToDisplay={[
            {
              field: 'isBanned' as keyof Customer,
              label: 'Estado de baneo',
              render: (value) => (value ? '⛔ Baneado' : '✅ No baneado'),
            },
            {
              field: 'whatsappPhoneNumber' as keyof Customer,
              label: 'WhatsApp',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'stripeCustomerId' as keyof Customer,
              label: 'Stripe Customer ID',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'email' as keyof Customer,
              label: 'Correo',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'birthDate' as keyof Customer,
              label: 'Fecha de nacimiento',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleDateString()
                  : 'No registrada',
            },
            {
              field: 'addresses' as keyof Customer,
              label: 'Direcciones',
              render: (value) => {
                const addresses = value as any[];
                const count = addresses?.length || 0;
                if (count === 0) return '❌ Sin direcciones';
                if (count === 1) return '📍 1 dirección';
                return `📍 ${count} direcciones ${count > 3 ? '✨' : ''}`;
              },
            },
            {
              field: 'totalOrders' as keyof Customer,
              label: 'Total de pedidos',
              render: (value) => value?.toString() || '0',
            },
            {
              field: 'totalSpent' as keyof Customer,
              label: 'Total gastado',
              render: (value) => formatCurrency((value as number) || 0),
            },
            {
              field: 'lastInteraction' as keyof Customer,
              label: 'Última interacción',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleString()
                  : 'Sin interacciones',
            },
            {
              field: 'whatsappMessageCount' as keyof Customer,
              label: 'Mensajes de WhatsApp',
              render: (value) => `${value || 0} mensajes`,
            },
            {
              field: 'lastWhatsappMessageTime' as keyof Customer,
              label: 'Último mensaje WhatsApp',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleString()
                  : 'Sin mensajes',
            },
          ]}
        />

        <ConfirmationModal
          visible={showDeleteConfirmation}
          title="Confirmar Eliminación"
          message="¿Estás seguro de que quieres eliminar este cliente? Esta acción no se puede deshacer."
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
          onConfirm={handleConfirmDelete}
          onCancel={() => {
            setShowDeleteConfirmation(false);
            setCustomerToDelete(null);
          }}
          onDismiss={() => {
            setShowDeleteConfirmation(false);
            setCustomerToDelete(null);
          }}
        />
      </Portal>
    </SafeAreaView>
  );
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    rightContent: {
      flexDirection: 'column',
      alignItems: 'flex-end',
      gap: theme.spacing.xs,
    },
    activeChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    inactiveChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    statsChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
  });

export default CustomersScreen;

================
File: app/src/modules/kitchen/hooks/useKitchenOrders.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { kitchenService } from '../services/kitchenService';
import { KitchenFilters } from '../types/kitchen.types';
import { useKitchenSnackbar } from './useKitchenSnackbar';

export const KITCHEN_ORDERS_KEY = 'kitchen-orders';

/**
 * Hook principal para obtener órdenes de cocina
 * Optimizado con refetch cada 30 segundos para balance entre actualización y rendimiento
 */
export function useKitchenOrders(filters: Partial<KitchenFilters> = {}) {
  return useQuery({
    queryKey: [KITCHEN_ORDERS_KEY, filters],
    queryFn: () => kitchenService.getKitchenOrders(filters),
    refetchInterval: 30000, // Refetch cada 30 segundos - balance óptimo
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 25000, // Datos frescos por 25 segundos
    gcTime: 5 * 60 * 1000, // Cache por 5 minutos
    keepPreviousData: true, // Evitar parpadeos durante refetch
    notifyOnChangeProps: ['data', 'error'],
  });
}

/**
 * Hook para marcar items como preparados con actualización optimista granular
 * No invalida toda la query, solo actualiza el item específico
 */
export function useUpdateKitchenItem() {
  const queryClient = useQueryClient();
  const { showError } = useKitchenSnackbar();

  const updateAllQueriesForItem = (itemId: string, isPrepared: boolean) => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    const previousData: any[] = [];

    queries.forEach((query) => {
      const queryKey = query.queryKey;
      if (Array.isArray(queryKey) && queryKey[0] === KITCHEN_ORDERS_KEY) {
        const oldData = query.state.data;
        if (oldData) {
          previousData.push([queryKey, oldData]);

          queryClient.setQueryData(queryKey, (old: any) => {
            if (!old || !Array.isArray(old)) return old;

            return old.map((order: any) => ({
              ...order,
              items: order.items?.map((item: any) =>
                item.id === itemId
                  ? {
                      ...item,
                      preparationStatus: isPrepared ? 'READY' : 'IN_PROGRESS',
                      preparedAt: isPrepared ? new Date().toISOString() : null,
                    }
                  : item,
              ),
            }));
          });
        }
      }
    });

    return previousData;
  };

  const rollbackAllQueries = (previousData: any[]) => {
    previousData.forEach(([queryKey, data]) => {
      queryClient.setQueryData(queryKey, data);
    });
  };

  return useMutation({
    mutationFn: ({
      itemId,
      isPrepared,
    }: {
      itemId: string;
      isPrepared: boolean;
    }) => kitchenService.markItemPrepared(itemId, isPrepared),

    onMutate: async ({ itemId, isPrepared }) => {
      await queryClient.cancelQueries({ queryKey: [KITCHEN_ORDERS_KEY] });
      const previousData = updateAllQueriesForItem(itemId, isPrepared);
      return { previousData };
    },

    onError: (error: any, variables, context) => {
      if (context?.previousData) {
        rollbackAllQueries(context.previousData);
      }
      showError(error.response?.data?.message || 'Error al actualizar el item');
    },

    // NO invalidar inmediatamente - dejar que el background refetch se encargue
    onSettled: () => {
      // Invalidar después de 2 segundos para permitir ver el cambio optimista
      setTimeout(() => {
        queryClient.invalidateQueries({
          queryKey: [KITCHEN_ORDERS_KEY],
          refetchType: 'none', // Solo marcar como stale, no refetch inmediato
        });
      }, 2000);
    },
  });
}

/**
 * Hook para iniciar preparación de órdenes con actualización optimista granular
 */
export function useUpdateKitchenOrderStatus() {
  const queryClient = useQueryClient();
  const { showError } = useKitchenSnackbar();

  const updateAllQueriesForOrder = (
    orderId: string,
    status: string,
    extraUpdates?: any,
  ) => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    const previousData: any[] = [];

    queries.forEach((query) => {
      const queryKey = query.queryKey;
      if (Array.isArray(queryKey) && queryKey[0] === KITCHEN_ORDERS_KEY) {
        const oldData = query.state.data;
        if (oldData) {
          previousData.push([queryKey, oldData]);

          queryClient.setQueryData(queryKey, (old: any) => {
            if (!old || !Array.isArray(old)) return old;

            return old.map((order: any) =>
              order.id === orderId
                ? {
                    ...order,
                    myScreenStatus: status,
                    preparationStartedAt:
                      status === 'IN_PREPARATION'
                        ? new Date().toISOString()
                        : order.preparationStartedAt,
                    preparationCompletedAt:
                      status === 'READY'
                        ? new Date().toISOString()
                        : order.preparationCompletedAt,
                    // Si se cancela, resetear items
                    items:
                      status === 'PENDING'
                        ? order.items?.map((item: any) => ({
                            ...item,
                            preparationStatus: item.belongsToMyScreen
                              ? 'IN_PROGRESS'
                              : item.preparationStatus,
                            preparedAt: item.belongsToMyScreen
                              ? null
                              : item.preparedAt,
                          }))
                        : order.items,
                    ...extraUpdates,
                  }
                : order,
            );
          });
        }
      }
    });

    return previousData;
  };

  const rollbackAllQueries = (previousData: any[]) => {
    previousData.forEach(([queryKey, data]) => {
      queryClient.setQueryData(queryKey, data);
    });
  };

  return {
    // Función genérica para actualizar status
    updateStatus: useMutation({
      mutationFn: ({
        orderId,
        status,
        serverAction,
      }: {
        orderId: string;
        status: string;
        serverAction: () => Promise<any>;
      }) => serverAction(),

      onMutate: async ({ orderId, status }) => {
        await queryClient.cancelQueries({ queryKey: [KITCHEN_ORDERS_KEY] });
        const previousData = updateAllQueriesForOrder(orderId, status);
        return { previousData };
      },

      onError: (error: any, variables, context) => {
        if (context?.previousData) {
          rollbackAllQueries(context.previousData);
        }
        showError(error.response?.data?.message || 'Error al actualizar orden');
      },

      onSettled: () => {
        setTimeout(() => {
          queryClient.invalidateQueries({
            queryKey: [KITCHEN_ORDERS_KEY],
            refetchType: 'none',
          });
        }, 2000);
      },
    }),

    // Helpers específicos
    startPreparation: (orderId: string) => ({
      orderId,
      status: 'IN_PREPARATION',
      serverAction: () => kitchenService.startOrderPreparation(orderId),
    }),

    cancelPreparation: (orderId: string) => ({
      orderId,
      status: 'PENDING',
      serverAction: () => kitchenService.cancelOrderPreparation(orderId),
    }),

    completePreparation: (orderId: string) => ({
      orderId,
      status: 'READY',
      serverAction: () => kitchenService.completeOrderPreparation(orderId),
    }),
  };
}

/**
 * Hook de conveniencia para iniciar preparación
 */
export function useStartOrderPreparation() {
  const { updateStatus, startPreparation } = useUpdateKitchenOrderStatus();

  return useMutation({
    mutationFn: (orderId: string) => {
      const params = startPreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}

/**
 * Hook de conveniencia para cancelar preparación
 */
export function useCancelOrderPreparation() {
  const { updateStatus, cancelPreparation } = useUpdateKitchenOrderStatus();

  return useMutation({
    mutationFn: (orderId: string) => {
      const params = cancelPreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}

/**
 * Hook de conveniencia para completar preparación
 */
export function useCompleteOrderPreparation() {
  const { updateStatus, completePreparation } = useUpdateKitchenOrderStatus();

  return useMutation({
    mutationFn: (orderId: string) => {
      const params = completePreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}

/**
 * Hook de conveniencia para marcar items como preparados
 * Mantiene la API existente para compatibilidad
 */
export function useMarkItemPrepared() {
  const updateItem = useUpdateKitchenItem();

  return useMutation({
    mutationFn: ({
      itemId,
      isPrepared,
    }: {
      itemId: string;
      isPrepared: boolean;
    }) => {
      return updateItem.mutateAsync({ itemId, isPrepared });
    },
  });
}

================
File: app/src/modules/kitchen/store/kitchenStore.ts
================
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import EncryptedStorage from '@/app/services/secureStorageService';
import { KitchenFilters } from '../types/kitchen.types';

const KITCHEN_FILTERS_STORAGE_KEY = 'kitchen_filters_preferences';

interface KitchenStore {
  filters: KitchenFilters;
  setFilters: (filters: KitchenFilters) => void;
  resetFilters: () => void;
}

const defaultFilters: KitchenFilters = {
  orderType: undefined,
  showPrepared: true,
  showAllProducts: true,
  ungroupProducts: false,
};

export const useKitchenStore = create<KitchenStore>()(
  persist(
    (set) => ({
      filters: defaultFilters,
      setFilters: (filters) => set({ filters }),
      resetFilters: () => set({ filters: defaultFilters }),
    }),
    {
      name: KITCHEN_FILTERS_STORAGE_KEY,
      storage: createJSONStorage(() => EncryptedStorage),
      partialize: (state) => ({ filters: state.filters }),
      onRehydrateStorage: () => {
        return (state, error) => {
          if (error) {
            // Error al rehidratar filtros de cocina
            return;
          }
          if (!state) {
            // Estado no disponible durante la rehidratación de filtros de cocina
            return;
          }
          // Filtros de cocina restaurados
        };
      },
    },
  ),
);

================
File: app/src/modules/menu/screens/ProductsScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { StyleSheet } from 'react-native';
import { Portal } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRoute, RouteProp, useNavigation } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import debounce from 'lodash.debounce';
import { useQueryClient } from '@tanstack/react-query';

import {
  useProductsQuery,
  useCreateProductMutation,
  useUpdateProductMutation,
  useDeleteProductMutation,
} from '../hooks/useProductsQueries';
import { Product, ProductFormInputs } from '../schema/products.schema';
import { MenuStackParamList } from '@/modules/menu/navigation/types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import GenericList, { FilterOption } from '@/app/components/crud/GenericList';
import ProductFormModal from '../components/ProductFormModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { FileObject } from '@/app/components/common/CustomImagePicker';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

type ProductsScreenRouteProp = RouteProp<MenuStackParamList, 'Products'>;

function ProductsScreen(): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);
  const navigation = useNavigation();
  const route = useRoute<ProductsScreenRouteProp>();
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const { subcategoryId, subCategoryName } = route.params;

  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'active' | 'inactive'
  >('all');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };

  const queryFilters = useMemo(
    () => ({
      subcategoryId: subcategoryId,
      search: debouncedSearchQuery || undefined,
      limit: 20,
      page: 1,
      isActive: statusFilter === 'all' ? undefined : statusFilter === 'active',
    }),
    [subcategoryId, debouncedSearchQuery, statusFilter],
  );

  const {
    data: productsResponse,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useProductsQuery(queryFilters, {});

  // Refrescar productos cuando la pantalla recibe foco

  useRefreshModuleOnFocus('products');

  const createMutation = useCreateProductMutation();
  const updateMutation = useUpdateProductMutation();
  const { mutateAsync: deleteProduct } = useDeleteProductMutation();

  const {
    isFormModalVisible,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleCloseModals,
  } = useCrudScreenLogic<Product>({
    entityName: 'Producto',
    queryKey: ['products', queryFilters],
    deleteMutationFn: deleteProduct,
  });

  const products = useMemo(() => {
    return (productsResponse?.data ?? []).map((p: Product) => ({
      ...p,
      displayDescription: p.hasVariants
        ? `${p.variants?.length || 0} variante(s)`
        : !isNaN(parseFloat(String(p.price)))
          ? `$${parseFloat(String(p.price)).toFixed(2)}`
          : 'Precio no definido',
    }));
  }, [productsResponse]);

  const handleFormSubmit = useCallback(
    async (
      formData: ProductFormInputs,
      photoId: string | null | undefined,
      _file?: FileObject | null,
    ) => {
      const isEditing = !!editingItem;

      const { imageUri, ...dataToSend } = formData;

      const mutationData = {
        ...dataToSend,
        modifierGroupIds: dataToSend.modifierGroupIds ?? [],
        ...(photoId !== undefined && { photoId }),
      };

      try {
        let productResult: Product;

        if (isEditing && editingItem) {
          productResult = await updateMutation.mutateAsync({
            id: editingItem.id,
            data: mutationData,
          });
        } else {
          productResult = await createMutation.mutateAsync(mutationData);
        }

        // Éxito
        const message = isEditing
          ? 'Producto actualizado con éxito'
          : 'Producto creado con éxito';

        showSnackbar({ message, type: 'success' });
        handleCloseModals();

        queryClient.invalidateQueries({
          queryKey: ['products', queryFilters],
        });
        if (productResult?.id) {
          queryClient.invalidateQueries({
            queryKey: ['product', productResult.id],
          });
        }
      } catch (err) {
        const errorMessage = getApiErrorMessage(err);
        showSnackbar({
          message: `Error al ${isEditing ? 'actualizar' : 'crear'} producto: ${errorMessage}`,
          type: 'error',
        });
      }
    },
    [
      editingItem,
      updateMutation,
      createMutation,
      showSnackbar,
      handleCloseModals,
      queryClient,
      queryFilters,
    ],
  );

  const listRenderConfig = {
    titleField: 'name' as keyof Product,
    descriptionField: 'displayDescription' as keyof (Product & {
      displayDescription: string;
    }),
    imageField: 'photo' as keyof Product,
    sortOrderField: 'sortOrder' as keyof Product,
    statusConfig: {
      field: 'isActive' as keyof Product,
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
  };

  const filterOptions: FilterOption<'all' | 'active' | 'inactive'>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: !!error,
    data: products,
    emptyConfig: {
      title: debouncedSearchQuery
        ? `No se encontraron productos`
        : 'No hay productos',
      message: debouncedSearchQuery
        ? `No se encontraron productos para "${debouncedSearchQuery}"`
        : `No hay productos en "${subCategoryName}". Presiona el botón + para crear el primero.`,
      icon: 'package-variant',
    },
    errorConfig: {
      title: 'Error al cargar productos',
      message: 'No se pudieron cargar los productos. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });

  React.useLayoutEffect(() => {
    navigation.setOptions({
      title: subCategoryName ? `Productos de ${subCategoryName}` : 'Productos',
    });
  }, [navigation, subCategoryName]);

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Product & { displayDescription: string }>
        items={products}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenEditModal}
        onRefresh={refetch}
        isRefreshing={isFetching && !isLoading}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading && !isFetching}
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar productos..."
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible}
        enableSort={false}
        contentContainerStyle={styles.contentContainer}
        showImagePlaceholder={true}
        placeholderIcon="food-outline"
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        {isFormModalVisible && (
          <ProductFormModal
            visible={isFormModalVisible}
            onDismiss={handleCloseModals}
            onSubmit={handleFormSubmit}
            initialData={editingItem}
            isSubmitting={createMutation.isPending || updateMutation.isPending}
            productId={editingItem?.id}
            subcategoryId={subcategoryId}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    errorText: {
      color: theme.colors.error,
      textAlign: 'center',
    },
    contentContainer: {
      paddingBottom: 80,
    },
  });

export default ProductsScreen;

================
File: app/src/modules/modifiers/screens/ModifierGroupsScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { StyleSheet } from 'react-native';
import { Text, IconButton } from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';

import { modifierGroupService } from '../services/modifierGroupService';
import { ModifierGroup } from '../schema/modifierGroup.schema';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import debounce from 'lodash.debounce';
import ModifierGroupFormModal from '../components/ModifierGroupFormModal';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '@/app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '@/app/components/crud/GenericDetailModal';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { PaginatedResponse } from '@/app/types/api.types';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

type NavigationProps = {
  navigate: (screen: string, params?: any) => void;
};

type StatusFilter = 'all' | 'active' | 'inactive';

const QUERY_KEY = ['modifierGroups'];

const ModifierGroupsScreen = () => {
  const theme = useAppTheme();
  const navigation = useNavigation<NavigationProps>();
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  const queryParams = useMemo(() => {
    const params: Parameters<typeof modifierGroupService.findAll>[0] = {};
    if (statusFilter !== 'all') {
      params.isActive = statusFilter === 'active';
    }
    if (debouncedSearchQuery) {
      params.search = debouncedSearchQuery;
    }
    return params;
  }, [statusFilter, debouncedSearchQuery]);

  const {
    data: paginatedData,
    isLoading,
    isError,
    error: _error,
    refetch,
    isRefetching,
  } = useQuery<PaginatedResponse<ModifierGroup>, Error>({
    queryKey: [QUERY_KEY[0], queryParams],
    queryFn: () => modifierGroupService.findAll(queryParams),
  });

  // Refrescar todos los modificadores cuando la pantalla recibe foco
  useRefreshModuleOnFocus('modifierGroups');

  const modifierGroups = paginatedData?.data || [];

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<ModifierGroup>({
    entityName: 'Grupo de Modificadores',
    queryKey: [QUERY_KEY[0], queryParams],
    deleteMutationFn: modifierGroupService.remove,
  });

  const handleNavigateToModifiers = (groupId: string, groupName: string) => {
    navigation.navigate('ModifiersScreen', { groupId, groupName });
  };

  const handleFormSaveSuccess = () => {
    handleCloseModals();
  };

  const handleFilterChange = (value: string | number) => {
    // Validar que el valor sea uno de los StatusFilter esperados
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value as StatusFilter);
    } else {
      // Opcional: manejar valor inesperado, por ahora default a 'all'
      setStatusFilter('all');
    }
  };

  const handleRefresh = () => {
    refetch();
  };

  const listRenderConfig: RenderItemConfig<ModifierGroup> = {
    titleField: 'name',
    descriptionField: 'description',
    sortOrderField: 'sortOrder',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
    renderDescription: (item) => {
      const parts = [];

      // Agregar orden de visualización
      if (item.sortOrder !== undefined && item.sortOrder !== null) {
        parts.push(`Orden: ${item.sortOrder}`);
      }

      // Agregar si es requerido
      parts.push(`Requerido: ${item.isRequired ? 'Sí' : 'No'}`);

      // Agregar si permite múltiples
      parts.push(`Múltiples: ${item.allowMultipleSelections ? 'Sí' : 'No'}`);

      // Agregar descripción si existe
      if (item.description) {
        parts.push(item.description);
      }

      return (
        <Text style={{ color: theme.colors.onSurfaceVariant, fontSize: 12 }}>
          {parts.join(' • ')}
        </Text>
      );
    },
  };

  const detailFields: DisplayFieldConfig<ModifierGroup>[] = [
    { field: 'sortOrder', label: 'Orden de Visualización' },
    { field: 'minSelections', label: 'Mín. Selecciones' },
    { field: 'maxSelections', label: 'Máx. Selecciones' },
    {
      field: 'isRequired',
      label: 'Requerido',
      render: (value) => (
        <Text style={{ color: theme.colors.onSurface }}>
          {value ? 'Sí' : 'No'}
        </Text>
      ),
    },
    {
      field: 'allowMultipleSelections',
      label: 'Permite Múltiples',
      render: (value) => (
        <Text style={{ color: theme.colors.onSurface }}>
          {value ? 'Sí' : 'No'}
        </Text>
      ),
    },
  ];

  const styles = useMemo(() => createStyles(theme), [theme]);

  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading: isLoading && !isRefetching,
    isError,
    data: modifierGroups,
    emptyConfig: {
      title: searchQuery
        ? 'No se encontraron grupos'
        : 'No hay grupos de modificadores',
      message: searchQuery
        ? `No se encontraron grupos para "${searchQuery}"`
        : statusFilter !== 'all'
          ? `No hay grupos de modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'}.`
          : 'No hay grupos de modificadores registrados. Presiona el botón + para crear el primero.',
      icon: 'folder-multiple-outline',
    },
    errorConfig: {
      title: 'Error al cargar grupos',
      message:
        'No se pudieron cargar los grupos de modificadores. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<ModifierGroup>
        items={modifierGroups}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading} // Pasar directamente el estado de carga principal
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar grupos..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
        renderItemActions={(item) => (
          <IconButton
            icon="format-list-bulleted"
            size={24}
            onPress={(e) => {
              e.stopPropagation();
              handleNavigateToModifiers(item.id, item.name);
            }}
          />
        )}
      />

      <ModifierGroupFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSaveSuccess={handleFormSaveSuccess}
        initialData={editingItem}
      />

      <GenericDetailModal<ModifierGroup>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        descriptionField="description"
        statusConfig={listRenderConfig.statusConfig}
        fieldsToDisplay={detailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        editButtonLabel="Editar"
        deleteButtonLabel="Eliminar"
        showImage={false}
      ></GenericDetailModal>
    </SafeAreaView>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 20,
    },
    emptyText: {
      textAlign: 'center',
      fontSize: 18,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 8,
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: 10,
      textAlign: 'center',
    },
    detailActionButton: {
      marginTop: theme.spacing.m,
      alignSelf: 'stretch',
      borderRadius: theme.roundness,
    },
  });

export default ModifierGroupsScreen;

================
File: app/src/modules/modifiers/screens/ModifiersScreen.tsx
================
import React, { useLayoutEffect, useCallback, useMemo, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Portal, Button } from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';

import { modifierService } from '../services/modifierService';
import { Modifier } from '../schema/modifier.schema';
import { useAppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import debounce from 'lodash.debounce';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';

import ModifierFormModal from '@/modules/modifiers/components/ModifierFormModal';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '@/app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '@/app/components/crud/GenericDetailModal';
import { useListState } from '@/app/hooks/useListState';

type StatusFilter = 'all' | 'active' | 'inactive';

type ModifiersScreenRouteParams = {
  groupId: string;
  groupName: string;
};

type ModifiersScreenRouteProp = RouteProp<
  { params: ModifiersScreenRouteParams },
  'params'
>;

type NavigationProps = {
  goBack: () => void;
  setOptions: (options: object) => void;
};

const ModifiersScreen = () => {
  const theme = useAppTheme();
  const navigation = useNavigation<NavigationProps>();
  const route = useRoute<ModifiersScreenRouteProp>();
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const { groupId, groupName } = route.params ?? {};

  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

  const QUERY_KEY = ['modifiers', groupId];

  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  useLayoutEffect(() => {
    if (groupName) {
      navigation.setOptions({
        headerTitle: `Modificadores: ${groupName}`,
      });
    }
  }, [navigation, groupName]);

  const queryParams = useMemo(() => {
    const params: Parameters<typeof modifierService.findByGroupId>[1] = {};
    if (statusFilter !== 'all') {
      params.isActive = statusFilter === 'active';
    }
    if (debouncedSearchQuery) {
      params.search = debouncedSearchQuery;
    }
    return params;
  }, [statusFilter, debouncedSearchQuery]);

  const {
    data: modifiers = [],
    isLoading,
    isError,
    error: _error,
    refetch,
    isRefetching,
  } = useQuery<Modifier[], Error>({
    queryKey: [QUERY_KEY[0], groupId, queryParams],
    queryFn: () => modifierService.findByGroupId(groupId, queryParams),
    enabled: !!groupId,
  });

  // Recargar automáticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('modifiers');

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Modifier>({
    entityName: 'Modificador',
    queryKey: QUERY_KEY,
    deleteMutationFn: modifierService.remove,
  });

  const handleFormModalSave = () => {
    handleCloseModals();
  };

  const handleEditFromDetails = (modifier: Modifier) => {
    handleOpenEditModal(modifier);
  };

  const handleFilterChange = (value: StatusFilter) => {
    setStatusFilter(value);
  };

  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: modifiers,
    emptyConfig: {
      title: searchQuery
        ? 'No se encontraron modificadores'
        : 'No hay modificadores',
      message: searchQuery
        ? `No se encontraron modificadores para "${searchQuery}"`
        : statusFilter !== 'all'
          ? `No hay modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'} en este grupo.`
          : `No hay modificadores en "${groupName}". Presiona el botón + para crear el primero.`,
      icon: 'format-list-bulleted',
    },
    errorConfig: {
      title: 'Error al cargar modificadores',
      message: 'No se pudieron cargar los modificadores. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });

  if (!groupId) {
    return (
      <View style={styles.centered}>
        <Text style={styles.errorText}>
          Error: No se proporcionó ID del grupo.
        </Text>
        <Button onPress={() => navigation.goBack()}>Volver</Button>
      </View>
    );
  }

  const listRenderConfig: RenderItemConfig<Modifier> = {
    titleField: 'name',
    priceField: 'price',
    sortOrderField: 'sortOrder',
    isDefaultField: 'isDefault',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
  };

  const detailFields: DisplayFieldConfig<Modifier>[] = [
    {
      field: 'price',
      label: 'Precio Adicional',
      render: (value) => (
        <Text style={styles.fieldValue}>
          {value !== null ? `$${Number(value).toFixed(2)}` : 'N/A'}
        </Text>
      ),
    },
    {
      field: 'sortOrder',
      label: 'Orden',
    },
    {
      field: 'isDefault',
      label: 'Por Defecto',
    },
  ];

  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Modifier>
        items={modifiers}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={refetch}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading && !isRefetching}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar modificadores..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        fabLabel="Añadir Modificador"
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        <ModifierFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSaveSuccess={handleFormModalSave}
          initialData={editingItem}
          groupId={groupId}
        />

        <GenericDetailModal<Modifier>
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          item={selectedItem}
          titleField="name"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={detailFields}
          onEdit={handleEditFromDetails}
          deleteConfirmation={deleteConfirmation}
          isDeleting={isDeleting}
          showImage={false}
        />
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 20,
    },
    emptyText: {
      textAlign: 'center',
      fontSize: 18,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 8,
    },
    emptySubText: {
      textAlign: 'center',
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: 10,
      textAlign: 'center',
    },
    fieldValue: {
      flexShrink: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
    },
  });

export default ModifiersScreen;

================
File: app/src/modules/orders/components/CartButton.tsx
================
import React, { useRef, useCallback, useMemo } from 'react';
import { StyleSheet, View, Animated } from 'react-native';
import { IconButton, Badge, useTheme, MD3Theme } from 'react-native-paper';

interface CartButtonProps {
  itemCount: number;
  onPress: () => void;
}

const createStyles = (theme: MD3Theme) =>
  StyleSheet.create({
    cartButton: {
      margin: 0,
      backgroundColor: theme.colors.surfaceVariant,
      zIndex: 999,
    },
    cartBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: theme.colors.error,
      zIndex: 1000,
    },
    touchableArea: {
      padding: 5,
    },
    // Estilos adicionales para eliminar inline styles
    animatedContainer: {
      // El transform se aplica dinámicamente
    },
    badgeContainer: {
      position: 'absolute',
      top: 0,
      right: 0,
      pointerEvents: 'none',
    },
  });

const CartButton = React.forwardRef(
  ({ itemCount, onPress }: CartButtonProps, ref) => {
    const theme = useTheme();
    const cartBadgeScale = useRef(new Animated.Value(1)).current;
    const cartBounceAnimation = useRef(new Animated.Value(1)).current;
    const isPressedRef = useRef(false);

    const styles = useMemo(() => createStyles(theme), [theme]);

    const animateCartButton = () => {
      Animated.sequence([
        Animated.timing(cartBounceAnimation, {
          toValue: 1.3,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(cartBounceAnimation, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();

      Animated.sequence([
        Animated.timing(cartBadgeScale, {
          toValue: 1.6,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(cartBadgeScale, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    };

    React.useImperativeHandle(ref, () => ({
      animate: animateCartButton,
    }));

    const handlePress = useCallback(() => {
      if (isPressedRef.current) return;

      isPressedRef.current = true;
      onPress();

      setTimeout(() => {
        isPressedRef.current = false;
      }, 150);
    }, [onPress]);

    return (
      <View style={styles.touchableArea}>
        <Animated.View
          style={[
            styles.animatedContainer,
            { transform: [{ scale: cartBounceAnimation }] },
          ]}
        >
          <IconButton
            icon="cart-outline"
            iconColor={theme.colors.primary}
            size={30}
            onPress={handlePress}
            style={styles.cartButton}
            rippleColor={theme.colors.primary + '20'}
          />
        </Animated.View>
        {itemCount > 0 && (
          <Animated.View
            style={[
              styles.badgeContainer,
              { transform: [{ scale: cartBadgeScale }] },
            ]}
          >
            <Badge style={styles.cartBadge} size={22}>
              {itemCount}
            </Badge>
          </Animated.View>
        )}
      </View>
    );
  },
);

export default CartButton;

================
File: app/src/modules/orders/components/ShiftStatusModal.tsx
================
import React from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Surface,
  Divider,
  Card,
  Chip,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { type Shift } from '@/services/shifts';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

interface ShiftStatusModalProps {
  visible: boolean;
  onDismiss: () => void;
  shift: Shift | null;
  onOpenShift: () => void;
  onCloseShift?: () => void;
  canOpenShift: boolean;
  loading: boolean;
}

export const ShiftStatusModal: React.FC<ShiftStatusModalProps> = ({
  visible,
  onDismiss,
  shift,
  onOpenShift,
  onCloseShift,
  canOpenShift,
  loading: _loading,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const isShiftOpen = shift && shift.status === 'OPEN';
  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });

  const handleOpenShift = () => {
    onDismiss();
    onOpenShift();
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency: 'MXN',
    }).format(amount);
  };

  const formatTime = (dateString: string) => {
    return format(new Date(dateString), 'HH:mm', { locale: es });
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <ScrollView showsVerticalScrollIndicator={false}>
          <Surface style={styles.modal} elevation={3}>
            {/* Header */}
            <View style={styles.header}>
              <View style={styles.iconContainer}>
                <MaterialCommunityIcons
                  name={isShiftOpen ? 'store-check' : 'store-alert'}
                  size={48}
                  color={isShiftOpen ? '#4CAF50' : '#FF9800'}
                />
              </View>
              <Text variant="headlineMedium" style={styles.title}>
                {isShiftOpen ? 'Turno Abierto' : 'Turno Cerrado'}
              </Text>
              <Text variant="bodyLarge" style={styles.date}>
                {todayFormatted}
              </Text>
              <Chip
                mode="outlined"
                style={[
                  styles.statusChip,
                  { borderColor: isShiftOpen ? '#4CAF50' : '#FF9800' },
                ]}
                textStyle={{ color: isShiftOpen ? '#4CAF50' : '#FF9800' }}
              >
                {isShiftOpen ? 'ABIERTO' : 'CERRADO'}
              </Chip>
            </View>

            <Divider style={styles.divider} />

            {/* Content */}
            <View style={styles.content}>
              {isShiftOpen && shift ? (
                <>
                  {/* Información del turno abierto */}
                  <Card style={styles.infoCard}>
                    <Card.Content>
                      <Text variant="titleMedium" style={styles.sectionTitle}>
                        Información del Turno
                      </Text>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Turno #:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {shift.globalShiftNumber}
                        </Text>
                      </View>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto a las:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatTime(shift.openedAt)}
                        </Text>
                      </View>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto por:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {shift.openedBy.firstName} {shift.openedBy.lastName}
                        </Text>
                      </View>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Efectivo inicial:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatCurrency(shift.initialCash)}
                        </Text>
                      </View>

                      {shift.totalSales !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Ventas del turno:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.totalSales)}
                          </Text>
                        </View>
                      )}

                      {shift.totalOrders !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Órdenes:
                          </Text>
                          <Text variant="bodyMedium" style={styles.value}>
                            {shift.totalOrders}
                          </Text>
                        </View>
                      )}

                      {shift.expectedCash !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Efectivo esperado:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.expectedCash)}
                          </Text>
                        </View>
                      )}

                      {shift.notes && (
                        <View style={styles.notesSection}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Notas:
                          </Text>
                          <Text variant="bodySmall" style={styles.notes}>
                            {shift.notes}
                          </Text>
                        </View>
                      )}
                    </Card.Content>
                  </Card>
                </>
              ) : (
                <>
                  {/* Turno cerrado */}
                  <View style={styles.closedInfo}>
                    <MaterialCommunityIcons
                      name="information"
                      size={20}
                      color={theme.colors.primary}
                    />
                    <Text variant="bodyMedium" style={styles.closedText}>
                      {canOpenShift
                        ? 'El turno está cerrado. Para comenzar las operaciones, abre el turno.'
                        : 'El turno está cerrado. Contacta a un administrador para abrirlo.'}
                    </Text>
                  </View>
                </>
              )}
            </View>

            {/* Footer */}
            <View style={styles.footer}>
              <Button
                mode="text"
                onPress={onDismiss}
                style={styles.cancelButton}
                labelStyle={styles.cancelButtonText}
              >
                Cerrar
              </Button>

              {!isShiftOpen && canOpenShift && (
                <Button
                  mode="contained"
                  onPress={handleOpenShift}
                  style={styles.actionButton}
                  contentStyle={styles.actionButtonContent}
                  labelStyle={styles.actionButtonText}
                  icon="play-circle"
                >
                  Abrir Turno
                </Button>
              )}

              {isShiftOpen && canOpenShift && onCloseShift && (
                <Button
                  mode="contained"
                  onPress={() => {
                    onDismiss();
                    onCloseShift();
                  }}
                  style={styles.closeShiftButton}
                  contentStyle={styles.actionButtonContent}
                  labelStyle={styles.closeShiftButtonText}
                  icon="stop-circle"
                >
                  Cerrar Turno
                </Button>
              )}
            </View>
          </Surface>
        </ScrollView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.m,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 8,
      },
      shadowOpacity: 0.25,
      shadowRadius: 16,
      elevation: 8,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surfaceVariant,
    },
    iconContainer: {
      width: 90,
      height: 90,
      borderRadius: 45,
      backgroundColor: theme.colors.surface,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      borderWidth: 3,
      borderColor: theme.colors.primary,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 4,
      },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 4,
    },
    title: {
      color: theme.colors.onSurfaceVariant,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
      marginBottom: theme.spacing.m,
    },
    statusChip: {
      backgroundColor: theme.colors.surface,
      borderWidth: 2,
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    infoCard: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    value: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
    },
    highlight: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    notesSection: {
      marginTop: theme.spacing.m,
      paddingTop: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outline,
    },
    notes: {
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      fontStyle: 'italic',
    },
    closedInfo: {
      flexDirection: 'row',
      backgroundColor: theme.colors.primaryContainer,
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.primary,
      gap: theme.spacing.s,
    },
    closedText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
      lineHeight: 20,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      borderBottomLeftRadius: theme.roundness * 3,
      borderBottomRightRadius: theme.roundness * 3,
    },
    cancelButton: {
      flex: 1,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    cancelButtonText: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    actionButton: {
      flex: 1,
      backgroundColor: theme.colors.primary,
      borderWidth: 2,
      borderColor: theme.colors.primary,
      borderRadius: theme.roundness * 2,
    },
    actionButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    actionButtonText: {
      color: theme.colors.onPrimary,
      fontWeight: '600',
    },
    closeShiftButton: {
      flex: 1,
      backgroundColor: '#FF5722',
      borderWidth: 2,
      borderColor: '#FF5722',
      borderRadius: theme.roundness * 2,
    },
    closeShiftButtonText: {
      color: '#FFFFFF',
      fontWeight: '600',
    },
  });

================
File: app/src/modules/orders/types/orders.types.ts
================
// Importar tipos de dominio centralizados desde /app/schemas/domain/
import type { Photo } from '@/app/schemas/domain/photo.schema';
import type { Modifier } from '@/app/schemas/domain/modifier.schema';
import type { ModifierGroup } from '@/app/schemas/domain/modifier-group.schema';
import type { ProductVariant } from '@/app/schemas/domain/product-variant.schema'; // Asumiendo que se creará
import type { Product } from '@/app/schemas/domain/product.schema'; // Asumiendo que se creará
import type { SubCategory } from '@/app/schemas/domain/subcategory.schema'; // Asumiendo que se creará
import type { Category } from '@/app/schemas/domain/category.schema';
import {
  orderStatusSchema, // Importar el schema Zod
  orderTypeSchema, // Importar el schema Zod
} from '@/app/schemas/domain/order.schema';
import type {
  OrderItemModifier,
  OrderItem,
  OrderStatus,
  OrderType,
  Order,
} from '@/app/schemas/domain/order.schema'; // Mantener importación de tipos

// Re-exportar tipos de dominio para que otros archivos dentro de este módulo puedan importarlos desde aquí
export type {
  Photo,
  Modifier,
  ModifierGroup,
  ProductVariant,
  Product,
  SubCategory,
  Category,
  OrderItemModifier,
  OrderItem,
  OrderStatus,
  OrderType,
  Order,
};

// Exportar los valores de los enums para uso en runtime
export const OrderStatusEnum = orderStatusSchema.enum;
export const OrderTypeEnum = orderTypeSchema.enum;

// --- Tipos específicos del módulo de Órdenes que no son entidades de dominio ---

// Tipos extendidos para el menú completo con relaciones anidadas
export interface FullMenuModifierGroup extends ModifierGroup {
  productModifiers?: Modifier[];
}

export interface FullMenuProduct extends Product {
  variants?: ProductVariant[];
  modifierGroups?: FullMenuModifierGroup[];
}

export interface FullMenuSubCategory extends SubCategory {
  products?: FullMenuProduct[];
}

export interface FullMenuCategory extends Category {
  subcategories?: FullMenuSubCategory[];
}

// DTO para filtrar órdenes (basado en el backend DTO)
// Este tipo es específico para la API de este módulo, por lo que permanece aquí.
export interface FindAllOrdersDto {
  userId?: string;
  tableId?: string;
  orderStatus?: OrderStatus | OrderStatus[]; // Permitir un array de estados
  orderType?: OrderType;
  startDate?: string; // Usar string para fechas en DTOs
  endDate?: string; // Usar string para fechas en DTOs
  page?: number; // Añadir paginación
  limit?: number; // Añadir paginación
  // Añadir otros campos de filtro si existen en el backend DTO
}

// Otros tipos específicos de este módulo podrían ir aquí, por ejemplo:
// - Tipos para el estado del carrito si no se maneja con Zustand/Context
// - Tipos para formularios específicos de este módulo

// Tipo optimizado para lista de órdenes abiertas
export interface OrderOpenList
  extends Omit<
    Order,
    'orderItems' | 'payments' | 'adjustments' | 'user' | 'customer'
  > {
  // Información básica de la mesa
  table?: {
    id: string;
    number: number;
    name: string;
    isTemporary: boolean;
    area?: {
      name: string;
    };
  } | null;

  // Información básica de entrega
  deliveryInfo?: {
    recipientName: string;
    recipientPhone: string | null;
    fullAddress: string;
  } | null;

  // Campos adicionales calculados
  paymentsSummary?: {
    totalPaid: number;
  };
  preparationScreens?: string[];
  preparationScreenStatuses?: Array<{
    name: string;
    status: 'PENDING' | 'IN_PROGRESS' | 'READY';
  }>;
  ticketImpressionCount?: number;

  // Información del usuario creador
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaConfigurationModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  IconButton,
  HelperText,
  Divider,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Controller, useForm } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { pizzaConfigurationsService } from '../services/pizzaConfigurationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { Product } from '@/modules/menu/schema/products.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

interface PizzaConfigurationModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product | null;
}

const configurationSchema = z.object({
  includedToppings: z.number().int().min(0),
  extraToppingCost: z.number().min(0),
});

type ConfigurationFormData = z.infer<typeof configurationSchema>;

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: responsive.spacing(theme.spacing.l),
      borderRadius: theme.roundness * 2,
      maxHeight: responsive.isTablet ? '85%' : '80%',
      maxWidth: responsive.isTablet ? 650 : 500,
      width: responsive.isTablet ? '85%' : '100%',
      alignSelf: 'center',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: responsive.spacing(theme.spacing.m),
      paddingBottom: 0,
    },
    title: {
      fontSize: responsive.fontSize(20),
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    closeButton: {
      margin: 0,
    },
    content: {
      padding: responsive.spacing(theme.spacing.m),
    },
    productInfo: {
      backgroundColor: theme.colors.surfaceVariant,
      padding: responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness,
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    productName: {
      fontWeight: '600',
      marginBottom: responsive.spacing(theme.spacing.xs),
      fontSize: responsive.fontSize(16),
    },
    section: {
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    sectionTitle: {
      marginBottom: responsive.spacing(theme.spacing.m),
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.fontSize(16),
    },
    input: {
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surface,
    },
    helperText: {
      marginTop: -responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.m),
      fontSize: responsive.fontSize(12),
    },
    infoBox: {
      backgroundColor: theme.colors.primaryContainer,
      padding: responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness,
      marginBottom: responsive.spacing(theme.spacing.m),
    },
    infoText: {
      color: theme.colors.onPrimaryContainer,
      fontSize: responsive.fontSize(12),
    },
    example: {
      marginTop: responsive.spacing(theme.spacing.m),
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    exampleTitle: {
      fontWeight: '600',
      marginBottom: responsive.spacing(theme.spacing.xs),
      fontSize: responsive.fontSize(14),
    },
    exampleText: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      gap: responsive.spacing(theme.spacing.m),
    },
    actionButton: {
      flex: 1,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      maxWidth: responsive.isTablet ? 180 : 160,
    },
    cancelButton: {
      borderColor: theme.colors.outlineVariant,
    },
    saveButton: {
      borderWidth: 0,
    },
    buttonLabel: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
    },
  });

export function PizzaConfigurationModal({
  visible,
  onDismiss,
  product,
}: PizzaConfigurationModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [extraCostText, setExtraCostText] = useState('20.00');

  // Query para obtener la configuración existente
  const { data: configuration, isLoading: _isLoading } = useQuery({
    queryKey: ['pizza-configuration', product?.id],
    queryFn: async () => {
      if (!product?.id) return null;
      try {
        return await pizzaConfigurationsService.findByProductId(product.id);
      } catch (error) {
        return null;
      }
    },
    enabled: !!product?.id && visible,
  });

  // Form
  const {
    control,
    handleSubmit,
    formState: { errors, isDirty },
    reset,
    setValue,
    getValues: _getValues,
  } = useForm<ConfigurationFormData>({
    resolver: zodResolver(configurationSchema),
    defaultValues: {
      includedToppings: 4,
      extraToppingCost: 20,
    },
  });

  // Cargar datos de configuración existente
  useEffect(() => {
    if (visible && product) {
      if (
        configuration &&
        configuration.extraToppingCost !== undefined &&
        configuration.extraToppingCost !== null
      ) {
        const cost = Number(configuration.extraToppingCost);
        const toppings = Number(configuration.includedToppings) || 4;
        reset({
          includedToppings: toppings,
          extraToppingCost: cost,
        });
        setExtraCostText(cost.toFixed(2));
        // Asegurar que el valor esté sincronizado
        setValue('extraToppingCost', cost, { shouldValidate: false });
      } else {
        // Reset a valores por defecto cuando se abre el modal sin configuración
        const defaultCost = 20;
        const defaultToppings = 4;
        reset({
          includedToppings: defaultToppings,
          extraToppingCost: defaultCost,
        });
        setExtraCostText(defaultCost.toFixed(2));
        // Asegurar que el valor esté sincronizado
        setValue('extraToppingCost', defaultCost, { shouldValidate: false });
      }
    }
  }, [configuration, reset, visible, product, setValue]);

  // Mutation para guardar
  const saveMutation = useMutation({
    mutationFn: async (data: ConfigurationFormData) => {
      if (!product) throw new Error('No product selected');

      if (configuration) {
        return await pizzaConfigurationsService.update(configuration.id, data);
      } else {
        return await pizzaConfigurationsService.create({
          ...data,
          productId: product.id,
        });
      }
    },
    onSuccess: () => {
      showSnackbar({
        message: 'Configuración guardada exitosamente',
        type: 'success',
      });
      queryClient.invalidateQueries({
        queryKey: ['pizza-configuration', product?.id],
      });
      queryClient.invalidateQueries({ queryKey: ['pizza-configurations'] });
      onDismiss();
    },
    onError: (error) => {
      showSnackbar({
        message: error instanceof Error ? error.message : 'Error al guardar',
        type: 'error',
      });
    },
  });

  const onSubmit = (data: ConfigurationFormData) => {
    saveMutation.mutate(data);
  };

  if (!product) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (isDirty) {
            setShowConfirmation(true);
          } else {
            onDismiss();
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={true}
      >
        <View style={styles.header}>
          <Text style={styles.title}>Configuración de Pizza</Text>
          <IconButton
            icon="close"
            size={24}
            onPress={() => {
              if (isDirty) {
                setShowConfirmation(true);
              } else {
                onDismiss();
              }
            }}
            style={styles.closeButton}
          />
        </View>

        <Divider />

        <ScrollView style={styles.content}>
          <View style={styles.productInfo}>
            <Text variant="titleMedium" style={styles.productName}>
              {product.name}
            </Text>
            <Text variant="bodySmall">
              {product.variants?.length || 0} variantes disponibles
            </Text>
          </View>

          <View style={styles.section}>
            <View style={styles.infoBox}>
              <Text style={styles.infoText}>
                ℹ️ Esta configuración determina cuántos toppings están incluidos
                en el precio base y cuánto se cobra por cada topping adicional.
              </Text>
            </View>

            <Controller
              control={control}
              name="includedToppings"
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Toppings incluidos en el precio base *"
                  value={value?.toString() || ''}
                  onChangeText={(text) => {
                    // Solo permitir números enteros
                    const cleanText = text.replace(/[^0-9]/g, '');
                    if (cleanText === '') {
                      onChange(0);
                    } else {
                      const num = parseInt(cleanText, 10);
                      onChange(isNaN(num) ? 0 : num);
                    }
                  }}
                  onBlur={onBlur}
                  mode="outlined"
                  style={styles.input}
                  keyboardType="number-pad"
                  error={!!errors.includedToppings}
                />
              )}
            />
            {errors.includedToppings && (
              <HelperText type="error" visible style={styles.helperText}>
                Debe ser un número entero mayor o igual a 0
              </HelperText>
            )}
            <HelperText type="info" visible style={styles.helperText}>
              Cantidad de toppings que el cliente puede elegir sin costo
              adicional
            </HelperText>

            <Controller
              control={control}
              name="extraToppingCost"
              render={({ field: { onChange, onBlur } }) => (
                <TextInput
                  label="Costo por topping adicional *"
                  value={extraCostText}
                  onChangeText={(text) => {
                    // Permitir números y punto decimal
                    let cleanText = text.replace(/[^0-9.]/g, '');

                    // Evitar múltiples puntos decimales
                    const parts = cleanText.split('.');
                    if (parts.length > 2) {
                      cleanText = parts[0] + '.' + parts.slice(1).join('');
                    }

                    // Limitar a 2 decimales
                    if (parts.length === 2 && parts[1].length > 2) {
                      cleanText = parts[0] + '.' + parts[1].substring(0, 2);
                    }

                    // Actualizar el texto mostrado
                    setExtraCostText(cleanText);

                    // Convertir a número y actualizar el formulario
                    const numValue = parseFloat(cleanText);
                    if (!isNaN(numValue)) {
                      onChange(numValue);
                      setValue('extraToppingCost', numValue, {
                        shouldValidate: true,
                      });
                    } else if (cleanText === '' || cleanText === '.') {
                      onChange(0);
                      setValue('extraToppingCost', 0, { shouldValidate: true });
                    }
                  }}
                  onBlur={() => {
                    onBlur();
                    // Formatear al perder el foco
                    const numValue = parseFloat(extraCostText);
                    if (!isNaN(numValue)) {
                      setExtraCostText(numValue.toFixed(2));
                      setValue('extraToppingCost', numValue, {
                        shouldValidate: true,
                      });
                    } else {
                      setExtraCostText('0.00');
                      setValue('extraToppingCost', 0, { shouldValidate: true });
                    }
                  }}
                  mode="outlined"
                  style={styles.input}
                  keyboardType="decimal-pad"
                  error={!!errors.extraToppingCost}
                  left={<TextInput.Affix text="$" />}
                />
              )}
            />
            {errors.extraToppingCost && (
              <HelperText type="error" visible style={styles.helperText}>
                {errors.extraToppingCost.message ||
                  'Debe ser un número mayor o igual a 0'}
              </HelperText>
            )}
            <HelperText type="info" visible style={styles.helperText}>
              Precio que se cobra por cada topping después de los incluidos
            </HelperText>

            <View style={styles.example}>
              <Text variant="labelLarge" style={styles.exampleTitle}>
                Ejemplo de cálculo:
              </Text>
              <Text style={styles.exampleText}>
                Si configuras 4 toppings incluidos y $20 por extra:{'\n'}•
                Cliente elige 4 toppings: Sin costo adicional{'\n'}• Cliente
                elige 6 toppings: +$40 (2 extras × $20)
              </Text>
            </View>
          </View>
        </ScrollView>

        <Divider />

        <View style={styles.actions}>
          <Button
            mode="outlined"
            onPress={() => {
              if (isDirty) {
                setShowConfirmation(true);
              } else {
                onDismiss();
              }
            }}
            style={[styles.actionButton, styles.cancelButton]}
            contentStyle={{ paddingVertical: responsive.isTablet ? 4 : 6 }}
            labelStyle={styles.buttonLabel}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSubmit(onSubmit)}
            loading={saveMutation.isPending}
            style={[styles.actionButton, styles.saveButton]}
            contentStyle={{ paddingVertical: responsive.isTablet ? 4 : 6 }}
            labelStyle={styles.buttonLabel}
          >
            Guardar
          </Button>
        </View>
      </Modal>

      <ConfirmationModal
        visible={showConfirmation}
        title="¿Salir sin guardar?"
        message="Los cambios se perderán"
        confirmText="Salir"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={() => {
          setShowConfirmation(false);
          reset();
          setExtraCostText('20.00');
          onDismiss();
        }}
        onCancel={() => setShowConfirmation(false)}
        onDismiss={() => setShowConfirmation(false)}
      />
    </Portal>
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationFormModal.tsx
================
import React, { useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Pressable,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  Switch,
  SegmentedButtons,
  HelperText,
  ActivityIndicator,
  IconButton,
  Surface,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  pizzaCustomizationFormSchema,
  PizzaCustomizationFormInputs,
} from '../schema/pizzaCustomization.schema';
import {
  usePizzaCustomization,
  useCreatePizzaCustomization,
  useUpdatePizzaCustomization,
} from '../hooks/usePizzaCustomizationsQueries';
import { CustomizationType } from '../types/pizzaCustomization.types';

interface PizzaCustomizationFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  customizationId?: string;
  onSuccess?: () => void;
}

const createStyles = (theme: any, responsive: any) => {
  const isTablet = responsive.isTablet;

  return StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    backdrop: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
      backgroundColor: theme.colors.surface,
      borderRadius: 28,
      maxHeight: isTablet ? '90%' : '85%',
      minHeight: isTablet ? 600 : undefined,
      maxWidth: isTablet ? 650 : 500,
      width: '100%',
      alignSelf: 'center',
      overflow: 'hidden',
      elevation: 24,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 12,
      },
      shadowOpacity: 0.58,
      shadowRadius: 16.0,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.l),
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    headerTitle: {
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    closeButton: {
      margin: -responsive.spacing(theme.spacing.xs),
    },
    scrollContent: {
      padding: responsive.spacing(theme.spacing.l),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    formGroup: {
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    label: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(theme.spacing.xs),
      marginLeft: responsive.spacing(theme.spacing.xs),
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    segmentedButtons: {
      marginBottom: responsive.spacing(theme.spacing.xs),
      borderRadius: 16,
    },
    row: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    halfWidth: {
      flex: 1,
    },
    switchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.l),
      backgroundColor: theme.colors.secondaryContainer,
      borderRadius: 16,
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    switchLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSecondaryContainer,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.spacing(theme.spacing.l),
      paddingTop: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.elevation.level1,
    },
    button: {
      borderRadius: 24,
      flex: 1,
      maxWidth: isTablet ? 180 : 160,
    },
    buttonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    loadingContainer: {
      padding: responsive.spacing(theme.spacing.xl * 2),
      alignItems: 'center',
    },
    inputStyle: {
      backgroundColor: theme.colors.elevation.level1,
    },
  });
};

export function PizzaCustomizationFormModal({
  visible,
  onDismiss,
  customizationId,
  onSuccess,
}: PizzaCustomizationFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const isEditMode = !!customizationId;
  const styles = createStyles(theme, responsive);

  const { data: customization, isLoading: isLoadingCustomization } =
    usePizzaCustomization(customizationId || '');

  const createMutation = useCreatePizzaCustomization();
  const updateMutation = useUpdatePizzaCustomization();

  const {
    control,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
    setValue,
  } = useForm<PizzaCustomizationFormInputs>({
    resolver: zodResolver(pizzaCustomizationFormSchema),
    defaultValues: {
      name: '',
      type: CustomizationType.INGREDIENT,
      ingredients: '',
      toppingValue: 1,
      isActive: true,
      sortOrder: 100,
    },
  });

  const watchType = watch('type');

  useEffect(() => {
    if (customization && isEditMode) {
      reset({
        name: customization.name,
        type: customization.type,
        ingredients: customization.ingredients || '',
        toppingValue: customization.toppingValue,
        isActive: customization.isActive,
        sortOrder: customization.sortOrder,
      });
    } else if (!visible) {
      reset({
        name: '',
        type: CustomizationType.INGREDIENT,
        ingredients: '',
        toppingValue: 1,
        isActive: true,
        sortOrder: 100,
      });
    }
  }, [customization, isEditMode, reset, visible]);

  // Limpiar ingredientes cuando se cambie de FLAVOR a INGREDIENT
  useEffect(() => {
    if (watchType === CustomizationType.INGREDIENT) {
      setValue('ingredients', '');
    }
  }, [watchType, setValue]);

  const onSubmit = async (data: PizzaCustomizationFormInputs) => {
    try {
      // Asegurar que los ingredientes estén vacíos para tipo INGREDIENT
      const submissionData = {
        ...data,
        ingredients:
          data.type === CustomizationType.INGREDIENT ? '' : data.ingredients,
      };

      if (isEditMode && customizationId) {
        await updateMutation.mutateAsync({
          id: customizationId,
          data: submissionData,
        });
      } else {
        await createMutation.mutateAsync(submissionData);
      }
      onSuccess?.();
      onDismiss();
    } catch (error) {
      // El error ya se maneja en los hooks con snackbar
    }
  };

  if (isLoadingCustomization && isEditMode) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.container}
        >
          <Pressable style={styles.backdrop} onPress={onDismiss} />
          <Surface style={styles.modalContent} elevation={5}>
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
              <Text
                variant="bodyLarge"
                style={{
                  marginTop: responsive.spacing(theme.spacing.m),
                  color: theme.colors.onSurfaceVariant,
                }}
              >
                Cargando personalización...
              </Text>
            </View>
          </Surface>
        </Modal>
      </Portal>
    );
  }

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.container}
      >
        <Pressable style={styles.backdrop} onPress={onDismiss} />
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ width: '100%' }}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View style={styles.header}>
              <Text style={styles.headerTitle}>
                {isEditMode ? 'Editar' : 'Nueva'} personalización
              </Text>
              <IconButton
                icon="close"
                size={20}
                onPress={onDismiss}
                iconColor={theme.colors.onSurfaceVariant}
                style={styles.closeButton}
              />
            </View>

            <ScrollView
              contentContainerStyle={styles.scrollContent}
              showsVerticalScrollIndicator={false}
            >
              <View style={styles.formGroup}>
                <Text style={styles.label}>Nombre del producto</Text>
                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      placeholder="Ej: Pepperoni, Hawaiana"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.name}
                      mode="outlined"
                      outlineColor={theme.colors.outline}
                      activeOutlineColor={theme.colors.primary}
                      style={styles.inputStyle}
                      outlineStyle={{ borderRadius: 12 }}
                    />
                  )}
                />
                {errors.name && (
                  <HelperText type="error" visible={!!errors.name}>
                    {errors.name.message}
                  </HelperText>
                )}
              </View>

              <View style={styles.formGroup}>
                <Text style={styles.label}>Tipo de personalización</Text>
                <Controller
                  control={control}
                  name="type"
                  render={({ field: { onChange, value } }) => (
                    <SegmentedButtons
                      value={value}
                      onValueChange={onChange}
                      buttons={[
                        {
                          value: CustomizationType.FLAVOR,
                          label: 'Sabor',
                          icon: 'pizza',
                          style: {
                            backgroundColor:
                              value === CustomizationType.FLAVOR
                                ? theme.colors.primaryContainer
                                : 'transparent',
                          },
                        },
                        {
                          value: CustomizationType.INGREDIENT,
                          label: 'Ingrediente',
                          icon: 'cheese',
                          style: {
                            backgroundColor:
                              value === CustomizationType.INGREDIENT
                                ? theme.colors.primaryContainer
                                : 'transparent',
                          },
                        },
                      ]}
                      style={styles.segmentedButtons}
                    />
                  )}
                />
              </View>

              {watchType === CustomizationType.FLAVOR && (
                <View style={styles.formGroup}>
                  <Text style={styles.label}>Ingredientes del sabor</Text>
                  <Controller
                    control={control}
                    name="ingredients"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="Ej: Jamón, Piña, Queso"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.ingredients}
                        mode="outlined"
                        multiline
                        numberOfLines={2}
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={{ borderRadius: 12 }}
                      />
                    )}
                  />
                  {errors.ingredients && (
                    <HelperText type="error" visible={!!errors.ingredients}>
                      {errors.ingredients.message}
                    </HelperText>
                  )}
                </View>
              )}

              <View style={styles.row}>
                <View style={styles.halfWidth}>
                  <Text style={styles.label}>Valor del topping</Text>
                  <Controller
                    control={control}
                    name="toppingValue"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="0"
                        value={value?.toString() || ''}
                        onChangeText={(text) => {
                          const num = parseInt(text, 10);
                          onChange(isNaN(num) ? 0 : num);
                        }}
                        onBlur={onBlur}
                        error={!!errors.toppingValue}
                        mode="outlined"
                        keyboardType="numeric"
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={{ borderRadius: 12 }}
                      />
                    )}
                  />
                  {errors.toppingValue && (
                    <HelperText type="error" visible={!!errors.toppingValue}>
                      {errors.toppingValue.message}
                    </HelperText>
                  )}
                </View>

                <View style={styles.halfWidth}>
                  <Text style={styles.label}>Orden de aparición</Text>
                  <Controller
                    control={control}
                    name="sortOrder"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="100"
                        value={value?.toString() || ''}
                        onChangeText={(text) => {
                          const num = parseInt(text, 10);
                          onChange(isNaN(num) ? 0 : num);
                        }}
                        onBlur={onBlur}
                        error={!!errors.sortOrder}
                        mode="outlined"
                        keyboardType="numeric"
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={{ borderRadius: 12 }}
                      />
                    )}
                  />
                  {errors.sortOrder && (
                    <HelperText type="error" visible={!!errors.sortOrder}>
                      {errors.sortOrder.message}
                    </HelperText>
                  )}
                </View>
              </View>

              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.switchRow}>
                    <Text style={styles.switchLabel}>Activo</Text>
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      color={theme.colors.primary}
                    />
                  </View>
                )}
              />
            </ScrollView>

            <View style={styles.footer}>
              <Button
                mode="contained-tonal"
                onPress={onDismiss}
                disabled={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                style={styles.button}
                contentStyle={styles.buttonContent}
                labelStyle={{
                  fontSize: responsive.fontSize(16),
                  fontWeight: '600',
                }}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleSubmit(onSubmit)}
                loading={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                disabled={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                style={[
                  styles.button,
                  { backgroundColor: theme.colors.primary },
                ]}
                contentStyle={styles.buttonContent}
                labelStyle={{
                  fontSize: responsive.fontSize(16),
                  fontWeight: '600',
                }}
                icon={isEditMode ? 'check' : 'plus'}
              >
                {isEditMode ? 'Guardar' : 'Crear'}
              </Button>
            </View>
          </Surface>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
}

================
File: app/src/modules/preparationScreens/components/PreparationScreenFormModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  List,
  Divider,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { User, RoleEnum } from '@/modules/users/types/user.types';
import { useGetUsers } from '@/modules/users/hooks/useUsers';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  CreatePreparationScreenSchema,
  UpdatePreparationScreenSchema,
} from '../schema/preparationScreen.schema';
import {
  useCreatePreparationScreen,
  useUpdatePreparationScreen,
  useGetPreparationScreens,
} from '../hooks/usePreparationScreensQueries';

interface PreparationScreenFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  editingItem: PreparationScreen | null;
  onSubmitSuccess?: () => void;
}

type FormData = CreatePreparationScreenDto | UpdatePreparationScreenDto;

const PreparationScreenFormModal: React.FC<PreparationScreenFormModalProps> = ({
  visible,
  onDismiss,
  editingItem,
  onSubmitSuccess,
}) => {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  const isEditing = !!editingItem;
  const [showUserDropdown, setShowUserDropdown] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);

  // Obtener todos los usuarios activos
  const { data: usersData, isLoading: isLoadingUsers } = useGetUsers({
    filters: {
      isActive: true,
    },
  });

  // Obtener todas las pantallas de preparación para verificar usuarios asignados
  const { data: screensData } = useGetPreparationScreens(
    {},
    { page: 1, limit: 100 }, // Obtener todas las pantallas
  );

  // Crear mapa de usuarios asignados a pantallas
  const userAssignments = React.useMemo(() => {
    if (!screensData?.data) return new Map<string, string>();

    const assignments = new Map<string, string>();
    screensData.data.forEach((screen) => {
      // Excluir la pantalla actual al editar
      if (editingItem && screen.id === editingItem.id) return;

      if (screen.users && screen.users.length > 0) {
        screen.users.forEach((user) => {
          assignments.set(user.id, screen.name);
        });
      }
    });
    return assignments;
  }, [screensData, editingItem]);

  // Todos los usuarios, ordenados con los de cocina primero y disponibles al inicio
  const allUsers = React.useMemo(() => {
    if (!usersData?.data) return [];

    return usersData.data.sort((a, b) => {
      // Primero ordenar por disponibilidad
      const aAssigned = userAssignments.has(a.id);
      const bAssigned = userAssignments.has(b.id);
      if (!aAssigned && bAssigned) return -1;
      if (aAssigned && !bAssigned) return 1;

      // Luego por rol de cocina
      const aIsKitchen = a.role?.id === RoleEnum.KITCHEN;
      const bIsKitchen = b.role?.id === RoleEnum.KITCHEN;
      if (aIsKitchen && !bIsKitchen) return -1;
      if (!aIsKitchen && bIsKitchen) return 1;

      return 0;
    });
  }, [usersData, userAssignments]);

  // Hooks de mutación
  const createScreen = useCreatePreparationScreen();
  const updateScreen = useUpdatePreparationScreen();

  // Configuración del formulario
  const formSchema = isEditing
    ? UpdatePreparationScreenSchema
    : CreatePreparationScreenSchema;

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
  } = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      description: undefined,
      isActive: true,
      userId: '',
    },
  });

  // Efecto para cargar datos al editar
  useEffect(() => {
    if (editingItem) {
      reset({
        name: editingItem.name,
        description: editingItem.description ?? undefined,
        isActive: editingItem.isActive,
        userId:
          editingItem.users && editingItem.users.length > 0
            ? editingItem.users[0].id
            : '', // Siempre string vacío para activar validación
      });
      setSelectedUser(
        editingItem.users && editingItem.users.length > 0
          ? (editingItem.users[0] as User)
          : null,
      );
    } else {
      reset({
        name: '',
        description: undefined,
        isActive: true,
        userId: '',
      });
      setSelectedUser(null);
    }
  }, [editingItem, reset]);

  // Manejo del envío del formulario
  const onSubmit = async (data: FormData) => {
    try {
      if (isEditing && editingItem) {
        await updateScreen.mutateAsync({
          id: editingItem.id,
          data: data as UpdatePreparationScreenDto,
        });
      } else {
        await createScreen.mutateAsync(data as CreatePreparationScreenDto);
      }
      onSubmitSuccess?.();
      onDismiss();
    } catch (error: any) {
      // No mostrar snackbar aquí porque el hook ya lo hace
      // Solo hacer log para debugging
    }
  };

  // Manejo de selección de usuario
  const handleUserSelect = (user: User) => {
    setSelectedUser(user);
    setValue('userId', user.id);
    setShowUserDropdown(false);
  };

  const handleClearUser = () => {
    setSelectedUser(null);
    setValue('userId', '');
  };

  const isSubmitting = createScreen.isPending || updateScreen.isPending;

  // Funciones auxiliares para roles
  const getRoleLabel = (roleId?: number) => {
    switch (roleId) {
      case RoleEnum.ADMIN:
        return 'Administrador';
      case RoleEnum.MANAGER:
        return 'Gerente';
      case RoleEnum.CASHIER:
        return 'Cajero';
      case RoleEnum.WAITER:
        return 'Mesero';
      case RoleEnum.KITCHEN:
        return 'Cocina';
      case RoleEnum.DELIVERY:
        return 'Repartidor';
      default:
        return 'Sin rol';
    }
  };

  const getIconForRole = (roleId?: number) => {
    switch (roleId) {
      case RoleEnum.ADMIN:
        return 'shield-account';
      case RoleEnum.MANAGER:
        return 'account-tie';
      case RoleEnum.CASHIER:
        return 'cash-register';
      case RoleEnum.WAITER:
        return 'room-service';
      case RoleEnum.KITCHEN:
        return 'chef-hat';
      case RoleEnum.DELIVERY:
        return 'moped';
      default:
        return 'account';
    }
  };

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContent}
        >
          <ScrollView>
            <Surface style={styles.surface}>
              <Text variant="headlineSmall" style={styles.title}>
                {isEditing
                  ? 'Editar Pantalla de Preparación'
                  : 'Crear Nueva Pantalla'}
              </Text>

              <View style={styles.form}>
                {/* Campo Nombre */}
                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.field}>
                      <TextInput
                        label="Nombre de la Pantalla *"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.name}
                        disabled={isSubmitting}
                        placeholder="Ej: Cocina Principal, Barra Fría"
                        mode="outlined"
                      />
                      {errors.name && (
                        <HelperText type="error" visible={!!errors.name}>
                          {errors.name.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                {/* Campo Descripción */}
                <Controller
                  control={control}
                  name="description"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.field}>
                      <TextInput
                        label="Descripción (Opcional)"
                        value={value || ''}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.description}
                        disabled={isSubmitting}
                        placeholder="Ej: Pantalla para órdenes de cocina caliente"
                        mode="outlined"
                        multiline
                        numberOfLines={3}
                      />
                      {errors.description && (
                        <HelperText type="error" visible={!!errors.description}>
                          {errors.description.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                {/* Campo Usuario */}
                <Controller
                  control={control}
                  name="userId"
                  render={() => (
                    <View style={styles.field}>
                      <TextInput
                        label="Usuario de Cocina *"
                        value={
                          selectedUser
                            ? `${selectedUser.firstName || ''} ${selectedUser.lastName || ''}`.trim() ||
                              selectedUser.username
                            : ''
                        }
                        mode="outlined"
                        error={!!errors.userId}
                        disabled={isSubmitting || isLoadingUsers}
                        onPressOut={() => {
                          if (
                            !isSubmitting &&
                            !isLoadingUsers &&
                            allUsers.length > 0
                          ) {
                            setShowUserDropdown(true);
                          }
                        }}
                        showSoftInputOnFocus={false}
                        editable={false}
                        right={
                          selectedUser ? (
                            <TextInput.Icon
                              icon="close"
                              onPress={() => {
                                handleClearUser();
                              }}
                              disabled={isSubmitting}
                            />
                          ) : (
                            <TextInput.Icon
                              icon={isLoadingUsers ? 'loading' : 'chevron-down'}
                              disabled={isSubmitting || isLoadingUsers}
                              onPress={() => {
                                if (!isSubmitting && !isLoadingUsers) {
                                  setShowUserDropdown(true);
                                }
                              }}
                            />
                          )
                        }
                      />
                      {errors.userId && (
                        <HelperText type="error" visible={!!errors.userId}>
                          {errors.userId.message}
                        </HelperText>
                      )}
                      {!errors.userId && (
                        <HelperText type="info" visible={true}>
                          Nota: Un usuario solo puede estar asignado a una
                          pantalla a la vez
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                {/* Campo Activa */}
                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.switchField}>
                      <Text variant="bodyLarge">¿Está activa?</Text>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        disabled={isSubmitting}
                        color={theme.colors.primary}
                      />
                    </View>
                  )}
                />
              </View>

              <View style={styles.actions}>
                <Button mode="text" onPress={onDismiss} disabled={isSubmitting}>
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleSubmit(onSubmit)}
                  loading={isSubmitting}
                  disabled={isSubmitting}
                >
                  {isEditing ? 'Actualizar' : 'Crear'}
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </Modal>
      </Portal>

      {/* Dropdown de usuarios */}
      <Portal>
        <Modal
          visible={showUserDropdown}
          onDismiss={() => setShowUserDropdown(false)}
          contentContainerStyle={[styles.dropdownModal, { maxHeight: 300 }]}
        >
          <Surface style={styles.dropdownContent}>
            <View style={styles.dropdownHeader}>
              <Text variant="titleMedium" style={styles.dropdownTitle}>
                Seleccionar Usuario de Cocina
              </Text>
              <Text variant="bodySmall" style={styles.dropdownSubtitle}>
                Solo los usuarios con rol de cocina pueden ser seleccionados
              </Text>
            </View>
            <Divider />
            <ScrollView>
              {isLoadingUsers ? (
                <View style={styles.loadingContainer}>
                  <Text>Cargando usuarios...</Text>
                </View>
              ) : allUsers.length === 0 ? (
                <View style={styles.emptyContainer}>
                  <Text>No hay usuarios disponibles</Text>
                </View>
              ) : (
                allUsers.map((user) => {
                  const displayName =
                    `${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username;
                  const isKitchenUser = user.role?.id === RoleEnum.KITCHEN;
                  const roleLabel = getRoleLabel(user.role?.id);
                  const assignedScreen = userAssignments.get(user.id);
                  const isAssigned = !!assignedScreen;
                  const isSelectable = isKitchenUser && !isAssigned;

                  return (
                    <List.Item
                      key={user.id}
                      title={displayName}
                      description={
                        isAssigned
                          ? `Asignado a: ${assignedScreen}`
                          : `${user.username !== displayName ? user.username + ' • ' : ''}${roleLabel}`
                      }
                      onPress={
                        isSelectable ? () => handleUserSelect(user) : undefined
                      }
                      left={(props) => (
                        <List.Icon
                          {...props}
                          icon={getIconForRole(user.role?.id)}
                          color={
                            isAssigned ? theme.colors.outline : props.color
                          }
                        />
                      )}
                      style={[
                        styles.dropdownItem,
                        !isSelectable && styles.disabledDropdownItem,
                      ]}
                      disabled={!isSelectable}
                      titleStyle={!isSelectable && styles.disabledText}
                      descriptionStyle={[
                        !isSelectable && styles.disabledText,
                        isAssigned && { color: theme.colors.error },
                      ]}
                    />
                  );
                })
              )}
            </ScrollView>
          </Surface>
        </Modal>
      </Portal>
    </>
  );
};

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      margin: 20,
    },
    surface: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    title: {
      padding: 24,
      paddingBottom: 16,
      color: theme.colors.onSurface,
    },
    form: {
      paddingHorizontal: 24,
    },
    field: {
      marginBottom: 16,
    },
    switchField: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 16,
      paddingVertical: 8,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      padding: 16,
      paddingTop: 8,
      gap: 8,
      borderTopWidth: 1,
      borderTopColor: theme.colors.surfaceVariant,
    },
    dropdownModal: {
      margin: 20,
      marginTop: '30%',
    },
    dropdownContent: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    dropdownHeader: {
      padding: 16,
      paddingBottom: 12,
    },
    dropdownTitle: {
      marginBottom: 4,
    },
    dropdownSubtitle: {
      color: theme.colors.onSurfaceVariant,
    },
    dropdownItem: {
      paddingHorizontal: 16,
    },
    disabledDropdownItem: {
      opacity: 0.5,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    disabledText: {
      color: theme.colors.onSurfaceDisabled,
    },
    loadingContainer: {
      padding: 20,
      alignItems: 'center',
    },
    emptyContainer: {
      padding: 20,
      alignItems: 'center',
    },
  });

export default PreparationScreenFormModal;

================
File: app/src/modules/receipts/types/receipt.types.ts
================
import type {
  OrderType,
  OrderStatus,
} from '@/modules/orders/types/orders.types';

// Tipo para la lista optimizada de recibos
export interface ReceiptList {
  id: string;
  shiftOrderNumber: number;
  orderType: OrderType;
  orderStatus: OrderStatus;
  total: number;
  createdAt: string;
  scheduledAt?: string;
  finalizedAt: string;
  notes?: string;
  paymentsSummary?: {
    totalPaid: number;
  };
  table?: {
    id: string;
    number: string;
    name: string;
    isTemporary: boolean;
    area?: {
      name: string;
    };
  };
  deliveryInfo?: {
    recipientName?: string;
    recipientPhone?: string;
    fullAddress?: string;
  };
  preparationScreenStatuses?: Array<{
    name: string;
    status: 'PENDING' | 'IN_PROGRESS' | 'READY';
  }>;
  ticketImpressionCount?: number;
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
  isFromWhatsApp?: boolean;
}

// Tipo para el detalle completo del recibo
export interface Receipt {
  id: string;
  shiftOrderNumber: number;
  orderType: OrderType;
  orderStatus: OrderStatus;
  total: number;
  subtotal: number;
  createdAt: string;
  updatedAt: string;
  finalizedAt?: string;
  scheduledAt?: string;
  notes?: string;
  userId?: string;
  tableId?: string;
  customerId?: string;
  isFromWhatsApp?: boolean;
  estimatedDeliveryTime?: string;
  user?: {
    id: string;
    firstName?: string;
    lastName?: string;
    username?: string;
  };
  table?: {
    id: string;
    number: string;
    name: string;
    isTemporary: boolean;
    area?: {
      id: string;
      name: string;
    };
  };
  customer?: {
    id: string;
    name: string;
    phone?: string;
    email?: string;
  };
  deliveryInfo?: {
    id: string;
    recipientName?: string;
    recipientPhone?: string;
    deliveryInstructions?: string;
    fullAddress?: string;
    street?: string;
    number?: string;
    interiorNumber?: string;
    neighborhood?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    country?: string;
    latitude?: number;
    longitude?: number;
  };
  preparationScreens?: string[];
  orderItems: Array<{
    id: string;
    quantity?: number;
    basePrice: number;
    finalPrice: number;
    preparationNotes?: string;
    preparationStatus?: string;
    product: {
      id: string;
      name: string;
      description?: string;
      price: number;
    };
    productVariant?: {
      id: string;
      name: string;
      price: number;
    };
    productModifiers?: Array<{
      id: string;
      name: string;
      price: number;
    }>;
    selectedPizzaCustomizations?: Array<any>;
  }>;
  payments?: Array<{
    id: string;
    amount: number;
    paymentMethod: string;
    paymentStatus: string;
    createdAt: string;
    updatedAt: string;
  }>;
  adjustments?: Array<{
    id: string;
    type: string;
    amount: number;
    reason?: string;
    createdAt: string;
  }>;
  ticketImpressions?: Array<{
    id: string;
    ticketType: string;
    impressionTime: string;
    user?: {
      id: string;
      firstName?: string;
      lastName?: string;
    };
    printer?: {
      id: string;
      name: string;
    };
  }>;
}

// Respuesta de lista de recibos (sin paginación)
export type ReceiptsListResponse = ReceiptList[];

// Filtros para buscar recibos
export interface ReceiptFilters {
  startDate?: string;
  endDate?: string;
  orderType?: OrderType;
}

================
File: app/src/modules/shiftAudit/components/ShiftOrdersModal.tsx
================
import React, { useState, useMemo } from 'react';
import {
  Modal,
  View,
  StyleSheet,
  TouchableOpacity,
  RefreshControl,
  FlatList,
} from 'react-native';
import {
  Portal,
  Appbar,
  Searchbar,
  Text,
  ActivityIndicator,
} from 'react-native-paper';
import OrderSummaryCard from '@/modules/shared/components/OrderSummaryCard';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useShiftOrders } from '../hooks/useShiftOrders';
import EmptyState from '@/app/components/common/EmptyState';
import type { Order } from '@/app/schemas/domain/order.schema';
import { OrderTypeEnum } from '@/modules/orders/types/orders.types';
import {
  formatOrderTypeShort,
  getPaymentStatus,
} from '@/app/utils/orderFormatters';
import { receiptService } from '@/modules/receipts/services/receiptService';
import type { Receipt } from '@/modules/receipts/types/receipt.types';
import { OrderDetailsView } from './OrderDetailsView';
import { OrderHistoryView } from './OrderHistoryView';

interface ShiftOrdersModalProps {
  visible: boolean;
  onClose: () => void;
  shiftId: string;
}

export function ShiftOrdersModal({
  visible,
  onClose,
  shiftId,
}: ShiftOrdersModalProps) {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const [searchQuery, setSearchQuery] = useState('');
  const [selectedReceipt, setSelectedReceipt] = useState<Receipt | null>(null);
  const [showReceiptDetails, setShowReceiptDetails] = useState(false);
  const [showOrderHistory, setShowOrderHistory] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);

  const {
    data: orders,
    isLoading,
    error,
    refetch,
    isRefetching,
  } = useShiftOrders(shiftId);

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };

  const handleReceiptPress = async (order: Order) => {
    try {
      const fullOrder = await receiptService.getReceiptById(order.id);
      setSelectedReceipt(fullOrder);
      setShowReceiptDetails(true);
    } catch (error) {
      // Error al cargar detalles del recibo
    }
  };

  // Filtrar órdenes basado en búsqueda
  const filteredOrders = useMemo(() => {
    if (!orders) return [];
    if (!searchQuery.trim()) return orders;

    const search = searchQuery.toLowerCase().trim();
    return orders.filter((order) => {
      // Buscar por número de orden
      if (order.shiftOrderNumber?.toString().includes(search)) return true;
      if (order.orderNumber?.toString().includes(search)) return true;

      // Buscar en información de entrega
      if (order.deliveryInfo) {
        // Campos principales
        if (order.deliveryInfo.customerName?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.customerPhone?.includes(search)) return true;
        if (order.deliveryInfo.address?.toLowerCase().includes(search))
          return true;

        // Campos alternativos que pueden venir del backend
        if (order.deliveryInfo.recipientName?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.recipientPhone?.includes(search)) return true;
        if (order.deliveryInfo.fullAddress?.toLowerCase().includes(search))
          return true;

        // Campos adicionales de dirección
        if (order.deliveryInfo.street?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.neighborhood?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.city?.toLowerCase().includes(search))
          return true;
      }

      // Buscar en mesa/área para órdenes locales
      if (order.table) {
        if (order.table.name?.toLowerCase().includes(search)) return true;
        if (order.table.number?.toString().includes(search)) return true;
        if (order.table.area?.name?.toLowerCase().includes(search)) return true;
      }

      // Buscar en área directa
      if (order.area?.name?.toLowerCase().includes(search)) return true;

      // Buscar en notas
      if (order.notes?.toLowerCase().includes(search)) return true;

      // Buscar en nombre del usuario creador
      if (order.createdBy) {
        if (order.createdBy.firstName?.toLowerCase().includes(search))
          return true;
        if (order.createdBy.lastName?.toLowerCase().includes(search))
          return true;
        if (order.createdBy.username?.toLowerCase().includes(search))
          return true;
      }

      // Buscar en user (campo alternativo)
      if (order.user) {
        if (order.user.firstName?.toLowerCase().includes(search)) return true;
        if (order.user.lastName?.toLowerCase().includes(search)) return true;
      }

      return false;
    });
  }, [orders, searchQuery]);

  // Función específica para el color de estado en recibos
  const getReceiptStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return theme.colors.primary;
      case 'CANCELLED':
        return theme.colors.error;
      case 'DELIVERED':
        return '#9333EA'; // Morado
      default:
        return theme.colors.onSurfaceDisabled;
    }
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      case 'DELIVERED':
        return 'Entregada';
      default:
        return status;
    }
  };

  // Renderizar item de recibo usando el componente compartido
  const renderReceiptItem = ({ item }: { item: Order }) => (
    <OrderSummaryCard
      item={item}
      onPress={() => handleReceiptPress(item)}
      getStatusColor={getReceiptStatusColor}
      getStatusLabel={getStatusLabel}
    />
  );


  // Renderizar lista vacía
  const renderEmptyComponent = () => {
    if (isLoading) {
      return (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    return (
      <EmptyState
        icon="receipt"
        title="No hay órdenes"
        message={
          searchQuery
            ? 'No se encontraron órdenes con los criterios de búsqueda'
            : 'Este turno no tiene órdenes registradas'
        }
      />
    );
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onRequestClose={onClose}
        animationType="slide"
        presentationStyle="formSheet"
      >
        <View style={styles.container}>
          {showOrderHistory && selectedReceipt ? (
            <OrderHistoryView
              orderId={selectedReceipt.id}
              orderNumber={
                selectedReceipt.shiftOrderNumber || selectedReceipt.orderNumber
              }
              onBack={() => {
                setShowOrderHistory(false);
                setShowReceiptDetails(true);
              }}
            />
          ) : showReceiptDetails && selectedReceipt ? (
            <OrderDetailsView
              order={selectedReceipt}
              onBack={() => {
                setShowReceiptDetails(false);
                setSelectedReceipt(null);
              }}
              onShowHistory={() => {
                setShowReceiptDetails(false);
                setShowOrderHistory(true);
              }}
            />
          ) : (
            <>
              <Appbar.Header style={styles.header}>
                <Appbar.BackAction onPress={onClose} />
                <Appbar.Content title="Órdenes del Turno" />
                <Appbar.Action
                  icon="refresh"
                  onPress={handleRefresh}
                  disabled={isLoading || isRefreshing}
                />
              </Appbar.Header>

              {/* Búsqueda */}
              <View style={styles.searchContainer}>
                <Searchbar
                  placeholder="Buscar por nombre, teléfono o dirección..."
                  onChangeText={setSearchQuery}
                  value={searchQuery}
                  style={styles.searchbar}
                  elevation={0}
                />
              </View>

              {/* Lista de órdenes */}
              {error ? (
                <EmptyState
                  icon="alert-circle"
                  title="Error al cargar"
                  message={error.message || 'No se pudieron cargar las órdenes'}
                  actionLabel="Reintentar"
                  onAction={refetch}
                />
              ) : (
                <FlatList
                  data={filteredOrders}
                  renderItem={renderReceiptItem}
                  keyExtractor={(item) => item.id}
                  contentContainerStyle={styles.listContent}
                  refreshControl={
                    <RefreshControl
                      refreshing={isRefetching}
                      onRefresh={refetch}
                      colors={[theme.colors.primary]}
                    />
                  }
                  ListEmptyComponent={renderEmptyComponent}
                />
              )}
            </>
          )}
        </View>
      </Modal>
    </Portal>
  );
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    searchContainer: {
      paddingHorizontal: 16,
      paddingVertical: 12,
      backgroundColor: theme.colors.surface,
    },
    searchbar: {
      backgroundColor: theme.colors.background,
      elevation: 0,
    },
    listContent: {
      padding: theme.spacing.s,
      paddingBottom: theme.spacing.l * 2,
    },
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 12,
      flexShrink: 1,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: 120,
      gap: 8,
      flexShrink: 0,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 15,
      fontWeight: '700',
    },
    orderTime: {
      fontSize: 16,
      fontWeight: '600',
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 32,
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    createdByText: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
      textAlign: 'right',
    },
  });

================
File: app/src/modules/shiftAudit/hooks/useShifts.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService, type Shift } from '@/services/shifts';

export const useShifts = (params?: {
  startDate?: string;
  endDate?: string;
}) => {
  return useQuery<Shift[], Error>({
    queryKey: ['shifts', 'history', params],
    queryFn: () => shiftsService.getHistory(params),
    staleTime: 0,
    gcTime: 0,
    refetchOnWindowFocus: false,
    refetchOnMount: true,
  });
};

export const useCurrentShift = () => {
  return useQuery<Shift | null, Error>({
    queryKey: ['shifts', 'current'],
    queryFn: () => shiftsService.getCurrentShift(),
    staleTime: 30000,
    refetchInterval: 60000,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
  });
};

export const useShiftDetail = (shiftId: string | undefined) => {
  return useQuery<Shift, Error>({
    queryKey: ['shifts', shiftId],
    queryFn: () => shiftsService.getById(shiftId!),
    enabled: !!shiftId,
    staleTime: 300000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });
};

================
File: app/src/modules/sync/services/syncService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { SyncStatus, SyncActivity } from '../types/sync.types';

class SyncService {
  /**
   * Obtiene el estado actual del servicio de sincronización
   */
  async getSyncStatus(): Promise<SyncStatus> {
    const response = await apiClient.get<SyncStatus>(API_PATHS.SYNC_STATUS);
    if (!response.data) {
      throw new Error('No se pudo obtener el estado de sincronización');
    }
    return response.data;
  }

  /**
   * Obtiene el historial de actividad reciente de sincronización
   * @param limit Número máximo de registros (por defecto 20)
   */
  async getSyncActivity(limit: number = 20): Promise<SyncActivity[]> {
    const response = await apiClient.get<SyncActivity[]>(
      API_PATHS.SYNC_ACTIVITY,
      { params: { limit } },
    );
    if (!response.data) {
      throw new Error('No se pudo obtener la actividad de sincronización');
    }
    return response.data;
  }

  /**
   * Verifica si el servicio de sincronización está disponible
   */
  async checkSyncAvailability(): Promise<boolean> {
    try {
      const status = await this.getSyncStatus();
      return status.enabled;
    } catch (error) {
      console.error(
        'Error verificando disponibilidad de sincronización:',
        error,
      );
      return false;
    }
  }
}

export const syncService = new SyncService();

================
File: app/src/modules/users/components/UserDetailModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  Surface,
  IconButton,
  Chip,
  Button,
  Dialog,
  TextInput,
  Icon,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useResetPassword, useDeleteUser } from '../hooks';
import type { User } from '../types';

interface UserDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  user: User;
  onEdit: (user: User) => void;
}

export function UserDetailModal({
  visible,
  onDismiss,
  user,
  onEdit,
}: UserDetailModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);

  const [showPasswordDialog, setShowPasswordDialog] = useState(false);
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);

  const resetPasswordMutation = useResetPassword();
  const deleteUserMutation = useDeleteUser();

  const handleResetPassword = async () => {
    if (newPassword !== confirmPassword) {
      return;
    }
    if (newPassword.length < 6) {
      return;
    }

    try {
      await resetPasswordMutation.mutateAsync({
        id: user.id,
        password: newPassword,
      });
      setShowPasswordDialog(false);
      setNewPassword('');
      setConfirmPassword('');
    } catch (error) {
      // Error handled in mutation
    }
  };

  const handleDeleteUser = async () => {
    try {
      await deleteUserMutation.mutateAsync(user.id);
      onDismiss();
    } catch (error) {
      // Error handled in mutation
    }
  };

  const getGenderLabel = (gender?: string | null) => {
    switch (gender) {
      case 'male':
        return 'Masculino';
      case 'female':
        return 'Femenino';
      case 'other':
        return 'Otro';
      default:
        return 'No especificado';
    }
  };

  const getRoleInfo = (roleId?: number) => {
    switch (roleId) {
      case 1:
        return {
          label: 'Administrador',
          icon: 'shield-account',
          color: theme.colors.error,
        };
      case 2:
        return {
          label: 'Gerente',
          icon: 'account-tie',
          color: theme.colors.primary,
        };
      case 3:
        return {
          label: 'Cajero',
          icon: 'cash-register',
          color: theme.colors.tertiary,
        };
      case 4:
        return {
          label: 'Mesero',
          icon: 'room-service',
          color: theme.colors.secondary,
        };
      case 5:
        return { label: 'Cocina', icon: 'chef-hat', color: '#FF6B6B' };
      case 6:
        return { label: 'Repartidor', icon: 'moped', color: '#4ECDC4' };
      default:
        return {
          label: 'Sin rol',
          icon: 'account',
          color: theme.colors.onSurfaceVariant,
        };
    }
  };

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={3}>
            {/* Header */}
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.elevation.level2 },
              ]}
            >
              <View style={styles.headerContent}>
                <View style={styles.headerNameRow}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onSurface },
                    ]}
                    variant="titleMedium"
                  >
                    {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                      user.username}
                  </Text>
                  <Chip
                    mode="flat"
                    icon={getRoleInfo(user.role?.id).icon}
                    style={[
                      styles.headerRoleChip,
                      { backgroundColor: theme.colors.surface },
                    ]}
                    textStyle={[
                      styles.headerRoleChipText,
                      { color: getRoleInfo(user.role?.id).color },
                    ]}
                    compact
                  >
                    {getRoleInfo(user.role?.id).label}
                  </Chip>
                </View>
                <Text
                  style={[
                    styles.modalSubtitle,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                  variant="bodySmall"
                >
                  {user.username}
                </Text>
              </View>
              <IconButton
                icon="close"
                size={20}
                onPress={onDismiss}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>

            <ScrollView
              style={styles.contentContainer}
              showsVerticalScrollIndicator={false}
            >
              {/* Contact Information */}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="contacts"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información de Contacto
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="email" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Email
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.email || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="phone" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Teléfono
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.phoneNumber || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>

              {/* Personal Information */}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="account-details"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información Personal
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="account"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Nombre completo
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {`${user.firstName || 'No especificado'} ${user.lastName || 'No especificado'}`}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="gender-transgender"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Género
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {getGenderLabel(user.gender)}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="cake-variant"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Fecha de nacimiento
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.birthDate
                        ? new Date(user.birthDate).toLocaleDateString('es-MX', {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                          })
                        : 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source={
                      user.isActive
                        ? 'check-circle-outline'
                        : 'close-circle-outline'
                    }
                    size={18}
                    color={
                      user.isActive ? theme.colors.primary : theme.colors.error
                    }
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Estado de la cuenta
                    </Text>
                    <Text
                      style={[
                        styles.compactValue,
                        {
                          color: user.isActive
                            ? theme.colors.primary
                            : theme.colors.error,
                        },
                      ]}
                      variant="bodySmall"
                    >
                      {user.isActive ? 'Activa' : 'Inactiva'}
                    </Text>
                  </View>
                </View>

                {/* Preparation Screen for Kitchen Role */}
                {user.role?.id === 5 && (
                  <View style={styles.compactRow}>
                    <Icon
                      source="monitor"
                      size={18}
                      color={theme.colors.primary}
                    />
                    <View style={styles.compactContent}>
                      <Text style={styles.compactLabel} variant="labelSmall">
                        Pantalla de Preparación
                      </Text>
                      <Text style={styles.compactValue} variant="bodySmall">
                        {user.preparationScreen?.name || 'No asignada'}
                      </Text>
                    </View>
                  </View>
                )}
              </View>

              {/* Address Information */}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="map-marker"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Dirección
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="home" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Dirección
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.address || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="city" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Ciudad
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.city || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="map" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Estado/Provincia
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.state || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="earth" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      País
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.country || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="mailbox"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Código Postal
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.zipCode || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>

              {/* Emergency Contact */}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="alert-circle"
                    size={20}
                    color={theme.colors.error}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Contacto de Emergencia
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="account-alert"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Nombre
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.name || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="phone-alert"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Teléfono
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.phone || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="account-multiple"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Relación
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.relationship || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>

              {/* Actions */}
              <View style={styles.actionsContainer}>
                <Button
                  mode="contained-tonal"
                  onPress={() => onEdit(user)}
                  icon="pencil"
                  style={styles.actionButton}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  compact
                >
                  Editar Usuario
                </Button>

                <Button
                  mode="contained-tonal"
                  onPress={() => setShowPasswordDialog(true)}
                  icon="lock-reset"
                  style={styles.actionButton}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  buttonColor={theme.colors.secondaryContainer}
                  compact
                >
                  Cambiar Contraseña
                </Button>

                <Button
                  mode="outlined"
                  onPress={() => setShowDeleteDialog(true)}
                  icon="delete"
                  style={[styles.actionButton, styles.deleteButton]}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  textColor={theme.colors.error}
                  compact
                >
                  Eliminar Usuario
                </Button>
              </View>
            </ScrollView>
          </Surface>
        </Modal>
      </Portal>

      {/* Password Reset Dialog */}
      <Portal>
        <Dialog
          visible={showPasswordDialog}
          onDismiss={() => {
            setShowPasswordDialog(false);
            setNewPassword('');
            setConfirmPassword('');
            setShowPassword(false);
          }}
          style={styles.passwordDialog}
        >
          <View
            style={[
              styles.passwordDialogContainer,
              { borderColor: theme.colors.primary },
            ]}
          >
            <View style={styles.passwordDialogHeader}>
              <Icon
                source="lock-reset"
                size={40}
                color={theme.colors.primary}
              />
              <Dialog.Title style={styles.passwordDialogTitle}>
                Cambiar Contraseña
              </Dialog.Title>
              <View style={styles.passwordDialogUserInfo}>
                <Text
                  variant="bodyMedium"
                  style={styles.passwordDialogUserName}
                >
                  {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username}
                </Text>
                <Text
                  variant="bodySmall"
                  style={styles.passwordDialogUserDetail}
                >
                  {user.email}
                </Text>
                <Text
                  variant="labelSmall"
                  style={styles.passwordDialogUserDetail}
                >
                  @{user.username}
                </Text>
              </View>
            </View>

            <Dialog.Content style={styles.passwordDialogContent}>
              <TextInput
                label="Nueva contraseña"
                value={newPassword}
                onChangeText={setNewPassword}
                mode="flat"
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                autoCorrect={false}
                autoComplete="new-password"
                style={styles.passwordInput}
                contentStyle={styles.passwordInputContent}
                underlineColor={theme.colors.surfaceVariant}
                activeUnderlineColor={theme.colors.primary}
                right={
                  <TextInput.Icon
                    icon={showPassword ? 'eye-off' : 'eye'}
                    onPress={() => setShowPassword(!showPassword)}
                    size={20}
                    style={styles.passwordInputIcon}
                  />
                }
              />

              <TextInput
                label="Confirmar contraseña"
                value={confirmPassword}
                onChangeText={setConfirmPassword}
                mode="flat"
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                autoCorrect={false}
                autoComplete="new-password"
                style={styles.passwordInput}
                contentStyle={styles.passwordInputContent}
                underlineColor={theme.colors.surfaceVariant}
                activeUnderlineColor={theme.colors.primary}
              />

              {(newPassword.length > 0 || confirmPassword.length > 0) && (
                <View style={styles.passwordValidation}>
                  <View style={styles.validationItem}>
                    <Icon
                      source={
                        newPassword.length >= 6
                          ? 'check-circle'
                          : 'circle-outline'
                      }
                      size={16}
                      color={
                        newPassword.length >= 6
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.validationText,
                        {
                          color:
                            newPassword.length >= 6
                              ? theme.colors.primary
                              : theme.colors.onSurfaceVariant,
                        },
                      ]}
                    >
                      Mínimo 6 caracteres
                    </Text>
                  </View>

                  <View style={styles.validationItem}>
                    <Icon
                      source={
                        newPassword === confirmPassword &&
                        newPassword.length > 0
                          ? 'check-circle'
                          : 'circle-outline'
                      }
                      size={16}
                      color={
                        newPassword === confirmPassword &&
                        newPassword.length > 0
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.validationText,
                        {
                          color:
                            newPassword === confirmPassword &&
                            newPassword.length > 0
                              ? theme.colors.primary
                              : theme.colors.onSurfaceVariant,
                        },
                      ]}
                    >
                      Las contraseñas coinciden
                    </Text>
                  </View>
                </View>
              )}
            </Dialog.Content>

            <Dialog.Actions style={styles.passwordDialogActions}>
              <Button
                mode="text"
                onPress={() => {
                  setShowPasswordDialog(false);
                  setNewPassword('');
                  setConfirmPassword('');
                  setShowPassword(false);
                }}
                style={[
                  styles.passwordDialogButton,
                  styles.passwordDialogCancelButton,
                ]}
                labelStyle={styles.passwordDialogButtonLabel}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleResetPassword}
                loading={resetPasswordMutation.isPending}
                disabled={
                  resetPasswordMutation.isPending ||
                  newPassword.length < 6 ||
                  newPassword !== confirmPassword
                }
                style={[
                  styles.passwordDialogButton,
                  styles.passwordDialogPrimaryButton,
                ]}
                labelStyle={styles.passwordDialogButtonLabel}
              >
                Cambiar
              </Button>
            </Dialog.Actions>
          </View>
        </Dialog>
      </Portal>

      {/* Delete Confirmation Dialog */}
      <Portal>
        <Dialog
          visible={showDeleteDialog}
          onDismiss={() => setShowDeleteDialog(false)}
        >
          <Dialog.Icon icon="alert" color={theme.colors.error} />
          <Dialog.Title style={{ textAlign: 'center' }}>
            Eliminar Usuario
          </Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium" style={{ textAlign: 'center' }}>
              ¿Estás seguro de que deseas eliminar al usuario{' '}
              <Text style={{ fontWeight: 'bold' }}>{user.username}</Text>?
            </Text>
            <Text
              variant="bodySmall"
              style={{
                textAlign: 'center',
                marginTop: theme.spacing.s,
                color: theme.colors.error,
              }}
            >
              Esta acción no se puede deshacer
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowDeleteDialog(false)}>Cancelar</Button>
            <Button
              onPress={handleDeleteUser}
              loading={deleteUserMutation.isPending}
              disabled={deleteUserMutation.isPending}
              textColor={theme.colors.error}
            >
              Eliminar
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    passwordDialog: {
      backgroundColor: 'transparent',
    },
    passwordDialogContainer: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 4,
      borderWidth: 2,
      overflow: 'hidden',
    },
    passwordDialogHeader: {
      alignItems: 'center',
      paddingTop: theme.spacing.l,
      paddingBottom: theme.spacing.s,
      backgroundColor: theme.colors.elevation.level1,
    },
    passwordDialogTitle: {
      textAlign: 'center',
      fontSize: 20,
      fontWeight: '600',
      marginTop: theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    passwordDialogUserInfo: {
      alignItems: 'center',
      paddingHorizontal: theme.spacing.l,
      marginBottom: theme.spacing.xs,
    },
    passwordDialogUserName: {
      textAlign: 'center',
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.xs,
    },
    passwordDialogUserDetail: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    passwordDialogContent: {
      paddingTop: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    passwordInput: {
      backgroundColor: 'transparent',
      marginBottom: theme.spacing.m,
    },
    passwordInputContent: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 2,
      paddingHorizontal: theme.spacing.m,
      paddingRight: theme.spacing.m,
    },
    passwordInputIcon: {
      marginRight: -theme.spacing.xs,
    },
    passwordValidation: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.m,
      gap: theme.spacing.s,
    },
    validationItem: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    validationText: {
      fontSize: 12,
    },
    passwordDialogActions: {
      justifyContent: 'center',
      paddingBottom: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      gap: theme.spacing.s,
    },
    passwordDialogButton: {
      minWidth: 100,
      borderRadius: theme.roundness * 3,
    },
    passwordDialogCancelButton: {
      marginRight: theme.spacing.s,
    },
    passwordDialogPrimaryButton: {
      elevation: 0,
    },
    passwordDialogButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
      letterSpacing: 0.1,
    },
    modalContainer: {
      margin: responsive.isTablet ? theme.spacing.xl : theme.spacing.m,
      maxWidth: responsive.isTablet ? 700 : 420,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '92%',
      paddingHorizontal: 0,
      height: responsive.isTablet ? '80%' : '80%',
      maxHeight: responsive.isTablet ? '85%' : '92%',
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      height: '100%',
      flex: 1,
      overflow: 'hidden',
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingVertical: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'column',
      justifyContent: 'center',
    },
    headerNameRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    modalTitle: {
      fontWeight: '600',
      marginRight: theme.spacing.xs,
      fontSize: responsive.isTablet ? 15 : 16,
    },
    modalSubtitle: {
      marginTop: 2,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    headerRoleChip: {
      minHeight: responsive.isTablet ? 32 : 28,
      height: 'auto',
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      paddingHorizontal: theme.spacing.s,
      paddingVertical: 3,
      alignItems: 'center',
      justifyContent: 'center',
    },
    headerRoleChipText: {
      fontSize: 12,
      fontWeight: '600',
      lineHeight: 16,
      marginVertical: 0,
      paddingVertical: 0,
      includeFontPadding: false,
    },
    contentContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.m,
    },
    infoSection: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      marginBottom: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      backgroundColor: theme.colors.elevation.level1,
      borderWidth: 0,
      elevation: 0,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : theme.spacing.xs,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 14,
    },
    listItemTitle: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontSize: 14,
    },
    listItemDescription: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    actionsContainer: {
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      marginBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.m,
      marginTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingHorizontal: 0,
    },
    actionButton: {
      borderRadius: theme.roundness * 2,
      elevation: 0,
      height: responsive.isTablet ? 36 : 40,
    },
    buttonContent: {
      height: responsive.isTablet ? 36 : 40,
      paddingTop: 0,
      paddingBottom: 0,
    },
    buttonLabel: {
      fontSize: responsive.isTablet ? 13 : 14,
      lineHeight: responsive.isTablet ? 18 : 20,
      marginVertical: responsive.isTablet ? 6 : 8,
      includeFontPadding: false,
    },
    deleteButton: {
      borderColor: theme.colors.error,
      marginTop: theme.spacing.xs,
    },
    compactRow: {
      flexDirection: 'row',
      alignItems: 'flex-start',
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.s,
      paddingVertical: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    compactContent: {
      flex: 1,
    },
    compactLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 11,
      lineHeight: responsive.isTablet ? 14 : 14,
    },
    compactValue: {
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 13,
      fontWeight: '500',
      lineHeight: responsive.isTablet ? 16 : 16,
    },
  });

================
File: app/src/services/appConfig.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

export interface AppConfig {
  maps: {
    apiKey: string;
  };
}

class AppConfigService {
  private config: AppConfig | null = null;

  async getConfig(): Promise<AppConfig> {
    if (this.config) {
      return this.config;
    }

    try {
      const response = await apiClient.get<AppConfig>(API_PATHS.APP_CONFIG);
      this.config = response.data;
      return this.config;
    } catch (error) {
      const defaultConfig: AppConfig = {
        maps: {
          apiKey: '',
        },
      };
      this.config = defaultConfig;
      return defaultConfig;
    }
  }

  async getMapsApiKey(): Promise<string> {
    const config = await this.getConfig();
    return config.maps.apiKey;
  }

  // Limpiar caché si es necesario
  clearCache() {
    this.config = null;
  }
}

export const appConfigService = new AppConfigService();

================
File: app/android/app/src/main/res/xml/network_security_config.xml
================
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <!-- Configuración base para producción - Solo HTTPS por defecto -->
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>
    
    <!-- Permitir tráfico cleartext SOLO para redes locales (auto-descubrimiento) -->
    <!-- Esto es necesario para el sistema de discovery del servidor -->
    <domain-config cleartextTrafficPermitted="true">
        <!-- Redes privadas IPv4 (RFC 1918) -->
        <domain>10.0.0.0/8</domain>
        <domain>172.16.0.0/12</domain>
        <domain>192.168.0.0/16</domain>
        
        <!-- Localhost y loopback -->
        <domain>localhost</domain>
        <domain>127.0.0.1</domain>
        <domain>10.0.2.2</domain> <!-- Emulador Android -->
        
        <!-- Patrón para IPs locales comunes -->
        <domain includeSubdomains="false">192.168.1.*</domain>
        <domain includeSubdomains="false">192.168.0.*</domain>
        <domain includeSubdomains="false">10.0.0.*</domain>
        <domain includeSubdomains="false">172.16.*.*</domain>
    </domain-config>
    
    <!-- Configuración específica para tu dominio de producción -->
    <!-- TODO: Reemplaza "tu-dominio.com" con tu dominio real de producción -->
    <domain-config>
        <domain includeSubdomains="true">tu-dominio.com</domain>
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
        
        <!-- Certificate Pinning (opcional pero recomendado para producción) -->
        <!-- TODO: Descomentar y actualizar con los hashes SHA-256 de tu certificado
        <pin-set expiration="2026-01-01">
            <pin digest="SHA-256">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</pin>
            <pin digest="SHA-256">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=</pin>
        </pin-set>
        -->
    </domain-config>
    
    <!-- Solo para desarrollo - Se ignora en builds de producción -->
    <debug-overrides>
        <trust-anchors>
            <!-- Permite certificados del sistema -->
            <certificates src="system" />
            <!-- Permite certificados instalados por el usuario (ej: Charles Proxy) -->
            <certificates src="user" />
        </trust-anchors>
    </debug-overrides>
</network-security-config>

================
File: app/src/app/components/crud/GenericList.tsx
================
import React, { useCallback, useMemo, useState } from 'react';
import { useIsFocused } from '@react-navigation/native';
import {
  StyleSheet,
  RefreshControl,
  ViewStyle,
  StyleProp,
  View,
  TextStyle,
} from 'react-native';
import { FlashList } from '@shopify/flash-list';
import {
  List,
  Chip,
  Text,
  Surface,
  Searchbar,
  FAB,
  Portal,
  Menu,
  IconButton,
  Badge,
} from 'react-native-paper';
import AutoImage from '../common/AutoImage';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
export interface FilterOption<TValue> {
  value: TValue;
  label: string;
  icon?: string;
  disabled?: boolean;
}

interface StatusConfig<TItem> {
  field: keyof TItem;
  activeValue: TItem[keyof TItem];
  activeLabel: string;
  inactiveLabel: string;
}

export interface RenderItemConfig<TItem> {
  titleField: keyof TItem;
  descriptionField?: keyof TItem;
  descriptionFormatter?: (value: any) => string | undefined;
  descriptionMaxLength?: number;
  priceField?: keyof TItem;
  sortOrderField?: keyof TItem;
  imageField?: keyof TItem;
  isDefaultField?: keyof TItem;
  statusConfig?: StatusConfig<TItem>;
  renderTitle?: (item: TItem) => React.ReactNode;
  renderDescription?: (item: TItem) => React.ReactNode;
}

interface GenericListProps<TItem extends { id: string }> {
  items: TItem[];
  renderConfig: RenderItemConfig<TItem>;
  onItemPress: (item: TItem) => void;
  onRefresh: () => void;
  isRefreshing: boolean;
  ListEmptyComponent: React.ComponentType<any> | React.ReactElement | null;
  isLoading?: boolean;
  listItemStyle?: StyleProp<ViewStyle>;
  listItemContentStyle?: StyleProp<ViewStyle>;
  contentContainerStyle?: StyleProp<ViewStyle>;
  imageStyle?: StyleProp<ViewStyle>;
  itemActionsContainerStyle?: StyleProp<ViewStyle>;
  renderItemActions?: (item: TItem) => React.ReactNode;
  renderItem?: ({ item }: { item: TItem }) => React.ReactElement;
  enableSearch?: boolean;
  searchPlaceholder?: string;
  searchQuery?: string;
  onSearchChange?: (query: string) => void;
  enableSort?: boolean;
  filterValue?: string | number;
  onFilterChange?: (value: string | number) => void;
  filterOptions?: FilterOption<string | number>[];
  showFab?: boolean;
  onFabPress?: () => void;
  fabIcon?: string;
  fabLabel?: string;
  fabVisible?: boolean;
  showImagePlaceholder?: boolean;
  placeholderIcon?: string;
  isModalOpen?: boolean;
  isDrawerOpen?: boolean;
  enableGrid?: boolean;
  gridColumns?: number;
  gridColumnsTablet?: number;
  minItemWidth?: number;
  itemSpacing?: number;
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) => {
  const listItemHorizontalMargin = responsive.spacing(theme.spacing.m);
  return StyleSheet.create({
    listContainer: {
      flex: 1,
    },
    searchbarContainer: {
      paddingHorizontal:
        listItemHorizontalMargin - responsive.spacing(theme.spacing.xs),
      paddingTop: responsive.spacing(theme.spacing.xs),
      paddingBottom: responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.background,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    searchbarWithFilter: {
      flex: 1,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: responsive.spacing(theme.spacing.xs),
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      marginVertical: responsive.isTablet
        ? responsive.spacing(3)
        : responsive.spacing(4),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness * 1.5,
      elevation: 1,
      overflow: 'hidden',
    },
    gridListItem: {
      backgroundColor: theme.colors.surface,
      flex: 1,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
      elevation: 2,
      overflow: 'hidden',
    },
    listItemContent: {
      paddingVertical: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      minHeight: responsive.isTablet ? 40 : 56,
      flexWrap: 'wrap',
      alignItems: 'flex-start',
    },
    listItemImage: {
      width: responsive.isTablet ? 36 : 40,
      height: responsive.isTablet ? 36 : 40,
      borderRadius: theme.roundness,
      marginLeft: responsive.spacing(theme.spacing.xs),
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.surfaceDisabled,
    },
    gridItemImage: {
      width: responsive.scaleWidth(64),
      height: responsive.scaleWidth(64),
      borderRadius: theme.roundness,
      marginLeft: responsive.spacing(theme.spacing.s),
      marginRight: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceDisabled,
    },
    statusChip: {
      borderRadius: theme.roundness * 1.5,
      height: responsive.isTablet ? 32 : 28,
      alignSelf: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    title: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 15 : 14,
      lineHeight: responsive.isTablet ? 20 : 18,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 13 : 12,
      lineHeight: responsive.isTablet ? 18 : 16,
    },
    emptyListContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
    defaultContentContainer: {
      paddingBottom: 80,
      paddingTop: responsive.spacing(theme.spacing.xs),
    },
    itemActionsContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      paddingLeft: responsive.spacing(theme.spacing.xs),
    },
    filtersOuterContainer: {
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      backgroundColor: theme.colors.background,
    },
    segmentedButtons: {
      backgroundColor: 'transparent',
      borderRadius: theme.roundness,
      minHeight: 40,
    },
    filterButton: {
      borderWidth: 0,
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    filterButtonLabel: {
      fontSize: 15,
      letterSpacing: 0.15,
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    fab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 0,
    },
  });
};

const GenericList = <TItem extends { id: string }>({
  items,
  renderConfig,
  onItemPress,
  onRefresh,
  isRefreshing,
  ListEmptyComponent,
  listItemStyle,
  listItemContentStyle,
  contentContainerStyle,
  imageStyle,
  renderItemActions,
  itemActionsContainerStyle,
  enableSearch = false,
  searchPlaceholder = 'Buscar...',
  enableSort = false,
  filterValue,
  onFilterChange,
  filterOptions,
  searchQuery: externalSearchQuery,
  onSearchChange,
  showFab = false,
  onFabPress,
  fabIcon = 'plus',
  fabLabel,
  fabVisible = true,
  showImagePlaceholder = true,
  placeholderIcon = 'image-outline',
  isModalOpen = false,
  isDrawerOpen = false,
  renderItem,
  enableGrid = false,
  gridColumns = 1,
  gridColumnsTablet,
  minItemWidth,
  itemSpacing,
}: GenericListProps<TItem>) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const [internalSearchTerm, setInternalSearchTerm] = useState('');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const isSearchControlled =
    externalSearchQuery !== undefined && onSearchChange !== undefined;
  const currentSearchTerm = isSearchControlled
    ? externalSearchQuery
    : internalSearchTerm;
  const isFocused = useIsFocused();

  const processedItems = useMemo(() => {
    let processed = [...items];

    if (enableSort && renderConfig.titleField) {
      processed.sort((a, b) => {
        const titleA = String(a[renderConfig.titleField] ?? '').toLowerCase();
        const titleB = String(b[renderConfig.titleField] ?? '').toLowerCase();
        return titleA.localeCompare(titleB);
      });
    }

    if (enableSearch && !isSearchControlled && currentSearchTerm.trim()) {
      const lowerCaseSearchTerm = currentSearchTerm.toLowerCase();
      processed = processed.filter((item) => {
        const title = String(item[renderConfig.titleField] ?? '').toLowerCase();
        if (title.includes(lowerCaseSearchTerm)) {
          return true;
        }
        if (renderConfig.descriptionField) {
          const description = String(
            item[renderConfig.descriptionField] ?? '',
          ).toLowerCase();
          if (description.includes(lowerCaseSearchTerm)) {
            return true;
          }
        }
        return false;
      });
    }

    return processed;
  }, [
    items,
    enableSort,
    enableSearch,
    isSearchControlled,
    currentSearchTerm,
    renderConfig,
  ]);

  const numColumns = useMemo(() => {
    if (!enableGrid) return 1;

    if (minItemWidth) {
      const gap = itemSpacing || responsive.spacing(theme.spacing.m);
      const padding = responsive.spacing(theme.spacing.m);
      return responsive.getGridColumns(minItemWidth, gap, padding);
    }

    if (responsive.isTablet && gridColumnsTablet) {
      return gridColumnsTablet;
    }

    return gridColumns;
  }, [
    enableGrid,
    minItemWidth,
    itemSpacing,
    responsive,
    gridColumns,
    gridColumnsTablet,
  ]);

  const renderGenericItem = useCallback(
    ({ item }: { item: TItem }) => {
      const title = String(item[renderConfig.titleField] ?? '');

      let description = '';
      if (
        renderConfig.descriptionField &&
        item.hasOwnProperty(renderConfig.descriptionField)
      ) {
        const fieldValue = item[renderConfig.descriptionField];
        if (renderConfig.descriptionFormatter) {
          const formattedDescription =
            renderConfig.descriptionFormatter(fieldValue);
          if (formattedDescription) {
            description = formattedDescription;
          }
        } else {
          const rawDescription = String(fieldValue || '');
          if (rawDescription && rawDescription.toLowerCase() !== 'null') {
            description = rawDescription;
          }
        }
      }

      let sortOrderString: string | null = null;
      if (
        renderConfig.sortOrderField &&
        item.hasOwnProperty(renderConfig.sortOrderField)
      ) {
        const sortOrderValue = item[renderConfig.sortOrderField];
        if (sortOrderValue !== null && sortOrderValue !== undefined) {
          sortOrderString = `Posicion: ${String(sortOrderValue)}`;
        }
      }

      let priceString: string | null = null;
      if (
        renderConfig.priceField &&
        item.hasOwnProperty(renderConfig.priceField)
      ) {
        const priceValue = item[renderConfig.priceField];
        if (priceValue !== null && priceValue !== undefined) {
          const numericPrice = Number(priceValue);
          if (!isNaN(numericPrice)) {
            priceString = `$${numericPrice.toFixed(2)}`;
          } else if (
            typeof priceValue === 'string' &&
            priceValue.trim() !== ''
          ) {
            priceString = String(priceValue);
          }
        }
      }

      let imageSource: string | undefined = undefined;
      if (
        renderConfig.imageField &&
        item.hasOwnProperty(renderConfig.imageField)
      ) {
        const imageFieldValue = item[renderConfig.imageField];
        if (
          typeof imageFieldValue === 'object' &&
          imageFieldValue !== null &&
          'path' in imageFieldValue &&
          typeof imageFieldValue.path === 'string'
        ) {
          imageSource = imageFieldValue.path;
        } else if (typeof imageFieldValue === 'string') {
          imageSource = imageFieldValue;
        }
      }

      let statusChip = null;
      if (
        renderConfig.statusConfig &&
        item.hasOwnProperty(renderConfig.statusConfig.field)
      ) {
        const { field, activeValue, activeLabel, inactiveLabel } =
          renderConfig.statusConfig;
        const isActive = item[field] === activeValue;
        const chipLabel = isActive ? activeLabel : inactiveLabel;

        statusChip = (props: {
          color: string;
          style?: StyleProp<TextStyle>;
        }) => (
          <Chip
            {...props}
            mode="flat"
            selectedColor={
              isActive ? theme.colors.success : theme.colors.onSurfaceVariant
            }
            style={[
              styles.statusChip,
              {
                backgroundColor: isActive
                  ? theme.colors.successContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
            textStyle={{
              fontSize: responsive.isTablet ? 12 : 11,
              marginVertical: 0,
            }}
            compact
          >
            {chipLabel}
          </Chip>
        );
      }

      const isGrid = enableGrid && numColumns > 1;

      return (
        <Surface
          style={[
            isGrid ? styles.gridListItem : styles.listItem,
            listItemStyle,
          ]}
          elevation={1}
        >
          <List.Item
            title={() =>
              renderConfig.renderTitle ? (
                renderConfig.renderTitle(item)
              ) : (
                <Text variant="bodyLarge" style={styles.title}>
                  {title}
                </Text>
              )
            }
            description={() => {
              if (renderConfig.renderDescription) {
                return renderConfig.renderDescription(item);
              }

              const parts = [];

              if (
                renderConfig.isDefaultField &&
                item.hasOwnProperty(renderConfig.isDefaultField) &&
                item[renderConfig.isDefaultField] === true
              ) {
                parts.push('✓ Por defecto');
              }

              if (sortOrderString) {
                parts.push(sortOrderString);
              }

              if (description) {
                parts.push(description);
              }

              if (priceString) {
                parts.push(priceString);
              }

              const combinedText = parts.join(' - ');

              if (combinedText.trim()) {
                return (
                  <Text variant="bodySmall" style={styles.description}>
                    {combinedText}
                  </Text>
                );
              }
              return null;
            }}
            left={() => {
              if (imageSource || showImagePlaceholder) {
                return (
                  <AutoImage
                    source={imageSource}
                    placeholderIcon={placeholderIcon}
                    style={[
                      isGrid ? styles.gridItemImage : styles.listItemImage,
                      imageStyle,
                    ]}
                    contentFit="cover"
                    transition={300}
                  />
                );
              } else {
                return null;
              }
            }}
            right={() => (
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {statusChip && statusChip({ color: theme.colors.onSurface })}
                {renderItemActions && (
                  <View
                    style={[
                      styles.itemActionsContainer,
                      itemActionsContainerStyle,
                    ]}
                  >
                    {renderItemActions(item)}
                  </View>
                )}
              </View>
            )}
            onPress={() => onItemPress(item)}
            style={[styles.listItemContent, listItemContentStyle]}
          />
        </Surface>
      );
    },
    [
      theme,
      renderConfig,
      onItemPress,
      styles,
      listItemStyle,
      listItemContentStyle,
      imageStyle,
      renderItemActions,
      itemActionsContainerStyle,
      enableGrid,
      numColumns,
      showImagePlaceholder,
      placeholderIcon,
      responsive,
    ],
  );

  const finalContentContainerStyle = useMemo(() => {
    return StyleSheet.flatten([
      styles.defaultContentContainer,
      contentContainerStyle,
    ]);
  }, [styles.defaultContentContainer, contentContainerStyle]);

  const hasActiveFilter = filterValue !== 'all' && filterValue !== undefined;

  return (
    <View style={styles.listContainer}>
      {(enableSearch ||
        (filterOptions && filterValue !== undefined && onFilterChange)) && (
        <View style={styles.searchbarContainer}>
          <View style={styles.searchRow}>
            {enableSearch && (
              <Searchbar
                placeholder={searchPlaceholder}
                onChangeText={
                  isSearchControlled ? onSearchChange : setInternalSearchTerm
                }
                value={currentSearchTerm}
                style={[
                  styles.searchbar,
                  filterOptions ? styles.searchbarWithFilter : {},
                ]}
                inputStyle={{
                  color: theme.colors.onSurface,
                  fontSize: 14,
                  minHeight: 40,
                }}
                placeholderTextColor={theme.colors.onSurfaceVariant}
                iconColor={theme.colors.onSurfaceVariant}
                clearIcon={
                  currentSearchTerm
                    ? () => <List.Icon icon="close-circle" />
                    : undefined
                }
                onClearIconPress={() =>
                  isSearchControlled
                    ? onSearchChange('')
                    : setInternalSearchTerm('')
                }
              />
            )}
            {filterOptions && filterValue !== undefined && onFilterChange && (
              <View style={styles.filterButtonContainer}>
                <Menu
                  visible={filterMenuVisible}
                  onDismiss={() => setFilterMenuVisible(false)}
                  anchor={
                    <IconButton
                      icon={hasActiveFilter ? 'filter-check' : 'filter-variant'}
                      mode="contained-tonal"
                      size={24}
                      onPress={() => setFilterMenuVisible(true)}
                      style={styles.filterIconButton}
                      iconColor={
                        hasActiveFilter
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                  }
                  anchorPosition="bottom"
                  contentStyle={styles.menuContent}
                >
                  {filterOptions.map((option) => (
                    <Menu.Item
                      key={String(option.value)}
                      onPress={() => {
                        onFilterChange(option.value);
                        setFilterMenuVisible(false);
                      }}
                      title={option.label}
                      leadingIcon={option.icon}
                      trailingIcon={
                        filterValue === option.value ? 'check' : undefined
                      }
                      disabled={option.disabled}
                      titleStyle={
                        filterValue === option.value
                          ? { color: theme.colors.primary, fontWeight: '600' }
                          : undefined
                      }
                    />
                  ))}
                </Menu>
                {hasActiveFilter && (
                  <Badge style={styles.filterBadge} size={8} />
                )}
              </View>
            )}
          </View>
        </View>
      )}

      <FlashList
        data={processedItems}
        renderItem={renderItem || renderGenericItem}
        keyExtractor={(item) => item.id}
        estimatedItemSize={enableGrid && numColumns > 1 ? 150 : 80}
        numColumns={numColumns}
        contentContainerStyle={finalContentContainerStyle}
        ListEmptyComponent={
          processedItems.length === 0 ? ListEmptyComponent || null : null
        }
        ItemSeparatorComponent={
          enableGrid && numColumns > 1
            ? () => (
                <View
                  style={{
                    height: itemSpacing || responsive.spacing(theme.spacing.m),
                  }}
                />
              )
            : undefined
        }
        refreshControl={
          <RefreshControl
            refreshing={isRefreshing}
            onRefresh={() => {
              if (isSearchControlled) {
                onSearchChange('');
              } else {
                setInternalSearchTerm('');
              }
              onRefresh();
            }}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        keyboardShouldPersistTaps="handled"
      />
      {showFab && onFabPress && (
        <Portal>
          <FAB
            icon={fabIcon}
            style={styles.fab}
            onPress={onFabPress}
            visible={
              isFocused &&
              showFab &&
              fabVisible &&
              !isModalOpen &&
              !isDrawerOpen
            }
            label={fabLabel}
            color={theme.colors.onPrimary}
            theme={{ colors: { primaryContainer: theme.colors.primary } }}
          />
        </Portal>
      )}
    </View>
  );
};

export default GenericList;

================
File: app/src/app/navigation/AppNavigator.tsx
================
import React, { useEffect } from 'react';
import {
  NavigationContainer,
  Theme as NavigationTheme,
} from '@react-navigation/native';
import { useAuthStore } from '../store/authStore';
import { AuthStack } from './AuthStack';
import { ConditionalAppNavigator } from './ConditionalAppNavigator';
import { useAppTheme } from '../styles/theme';
import { initImageCache } from '../lib/imageCache';
import { reconnectionSnackbarService } from '@/services/reconnectionSnackbarService';
import { serverConnectionService } from '@/services/serverConnectionService';

export function AppNavigator() {
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const paperTheme = useAppTheme();

  // Inicializar servicios una sola vez al montar la app
  useEffect(() => {
    initImageCache();

    // El servicio se inicializa automáticamente en su constructor
    // No necesita llamada explícita a initialize()

    return () => {
      // Limpiar cuando se desmonte toda la app
      serverConnectionService.destroy();
    };
  }, []); // Sin dependencias para que solo se ejecute una vez

  // Manejar servicios de notificación basados en autenticación
  useEffect(() => {
    if (isAuthenticated) {
      reconnectionSnackbarService.start();
    } else {
      reconnectionSnackbarService.stop();
    }

    return () => {
      reconnectionSnackbarService.stop();
    };
  }, [isAuthenticated]);

  const navigationTheme: NavigationTheme = {
    dark: paperTheme.dark,
    colors: {
      primary: paperTheme.colors.primary,
      background: paperTheme.colors.background,
      card: paperTheme.colors.surface,
      text: paperTheme.colors.onBackground,
      border: paperTheme.colors.outline,
      notification: paperTheme.colors.error,
    },
    fonts: {
      regular: {
        ...paperTheme.fonts.bodyMedium,
        fontWeight: paperTheme.fonts.bodyMedium.fontWeight ?? 'normal',
      },
      medium: {
        ...paperTheme.fonts.titleMedium,
        fontWeight: paperTheme.fonts.titleMedium.fontWeight ?? 'normal',
      },
      bold: {
        ...paperTheme.fonts.titleLarge,
        fontWeight: paperTheme.fonts.titleLarge.fontWeight ?? 'bold',
      },
      heavy: {
        ...paperTheme.fonts.titleLarge,
        fontWeight: paperTheme.fonts.titleLarge.fontWeight ?? '900',
      },
    },
  };

  return (
    <NavigationContainer theme={navigationTheme}>
      {isAuthenticated ? <ConditionalAppNavigator /> : <AuthStack />}
    </NavigationContainer>
  );
}

================
File: app/src/app/navigation/KitchenOnlyNavigator.tsx
================
import React, { useEffect } from 'react';
import {
  BackHandler,
  TouchableOpacity,
  StatusBar,
  StyleSheet,
  View,
  Text,
  Platform,
} from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import KitchenNavigator from '../../modules/kitchen/navigation/KitchenNavigator';
import { CustomDrawerContent } from './components/CustomDrawerContent';
import { ServerSettingsScreen } from '../../modules/settings/screens/ServerSettingsScreen';
import { useAppTheme } from '../styles/theme';
import { Icon, Surface, Checkbox } from 'react-native-paper';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { RefreshButton } from '../../modules/kitchen/components/RefreshButton';
import { useAuthStore } from '../store/authStore';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderType } from '../../modules/kitchen/types/kitchen.types';
import { KitchenProvider } from '../../modules/kitchen/context/KitchenContext';

const Drawer = createDrawerNavigator();

function KitchenOnlyNavigatorContent() {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const screenName = user?.preparationScreen?.name || 'Pantalla de Preparación';

  // Obtener el texto del filtro activo
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderType.DINE_IN:
        return ' • Mesa';
      case OrderType.TAKE_AWAY:
        return ' • Llevar';
      case OrderType.DELIVERY:
        return ' • Domicilio';
      default:
        return '';
    }
  };

  // Prevenir navegación hacia atrás en Android (no aplicar en web)
  useEffect(() => {
    if (Platform.OS !== 'web') {
      const backHandler = BackHandler.addEventListener(
        'hardwareBackPress',
        () => {
          // Retornar true previene el comportamiento por defecto
          return true;
        },
      );

      return () => backHandler.remove();
    }
  }, []);

  const responsive = useResponsive();

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        drawerButtonContainer: {
          width: 56,
          height: 56,
          justifyContent: 'center',
          alignItems: 'center',
          marginLeft: 0,
          borderRadius: 28,
        },
        headerStyle: {
          backgroundColor: theme.colors.primary,
          height: responsive.isWeb ? 80 : responsive.dimensions.headerHeight,
          elevation: 2,
        },
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
          color: theme.colors.onPrimary,
          fontWeight: 'bold',
          fontSize: responsive.isWeb ? 26 : responsive.isTablet ? 20 : 22,
        },
        drawerStyle: {
          backgroundColor: theme.colors.surface,
          width: responsive.isWeb ? 320 : responsive.dimensions.drawerWidth,
          borderTopRightRadius: responsive.isWeb ? 0 : theme.roundness * 2,
          borderBottomRightRadius: responsive.isWeb ? 0 : theme.roundness * 2,
          borderRightWidth: 0,
          borderRightColor: theme.colors.outlineVariant,
          elevation: 2,
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 0 },
          shadowOpacity: 0,
          shadowRadius: 0,
        },
        titleContainer: {
          flexDirection: 'row',
          alignItems: 'center',
        },
        filterIndicator: {
          ...theme.fonts.titleMedium,
          fontWeight: '500',
          opacity: 0.9,
        },
      }),
    [theme, responsive],
  );

  return (
    <>
      <StatusBar
        backgroundColor={theme.colors.primary}
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
      />
      <Drawer.Navigator
        initialRouteName="Kitchen"
        drawerContent={(props) => <CustomDrawerContent {...props} />}
        defaultStatus="closed"
        screenOptions={({ navigation }) => ({
          headerStyle: styles.headerStyle,
          headerTintColor: theme.colors.onPrimary,
          headerTitleStyle: styles.headerTitleStyle,
          drawerStyle: styles.drawerStyle,
          drawerActiveTintColor: theme.colors.primary,
          drawerInactiveTintColor: theme.colors.onSurfaceVariant,
          drawerLabelStyle: {
            ...theme.fonts.labelLarge,
            fontSize: responsive.fontSize.m,
          },
          drawerItemStyle: {
            marginVertical: responsive.spacing.xxs,
            borderRadius: theme.roundness * 2,
            paddingVertical: responsive.spacing.xxs,
            paddingHorizontal: responsive.spacing.xs,
          },
          headerShown: true,
          drawerType: 'slide',
          drawerPosition: 'left',
          headerShadowVisible: false,
          swipeEdgeWidth: 0,
          swipeEnabled: false,
          drawerHideStatusBarOnOpen: false,
          headerLeft: () => (
            <TouchableOpacity
              style={styles.drawerButtonContainer}
              onPress={() => navigation.openDrawer()}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Icon
                source="menu"
                size={responsive.isWeb ? 36 : 32}
                color={theme.colors.onPrimary}
              />
            </TouchableOpacity>
          ),
          headerTitle: () => (
            <Surface
              elevation={0}
              style={{
                backgroundColor: 'transparent',
              }}
            >
              <View style={styles.titleContainer}>
                <Text style={styles.headerTitleStyle}>{screenName}</Text>
                {filters.orderType && (
                  <Text
                    style={[
                      styles.filterIndicator,
                      { color: theme.colors.onPrimary },
                    ]}
                  >
                    {getFilterText()}
                  </Text>
                )}
              </View>
            </Surface>
          ),
          headerRight: () => (
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              {/* Checkbox para mostrar/ocultar ordenes listas */}
              <TouchableOpacity
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  paddingHorizontal: 12,
                  paddingVertical: 8,
                  marginRight: 8,
                  backgroundColor: filters.showPrepared
                    ? 'rgba(255,255,255,0.2)'
                    : 'transparent',
                  borderRadius: 20,
                }}
                onPress={() =>
                  setFilters({
                    ...filters,
                    showPrepared: !filters.showPrepared,
                  })
                }
              >
                <Checkbox
                  status={filters.showPrepared ? 'checked' : 'unchecked'}
                  onPress={() =>
                    setFilters({
                      ...filters,
                      showPrepared: !filters.showPrepared,
                    })
                  }
                  color={theme.colors.onPrimary}
                  uncheckedColor={theme.colors.onPrimary}
                />
                <Text
                  style={{
                    color: theme.colors.onPrimary,
                    fontSize: responsive.isWeb ? 16 : 14,
                    marginLeft: 4,
                    fontWeight: filters.showPrepared ? 'bold' : 'normal',
                  }}
                >
                  Mostrar Listas
                </Text>
              </TouchableOpacity>
              <KitchenFilterButton />
              {/* Botón de recargar */}
              <RefreshButton />
              <ConnectionIndicator />
            </View>
          ),
        })}
      >
        <Drawer.Screen
          name="Kitchen"
          options={{
            title: screenName,
            drawerIcon: ({ color, size }) => (
              <Icon source="chef-hat" color={color} size={size} />
            ),
          }}
        >
          {() => <KitchenNavigator />}
        </Drawer.Screen>

        <Drawer.Screen
          name="ServerSettings"
          component={ServerSettingsScreen}
          options={{
            title: 'Configuración del Servidor',
            drawerIcon: ({ color, size }) => (
              <Icon source="server-network" color={color} size={size} />
            ),
            headerShown: true,
            headerStyle: styles.headerStyle,
            headerTintColor: theme.colors.onPrimary,
            headerTitleStyle: styles.headerTitleStyle,
          }}
        />
      </Drawer.Navigator>
    </>
  );
}

export function KitchenOnlyNavigator() {
  // Usar navegador web personalizado en plataforma web
  if (Platform.OS === 'web') {
    const { KitchenWebNavigator } = require('./KitchenWebNavigator');
    return <KitchenWebNavigator />;
  }

  // Usar navegador nativo para otras plataformas
  return (
    <KitchenProvider>
      <KitchenOnlyNavigatorContent />
    </KitchenProvider>
  );
}

================
File: app/src/components/AudioOrderModal.tsx
================
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  ActivityIndicator,
  Dimensions,
  TouchableOpacity,
  Animated,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Divider,
  Surface,
  IconButton,
} from 'react-native-paper';
import { MaterialIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { useGetOrderMenu } from '@/modules/orders/hooks/useMenuQueries';
import type {
  AIOrderItem,
  DeliveryInfoData,
  ScheduledDeliveryData,
} from '@/services/audioOrderService';
import ProductCustomizationModal from '@/modules/orders/components/ProductCustomizationModal';
import type { FullMenuProduct as Product } from '@/modules/orders/types/orders.types';
import type {
  CartItem,
  CartItemModifier,
} from '@/modules/orders/stores/useCartStore';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import { Swipeable } from 'react-native-gesture-handler';
import {
  OrderTypeEnum,
  type OrderType,
} from '@/modules/orders/types/orders.types';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import { useGetAreas } from '@/modules/areasTables/services/areaService';
import { useGetTablesByArea } from '@/modules/areasTables/services/tableService';
import type { Table } from '@/modules/areasTables/types/areasTables.types';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import { Menu, Checkbox, HelperText } from 'react-native-paper';
import type { DeliveryInfo } from '@/app/schemas/domain/delivery-info.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

interface AudioOrderModalProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: (
    items: AIOrderItem[],
    deliveryInfo?: DeliveryInfoData,
    scheduledDelivery?: ScheduledDeliveryData,
    orderType?: OrderType,
  ) => void;
  isProcessing: boolean;
  orderData?: {
    orderItems?: AIOrderItem[];
    deliveryInfo?: DeliveryInfoData;
    scheduledDelivery?: ScheduledDeliveryData;
    orderType?: OrderType;
    warnings?: string;
    processingTime?: number;
  };
  error?: string;
}

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');
const modalWidth = Math.min(screenWidth * 0.95, 500);

export const AudioOrderModal: React.FC<AudioOrderModalProps> = ({
  visible,
  onDismiss,
  onConfirm,
  isProcessing,
  orderData,
  error,
}) => {
  const theme = useAppTheme();
  const { colors } = theme;
  const [editableDeliveryInfo, setEditableDeliveryInfo] =
    useState<DeliveryInfo>({});
  const [editableItems, setEditableItems] = useState<AIOrderItem[]>([]);
  const [editableOrderType, setEditableOrderType] = useState<OrderType>(
    OrderTypeEnum.DINE_IN,
  );
  const [editableSelectedAreaId, setEditableSelectedAreaId] = useState<
    string | null
  >(null);
  const [editableSelectedTableId, setEditableSelectedTableId] = useState<
    string | null
  >(null);
  const [editableIsTemporaryTable, setEditableIsTemporaryTable] =
    useState<boolean>(false);
  const [editableTemporaryTableName, setEditableTemporaryTableName] =
    useState<string>('');
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [editingProduct, setEditingProduct] = useState<Product | null>(null);
  const [showCustomizationModal, setShowCustomizationModal] = useState(false);

  // Estados para validación de productos
  const [itemsWithErrors, setItemsWithErrors] = useState<Set<number>>(
    new Set(),
  );
  const [itemValidationErrors, setItemValidationErrors] = useState<
    Record<number, string[]>
  >({});

  // Estados de error
  const [areaError, setAreaError] = useState<string | null>(null);
  const [tableError, setTableError] = useState<string | null>(null);
  const [recipientNameError, setRecipientNameError] = useState<string | null>(
    null,
  );
  const [recipientPhoneError, setRecipientPhoneError] = useState<string | null>(
    null,
  );
  const [addressError, setAddressError] = useState<string | null>(null);

  // Estado para modal de confirmación de salida
  const [showExitConfirmationModal, setShowExitConfirmationModal] =
    useState(false);

  // Estados de menús
  const [areaMenuVisible, setAreaMenuVisible] = useState(false);
  const [tableMenuVisible, setTableMenuVisible] = useState(false);

  const { data: menu } = useGetOrderMenu();

  // Queries para áreas y mesas
  const {
    data: areasData,
    isLoading: isLoadingAreas,
    error: errorAreas,
  } = useGetAreas();
  const {
    data: tablesData,
    isLoading: isLoadingTables,
    error: errorTables,
  } = useGetTablesByArea(editableSelectedAreaId);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Nombres computed para área y mesa
  const selectedAreaName = useMemo(
    () => areasData?.find((a: any) => a.id === editableSelectedAreaId)?.name,
    [areasData, editableSelectedAreaId],
  );
  const selectedTableName = useMemo(() => {
    return tablesData?.find((t) => t.id === editableSelectedTableId)?.name;
  }, [tablesData, editableSelectedTableId]);

  // Función para validar un producto según las reglas del ProductCustomizationModal
  const validateProductItem = useCallback(
    (item: AIOrderItem, product?: Product) => {
      if (!menu || !product) return [];

      const errors: string[] = [];

      // 1. Validar variante requerida
      if (
        product.hasVariants &&
        product.variants &&
        product.variants.length > 0
      ) {
        if (!item.variantId) {
          errors.push('Variante requerida');
        }
      }

      // 2. Validar modificadores requeridos
      if (product.modifierGroups && product.modifierGroups.length > 0) {
        for (const group of product.modifierGroups) {
          const selectedModifiersInGroup = (item.modifiers || []).filter(
            (modName) => {
              // Buscar si este modificador pertenece a este grupo
              return group.productModifiers?.some((pm) => pm.name === modName);
            },
          );

          const selectedCount = selectedModifiersInGroup.length;
          const minRequired = Math.max(
            group.minSelections || 0,
            group.isRequired ? 1 : 0,
          );

          if (selectedCount < minRequired) {
            if (group.isRequired && minRequired === 1) {
              errors.push(`${group.name}: Requerido`);
            } else {
              errors.push(`${group.name}: Mínimo ${minRequired}`);
            }
          }

          // Validar máximo
          if (group.maxSelections && selectedCount > group.maxSelections) {
            errors.push(`${group.name}: Máximo ${group.maxSelections}`);
          }
        }
      }

      // 3. Validar personalizaciones de pizza
      if (
        product.category?.name?.toLowerCase().includes('pizza') &&
        item.pizzaCustomizations
      ) {
        // Las pizzas necesitan al menos una personalización válida
        const validCustomizations = item.pizzaCustomizations.filter(
          (custom) => custom.customizationId && custom.action,
        );

        if (validCustomizations.length === 0) {
          errors.push('Pizza requiere personalizaciones');
        }
      }

      return errors;
    },
    [menu],
  );

  // Función para encontrar el producto completo en el menú
  const findProductInMenu = useCallback(
    (productId: string): Product | undefined => {
      if (!menu) return undefined;

      for (const category of menu) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            if (product.id === productId) {
              return product;
            }
          }
        }
      }
      return undefined;
    },
    [menu],
  );

  // Validar todos los productos cuando cambien
  useEffect(() => {
    if (!editableItems || editableItems.length === 0) {
      setItemsWithErrors(new Set());
      setItemValidationErrors({});
      return;
    }

    const newItemsWithErrors = new Set<number>();
    const newValidationErrors: Record<number, string[]> = {};

    editableItems.forEach((item, index) => {
      const product = findProductInMenu(item.productId);
      const errors = validateProductItem(item, product);

      if (errors.length > 0) {
        newItemsWithErrors.add(index);
        newValidationErrors[index] = errors;
      }
    });

    setItemsWithErrors(newItemsWithErrors);
    setItemValidationErrors(newValidationErrors);
  }, [editableItems, findProductInMenu, validateProductItem]);

  // Función para abrir modal de personalización para un producto específico
  // Se definirá después de handleEditItem para evitar problemas de dependencias

  // Verificar si hay productos con errores que bloqueen el guardado
  const hasValidationErrors = useMemo(() => {
    return itemsWithErrors.size > 0;
  }, [itemsWithErrors]);

  // Verificar si hay datos modificados que se perderían al salir
  const hasUnsavedChanges = useMemo(() => {
    // Si hay productos procesados o datos editados, hay cambios sin guardar
    return (
      editableItems.length > 0 ||
      editableDeliveryInfo.recipientName?.trim() ||
      editableDeliveryInfo.recipientPhone?.trim() ||
      editableDeliveryInfo.fullAddress?.trim() ||
      editableSelectedAreaId ||
      editableSelectedTableId ||
      editableTemporaryTableName?.trim()
    );
  }, [
    editableItems.length,
    editableDeliveryInfo.recipientName,
    editableDeliveryInfo.recipientPhone,
    editableDeliveryInfo.fullAddress,
    editableSelectedAreaId,
    editableSelectedTableId,
    editableTemporaryTableName,
  ]);

  // Sincronizar la información cuando cambie orderData
  useEffect(() => {
    if (orderData?.deliveryInfo) {
      setEditableDeliveryInfo(orderData.deliveryInfo as DeliveryInfo);
    }
    if (orderData?.orderItems) {
      setEditableItems(orderData.orderItems);
    }
    // Si orderType viene del backend, usarlo; si es undefined, usar DELIVERY como defecto
    if (orderData?.orderType !== undefined) {
      setEditableOrderType(orderData.orderType);
    } else if (orderData) {
      // Solo cambiar a DELIVERY si hay datos de la orden pero orderType es undefined
      setEditableOrderType(OrderTypeEnum.DELIVERY);
    }
  }, [orderData?.deliveryInfo, orderData?.orderItems, orderData?.orderType]);

  // Limpiar errores cuando cambie el tipo de orden
  useEffect(() => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
  }, [editableOrderType]);

  const handleConfirm = () => {
    // Resetear errores
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);

    if (editableItems && editableItems.length > 0) {
      // Solo verificar errores de validación de productos
      if (hasValidationErrors) {
        showSnackbar({
          message:
            'Hay productos con errores que deben corregirse antes de continuar',
          type: 'error',
        });
        return;
      }

      // Crear deliveryInfo adaptada
      const adaptedDeliveryInfo: DeliveryInfoData = {
        recipientName: editableDeliveryInfo.recipientName,
        recipientPhone: editableDeliveryInfo.recipientPhone,
        fullAddress: editableDeliveryInfo.fullAddress,
      };

      onConfirm(
        editableItems,
        adaptedDeliveryInfo,
        orderData?.scheduledDelivery,
        editableOrderType,
      );
    }
  };

  // Función para actualizar la cantidad de un item
  const updateItemQuantity = useCallback(
    (itemId: string, index: number, newQuantity: number) => {
      if (newQuantity < 1) {
        return; // No permitir cantidad menor a 1 con los botones
      }

      setEditableItems((prev) =>
        prev.map((item, i) => {
          if (i === index) {
            return { ...item, quantity: newQuantity };
          }
          return item;
        }),
      );
    },
    [],
  );

  // Función para eliminar un item
  const removeItem = useCallback(
    (index: number) => {
      setEditableItems((prev) => prev.filter((_, i) => i !== index));
      showSnackbar({
        message: 'Producto eliminado',
        type: 'info',
      });
    },
    [showSnackbar],
  );

  // Función para manejar la edición de un item
  const handleEditItem = useCallback(
    (item: AIOrderItem, index: number) => {
      if (!menu) {
        showSnackbar({
          message: 'El menú no está disponible',
          type: 'error',
        });
        return;
      }

      // Buscar el producto en el menú
      let foundProduct: Product | null = null;
      outer: for (const category of menu) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            if (product.id === item.productId) {
              foundProduct = product;
              break outer;
            }
          }
        }
      }

      if (!foundProduct) {
        showSnackbar({
          message: 'Producto no encontrado en el menú',
          type: 'error',
        });
        return;
      }

      // Convertir AIOrderItem a CartItem para el modal
      const cartItem: CartItem = {
        id: `${item.productId}-${index}`,
        productId: item.productId,
        productName: foundProduct.name,
        quantity: item.quantity,
        unitPrice:
          foundProduct.variants?.find((v) => v.id === item.variantId)?.price ||
          foundProduct.price ||
          0,
        totalPrice: 0, // Se calculará en el modal
        modifiers:
          item.modifiers?.map((modName) => {
            // Buscar el modificador en el producto
            for (const modGroup of foundProduct.modifierGroups || []) {
              const modifier = modGroup.productModifiers?.find(
                (m) => m.name === modName,
              );
              if (modifier) {
                return {
                  id: modifier.id,
                  modifierGroupId: modGroup.id,
                  name: modifier.name,
                  price: modifier.price || 0,
                };
              }
            }
            return {
              id: modName,
              modifierGroupId: '',
              name: modName,
              price: 0,
            };
          }) || [],
        variantId: item.variantId,
        variantName: foundProduct.variants?.find((v) => v.id === item.variantId)
          ?.name,
        selectedPizzaCustomizations: item.pizzaCustomizations?.map((pc) => ({
          pizzaCustomizationId: pc.customizationId,
          half: pc.half as any,
          action: pc.action as any,
        })),
      };

      setEditingItem(cartItem);
      setEditingProduct(foundProduct);
      setShowCustomizationModal(true);
    },
    [menu, showSnackbar],
  );

  // Función para manejar la actualización desde el modal
  const handleUpdateEditedItem = useCallback(
    (
      itemId: string,
      quantity: number,
      modifiers: CartItemModifier[],
      preparationNotes?: string,
      variantId?: string,
      variantName?: string,
      unitPrice?: number,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    ) => {
      const index = parseInt(itemId.split('-').pop() || '0');

      setEditableItems((prev) =>
        prev.map((item, i) => {
          if (i === index) {
            return {
              ...item,
              quantity,
              variantId,
              modifiers: modifiers.map((m) => m.name),
              pizzaCustomizations: selectedPizzaCustomizations?.map((pc) => ({
                customizationId: pc.pizzaCustomizationId,
                half: pc.half,
                action: pc.action,
              })),
            };
          }
          return item;
        }),
      );

      setShowCustomizationModal(false);
      setEditingItem(null);
      setEditingProduct(null);

      showSnackbar({
        message: 'Producto actualizado',
        type: 'success',
      });
    },
    [showSnackbar],
  );

  // Funciones para manejo de confirmación de salida
  const handleAttemptExit = useCallback(() => {
    if (!hasUnsavedChanges) {
      onDismiss();
    } else {
      setShowExitConfirmationModal(true);
    }
  }, [hasUnsavedChanges, onDismiss]);

  const handleConfirmExit = useCallback(() => {
    setShowExitConfirmationModal(false);
    onDismiss();
  }, [onDismiss]);

  const handleCancelExit = useCallback(() => {
    setShowExitConfirmationModal(false);
  }, []);

  // Función para obtener el nombre del producto desde el menú
  const getProductDetails = (productId: string, variantId?: string) => {
    if (!menu)
      return {
        productName: `Producto ${productId.slice(-4)}`,
        variantName: undefined,
      };

    for (const category of menu) {
      for (const subcategory of category.subcategories || []) {
        for (const product of subcategory.products || []) {
          if (product.id === productId) {
            const variant = variantId
              ? product.variants?.find((v) => v.id === variantId)
              : undefined;
            return {
              productName: product.name,
              variantName: variant?.name,
            };
          }
        }
      }
    }
    return {
      productName: `Producto ${productId.slice(-4)}`,
      variantName: undefined,
    };
  };

  // Función para formatear personalizaciones de pizza
  const formatPizzaCustomizations = (customizations?: any[]) => {
    if (!customizations || customizations.length === 0) return '';

    const groupedByHalf = customizations.reduce(
      (acc, curr) => {
        const half = curr.half || 'FULL';
        if (!acc[half]) {
          acc[half] = { ingredients: [] };
        }

        let name = curr.customizationName;
        if (!name && menu) {
          // Buscar el nombre en el menú
          outer: for (const category of menu) {
            for (const subcategory of category.subcategories || []) {
              for (const product of subcategory.products || []) {
                if (product.pizzaCustomizations) {
                  const customization = product.pizzaCustomizations.find(
                    (pc) => pc.id === curr.customizationId,
                  );
                  if (customization) {
                    name = customization.name;
                    break outer;
                  }
                }
              }
            }
          }
        }

        if (!name) {
          name = curr.customizationId.slice(-4);
        }

        const prefix = curr.action === 'ADD' ? '+ ' : '- ';
        acc[half].ingredients.push(prefix + name);

        return acc;
      },
      {} as Record<string, { ingredients: string[] }>,
    );

    if (groupedByHalf.FULL) {
      return groupedByHalf.FULL.ingredients.join(', ');
    } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
      const half1 = groupedByHalf.HALF_1
        ? `Mitad 1: ${groupedByHalf.HALF_1.ingredients.join(', ')}`
        : '';
      const half2 = groupedByHalf.HALF_2
        ? `Mitad 2: ${groupedByHalf.HALF_2.ingredients.join(', ')}`
        : '';
      return [half1, half2].filter(Boolean).join(' / ');
    }

    return '';
  };

  const renderProcessingState = () => (
    <View style={styles.processingContainer}>
      <View style={styles.processingContent}>
        <MaterialIcons
          name="mic"
          size={80}
          color={colors.primary}
          style={styles.processingIcon}
        />
        <ActivityIndicator
          size="large"
          color={colors.primary}
          style={styles.processingSpinner}
        />
        <Text style={[styles.processingTitle, { color: colors.onSurface }]}>
          Analizando tu solicitud
        </Text>
        <Text
          style={[styles.processingSubtext, { color: colors.onSurfaceVariant }]}
        >
          Extrayendo productos y detalles de tu pedido por voz...
        </Text>
        <View style={styles.processingSteps}>
          <View style={styles.processingStep}>
            <MaterialIcons name="hearing" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Transcribiendo audio
            </Text>
          </View>
          <View style={styles.processingStep}>
            <MaterialIcons name="psychology" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Analizando productos
            </Text>
          </View>
          <View style={styles.processingStep}>
            <MaterialIcons name="list-alt" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Generando orden
            </Text>
          </View>
        </View>
        <Text
          style={[styles.processingFooter, { color: colors.onSurfaceVariant }]}
        >
          ⏱️ Esto puede tomar unos segundos
        </Text>
      </View>
    </View>
  );

  const renderErrorState = () => (
    <View style={styles.errorContainer}>
      <View style={styles.errorContent}>
        <MaterialIcons name="error-outline" size={80} color={colors.error} />
        <Text style={[styles.errorTitle, { color: colors.error }]}>
          No se pudo procesar tu solicitud
        </Text>
        <Text style={[styles.errorMessage, { color: colors.onSurfaceVariant }]}>
          {error}
        </Text>
        <View style={styles.errorActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={styles.errorButton}
            icon="refresh"
          >
            Intentar de nuevo
          </Button>
          <Button
            mode="contained"
            onPress={handleAttemptExit}
            style={styles.errorButton}
            icon="close"
          >
            Cerrar
          </Button>
        </View>
        <Text style={[styles.errorFooter, { color: colors.onSurfaceVariant }]}>
          💡 Asegúrate de hablar claramente y mencionar los productos que deseas
        </Text>
      </View>
    </View>
  );

  const renderOrderSummary = () => {
    if (!orderData) return null;

    const { scheduledDelivery, warnings } = orderData;

    return (
      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
      >
        {/* Header con tiempo de procesamiento - REMOVIDO */}

        {/* Tipo de Orden - Always visible at top */}
        <View style={styles.orderTypeSection}>
          <View style={styles.compactSectionHeader}>
            <MaterialIcons name="restaurant" size={20} color={colors.primary} />
            <Text
              style={[styles.compactSectionTitle, { color: colors.onSurface }]}
            >
              Tipo de Orden
            </Text>
          </View>

          <View style={styles.orderTypeButtons}>
            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.DINE_IN &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.DINE_IN
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.DINE_IN)}
            >
              <MaterialIcons
                name="restaurant"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.DINE_IN
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.DINE_IN
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Comer aquí
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.TAKE_AWAY &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.TAKE_AWAY
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.TAKE_AWAY)}
            >
              <MaterialIcons
                name="shopping-bag"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.TAKE_AWAY
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.TAKE_AWAY
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Para llevar
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.DELIVERY &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.DELIVERY
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.DELIVERY)}
            >
              <MaterialIcons
                name="moped"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.DELIVERY
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.DELIVERY
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Domicilio
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* Renderizado condicional según tipo de orden - EXACTAMENTE como OrderCartDetail */}
        {editableOrderType === OrderTypeEnum.DINE_IN && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons
                name="restaurant"
                size={20}
                color={colors.primary}
              />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Mesa y Área
              </Text>
            </View>

            <View style={styles.compactDeliveryContainer}>
              {/* Área y Mesa en la misma fila */}
              <View style={styles.dineInSelectorsRow}>
                {/* Área */}
                <View style={styles.dineInSelectorContainer}>
                  <Menu
                    visible={areaMenuVisible}
                    onDismiss={() => setAreaMenuVisible(false)}
                    anchor={
                      <AnimatedLabelSelector
                        label="Área *"
                        value={selectedAreaName}
                        onPress={() => setAreaMenuVisible(true)}
                        isLoading={isLoadingAreas}
                        error={!!areaError || !!errorAreas}
                        disabled={isLoadingAreas}
                      />
                    }
                  >
                    {areasData?.map((area: any) => (
                      <Menu.Item
                        key={area.id}
                        onPress={() => {
                          setEditableSelectedAreaId(area.id);
                          setEditableSelectedTableId(null);
                          setAreaMenuVisible(false);
                          setAreaError(null);
                        }}
                        title={area.name}
                      />
                    ))}
                    {errorAreas && (
                      <Menu.Item title="Error al cargar áreas" disabled />
                    )}
                  </Menu>
                  {areaError && !errorAreas && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {areaError}
                    </HelperText>
                  )}
                  {errorAreas && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      Error al cargar áreas
                    </HelperText>
                  )}
                </View>

                {/* Mesa */}
                <View style={styles.dineInSelectorContainer}>
                  <Menu
                    visible={tableMenuVisible}
                    onDismiss={() => setTableMenuVisible(false)}
                    anchor={
                      <AnimatedLabelSelector
                        label="Mesa *"
                        value={selectedTableName}
                        onPress={() => setTableMenuVisible(true)}
                        isLoading={isLoadingTables}
                        error={!!tableError || !!errorTables}
                        disabled={
                          !editableSelectedAreaId ||
                          isLoadingTables ||
                          isLoadingAreas ||
                          editableIsTemporaryTable
                        }
                      />
                    }
                  >
                    {tablesData?.map((table: Table) => (
                      <Menu.Item
                        key={table.id}
                        onPress={() => {
                          if (table.isAvailable) {
                            setEditableSelectedTableId(table.id);
                            setTableMenuVisible(false);
                            setTableError(null);
                          }
                        }}
                        title={`${table.name}${!table.isAvailable ? ' (Ocupada)' : ''}`}
                        disabled={!table.isAvailable}
                        titleStyle={
                          !table.isAvailable
                            ? { color: colors.error }
                            : undefined
                        }
                      />
                    ))}
                    {editableSelectedAreaId &&
                      tablesData?.length === 0 &&
                      !isLoadingTables &&
                      !errorTables && (
                        <Menu.Item title="No hay mesas" disabled />
                      )}
                    {errorTables && (
                      <Menu.Item title="Error al cargar mesas" disabled />
                    )}
                  </Menu>
                  {tableError && !errorTables && !editableIsTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                  {errorTables && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      Error al cargar mesas
                    </HelperText>
                  )}
                </View>
              </View>

              {/* Opción de mesa temporal */}
              <TouchableOpacity
                onPress={() => {
                  setEditableIsTemporaryTable(!editableIsTemporaryTable);
                  if (!editableIsTemporaryTable) {
                    setEditableSelectedTableId(null);
                    setTableError(null);
                  } else {
                    setEditableTemporaryTableName('');
                  }
                }}
                style={styles.checkboxContainer}
              >
                <Checkbox.Android
                  status={editableIsTemporaryTable ? 'checked' : 'unchecked'}
                  onPress={() => {
                    setEditableIsTemporaryTable(!editableIsTemporaryTable);
                    if (!editableIsTemporaryTable) {
                      setEditableSelectedTableId(null);
                      setTableError(null);
                    } else {
                      setEditableTemporaryTableName('');
                    }
                  }}
                  color={colors.primary}
                />
                <Text style={styles.checkboxLabel}>Crear mesa temporal</Text>
              </TouchableOpacity>

              {/* Campo para nombre de mesa temporal */}
              {editableIsTemporaryTable && (
                <View style={styles.temporaryTableInputContainer}>
                  <SpeechRecognitionInput
                    label="Nombre de la Mesa Temporal *"
                    value={editableTemporaryTableName}
                    onChangeText={(text) => {
                      setEditableTemporaryTableName(text);
                      if (tableError) setTableError(null);
                    }}
                    error={!!tableError && editableIsTemporaryTable}
                    speechLang="es-MX"
                    autoCapitalize="words"
                    autoCorrect={false}
                    placeholder="Ej: Mesa Terraza 1"
                    style={styles.compactTextInput}
                    dense
                  />
                  {tableError && editableIsTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                </View>
              )}
            </View>
          </View>
        )}

        {/* Para llevar - Solo nombre del cliente */}
        {editableOrderType === OrderTypeEnum.TAKE_AWAY && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons name="person" size={20} color={colors.primary} />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Información del Cliente
              </Text>
            </View>

            <View style={styles.compactDeliveryContainer}>
              <SpeechRecognitionInput
                label="Nombre del Cliente *"
                value={editableDeliveryInfo.recipientName || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientName: text,
                  }));
                  if (recipientNameError) setRecipientNameError(null);
                }}
                error={!!recipientNameError}
                speechLang="es-MX"
                autoCapitalize="words"
                autoCorrect={false}
                style={styles.compactTextInput}
                dense
              />
              {recipientNameError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientNameError}
                </HelperText>
              )}

              <SpeechRecognitionInput
                label="Teléfono (Opcional)"
                value={editableDeliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientPhone: text,
                  }));
                  if (recipientPhoneError) setRecipientPhoneError(null);
                }}
                error={!!recipientPhoneError}
                speechLang="es-MX"
                keyboardType="phone-pad"
                style={styles.compactTextInput}
                dense
              />
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>
          </View>
        )}

        {/* Domicilio - Solo dirección y teléfono */}
        {editableOrderType === OrderTypeEnum.DELIVERY && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons
                name="local-shipping"
                size={20}
                color={colors.primary}
              />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Información de Entrega
              </Text>
            </View>

            <View style={styles.compactDeliveryContainer}>
              <SpeechRecognitionInput
                label="Dirección completa *"
                value={editableDeliveryInfo.fullAddress || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    fullAddress: text,
                  }));
                  if (addressError) setAddressError(null);
                }}
                error={!!addressError}
                speechLang="es-MX"
                multiline
                numberOfLines={2}
                style={styles.compactTextInput}
                dense
              />
              {addressError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {addressError}
                </HelperText>
              )}

              <SpeechRecognitionInput
                label="Teléfono *"
                value={editableDeliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientPhone: text,
                  }));
                  if (recipientPhoneError) setRecipientPhoneError(null);
                }}
                error={!!recipientPhoneError}
                speechLang="es-MX"
                keyboardType="phone-pad"
                style={styles.compactTextInput}
                dense
              />
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>
          </View>
        )}

        {/* Advertencias */}
        {warnings && (
          <Surface
            style={[
              styles.warningContainer,
              { backgroundColor: colors.tertiaryContainer },
            ]}
          >
            <MaterialIcons name="warning" size={20} color={colors.tertiary} />
            <Text
              style={[
                styles.warningText,
                { color: colors.onTertiaryContainer },
              ]}
            >
              {warnings}
            </Text>
          </Surface>
        )}

        {/* Items de la orden - Versión compacta */}
        <View
          style={[
            styles.compactSectionContainer,
            { borderTopWidth: 1, borderTopColor: colors.primary + '40' },
          ]}
        >
          <View style={styles.compactSectionHeader}>
            <MaterialIcons
              name="restaurant-menu"
              size={20}
              color={colors.primary}
            />
            <Text
              style={[styles.compactSectionTitle, { color: colors.onSurface }]}
            >
              Productos ({editableItems.length})
            </Text>
          </View>

          {editableItems.length === 0 ? (
            <View style={styles.emptyContainerCompact}>
              <MaterialIcons
                name="mic-off"
                size={32}
                color={colors.onSurfaceVariant}
              />
              <Text
                style={[
                  styles.emptyTextCompact,
                  { color: colors.onSurfaceVariant },
                ]}
              >
                No se detectaron productos
              </Text>
            </View>
          ) : (
            <View style={styles.compactItemsList}>
              {editableItems.map((item, index) => {
                const itemKey = `${item.productId}-${index}`;
                const { productName, variantName } = getProductDetails(
                  item.productId,
                  item.variantId,
                );
                const pizzaCustomizationsText = formatPizzaCustomizations(
                  item.pizzaCustomizations,
                );

                // Función para renderizar acciones de deslizar
                const renderRightActions = (_progress: any, dragX: any) => {
                  const translateX = dragX.interpolate({
                    inputRange: [-100, 0],
                    outputRange: [0, 100],
                    extrapolate: 'clamp',
                  });

                  const scale = dragX.interpolate({
                    inputRange: [-100, -50, 0],
                    outputRange: [1, 0.8, 0.5],
                    extrapolate: 'clamp',
                  });

                  const opacity = dragX.interpolate({
                    inputRange: [-100, -20, 0],
                    outputRange: [1, 0.5, 0],
                    extrapolate: 'clamp',
                  });

                  return (
                    <Animated.View
                      style={[
                        styles.deleteActionContainer,
                        {
                          opacity,
                          transform: [{ translateX }],
                        },
                      ]}
                    >
                      <Animated.View
                        style={[
                          styles.deleteAction,
                          {
                            backgroundColor: colors.error,
                            transform: [{ scale }],
                          },
                        ]}
                      >
                        <View style={styles.deleteIconContainer}>
                          <IconButton
                            icon="delete-sweep"
                            size={28}
                            iconColor="white"
                            style={styles.deleteIcon}
                          />
                        </View>
                        <Text style={styles.deleteActionText}>ELIMINAR</Text>
                      </Animated.View>
                    </Animated.View>
                  );
                };

                return (
                  <View key={itemKey}>
                    <Swipeable
                      renderRightActions={renderRightActions}
                      overshootRight={false}
                      friction={2}
                      rightThreshold={90}
                      leftThreshold={100}
                      onSwipeableOpen={(direction) => {
                        if (direction === 'right') {
                          setTimeout(() => {
                            removeItem(index);
                          }, 150);
                        }
                      }}
                    >
                      <TouchableOpacity
                        onPress={() => handleEditItem(item, index)}
                        activeOpacity={0.7}
                        style={[
                          styles.compactItemContainer,
                          itemsWithErrors.has(index) && {
                            borderWidth: 1,
                            borderColor: colors.error,
                            backgroundColor: colors.errorContainer + '20',
                          },
                        ]}
                      >
                        <View style={styles.compactItemContent}>
                          <View style={styles.compactItemLeft}>
                            <Text
                              style={[
                                styles.compactItemTitle,
                                { color: colors.onSurface },
                              ]}
                            >
                              {`${item.quantity}x ${variantName || productName}`}
                            </Text>

                            {/* Mostrar errores de validación */}
                            {itemValidationErrors[index] && (
                              <View style={styles.validationErrorsContainer}>
                                {itemValidationErrors[index].map(
                                  (error, errorIdx) => (
                                    <Text
                                      key={errorIdx}
                                      style={[
                                        styles.validationErrorText,
                                        { color: colors.error },
                                      ]}
                                    >
                                      ⚠️ {error}
                                    </Text>
                                  ),
                                )}
                              </View>
                            )}

                            {/* Renderizar personalizaciones de pizza */}
                            {pizzaCustomizationsText && (
                              <Text
                                style={[
                                  styles.compactItemSubtitle,
                                  { color: colors.onSurfaceVariant },
                                ]}
                              >
                                {pizzaCustomizationsText}
                              </Text>
                            )}

                            {/* Renderizar modificadores */}
                            {item.modifiers &&
                              item.modifiers.length > 0 &&
                              item.modifiers.map((mod, idx) => (
                                <Text
                                  key={idx}
                                  style={[
                                    styles.compactItemSubtitle,
                                    { color: colors.onSurfaceVariant },
                                  ]}
                                >
                                  • {mod}
                                </Text>
                              ))}
                          </View>

                          <View style={styles.compactItemRight}>
                            <View style={styles.compactQuantityActions}>
                              <IconButton
                                icon="minus-circle-outline"
                                size={18}
                                onPress={() =>
                                  updateItemQuantity(
                                    item.productId,
                                    index,
                                    item.quantity - 1,
                                  )
                                }
                                style={styles.compactQuantityButton}
                                disabled={item.quantity <= 1}
                              />
                              <Text
                                style={[
                                  styles.compactQuantityText,
                                  { color: colors.onSurface },
                                ]}
                              >
                                {item.quantity}
                              </Text>
                              <IconButton
                                icon="plus-circle-outline"
                                size={18}
                                onPress={() =>
                                  updateItemQuantity(
                                    item.productId,
                                    index,
                                    item.quantity + 1,
                                  )
                                }
                                style={styles.compactQuantityButton}
                              />
                            </View>
                            <IconButton
                              icon="pencil"
                              size={16}
                              onPress={() => handleEditItem(item, index)}
                              style={styles.compactEditButton}
                            />
                          </View>
                        </View>
                      </TouchableOpacity>
                    </Swipeable>

                    {index < editableItems.length - 1 && (
                      <Divider style={styles.compactItemDivider} />
                    )}
                  </View>
                );
              })}
            </View>
          )}
        </View>

        {/* Hora programada - Versión compacta */}
        {scheduledDelivery?.time && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons name="schedule" size={20} color={colors.primary} />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Entrega Programada
              </Text>
            </View>
            <Text
              style={[styles.compactScheduledTime, { color: colors.onSurface }]}
            >
              {scheduledDelivery.time}
            </Text>
          </View>
        )}
      </ScrollView>
    );
  };

  return (
    <>
      {visible && (
        <Portal>
          <Modal
            visible={visible}
            onDismiss={onDismiss}
            contentContainerStyle={[
              styles.modalContainer,
              {
                width: modalWidth,
                backgroundColor: colors.surface,
                maxHeight: screenHeight * 0.9,
                height: screenHeight * 0.85,
                // Borde grueso y muy visible
                borderWidth: 6,
                borderColor: colors.primary,
                // Sombra pronunciada con color primario
                shadowColor: colors.primary,
                shadowOffset: { width: 0, height: 6 },
                shadowOpacity: 0.6,
                shadowRadius: 16,
                // Para Android - elevación alta
                elevation: 20,
              },
            ]}
          >
            {/* Header dinámico según el estado */}
            <View style={styles.header}>
              <Text style={[styles.title, { color: colors.onSurface }]}>
                {isProcessing && '🎤 Procesando orden por voz...'}
                {error && '⚠️ Error en el procesamiento'}
                {!isProcessing &&
                  !error &&
                  hasValidationErrors &&
                  '⚠️ Revisa los productos'}
                {!isProcessing &&
                  !error &&
                  !hasValidationErrors &&
                  'Agregar a tu orden 🛒'}
              </Text>
              <IconButton
                icon="close"
                size={24}
                onPress={handleAttemptExit}
                style={styles.closeButton}
              />
            </View>

            {/* Divider solo cuando no está procesando ni hay error */}
            {!isProcessing && !error && (
              <Divider style={{ backgroundColor: colors.outlineVariant }} />
            )}

            {isProcessing && renderProcessingState()}
            {error && renderErrorState()}
            {!isProcessing && !error && orderData && renderOrderSummary()}

            {!isProcessing && !error && orderData && (
              <>
                <Divider style={{ backgroundColor: colors.outlineVariant }} />
                <View style={styles.footer}>
                  {editableItems && editableItems.length > 0 ? (
                    <>
                      <Button
                        mode="outlined"
                        onPress={handleAttemptExit}
                        style={styles.footerButton}
                      >
                        Cancelar
                      </Button>
                      <Button
                        mode="contained"
                        onPress={handleConfirm}
                        style={[
                          styles.footerButton,
                          hasValidationErrors && {
                            backgroundColor: colors.error,
                          },
                        ]}
                        icon={hasValidationErrors ? 'alert-circle' : 'plus'}
                        buttonColor={
                          hasValidationErrors ? colors.error : undefined
                        }
                      >
                        {hasValidationErrors ? 'Hay errores' : 'Agregar'}
                      </Button>
                    </>
                  ) : (
                    <Button
                      mode="contained"
                      onPress={handleAttemptExit}
                      style={[styles.footerButton, { flex: 1 }]}
                    >
                      Cerrar
                    </Button>
                  )}
                </View>
              </>
            )}
          </Modal>

          {/* Modal de personalización de producto */}
          {showCustomizationModal && editingProduct && editingItem && (
            <ProductCustomizationModal
              visible={showCustomizationModal}
              product={editingProduct}
              editingItem={editingItem}
              onDismiss={() => {
                setShowCustomizationModal(false);
                setEditingItem(null);
                setEditingProduct(null);
              }}
              onAddToCart={() => {}}
              onUpdateItem={handleUpdateEditedItem}
            />
          )}
        </Portal>
      )}

      {/* Modal de confirmación de salida */}
      <ConfirmationModal
        visible={showExitConfirmationModal}
        title="¿Descartar datos?"
        message="Tienes datos sin guardar. Si sales, se perderán los productos y la información que has modificado. ¿Estás seguro?"
        confirmText="Salir y Descartar"
        cancelText="Cancelar"
        onConfirm={handleConfirmExit}
        onCancel={handleCancelExit}
        onDismiss={handleCancelExit}
        confirmButtonColor={colors.error}
      />
    </>
  );
};

const styles = StyleSheet.create({
  modalContainer: {
    borderRadius: 16,
    alignSelf: 'center',
    flex: 1,
    marginVertical: 16,
    marginHorizontal: 12,
    // Sombra base adicional en negro para mayor contraste
    shadowColor: '#000000',
    shadowOffset: {
      width: 0,
      height: 8,
    },
    shadowOpacity: 0.3,
    shadowRadius: 20,
    elevation: 24,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  closeButton: {
    margin: 0,
  },
  scrollView: {
    flex: 1,
  },
  processingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingVertical: 40,
  },
  processingContent: {
    alignItems: 'center',
    maxWidth: 400,
    width: '100%',
  },
  processingIcon: {
    marginBottom: 16,
    opacity: 0.8,
  },
  processingSpinner: {
    marginBottom: 24,
  },
  processingTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: 12,
    textAlign: 'center',
  },
  processingSubtext: {
    fontSize: 16,
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 22,
  },
  processingSteps: {
    width: '100%',
    marginBottom: 32,
    gap: 16,
  },
  processingStep: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    paddingHorizontal: 16,
  },
  stepText: {
    fontSize: 14,
    flex: 1,
  },
  processingFooter: {
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingVertical: 40,
  },
  errorContent: {
    alignItems: 'center',
    maxWidth: 400,
    width: '100%',
  },
  errorTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginTop: 16,
    marginBottom: 12,
    textAlign: 'center',
  },
  errorMessage: {
    fontSize: 16,
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 22,
  },
  errorActions: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 24,
    width: '100%',
  },
  errorButton: {
    flex: 1,
  },
  errorFooter: {
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
    lineHeight: 20,
  },
  // Estilos de processingTime removidos
  warningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    margin: 16,
    borderRadius: 8,
    gap: 8,
  },
  warningText: {
    flex: 1,
    fontSize: 14,
  },
  sectionCard: {
    margin: 16,
    marginBottom: 8,
  },
  emptyText: {
    textAlign: 'center',
    paddingVertical: 16,
  },
  itemRightContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  expandedContent: {
    paddingLeft: 16,
    paddingRight: 16,
    paddingBottom: 12,
  },
  sectionLabel: {
    fontSize: 12,
    fontWeight: '600',
    marginBottom: 4,
  },
  modifiersContainer: {
    marginTop: 8,
  },
  modifierText: {
    fontSize: 14,
    marginLeft: 8,
    marginVertical: 2,
  },
  pizzaContainer: {
    marginTop: 8,
  },
  customizationRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginVertical: 4,
  },
  customizationChip: {
    height: 24,
  },
  halfText: {
    fontSize: 12,
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    marginVertical: 6,
  },
  infoText: {
    fontSize: 14,
    flex: 1,
  },
  scheduledTime: {
    fontSize: 18,
    fontWeight: '600',
    textAlign: 'center',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 16,
    gap: 12,
  },
  footerButton: {
    flex: 1,
  },
  itemTextContainer: {
    flex: 1,
    paddingRight: 8,
  },
  itemTitleText: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
  },
  itemDescription: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  listItem: {
    paddingVertical: 12,
    paddingHorizontal: 0,
  },
  itemDivider: {
    marginVertical: 8,
  },
  itemActionsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  quantityBadge: {
    backgroundColor: '#E0E0E0',
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
    minWidth: 28,
    alignItems: 'center',
  },
  quantityBadgeText: {
    fontSize: 14,
    fontWeight: '600',
  },
  expandButton: {
    margin: 0,
  },
  deliveryInfoContainer: {
    gap: 12,
  },
  textInput: {
    backgroundColor: 'transparent',
  },
  quantityActions: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  quantityButton: {
    margin: 0,
  },
  quantityTextContainer: {
    minWidth: 24,
    alignItems: 'center',
    justifyContent: 'center',
  },
  quantityText: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
  },
  editButton: {
    margin: 0,
    marginLeft: 8,
  },
  deleteActionContainer: {
    position: 'absolute',
    right: 0,
    top: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
  deleteAction: {
    borderRadius: 8,
    paddingHorizontal: 20,
    paddingVertical: 8,
    marginRight: 16,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  deleteIconContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  deleteIcon: {
    margin: 0,
  },
  deleteActionText: {
    color: 'white',
    fontWeight: '600',
    fontSize: 14,
  },
  emptyContainer: {
    alignItems: 'center',
    paddingVertical: 32,
    gap: 16,
  },
  emptyAddButton: {
    marginTop: 8,
  },
  emptySubtext: {
    fontSize: 14,
    marginTop: 4,
  },
  orderTypeContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    paddingVertical: 8,
  },
  orderTypeChip: {
    paddingHorizontal: 16,
  },
  // Nuevos estilos compactos
  compactSectionContainer: {
    margin: 16,
    marginBottom: 8,
  },
  compactSectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingBottom: 12,
    gap: 8,
  },
  compactSectionTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  emptyContainerCompact: {
    alignItems: 'center',
    paddingVertical: 24,
    gap: 12,
  },
  emptyTextCompact: {
    fontSize: 14,
    textAlign: 'center',
  },
  compactItemsList: {
    gap: 2,
  },
  compactItemContainer: {
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  compactItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  compactItemLeft: {
    flex: 1,
    paddingRight: 8,
  },
  compactItemTitle: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 2,
  },
  compactItemSubtitle: {
    fontSize: 12,
    marginTop: 1,
    lineHeight: 16,
  },
  compactItemRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  compactQuantityActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  compactQuantityButton: {
    margin: 0,
    width: 32,
    height: 32,
  },
  compactQuantityText: {
    fontSize: 13,
    fontWeight: '600',
    minWidth: 20,
    textAlign: 'center',
  },
  compactEditButton: {
    margin: 0,
    width: 28,
    height: 28,
    marginLeft: 4,
  },
  compactItemDivider: {
    marginVertical: 4,
    marginHorizontal: 12,
  },
  compactDeliveryContainer: {
    gap: 8,
  },
  compactTextInput: {
    backgroundColor: 'transparent',
  },
  compactScheduledTime: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
    paddingVertical: 8,
  },
  compactOrderTypeContainer: {
    alignItems: 'flex-start',
    paddingVertical: 4,
  },
  compactOrderTypeChip: {
    paddingHorizontal: 12,
    height: 28,
  },
  // Estilos para el tipo de orden editable
  orderTypeSection: {
    margin: 16,
    marginBottom: 8,
  },
  orderTypeButtons: {
    flexDirection: 'row',
    gap: 4,
  },
  orderTypeButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 8,
    gap: 6,
    elevation: 1,
  },
  orderTypeButtonActive: {
    elevation: 2,
  },
  orderTypeButtonText: {
    fontSize: 12,
    fontWeight: '500',
  },
  errorText: {
    fontSize: 12,
    marginTop: 4,
    marginLeft: 4,
  },
  compactInputContainer: {
    marginBottom: 8,
  },
  helperTextFix: {
    marginTop: 4,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 8,
  },
  checkboxLabel: {
    marginLeft: 8,
    fontSize: 14,
  },
  temporaryTableInputContainer: {
    marginTop: 8,
  },
  dineInSelectorsRow: {
    flexDirection: 'row',
    gap: 8,
    marginBottom: 8,
  },
  dineInSelectorContainer: {
    flex: 1,
  },
  // Estilos para validación de productos
  validationErrorsContainer: {
    marginTop: 4,
    gap: 2,
  },
  validationErrorText: {
    fontSize: 11,
    fontWeight: '500',
  },
});

================
File: app/src/modules/menu/screens/SubcategoriesScreen.tsx
================
import React, { useCallback, useMemo, useEffect, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Portal, IconButton } from 'react-native-paper';
import {
  useFocusEffect,
  useRoute,
  RouteProp,
  useNavigation,
} from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import GenericList from '../../../app/components/crud/GenericList';
import GenericDetailModal from '../../../app/components/crud/GenericDetailModal';
import GenericFormModal, {
  FormFieldConfig,
  ImagePickerConfig,
} from '../../../app/components/crud/GenericFormModal';
import { FilterOption } from '../../../app/components/crud/GenericList';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';

import {
  ImageUploadService,
  FileObject,
} from '../../../app/lib/imageUploadService';
import {
  useFindAllSubcategories,
  useCreateSubcategory,
  useUpdateSubcategory,
  useRemoveSubcategory,
} from '../hooks/useSubcategoriesQueries';
import {
  SubCategory,
  createSubCategoryDtoSchema,
  updateSubCategoryDtoSchema,
  SubCategoryFormInputs,
  UpdateSubCategoryFormInputs,
  findAllSubcategoriesDtoSchema,
} from '../schema/subcategories.schema';
import { z } from 'zod';
import { MenuStackParamList } from '@/modules/menu/navigation/types';

type SubcategoriesScreenRouteProp = RouteProp<
  MenuStackParamList,
  'SubcategoriesScreen'
>;
type SubcategoriesScreenNavigationProp = NativeStackNavigationProp<
  MenuStackParamList,
  'SubcategoriesScreen'
>;

type StatusFilter = 'all' | 'active' | 'inactive';
type FindAllSubcategoriesDto = z.infer<typeof findAllSubcategoriesDtoSchema>;

const SubcategoriesScreen: React.FC = () => {
  const theme = useAppTheme();
  const route = useRoute<SubcategoriesScreenRouteProp>();
  const navigation = useNavigation<SubcategoriesScreenNavigationProp>();
  const { categoryId, categoryName } = route.params;
  const styles = useMemo(() => createStyles(theme), [theme]);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [statusFilter, setStatusFilter] = React.useState<StatusFilter>('all');

  // Estado para manejar los valores iniciales del formulario
  const [formInitialValues, setFormInitialValues] = useState<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  >({
    name: '',
    description: '',
    isActive: true,
    categoryId: categoryId,
    sortOrder: 0,
    imageUri: null,
  });

  const queryParams = useMemo((): FindAllSubcategoriesDto => {
    let isActive: boolean | undefined;
    if (statusFilter === 'active') isActive = true;
    if (statusFilter === 'inactive') isActive = false;

    const params: FindAllSubcategoriesDto = { categoryId, page: 1, limit: 100 };
    if (isActive !== undefined) {
      params.isActive = isActive;
    }
    return params;
  }, [statusFilter, categoryId]);

  const {
    data: subcategoriesData,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: listError,
  } = useFindAllSubcategories(queryParams);

  const createMutation = useCreateSubcategory();
  const updateMutation = useUpdateSubcategory();
  const { mutateAsync: removeSubcategory } = useRemoveSubcategory();

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<SubCategory>({
    entityName: 'Subcategoría',
    queryKey: ['subcategories', queryParams],
    deleteMutationFn: removeSubcategory,
  });

  const handleRefresh = useCallback(() => {
    refetchList();
  }, [refetchList]);

  // Efecto para cargar valores iniciales incluyendo la imagen
  useEffect(() => {
    const loadFormData = async () => {
      if (editingItem) {
        let imageUrl = null;
        if (editingItem.photo?.path) {
          try {
            const { getImageUrl } = await import('@/app/lib/imageUtils');
            imageUrl = await getImageUrl(editingItem.photo.path);
          } catch (error) {
            imageUrl = editingItem.photo.path;
          }
        }

        setFormInitialValues({
          name: editingItem.name,
          description: editingItem.description ?? '',
          isActive: editingItem.isActive,
          categoryId: editingItem.categoryId,
          sortOrder: editingItem.sortOrder ?? 0,
          imageUri: imageUrl,
        });
      } else {
        setFormInitialValues({
          name: '',
          description: '',
          isActive: true,
          categoryId: categoryId,
          sortOrder: 0,
          imageUri: null,
        });
      }
    };

    loadFormData();
  }, [editingItem, categoryId]);

  useFocusEffect(
    useCallback(() => {
      refetchList();
    }, [refetchList]),
  );

  const handleFormSubmit = async (
    formData: SubCategoryFormInputs | UpdateSubCategoryFormInputs,
    photoId: string | null | undefined,
  ) => {
    const { imageUri, ...dataToSubmit } = formData;
    const finalData = {
      ...dataToSubmit,
      ...(photoId !== undefined && { photoId }),
    };

    if (finalData.photoId === undefined && !editingItem) {
      delete (finalData as any).photoId;
    }

    try {
      if (editingItem) {
        await updateMutation.mutateAsync({
          id: editingItem.id,
          data: finalData as UpdateSubCategoryFormInputs,
        });
      } else {
        await createMutation.mutateAsync(finalData as SubCategoryFormInputs);
      }
      handleCloseModals();
    } catch (error) {}
  };

  const listRenderConfig = {
    titleField: 'name' as keyof SubCategory,
    descriptionField: 'description' as keyof SubCategory,
    imageField: 'photo' as keyof SubCategory,
    sortOrderField: 'sortOrder' as keyof SubCategory,
    statusConfig: {
      field: 'isActive' as keyof SubCategory,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };

  const formatDate = (value: string | Date) => {
    if (!value) return 'N/A';
    const date = new Date(value);
    return date.toLocaleDateString('es-ES', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const detailFieldsToDisplay: Array<{
    field: keyof SubCategory;
    label: string;
    render?: (value: any) => string;
  }> = [
    {
      field: 'sortOrder',
      label: 'Orden de visualización',
      render: (value) => value ?? '0',
    },
    {
      field: 'createdAt',
      label: 'Fecha de creación',
      render: formatDate,
    },
    {
      field: 'updatedAt',
      label: 'Última actualización',
      render: formatDate,
    },
  ];

  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todas' },
    { value: 'active', label: 'Activas' },
    { value: 'inactive', label: 'Inactivas' },
  ];

  const formFields: FormFieldConfig<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  >[] = [
    { name: 'name', label: 'Nombre *', type: 'text', required: true },
    {
      name: 'description',
      label: 'Descripción',
      type: 'textarea',
      numberOfLines: 3,
    },
    {
      name: 'sortOrder',
      label: 'Orden de visualización',
      type: 'number',
      placeholder: '0',
    },
    {
      name: 'isActive',
      label: 'Activo',
      type: 'switch',
      switchLabel: 'Activo',
      defaultValue: true,
    },
  ];

  const imagePickerConfig: ImagePickerConfig<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  > = {
    imageUriField: 'imageUri',
    onImageUpload: async (file: FileObject) => {
      const result = await ImageUploadService.uploadImage(file);
      if (result.success && result.photoId) {
        return { id: result.photoId };
      }
      throw new Error(result.error || 'Error desconocido al subir imagen');
    },
    determineFinalPhotoId: ImageUploadService.determinePhotoId,
    imagePickerSize: 150,
    placeholderIcon: 'folder-open-outline',
    placeholderText: 'Imagen de subcategoría',
  };

  const renderSubcategoryActions = (item: SubCategory) => (
    <IconButton
      icon="chevron-right"
      size={28}
      onPress={() =>
        navigation.navigate('Products', {
          subcategoryId: item.id,
          subCategoryName: item.name,
        })
      }
      style={{ margin: 0 }}
    />
  );

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!listError,
    data: subcategoriesData?.data,
    emptyConfig: {
      title: 'No hay subcategorías',
      message: `No hay subcategorías registradas para ${categoryName}. Presiona el botón + para crear la primera.`,
      icon: 'folder-outline',
    },
    errorConfig: {
      title: 'Error al cargar subcategorías',
      message: 'No se pudieron cargar las subcategorías. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchList,
    },
  });

  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };

  return (
    <View style={styles.container}>
      <GenericList<SubCategory>
        items={subcategoriesData?.data ?? []}
        enableSort={true}
        enableSearch={true}
        searchPlaceholder="Buscar subcategorías..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoadingList}
        contentContainerStyle={styles.listContentContainer}
        renderItemActions={renderSubcategoryActions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isDetailModalVisible || isFormModalVisible}
        showImagePlaceholder={true}
        placeholderIcon="folder-open-outline"
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        <GenericDetailModal<SubCategory>
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          item={selectedItem}
          titleField="name"
          imageField="photo"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={detailFieldsToDisplay}
          onEdit={() => {
            if (selectedItem) {
              handleOpenEditModal(selectedItem);
            }
          }}
          deleteConfirmation={deleteConfirmation}
          isDeleting={isDeleting}
          showImage={true}
        />

        <GenericFormModal<
          SubCategoryFormInputs | UpdateSubCategoryFormInputs,
          SubCategory
        >
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSubmit={handleFormSubmit}
          formSchema={
            editingItem
              ? updateSubCategoryDtoSchema
              : createSubCategoryDtoSchema
          }
          formFields={formFields}
          imagePickerConfig={imagePickerConfig}
          initialValues={formInitialValues}
          editingItem={editingItem}
          isSubmitting={createMutation.isPending || updateMutation.isPending}
          modalTitle={(editing) =>
            editing ? 'Editar Subcategoría' : 'Crear Subcategoría'
          }
        />
      </Portal>
    </View>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContentContainer: {
      paddingBottom: 80,
    },
  });

export default SubcategoriesScreen;

================
File: app/src/modules/orders/components/OrderDetailModal.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  IconButton,
  Divider,
  Card,
  Chip,
  Surface,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { OrderStatusEnum } from '../types/orders.types';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

interface OrderDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId: string | null;
  orderNumber?: number;
  orderData?: any; // Datos de la orden pasados como prop
}

const getStatusColor = (status: string, theme: any) => {
  switch (status) {
    case OrderStatusEnum.PENDING:
      return '#FFA000';
    case OrderStatusEnum.IN_PROGRESS:
      return theme.colors.primary;
    case OrderStatusEnum.IN_PREPARATION:
      return '#FF6B35';
    case OrderStatusEnum.READY:
      return '#4CAF50';
    case OrderStatusEnum.DELIVERED:
      return theme.colors.tertiary;
    case OrderStatusEnum.COMPLETED:
      return '#9E9E9E';
    case OrderStatusEnum.CANCELLED:
      return theme.colors.error;
    default:
      return theme.colors.onSurfaceVariant;
  }
};

const getStatusLabel = (status: string) => {
  const statusMap: Record<string, string> = {
    [OrderStatusEnum.PENDING]: 'Pendiente',
    [OrderStatusEnum.IN_PROGRESS]: 'En Progreso',
    [OrderStatusEnum.IN_PREPARATION]: 'En Preparación',
    [OrderStatusEnum.READY]: 'Lista',
    [OrderStatusEnum.DELIVERED]: 'Entregada',
    [OrderStatusEnum.COMPLETED]: 'Completada',
    [OrderStatusEnum.CANCELLED]: 'Cancelada',
  };
  return statusMap[status] || status;
};

const getPreparationStatusLabel = (status: string) => {
  const statusMap: Record<string, string> = {
    PENDING: 'Pendiente',
    IN_PROGRESS: 'En Preparación',
    READY: 'Listo',
    DELIVERED: 'Entregado',
    CANCELLED: 'Cancelado',
  };
  return statusMap[status] || status;
};

const getPreparationStatusColor = (status: string, theme: any) => {
  switch (status) {
    case 'PENDING':
      return theme.colors.error;
    case 'IN_PROGRESS':
      return '#FFA000';
    case 'READY':
      return '#4CAF50';
    case 'DELIVERED':
      return theme.colors.tertiary;
    case 'CANCELLED':
      return theme.colors.onSurfaceDisabled;
    default:
      return theme.colors.onSurfaceVariant;
  }
};

// Componente interno para mostrar el contenido de detalles
export const OrderDetailContent: React.FC<{
  orderId: string | null;
  orderNumber?: number;
  orderData?: any; // Datos de la orden pasados como prop
}> = ({ orderId: _orderId, orderNumber: _orderNumber, orderData }) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  return (
    <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
      {!orderData ? (
        <View style={styles.errorContainer}>
          <Icon
            name="alert-circle-outline"
            size={48}
            color={theme.colors.error}
          />
          <Text style={styles.errorText}>
            No hay datos de la orden disponibles
          </Text>
        </View>
      ) : (
        <>
          {/* Información General - Simplificada */}
          <View style={styles.infoHeader}>
            <View style={styles.infoHeaderRow}>
              <Text style={styles.infoHeaderLabel}>Hora de creación:</Text>
              <Text style={styles.infoHeaderValue}>
                {format(new Date(orderData.createdAt), 'HH:mm', { locale: es })}
              </Text>
            </View>
          </View>

          {/* Items de la Orden */}
          <Card style={styles.itemsCard}>
            <Card.Content style={styles.cardContentCompact}>
              <Text style={styles.sectionTitle}>
                Artículos ({orderData.orderItems?.length || 0})
              </Text>

              {orderData.orderItems?.map((item: any, index: number) => (
                <View key={item.id || index} style={styles.itemRow}>
                  <View style={styles.itemCompactRow}>
                    <View style={styles.itemMainInfo}>
                      <View style={styles.itemTitleRow}>
                        <Text style={styles.itemName}>
                          {item.product?.name || 'Producto desconocido'}
                          {item.productVariant &&
                            ` - ${item.productVariant.name}`}
                        </Text>
                        <Chip
                          mode="flat"
                          compact
                          style={[
                            styles.preparationChip,
                            {
                              backgroundColor:
                                getPreparationStatusColor(
                                  item.preparationStatus,
                                  theme,
                                ) + '20',
                            },
                          ]}
                          textStyle={[
                            styles.preparationChipText,
                            {
                              color: getPreparationStatusColor(
                                item.preparationStatus,
                                theme,
                              ),
                            },
                          ]}
                        >
                          {getPreparationStatusLabel(item.preparationStatus)}
                        </Chip>
                      </View>
                      {item.preparationNotes && (
                        <Text style={styles.itemNotes}>
                          📝 {item.preparationNotes}
                        </Text>
                      )}
                    </View>
                    {item.preparedAt && (
                      <Text style={styles.preparedTime}>
                        {format(new Date(item.preparedAt), 'HH:mm')}
                      </Text>
                    )}
                  </View>
                  {index < orderData.orderItems.length - 1 && (
                    <Divider style={styles.itemDivider} />
                  )}
                </View>
              ))}
            </Card.Content>
          </Card>
        </>
      )}
    </ScrollView>
  );
};

export const OrderDetailModal: React.FC<OrderDetailModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderNumber,
  orderData,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  if (!visible) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.surface} elevation={2}>
          {/* Header */}
          <View style={styles.header}>
            <View style={styles.headerContent}>
              <Text style={styles.title}>
                {orderNumber ? `Orden #${orderNumber}` : 'Detalles de la Orden'}
              </Text>
              {orderData && (
                <Chip
                  mode="flat"
                  style={[
                    styles.statusChip,
                    {
                      backgroundColor: getStatusColor(
                        orderData.orderStatus,
                        theme,
                      ),
                    },
                  ]}
                  textStyle={styles.statusChipText}
                >
                  {getStatusLabel(orderData.orderStatus)}
                </Chip>
              )}
            </View>
            <IconButton
              icon="close-circle"
              size={32}
              onPress={onDismiss}
              style={styles.closeButton}
              iconColor={theme.colors.error}
            />
          </View>

          <Divider />

          {/* Content */}
          <OrderDetailContent
            orderId={orderId}
            orderNumber={orderNumber}
            orderData={order}
          />
        </Surface>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: any) =>
  StyleSheet.create({
    modalContainer: {
      padding: 12,
      maxWidth: 600,
      width: '95%',
      alignSelf: 'center',
      maxHeight: '92%',
    },
    surface: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 12,
      paddingVertical: 8,
      minHeight: 56,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: 12,
      marginRight: 8,
    },
    title: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    statusChip: {
      minHeight: 28,
      height: 'auto',
      paddingVertical: 4,
    },
    statusChipText: {
      fontSize: 13,
      fontWeight: '600',
      color: 'white',
      lineHeight: 18,
      includeFontPadding: false,
      textAlignVertical: 'center',
    },
    closeButton: {
      margin: -4,
      backgroundColor: theme.colors.errorContainer,
      borderRadius: 20,
    },
    content: {
      maxHeight: 600,
    },
    loadingContainer: {
      padding: 40,
      alignItems: 'center',
    },
    loadingText: {
      marginTop: 16,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      padding: 40,
      alignItems: 'center',
    },
    errorText: {
      marginTop: 16,
      color: theme.colors.error,
    },
    infoHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingHorizontal: 12,
      paddingVertical: 8,
      backgroundColor: theme.colors.surfaceVariant,
      marginBottom: 4,
    },
    infoHeaderRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    infoHeaderLabel: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginRight: 8,
    },
    infoHeaderValue: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    infoCard: {
      margin: 8,
      marginBottom: 4,
    },
    itemsCard: {
      marginHorizontal: 8,
      marginTop: 4,
      marginBottom: 8,
      flex: 1,
    },
    itemRow: {
      paddingVertical: 3,
    },
    itemCompactRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      gap: 8,
    },
    itemMainInfo: {
      flex: 1,
    },
    itemTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      flexWrap: 'nowrap',
    },
    itemStatusInfo: {
      alignItems: 'flex-end',
      gap: 2,
    },
    itemContent: {
      flex: 1,
    },
    itemHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    itemFooter: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginTop: 8,
    },
    itemDivider: {
      marginTop: 2,
      marginBottom: 1,
      backgroundColor: theme.colors.outlineVariant,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: 12,
    },
    itemName: {
      fontWeight: '600',
      fontSize: 13,
      color: theme.colors.onSurface,
      flex: 1,
      flexShrink: 1,
    },
    itemVariant: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    itemNotes: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: 0,
    },
    preparationChip: {
      minHeight: 26,
      height: 'auto',
      paddingHorizontal: 10,
      paddingVertical: 4,
    },
    preparationChipText: {
      fontSize: 12,
      fontWeight: '600',
      lineHeight: 16,
      includeFontPadding: false,
      textAlignVertical: 'center',
    },
    preparedTime: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '600',
      minWidth: 40,
      textAlign: 'right',
      alignSelf: 'center',
      lineHeight: 16,
    },
    itemTimesContainer: {
      flex: 1,
      alignItems: 'flex-end',
    },
    itemCreatedTime: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
    },
    preparedByText: {
      fontSize: 11,
      color: theme.colors.primary,
      fontWeight: '500',
      marginTop: 2,
    },
    notPrepared: {
      fontSize: 12,
      color: theme.colors.onSurfaceDisabled,
    },
    cardContentCompact: {
      paddingVertical: 6,
      paddingHorizontal: 10,
    },
  });

export default OrderDetailModal;

================
File: app/src/modules/orders/components/PaymentModal.tsx
================
import React, { useState, useEffect, useMemo, useRef } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Keyboard,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  RadioButton,
  TextInput,
  HelperText,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
  Surface,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  PaymentMethodEnum,
  PaymentStatusEnum,
  type PaymentMethod,
} from '../types/payment.types';
import {
  useGetPaymentsByOrderIdQuery,
  useCreatePaymentMutation,
  useUpdatePaymentMutation as _useUpdatePaymentMutation,
  useDeletePaymentMutation,
} from '../hooks/usePaymentQueries';
import { useCompleteOrderMutation } from '../hooks/useOrdersQueries';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import ChangeCalculatorModal from './ChangeCalculatorModal';
import { prepaymentService } from '@/modules/payments/services/prepaymentService';

interface PaymentModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId?: string; // Opcional para modo pre-pago
  orderTotal: number;
  orderNumber?: number;
  orderStatus?: string; // Estado de la orden
  onOrderCompleted?: () => void; // Callback cuando se completa la orden
  mode?: 'payment' | 'prepayment'; // Modo del modal
  onPrepaymentCreated?: (
    prepaymentId: string,
    amount: number,
    method: PaymentMethod,
  ) => void; // Callback para pre-pago
  existingPrepaymentId?: string; // ID del pre-pago existente para edición
  onPrepaymentDeleted?: () => void; // Callback para eliminar pre-pago
}

const PAYMENT_METHOD_LABELS: Record<PaymentMethod, string> = {
  CASH: '💵 Efectivo',
  CARD: '💳 Tarjeta',
  TRANSFER: '📱 Transferencia',
};

const PAYMENT_METHOD_ICONS: Record<PaymentMethod, string> = {
  CASH: 'cash',
  CARD: 'credit-card',
  TRANSFER: 'bank-transfer',
};

// Métodos de pago deshabilitados temporalmente
const DISABLED_METHODS: PaymentMethod[] = ['CARD', 'TRANSFER'];

// Helper para formatear el estado de la orden
const formatOrderStatus = (status: string): string => {
  switch (status) {
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En Progreso';
    case 'IN_PREPARATION':
      return 'En Preparación';
    case 'READY':
      return 'Lista';
    case 'DELIVERED':
      return 'Entregada';
    case 'COMPLETED':
      return 'Completada';
    case 'CANCELLED':
      return 'Cancelada';
    default:
      return status;
  }
};

export const PaymentModal: React.FC<PaymentModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderTotal,
  orderNumber,
  orderStatus,
  onOrderCompleted,
  mode = 'payment',
  onPrepaymentCreated,
  existingPrepaymentId,
  onPrepaymentDeleted,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const scrollViewRef = useRef<ScrollView>(null);
  const amountInputRef = useRef<View>(null);

  // Estado del formulario
  const [selectedMethod, setSelectedMethod] = useState<PaymentMethod>(
    PaymentMethodEnum.CASH,
  );
  const [amount, setAmount] = useState('');
  const [showChangeCalculator, setShowChangeCalculator] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [paymentToDelete, setPaymentToDelete] = useState<string | null>(null);
  const [keyboardVisible, setKeyboardVisible] = useState(false);
  const [showFinalizeConfirm, setShowFinalizeConfirm] = useState(false);
  const [isCreatingPrepayment, setIsCreatingPrepayment] = useState(false);
  const [showDeletePrepaymentConfirm, setShowDeletePrepaymentConfirm] =
    useState(false);

  // Queries y mutations (solo para modo payment)
  const { data: payments = [], isLoading: isLoadingPayments } =
    useGetPaymentsByOrderIdQuery(orderId || '', {
      enabled: mode === 'payment' && !!orderId,
    });
  const createPaymentMutation = useCreatePaymentMutation();
  // const updatePaymentMutation = useUpdatePaymentMutation(); // No se usa actualmente
  const deletePaymentMutation = useDeletePaymentMutation();
  const completeOrderMutation = useCompleteOrderMutation();

  // Calcular totales
  const totalPaid = useMemo(() => {
    if (mode === 'prepayment') {
      return 0; // En modo pre-pago, no hay pagos previos
    }
    return (payments || [])
      .filter((p) => p.paymentStatus === PaymentStatusEnum.COMPLETED)
      .reduce((sum, payment) => sum + (Number(payment.amount) || 0), 0);
  }, [payments, mode]);

  const pendingAmount = orderTotal - totalPaid;
  const isFullyPaid = pendingAmount <= 0;

  // Resetear formulario cuando se abre el modal
  useEffect(() => {
    if (visible) {
      if (mode === 'prepayment') {
        setAmount(orderTotal.toFixed(2));
      } else {
        setAmount(pendingAmount > 0 ? pendingAmount.toFixed(2) : '');
      }
      setShowChangeCalculator(false);
      setSelectedMethod(PaymentMethodEnum.CASH);
    }
  }, [visible, pendingAmount, orderTotal, mode]);

  // Manejar el teclado
  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setKeyboardVisible(true);
        // Pequeño delay para asegurar que el layout esté actualizado
        setTimeout(() => {
          if (amountInputRef.current && scrollViewRef.current) {
            amountInputRef.current.measureLayout(
              scrollViewRef.current as any,
              (x, y) => {
                scrollViewRef.current?.scrollTo({ y: y - 50, animated: true });
              },
              () => {},
            );
          }
        }, 100);
      },
    );

    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardVisible(false);
      },
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const handleSubmit = async () => {
    const parsedAmount = parseFloat(amount);

    if (isNaN(parsedAmount) || parsedAmount <= 0) {
      return;
    }

    // Si es efectivo, mostrar calculadora de cambio
    if (selectedMethod === PaymentMethodEnum.CASH) {
      setShowChangeCalculator(true);
      return;
    }

    // Para otros métodos de pago, procesar directamente
    await processPayment();
  };

  const processPayment = async () => {
    const parsedAmount = parseFloat(amount);

    try {
      if (mode === 'prepayment') {
        // Crear pre-pago
        setIsCreatingPrepayment(true);
        const prepayment = await prepaymentService.createPrepayment({
          paymentMethod: selectedMethod,
          amount: parsedAmount,
        });

        // Notificar al componente padre
        onPrepaymentCreated?.(prepayment.id, parsedAmount, selectedMethod);

        // Cerrar el modal
        onDismiss();
      } else {
        // Crear pago normal
        await createPaymentMutation.mutateAsync({
          orderId: orderId!,
          paymentMethod: selectedMethod,
          amount: parsedAmount,
        });

        // Resetear formulario
        setAmount('');
        setShowChangeCalculator(false);

        // Si ya está totalmente pagado, cerrar el modal
        if (pendingAmount - parsedAmount <= 0) {
          onDismiss();
        }
      }
    } catch (error) {
      // Error ya manejado por el mutation hook
    } finally {
      setIsCreatingPrepayment(false);
    }
  };

  const handleDeletePayment = async () => {
    if (!paymentToDelete) return;

    try {
      await deletePaymentMutation.mutateAsync(paymentToDelete);
      setShowDeleteConfirm(false);
      setPaymentToDelete(null);
    } catch (error) {}
  };

  const handleFinalizeOrder = async () => {
    try {
      await completeOrderMutation.mutateAsync(orderId);
      setShowFinalizeConfirm(false);

      // Llamar al callback si existe
      if (onOrderCompleted) {
        onOrderCompleted();
      } else {
        // Si no hay callback, solo cerrar el modal
        onDismiss();
      }
    } catch (error) {}
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case PaymentStatusEnum.COMPLETED:
        return '#4CAF50';
      case PaymentStatusEnum.PENDING:
        return theme.colors.primary;
      case PaymentStatusEnum.CANCELLED:
        return theme.colors.error;
      case PaymentStatusEnum.FAILED:
        return theme.colors.error;
      case PaymentStatusEnum.REFUNDED:
        return '#FF9800';
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getStatusText = (status: string) => {
    switch (status) {
      case PaymentStatusEnum.COMPLETED:
        return 'Completado';
      case PaymentStatusEnum.PENDING:
        return 'Pendiente';
      case PaymentStatusEnum.CANCELLED:
        return 'Cancelado';
      case PaymentStatusEnum.FAILED:
        return 'Fallido';
      case PaymentStatusEnum.REFUNDED:
        return 'Reembolsado';
      default:
        return status;
    }
  };

  const handleDeletePrepayment = async () => {
    if (!existingPrepaymentId) return;

    try {
      setIsCreatingPrepayment(true);
      await prepaymentService.deletePrepayment(existingPrepaymentId);
      onPrepaymentDeleted?.();
      setShowDeletePrepaymentConfirm(false);
      onDismiss();
    } catch (error) {
      // Error manejado en el servicio
    } finally {
      setIsCreatingPrepayment(false);
    }
  };

  return (
    <Portal>
      <Modal
        visible={visible && !showChangeCalculator}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <View style={styles.modalWrapper}>
          <Surface style={styles.modalContent} elevation={3}>
            {/* Header */}
            <View style={styles.header}>
              <View style={styles.headerTextContainer}>
                <Text style={styles.title}>
                  {mode === 'prepayment' ? 'Registrar Pago' : 'Pagos'}
                </Text>
                {orderNumber && mode !== 'prepayment' && (
                  <Text style={styles.orderNumber}>Orden #{orderNumber}</Text>
                )}
                {mode === 'prepayment' && (
                  <Text style={styles.orderNumber}>Pago anticipado</Text>
                )}
              </View>
              <IconButton icon="close" size={24} onPress={onDismiss} />
            </View>

            <Divider />

            <ScrollView
              ref={scrollViewRef}
              style={[
                styles.scrollView,
                keyboardVisible && styles.scrollViewWithKeyboard,
              ]}
              contentContainerStyle={styles.scrollViewContent}
              showsVerticalScrollIndicator={true}
              keyboardShouldPersistTaps="handled"
              bounces={true}
              nestedScrollEnabled={true}
            >
              {/* Resumen de pagos */}
              <View style={styles.summaryContainer}>
                <View style={styles.summaryItem}>
                  <Text style={styles.summaryLabel}>Total</Text>
                  <Text style={styles.summaryAmount}>
                    ${orderTotal.toFixed(2)}
                  </Text>
                </View>
                {mode !== 'prepayment' && (
                  <>
                    <View style={styles.summaryDividerVertical} />
                    <View style={styles.summaryItem}>
                      <Text style={styles.summaryLabel}>Pagado</Text>
                      <Text
                        style={[styles.summaryAmount, { color: '#4CAF50' }]}
                      >
                        ${totalPaid.toFixed(2)}
                      </Text>
                    </View>
                    <View style={styles.summaryDividerVertical} />
                    <View style={styles.summaryItem}>
                      <Text
                        style={[styles.summaryLabel, { fontWeight: 'bold' }]}
                      >
                        Pendiente
                      </Text>
                      <Text
                        style={[
                          styles.summaryAmount,
                          {
                            fontWeight: 'bold',
                            color:
                              pendingAmount > 0
                                ? theme.colors.error
                                : '#4CAF50',
                          },
                        ]}
                      >
                        ${pendingAmount.toFixed(2)}
                      </Text>
                    </View>
                  </>
                )}
              </View>

              {/* Lista de pagos existentes - Solo mostrar en modo payment */}
              {mode === 'payment' && (
                <>
                  {isLoadingPayments ? (
                    <ActivityIndicator style={styles.loader} />
                  ) : (payments || []).length > 0 ? (
                    <View style={styles.paymentsSection}>
                      <Text style={styles.sectionTitle}>Pagos registrados</Text>
                      {(payments || []).map((payment) => (
                        <View key={payment.id} style={styles.paymentItem}>
                          <View style={styles.paymentLeftInfo}>
                            <View style={styles.paymentMethodRow}>
                              <Text style={styles.paymentMethodCompact}>
                                {PAYMENT_METHOD_LABELS[payment.paymentMethod]}
                              </Text>
                            </View>
                            <Text style={styles.paymentDateCompact}>
                              {new Date(payment.createdAt).toLocaleTimeString(
                                'es-MX',
                                {
                                  hour: '2-digit',
                                  minute: '2-digit',
                                },
                              )}
                            </Text>
                          </View>

                          <View style={styles.paymentRightInfo}>
                            <Text style={styles.paymentAmountCompact}>
                              ${(Number(payment.amount) || 0).toFixed(2)}
                            </Text>

                            <Chip
                              mode="flat"
                              style={[
                                styles.statusChipCompact,
                                {
                                  backgroundColor: getStatusColor(
                                    payment.paymentStatus,
                                  ),
                                },
                              ]}
                              textStyle={styles.statusChipTextCompact}
                            >
                              {getStatusText(payment.paymentStatus)}
                            </Chip>

                            <IconButton
                              icon="delete"
                              size={20}
                              iconColor={theme.colors.error}
                              onPress={() => {
                                setPaymentToDelete(payment.id);
                                setShowDeleteConfirm(true);
                              }}
                              disabled={deletePaymentMutation.isPending}
                              style={styles.deleteIconButton}
                            />
                          </View>
                        </View>
                      ))}
                    </View>
                  ) : null}
                </>
              )}

              {/* Formulario para nuevo pago */}
              {(mode === 'prepayment' || !isFullyPaid) && (
                <View style={styles.formSection}>
                  <Text style={styles.sectionTitle}>
                    {mode === 'prepayment'
                      ? 'Configurar pago'
                      : 'Registrar nuevo pago'}
                  </Text>

                  {/* Métodos de pago */}
                  <View style={styles.methodsContainer}>
                    {Object.entries(PaymentMethodEnum).map(([key, value]) => {
                      const isDisabled = DISABLED_METHODS.includes(
                        value as PaymentMethod,
                      );
                      return (
                        <TouchableOpacity
                          key={key}
                          style={[
                            styles.methodCard,
                            selectedMethod === value &&
                              styles.methodCardSelected,
                            isDisabled && styles.methodCardDisabled,
                          ]}
                          onPress={() =>
                            !isDisabled && setSelectedMethod(value)
                          }
                          disabled={isDisabled}
                        >
                          <RadioButton
                            value={value}
                            status={
                              selectedMethod === value ? 'checked' : 'unchecked'
                            }
                            onPress={() =>
                              !isDisabled && setSelectedMethod(value)
                            }
                            disabled={isDisabled}
                          />
                          <View style={styles.methodLabelContainer}>
                            <Text
                              style={[
                                styles.methodText,
                                selectedMethod === value &&
                                  styles.methodTextSelected,
                                isDisabled && styles.methodTextDisabled,
                              ]}
                            >
                              {PAYMENT_METHOD_LABELS[value]}
                            </Text>
                            {isDisabled && (
                              <Text style={styles.comingSoonText}>
                                Próximamente
                              </Text>
                            )}
                          </View>
                        </TouchableOpacity>
                      );
                    })}
                  </View>

                  {/* Campo de monto */}
                  <View style={styles.amountContainer} ref={amountInputRef}>
                    <View style={styles.amountRow}>
                      <TextInput
                        label="Monto a pagar"
                        value={amount}
                        onChangeText={setAmount}
                        keyboardType="decimal-pad"
                        mode="outlined"
                        left={<TextInput.Affix text="$" />}
                        style={styles.amountInput}
                        error={
                          amount !== '' &&
                          (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)
                        }
                      />
                      <Button
                        mode="outlined"
                        onPress={() => setAmount(pendingAmount.toFixed(2))}
                        style={styles.totalPendingButton}
                        labelStyle={styles.totalPendingButtonLabel}
                        contentStyle={styles.totalPendingButtonContent}
                        compact
                      >
                        Total a pagar
                      </Button>
                    </View>
                    <HelperText
                      type="error"
                      visible={
                        amount !== '' &&
                        (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)
                      }
                    >
                      Ingrese un monto válido
                    </HelperText>
                  </View>
                </View>
              )}
            </ScrollView>

            {/* Botones de acción */}
            <View style={styles.footer}>
              <Button
                mode="outlined"
                onPress={onDismiss}
                style={[styles.footerButton, styles.cancelButton]}
                contentStyle={styles.footerButtonContent}
              >
                Cerrar
              </Button>
              {mode === 'prepayment' && existingPrepaymentId && (
                <Button
                  mode="outlined"
                  onPress={() => setShowDeletePrepaymentConfirm(true)}
                  style={[
                    styles.footerButton,
                    { borderColor: theme.colors.error },
                  ]}
                  contentStyle={styles.footerButtonContent}
                  textColor={theme.colors.error}
                  icon="delete"
                >
                  Eliminar
                </Button>
              )}
              {(mode === 'prepayment' || !isFullyPaid) && (
                <Button
                  mode="contained"
                  onPress={handleSubmit}
                  disabled={
                    !amount ||
                    isNaN(parseFloat(amount)) ||
                    parseFloat(amount) <= 0 ||
                    createPaymentMutation.isPending ||
                    isCreatingPrepayment
                  }
                  loading={
                    createPaymentMutation.isPending || isCreatingPrepayment
                  }
                  style={styles.footerButton}
                  contentStyle={styles.footerButtonContent}
                >
                  {mode === 'prepayment'
                    ? 'Registrar Pre-pago'
                    : 'Registrar Pago'}
                </Button>
              )}
              {isFullyPaid && mode !== 'prepayment' && (
                <Button
                  mode="contained"
                  onPress={() => setShowFinalizeConfirm(true)}
                  disabled={completeOrderMutation.isPending}
                  loading={completeOrderMutation.isPending}
                  style={[styles.footerButton, { backgroundColor: '#10B981' }]}
                  contentStyle={styles.footerButtonContent}
                  icon="check-circle"
                >
                  Finalizar Orden
                </Button>
              )}
            </View>
          </Surface>
        </View>
      </Modal>

      {/* Modal de confirmación para eliminar */}
      <ConfirmationModal
        visible={showDeleteConfirm}
        onDismiss={() => {
          setShowDeleteConfirm(false);
          setPaymentToDelete(null);
        }}
        onCancel={() => {
          setShowDeleteConfirm(false);
          setPaymentToDelete(null);
        }}
        onConfirm={handleDeletePayment}
        title="Eliminar pago"
        message="¿Está seguro de que desea eliminar este pago? Esta acción no se puede deshacer."
        confirmText="Sí, eliminar"
        cancelText="No, cancelar"
        confirmButtonColor={theme.colors.error}
      />

      {/* Modal de cálculo de cambio */}
      <ChangeCalculatorModal
        visible={showChangeCalculator}
        onDismiss={() => {
          setShowChangeCalculator(false);
        }}
        onConfirm={() => {
          setShowChangeCalculator(false);
          processPayment();
        }}
        amountToPay={parseFloat(amount) || 0}
      />

      {/* Modal de confirmación para finalizar orden */}
      <ConfirmationModal
        visible={showFinalizeConfirm}
        onDismiss={() => setShowFinalizeConfirm(false)}
        onCancel={() => setShowFinalizeConfirm(false)}
        onConfirm={handleFinalizeOrder}
        title="Finalizar orden"
        message={
          orderStatus && orderStatus !== 'READY'
            ? `⚠️ ADVERTENCIA: Esta orden está en estado "${formatOrderStatus(orderStatus)}" y no "Lista".\n\n¿Está seguro de que desea finalizar la orden #${orderNumber}? La orden se marcará como completada.`
            : `¿Está seguro de que desea finalizar la orden #${orderNumber}? La orden se marcará como completada.`
        }
        confirmText={
          orderStatus && orderStatus !== 'READY'
            ? 'Finalizar igual'
            : 'Sí, finalizar'
        }
        cancelText="No, cancelar"
        confirmButtonColor={
          orderStatus && orderStatus !== 'READY'
            ? theme.colors.error
            : '#10B981'
        }
      />

      {/* Modal de confirmación para eliminar pre-pago */}
      <ConfirmationModal
        visible={showDeletePrepaymentConfirm}
        onDismiss={() => setShowDeletePrepaymentConfirm(false)}
        onCancel={() => setShowDeletePrepaymentConfirm(false)}
        onConfirm={handleDeletePrepayment}
        title="Eliminar pago"
        message="¿Está seguro de que desea eliminar este pago registrado? Esta acción no se puede deshacer."
        confirmText="Sí, eliminar"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
      />
    </Portal>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m, theme.spacing.s),
    },
    modalWrapper: {
      width: '100%',
      maxWidth: responsive.isTablet ? 700 : 600,
      maxHeight: responsive.isTablet ? '90%' : '85%',
    },
    modalContent: {
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      width: '100%',
      maxHeight: '100%',
      minHeight: responsive.isTablet ? 550 : undefined,
      overflow: 'hidden',
      borderWidth: 2,
      borderColor: theme.colors.outline,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingVertical: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    headerTextContainer: {
      flex: 1,
    },
    title: {
      ...theme.fonts.headlineSmall,
      fontSize: responsive.fontSize(theme.fonts.headlineSmall.fontSize),
      color: theme.colors.onSurface,
      fontWeight: 'bold',
    },
    orderNumber: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      color: theme.colors.onSurfaceVariant,
    },
    scrollView: {
      maxHeight: responsive.isTablet ? 600 : 500,
    },
    scrollViewContent: {
      paddingBottom: responsive.spacing(theme.spacing.m, theme.spacing.s),
    },
    scrollViewWithKeyboard: {
      maxHeight: responsive.isTablet ? 350 : 250,
    },
    summaryContainer: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      alignItems: 'center',
      backgroundColor: theme.colors.primaryContainer,
      paddingVertical: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      marginTop: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      marginBottom: responsive.spacing(theme.spacing.m, theme.spacing.s),
      borderRadius: theme.roundness,
    },
    summaryItem: {
      flex: 1,
      alignItems: 'center',
    },
    summaryLabel: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onPrimaryContainer,
      opacity: 0.8,
      marginBottom: 2,
    },
    summaryAmount: {
      ...theme.fonts.titleSmall,
      fontSize: responsive.fontSize(theme.fonts.titleSmall.fontSize),
      fontWeight: 'bold',
      color: theme.colors.onPrimaryContainer,
    },
    summaryDividerVertical: {
      width: 1,
      height: '80%',
      backgroundColor: theme.colors.onPrimaryContainer,
      opacity: 0.2,
      marginHorizontal: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    loader: {
      marginVertical: responsive.spacing(theme.spacing.xl, theme.spacing.l),
    },
    paymentsSection: {
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    sectionTitle: {
      ...theme.fonts.titleSmall,
      fontSize: responsive.fontSize(theme.fonts.titleSmall.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      fontWeight: '600',
    },
    paymentItem: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
      padding: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      marginBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    paymentLeftInfo: {
      flex: 1,
    },
    paymentRightInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    paymentMethodRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    paymentMethodCompact: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    paymentAmountCompact: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      fontWeight: 'bold',
      color: theme.colors.primary,
      minWidth: responsive.isTablet ? 60 : 70,
      textAlign: 'right',
    },
    paymentDateCompact: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    statusChipCompact: {
      height: responsive.isTablet ? 24 : 26,
      minWidth: responsive.isTablet ? 80 : 90,
    },
    statusChipTextCompact: {
      fontSize: responsive.fontSize(11),
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 12 : 14,
    },
    deleteIconButton: {
      margin: 0,
      width: responsive.isTablet ? 32 : 36,
      height: responsive.isTablet ? 32 : 36,
    },
    formSection: {
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    methodsContainer: {
      marginBottom: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    methodCard: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      paddingHorizontal: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      marginBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      borderRadius: theme.roundness,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      backgroundColor: theme.colors.surface,
    },
    methodCardSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    methodText: {
      ...theme.fonts.bodyLarge,
      fontSize: responsive.fontSize(theme.fonts.bodyLarge.fontSize),
      color: theme.colors.onSurface,
      marginLeft: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    methodTextSelected: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '500',
    },
    methodCardDisabled: {
      opacity: 0.5,
      borderColor: theme.colors.outlineVariant,
    },
    methodLabelContainer: {
      flex: 1,
      marginLeft: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    methodTextDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    comingSoonText: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: 2,
    },
    amountContainer: {
      marginTop: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    amountRow: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      alignItems: 'flex-start',
    },
    amountInput: {
      backgroundColor: theme.colors.surface,
      flex: 1,
    },
    totalPendingButton: {
      marginTop: 4, // Alinear con el input que tiene un label
      height: responsive.isTablet ? 48 : 56, // Misma altura que el TextInput con outlined
      borderColor: theme.colors.primary,
      justifyContent: 'center',
    },
    totalPendingButtonContent: {
      height: '100%',
      paddingVertical: 0,
      paddingHorizontal: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    totalPendingButtonLabel: {
      fontSize: responsive.fontSize(13),
      lineHeight: responsive.isTablet ? 18 : 20,
      textAlignVertical: 'center',
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingVertical: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingTop: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      backgroundColor: theme.colors.surface,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    footerButton: {
      minWidth: responsive.isTablet ? 110 : 120,
    },
    footerButtonContent: {
      height: responsive.isTablet ? 36 : 40,
    },
    cancelButton: {
      borderColor: theme.colors.outline,
    },
  });

export default PaymentModal;

================
File: app/src/modules/orders/services/orderService.ts
================
import apiClient from '@/app/services/apiClient';
import { handleApiResponse } from '@/app/lib/apiHelpers';
import { API_PATHS } from '@/app/constants/apiPaths';
import { ApiError } from '@/app/lib/errors';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { FindAllOrdersDto, OrderOpenList } from '../types/orders.types';
import type { PaginatedResponse } from '../../../app/types/api.types';
import type { OrderDetailsForBackend } from '../components/OrderCartDetail';
import type { UpdateOrderPayload } from '../types/update-order.types';

const createOrder = async (
  orderData: OrderDetailsForBackend,
): Promise<Order> => {
  const response = await apiClient.post<Order>(API_PATHS.ORDERS, orderData);
  return handleApiResponse(response);
};

export const orderService = {
  createOrder,
  getOrders: async (
    filters: FindAllOrdersDto = {},
  ): Promise<PaginatedResponse<Order>> => {
    const queryParams: Record<string, any> = {};
    for (const [key, value] of Object.entries(filters)) {
      if (value !== undefined) {
        if (key !== 'page' && key !== 'limit') {
          queryParams[key] = value;
        }
      }
    }

    const page = filters.page ?? 1;
    const limit = filters.limit ?? 10;
    queryParams.page = page;
    queryParams.limit = limit;
    const response = await apiClient.get<[Order[], number]>(
      API_PATHS.ORDERS,
      queryParams,
    );

    if (
      !response.ok ||
      !response.data ||
      !Array.isArray(response.data) ||
      response.data.length !== 2
    ) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    const [data, total] = response.data;
    const totalPages = limit > 0 ? Math.ceil(total / limit) : 1;

    return {
      data,
      total,
      page,
      limit,
      totalPages,
    };
  },
  getOpenOrdersCurrentShift: async (): Promise<Order[]> => {
    const response = await apiClient.get<Order[]>(
      API_PATHS.ORDERS_OPEN_CURRENT_SHIFT,
    );
    return handleApiResponse(response);
  },
  getOpenOrdersList: async (): Promise<OrderOpenList[]> => {
    const response = await apiClient.get<OrderOpenList[]>(
      API_PATHS.ORDERS_OPEN_ORDERS_LIST,
    );
    return handleApiResponse(response);
  },
  printOrderTicket: async (
    orderId: string,
    printerId: string,
  ): Promise<void> => {
    const url = API_PATHS.PRINT_ORDER_TICKET;
    const body = { orderId, printerId };
    const response = await apiClient.post<any>(url, body);

    if (!response.ok) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
  },
  getOrderById: async (orderId: string): Promise<Order> => {
    const response = await apiClient.get<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
  updateOrder: async (
    orderId: string,
    payload: UpdateOrderPayload,
  ): Promise<Order> => {
    const response = await apiClient.patch<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
      payload,
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
  cancelOrder: async (orderId: string): Promise<Order> => {
    const payload: UpdateOrderPayload = {
      orderStatus: 'CANCELLED',
    };

    const response = await apiClient.patch<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
      payload,
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
};

================
File: app/src/modules/restaurantConfig/components/WebViewDeliveryCoverageMap.tsx
================
import React, { useRef, useEffect, useState } from 'react';
import { View, StyleSheet, Alert, useWindowDimensions } from 'react-native';
import { WebView } from 'react-native-webview';
import {
  Surface,
  IconButton,
  ActivityIndicator,
  Text,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { DeliveryCoveragePoint } from '../types/restaurantConfig.types';
import { useGoogleMapsConfig } from '@/hooks/useGoogleMapsConfig';

interface DeliveryCoverageMapProps {
  initialPolygon?: DeliveryCoveragePoint[] | null;
  isEditing: boolean;
  onChange?: (polygon: DeliveryCoveragePoint[]) => void;
  restaurantLocation?: {
    latitude: number;
    longitude: number;
  };
}

export const WebViewDeliveryCoverageMap: React.FC<DeliveryCoverageMapProps> = ({
  initialPolygon,
  isEditing,
  onChange,
  restaurantLocation,
}) => {
  const theme = useAppTheme();
  const { width, height } = useWindowDimensions();
  const webViewRef = useRef<WebView>(null);
  const { config: mapsConfig, loading: isLoadingApiKey } =
    useGoogleMapsConfig();
  const apiKey = mapsConfig?.apiKey;

  const styles = React.useMemo(
    () => createStyles(theme, width, height),
    [theme, width, height],
  );

  const [mapReady, setMapReady] = useState(false);
  const [isDrawing, setIsDrawing] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [currentPolygon, setCurrentPolygon] = useState<DeliveryCoveragePoint[]>(
    () => {
      return initialPolygon || [];
    },
  );

  // HTML del mapa con Google Maps API
  const mapHtml = apiKey
    ? `
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
    #map {
      height: 100%;
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    let map;
    let polygon;
    let markers = [];
    let isEditing = false;
    let polygonPath = [];

    function initMap() {
      // Inicializar el mapa
      const initialLocation = ${
        restaurantLocation
          ? `{ lat: ${restaurantLocation.latitude}, lng: ${restaurantLocation.longitude} }`
          : '{ lat: 20.5425, lng: -102.7935 }'
      };
      
      map = new google.maps.Map(document.getElementById('map'), {
        center: initialLocation,
        zoom: 14,
        disableDefaultUI: true,
        zoomControl: true,
        mapTypeControl: false,
        scaleControl: false,
        streetViewControl: false,
        rotateControl: false,
        fullscreenControl: false
      });

      // Escuchar mensajes desde React Native
      window.addEventListener('message', handleMessage);
      
      // Notificar que el mapa está listo
      sendMessage('mapReady', {});
    }

    function handleMessage(event) {
      try {
        const data = JSON.parse(event.data);
        
        switch(data.type) {
          case 'setPolygon':
            setPolygon(data.coordinates);
            break;
          case 'setEditMode':
            setEditMode(data.isEditing);
            break;
          case 'centerOnPolygon':
            centerOnPolygon();
            break;
          case 'clearPolygon':
            clearPolygon();
            break;
        }
      } catch (e) {
        // Error handling message
      }
    }

    function setPolygon(coordinates) {
      // Limpiar polígono anterior
      if (polygon) {
        polygon.setMap(null);
      }
      
      // Limpiar marcadores
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      
      // Convertir coordenadas
      polygonPath = coordinates.map(coord => ({
        lat: coord.lat || coord.latitude,
        lng: coord.lng || coord.longitude
      }));
      
      
      if (polygonPath.length >= 3) {
        // Crear polígono
        polygon = new google.maps.Polygon({
          paths: polygonPath,
          strokeColor: '#FF0000',
          strokeOpacity: 0.8,
          strokeWeight: 3,
          fillColor: '#FF0000',
          fillOpacity: 0.35,
          editable: false,
          draggable: false
        });
        
        polygon.setMap(map);
        
        // Centrar en el polígono
        setTimeout(() => {
          centerOnPolygon();
          // Notificar que el polígono se ha dibujado
          sendMessage('polygonSet', {});
        }, 100);
      }
    }

    function setEditMode(editing) {
      isEditing = editing;
      
      if (isEditing) {
        // Habilitar clicks en el mapa
        google.maps.event.clearListeners(map, 'click');
        map.addListener('click', function(event) {
          addPoint(event.latLng);
        });
        
        // Mostrar marcadores inmediatamente
        updateMarkers();
      } else {
        // Deshabilitar clicks
        google.maps.event.clearListeners(map, 'click');
        
        // Ocultar marcadores
        markers.forEach(marker => marker.setMap(null));
        markers = [];
      }
    }

    function addPoint(latLng) {
      if (!isEditing) return;
      
      polygonPath.push({
        lat: latLng.lat(),
        lng: latLng.lng()
      });
      
      updatePolygon();
      updateMarkers();
      
      // Enviar actualización a React Native
      sendMessage('polygonUpdated', {
        coordinates: polygonPath
      });
    }

    function updatePolygon() {
      if (polygon) {
        polygon.setPath(polygonPath);
      } else if (polygonPath.length >= 3) {
        polygon = new google.maps.Polygon({
          paths: polygonPath,
          strokeColor: '#FF0000',
          strokeOpacity: 0.8,
          strokeWeight: 3,
          fillColor: '#FF0000',
          fillOpacity: 0.35
        });
        polygon.setMap(map);
      }
    }

    function updateMarkers() {
      // Limpiar marcadores anteriores
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      
      if (!isEditing) return;
      
      // Crear nuevos marcadores
      polygonPath.forEach((point, index) => {
        const marker = new google.maps.Marker({
          position: point,
          map: map,
          draggable: true,
          label: {
            text: (index + 1).toString(),
            color: 'white',
            fontSize: '12px',
            fontWeight: 'bold'
          },
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 20,
            fillColor: '#2563eb',
            fillOpacity: 1,
            strokeColor: 'white',
            strokeWeight: 2
          }
        });
        
        // Permitir arrastrar
        marker.addListener('dragend', function() {
          polygonPath[index] = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          updatePolygon();
          sendMessage('polygonUpdated', {
            coordinates: polygonPath
          });
        });
        
        // Click para eliminar
        marker.addListener('click', function() {
          polygonPath.splice(index, 1);
          updatePolygon();
          updateMarkers();
          sendMessage('polygonUpdated', {
            coordinates: polygonPath
          });
        });
        
        markers.push(marker);
      });
    }

    function centerOnPolygon() {
      if (polygonPath.length > 0) {
        const bounds = new google.maps.LatLngBounds();
        polygonPath.forEach(point => {
          bounds.extend(point);
        });
        map.fitBounds(bounds);
        
        // Ajustar el zoom si es necesario
        const listener = google.maps.event.addListener(map, 'idle', function() { 
          if (map.getZoom() > 18) {
            map.setZoom(18);
          }
          google.maps.event.removeListener(listener);
        });
      }
    }

    function clearPolygon() {
      polygonPath = [];
      if (polygon) {
        polygon.setMap(null);
        polygon = null;
      }
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      
      sendMessage('polygonUpdated', {
        coordinates: []
      });
    }

    function sendMessage(type, data) {
      try {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: type,
            ...data
          }));
        }
      } catch (e) {
        // Error sending message
      }
    }
  </script>
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap">
  </script>
</body>
</html>
  `
    : '';

  // Manejar mensajes del WebView
  const handleWebViewMessage = (event: any) => {
    try {
      const data = JSON.parse(event.nativeEvent.data);

      switch (data.type) {
        case 'mapReady':
          setMapReady(true);

          // Enviar polígono inicial si existe
          if (initialPolygon && initialPolygon.length > 0) {
            setTimeout(() => {
              sendMessageToWebView('setPolygon', {
                coordinates: initialPolygon,
              });
            }, 1000);
          } else {
            // Si no hay polígono inicial, ocultar el loading
            setIsLoading(false);
          }
          break;
        case 'polygonSet':
          // El polígono se ha dibujado en el mapa
          setIsLoading(false);
          break;
        case 'polygonUpdated': {
          const newPolygon = data.coordinates;
          setCurrentPolygon(newPolygon);
          if (onChange) {
            onChange(newPolygon);
          }
          break;
        }
      }
    } catch (e) {}
  };

  // Enviar mensaje al WebView
  const sendMessageToWebView = (type: string, data: any) => {
    if (webViewRef.current) {
      const message = JSON.stringify({ type, ...data });
      webViewRef.current.postMessage(message);
    }
  };

  // Actualizar el modo de edición cuando cambie
  useEffect(() => {
    if (mapReady) {
      sendMessageToWebView('setEditMode', {
        isEditing: isEditing && isDrawing,
      });
    }
  }, [isEditing, isDrawing, mapReady]);

  // Actualizar el polígono cuando cambie desde fuera
  useEffect(() => {
    if (mapReady && initialPolygon && initialPolygon.length > 0) {
      setCurrentPolygon(initialPolygon);
      sendMessageToWebView('setPolygon', { coordinates: initialPolygon });
    }
  }, [initialPolygon, mapReady]);

  // Resetear estados cuando el componente se monta
  useEffect(() => {
    setIsLoading(true);
    setMapReady(false);
  }, []);

  const toggleDrawing = () => {
    if (isDrawing && currentPolygon.length < 3) {
      Alert.alert(
        'Área incompleta',
        'Necesitas al menos 3 puntos para crear un área de cobertura.',
      );
      return;
    }
    const newDrawingState = !isDrawing;
    setIsDrawing(newDrawingState);

    // Enviar el estado de edición al mapa inmediatamente
    if (webViewRef.current) {
      const jsCode = `
        if (typeof setEditMode === 'function') {
          setEditMode(${newDrawingState});
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }
  };

  const clearPolygon = () => {
    sendMessageToWebView('clearPolygon', {});

    // También usar inyección directa
    if (webViewRef.current) {
      const jsCode = `
        if (typeof clearPolygon === 'function') {
          clearPolygon();
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }

    setCurrentPolygon([]);
    setIsDrawing(false);
    if (onChange) {
      onChange([]);
    }
  };

  const centerOnPolygon = () => {
    sendMessageToWebView('centerOnPolygon', {});

    // También usar inyección directa
    if (webViewRef.current) {
      const jsCode = `
        if (typeof centerOnPolygon === 'function') {
          centerOnPolygon();
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }
  };

  // Si estamos cargando la API key o no tenemos HTML, mostrar loading
  if (isLoadingApiKey || !mapHtml) {
    return (
      <View style={[styles.container, styles.loadingContainer]}>
        <Surface style={styles.loadingCard} elevation={3}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>
            Cargando configuración del mapa...
          </Text>
        </Surface>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <WebView
        ref={webViewRef}
        source={{ html: mapHtml }}
        style={styles.map}
        onMessage={handleWebViewMessage}
        onLoad={() => {
          // Inyectar código JavaScript después de cargar
          if (
            webViewRef.current &&
            initialPolygon &&
            initialPolygon.length > 0
          ) {
            const jsCode = `
              setTimeout(() => {
                if (typeof setPolygon === 'function') {
                  setPolygon(${JSON.stringify(initialPolygon)});
                }
              }, 1500);
              true;
            `;
            webViewRef.current.injectJavaScript(jsCode);
          }
        }}
        onError={(_error) => {}}
        javaScriptEnabled={true}
        domStorageEnabled={true}
        startInLoadingState={true}
        mixedContentMode="compatibility"
        allowsInlineMediaPlayback={true}
        originWhitelist={['*']}
      />

      {/* Indicador de carga */}
      {isLoading && (
        <View style={styles.loadingContainer}>
          <Surface style={styles.loadingCard} elevation={3}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando mapa...</Text>
          </Surface>
        </View>
      )}

      {/* Controles flotantes */}
      {isEditing && (
        <View style={styles.controls}>
          <Surface style={styles.controlsCard} elevation={2}>
            <View style={styles.controlsRow}>
              <IconButton
                icon={isDrawing ? 'check' : 'draw'}
                mode="contained"
                containerColor={
                  isDrawing ? theme.colors.primary : theme.colors.secondary
                }
                iconColor={
                  isDrawing ? theme.colors.onPrimary : theme.colors.onSecondary
                }
                size={24}
                onPress={toggleDrawing}
              />
              <IconButton
                icon="crosshairs-gps"
                mode="contained"
                containerColor={theme.colors.tertiaryContainer}
                iconColor={theme.colors.onTertiaryContainer}
                size={24}
                onPress={centerOnPolygon}
                disabled={currentPolygon.length === 0}
              />
              <IconButton
                icon="delete"
                mode="contained"
                containerColor={theme.colors.errorContainer}
                iconColor={theme.colors.onErrorContainer}
                size={24}
                onPress={clearPolygon}
                disabled={currentPolygon.length === 0}
              />
            </View>
          </Surface>
        </View>
      )}

      {/* Botón de centrar cuando no se está editando */}
      {!isEditing && currentPolygon.length > 0 && (
        <View style={styles.centerButtonContainer}>
          <IconButton
            icon="crosshairs-gps"
            mode="contained"
            containerColor={theme.colors.primaryContainer}
            iconColor={theme.colors.onPrimaryContainer}
            size={24}
            onPress={centerOnPolygon}
            style={styles.floatingCenterButton}
          />
        </View>
      )}
    </View>
  );
};

const createStyles = (theme: AppTheme, width: number, height: number) =>
  StyleSheet.create({
    container: {
      height: Math.min(height * 0.6, 500),
      width: '100%',
      borderRadius: 16,
      overflow: 'hidden',
      backgroundColor: theme.colors.surfaceVariant,
    },
    map: {
      ...StyleSheet.absoluteFillObject,
    },
    controls: {
      position: 'absolute',
      top: theme.spacing.m,
      right: theme.spacing.m,
    },
    controlsCard: {
      borderRadius: 12,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    controlsRow: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
    },
    statusText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
    },
    centerButtonContainer: {
      position: 'absolute',
      bottom: theme.spacing.m,
      right: theme.spacing.m,
    },
    floatingCenterButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    loadingContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
    },
    loadingCard: {
      padding: theme.spacing.xl,
      borderRadius: 16,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
    },
    loadingText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
  });

export default WebViewDeliveryCoverageMap;

================
File: app/src/modules/shiftAudit/screens/ShiftsListScreen.tsx
================
import React, { useState, useMemo } from 'react';
import {
  View,
  StyleSheet,
  RefreshControl,
  TouchableOpacity,
  Modal,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import {
  Text,
  Chip,
  Card,
  Divider,
  Button,
  Menu,
  Avatar,
  ActivityIndicator,
  IconButton,
  Surface,
} from 'react-native-paper';
import { FlashList } from '@shopify/flash-list';
import { format, parseISO, subDays, startOfDay, endOfDay } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useShifts } from '../hooks/useShifts';
import { formatCurrency } from '@/app/lib/formatters';
import type { Shift } from '../types';
import { ShiftOrdersModal, ShiftSalesSummaryView } from '../components';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import DateTimePicker from '@react-native-community/datetimepicker';

export function ShiftsListScreen() {
  const theme = useAppTheme();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [dateFilter, setDateFilter] = useState<
    'today' | 'yesterday' | 'last7' | 'custom'
  >('last7');
  const [showDateMenu, setShowDateMenu] = useState(false);
  const [showDateRangePicker, setShowDateRangePicker] = useState(false);
  const [customDateRange, setCustomDateRange] = useState<{
    start: Date;
    end: Date;
  }>({
    start: subDays(new Date(), 7),
    end: new Date(),
  });
  const [datePickerMode, setDatePickerMode] = useState<'start' | 'end'>(
    'start',
  );
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [selectedShiftId, setSelectedShiftId] = useState<string | null>(null);
  const [selectedShiftNumber, setSelectedShiftNumber] = useState<
    number | undefined
  >();
  const [showOrdersModal, setShowOrdersModal] = useState(false);
  const [showSalesSummaryView, setShowSalesSummaryView] = useState(false);

  const dateParams = useMemo(() => {
    const now = new Date();

    switch (dateFilter) {
      case 'today':
        return {
          startDate: format(startOfDay(now), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
      case 'yesterday': {
        const yesterday = subDays(now, 1);
        return {
          startDate: format(startOfDay(yesterday), 'yyyy-MM-dd'),
          endDate: format(endOfDay(yesterday), 'yyyy-MM-dd'),
        };
      }
      case 'last7':
        return {
          startDate: format(startOfDay(subDays(now, 7)), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
      case 'custom':
        return {
          startDate: format(startOfDay(customDateRange.start), 'yyyy-MM-dd'),
          endDate: format(endOfDay(customDateRange.end), 'yyyy-MM-dd'),
        };
      default:
        return {
          startDate: format(startOfDay(subDays(now, 7)), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
    }
  }, [dateFilter, customDateRange]);

  const {
    data: shifts,
    isLoading,
    error,
    refetch,
    isRefetching,
  } = useShifts(dateParams);

  useRefreshModuleOnFocus('shifts');

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };

  const filteredShifts = useMemo(() => {
    if (!shifts || !Array.isArray(shifts)) {
      return [];
    }

    return shifts.filter((shift) => {
      if (!shift.openedAt) return false;

      try {
        const shiftDate = parseISO(shift.openedAt);
        const shiftDateOnly = format(shiftDate, 'yyyy-MM-dd');

        switch (dateFilter) {
          case 'today':
            return shiftDateOnly === format(new Date(), 'yyyy-MM-dd');
          case 'yesterday':
            return (
              shiftDateOnly === format(subDays(new Date(), 1), 'yyyy-MM-dd')
            );
          case 'last7': {
            const sevenDaysAgo = format(subDays(new Date(), 7), 'yyyy-MM-dd');
            const today = format(new Date(), 'yyyy-MM-dd');
            return shiftDateOnly >= sevenDaysAgo && shiftDateOnly <= today;
          }
          case 'custom': {
            const customStart = format(customDateRange.start, 'yyyy-MM-dd');
            const customEnd = format(customDateRange.end, 'yyyy-MM-dd');
            return shiftDateOnly >= customStart && shiftDateOnly <= customEnd;
          }
          default:
            return true;
        }
      } catch (e) {
        return false;
      }
    });
  }, [shifts, dateFilter, customDateRange]);

  const getDateFilterLabel = () => {
    switch (dateFilter) {
      case 'today':
        return 'Hoy';
      case 'yesterday':
        return 'Ayer';
      case 'last7':
        return 'Últimos 7 días';
      case 'custom':
        return `${format(customDateRange.start, 'dd/MM')} - ${format(customDateRange.end, 'dd/MM')}`;
      default:
        return 'Últimos 7 días';
    }
  };

  const handleDateChange = (event: any, selectedDate?: Date) => {
    setShowDatePicker(false);
    if (selectedDate) {
      if (datePickerMode === 'start') {
        setCustomDateRange({ ...customDateRange, start: selectedDate });
      } else {
        setCustomDateRange({ ...customDateRange, end: selectedDate });
      }
    }
  };

  const handleCustomDateRange = () => {
    setDateFilter('custom');
    setShowDateMenu(false);
    setShowDateRangePicker(true);
  };

  const handleViewOrders = (shift: Shift) => {
    setSelectedShiftId(String(shift.id));
    setSelectedShiftNumber(shift.globalShiftNumber || shift.shiftNumber);
    setShowOrdersModal(true);
  };

  const handleViewSalesSummary = (shift: Shift) => {
    setSelectedShiftId(String(shift.id));
    setSelectedShiftNumber(shift.globalShiftNumber || shift.shiftNumber);
    setShowSalesSummaryView(true);
  };

  const formatShiftDate = (dateString: string) => {
    try {
      const date = parseISO(dateString);
      return format(date, "d 'de' MMMM, yyyy", { locale: es });
    } catch {
      return dateString;
    }
  };

  const formatShiftTime = (dateString: string) => {
    try {
      const date = parseISO(dateString);
      return format(date, 'HH:mm', { locale: es });
    } catch {
      return dateString;
    }
  };

  const getShiftDuration = (openedAt: string, closedAt: string | null) => {
    if (!closedAt) return 'En curso';
    try {
      const start = parseISO(openedAt);
      const end = parseISO(closedAt);
      const diffInMinutes = Math.round(
        (end.getTime() - start.getTime()) / (1000 * 60),
      );
      const hours = Math.floor(diffInMinutes / 60);
      const minutes = diffInMinutes % 60;
      return `${hours}h ${minutes}m`;
    } catch {
      return 'N/A';
    }
  };

  const renderShiftItem = ({ item: shift }: { item: Shift }) => {
    const isOpen = shift.status === 'open';

    return (
      <Card
        style={[styles.shiftCard, isOpen && styles.openShiftCard]}
        mode="contained"
      >
        <Card.Content>
          <View style={styles.shiftHeader}>
            <View style={styles.shiftTitleRow}>
              <Text style={styles.shiftNumber}>
                Turno #{shift.globalShiftNumber || shift.shiftNumber || 'N/A'}
              </Text>
              <Chip
                mode="flat"
                icon={isOpen ? 'lock-open' : 'lock'}
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: isOpen
                      ? theme.colors.primaryContainer
                      : theme.colors.surfaceVariant,
                  },
                ]}
                textStyle={[
                  styles.statusChipText,
                  {
                    color: isOpen
                      ? theme.colors.onPrimaryContainer
                      : theme.colors.onSurfaceVariant,
                  },
                ]}
                compact
              >
                {isOpen ? 'Abierto' : 'Cerrado'}
              </Chip>
            </View>
            <Text style={styles.shiftDate}>
              {shift.openedAt
                ? formatShiftDate(shift.openedAt)
                : 'Fecha no disponible'}
            </Text>
          </View>

          <Divider style={styles.divider} />

          <View style={styles.shiftDetails}>
            {/* Sección de tiempo y estadísticas en una sola línea */}
            <View style={styles.timeSection}>
              <View style={{ flex: 1 }}>
                <Text style={styles.timeText}>
                  {shift.openedAt ? formatShiftTime(shift.openedAt) : 'N/A'} -{' '}
                  {shift.closedAt
                    ? formatShiftTime(shift.closedAt)
                    : 'En curso'}
                </Text>
                <Text style={styles.durationText}>
                  {shift.openedAt
                    ? getShiftDuration(shift.openedAt, shift.closedAt)
                    : 'N/A'}
                </Text>
              </View>
            </View>

            {/* Estadísticas más compactas */}
            <View style={styles.statsSection}>
              <Surface style={styles.statCard} elevation={0}>
                <Text style={styles.statLabel}>VENTAS</Text>
                <Text style={styles.statValue}>
                  {formatCurrency(shift.totalSales)}
                </Text>
              </Surface>

              <Surface style={styles.statCard} elevation={0}>
                <Text style={styles.statLabel}>ÓRDENES</Text>
                <Text style={styles.statValue}>{shift.totalOrders || 0}</Text>
              </Surface>
            </View>

            {/* Sección de efectivo más compacta */}
            <View style={styles.cashSection}>
              <View style={styles.cashRow}>
                <Text style={styles.cashLabel}>Inicial</Text>
                <Text style={styles.cashValue}>
                  {formatCurrency(shift.initialCash)}
                </Text>
              </View>
              {shift.finalCash !== null && (
                <>
                  <View style={styles.cashRow}>
                    <Text style={styles.cashLabel}>Final</Text>
                    <Text style={styles.cashValue}>
                      {formatCurrency(shift.finalCash)}
                    </Text>
                  </View>
                  <View style={styles.cashRow}>
                    <Text style={[styles.cashLabel, styles.differenceLabel]}>
                      Diferencia
                    </Text>
                    <Text
                      style={[
                        styles.cashValue,
                        styles.differenceValue,
                        {
                          color:
                            shift.finalCash - shift.initialCash >= 0
                              ? theme.colors.tertiary
                              : theme.colors.error,
                        },
                      ]}
                    >
                      {formatCurrency(shift.finalCash - shift.initialCash)}
                    </Text>
                  </View>
                </>
              )}
            </View>

            {/* Usuarios en una línea */}
            <View style={styles.userSection}>
              <Text style={styles.userText}>
                👤 {shift.openedBy?.firstName || 'N/A'}{' '}
                {shift.openedBy?.lastName || ''}
              </Text>
              {shift.closedBy && (
                <Text style={styles.userText}>
                  🔒 {shift.closedBy.firstName || 'N/A'}{' '}
                  {shift.closedBy.lastName || ''}
                </Text>
              )}
            </View>

            {/* Botones de acciones */}
            <View style={styles.actionButtonsContainer}>
              <Button
                mode="contained-tonal"
                onPress={() => handleViewOrders(shift)}
                icon="receipt"
                style={[styles.actionButton, styles.ordersButton]}
                labelStyle={styles.actionButtonLabel}
                contentStyle={styles.actionButtonContent}
                compact
              >
                Órdenes ({shift.totalOrders || 0})
              </Button>
              <Button
                mode="contained-tonal"
                onPress={() => handleViewSalesSummary(shift)}
                icon="chart-bar"
                style={[styles.actionButton, styles.summaryButton]}
                labelStyle={styles.actionButtonLabel}
                contentStyle={styles.actionButtonContent}
                compact
              >
                Resumen
              </Button>
            </View>
          </View>
        </Card.Content>
      </Card>
    );
  };

  const renderFilters = () => (
    <Surface style={styles.filterContainer} elevation={1}>
      <View style={styles.filterContent}>
        <Menu
          visible={showDateMenu}
          onDismiss={() => setShowDateMenu(false)}
          anchor={
            <TouchableOpacity
              style={styles.filterButton}
              onPress={() => setShowDateMenu(true)}
              activeOpacity={0.8}
            >
              <Avatar.Icon
                icon="calendar-range"
                size={32}
                style={styles.filterIcon}
                color={theme.colors.primary}
              />
              <View style={styles.filterTextContainer}>
                <Text style={styles.filterLabel}>Filtrar por fecha</Text>
                <Text style={styles.filterValue}>{getDateFilterLabel()}</Text>
              </View>
              <Avatar.Icon
                icon="chevron-down"
                size={24}
                style={styles.filterArrow}
                color={theme.colors.onSurfaceVariant}
              />
            </TouchableOpacity>
          }
          contentStyle={styles.menuContent}
        >
          <Menu.Item
            onPress={() => {
              setDateFilter('today');
              setShowDateMenu(false);
            }}
            title="Hoy"
            leadingIcon="calendar-today"
            style={dateFilter === 'today' && styles.selectedMenuItem}
          />
          <Menu.Item
            onPress={() => {
              setDateFilter('yesterday');
              setShowDateMenu(false);
            }}
            title="Ayer"
            leadingIcon="calendar-minus"
            style={dateFilter === 'yesterday' && styles.selectedMenuItem}
          />
          <Menu.Item
            onPress={() => {
              setDateFilter('last7');
              setShowDateMenu(false);
            }}
            title="Últimos 7 días"
            leadingIcon="calendar-week"
            style={dateFilter === 'last7' && styles.selectedMenuItem}
          />
          <Divider />
          <Menu.Item
            onPress={handleCustomDateRange}
            title="Rango personalizado"
            leadingIcon="calendar-range"
            style={dateFilter === 'custom' && styles.selectedMenuItem}
          />
        </Menu>
      </View>

      {/* Modal para selección de rango de fechas */}
      <Modal
        visible={showDateRangePicker}
        transparent
        animationType="fade"
        onRequestClose={() => setShowDateRangePicker(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            {/* Header del modal */}
            <View style={styles.modalHeader}>
              <Avatar.Icon
                icon="calendar-range"
                size={48}
                style={styles.modalIcon}
                color={theme.colors.primary}
              />
              <Text style={styles.modalTitle}>Seleccionar rango</Text>
              <IconButton
                icon="close"
                onPress={() => setShowDateRangePicker(false)}
                size={20}
                style={styles.modalCloseButton}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>

            {/* Selección de fechas */}
            <View style={styles.dateRangeContainer}>
              <TouchableOpacity
                style={styles.dateButton}
                onPress={() => {
                  setDatePickerMode('start');
                  setShowDatePicker(true);
                }}
                activeOpacity={0.8}
              >
                <View style={styles.dateButtonContent}>
                  <Avatar.Icon
                    icon="calendar-start"
                    size={36}
                    style={styles.dateButtonIcon}
                    color={theme.colors.primary}
                  />
                  <View style={styles.dateButtonTextContainer}>
                    <Text style={styles.dateButtonLabel}>DESDE</Text>
                    <Text style={styles.dateButtonValue}>
                      {format(customDateRange.start, 'd MMM yyyy', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>

              <View style={styles.dateArrowContainer}>
                <Avatar.Icon
                  icon="arrow-right"
                  size={20}
                  style={styles.dateArrow}
                  color={theme.colors.primary}
                />
              </View>

              <TouchableOpacity
                style={styles.dateButton}
                onPress={() => {
                  setDatePickerMode('end');
                  setShowDatePicker(true);
                }}
                activeOpacity={0.8}
              >
                <View style={styles.dateButtonContent}>
                  <Avatar.Icon
                    icon="calendar-end"
                    size={36}
                    style={styles.dateButtonIcon}
                    color={theme.colors.primary}
                  />
                  <View style={styles.dateButtonTextContainer}>
                    <Text style={styles.dateButtonLabel}>HASTA</Text>
                    <Text style={styles.dateButtonValue}>
                      {format(customDateRange.end, 'd MMM yyyy', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>
            </View>

            {/* Botones de acción */}
            <View style={styles.modalActions}>
              <Button
                mode="outlined"
                onPress={() => setShowDateRangePicker(false)}
                style={styles.modalButton}
                labelStyle={styles.modalButtonLabel}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={() => {
                  setDateFilter('custom');
                  setShowDateRangePicker(false);
                }}
                style={[styles.modalButton, styles.modalButtonPrimary]}
                labelStyle={styles.modalButtonLabel}
              >
                Aplicar filtro
              </Button>
            </View>
          </View>
        </View>
      </Modal>

      {showDatePicker && (
        <DateTimePicker
          value={
            datePickerMode === 'start'
              ? customDateRange.start
              : customDateRange.end
          }
          mode="date"
          display="default"
          onChange={handleDateChange}
          maximumDate={new Date()}
        />
      )}
    </Surface>
  );

  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Avatar.Icon
        icon="history"
        size={80}
        style={{ backgroundColor: theme.colors.surfaceVariant }}
        color={theme.colors.onSurfaceVariant}
      />
      <Text style={styles.emptyTitle}>No se encontraron turnos</Text>
      <Text style={styles.emptyMessage}>
        {dateFilter === 'custom'
          ? 'No hay turnos en el rango seleccionado'
          : 'Prueba seleccionando otro rango de fechas'}
      </Text>
    </View>
  );

  const renderError = () => (
    <View style={styles.errorContainer}>
      <Avatar.Icon
        icon="alert-circle-outline"
        size={80}
        style={{ backgroundColor: theme.colors.errorContainer }}
        color={theme.colors.error}
      />
      <Text style={styles.errorTitle}>Error al cargar turnos</Text>
      <Text style={styles.errorMessage}>
        {error?.message || 'No se pudieron cargar los turnos'}
      </Text>
      <Button mode="contained" onPress={refetch} style={styles.retryButton}>
        Reintentar
      </Button>
    </View>
  );

  const renderLoading = () => (
    <View style={styles.loadingContainer}>
      <ActivityIndicator size="large" />
      <Text style={styles.loadingText}>Cargando turnos...</Text>
    </View>
  );

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    filterContainer: {
      backgroundColor: theme.colors.surface,
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      elevation: 1,
    },
    filterContent: {
      padding: theme.spacing.s,
    },
    filterButton: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
    },
    filterIcon: {
      backgroundColor: theme.colors.primaryContainer,
      marginRight: theme.spacing.m,
    },
    filterTextContainer: {
      flex: 1,
    },
    filterLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    filterValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    filterArrow: {
      backgroundColor: 'transparent',
    },
    menuContent: {
      backgroundColor: theme.colors.surface,
      marginTop: 40,
      minWidth: 200,
    },
    selectedMenuItem: {
      backgroundColor: theme.colors.primaryContainer,
    },
    modalOverlay: {
      flex: 1,
      backgroundColor: 'rgba(0, 0, 0, 0.4)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    modalContent: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 4,
      marginHorizontal: theme.spacing.xl,
      width: '90%',
      maxWidth: 380,
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 12,
      borderWidth: 2,
      borderColor: theme.colors.outline,
    },
    modalHeader: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.m,
      position: 'relative',
    },
    modalIcon: {
      backgroundColor: theme.colors.primaryContainer,
      marginBottom: theme.spacing.m,
    },
    modalTitle: {
      fontSize: 22,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
    },
    modalCloseButton: {
      position: 'absolute',
      top: theme.spacing.s,
      right: theme.spacing.s,
    },
    dateRangeContainer: {
      paddingHorizontal: theme.spacing.l,
      paddingVertical: theme.spacing.l,
      flexDirection: 'column',
      gap: theme.spacing.m,
    },
    dateButton: {
      backgroundColor: theme.colors.background,
      borderRadius: theme.roundness * 2,
      borderWidth: 1.5,
      borderColor: theme.colors.outline,
      overflow: 'hidden',
      elevation: 1,
    },
    dateButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.m,
      gap: theme.spacing.m,
    },
    dateButtonIcon: {
      backgroundColor: theme.colors.primaryContainer,
    },
    dateButtonTextContainer: {
      flex: 1,
    },
    dateButtonLabel: {
      fontSize: 10,
      fontWeight: '700',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 1,
      marginBottom: 2,
    },
    dateButtonValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    dateArrowContainer: {
      alignSelf: 'center',
      paddingVertical: theme.spacing.xs,
    },
    dateArrow: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    modalActions: {
      flexDirection: 'row',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.m,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    modalButton: {
      flex: 1,
      borderRadius: theme.roundness * 2,
    },
    modalButtonPrimary: {
      elevation: 0,
    },
    modalButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
      paddingVertical: 4,
    },
    listContent: {
      paddingBottom: theme.spacing.m,
    },
    shiftCard: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.surface,
    },
    openShiftCard: {
      backgroundColor: theme.colors.primaryContainer,
    },
    shiftHeader: {
      marginBottom: theme.spacing.s,
    },
    shiftTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      marginBottom: 2,
    },
    shiftNumber: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    shiftDate: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    statusChip: {
      marginLeft: 'auto',
    },
    statusChipText: {
      fontWeight: '600',
      fontSize: 11,
    },
    divider: {
      marginVertical: theme.spacing.s,
    },
    shiftDetails: {
      gap: theme.spacing.s,
    },
    timeSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    label: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
      textTransform: 'uppercase',
    },
    timeText: {
      fontSize: 14,
      color: theme.colors.onSurface,
    },
    durationText: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    statsSection: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    statCard: {
      flex: 1,
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
      gap: 2,
    },
    statLabel: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      textTransform: 'uppercase',
      letterSpacing: 0.3,
    },
    statValue: {
      fontSize: 15,
      fontWeight: '700',
      color: theme.colors.onSurface,
    },
    cashSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    cashRow: {
      alignItems: 'center',
    },
    cashLabel: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
    },
    cashValue: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginTop: 2,
    },
    differenceLabel: {
      fontWeight: '600',
    },
    differenceValue: {
      fontWeight: '700',
    },
    userSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginTop: theme.spacing.xs,
    },
    userText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    actionButtonsContainer: {
      flexDirection: 'row',
      marginTop: theme.spacing.s,
      gap: theme.spacing.s,
    },
    actionButton: {
      flex: 1,
      borderRadius: theme.roundness,
    },
    ordersButton: {
      // Estilo específico para el botón de órdenes si es necesario
    },
    summaryButton: {
      // Estilo específico para el botón de resumen si es necesario
    },
    actionButtonLabel: {
      fontSize: 12,
      fontWeight: '600',
    },
    actionButtonContent: {
      paddingHorizontal: theme.spacing.xs,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
      gap: theme.spacing.l,
    },
    emptyTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
    },
    emptyMessage: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
      gap: theme.spacing.l,
    },
    errorTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.error,
      textAlign: 'center',
    },
    errorMessage: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    retryButton: {
      marginTop: theme.spacing.m,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    loadingText: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
    },
  });

  // Renderizado principal
  if ((isLoading || isRefetching) && !shifts) {
    return (
      <SafeAreaView style={styles.container} edges={['bottom']}>
        {renderLoading()}
      </SafeAreaView>
    );
  }

  if (error && !shifts) {
    return (
      <SafeAreaView style={styles.container} edges={['bottom']}>
        {renderError()}
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        {/* Filtros */}
        {renderFilters()}

        {/* Lista de turnos */}
        {filteredShifts.length === 0 ? (
          renderEmpty()
        ) : (
          <FlashList
            data={filteredShifts}
            renderItem={renderShiftItem}
            keyExtractor={(item) => item.id}
            estimatedItemSize={200}
            contentContainerStyle={styles.listContent}
            refreshControl={
              <RefreshControl
                refreshing={isRefreshing}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
          />
        )}

        {/* Modal de órdenes del turno */}
        {selectedShiftId && !showSalesSummaryView && (
          <ShiftOrdersModal
            visible={showOrdersModal}
            onClose={() => {
              setShowOrdersModal(false);
              setSelectedShiftId(null);
              setSelectedShiftNumber(undefined);
            }}
            shiftId={selectedShiftId}
          />
        )}

        {/* Vista de resumen de ventas */}
        {showSalesSummaryView && selectedShiftId && (
          <Modal
            visible={showSalesSummaryView}
            animationType="slide"
            presentationStyle="fullScreen"
          >
            <ShiftSalesSummaryView
              shiftId={selectedShiftId}
              shiftNumber={selectedShiftNumber}
              onBack={() => {
                setShowSalesSummaryView(false);
                setSelectedShiftId(null);
                setSelectedShiftNumber(undefined);
              }}
            />
          </Modal>
        )}
      </View>
    </SafeAreaView>
  );
}

================
File: app/src/modules/users/components/UserFormModal.tsx
================
import React, { useEffect, useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useCreateUser, useUpdateUser } from '../hooks';
import type { User } from '../types';

const createUserSchema = z.object({
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .max(20, 'El nombre de usuario no puede exceder 20 caracteres')
    .regex(/^[a-zA-Z0-9_]+$/, 'Solo se permiten letras, números y guión bajo'),
  email: z
    .union([z.string().email('Email inválido'), z.literal('')])
    .optional(),
  password: z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
  firstName: z
    .string()
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres'),
  lastName: z
    .string()
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(50, 'El apellido no puede exceder 50 caracteres'),
  phoneNumber: z
    .union([
      z.string().regex(/^\+?[0-9\s-]+$/, 'Número de teléfono inválido'),
      z.literal(''),
    ])
    .optional(),
  gender: z.enum(['male', 'female', 'other']).nullable().optional(),
  address: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  country: z.string().optional(),
  zipCode: z.string().optional(),
  role: z.number(),
  isActive: z.boolean(),
});

const updateUserSchema = createUserSchema.omit({ password: true }).extend({
  password: z
    .union([
      z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
      z.literal(''),
    ])
    .optional(),
});

type CreateUserFormInputs = z.infer<typeof createUserSchema>;
type UpdateUserFormInputs = z.infer<typeof updateUserSchema>;
type UserFormInputs = CreateUserFormInputs | UpdateUserFormInputs;

interface UserFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  user?: User | null;
}

export function UserFormModal({
  visible,
  onDismiss,
  user,
}: UserFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showPassword, setShowPassword] = useState(false);

  const createUserMutation = useCreateUser();
  const updateUserMutation = useUpdateUser();

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<UserFormInputs>({
    resolver: zodResolver(user ? updateUserSchema : createUserSchema) as any,
    defaultValues: {
      username: '',
      email: '',
      password: '',
      firstName: '',
      lastName: '',
      phoneNumber: '',
      gender: undefined,
      address: '',
      city: '',
      state: '',
      country: '',
      zipCode: '',
      role: 2, // Default to MANAGER role
      isActive: true,
    },
  });

  useEffect(() => {
    if (user) {
      reset({
        username: user.username,
        email: user.email || '',
        password: '', // Never pre-fill password
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        phoneNumber: user.phoneNumber || '',
        gender: user.gender || undefined, // Convert null to undefined
        address: user.address || '',
        city: user.city || '',
        state: user.state || '',
        country: user.country || '',
        zipCode: user.zipCode || '',
        role: user.role?.id || 2,
        isActive: user.isActive,
      });
    } else {
      reset({
        username: '',
        email: '',
        password: '',
        firstName: '',
        lastName: '',
        phoneNumber: '',
        gender: undefined,
        address: '',
        city: '',
        state: '',
        country: '',
        zipCode: '',
        role: 2,
        isActive: true,
      });
    }
  }, [user, reset]);

  const onSubmit = async (data: UserFormInputs) => {
    try {
      // Clean empty strings to undefined
      const cleanData = {
        username: data.username,
        email: data.email || undefined,
        password: data.password || undefined,
        firstName: data.firstName,
        lastName: data.lastName,
        phoneNumber: data.phoneNumber || undefined,
        gender: data.gender || undefined,
        address: data.address || undefined,
        city: data.city || undefined,
        state: data.state || undefined,
        country: data.country || undefined,
        zipCode: data.zipCode || undefined,
        role: { id: data.role },
        isActive: data.isActive,
      };

      if (user) {
        // For update, remove password if empty and remove username (can't be changed)
        const { username, password, ...updateData } = cleanData;
        const finalUpdateData = password
          ? { ...updateData, password }
          : updateData;

        await updateUserMutation.mutateAsync({
          id: user.id,
          data: finalUpdateData as any,
        });
      } else {
        // For create, password is required
        if (!data.password) {
          return; // Should be caught by validation
        }
        await createUserMutation.mutateAsync(cleanData as any);
      }
      onDismiss();
    } catch (error) {
      // Error handling is done in the mutation hooks
    }
  };

  const isSubmitting =
    createUserMutation.isPending || updateUserMutation.isPending;

  const genderOptions = [
    {
      value: 'male',
      label: 'Masculino',
      icon: 'gender-male',
      color: '#3498db',
    },
    {
      value: 'female',
      label: 'Femenino',
      icon: 'gender-female',
      color: '#e74c3c',
    },
    {
      value: 'other',
      label: 'Otro',
      icon: 'gender-transgender',
      color: '#9b59b6',
    },
  ];

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.modalContent} elevation={5}>
          <View
            style={[
              styles.headerContainer,
              { backgroundColor: theme.colors.primary },
            ]}
          >
            <View style={styles.headerLeft}>
              <Avatar.Icon
                size={32}
                icon={user ? 'account-edit' : 'account-plus'}
                style={[
                  styles.headerIcon,
                  { backgroundColor: theme.colors.onPrimary + '20' },
                ]}
                color={theme.colors.onPrimary}
              />
              <View style={styles.headerTextContainer}>
                <Text
                  style={[styles.modalTitle, { color: theme.colors.onPrimary }]}
                  variant="titleMedium"
                >
                  {user ? 'Editar Usuario' : 'Nuevo Usuario'}
                </Text>
              </View>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={onDismiss}
              disabled={isSubmitting}
              iconColor={theme.colors.onPrimary}
            />
          </View>

          <ScrollView
            style={styles.formContainer}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            {/* Información de Cuenta */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-key"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información de Cuenta
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="username"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre de usuario"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.username}
                      mode="outlined"
                      placeholder="usuario123"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                      disabled={!!user} // Username can't be changed
                    />
                    {errors.username && (
                      <HelperText type="error" visible={!!errors.username}>
                        {errors.username.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="email"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Email (opcional)"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.email}
                      mode="outlined"
                      placeholder="usuario@ejemplo.com"
                      keyboardType="email-address"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="email" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.email && (
                      <HelperText type="error" visible={!!errors.email}>
                        {errors.email.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="password"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label={
                        user
                          ? 'Nueva contraseña (dejar vacío para no cambiar)'
                          : 'Contraseña'
                      }
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.password}
                      mode="outlined"
                      placeholder="••••••"
                      secureTextEntry={!showPassword}
                      left={<TextInput.Icon icon="lock" />}
                      right={
                        <TextInput.Icon
                          icon={showPassword ? 'eye-off' : 'eye'}
                          onPress={() => setShowPassword(!showPassword)}
                        />
                      }
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.password && (
                      <HelperText type="error" visible={!!errors.password}>
                        {errors.password.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="role"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="badge-account"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Rol del usuario
                      </Text>
                    </View>
                    <ScrollView
                      horizontal
                      showsHorizontalScrollIndicator={false}
                      style={{ marginTop: theme.spacing.s }}
                    >
                      <View style={styles.rolesContainer}>
                        {[
                          {
                            value: 1,
                            label: 'Admin',
                            icon: 'shield-account',
                            description: 'Acceso completo',
                          },
                          {
                            value: 2,
                            label: 'Gerente',
                            icon: 'account-tie',
                            description: 'Gestión general',
                          },
                          {
                            value: 3,
                            label: 'Cajero',
                            icon: 'cash-register',
                            description: 'Ventas',
                          },
                          {
                            value: 4,
                            label: 'Mesero',
                            icon: 'room-service',
                            description: 'Órdenes',
                          },
                          {
                            value: 5,
                            label: 'Cocina',
                            icon: 'chef-hat',
                            description: 'Preparación',
                          },
                          {
                            value: 6,
                            label: 'Repartidor',
                            icon: 'moped',
                            description: 'Entregas',
                          },
                        ].map((role) => (
                          <Surface
                            key={role.value}
                            style={[
                              styles.roleCard,
                              value === role.value && styles.roleCardActive,
                            ]}
                            elevation={value === role.value ? 2 : 0}
                          >
                            <TouchableOpacity
                              onPress={() => onChange(role.value)}
                              style={styles.roleCardContent}
                            >
                              <Icon
                                source={role.icon}
                                size={24}
                                color={
                                  value === role.value
                                    ? theme.colors.primary
                                    : theme.colors.onSurfaceVariant
                                }
                              />
                              <Text
                                style={[
                                  styles.roleLabel,
                                  value === role.value &&
                                    styles.roleLabelActive,
                                ]}
                                variant="labelMedium"
                              >
                                {role.label}
                              </Text>
                              <Text
                                style={styles.roleDescription}
                                variant="bodySmall"
                                numberOfLines={1}
                              >
                                {role.description}
                              </Text>
                            </TouchableOpacity>
                          </Surface>
                        ))}
                      </View>
                    </ScrollView>
                  </View>
                )}
              />
            </View>

            <Divider style={styles.divider} />

            {/* Información Personal */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-circle"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información Personal
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="firstName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.firstName}
                      mode="outlined"
                      placeholder="Juan"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.firstName && (
                      <HelperText type="error" visible={!!errors.firstName}>
                        {errors.firstName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="lastName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Apellido"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.lastName}
                      mode="outlined"
                      placeholder="Pérez"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.lastName && (
                      <HelperText type="error" visible={!!errors.lastName}>
                        {errors.lastName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="gender"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="gender-transgender"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Género
                      </Text>
                    </View>
                    <View
                      style={[
                        styles.genderContainer,
                        { marginTop: theme.spacing.s },
                      ]}
                    >
                      {genderOptions.map((option) => (
                        <TouchableOpacity
                          key={option.value}
                          onPress={() => onChange(option.value)}
                          activeOpacity={0.7}
                        >
                          <Surface
                            style={[
                              styles.genderOption,
                              value === option.value &&
                                styles.genderOptionActive,
                            ]}
                            elevation={value === option.value ? 3 : 1}
                          >
                            <View
                              style={[
                                styles.genderIconContainer,
                                value === option.value && {
                                  backgroundColor: option.color + '20',
                                },
                              ]}
                            >
                              <Icon
                                source={option.icon}
                                size={20}
                                color={
                                  value === option.value
                                    ? option.color
                                    : theme.colors.onSurfaceVariant
                                }
                              />
                            </View>
                            <Text
                              style={[
                                styles.genderLabel,
                                value === option.value &&
                                  styles.genderLabelActive,
                              ]}
                              variant="labelMedium"
                            >
                              {option.label}
                            </Text>
                          </Surface>
                        </TouchableOpacity>
                      ))}
                    </View>
                  </View>
                )}
              />
            </View>

            <Divider style={styles.divider} />

            {/* Información de Contacto */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="phone-in-talk"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información de Contacto
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="information"
                  style={styles.optionalChip}
                  textStyle={styles.optionalChipText}
                >
                  Opcional
                </Chip>
              </View>

              <Controller
                control={control}
                name="phoneNumber"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Teléfono"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.phoneNumber}
                      mode="outlined"
                      placeholder="+52 55 1234 5678"
                      keyboardType="phone-pad"
                      left={<TextInput.Icon icon="phone" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.phoneNumber && (
                      <HelperText type="error" visible={!!errors.phoneNumber}>
                        {errors.phoneNumber.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="address"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Dirección"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      mode="outlined"
                      placeholder="Calle Principal #123"
                      left={<TextInput.Icon icon="map-marker" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                  </View>
                )}
              />

              <View style={styles.rowContainer}>
                <Controller
                  control={control}
                  name="city"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Ciudad"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Ciudad"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="state"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Estado"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Estado"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
              </View>

              <View style={styles.rowContainer}>
                <Controller
                  control={control}
                  name="country"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="País"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="México"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="zipCode"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Código Postal"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="12345"
                        keyboardType="number-pad"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
              </View>
            </View>

            <Divider style={styles.divider} />

            {/* Estado de la cuenta */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="shield-check"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Estado de la cuenta
                </Text>
              </View>

              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <Surface style={styles.switchContainer} elevation={1}>
                    <View style={styles.switchContent}>
                      <View style={styles.switchTextContainer}>
                        <Text style={styles.switchLabel} variant="bodyLarge">
                          Usuario activo
                        </Text>
                        <Text
                          style={styles.switchDescription}
                          variant="bodySmall"
                        >
                          Los usuarios inactivos no pueden iniciar sesión
                        </Text>
                      </View>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                )}
              />
            </View>

            {/* Espacio adicional para el teclado */}
            <View style={{ height: 10 }} />
          </ScrollView>

          <Surface style={styles.buttonContainer} elevation={2}>
            <Button
              onPress={onDismiss}
              disabled={isSubmitting}
              style={[styles.button, styles.cancelButton]}
              textColor={theme.colors.onSecondaryContainer}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit as any)}
              disabled={isSubmitting}
              loading={isSubmitting}
              style={[styles.button, styles.confirmButton]}
              buttonColor={theme.colors.primary}
            >
              {user ? 'Guardar' : 'Crear'}
            </Button>
          </Surface>
        </Surface>
      </Modal>
    </Portal>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? theme.spacing.xl : theme.spacing.m,
      maxWidth: responsive.isTablet ? 700 : 420,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '92%',
      paddingHorizontal: 0,
      height: responsive.isTablet ? '85%' : '80%',
      maxHeight: responsive.isTablet ? '90%' : '85%',
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      height: '100%',
      flex: 1,
      overflow: 'hidden',
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingVertical: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.s,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
      gap: theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 14,
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.primary + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '40',
    },
    requiredChipText: {
      color: theme.colors.primary,
      fontSize: 11,
      fontWeight: '600',
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    inputContainer: {
      marginBottom: theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
    },
    input: {
      fontSize: 14,
      backgroundColor: theme.colors.surface,
      height: 48,
    },
    inputContent: {
      paddingVertical: 4,
      fontSize: 14,
      fontFamily: 'System',
    },
    fieldLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.xs,
      fontWeight: '600',
      fontSize: 12,
      letterSpacing: 0.4,
      textTransform: 'uppercase',
      fontFamily: 'System',
    },
    fieldLabelContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    segmentedButtons: {
      marginTop: theme.spacing.xs,
    },
    genderContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      flexWrap: 'wrap',
    },
    genderOption: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
      minWidth: 85,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
    },
    genderOptionActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    genderIconContainer: {
      width: 36,
      height: 36,
      borderRadius: 18,
      alignItems: 'center',
      justifyContent: 'center',
      marginBottom: theme.spacing.xs,
    },
    genderLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
      textAlign: 'center',
    },
    genderLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '600',
    },
    rowContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    halfInput: {
      flex: 1,
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '30',
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    divider: {
      marginVertical: theme.spacing.s,
      marginHorizontal: -theme.spacing.m,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.s,
    },
    button: {
      flex: 1,
      maxWidth: responsive.isTablet ? 180 : 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    rolesContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      paddingVertical: theme.spacing.xs,
    },
    roleCard: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      marginRight: theme.spacing.xs,
      minWidth: 90,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
      elevation: 1,
    },
    roleCardActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
      elevation: 3,
    },
    roleCardContent: {
      alignItems: 'center',
    },
    roleLabel: {
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      fontWeight: '500',
    },
    roleLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '700',
    },
    roleDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: 10,
      textAlign: 'center',
    },
  });

================
File: app/src/services/healthMonitoringService.ts
================
import axios from 'axios';
import { discoveryService } from '@/app/services/discoveryService';
import EventEmitter from 'eventemitter3';
import { NETWORK_CONFIG } from '@/app/constants/network';
import { API_PATHS } from '@/app/constants/apiPaths';

export type HealthStatus = 'ok' | 'error' | 'checking';

export interface HealthState {
  status: HealthStatus;
  isAvailable: boolean;
  message?: string;
}

class HealthMonitoringService extends EventEmitter {
  private state: HealthState = {
    status: 'checking',
    isAvailable: false,
  };

  private checkInterval: NodeJS.Timeout | null = null;
  private retryTimeout: NodeJS.Timeout | null = null;
  private isChecking = false;
  private retryCount = 0;

  constructor() {
    super();
  }

  // Obtener estado actual
  getState(): HealthState {
    return { ...this.state };
  }

  // Verificar si está monitoreando
  isMonitoring(): boolean {
    return this.checkInterval !== null;
  }

  // Iniciar monitoreo periódico
  startMonitoring() {
    this.stopMonitoring(); // Detener cualquier monitoreo previo

    // Reset retry count al iniciar monitoreo nuevo
    this.retryCount = 0;

    // Verificar inmediatamente
    this.checkHealth();

    // Configurar intervalo normal
    this.checkInterval = setInterval(() => {
      this.checkHealth();
    }, NETWORK_CONFIG.HEALTH_CHECK_INTERVAL);
  }

  // Detener monitoreo
  stopMonitoring() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }

    if (this.retryTimeout) {
      clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }

  // Verificar salud del backend
  async checkHealth(): Promise<boolean> {
    if (this.isChecking) {
      return this.state.isAvailable;
    }

    this.isChecking = true;

    try {
      let apiUrl: string;
      try {
        // Usar getLastKnownUrl que NO hace verificación con discovery
        const lastKnownUrl = await discoveryService.getLastKnownUrl();
        if (!lastKnownUrl) {
          throw new Error('No hay servidor configurado');
        }
        apiUrl = lastKnownUrl;
      } catch (error) {
        // Si no hay URL configurada, marcar como no disponible
        this.updateState({
          status: 'error',
          isAvailable: false,
          message: 'Servidor no configurado',
        });
        this.isChecking = false;
        return false;
      }

      // Asegurar que la URL NO termine con /
      const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
      const healthUrl = `${baseUrl}${API_PATHS.HEALTH}`;

      const response = await axios.get(healthUrl, {
        timeout: NETWORK_CONFIG.HEALTH_CHECK_TIMEOUT,
      });

      if (response.data.status === 'ok') {
        // Backend está saludable
        const wasUnavailable = !this.state.isAvailable;

        this.updateState({
          status: 'ok',
          isAvailable: true,
          message: 'Conectado al servidor',
        });

        // Si pasamos de no disponible a disponible, emitir evento adicional
        if (wasUnavailable) {
          // Emitir evento de recuperación después de un pequeño delay
          setTimeout(() => {
            this.emit('recovered');
          }, 100);
        }

        // Reset retry count en conexión exitosa
        this.retryCount = 0;

        // Limpiar retry timeout si existe
        if (this.retryTimeout) {
          clearTimeout(this.retryTimeout);
          this.retryTimeout = null;
        }

        this.isChecking = false; // Importante: marcar como no checking antes de retornar
        return true;
      } else {
        throw new Error('Backend returned unhealthy status');
      }
    } catch (error: any) {
      // Solo marcar como error si no es un problema temporal
      const isTemporaryError = this.isTemporaryError(error);

      this.updateState({
        status: 'error',
        isAvailable: false,
        message: this.getErrorMessage(error),
      });

      // Si es un error temporal y tenemos menos de 3 reintentos, programar reintento rápido
      if (isTemporaryError && this.retryCount < 3) {
        this.scheduleRetry();
      }

      this.isChecking = false;
      return false;
    }
  }

  // Programar reintento con backoff
  private scheduleRetry() {
    // Limpiar timeout existente
    if (this.retryTimeout) {
      clearTimeout(this.retryTimeout);
    }

    // Obtener intervalo de reintento
    const retryInterval =
      NETWORK_CONFIG.HEALTH_RETRY_INTERVALS[
        Math.min(
          this.retryCount,
          NETWORK_CONFIG.HEALTH_RETRY_INTERVALS.length - 1,
        )
      ];

    this.retryTimeout = setTimeout(() => {
      this.retryCount++;
      this.checkHealth();
    }, retryInterval);
  }

  private updateState(newState: HealthState) {
    this.state = newState;
    this.emit('stateChange', this.state);
  }

  // Detectar si es un error temporal
  private isTemporaryError(error: any): boolean {
    return (
      error.code === 'ECONNABORTED' ||
      error.code === 'ETIMEDOUT' ||
      error.message?.includes('timeout') ||
      error.code === 'ECONNRESET'
    );
  }

  // Obtener mensaje de error amigable
  private getErrorMessage(error: any): string {
    if (error.code === 'ECONNABORTED' || error.message?.includes('timeout')) {
      return 'Tiempo de espera agotado';
    }
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      return 'No se puede conectar al servidor';
    }
    if (error.message?.includes('No API URL')) {
      return 'Servidor no encontrado';
    }
    if (error.message?.includes('Servidor no configurado')) {
      return 'Servidor no configurado';
    }
    return 'Error de conexión';
  }

  // Suscribirse a cambios
  subscribe(callback: (state: HealthState) => void): () => void {
    this.on('stateChange', callback);

    // Llamar inmediatamente con el estado actual
    callback(this.state);

    // Retornar función para desuscribirse
    return () => {
      this.off('stateChange', callback);
    };
  }

  // Verificar salud con URL específica (sin actualizar estado interno)
  async checkHealthWithUrl(apiUrl: string): Promise<boolean> {
    try {
      // Asegurar que la URL NO termine con /
      const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
      const healthUrl = `${baseUrl}${API_PATHS.HEALTH}`;

      const response = await axios.get(healthUrl, {
        timeout: NETWORK_CONFIG.HEALTH_CHECK_TIMEOUT,
      });

      return response.data.status === 'ok';
    } catch (error) {
      return false;
    }
  }

  // Forzar verificación inmediata
  async forceCheck(): Promise<boolean> {
    this.retryCount = 0; // Reset retry count
    const result = await this.checkHealth();

    // Forzar emisión del estado actual después del check
    // Esto asegura que todos los componentes se actualicen
    this.emit('stateChange', this.state);

    return result;
  }
}

// Singleton
export const healthMonitoringService = new HealthMonitoringService();

================
File: app/src/app/components/ShiftIndicator.tsx
================
import React, { useState } from 'react';
import { TouchableOpacity, StyleSheet, Text } from 'react-native';
import { Icon, Badge } from 'react-native-paper';
import { useAppTheme } from '../styles/theme';
import { useAuthStore } from '../store/authStore';
import { canOpenShift } from '../utils/roleUtils';
import { OpenShiftModal } from '@/modules/orders/components/OpenShiftModal';
import { ShiftStatusModal } from '@/modules/orders/components/ShiftStatusModal';
import { CloseShiftModal } from '@/modules/orders/components/CloseShiftModal';
import { useGlobalShift } from '../hooks/useGlobalShift';
import { useQueryClient } from '@tanstack/react-query';

export const ShiftIndicator: React.FC = () => {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const queryClient = useQueryClient();

  const { data: shift, isLoading: loading, refetch } = useGlobalShift();

  const [statusModalVisible, setStatusModalVisible] = useState(false);
  const [openShiftModalVisible, setOpenShiftModalVisible] = useState(false);
  const [closeShiftModalVisible, setCloseShiftModalVisible] = useState(false);

  const userCanOpenShift = canOpenShift(user);
  const isShiftOpen = shift && shift.status === 'OPEN';

  const handlePress = () => {
    // No refrescamos aquí porque ya se actualiza automáticamente
    setStatusModalVisible(true);
  };

  const handleOpenShift = () => {
    setStatusModalVisible(false);
    setOpenShiftModalVisible(true);
  };

  const handleCloseShift = () => {
    setStatusModalVisible(false);
    setCloseShiftModalVisible(true);
  };

  const getIconColor = () => {
    if (loading) return theme.colors.onPrimary;
    return '#FFFFFF';
  };

  const getIconName = () => {
    if (loading) return 'clock-outline';
    if (isShiftOpen) return 'store-check';
    return 'store-alert';
  };

  return (
    <>
      <TouchableOpacity
        style={[
          styles.container,
          {
            backgroundColor: loading
              ? 'rgba(255, 255, 255, 0.2)'
              : isShiftOpen
                ? '#2E7D32' // Verde oscuro sólido
                : '#F57C00', // Naranja oscuro sólido
            borderWidth: 2,
            borderColor: loading
              ? 'rgba(255, 255, 255, 0.3)'
              : isShiftOpen
                ? '#4CAF50' // Verde más claro para el borde
                : '#FF9800', // Naranja más claro para el borde
          },
        ]}
        onPress={handlePress}
        disabled={loading}
        hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
      >
        <Icon source={getIconName()} size={22} color={getIconColor()} />
        <Text style={[styles.statusText, { color: getIconColor() }]}>
          {loading ? 'Cargando' : isShiftOpen ? 'ABIERTO' : 'CERRADO'}
        </Text>
        {!isShiftOpen && !loading && (
          <Badge
            style={[styles.badge, { backgroundColor: '#FF1744' }]}
            size={8}
          />
        )}
      </TouchableOpacity>

      <ShiftStatusModal
        visible={statusModalVisible}
        onDismiss={() => setStatusModalVisible(false)}
        shift={shift}
        onOpenShift={handleOpenShift}
        onCloseShift={handleCloseShift}
        canOpenShift={userCanOpenShift}
        loading={loading}
      />

      <OpenShiftModal
        visible={openShiftModalVisible}
        onDismiss={() => setOpenShiftModalVisible(false)}
        onShiftOpened={() => {
          queryClient.invalidateQueries(['global', 'shift', 'current']);
          setOpenShiftModalVisible(false);
        }}
      />

      <CloseShiftModal
        visible={closeShiftModalVisible}
        onDismiss={() => setCloseShiftModalVisible(false)}
        onShiftClosed={() => {
          queryClient.invalidateQueries(['global', 'shift', 'current']);
          setCloseShiftModalVisible(false);
        }}
        shift={shift}
      />
    </>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'relative',
    flexDirection: 'row',
    paddingHorizontal: 14,
    paddingVertical: 8,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
    borderRadius: 24,
    gap: 6,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  statusText: {
    fontSize: 14,
    fontWeight: '700',
    letterSpacing: 0.5,
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
  },
});

================
File: app/src/app/lib/imageCache.ts
================
import * as FileSystem from 'expo-file-system';
import * as Crypto from 'expo-crypto';
import { Platform } from 'react-native';
import { API_PATHS } from '@/app/constants/apiPaths';

const CACHE_DIR = `${FileSystem.cacheDirectory}image-cache/`;
const MAX_CACHE_SIZE_MB = 500;
const MAX_CACHE_AGE_DAYS = 7;
const MAX_RETRIES = 3;
const BASE_RETRY_DELAY = 1000; // 1 segundo

// Logging utility para operaciones de cache (solo errores y operaciones críticas)
const logCacheOperation = (operation: string, details: any) => {
  // Solo loggear errores y operaciones de limpieza
  if (
    operation.includes('ERROR') ||
    operation.includes('FAILED') ||
    operation === 'CACHE_CLEANED'
  ) {
    // [ImageCache] operation: details
  }
};

// Función para realizar descargas con retry y backoff exponencial
async function downloadWithRetry(
  remoteUrl: string,
  localUri: string,
  maxRetries: number = MAX_RETRIES,
  baseDelay: number = BASE_RETRY_DELAY,
): Promise<string | null> {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const { uri: downloadedUri } = await FileSystem.downloadAsync(
        remoteUrl,
        localUri,
      );

      // Solo loggear si hubo múltiples intentos y falló al final
      // Éxito después de reintentos no necesita log

      return downloadedUri;
    } catch (error) {
      if (attempt === maxRetries) {
        // Último intento fallido
        logCacheOperation('DOWNLOAD_FAILED_ALL_RETRIES', {
          url: remoteUrl,
          totalAttempts: maxRetries + 1,
          error: error.message,
        });
        break;
      }

      // Calcular el delay con backoff exponencial
      const delay = baseDelay * Math.pow(2, attempt);

      // No loggear cada reintento, solo el fallo final

      // Esperar antes del siguiente intento
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  return null;
}

async function ensureCacheDirExists() {
  // En web, el sistema de archivos no está disponible
  if (Platform.OS === 'web') {
    return;
  }

  const dirInfo = await FileSystem.getInfoAsync(CACHE_DIR);
  if (!dirInfo.exists) {
    await FileSystem.makeDirectoryAsync(CACHE_DIR, { intermediates: true });
  }
}

async function getCacheFilename(remoteUrl: string): Promise<string> {
  let urlToHash = remoteUrl;

  // Si la URL es de nuestra API, incluir el host en el hash para evitar conflictos
  // cuando cambia la IP del servidor
  if (remoteUrl.includes(API_PATHS.FILES_CHECK)) {
    try {
      const parsedUrl = new URL(remoteUrl);
      // Incluir host + pathname para diferenciar entre diferentes servidores
      urlToHash = `${parsedUrl.host}${parsedUrl.pathname}`;
    } catch (e) {
      // Si falla el parseo, usar la URL completa
      urlToHash = remoteUrl;
    }
  }

  const digest = await Crypto.digestStringAsync(
    Crypto.CryptoDigestAlgorithm.SHA256,
    urlToHash,
    { encoding: Crypto.CryptoEncoding.HEX },
  );
  const extensionMatch = remoteUrl.match(/\.([a-zA-Z0-9]+)(?:[?#]|$)/);
  const extension = extensionMatch ? extensionMatch[1] : 'jpg';
  return `${digest}.${extension}`;
}

interface ExistingFileInfo {
  uri: string;
  size: number;
  modificationTime: number;
  exists: true;
}

async function cleanCache() {
  await ensureCacheDirExists();

  try {
    const files = await FileSystem.readDirectoryAsync(CACHE_DIR);

    if (files.length === 0) {
      return;
    }

    const fileInfosPromises = files.map(
      async (
        file,
      ): Promise<ExistingFileInfo | { exists: false; uri: string }> => {
        const info = await FileSystem.getInfoAsync(`${CACHE_DIR}${file}`, {
          size: true,
        });
        if (info.exists) {
          return {
            uri: info.uri,
            size: info.size,
            modificationTime: info.modificationTime,
            exists: true,
          };
        } else {
          return {
            exists: false,
            uri: info.uri,
          };
        }
      },
    );

    const allFileInfos = await Promise.all(fileInfosPromises);
    const existingFileInfos: ExistingFileInfo[] = allFileInfos.filter(
      (f): f is ExistingFileInfo => f.exists,
    );

    let totalSize = existingFileInfos.reduce((sum, file) => sum + file.size, 0);
    const originalTotalSize = totalSize;

    const now = Date.now();
    const maxAgeMillis = MAX_CACHE_AGE_DAYS * 24 * 60 * 60 * 1000;
    const maxSizeInBytes = MAX_CACHE_SIZE_MB * 1024 * 1024;

    let filesDeletedCount = 0;
    let sizeDeleted = 0;

    // Fase 1: Eliminar archivos por edad (más eficiente)
    const filesToDeleteByAge = existingFileInfos.filter((file) => {
      const fileAgeMillis = now - Math.floor(file.modificationTime) * 1000;
      return fileAgeMillis > maxAgeMillis;
    });

    for (const file of filesToDeleteByAge) {
      try {
        await FileSystem.deleteAsync(file.uri, { idempotent: true });
        totalSize -= file.size;
        sizeDeleted += file.size;
        filesDeletedCount++;
      } catch (delError) {
        // Ignorar errores de archivos que no se pueden eliminar
      }
    }

    // Fase 2: Eliminar archivos por tamaño si es necesario (LRU)
    if (totalSize > maxSizeInBytes) {
      const remainingFiles = existingFileInfos
        .filter((file) => {
          const fileAgeMillis = now - Math.floor(file.modificationTime) * 1000;
          return fileAgeMillis <= maxAgeMillis;
        })
        .sort((a, b) => {
          // Ordenar por tiempo de modificación (más antiguos primero)
          return a.modificationTime < b.modificationTime
            ? -1
            : a.modificationTime > b.modificationTime
              ? 1
              : 0;
        });

      // Eliminar archivos más antiguos hasta llegar al límite de tamaño
      // Dejamos un margen del 10% para evitar limpiezas frecuentes
      const targetSize = maxSizeInBytes * 0.9;

      for (const file of remainingFiles) {
        if (totalSize <= targetSize) break;

        try {
          await FileSystem.deleteAsync(file.uri, { idempotent: true });
          totalSize -= file.size;
          sizeDeleted += file.size;
          filesDeletedCount++;
        } catch (delError) {
          // Ignorar errores de archivos que no se pueden eliminar
        }
      }
    }

    // Logging detallado
    if (filesDeletedCount > 0) {
      logCacheOperation('CACHE_CLEANED', {
        filesDeleted: filesDeletedCount,
        sizeCleaned: `${(sizeDeleted / 1024 / 1024).toFixed(2)}MB`,
        totalFilesRemaining: files.length - filesDeletedCount,
        totalSizeRemaining: `${(totalSize / 1024 / 1024).toFixed(2)}MB`,
        originalSize: `${(originalTotalSize / 1024 / 1024).toFixed(2)}MB`,
        spaceFreed: `${(sizeDeleted / 1024 / 1024).toFixed(2)}MB`,
        cacheUtilization: `${((totalSize / maxSizeInBytes) * 100).toFixed(1)}%`,
      });
    }
    // No necesitamos loggear cuando no se limpia nada
  } catch (error) {
    logCacheOperation('CACHE_CLEAN_ERROR', { error: error.message });
  }
}

export async function getCachedImageUri(
  remoteUrl: string,
): Promise<string | null> {
  if (
    !remoteUrl ||
    typeof remoteUrl !== 'string' ||
    (!remoteUrl.startsWith('http://') && !remoteUrl.startsWith('https://'))
  ) {
    return remoteUrl;
  }

  // En web, no usar cache - devolver URL directamente
  if (Platform.OS === 'web') {
    return remoteUrl;
  }

  await ensureCacheDirExists();
  const filename = await getCacheFilename(remoteUrl);
  const localUri = `${CACHE_DIR}${filename}`;
  const fileInfo = await FileSystem.getInfoAsync(localUri);

  if (fileInfo.exists) {
    return localUri;
  } else {
    // Usar downloadWithRetry en lugar de descarga directa
    const downloadedUri = await downloadWithRetry(remoteUrl, localUri);

    if (downloadedUri) {
      // Descarga exitosa - no necesita log en producción

      return downloadedUri;
    } else {
      // Limpiar archivos parciales si los hay
      const partialFileInfo = await FileSystem.getInfoAsync(localUri);
      if (partialFileInfo.exists) {
        await FileSystem.deleteAsync(localUri, { idempotent: true });
      }

      logCacheOperation('CACHE_MISS_FAILED', {
        url: remoteUrl,
        filename,
        error: 'Download failed after all retries',
      });

      return null;
    }
  }
}

export async function initImageCache() {
  // En web, no inicializar cache
  if (Platform.OS === 'web') {
    return;
  }

  await ensureCacheDirExists();

  cleanCache().catch((error) => {
    logCacheOperation('CACHE_CLEAN_ERROR', { error: error.message });
  });
}

export async function removeImageFromCache(remoteUrl: string) {
  if (!remoteUrl || typeof remoteUrl !== 'string') return;

  // En web, no hay cache que limpiar
  if (Platform.OS === 'web') {
    return;
  }

  try {
    const filename = await getCacheFilename(remoteUrl);
    const localUri = `${CACHE_DIR}${filename}`;
    await FileSystem.deleteAsync(localUri, { idempotent: true });

    // Item removido exitosamente - no necesita log
  } catch (error) {
    logCacheOperation('CACHE_ITEM_REMOVE_FAILED', {
      url: remoteUrl,
      error: error.message,
    });
  }
}

export async function clearImageCache() {
  try {
    await FileSystem.deleteAsync(CACHE_DIR, { idempotent: true });
    await ensureCacheDirExists();

    // Cache limpiado exitosamente - no necesita log
  } catch (error) {
    logCacheOperation('CACHE_CLEAR_FAILED', {
      error: error.message,
    });
  }
}

// Prefetching inteligente para optimizar la carga de imágenes
export async function prefetchImages(
  imagePaths: string[],
  options: {
    maxConcurrent?: number;
    skipExisting?: boolean;
    onProgress?: (completed: number, total: number) => void;
  } = {},
) {
  const { maxConcurrent = 5, skipExisting = true, onProgress } = options;

  if (!imagePaths || imagePaths.length === 0) {
    return;
  }

  let completed = 0;
  let failed = 0;

  // Función para procesar una imagen
  const processSingleImage = async (imagePath: string) => {
    try {
      // Construir la URL completa usando getImageUrl
      const { getImageUrl } = await import('./imageUtils');
      const fullUrl = await getImageUrl(imagePath);

      if (!fullUrl) {
        failed++;
        return;
      }

      // Verificar si ya existe en cache
      if (skipExisting) {
        const filename = await getCacheFilename(fullUrl);
        const localUri = `${CACHE_DIR}${filename}`;
        const fileInfo = await FileSystem.getInfoAsync(localUri);

        if (fileInfo.exists) {
          return;
        }
      }

      // Descargar la imagen usando el método con retry
      const result = await getCachedImageUri(fullUrl);
      if (!result) {
        failed++;
      }
    } catch (error) {
      failed++;
    } finally {
      completed++;
      onProgress?.(completed, imagePaths.length);
    }
  };

  // Procesar imágenes en lotes concurrentes
  const batches = [];
  for (let i = 0; i < imagePaths.length; i += maxConcurrent) {
    const batch = imagePaths.slice(i, i + maxConcurrent);
    batches.push(batch);
  }

  for (const batch of batches) {
    await Promise.all(batch.map(processSingleImage));
  }

  // Solo loggear si hubo errores
  if (failed > 0) {
    logCacheOperation('PREFETCH_FAILED', {
      totalImages: imagePaths.length,
      failed,
      successRate: `${((1 - failed / imagePaths.length) * 100).toFixed(1)}%`,
    });
  }
}

// Prefetching específico para menús
export async function prefetchMenuImages(
  menuData: any[],
  options?: {
    maxConcurrent?: number;
    onProgress?: (completed: number, total: number) => void;
  },
) {
  const imagePaths: string[] = [];

  // Extraer paths de imágenes del menú
  menuData.forEach((category) => {
    if (category.photo?.path) {
      imagePaths.push(category.photo.path);
    }

    if (category.subcategories) {
      category.subcategories.forEach((subcategory) => {
        if (subcategory.photo?.path) {
          imagePaths.push(subcategory.photo.path);
        }

        if (subcategory.products) {
          subcategory.products.forEach((product) => {
            if (product.photo?.path) {
              imagePaths.push(product.photo.path);
            }
          });
        }
      });
    }
  });

  if (imagePaths.length > 0) {
    await prefetchImages(imagePaths, {
      ...options,
      skipExisting: true,
    });
  }
}

================
File: app/src/app/store/authStore.ts
================
import { create } from 'zustand';
import EncryptedStorage from '@/app/services/secureStorageService';
import type { User } from '../../modules/auth/schema/auth.schema'; // Corregida ruta de importación
import * as ScreenOrientation from 'expo-screen-orientation';

const AUTH_TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';
const USER_INFO_KEY = 'user_info';

export interface AuthState {
  isAuthenticated: boolean;
  accessToken: string | null;
  refreshToken: string | null;
  user: User | null;
  setTokens: (
    accessToken: string,
    refreshToken: string,
    user: User | null,
  ) => Promise<void>;
  setAccessToken: (accessToken: string) => Promise<void>;
  setRefreshToken: (refreshToken: string) => Promise<void>;
  setUser: (user: User | null) => Promise<void>;
  logout: () => Promise<void>;
}

export const useAuthStore = create<AuthState>((set) => ({
  isAuthenticated: false,
  accessToken: null,
  refreshToken: null,
  user: null,

  setTokens: async (
    accessToken: string,
    refreshToken: string,
    user: User | null,
  ) => {
    // Verificar si el usuario está activo antes de guardar los tokens
    if (user && 'isActive' in user && !user.isActive) {
      throw new Error('Usuario inactivo');
    }

    await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);
    await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
    if (user) {
      await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
    } else {
      await EncryptedStorage.removeItem(USER_INFO_KEY);
    }
    set({
      accessToken,
      refreshToken,
      user: user ?? null,
      isAuthenticated: true,
    });
  },

  setAccessToken: async (accessToken: string) => {
    try {
      await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);
      set({ accessToken, isAuthenticated: true });
    } catch (error) {
      // Error al guardar access token
    }
  },

  setRefreshToken: async (refreshToken: string) => {
    try {
      await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
      set({ refreshToken });
    } catch (error) {
      // Error al guardar refresh token
    }
  },

  setUser: async (user: User | null) => {
    try {
      if (user) {
        // Si el usuario se actualiza y está inactivo, cerrar sesión
        if ('isActive' in user && !user.isActive) {
          await useAuthStore.getState().logout();
          return;
        }
        await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
      } else {
        await EncryptedStorage.removeItem(USER_INFO_KEY);
      }
      set({ user });
    } catch (error) {
      // Error al guardar información del usuario
    }
  },

  logout: async () => {
    const ORIENTATION_DELAYS = {
      UNLOCK: 100,
      LOCK: 200,
    };

    const clearAuthData = async () => {
      await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
      await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
      await EncryptedStorage.removeItem(USER_INFO_KEY);
      set({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });
    };

    try {
      await ScreenOrientation.unlockAsync();
      await new Promise((resolve) =>
        setTimeout(resolve, ORIENTATION_DELAYS.UNLOCK),
      );
      await ScreenOrientation.lockAsync(
        ScreenOrientation.OrientationLock.PORTRAIT_UP,
      );
      await new Promise((resolve) =>
        setTimeout(resolve, ORIENTATION_DELAYS.LOCK),
      );
      await clearAuthData();
    } catch (error) {
      try {
        await clearAuthData();
      } catch (fallbackError) {
        // Silently handle critical error
      }
    }
  },
}));

export const initializeAuthStore = async () => {
  try {
    const accessToken = await EncryptedStorage.getItem(AUTH_TOKEN_KEY);
    const refreshToken = await EncryptedStorage.getItem(REFRESH_TOKEN_KEY);
    const userInfoString = await EncryptedStorage.getItem(USER_INFO_KEY);
    let user: User | null = null;
    if (userInfoString) {
      try {
        user = JSON.parse(userInfoString);
      } catch (parseError) {
        await EncryptedStorage.removeItem(USER_INFO_KEY);
      }
    }

    if (accessToken && refreshToken) {
      // Verificar si el usuario está activo antes de restaurar la sesión
      if (user && 'isActive' in user && !user.isActive) {
        await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
        await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
        await EncryptedStorage.removeItem(USER_INFO_KEY);
        useAuthStore.setState({
          accessToken: null,
          refreshToken: null,
          user: null,
          isAuthenticated: false,
        });
        return;
      }

      // Primero establecemos el token en el estado para que el apiClient pueda usarlo
      useAuthStore.setState({
        accessToken,
        refreshToken,
        user,
        isAuthenticated: true,
      });

      // La verificación del token se hará de manera lazy cuando sea necesario
      // Esto evita el ciclo de dependencias con authService
    } else {
      useAuthStore.setState({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });
    }
  } catch (error) {
    useAuthStore.setState({
      accessToken: null,
      refreshToken: null,
      user: null,
      isAuthenticated: false,
    });
  }
};

================
File: app/src/components/AudioRecorderWidget.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import {
  View,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Easing,
  Text,
  Platform,
} from 'react-native';
import { MaterialIcons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from 'react-native-paper';
import { useAudioRecorder } from '@/hooks/useAudioRecorder';
import {
  audioServiceHealth,
  type AudioServiceHealthStatus,
} from '@/services/audioServiceHealth';
import { serverConnectionService } from '@/services/serverConnectionService';

interface AudioRecorderWidgetProps {
  onRecordingComplete: (audioUri: string, transcription: string) => void;
  onError: (error: string) => void;
}

export const AudioRecorderWidget: React.FC<AudioRecorderWidgetProps> = ({
  onRecordingComplete,
  onError,
}) => {
  const theme = useTheme();
  const {
    isRecording,
    isPreparing,
    isProcessing,
    audioUri,
    transcription,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  } = useAudioRecorder();

  // Estado para el tiempo de grabación
  const [recordingTime, setRecordingTime] = useState(0);
  const recordingInterval = useRef<NodeJS.Timeout | null>(null);

  // Estado de disponibilidad del servicio
  const [serviceHealth, setServiceHealth] = useState<AudioServiceHealthStatus>(
    audioServiceHealth.getStatus(),
  );
  const [isServiceAvailable, setIsServiceAvailable] = useState(false);
  const [isServerReady, setIsServerReady] = useState(false);

  // Animaciones
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const waveAnim1 = useRef(new Animated.Value(0.8)).current;
  const waveAnim2 = useRef(new Animated.Value(0.8)).current;
  const waveAnim3 = useRef(new Animated.Value(0.8)).current;
  const bounceAnim = useRef(new Animated.Value(0)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;

  // Verificar estado del servidor primero
  useEffect(() => {
    const checkServerConnection = () => {
      const connectionState = serverConnectionService.getState();
      const ready = connectionState.isConnected && !!connectionState.currentUrl;
      setIsServerReady(ready);
    };

    // Verificación inicial
    checkServerConnection();

    // Suscribirse a cambios en el estado del servidor
    const unsubscribeServer = serverConnectionService.subscribe(
      checkServerConnection,
    );

    return unsubscribeServer;
  }, []);

  // Suscribirse a cambios en el estado del servicio solo cuando el servidor esté listo
  useEffect(() => {
    if (!isServerReady) return;

    const unsubscribe = audioServiceHealth.subscribe((status) => {
      setServiceHealth(status);
      setIsServiceAvailable(status.isAvailable);
    });

    // Iniciar verificación periódica solo cuando el servidor esté conectado
    audioServiceHealth.startPeriodicCheck();

    return () => {
      unsubscribe();
      // IMPORTANTE: Detener verificaciones periódicas cuando el componente se desmonte
      audioServiceHealth.stopPeriodicCheck();
    };
  }, [isServerReady]);

  // Animación de entrada del widget (siempre visible)
  useEffect(() => {
    Animated.spring(bounceAnim, {
      toValue: 1,
      friction: 4,
      tension: 40,
      useNativeDriver: true,
    }).start();
  }, []);

  // Animación de ondas cuando está grabando
  useEffect(() => {
    if (isRecording) {
      // Iniciar contador de tiempo
      recordingInterval.current = setInterval(() => {
        setRecordingTime((prev) => prev + 1);
      }, 1000);

      // Animaciones de onda
      const wave1 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim1, {
            toValue: 1.5,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim1, {
            toValue: 0.8,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      const wave2 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim2, {
            toValue: 1.8,
            duration: 2500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim2, {
            toValue: 0.8,
            duration: 2500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      const wave3 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim3, {
            toValue: 2.1,
            duration: 3000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim3, {
            toValue: 0.8,
            duration: 3000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      // Animación de brillo
      const glow = Animated.loop(
        Animated.sequence([
          Animated.timing(glowAnim, {
            toValue: 1,
            duration: 1500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(glowAnim, {
            toValue: 0,
            duration: 1500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      wave1.start();
      wave2.start();
      wave3.start();
      glow.start();

      // Fade in de las ondas
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();

      return () => {
        wave1.stop();
        wave2.stop();
        wave3.stop();
        glow.stop();
        if (recordingInterval.current) {
          clearInterval(recordingInterval.current);
        }
        setRecordingTime(0);
      };
    } else {
      // Fade out de las ondas
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }).start();
      waveAnim1.setValue(0.8);
      waveAnim2.setValue(0.8);
      waveAnim3.setValue(0.8);
      glowAnim.setValue(0);
    }
  }, [isRecording]);

  // Animación de procesamiento
  useEffect(() => {
    if (isProcessing || isPreparing) {
      const spin = Animated.loop(
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 1500,
          easing: Easing.bezier(0.645, 0.045, 0.355, 1),
          useNativeDriver: true,
        }),
      );
      spin.start();
      return () => {
        spin.stop();
        rotateAnim.setValue(0);
      };
    }
  }, [isProcessing, isPreparing]);

  // Estado para evitar llamadas duplicadas
  const hasCompletedRef = useRef(false);

  // Efecto cuando se completa la grabación
  useEffect(() => {
    if (
      audioUri &&
      transcription &&
      !isProcessing &&
      !hasCompletedRef.current
    ) {
      hasCompletedRef.current = true;

      // Reset primero para evitar loops
      resetRecording();

      // Luego llamar a onRecordingComplete
      onRecordingComplete(audioUri, transcription);

      // Resetear el flag después de un tiempo
      setTimeout(() => {
        hasCompletedRef.current = false;
      }, 1000);
    }
  }, [
    audioUri,
    transcription,
    isProcessing,
    onRecordingComplete,
    resetRecording,
  ]);

  // Efecto para manejar errores
  useEffect(() => {
    if (error) {
      onError(error);
    }
  }, [error, onError]);

  const handlePress = async () => {
    // Verificar disponibilidad del servicio
    if (!isServiceAvailable) {
      // Animación de "shake" para indicar que no está disponible
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 0.9,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();

      onError(serviceHealth.message || 'Servicio de voz no disponible');
      return;
    }

    // Prevenir múltiples clics mientras procesa
    if (isProcessing || isPreparing) {
      return;
    }

    // Animación de presión más suave
    Animated.sequence([
      Animated.spring(scaleAnim, {
        toValue: 0.85,
        friction: 3,
        tension: 40,
        useNativeDriver: true,
      }),
      Animated.spring(scaleAnim, {
        toValue: 1,
        friction: 3,
        tension: 40,
        useNativeDriver: true,
      }),
    ]).start();

    try {
      if (isRecording) {
        await stopRecording();
      } else {
        await startRecording();
      }
    } catch (err) {}
  };

  const rotateInterpolate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  };

  const getIcon = () => {
    if (isRecording) {
      return <MaterialIcons name="stop" size={30} color="white" />;
    }
    return <MaterialIcons name="mic" size={30} color="white" />;
  };

  const getBackgroundColor = () => {
    if (!isServiceAvailable) return '#B0B0B0'; // Gris más suave
    if (isProcessing || isPreparing) return theme.colors.secondary;
    if (isRecording) return '#FF3B30'; // Rojo vibrante
    return theme.colors.primary;
  };

  return (
    <Animated.View
      style={[
        styles.container,
        {
          transform: [
            {
              translateY: bounceAnim.interpolate({
                inputRange: [0, 1],
                outputRange: [100, 0],
              }),
            },
            { scale: bounceAnim },
          ],
          opacity: bounceAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [0, isServiceAvailable ? 1 : 0.8],
          }),
        },
      ]}
    >
      {/* Ondas animadas de fondo */}
      {isRecording && (
        <View style={styles.wavesContainer}>
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim1 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.1],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim2 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.15],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim3 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.2],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
        </View>
      )}

      {/* Contador de tiempo */}
      {isRecording && (
        <Animated.View
          style={[
            styles.timerContainer,
            {
              opacity: fadeAnim,
              transform: [
                {
                  translateY: fadeAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [-10, 0],
                  }),
                },
              ],
            },
          ]}
        >
          <View style={[styles.timerBadge, { backgroundColor: '#FF3B30' }]}>
            <View style={styles.recordingDot} />
            <Text style={styles.timerText}>{formatTime(recordingTime)}</Text>
          </View>
        </Animated.View>
      )}

      {/* Indicador de servicio no disponible */}
      {!isServiceAvailable && (
        <View
          style={[
            styles.disabledIndicator,
            { backgroundColor: theme.colors.error },
          ]}
        >
          <MaterialIcons name="cloud-off" size={14} color="white" />
        </View>
      )}

      <TouchableOpacity
        onPress={handlePress}
        disabled={isProcessing || isPreparing || !isServiceAvailable}
        activeOpacity={0.9}
      >
        <Animated.View
          style={[
            styles.buttonContainer,
            {
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          {/* Brillo de fondo cuando graba */}
          {isRecording && (
            <Animated.View
              style={[
                styles.glowEffect,
                {
                  backgroundColor: '#FF3B30',
                  opacity: glowAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.3, 0.6],
                  }),
                  transform: [
                    {
                      scale: glowAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [1, 1.2],
                      }),
                    },
                  ],
                },
              ]}
            />
          )}

          <View
            style={[
              styles.button,
              {
                backgroundColor: getBackgroundColor(),
                ...Platform.select({
                  web: {
                    boxShadow: !isServiceAvailable
                      ? 'none'
                      : isRecording
                        ? '0px 2px 8px rgba(255, 59, 48, 0.4)'
                        : `0px 2px 8px ${theme.colors.primary}40`,
                  },
                  default: {
                    shadowColor: !isServiceAvailable
                      ? 'transparent'
                      : isRecording
                        ? '#FF3B30'
                        : theme.colors.primary,
                    shadowOpacity: !isServiceAvailable
                      ? 0
                      : isRecording
                        ? 0.4
                        : 0.25,
                  },
                }),
              },
            ]}
          >
            {isProcessing || isPreparing ? (
              <Animated.View
                style={{
                  transform: [{ rotate: rotateInterpolate }],
                }}
              >
                <MaterialCommunityIcons name="brain" size={30} color="white" />
              </Animated.View>
            ) : (
              getIcon()
            )}
          </View>
        </Animated.View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    bottom: 30,
    right: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  wavesContainer: {
    position: 'absolute',
    alignItems: 'center',
    justifyContent: 'center',
  },
  wave: {
    position: 'absolute',
    width: 120,
    height: 120,
    borderRadius: 60,
  },
  buttonContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  button: {
    width: 72,
    height: 72,
    borderRadius: 36,
    alignItems: 'center',
    justifyContent: 'center',
    elevation: 8,
    ...Platform.select({
      web: {
        boxShadow: '0px 2px 8px rgba(0, 0, 0, 0.25)',
      },
      default: {
        shadowOffset: { width: 0, height: 2 },
        shadowRadius: 8,
      },
    }),
    zIndex: 10,
  },
  glowEffect: {
    position: 'absolute',
    width: 80,
    height: 80,
    borderRadius: 40,
    zIndex: 5,
  },
  timerContainer: {
    position: 'absolute',
    top: -45,
    alignItems: 'center',
  },
  timerBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    gap: 6,
  },
  recordingDot: {
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: 'white',
    opacity: 0.9,
  },
  timerText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  disabledIndicator: {
    position: 'absolute',
    top: 0,
    right: 0,
    width: 26,
    height: 26,
    borderRadius: 13,
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 20,
    elevation: 12,
    borderWidth: 2,
    borderColor: 'white',
  },
});

================
File: app/src/modules/customers/components/CustomerFormModal.tsx
================
import React, { useEffect, useState } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Customer, Address } from '../types/customer.types';
import {
  CustomerFormInputs,
  customerFormSchema,
} from '../schema/customer.schema';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import { DateTimePickerSafe } from '@/app/components/DateTimePickerSafe';
import PhoneNumberInput from '@/app/components/common/PhoneNumberInput';
import { useGetAddressesByCustomer } from '../hooks/useCustomersQueries';
import AddressFormModal from './AddressFormModal';
import { addressesService } from '../services/addressesService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

interface CustomerFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: CustomerFormInputs) => Promise<void>;
  editingItem: Customer | null;
  isSubmitting: boolean;
}

export default function CustomerFormModal({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}: CustomerFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showAddressModal, setShowAddressModal] = useState(false);
  const [editingAddress, setEditingAddress] = useState<Address | null>(null);
  const [isSubmittingAddress, setIsSubmittingAddress] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [tempDate, setTempDate] = useState<Date>(new Date());
  const [dateOnChange, setDateOnChange] = useState<
    ((value: string) => void) | null
  >(null);
  const { showSnackbar } = useSnackbarStore();

  // Query para obtener direcciones del cliente
  const { data: addresses = [], refetch: refetchAddresses } =
    useGetAddressesByCustomer(editingItem?.id || '', {
      enabled: !!editingItem?.id,
    });

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    watch,
  } = useForm<CustomerFormInputs>({
    resolver: zodResolver(customerFormSchema),
    defaultValues: {
      firstName: '',
      lastName: '',
      whatsappPhoneNumber: '',
      email: '',
      birthDate: '',
      isActive: true,
      isBanned: false,
      banReason: '',
    },
  });

  useEffect(() => {
    if (editingItem) {
      reset({
        firstName: editingItem.firstName,
        lastName: editingItem.lastName,
        whatsappPhoneNumber: editingItem.whatsappPhoneNumber || '',
        email: editingItem.email || '',
        birthDate: editingItem.birthDate
          ? new Date(editingItem.birthDate).toISOString().split('T')[0]
          : '',
        isActive: editingItem.isActive,
        isBanned: editingItem.isBanned || false,
        banReason: editingItem.banReason || '',
      });
    } else {
      reset({
        firstName: '',
        lastName: '',
        whatsappPhoneNumber: '',
        email: '',
        birthDate: '',
        isActive: true,
        isBanned: false,
        banReason: '',
      });
    }
  }, [editingItem, reset]);

  const isBanned = watch('isBanned');

  const handleAddressSubmit = async (data: any) => {
    try {
      setIsSubmittingAddress(true);
      if (editingAddress) {
        await addressesService.update(editingAddress.id, data);
        showSnackbar({ message: 'Dirección actualizada', type: 'success' });
      } else if (editingItem) {
        await addressesService.create(editingItem.id, data);
        showSnackbar({ message: 'Dirección agregada', type: 'success' });
      }
      await refetchAddresses();
      setShowAddressModal(false);
      setEditingAddress(null);
    } catch (error) {
      showSnackbar({ message: 'Error al guardar la dirección', type: 'error' });
    } finally {
      setIsSubmittingAddress(false);
    }
  };

  const handleFormSubmit = async (data: CustomerFormInputs) => {
    // Limpiar campos vacíos antes de enviar
    const cleanedData = {
      ...data,
      email: data.email || undefined,
      birthDate: data.birthDate || undefined,
      banReason: data.banReason || undefined,
    };

    // El número ya viene completo desde nuestro componente
    await onSubmit(cleanedData);
  };

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.primary },
              ]}
            >
              <View style={styles.headerLeft}>
                <Avatar.Icon
                  size={32}
                  icon={editingItem ? 'account-edit' : 'account-plus'}
                  style={[
                    styles.headerIcon,
                    { backgroundColor: theme.colors.onPrimary + '20' },
                  ]}
                  color={theme.colors.onPrimary}
                />
                <View style={styles.headerTextContainer}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onPrimary },
                    ]}
                    variant="titleMedium"
                  >
                    {editingItem ? 'Editar Cliente' : 'Nuevo Cliente'}
                  </Text>
                </View>
              </View>
              <IconButton
                icon="close"
                size={24}
                onPress={onDismiss}
                disabled={isSubmitting}
                iconColor={theme.colors.onPrimary}
              />
            </View>

            <ScrollView
              style={styles.formContainer}
              showsVerticalScrollIndicator={false}
              keyboardShouldPersistTaps="handled"
            >
              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información Personal
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.requiredChip}
                    textStyle={styles.requiredChipText}
                  >
                    Requerido
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="firstName"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Nombre"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.firstName}
                        mode="outlined"
                        placeholder="Ej: Juan"
                        left={<TextInput.Icon icon="account" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.firstName && (
                        <HelperText type="error" visible={!!errors.firstName}>
                          {errors.firstName.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="lastName"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Apellido"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.lastName}
                        mode="outlined"
                        placeholder="Ej: Pérez"
                        left={<TextInput.Icon icon="account" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.lastName && (
                        <HelperText type="error" visible={!!errors.lastName}>
                          {errors.lastName.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información de Contacto
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.optionalChip}
                    textStyle={styles.optionalChipText}
                  >
                    Opcional
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="whatsappPhoneNumber"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.inputContainer}>
                      <PhoneNumberInput
                        value={value || ''}
                        onChange={onChange}
                        error={!!errors.whatsappPhoneNumber}
                        helperText={errors.whatsappPhoneNumber?.message}
                        placeholder="Teléfono"
                      />
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="email"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Correo electrónico"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.email}
                        mode="outlined"
                        placeholder="juan@example.com"
                        keyboardType="email-address"
                        autoCapitalize="none"
                        left={<TextInput.Icon icon="email" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.email && (
                        <HelperText type="error" visible={!!errors.email}>
                          {errors.email.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="birthDate"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.inputContainer}>
                      <AnimatedLabelSelector
                        label="Fecha de nacimiento"
                        value={
                          value
                            ? format(new Date(value), "d 'de' MMMM 'de' yyyy", {
                                locale: es,
                              })
                            : ''
                        }
                        onPress={() => {
                          setTempDate(value ? new Date(value) : new Date());
                          setDateOnChange(() => onChange);
                          setShowDatePicker(true);
                        }}
                        error={!!errors.birthDate}
                      />
                      {errors.birthDate && (
                        <HelperText type="error" visible={!!errors.birthDate}>
                          {errors.birthDate.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Estado
                  </Text>
                </View>

                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <Surface style={styles.switchContainer} elevation={1}>
                      <View style={styles.switchContent}>
                        <View style={styles.switchTextContainer}>
                          <Text style={styles.switchLabel} variant="bodyLarge">
                            Cliente activo
                          </Text>
                        </View>
                        <Switch
                          value={value}
                          onValueChange={onChange}
                          color={theme.colors.primary}
                        />
                      </View>
                    </Surface>
                  )}
                />

                <Controller
                  control={control}
                  name="isBanned"
                  render={({ field: { onChange, value } }) => (
                    <Surface
                      style={[styles.switchContainer, styles.bannedContainer]}
                      elevation={1}
                    >
                      <View style={styles.switchContent}>
                        <View style={styles.switchTextContainer}>
                          <Text style={styles.switchLabel} variant="bodyLarge">
                            Cliente baneado
                          </Text>
                          <Text
                            style={styles.switchDescription}
                            variant="bodySmall"
                          >
                            Los clientes baneados no pueden realizar pedidos
                          </Text>
                        </View>
                        <Switch
                          value={value}
                          onValueChange={onChange}
                          color={theme.colors.error}
                        />
                      </View>
                    </Surface>
                  )}
                />

                {isBanned && (
                  <>
                    <Controller
                      control={control}
                      name="banReason"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View
                          style={[
                            styles.inputContainer,
                            styles.banReasonContainer,
                          ]}
                        >
                          <TextInput
                            label="Razón del baneo"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            mode="outlined"
                            placeholder="Ej: Comportamiento inapropiado"
                            multiline
                            numberOfLines={2}
                            left={<TextInput.Icon icon="alert-circle" />}
                            outlineStyle={styles.inputOutline}
                            outlineColor={theme.colors.error}
                            activeOutlineColor={theme.colors.error}
                          />
                        </View>
                      )}
                    />

                    {editingItem?.bannedAt && (
                      <Surface style={styles.infoCard} elevation={1}>
                        <View style={styles.infoCardContent}>
                          <IconButton
                            icon="calendar-clock"
                            size={20}
                            iconColor={theme.colors.error}
                          />
                          <View style={styles.infoText}>
                            <Text
                              variant="labelMedium"
                              style={styles.infoLabel}
                            >
                              Fecha de baneo
                            </Text>
                            <Text variant="bodyMedium" style={styles.infoValue}>
                              {new Date(editingItem.bannedAt).toLocaleString()}
                            </Text>
                          </View>
                        </View>
                      </Surface>
                    )}
                  </>
                )}
              </View>

              {/* Sección de WhatsApp - Solo en modo edición */}
              {editingItem && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Información de WhatsApp
                    </Text>
                  </View>

                  <Surface style={styles.whatsappCard} elevation={1}>
                    <View style={styles.whatsappRow}>
                      <View style={styles.whatsappStat}>
                        <Icon
                          source="message-text"
                          size={20}
                          color={theme.colors.primary}
                        />
                        <View style={styles.whatsappStatContent}>
                          <Text
                            variant="bodySmall"
                            style={styles.whatsappLabel}
                          >
                            Mensajes totales
                          </Text>
                          <Text
                            variant="titleMedium"
                            style={styles.whatsappValue}
                          >
                            {editingItem.whatsappMessageCount || 0}
                          </Text>
                        </View>
                      </View>

                      <View style={styles.whatsappDivider} />

                      <View style={styles.whatsappStat}>
                        <Icon
                          source="clock-outline"
                          size={20}
                          color={theme.colors.primary}
                        />
                        <View style={styles.whatsappStatContent}>
                          <Text
                            variant="bodySmall"
                            style={styles.whatsappLabel}
                          >
                            Último mensaje
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={styles.whatsappValue}
                          >
                            {editingItem.lastWhatsappMessageTime
                              ? new Date(
                                  editingItem.lastWhatsappMessageTime,
                                ).toLocaleDateString()
                              : 'Sin mensajes'}
                          </Text>
                        </View>
                      </View>
                    </View>
                  </Surface>
                </View>
              )}

              {/* Sección de Stripe - Solo en modo edición */}
              {editingItem?.stripeCustomerId && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Información de Pago
                    </Text>
                  </View>

                  <Surface style={styles.stripeCard} elevation={1}>
                    <View style={styles.stripeContent}>
                      <Icon
                        source="credit-card"
                        size={24}
                        color={theme.colors.primary}
                      />
                      <View style={styles.stripeInfo}>
                        <Text variant="bodySmall" style={styles.stripeLabel}>
                          Stripe Customer ID
                        </Text>
                        <Text
                          variant="bodyMedium"
                          style={styles.stripeValue}
                          selectable
                        >
                          {editingItem.stripeCustomerId}
                        </Text>
                      </View>
                    </View>
                  </Surface>
                </View>
              )}

              {/* Sección de Direcciones - Solo en modo edición */}
              {editingItem && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Direcciones
                    </Text>
                    <Button
                      mode="text"
                      onPress={() => {
                        setEditingAddress(null);
                        setShowAddressModal(true);
                      }}
                      icon="plus"
                      compact
                    >
                      Agregar
                    </Button>
                  </View>

                  {addresses.length === 0 ? (
                    <Surface style={styles.emptyAddressContainer} elevation={0}>
                      <Text
                        style={styles.emptyAddressText}
                        variant="bodyMedium"
                      >
                        No hay direcciones registradas
                      </Text>
                    </Surface>
                  ) : (
                    <View style={styles.addressList}>
                      {addresses.map((address: Address) => (
                        <Surface
                          key={address.id}
                          style={styles.addressCard}
                          elevation={1}
                        >
                          <View style={styles.addressContent}>
                            <View style={styles.addressHeader}>
                              <IconButton
                                icon="map-marker"
                                size={20}
                                iconColor={theme.colors.primary}
                              />
                              <View style={styles.addressInfo}>
                                <Text
                                  style={styles.addressName}
                                  variant="titleSmall"
                                >
                                  {address.name}
                                </Text>
                                <Text
                                  style={styles.addressStreet}
                                  variant="bodyMedium"
                                >
                                  {address.street} {address.number}
                                  {address.interiorNumber &&
                                    `, ${address.interiorNumber}`}
                                </Text>
                                <Text
                                  style={styles.addressDetails}
                                  variant="bodySmall"
                                >
                                  {address.neighborhood}, {address.city},{' '}
                                  {address.state}
                                </Text>
                                {address.isDefault && (
                                  <Chip
                                    mode="flat"
                                    compact
                                    style={styles.defaultChip}
                                    textStyle={styles.defaultChipText}
                                  >
                                    Predeterminada
                                  </Chip>
                                )}
                              </View>
                            </View>
                            <View style={styles.addressActions}>
                              <IconButton
                                icon="pencil"
                                size={20}
                                onPress={() => {
                                  setEditingAddress(address);
                                  setShowAddressModal(true);
                                }}
                              />
                              <IconButton
                                icon="delete"
                                size={20}
                                iconColor={theme.colors.error}
                                onPress={async () => {
                                  try {
                                    await addressesService.remove(address.id);
                                    await refetchAddresses();
                                    showSnackbar({
                                      message: 'Dirección eliminada',
                                      type: 'success',
                                    });
                                  } catch (error) {
                                    showSnackbar({
                                      message: 'Error al eliminar la dirección',
                                      type: 'error',
                                    });
                                  }
                                }}
                              />
                            </View>
                          </View>
                        </Surface>
                      ))}
                    </View>
                  )}
                </View>
              )}

              {/* Espacio adicional para el teclado */}
              <View style={{ height: 10 }} />
            </ScrollView>

            <Surface style={styles.buttonContainer} elevation={2}>
              <Button
                onPress={onDismiss}
                disabled={isSubmitting}
                style={[styles.button, styles.cancelButton]}
                textColor={theme.colors.onSecondaryContainer}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleSubmit(handleFormSubmit)}
                disabled={isSubmitting}
                loading={isSubmitting}
                style={[styles.button, styles.confirmButton]}
                buttonColor={theme.colors.primary}
              >
                {editingItem ? 'Guardar' : 'Crear'}
              </Button>
            </Surface>
          </Surface>
        </Modal>
      </Portal>

      {/* Modal de Dirección */}
      {editingItem && (
        <AddressFormModal
          visible={showAddressModal}
          onDismiss={() => {
            setShowAddressModal(false);
            setEditingAddress(null);
          }}
          onSubmit={handleAddressSubmit}
          editingItem={editingAddress}
          isSubmitting={isSubmittingAddress}
          customerId={editingItem.id}
        />
      )}

      {/* Date Picker */}
      <DateTimePickerSafe
        visible={showDatePicker}
        mode="date"
        value={tempDate}
        onConfirm={(date) => {
          if (dateOnChange) {
            dateOnChange(date.toISOString().split('T')[0]);
          }
          setShowDatePicker(false);
        }}
        onCancel={() => setShowDatePicker(false)}
        title="Fecha de nacimiento"
        maximumDate={new Date()}
      />
    </>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? 20 : 10,
      justifyContent: 'center',
      alignItems: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      maxHeight: '95%',
      minHeight: responsive.isTablet ? 600 : '80%',
      width: responsive.isTablet ? '85%' : '100%',
      maxWidth: responsive.isTablet ? 800 : undefined,
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
      paddingVertical: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: responsive.isTablet
        ? theme.spacing.s * 0.7
        : theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
      fontSize: responsive.isTablet ? 16 : 18,
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
      paddingTop: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.s * 0.7
        : theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    requiredChipText: {
      color: theme.colors.onErrorContainer,
      fontSize: responsive.isTablet ? 10 : 11,
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 10 : 11,
    },
    inputContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.xs * 0.7 : theme.spacing.xs,
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 14 : 16,
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    bannedContainer: {
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    banReasonContainer: {
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    infoCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      backgroundColor: theme.colors.errorContainer,
    },
    infoCardContent: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    infoText: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    infoLabel: {
      color: theme.colors.onErrorContainer,
      opacity: 0.8,
      fontSize: responsive.isTablet ? 11 : 12,
    },
    infoValue: {
      color: theme.colors.onErrorContainer,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    whatsappCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      backgroundColor: theme.colors.primaryContainer + '20',
    },
    whatsappRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    whatsappStat: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    whatsappStatContent: {
      flex: 1,
    },
    whatsappLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 12,
    },
    whatsappValue: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginTop: 2,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    whatsappDivider: {
      width: 1,
      height: responsive.isTablet ? 35 : 40,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
    },
    stripeCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
    },
    stripeContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
    },
    stripeInfo: {
      flex: 1,
    },
    stripeLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 12,
      marginBottom: responsive.isTablet ? 3 : 4,
    },
    stripeValue: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontFamily: 'monospace',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      borderBottomLeftRadius: theme.roundness * 2,
      borderBottomRightRadius: theme.roundness * 2,
    },
    button: {
      flex: 1,
      maxWidth: 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    addressList: {
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    addressCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
    },
    addressContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    addressHeader: {
      flexDirection: 'row',
      flex: 1,
    },
    addressInfo: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    addressName: {
      fontWeight: '600',
      color: theme.colors.primary,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    addressStreet: {
      fontWeight: '500',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    addressDetails: {
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
      fontSize: responsive.isTablet ? 12 : 13,
    },
    addressActions: {
      flexDirection: 'row',
    },
    defaultChip: {
      marginTop: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
      backgroundColor: theme.colors.primaryContainer,
    },
    defaultChipText: {
      color: theme.colors.onPrimaryContainer,
      fontSize: responsive.isTablet ? 9 : 10,
    },
    emptyAddressContainer: {
      padding: responsive.isTablet ? theme.spacing.l * 0.7 : theme.spacing.l,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
    },
    emptyAddressText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 13 : 14,
    },
  });

================
File: app/src/modules/menu/components/ProductFormModal.tsx
================
import React, { useEffect, useMemo, useState, useCallback } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Button,
  TextInput,
  Text,
  ActivityIndicator,
  Switch,
  HelperText,
  Divider,
  IconButton,
  Card,
  Checkbox,
  TouchableRipple,
} from 'react-native-paper';
import {
  useForm,
  Controller,
  useFieldArray,
  SubmitHandler,
} from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';

import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  ProductFormInputs,
  productSchema,
  updateProductSchema,
  ProductVariant,
  Product,
} from '../schema/products.schema';
import { ModifierGroup } from '../../modifiers/schema/modifierGroup.schema';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import VariantFormModal from './VariantFormModal';
import CustomImagePicker, {
  FileObject,
} from '@/app/components/common/CustomImagePicker';
import { ImageUploadService } from '@/app/lib/imageUploadService';
import { getImageUrl } from '@/app/lib/imageUtils';
import { useModifierGroupsQuery } from '../../modifiers/hooks/useModifierGroupsQuery';
import { modifierService } from '../../modifiers/services/modifierService';
import { useGetPreparationScreens } from '../../preparationScreens/hooks/usePreparationScreensQueries';
import { Menu } from 'react-native-paper';

interface ProductFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: ProductFormInputs,
    photoId: string | null | undefined,
    file?: FileObject | null,
  ) => Promise<void>;
  initialData?: Product | null;
  isSubmitting: boolean;
  productId?: string | null;
  subcategoryId: string;
}

function ProductFormModal({
  visible,
  onDismiss,
  onSubmit,
  initialData,
  isSubmitting,
  productId,
  subcategoryId,
}: ProductFormModalProps): React.ReactElement {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const isEditing = !!productId && !!initialData;

  const [isVariantModalVisible, setIsVariantModalVisible] = useState(false);
  const [editingVariantIndex, setEditingVariantIndex] = useState<number | null>(
    null,
  );
  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(
    null,
  );
  const [isInternalImageUploading, setIsInternalImageUploading] =
    useState(false);
  const [groupModifiers, setGroupModifiers] = useState<Record<string, any[]>>(
    {},
  );
  const [priceInputValue, setPriceInputValue] = useState<string>('');
  const [preparationScreenMenuVisible, setPreparationScreenMenuVisible] =
    useState(false);

  const defaultValues = useMemo(
    (): ProductFormInputs => ({
      name: '',
      description: null,
      price: null,
      hasVariants: false,
      isActive: true,
      isPizza: false,
      subcategoryId: subcategoryId,
      photoId: null,
      estimatedPrepTime: 10,
      preparationScreenId: null,
      sortOrder: 0,
      variants: [],
      variantsToDelete: [],
      imageUri: null,
      modifierGroupIds: [],
    }),
    [subcategoryId],
  );

  const {
    control,
    handleSubmit,
    reset,
    watch,
    setValue,
    formState: { errors },
  } = useForm<ProductFormInputs>({
    resolver: zodResolver(initialData ? updateProductSchema : productSchema),
    defaultValues: defaultValues,
  });

  const {
    fields: variantFields,
    append: appendVariant,
    remove: removeVariant,
    update: updateVariant,
  } = useFieldArray({
    control,
    name: 'variants',
  });

  useEffect(() => {
    const loadInitialData = async () => {
      if (visible) {
        if (isEditing && initialData) {
          const initialPrice = initialData.price;
          const parsedPrice =
            initialPrice !== null &&
            initialPrice !== undefined &&
            !isNaN(parseFloat(String(initialPrice)))
              ? parseFloat(String(initialPrice))
              : null;

          // Procesar la URL de la imagen si existe
          let imageUrl = null;
          if (initialData.photo?.path) {
            try {
              imageUrl = await getImageUrl(initialData.photo.path);
            } catch (error) {
              imageUrl = initialData.photo.path; // Fallback al path original
            }
          }

          reset({
            name: initialData.name,
            description: initialData.description || null,
            price: parsedPrice,
            hasVariants: initialData.hasVariants,
            isActive: initialData.isActive,
            isPizza: initialData.isPizza ?? false,
            subcategoryId: initialData.subcategoryId,
            photoId: initialData.photo?.id ?? null,
            estimatedPrepTime: initialData.estimatedPrepTime,
            preparationScreenId: initialData.preparationScreenId || null,
            sortOrder: initialData.sortOrder ?? 0,
            variants: initialData.variants || [],
            variantsToDelete: [],
            imageUri: imageUrl,
            modifierGroupIds: [],
          });
          setLocalSelectedFile(null);
        } else {
          reset(defaultValues);
          setLocalSelectedFile(null);
        }
      }
    };

    loadInitialData();
  }, [visible, isEditing, initialData, reset, defaultValues, subcategoryId]);

  const hasVariants = watch('hasVariants');
  const currentImageUri = watch('imageUri');
  const priceValue = watch('price');

  useEffect(() => {
    setPriceInputValue(
      priceValue !== null && priceValue !== undefined
        ? priceValue.toString()
        : '',
    );
  }, [priceValue]);

  const { data: modifierGroupsResponse, isLoading: isLoadingGroups } =
    useModifierGroupsQuery({ isActive: true });

  const { data: preparationScreensResponse } = useGetPreparationScreens(
    {},
    { page: 1, limit: 50 },
  );
  const preparationScreens = preparationScreensResponse?.data || [];

  const allModifierGroups = modifierGroupsResponse?.data || [];

  useEffect(() => {
    const loadModifiers = async () => {
      const modifiersMap: Record<string, any[]> = {};

      for (const group of allModifierGroups) {
        try {
          const modifiers = await modifierService.findByGroupId(group.id);
          modifiersMap[group.id] = modifiers.filter((mod) => mod.isActive);
        } catch (error) {
          modifiersMap[group.id] = [];
        }
      }

      setGroupModifiers(modifiersMap);
    };

    if (allModifierGroups.length > 0) {
      loadModifiers();
    }
  }, [allModifierGroups]);

  useEffect(() => {
    if (visible) {
      if (isEditing && initialData?.modifierGroups) {
        if (Array.isArray(initialData.modifierGroups)) {
          const assignedIds = initialData.modifierGroups.map(
            (group: ModifierGroup) => group.id,
          );
          setValue('modifierGroupIds', assignedIds);
        } else {
          setValue('modifierGroupIds', []);
        }
      } else if (!isEditing) {
        setValue('modifierGroupIds', []);
      } else if (isEditing && !initialData?.modifierGroups) {
        setValue('modifierGroupIds', []);
      }
    }
  }, [visible, isEditing, initialData, setValue, reset, defaultValues]);

  const handleImageSelected = useCallback(
    (uri: string, file: FileObject) => {
      setValue('imageUri', uri, { shouldValidate: true, shouldDirty: true });
      setLocalSelectedFile(file);
    },
    [setValue],
  );

  const handleImageRemoved = useCallback(() => {
    setValue('imageUri', null, { shouldValidate: true, shouldDirty: true });
    setLocalSelectedFile(null);
  }, [setValue]);

  const processSubmit: SubmitHandler<ProductFormInputs> = async (formData) => {
    if (isSubmitting || isInternalImageUploading) return;

    let finalPhotoId: string | null | undefined = undefined;

    if (localSelectedFile) {
      setIsInternalImageUploading(true);
      try {
        const uploadResult =
          await ImageUploadService.uploadImage(localSelectedFile);
        if (uploadResult.success && uploadResult.photoId) {
          finalPhotoId = uploadResult.photoId;
        } else {
          throw new Error(
            uploadResult.error || 'La subida de la imagen falló.',
          );
        }
      } catch (error) {
        showSnackbar({
          message: `Error al subir imagen: ${getApiErrorMessage(error)}`,
          type: 'error',
        });
        setIsInternalImageUploading(false);
        return;
      } finally {
        setIsInternalImageUploading(false);
      }
    } else {
      finalPhotoId = await ImageUploadService.determinePhotoId(
        currentImageUri,
        initialData ?? undefined,
      );
    }

    const finalData = {
      ...formData,
      price: hasVariants ? null : formData.price,
      variants: hasVariants ? formData.variants : [],
    };

    await onSubmit(finalData, finalPhotoId, localSelectedFile);
    setLocalSelectedFile(null);
  };

  const showVariantModal = (index: number | null = null) => {
    setEditingVariantIndex(index);
    setIsVariantModalVisible(true);
  };

  const handleVariantSubmit = (variantData: ProductVariant) => {
    if (editingVariantIndex !== null) {
      const originalVariantId =
        initialData?.variants?.[editingVariantIndex]?.id;

      const priceAsNumber = Number(variantData.price);

      const dataToUpdate = {
        ...variantData,
        price: isNaN(priceAsNumber) ? 0 : priceAsNumber,
        ...(originalVariantId && { id: originalVariantId }),
      };

      const finalDataToUpdate =
        !originalVariantId && 'id' in dataToUpdate
          ? (({ id, ...rest }) => rest)(dataToUpdate)
          : dataToUpdate;

      updateVariant(editingVariantIndex, finalDataToUpdate as ProductVariant);
    } else {
      const { id, price, ...restNewVariantData } = variantData;
      const newPriceAsNumber = Number(price);
      const newVariantData = {
        ...restNewVariantData,
        price: isNaN(newPriceAsNumber) ? 0 : newPriceAsNumber,
      };
      appendVariant(newVariantData as ProductVariant);
    }
    setIsVariantModalVisible(false);
    setEditingVariantIndex(null);
  };

  const handleRemoveVariant = (index: number) => {
    const variantToRemove = variantFields[index];
    if (variantToRemove.id) {
      const currentToDelete = watch('variantsToDelete') || [];
      setValue('variantsToDelete', [...currentToDelete, variantToRemove.id]);
    }
    removeVariant(index);
  };

  const variantInitialData =
    editingVariantIndex !== null
      ? (variantFields[editingVariantIndex] as ProductVariant)
      : undefined;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting && !isInternalImageUploading}
      >
        <View style={styles.modalHeader}>
          <Text variant="titleLarge" style={styles.modalTitle}>
            {isEditing ? 'Editar Producto' : 'Nuevo Producto'}
          </Text>
        </View>

        <ScrollView contentContainerStyle={styles.scrollContent}>
          <Card style={styles.card}>
            <Card.Content>
              <View style={styles.imagePickerContainer}>
                <CustomImagePicker
                  value={currentImageUri}
                  onImageSelected={handleImageSelected}
                  onImageRemoved={handleImageRemoved}
                  isLoading={isInternalImageUploading}
                  disabled={isSubmitting}
                  size={150}
                  placeholderIcon="food-outline"
                  placeholderText="Imagen del producto"
                />
                {errors.imageUri && (
                  <HelperText type="error">
                    {errors.imageUri.message}
                  </HelperText>
                )}
              </View>

              <Controller
                control={control}
                name="name"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Nombre del Producto *"
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.name}
                    style={styles.input}
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.name && (
                <HelperText type="error" visible={!!errors.name}>
                  {errors.name.message}
                </HelperText>
              )}

              <Controller
                control={control}
                name="description"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Descripción"
                    value={value || ''}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.description}
                    style={styles.input}
                    disabled={isSubmitting}
                    multiline
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && (
                <HelperText type="error" visible={!!errors.description}>
                  {errors.description.message}
                </HelperText>
              )}

              <View style={styles.switchContainer}>
                <Text style={styles.label}>¿Tiene Variantes?</Text>
                <Controller
                  control={control}
                  name="hasVariants"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={(newValue) => {
                        onChange(newValue);
                        if (newValue) {
                          setValue('price', null, { shouldValidate: true });
                        }
                      }}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>

              {hasVariants && errors.price && (
                <HelperText type="error" visible={!!errors.price}>
                  {errors.price.message}
                </HelperText>
              )}

              {!hasVariants && (
                <>
                  <Controller
                    control={control}
                    name="price"
                    render={({ field }) => (
                      <TextInput
                        mode="outlined"
                        label="Precio *"
                        keyboardType="decimal-pad"
                        value={priceInputValue}
                        onChangeText={(text) => {
                          const formattedText = text.replace(/,/g, '.');

                          if (/^(\d*\.?\d*)$/.test(formattedText)) {
                            setPriceInputValue(formattedText);
                            if (formattedText === '') {
                              field.onChange(null);
                            } else if (formattedText !== '.') {
                              field.onChange(parseFloat(formattedText));
                            }
                          }
                        }}
                        error={!!errors.price}
                        disabled={isSubmitting || hasVariants}
                        style={styles.input}
                      />
                    )}
                  />
                  {errors.price && (
                    <HelperText type="error" visible={!!errors.price}>
                      {errors.price?.message || 'Precio inválido'}
                    </HelperText>
                  )}
                </>
              )}

              {hasVariants && (
                <View style={styles.variantsSection}>
                  <Divider style={styles.divider} />
                  <View style={styles.variantsHeader}>
                    <Text variant="titleMedium">Variantes</Text>
                    <Button
                      mode="contained-tonal"
                      icon="plus"
                      onPress={() => showVariantModal()}
                      disabled={isSubmitting}
                    >
                      Añadir
                    </Button>
                  </View>
                  {variantFields.length === 0 && (
                    <Text style={styles.noVariantsText}>
                      Aún no hay variantes añadidas.
                    </Text>
                  )}
                  {variantFields.map((field, index) => (
                    <Card
                      key={field.id || `new-${index}`}
                      style={[
                        styles.variantCard,
                        field.isActive === false && styles.variantCardInactive,
                      ]}
                    >
                      <View style={styles.variantContent}>
                        <View style={styles.variantInfo}>
                          <View style={styles.variantHeader}>
                            <Text
                              style={[
                                styles.variantName,
                                field.isActive === false &&
                                  styles.variantNameInactive,
                              ]}
                              numberOfLines={1}
                              ellipsizeMode="tail"
                            >
                              {field.name || 'Nueva Variante'}
                            </Text>
                            {field.isActive === false && (
                              <View style={styles.inactiveBadge}>
                                <Text style={styles.inactiveBadgeText}>
                                  Inactiva
                                </Text>
                              </View>
                            )}
                          </View>
                          <Text style={styles.variantPrice}>
                            $
                            {!isNaN(Number(field.price))
                              ? Number(field.price).toFixed(2)
                              : '0.00'}
                          </Text>
                        </View>
                        <View style={styles.variantActions}>
                          <IconButton
                            icon="pencil"
                            size={24}
                            onPress={() => showVariantModal(index)}
                            disabled={isSubmitting}
                            style={styles.variantActionButton}
                          />
                          <IconButton
                            icon="delete"
                            size={24}
                            onPress={() => handleRemoveVariant(index)}
                            iconColor={theme.colors.error}
                            disabled={isSubmitting}
                            style={styles.variantActionButton}
                          />
                        </View>
                      </View>
                    </Card>
                  ))}
                  {/* Mostrar error si hasVariants es true pero no hay variantes */}
                  {errors.variants?.message && (
                    <HelperText
                      type="error"
                      visible={!!errors.variants.message}
                    >
                      {errors.variants.message as string}
                    </HelperText>
                  )}
                  {/* También podría estar en root para errores de array */}
                  {errors.variants?.root?.message && (
                    <HelperText
                      type="error"
                      visible={!!errors.variants.root.message}
                    >
                      {errors.variants.root.message as string}
                    </HelperText>
                  )}
                </View>
              )}

              <Divider style={styles.divider} />

              <Controller
                control={control}
                name="estimatedPrepTime"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Tiempo Prep. Estimado (min)"
                    value={
                      value !== null && value !== undefined ? String(value) : ''
                    }
                    onChangeText={(text) =>
                      onChange(text ? parseInt(text, 10) : 0)
                    }
                    onBlur={onBlur}
                    error={!!errors.estimatedPrepTime}
                    style={styles.input}
                    keyboardType="numeric"
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.estimatedPrepTime && (
                <HelperText type="error" visible={!!errors.estimatedPrepTime}>
                  {errors.estimatedPrepTime.message}
                </HelperText>
              )}

              {/* Campo de Pantalla de Preparación */}
              <Controller
                control={control}
                name="preparationScreenId"
                render={({ field: { onChange, value } }) => (
                  <View>
                    <Menu
                      visible={preparationScreenMenuVisible}
                      onDismiss={() => setPreparationScreenMenuVisible(false)}
                      anchor={
                        <TextInput
                          label="Pantalla de Preparación"
                          value={
                            preparationScreens.find(
                              (screen) => screen.id === value,
                            )?.name || ''
                          }
                          onPress={() => setPreparationScreenMenuVisible(true)}
                          right={
                            value ? (
                              <TextInput.Icon
                                icon="close"
                                onPress={() => {
                                  onChange(null);
                                }}
                              />
                            ) : (
                              <TextInput.Icon
                                icon="chevron-down"
                                onPress={() =>
                                  setPreparationScreenMenuVisible(true)
                                }
                              />
                            )
                          }
                          editable={false}
                          error={!!errors.preparationScreenId}
                          style={styles.input}
                          disabled={isSubmitting}
                        />
                      }
                    >
                      {preparationScreens.map((screen) => (
                        <Menu.Item
                          key={screen.id}
                          onPress={() => {
                            onChange(screen.id);
                            setPreparationScreenMenuVisible(false);
                          }}
                          title={screen.name}
                        />
                      ))}
                    </Menu>
                  </View>
                )}
              />
              {errors.preparationScreenId && (
                <HelperText type="error" visible={!!errors.preparationScreenId}>
                  {errors.preparationScreenId.message}
                </HelperText>
              )}

              <Controller
                control={control}
                name="sortOrder"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Orden de visualización"
                    value={
                      value !== null && value !== undefined ? String(value) : ''
                    }
                    onChangeText={(text) =>
                      onChange(text ? parseInt(text, 10) : 0)
                    }
                    onBlur={onBlur}
                    error={!!errors.sortOrder}
                    style={styles.input}
                    keyboardType="numeric"
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.sortOrder && (
                <HelperText type="error" visible={!!errors.sortOrder}>
                  {errors.sortOrder.message}
                </HelperText>
              )}

              <View style={styles.switchContainer}>
                <Text style={styles.label}>Activo</Text>
                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>

              <View style={styles.switchContainer}>
                <Text style={styles.label}>Es Pizza</Text>
                <Controller
                  control={control}
                  name="isPizza"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>

              <Divider style={styles.divider} />

              <View style={styles.modifierGroupSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>
                  Grupos de Modificadores
                </Text>
                {isLoadingGroups ? (
                  <ActivityIndicator
                    animating={true}
                    style={{
                      marginVertical: responsive.spacing(theme.spacing.m),
                    }}
                  />
                ) : allModifierGroups.length === 0 ? (
                  <Text style={styles.noItemsText}>
                    No hay grupos de modificadores disponibles.
                  </Text>
                ) : (
                  <Controller
                    control={control}
                    name="modifierGroupIds"
                    render={({ field: { onChange, value } }) => {
                      const currentIds = Array.isArray(value) ? value : []; // Asegurar que sea array
                      const availableGroups = allModifierGroups; // Ya es un array de ModifierGroup

                      return (
                        <>
                          {availableGroups.map((group: ModifierGroup) => {
                            const isSelected = currentIds.includes(group.id);
                            const modifiers = groupModifiers[group.id] || [];

                            return (
                              <TouchableRipple
                                key={group.id}
                                onPress={() => {
                                  const newIds = isSelected
                                    ? currentIds.filter((id) => id !== group.id)
                                    : [...currentIds, group.id];
                                  onChange(newIds);
                                }}
                                disabled={isSubmitting}
                                style={styles.modifierGroupTouchable}
                              >
                                <View style={styles.modifierGroupContent}>
                                  <Checkbox
                                    status={
                                      isSelected ? 'checked' : 'unchecked'
                                    }
                                    disabled={isSubmitting}
                                  />
                                  <View
                                    style={styles.modifierGroupTextContainer}
                                  >
                                    <Text style={styles.modifierGroupName}>
                                      {group.name}
                                    </Text>
                                    {modifiers.length > 0 && (
                                      <View
                                        style={styles.modifiersListContainer}
                                      >
                                        {modifiers.map((modifier, index) => (
                                          <Text
                                            key={modifier.id}
                                            style={styles.modifierItem}
                                          >
                                            {modifier.isDefault && '✓ '}
                                            {modifier.name}
                                            {index < modifiers.length - 1 &&
                                              ', '}
                                          </Text>
                                        ))}
                                      </View>
                                    )}
                                    {modifiers.length === 0 && (
                                      <Text style={styles.noModifiersText}>
                                        Sin modificadores activos
                                      </Text>
                                    )}
                                  </View>
                                </View>
                              </TouchableRipple>
                            );
                          })}
                        </>
                      );
                    }}
                  />
                )}
                {errors.modifierGroupIds && (
                  <HelperText type="error" visible={!!errors.modifierGroupIds}>
                    {errors.modifierGroupIds.message as string}
                  </HelperText>
                )}
              </View>
            </Card.Content>
          </Card>
        </ScrollView>

        {(isSubmitting || isInternalImageUploading) && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator
              animating={true}
              size="large"
              color={theme.colors.primary}
            />
          </View>
        )}

        <View style={styles.modalActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[styles.formButton, styles.cancelButton]}
            disabled={isSubmitting || isInternalImageUploading}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSubmit(processSubmit)}
            loading={isSubmitting || isInternalImageUploading}
            disabled={isSubmitting || isInternalImageUploading}
            style={styles.formButton}
          >
            {isEditing ? 'Guardar' : 'Crear'}
          </Button>
        </View>
      </Modal>

      <VariantFormModal
        visible={isVariantModalVisible}
        onDismiss={() => setIsVariantModalVisible(false)}
        onSubmit={handleVariantSubmit}
        initialData={variantInitialData}
      />
    </Portal>
  );
}

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: responsive.spacing(20),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(40)
        : responsive.spacing(20),
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: responsive.isTablet ? '92%' : '90%',
      minHeight: responsive.isTablet ? 650 : undefined,
      maxWidth: responsive.isTablet ? 700 : 500,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopLeftRadius: theme.roundness * 2,
      borderTopRightRadius: theme.roundness * 2,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: 'bold',
      textAlign: 'center',
      fontSize: responsive.isTablet ? 20 : 22,
    },
    scrollContent: {
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
    },
    card: {
      backgroundColor: theme.colors.surface,
      elevation: 1,
    },
    input: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
    },
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 16,
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    divider: {
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantsSection: {
      marginTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantsHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantCard: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.elevation.level1,
      paddingVertical: responsive.isTablet
        ? 6
        : responsive.spacing(theme.spacing.xs),
      paddingLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingRight: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.xs),
    },
    variantCardInactive: {
      opacity: 0.7,
      backgroundColor: theme.colors.surfaceVariant,
    },
    variantContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    variantInfo: {
      flex: 1,
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.isTablet ? 1 : 2,
    },
    variantName: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '500',
      color: theme.colors.onSurface,
      flex: 1,
    },
    variantNameInactive: {
      color: theme.colors.onSurfaceVariant,
    },
    variantPrice: {
      fontSize: responsive.isTablet ? 12 : 14,
      color: theme.colors.primary,
      fontWeight: '600',
    },
    inactiveBadge: {
      backgroundColor: theme.colors.errorContainer,
      paddingHorizontal: responsive.isTablet
        ? 6
        : responsive.spacing(theme.spacing.xs),
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: 4,
      marginLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.xs),
    },
    inactiveBadgeText: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onErrorContainer,
      fontWeight: '600',
    },
    variantActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? 4 : 8,
    },
    variantActionButton: {
      margin: 0,
    },
    noVariantsText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    imagePickerContainer: {
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
    },
    modifierGroupSection: {
      marginTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    sectionTitle: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      marginLeft: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.xs),
      fontSize: responsive.isTablet ? 16 : 18,
    },
    noItemsText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    modifierGroupTouchable: {
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      marginHorizontal: responsive.isTablet
        ? -responsive.spacing(theme.spacing.s)
        : -responsive.spacing(theme.spacing.m),
    },
    modifierGroupContent: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    modifierGroupTextContainer: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    modifierGroupName: {
      fontSize: responsive.isTablet ? 13 : 15,
      color: theme.colors.onSurface,
    },
    modifiersList: {
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: responsive.isTablet ? 1 : 2,
    },
    modifiersListContainer: {
      marginTop: responsive.isTablet ? 2 : 4,
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: responsive.isTablet ? 2 : 4,
    },
    modifierItem: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      lineHeight: responsive.isTablet ? 15 : 18,
    },
    noModifiersText: {
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: responsive.isTablet ? 2 : 4,
      opacity: 0.7,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    formButton: {
      borderRadius: theme.roundness * 2,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      minWidth: responsive.isTablet ? 100 : 120,
    },
    cancelButton: {
      marginRight: 0,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 10,
      borderRadius: theme.roundness * 2,
    },
  });

export default ProductFormModal;

================
File: app/src/modules/orderFinalization/services/orderFinalizationService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  OrderForFinalization,
  OrderForFinalizationList,
  FinalizeOrdersPayload,
} from '../types/orderFinalization.types';

export const orderFinalizationService = {
  async getOrdersForFinalizationList(): Promise<OrderForFinalizationList[]> {
    const response = await apiClient.get(
      API_PATHS.ORDERS_FOR_FINALIZATION_LIST,
    );
    return response.data;
  },

  async getOrderForFinalizationDetail(
    orderId: string,
  ): Promise<OrderForFinalization> {
    const response = await apiClient.get(
      API_PATHS.ORDERS_FOR_FINALIZATION_DETAIL.replace(':id', orderId),
    );
    return response.data;
  },

  async finalizeOrders(payload: FinalizeOrdersPayload): Promise<void> {
    await apiClient.patch(API_PATHS.ORDERS_FINALIZE_MULTIPLE, payload);
  },

  async quickFinalizeMultipleOrders(
    orderIds: string[],
  ): Promise<{ message: string; ordersWithWarnings: string[] }> {
    const response = await apiClient.post(
      API_PATHS.ORDERS_QUICK_FINALIZE_MULTIPLE,
      { orderIds },
    );
    return response.data;
  },

  async printTicket(
    orderId: string,
    params: { printerId: string; ticketType: 'GENERAL' | 'BILLING' },
  ): Promise<void> {
    await apiClient.post(
      API_PATHS.ORDERS_PRINT_TICKET.replace(':orderId', orderId),
      params,
    );
  },
};

================
File: app/src/modules/orders/screens/OrdersScreen.tsx
================
import React from 'react';
import { StyleSheet, View, ScrollView, RefreshControl } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Button, ActivityIndicator, Text } from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useAppTheme } from '@/app/styles/theme';
import type { OrdersStackParamList } from '@/app/navigation/types';
import { useGlobalShift } from '@/app/hooks/useGlobalShift';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';

function OrdersScreen() {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const navigation =
    useNavigation<NativeStackNavigationProp<OrdersStackParamList>>();

  const { data: shift, isLoading, isFetching, refetch } = useGlobalShift();
  const [isManualRefreshing, setIsManualRefreshing] = React.useState(false);

  // Manejar el pull to refresh
  const handleRefresh = React.useCallback(async () => {
    setIsManualRefreshing(true);
    await refetch();
    setIsManualRefreshing(false);
  }, [refetch]);

  const handleOpenOrders = () => {
    if (shift && shift.status === 'OPEN') {
      navigation.navigate(NAVIGATION_PATHS.OPEN_ORDERS);
    }
  };

  const handleCreateOrder = () => {
    if (shift && shift.status === 'OPEN') {
      navigation.navigate(NAVIGATION_PATHS.CREATE_ORDER);
    }
  };

  const isShiftOpen = shift && shift.status === 'OPEN';

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView
        style={styles.scrollView}
        refreshControl={
          <RefreshControl
            refreshing={isManualRefreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={styles.scrollContent}
      >
        <View style={styles.content}>
          {/* Indicador de carga */}
          {(isLoading || (isFetching && !isManualRefreshing)) && (
            <View style={styles.loadingIndicator}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text variant="bodySmall" style={styles.loadingText}>
                Actualizando estado del turno...
              </Text>
            </View>
          )}
          {/* Botón Crear Orden */}
          <Button
            mode="contained"
            onPress={handleCreateOrder}
            style={[styles.button, !isShiftOpen && styles.buttonDisabled]}
            contentStyle={styles.buttonContent}
            icon="plus-circle-outline"
            disabled={!isShiftOpen}
          >
            Crear Orden
          </Button>

          {/* Botón Órdenes Abiertas */}
          <Button
            mode="contained"
            onPress={handleOpenOrders}
            style={[styles.button, !isShiftOpen && styles.buttonDisabled]}
            contentStyle={styles.buttonContent}
            icon="folder-open-outline"
            disabled={!isShiftOpen}
          >
            Órdenes Abiertas
          </Button>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
    },
    scrollContent: {
      flexGrow: 1,
    },
    content: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    loadingIndicator: {
      position: 'absolute',
      top: theme.spacing.m,
      alignSelf: 'center',
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.surfaceVariant,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      gap: theme.spacing.s,
    },
    loadingText: {
      color: theme.colors.onSurfaceVariant,
    },
    title: {
      marginBottom: theme.spacing.l,
      color: theme.colors.onBackground,
    },
    button: {
      width: '90%',
      marginVertical: theme.spacing.l,
    },
    buttonDisabled: {
      opacity: 0.6,
    },
    buttonContent: {
      paddingVertical: theme.spacing.m,
    },
  });

export default OrdersScreen;

================
File: app/src/modules/preparationScreens/screens/PreparationScreensScreen.tsx
================
import React, { useCallback, useMemo, useState } from 'react';
import { StyleSheet } from 'react-native';
import { IconButton, Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import { discoveryService } from '@/app/services/discoveryService';

import GenericList, {
  FilterOption,
} from '../../../app/components/crud/GenericList';
import PreparationScreenDetailModalSimple from '../components/PreparationScreenDetailModalSimple';
import PreparationScreenListItem from '../components/PreparationScreenListItem';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import PreparationScreenFormModal from '../components/PreparationScreenFormModal';
import { ProductSelectionModal } from '../components/ProductSelectionModal';
import {
  useGetPreparationScreens,
  useGetPreparationScreenById,
  useDeletePreparationScreen,
  useGetMenuWithAssociations,
  useAssociateProducts,
} from '../hooks/usePreparationScreensQueries';
import {
  PreparationScreen,
  FindAllPreparationScreensDto as FindAllPreparationScreensFilter,
} from '../schema/preparationScreen.schema';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { BaseListQuery } from '../../../app/types/query.types';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
  });

const PreparationScreensScreen = () => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [filters, setFilters] = useState<FindAllPreparationScreensFilter>({});
  const [pagination, setPagination] = useState<BaseListQuery>({
    page: 1,
    limit: 15,
  });
  const [searchTerm, setSearchTerm] = useState('');
  const [isProductModalVisible, setIsProductModalVisible] = useState(false);
  const [productModalScreenId, setProductModalScreenId] = useState<
    string | null
  >(null);

  const {
    data: screensData,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: errorList,
  } = useGetPreparationScreens(filters, pagination);

  const { mutate: deleteScreenMutate } = useDeletePreparationScreen();
  const associateProductsMutation = useAssociateProducts();

  const deleteScreenWrapper = useCallback(
    async (id: string): Promise<void> => {
      return new Promise((resolve, reject) => {
        deleteScreenMutate(id, {
          onSuccess: () => resolve(),
          onError: (error) => reject(error),
        });
      });
    },
    [deleteScreenMutate],
  );

  // Hooks para el modal de productos
  const { data: menuData, isLoading: isLoadingMenu } =
    useGetMenuWithAssociations(productModalScreenId, {
      enabled: !!productModalScreenId && isProductModalVisible,
    });

  // Recargar automáticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('preparation-screens');

  // Enriquecer menuData con información de pantallas
  const enrichedMenuData = React.useMemo(() => {
    if (!menuData || !screensData?.data) return menuData;

    // Crear un mapa de productId a nombre de pantalla
    const screenAssignments: Record<string, string> = {};

    screensData.data.forEach((screen) => {
      if (screen.products) {
        screen.products.forEach((product) => {
          screenAssignments[product.id] = screen.name;
        });
      }
    });

    return {
      ...menuData,
      screenAssignments,
    };
  }, [menuData, screensData]);

  const handleOpenProductModal = useCallback((screen: PreparationScreen) => {
    setProductModalScreenId(screen.id);
    setIsProductModalVisible(true);
  }, []);

  const handleCloseProductModal = useCallback(() => {
    setIsProductModalVisible(false);
    setProductModalScreenId(null);
  }, []);

  const handleSaveProducts = useCallback(
    (productIds: string[]) => {
      if (productModalScreenId) {
        associateProductsMutation.mutate(
          { id: productModalScreenId, productIds },
          {
            onSuccess: () => {
              handleCloseProductModal();
              refetchList();
            },
          },
        );
      }
    },
    [
      productModalScreenId,
      associateProductsMutation,
      handleCloseProductModal,
      refetchList,
    ],
  );

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<PreparationScreen>({
    entityName: 'Pantalla de Preparación',
    queryKey: ['preparationScreens', filters, pagination],
    deleteMutationFn: deleteScreenWrapper,
  });

  const selectedScreenId = selectedItem?.id ?? null;

  const { data: selectedScreenData } = useGetPreparationScreenById(
    selectedScreenId,
    {
      enabled: !!selectedScreenId && isDetailModalVisible,
    },
  );

  const handleRefresh = useCallback(async () => {
    // Si hay error de conexión, intentar redescubrir el servidor
    if (
      errorList &&
      (errorList.message?.includes('conexión') ||
        errorList.message?.includes('network'))
    ) {
      try {
        await discoveryService.forceRediscovery();
        // Dar tiempo para que se reinicialice el cliente
        await new Promise((resolve) => setTimeout(resolve, 500));
      } catch (error) {
        // No es crítico, el usuario puede intentar manualmente
      }
    }
    refetchList();
  }, [refetchList, errorList]);

  const handleSearchChange = useCallback((query: string) => {
    setSearchTerm(query);
    const timerId = setTimeout(() => {
      setFilters((prev: FindAllPreparationScreensFilter) => ({
        ...prev,
        name: query || undefined,
      }));
      setPagination((prev) => ({ ...prev, page: 1 }));
    }, 500);
    return () => clearTimeout(timerId);
  }, []);

  const handleFilterChange = useCallback((value: string | number) => {
    const strValue = String(value);
    let newIsActive: boolean | undefined;
    if (strValue === 'true') newIsActive = true;
    else if (strValue === 'false') newIsActive = false;
    else newIsActive = undefined;
    setFilters((prev: FindAllPreparationScreensFilter) => ({
      ...prev,
      isActive: newIsActive,
    }));
    setPagination((prev) => ({ ...prev, page: 1 }));
  }, []);

  const listRenderConfig = {
    titleField: 'name' as keyof PreparationScreen,
    descriptionField: 'description' as keyof PreparationScreen,
    statusConfig: {
      field: 'isActive' as keyof PreparationScreen,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
    renderDescription: (item: PreparationScreen) => {
      const parts: string[] = [];

      if (item.description) {
        parts.push(item.description);
      }

      if (item.users && item.users.length > 0) {
        const userNames = item.users
          .map((user) => {
            const fullName =
              `${user.firstName || ''} ${user.lastName || ''}`.trim();
            return fullName || user.username;
          })
          .join(', ');
        parts.push(`Usuarios: ${userNames}`);
      }

      const text = parts.join(' • ');
      if (!text) return null;

      return (
        <Text variant="bodyMedium" numberOfLines={2} ellipsizeMode="tail">
          {text}
        </Text>
      );
    },
  };

  const filterOptions: FilterOption<string>[] = [
    { value: '', label: 'Todas' },
    { value: 'true', label: 'Activas' },
    { value: 'false', label: 'Inactivas' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!errorList,
    data: screensData?.data,
    emptyConfig: {
      title: searchTerm
        ? 'No se encontraron pantallas'
        : 'No hay pantallas de preparación',
      message: searchTerm
        ? `No se encontraron pantallas para "${searchTerm}"`
        : 'No hay pantallas de preparación creadas. Presiona el botón + para crear la primera.',
      icon: 'monitor-dashboard',
    },
    errorConfig: {
      title: 'Error al cargar pantallas',
      message: errorList?.message?.includes('encontrar el servidor')
        ? 'No se pudo encontrar el servidor. Verifica que el servidor esté encendido y en la misma red.'
        : 'No se pudieron cargar las pantallas de preparación. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      actionText: 'Reintentar',
      onAction: handleRefresh,
    },
  });

  const renderItem = useCallback(
    ({ item }: { item: PreparationScreen }) => (
      <PreparationScreenListItem
        item={item}
        onPress={handleOpenDetailModal}
        onManageProducts={handleOpenProductModal}
      />
    ),
    [handleOpenDetailModal, handleOpenProductModal],
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<PreparationScreen>
        showImagePlaceholder={false}
        items={screensData?.data ?? []}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchTerm}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar por nombre..."
        filterOptions={filterOptions}
        filterValue={
          filters.isActive === true
            ? 'true'
            : filters.isActive === false
              ? 'false'
              : ''
        }
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={
          isDetailModalVisible || isFormModalVisible || isProductModalVisible
        }
        isDrawerOpen={isDrawerOpen}
        renderItemActions={(item) => (
          <IconButton
            icon="link"
            size={20}
            onPress={() => handleOpenProductModal(item)}
          />
        )}
        renderItem={renderItem}
      />

      <PreparationScreenDetailModalSimple
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedScreenData ?? selectedItem ?? null}
        onEdit={() => {
          const itemToEdit = selectedScreenData ?? selectedItem;
          if (itemToEdit) {
            handleOpenEditModal(itemToEdit);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        onManageProducts={handleOpenProductModal}
        isDeleting={isDeleting}
      />

      <PreparationScreenFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        editingItem={editingItem}
        onSubmitSuccess={() => {}}
      />

      <ProductSelectionModal
        visible={isProductModalVisible}
        onDismiss={handleCloseProductModal}
        onSave={handleSaveProducts}
        screenId={productModalScreenId || ''}
        menuData={enrichedMenuData}
        loading={isLoadingMenu}
      />
    </SafeAreaView>
  );
};

export default PreparationScreensScreen;

================
File: app/src/modules/printers/screens/PrintersScreen.tsx
================
import React, { useState, useMemo, useCallback } from 'react';
import { View, StyleSheet, FlatList } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, ActivityIndicator, IconButton, FAB } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import PrinterDiscoveryModal from '../components/PrinterDiscoveryModal';
import PrinterFormModal from '../components/PrinterFormModal';
import PrinterListItem from '../components/PrinterListItem';
import PrinterDetailModal from '../components/PrinterDetailModal';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
} from '../types/printer.types';
import { useListState } from '../../../app/hooks/useListState';
import {
  usePrintersQuery,
  useDeletePrinterMutation,
  usePingPrinterMutation, // <-- Importar hook de ping
  useTestPrintPrinter, // <-- Importar hook de test print
} from '../hooks/usePrintersQueries';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic'; // Importar hook CRUD
import { useDrawerStatus } from '@react-navigation/drawer';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';

const PrintersScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [isDiscoveryModalVisible, setIsDiscoveryModalVisible] = useState(false);
  const [discoveredPrinterData, setDiscoveredPrinterData] =
    useState<Partial<CreateThermalPrinterDto> | null>(null);
  const [pingingPrinterId, setPingingPrinterId] = useState<string | null>(null);
  const [testPrintingPrinterId, setTestPrintingPrinterId] = useState<
    string | null
  >(null);
  const [fabOpen, setFabOpen] = useState(false); // Estado para el FAB.Group

  // --- Lógica CRUD ---
  const queryParams = useMemo(
    () => ({
      isActive: undefined,
      // Añadir otros filtros si son necesarios (ej. name, connectionType)
      page: 1, // O manejar paginación si es necesario
      limit: 50, // Ajustar límite según necesidad
    }),
    [],
  );

  const {
    data: printersResponse,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: listError,
  } = usePrintersQuery(queryParams);

  const { mutateAsync: deletePrinter } = useDeletePrinterMutation();
  const pingPrinterMutation = usePingPrinterMutation(); // Instanciar la mutación de ping
  const testPrintMutation = useTestPrintPrinter(); // Instanciar la mutación de test print

  // Refrescar impresoras cuando la pantalla recibe foco
  useRefreshModuleOnFocus('thermalPrinters');

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<ThermalPrinter>({
    entityName: 'Impresora',
    queryKey: ['thermalPrinters', queryParams], // Usar queryKey consistente
    deleteMutationFn: deletePrinter,
  });
  // --- Fin Lógica CRUD ---

  // Handler para imprimir ticket de prueba
  const handleTestPrint = useCallback(
    async (printerId: string) => {
      setTestPrintingPrinterId(printerId);
      try {
        await testPrintMutation.mutateAsync(printerId);
      } catch (error) {
        // El error ya se maneja en el hook con un snackbar
      } finally {
        setTestPrintingPrinterId(null);
      }
    },
    [testPrintMutation],
  );

  const handleOpenAddModal = () => {
    setDiscoveredPrinterData(null); // Limpiar datos de descubrimiento
    handleOpenCreateModal(); // Abrir modal de formulario vacío
  };

  const handleOpenDiscoveryModal = () => {
    setIsDiscoveryModalVisible(true);
  };

  const handleDismissDiscoveryModal = () => {
    setIsDiscoveryModalVisible(false);
  };

  const handlePrinterSelectedFromDiscovery = (printer: DiscoveredPrinter) => {
    // Pre-rellenar datos para el formulario
    setDiscoveredPrinterData({
      name: printer.name || `Impresora ${printer.ip}`,
      connectionType: 'NETWORK', // Asumir NETWORK
      ipAddress: printer.ip,
      port: printer.port,
      macAddress: printer.mac || undefined,
    });
    setIsDiscoveryModalVisible(false); // Cerrar modal de descubrimiento
    handleOpenCreateModal(); // Abrir modal de formulario con datos pre-rellenados
  };

  // Función para renderizar cada impresora
  const renderPrinter = useCallback(
    ({ item }: { item: ThermalPrinter }) => {
      const isPingingThis = pingingPrinterId === item.id;
      const canPing = item.connectionType === 'NETWORK';

      return (
        <PrinterListItem
          printer={item}
          onPress={() => handleOpenDetailModal(item)}
          renderActions={
            <View style={styles.itemActionsContainer}>
              {isPingingThis ? (
                <ActivityIndicator size={32} style={styles.pingIndicator} />
              ) : (
                <IconButton
                  icon="radar"
                  size={32}
                  onPress={() => handlePingPrinter(item.id)}
                  disabled={!canPing || pingPrinterMutation.isPending}
                  iconColor={
                    canPing
                      ? theme.colors.primary
                      : theme.colors.onSurfaceDisabled
                  }
                  style={styles.actionButton}
                />
              )}
            </View>
          }
        />
      );
    },
    [
      pingingPrinterId,
      pingPrinterMutation.isPending,
      handlePingPrinter,
      handleOpenDetailModal,
      theme.colors,
      styles,
    ],
  );

  // Filtrar datos según el estado seleccionado
  const filteredData = useMemo(() => {
    if (!printersResponse?.data) return [];
    return printersResponse.data;
  }, [printersResponse?.data]);

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!listError,
    data: printersResponse?.data,
    emptyConfig: {
      title: 'No hay impresoras',
      message:
        'No hay impresoras configuradas. Presiona el botón + para agregar una nueva o descubrir impresoras en la red.',
      icon: 'printer-outline',
    },
    errorConfig: {
      title: 'Error al cargar impresoras',
      message: 'No se pudieron cargar las impresoras. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchList,
    },
  });

  // --- Funcionalidad de Ping ---
  const handlePingPrinter = useCallback(
    async (printerId: string) => {
      setPingingPrinterId(printerId);
      try {
        await pingPrinterMutation.mutateAsync(printerId);
      } catch (error) {
        // El error ya se maneja en el hook con un snackbar
      } finally {
        setPingingPrinterId(null);
      }
    },
    [pingPrinterMutation],
  );

  // Función para renderizar cuando no hay datos
  const renderEmptyList = () => {
    if (isLoadingList) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    return ListEmptyComponent;
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      {/* Eliminar la View de headerButtons */}

      <FlatList
        data={filteredData}
        renderItem={renderPrinter}
        keyExtractor={(item) => item.id}
        onRefresh={refetchList}
        refreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={renderEmptyList()}
        contentContainerStyle={[
          styles.listPadding,
          filteredData.length === 0 && styles.emptyListContainer,
        ]}
      />

      <Portal>
        {/* Modal de Descubrimiento */}
        <PrinterDiscoveryModal
          visible={isDiscoveryModalVisible}
          onDismiss={handleDismissDiscoveryModal}
          onPrinterSelect={handlePrinterSelectedFromDiscovery}
        />
        {/* Modal de Formulario */}
        <PrinterFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          editingItem={editingItem}
          // Pasar datos descubiertos al crear, usar undefined en lugar de null
          initialDataFromDiscovery={
            !editingItem ? (discoveredPrinterData ?? undefined) : undefined
          }
        />
        {/* Modal de Detalle Personalizado */}
        <PrinterDetailModal
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          printer={selectedItem}
          onEdit={() => selectedItem && handleOpenEditModal(selectedItem)}
          deleteConfirmation={deleteConfirmation}
          onTestPrint={() => selectedItem && handleTestPrint(selectedItem.id)}
          isDeleting={isDeleting}
          isTestPrinting={testPrintingPrinterId === selectedItem?.id}
        />
        {/* Añadir FAB.Group dentro del Portal */}
        <FAB.Group
          open={fabOpen}
          visible={
            !isFormModalVisible &&
            !isDetailModalVisible &&
            !isDiscoveryModalVisible &&
            !isDrawerOpen
          } // Ocultar si hay modales abiertos o drawer
          icon={fabOpen ? 'close' : 'plus'}
          actions={[
            {
              icon: 'magnify-scan',
              label: 'Descubrir en Red',
              onPress: handleOpenDiscoveryModal,
              style: { backgroundColor: theme.colors.tertiaryContainer }, // Color diferente
              color: theme.colors.onTertiaryContainer,
              labelTextColor: theme.colors.onTertiaryContainer,
              size: 'small',
            },
            {
              icon: 'plus',
              label: 'Añadir Manual',
              onPress: handleOpenAddModal,
              style: { backgroundColor: theme.colors.secondaryContainer }, // Color diferente
              color: theme.colors.onSecondaryContainer,
              labelTextColor: theme.colors.onSecondaryContainer,
              size: 'small',
            },
          ]}
          onStateChange={({ open }) => setFabOpen(open)}
          onPress={() => {
            if (fabOpen) {
              // Acción opcional al cerrar el FAB principal
            }
          }}
          fabStyle={{ backgroundColor: theme.colors.primary }} // Color principal para el FAB
          color={theme.colors.onPrimary} // Color del icono principal
        />
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    // Eliminar estilos de headerButtons
    listPadding: {
      paddingBottom: 80, // Espacio para que el FAB no tape el último item
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    emptyListContainer: {
      flex: 1,
      minHeight: responsive.isTablet ? 350 : 400,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.xl),
    },
    itemActionsContainer: {
      // Contenedor para los botones de acción de cada item
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
    },
    actionButton: {
      // Estilo base para botones de acción en la lista
      margin: 0,
      padding: 0,
      width: responsive.isTablet ? 44 : 52, // Más pequeño en tablet
      height: responsive.isTablet ? 44 : 52, // Más pequeño en tablet
      borderRadius: responsive.isTablet ? 22 : 26, // Redondeado perfecto
      backgroundColor: theme.colors.surfaceVariant, // Fondo para hacerlo más atractivo
      elevation: 2, // Sombra sutil para darle profundidad
    },
    pingIndicator: {
      // Estilo para el indicador de carga del ping
      width: responsive.isTablet ? 44 : 52, // Mismo ancho que el botón
      height: responsive.isTablet ? 44 : 52, // Mismo alto
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: responsive.isTablet ? 22 : 26, // Redondeado perfecto
      backgroundColor: theme.colors.primaryContainer, // Fondo de color primario
      elevation: 2, // Sombra sutil
    },
    errorText: {
      color: theme.colors.error,
      textAlign: 'center',
      fontSize: responsive.fontSize(14),
    },
  });

export default PrintersScreen;

================
File: app/src/modules/receipts/services/receiptService.ts
================
import apiClient from '@/app/services/apiClient';
import type { QueryOptions } from '@tanstack/react-query';
import { API_PATHS } from '@/app/constants/apiPaths';
import { ApiError } from '@/app/lib/errors';
import type {
  Receipt,
  ReceiptsListResponse,
  ReceiptFilters,
} from '../types/receipt.types';
import type { Order } from '@/modules/orders/types/orders.types';

export const receiptService = {
  getReceiptsList: async (
    params: ReceiptFilters = {},
  ): Promise<ReceiptsListResponse> => {
    const { startDate, endDate, orderType } = params;

    const queryParams: Record<string, any> = {};

    if (startDate) {
      queryParams.startDate = startDate;
    }
    if (endDate) {
      queryParams.endDate = endDate;
    }
    if (orderType) {
      queryParams.orderType = orderType;
    }

    const response = await apiClient.get<ReceiptsListResponse>(
      API_PATHS.ORDERS_RECEIPTS_LIST,
      queryParams,
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    return response.data;
  },

  getReceiptById: async (id: string): Promise<Receipt> => {
    const response = await apiClient.get<Receipt>(
      API_PATHS.ORDERS_RECEIPTS_BY_ID.replace(':id', id),
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    return response.data;
  },

  recoverOrder: async (id: string): Promise<Order> => {
    const response = await apiClient.post<Order>(
      API_PATHS.ORDERS_RECOVER.replace(':id', id),
      {},
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    return response.data;
  },
};

export const receiptQueryOptions = {
  receipts: (
    params: ReceiptFilters = {},
  ): QueryOptions<ReceiptsListResponse, Error> => ({
    queryKey: ['receipts', params],
    queryFn: () => receiptService.getReceiptsList(params),
    refetchOnWindowFocus: true,
    refetchOnMount: true,
  }),

  receipt: (id: string): QueryOptions<Receipt, Error> => ({
    queryKey: ['receipt', id],
    queryFn: () => receiptService.getReceiptById(id),
  }),
};

================
File: app/src/services/autoReconnectService.ts
================
import EventEmitter from 'eventemitter3';
import { healthMonitoringService } from './healthMonitoringService';
import { discoveryService } from '@/app/services/discoveryService';
import NetInfo from '@react-native-community/netinfo';
import { NETWORK_CONFIG } from '@/app/constants/network';

export type ReconnectStatus =
  | 'idle'
  | 'checking-network'
  | 'checking-health'
  | 'running-discovery'
  | 'connected'
  | 'no-wifi'
  | 'failed';

export interface ReconnectState {
  status: ReconnectStatus;
  isReconnecting: boolean;
  attempts: number;
  lastError: string | null;
  logs: string[];
}

class AutoReconnectService extends EventEmitter {
  private state: ReconnectState = {
    status: 'idle',
    isReconnecting: false,
    attempts: 0,
    lastError: null,
    logs: [],
  };

  private reconnectTimer: NodeJS.Timeout | null = null;
  private isRunning = false;
  private readonly MAX_LOGS = 50;

  constructor() {
    super();
  }

  // Obtener estado actual
  getState(): ReconnectState {
    return { ...this.state };
  }

  // Agregar log con timestamp
  private addLog(message: string, type: 'info' | 'error' | 'success' = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;

    // Crear nueva array para asegurar actualización
    const newLogs = [logEntry, ...this.state.logs].slice(0, this.MAX_LOGS);
    this.state.logs = newLogs;

    // Emitir cambio completo del estado
    this.emit('stateChange', { ...this.state, logs: [...newLogs] });
  }

  // Actualizar estado y notificar
  private updateState(updates: Partial<ReconnectState>) {
    this.state = { ...this.state, ...updates };
    this.emit('stateChange', this.state);
  }

  // Iniciar proceso de reconexión automática
  async startAutoReconnect() {
    if (this.isRunning) {
      return;
    }

    this.isRunning = true;
    this.updateState({
      isReconnecting: true,
      attempts: 0,
      logs: [], // Limpiar logs anteriores
      lastError: null,
      status: 'idle', // Resetear estado
    });

    this.addLog('Iniciando proceso de reconexión automática', 'info');

    // Pequeño delay para asegurar que el estado se propague
    await this.delay(100);

    await this.reconnectCycle();
  }

  // Detener reconexión
  stopAutoReconnect() {
    if (!this.isRunning) return;

    this.addLog('Deteniendo proceso de reconexión', 'info');
    this.isRunning = false;

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    this.updateState({
      isReconnecting: false,
      status: 'idle',
    });
  }

  // Ciclo principal de reconexión
  private async reconnectCycle() {
    while (this.isRunning) {
      this.updateState({ attempts: this.state.attempts + 1 });
      this.addLog(`CICLO DE RECONEXIÓN #${this.state.attempts}`, 'info');

      const hasNetwork = await this.checkNetwork();
      if (!hasNetwork) {
        this.addLog('❌ Sin conexión WiFi. Esperando...', 'error');
        this.updateState({
          status: 'no-wifi',
          lastError: 'No hay conexión WiFi activa',
        });

        // Esperar antes de reintentar
        await this.delay(NETWORK_CONFIG.RECONNECT_CYCLE_DELAY);
        continue;
      }
      this.addLog('✅ WiFi conectado', 'success');

      this.addLog('Verificando servidor con health checks...', 'info');
      const healthOk = await this.tryHealthChecks();

      if (healthOk) {
        this.addLog('🎉 ¡SERVIDOR CONECTADO!', 'success');
        this.updateState({
          status: 'connected',
          isReconnecting: false,
          lastError: null,
        });
        this.isRunning = false;

        // Asegurar que el servicio de conexión actualice su estado
        // Pequeño delay para asegurar que el estado se propague correctamente
        setTimeout(() => {
          this.emit('reconnected');
        }, 100);

        break;
      }

      this.addLog(
        'Health checks fallaron. Buscando servidor en red...',
        'info',
      );
      const discoveryOk = await this.tryDiscovery();

      if (discoveryOk) {
        // Verificar con health check después del discovery
        this.addLog('📍 Servidor encontrado. Verificando...', 'info');
        const postDiscoveryHealth = await this.tryHealthChecks(1); // Solo 1 intento

        if (postDiscoveryHealth) {
          this.addLog('🎉 ¡RECONEXIÓN EXITOSA!', 'success');
          this.updateState({
            status: 'connected',
            isReconnecting: false,
            lastError: null,
          });
          this.isRunning = false;

          // Asegurar que el servicio de conexión actualice su estado
          // Pequeño delay para asegurar que el estado se propague correctamente
          setTimeout(() => {
            this.emit('reconnected');
          }, 100);

          break;
        } else {
          this.addLog('❌ Servidor encontrado pero no responde', 'error');
        }
      }

      this.addLog(
        `❌ Ciclo fallido. Esperando ${NETWORK_CONFIG.RECONNECT_CYCLE_DELAY / 1000}s...`,
        'error',
      );
      this.updateState({
        status: 'failed',
        lastError: 'No se pudo establecer conexión con el servidor',
      });

      await this.delay(NETWORK_CONFIG.RECONNECT_CYCLE_DELAY);
    }
  }

  // Verificar estado de red
  private async checkNetwork(): Promise<boolean> {
    this.updateState({ status: 'checking-network' });

    try {
      const netInfo = await NetInfo.fetch();
      const hasWifi =
        !!netInfo.isConnected &&
        (netInfo.type === 'wifi' || netInfo.type === 'ethernet');

      return hasWifi;
    } catch (error) {
      this.addLog('Error al verificar estado de red', 'error');
      return false;
    }
  }

  // Intentar health checks múltiples veces
  private async tryHealthChecks(
    maxAttempts = NETWORK_CONFIG.HEALTH_CHECK_ATTEMPTS,
  ): Promise<boolean> {
    this.updateState({ status: 'checking-health' });

    for (let i = 1; i <= maxAttempts; i++) {
      this.addLog(`  → Health check ${i}/${maxAttempts}...`, 'info');

      try {
        const isHealthy = await healthMonitoringService.forceCheck();

        if (isHealthy) {
          this.addLog('  ✓ Health check exitoso', 'success');
          return true;
        } else {
          this.addLog('  ✗ Health check falló', 'error');
        }
      } catch (error: any) {
        this.addLog('  ✗ Health check falló', 'error');
      }

      // Esperar antes del siguiente intento (excepto el último)
      if (i < maxAttempts) {
        this.addLog(`  ⏳ Esperando 2s...`, 'info');
        await this.delay(2000);
      }
    }

    this.addLog('  ❌ Todos los health checks fallaron', 'error');
    return false;
  }

  // Intentar discovery
  private async tryDiscovery(): Promise<boolean> {
    this.updateState({ status: 'running-discovery' });

    discoveryService.setLogCallback((message: string) => {
      this.addLog(`  ${message}`, 'info');
    });

    try {
      this.addLog('  → Iniciando escaneo de red...', 'info');
      this.addLog('  → Buscando servidor en puerto 3737...', 'info');
      const url = await discoveryService.forceRediscovery();

      if (url) {
        this.addLog(`  ✓ ¡Servidor encontrado!`, 'success');
        this.addLog(`  📍 URL: ${url}`, 'success');
        return true;
      } else {
        this.addLog('  ✗ No se encontró servidor en la red', 'error');
        return false;
      }
    } catch (error: any) {
      this.addLog(
        `  ✗ Error: ${error.message || 'Error al buscar servidor'}`,
        'error',
      );
      return false;
    } finally {
      discoveryService.setLogCallback(null);
    }
  }

  // Utilidad para delay
  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => {
      this.reconnectTimer = setTimeout(resolve, ms);
    });
  }

  // Suscribirse a cambios
  subscribe(callback: (state: ReconnectState) => void): () => void {
    this.on('stateChange', callback);

    // Llamar inmediatamente con el estado actual
    callback(this.state);

    // Retornar función para desuscribirse
    return () => {
      this.off('stateChange', callback);
    };
  }
}

// Singleton
export const autoReconnectService = new AutoReconnectService();

================
File: app/src/app/components/ConnectionErrorModal.tsx
================
import React, { useEffect, useState, useRef } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Dimensions,
  Platform,
} from 'react-native';
import {
  Text,
  Modal,
  Portal,
  Surface,
  Icon,
  IconButton,
  useTheme,
  ProgressBar,
  Button,
} from 'react-native-paper';
import { ServerConfigModal } from './ServerConfigModal';
import {
  autoReconnectService,
  ReconnectState,
} from '@/services/autoReconnectService';
import { useServerConnection } from '../hooks/useServerConnection';
import { useAuthStore } from '../store/authStore';
import { serverConnectionService } from '@/services/serverConnectionService';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

export function ConnectionErrorModal() {
  const theme = useTheme();
  const { isConnected } = useServerConnection();
  const isLoggedIn = useAuthStore((state) => !!state.user);
  const [visible, setVisible] = useState(false);
  const [reconnectState, setReconnectState] = useState<ReconnectState>(
    autoReconnectService.getState(),
  );
  const [isPaused, setIsPaused] = useState(false);
  const [pausedLogs, setPausedLogs] = useState<string[]>([]);
  const scrollViewRef = useRef<ScrollView>(null);
  const [showConfigModal, setShowConfigModal] = useState(false);

  useEffect(() => {
    // En web, mostrar directamente el modal de configuración
    if (Platform.OS === 'web' && !isConnected && !isLoggedIn) {
      setVisible(true);
      return;
    }

    const unsubscribe = autoReconnectService.subscribe((state) => {
      setReconnectState(state);

      if (!isLoggedIn && state.isReconnecting) {
        setVisible(true);
      }

      if (state.status === 'connected') {
        setVisible(false);
      }
    });

    return () => {
      unsubscribe();
    };
  }, [isLoggedIn, isConnected]);

  useEffect(() => {
    if (Platform.OS === 'web' && isConnected && visible) {
      setVisible(false);
      setShowConfigModal(false);
    }
  }, [isConnected, visible]);

  useEffect(() => {
    if (isPaused && pausedLogs.length === 0) {
      setPausedLogs([...reconnectState.logs]);
    } else if (!isPaused) {
      setPausedLogs([]);
    }
  }, [isPaused, reconnectState.logs]);

  useEffect(() => {
    if (Platform.OS === 'web') {
      return;
    }

    if (!isConnected && !autoReconnectService.getState().isReconnecting) {
      setTimeout(() => {
        if (!isConnected) {
          autoReconnectService.startAutoReconnect();
        }
      }, 500);
    }
  }, [isConnected]);

  const getStatusInfo = () => {
    switch (reconnectState.status) {
      case 'checking-network':
        return {
          icon: 'wifi',
          title: 'Verificando red...',
          color: theme.colors.primary,
        };
      case 'checking-health':
        return {
          icon: 'server-network',
          title: 'Verificando servidor...',
          color: theme.colors.primary,
        };
      case 'running-discovery':
        return {
          icon: 'magnify-scan',
          title: 'Buscando servidor en la red...',
          color: theme.colors.tertiary,
        };
      case 'no-wifi':
        return {
          icon: 'wifi-off',
          title: 'Sin conexión WiFi',
          color: theme.colors.error,
        };
      case 'failed':
        return {
          icon: 'server-off',
          title: 'No se puede conectar',
          color: theme.colors.error,
        };
      case 'connected':
        return {
          icon: 'check-circle',
          title: '¡Conexión establecida!',
          color: theme.colors.primary,
        };
      default:
        return {
          icon: 'alert-circle',
          title: 'Conectando...',
          color: theme.colors.tertiary,
        };
    }
  };

  const statusInfo = getStatusInfo();

  const styles = StyleSheet.create({
    modal: {
      justifyContent: 'center',
      alignItems: 'center',
      margin: 20,
    },
    container: {
      width: screenWidth - 40,
      minHeight: 400,
      maxHeight: screenHeight * 0.85,
      backgroundColor: theme.colors.surface,
      borderRadius: 24,
      overflow: 'hidden',
      elevation: 8,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 20,
      paddingVertical: 16,
      backgroundColor: theme.colors.elevation.level2,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    headerTitle: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
      marginLeft: 12,
    },
    statusSection: {
      paddingTop: 12,
      paddingBottom: 8,
      paddingHorizontal: 16,
      alignItems: 'center',
    },
    title: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
      marginBottom: 6,
    },
    subtitle: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    attemptBadge: {
      backgroundColor: theme.colors.primaryContainer,
      paddingHorizontal: 12,
      paddingVertical: 6,
      borderRadius: 16,
      marginTop: 8,
    },
    attemptText: {
      fontSize: 13,
      fontWeight: '500',
      color: theme.colors.onPrimaryContainer,
    },
    logsContainer: {
      backgroundColor: theme.colors.surfaceVariant,
      marginHorizontal: 16,
      marginBottom: 16,
      borderRadius: 16,
      overflow: 'hidden',
      minHeight: 200,
      maxHeight: 350,
    },
    logsHeader: {
      backgroundColor: theme.colors.elevation.level1,
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    logsTitle: {
      fontSize: 12,
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 1,
      textTransform: 'uppercase',
    },
    logsList: {
      padding: 16,
    },
    logEntry: {
      fontSize: 13,
      lineHeight: 20,
      color: theme.colors.onSurface,
      marginBottom: 6,
      fontFamily: 'monospace',
    },
    logInfo: {
      color: theme.colors.onSurface,
    },
    logError: {
      color: theme.colors.error,
      fontWeight: '600',
    },
    logSuccess: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    progressContainer: {
      paddingHorizontal: 24,
      paddingBottom: 12,
    },
    actionContainer: {
      paddingHorizontal: 16,
      paddingBottom: 16,
      paddingTop: 8,
    },
    actionButton: {
      marginTop: 8,
    },
  });

  if (!visible) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (
            Platform.OS === 'web' ||
            reconnectState.status === 'connected' ||
            reconnectState.status === 'no-wifi'
          ) {
            setVisible(false);
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={
          Platform.OS === 'web' ||
          reconnectState.status === 'connected' ||
          reconnectState.status === 'no-wifi'
        }
      >
        <Surface style={styles.container}>
          <View style={styles.header}>
            <Icon source="wifi-sync" size={24} color={theme.colors.primary} />
            <Text style={styles.headerTitle}>Estado de Conexión</Text>
            {(Platform.OS === 'web' ||
              reconnectState.status === 'connected' ||
              reconnectState.status === 'no-wifi') && (
              <IconButton
                icon="close"
                size={24}
                onPress={() => setVisible(false)}
                iconColor={theme.colors.onSurfaceVariant}
              />
            )}
          </View>

          <View style={styles.statusSection}>
            {Platform.OS === 'web' ? (
              <>
                <Icon
                  source="server-network"
                  size={64}
                  color={theme.colors.tertiary}
                  style={{ marginBottom: 16 }}
                />
                <Text style={styles.title}>Configuración Requerida</Text>
                <Text style={styles.subtitle}>
                  En la versión web, debes configurar manualmente la URL del
                  servidor
                </Text>
              </>
            ) : (
              <>
                <Text style={styles.title}>{statusInfo.title}</Text>
                {reconnectState.lastError &&
                  reconnectState.status !== 'connected' && (
                    <Text style={styles.subtitle}>
                      {reconnectState.lastError}
                    </Text>
                  )}
              </>
            )}

            {reconnectState.attempts > 0 &&
              reconnectState.status !== 'connected' &&
              Platform.OS !== 'web' && (
                <View style={styles.attemptBadge}>
                  <Text style={styles.attemptText}>
                    Intento #{reconnectState.attempts}
                  </Text>
                </View>
              )}
          </View>

          {reconnectState.isReconnecting &&
            reconnectState.status !== 'connected' &&
            Platform.OS !== 'web' && (
              <View style={styles.progressContainer}>
                <ProgressBar
                  indeterminate
                  color={statusInfo.color}
                  style={{ height: 4, borderRadius: 2 }}
                />
              </View>
            )}

          {reconnectState.logs.length > 0 && Platform.OS !== 'web' && (
            <View style={styles.logsContainer}>
              <View style={styles.logsHeader}>
                <View
                  style={{
                    flexDirection: 'row',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                  }}
                >
                  <Text style={styles.logsTitle}>
                    DETALLES DEL PROCESO {isPaused ? '(PAUSADO)' : ''}
                  </Text>
                  <IconButton
                    icon={isPaused ? 'play' : 'pause'}
                    size={32}
                    onPress={() => setIsPaused(!isPaused)}
                    iconColor={theme.colors.primary}
                    style={{ margin: -4 }}
                  />
                </View>
              </View>
              <ScrollView
                ref={scrollViewRef}
                style={styles.logsList}
                showsVerticalScrollIndicator={true}
                nestedScrollEnabled={true}
              >
                {(isPaused ? pausedLogs : reconnectState.logs).map(
                  (log, index) => {
                    let logStyle = [styles.logEntry, styles.logInfo];

                    if (
                      log.includes('ERROR:') ||
                      log.includes('❌') ||
                      log.includes('✗')
                    ) {
                      logStyle = [styles.logEntry, styles.logError];
                    } else if (
                      log.includes('SUCCESS:') ||
                      log.includes('✅') ||
                      log.includes('✓') ||
                      log.includes('🎉')
                    ) {
                      logStyle = [styles.logEntry, styles.logSuccess];
                    }

                    return (
                      <Text key={index} style={logStyle}>
                        {log}
                      </Text>
                    );
                  },
                )}
                <View style={{ height: 10 }} />
              </ScrollView>
            </View>
          )}

          {Platform.OS === 'web' ||
          reconnectState.status === 'failed' ||
          reconnectState.status === 'no-wifi' ||
          (reconnectState.attempts > 2 &&
            reconnectState.status !== 'connected') ? (
            <View style={styles.actionContainer}>
              <Button
                mode="contained"
                onPress={() => {
                  setShowConfigModal(true);
                }}
                icon="server-network"
                style={styles.actionButton}
              >
                Configurar Servidor Manualmente
              </Button>
            </View>
          ) : null}
        </Surface>
      </Modal>

      <ServerConfigModal
        visible={showConfigModal}
        onDismiss={() => setShowConfigModal(false)}
        onSuccess={() => {
          setShowConfigModal(false);
          if (Platform.OS === 'web') {
            setVisible(false);
          } else {
            setTimeout(() => {
              autoReconnectService.startAutoReconnect();
            }, 1000);
          }
        }}
      />
    </Portal>
  );
}

================
File: app/src/app/constants/apiPaths.ts
================
export const API_PATHS = {
  SUBCATEGORIES: '/api/v1/subcategories',
  SUBCATEGORIES_BY_ID: '/api/v1/subcategories/:id',
  PRODUCTS: '/api/v1/products',
  PRODUCTS_BY_ID: '/api/v1/products/:id',
  PRODUCTS_MODIFIER_GROUPS: '/api/v1/products/:productId/modifier-groups',
  PRODUCTS_PIZZA_CUSTOMIZATIONS:
    '/api/v1/products/:productId/pizza-customizations',
  PRODUCTS_PIZZAS_CUSTOMIZATIONS_BULK:
    '/api/v1/products/pizzas/customizations/bulk',
  CATEGORIES: '/api/v1/categories',
  CATEGORIES_BY_ID: '/api/v1/categories/:id',
  CATEGORIES_ORDER_MENU: '/api/v1/categories/order-menu',
  FILES_UPLOAD: '/api/v1/files/upload',

  PREPARATION_SCREENS: '/api/v1/preparation-screens',
  PREPARATION_SCREENS_BY_ID: '/api/v1/preparation-screens/:id',
  PREPARATION_SCREENS_PRODUCTS: '/api/v1/preparation-screens/:id/products',
  PREPARATION_SCREENS_MENU_WITH_ASSOCIATIONS:
    '/api/v1/preparation-screens/:id/menu-with-associations',

  AUTH_EMAIL_LOGIN: '/api/v1/auth/email/login',
  AUTH_EMAIL_REGISTER: '/api/v1/auth/email/register',
  AUTH_ME: '/api/v1/auth/me',
  AUTH_REFRESH: '/api/v1/auth/refresh',

  AREAS: '/api/v1/areas',
  AREAS_BY_ID: '/api/v1/areas/:id',
  TABLES: '/api/v1/tables',
  TABLES_BY_ID: '/api/v1/tables/:id',
  TABLES_BY_AREA: '/api/v1/tables/area/:areaId',

  MODIFIERS: '/api/v1/product-modifiers',
  MODIFIERS_BY_ID: '/api/v1/product-modifiers/:id',
  MODIFIERS_BY_GROUP: '/api/v1/product-modifiers/by-group/:modifierGroupId',
  MODIFIER_GROUPS: '/api/v1/modifier-groups',
  MODIFIER_GROUPS_BY_ID: '/api/v1/modifier-groups/:id',

  ORDERS: '/api/v1/orders',
  ORDERS_BY_ID: '/api/v1/orders/:orderId',
  ORDERS_OPEN_CURRENT_SHIFT: '/api/v1/orders/open-current-shift',
  ORDERS_OPEN_ORDERS_LIST: '/api/v1/orders/open-orders-list',
  ORDERS_FOR_FINALIZATION_LIST: '/api/v1/orders/for-finalization/list',
  ORDERS_FOR_FINALIZATION_DETAIL: '/api/v1/orders/for-finalization/:id',
  ORDERS_FINALIZE_MULTIPLE: '/api/v1/orders/finalize-multiple',
  ORDERS_DETAIL: '/api/v1/orders/:orderId/detail',
  ORDERS_RECEIPTS_LIST: '/api/v1/orders/receipts-list',
  ORDERS_RECEIPTS_BY_ID: '/api/v1/orders/receipts/:id',
  ORDERS_RECOVER: '/api/v1/orders/:id/recover',
  PRINT_ORDER_TICKET: '/api/v1/print/order',

  THERMAL_PRINTERS: '/api/v1/thermal-printers',
  THERMAL_PRINTERS_BY_ID: '/api/v1/thermal-printers/:id',
  THERMAL_PRINTERS_DISCOVER: '/api/v1/thermal-printers/discover',
  THERMAL_PRINTERS_PING: '/api/v1/thermal-printers/:id/ping',
  THERMAL_PRINTERS_TEST_PRINT: '/api/v1/thermal-printers/test-print',

  ADJUSTMENTS: '/api/v1/adjustments',
  ADJUSTMENTS_BY_ID: '/api/v1/adjustments/:id',

  RESTAURANT_CONFIG: '/api/v1/restaurant-config',

  AVAILABILITY_MENU: '/api/v1/availability/menu',
  AVAILABILITY_MODIFIER_GROUPS: '/api/v1/availability/modifier-groups',
  AVAILABILITY_PIZZA_CUSTOMIZATIONS:
    '/api/v1/availability/pizza-customizations',
  AVAILABILITY_UPDATE: '/api/v1/availability/update',
  AVAILABILITY_BULK_UPDATE: '/api/v1/availability/bulk-update',

  PAYMENTS: '/api/v1/payments',
  PAYMENTS_BY_ID: '/api/v1/payments/:paymentId',
  PAYMENTS_BY_ORDER: '/api/v1/payments/order/:orderId',
  PAYMENTS_PREPAYMENT: '/api/v1/payments/prepayment',
  PAYMENTS_ASSOCIATE: '/api/v1/payments/:paymentId/associate/:orderId',

  PIZZA_CUSTOMIZATIONS: '/api/v1/pizza-customizations',
  PIZZA_CUSTOMIZATIONS_BY_ID: '/api/v1/pizza-customizations/:id',
  PIZZA_CUSTOMIZATIONS_SORT_ORDER: '/api/v1/pizza-customizations/sort-order',
  PIZZA_CONFIGURATIONS: '/api/v1/pizza-configurations',
  PIZZA_CONFIGURATIONS_BY_ID: '/api/v1/pizza-configurations/:id',
  PRODUCTS_PIZZAS: '/api/v1/products/pizzas/all',

  CUSTOMERS: '/api/v1/customers',
  CUSTOMERS_BY_ID: '/api/v1/customers/:id',
  CUSTOMERS_CHAT_MESSAGE: '/api/v1/customers/:customerId/chat-message',
  CUSTOMERS_CHAT_HISTORY: '/api/v1/customers/:customerId/relevant-chat-history',
  CUSTOMERS_STATS: '/api/v1/customers/:customerId/stats',
  CUSTOMERS_ACTIVE_RECENT: '/api/v1/customers/active/recent',
  ADDRESSES: '/api/v1/addresses',
  ADDRESSES_BY_ID: '/api/v1/addresses/:id',
  ADDRESSES_BY_CUSTOMER: '/api/v1/customers/:customerId/addresses',

  KITCHEN_ORDERS: '/api/v1/kitchen/orders',
  KITCHEN_ORDERS_START_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/start-preparation',
  KITCHEN_ORDERS_CANCEL_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/cancel-preparation',
  KITCHEN_ORDERS_COMPLETE_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/complete-preparation',
  KITCHEN_MARK_PREPARED: '/api/v1/kitchen/order-items/:itemId/prepare',
  KITCHEN_MARK_UNPREPARED: '/api/v1/kitchen/order-items/:itemId/unprepare',
  KITCHEN_MY_SCREEN: '/api/v1/kitchen/my-screen',

  SHIFTS: '/api/v1/shifts',
  SHIFTS_OPEN: '/api/v1/shifts/open',
  SHIFTS_CLOSE: '/api/v1/shifts/close',
  SHIFTS_CURRENT: '/api/v1/shifts/current',
  SHIFTS_HISTORY: '/api/v1/shifts/history',
  SHIFTS_DETAIL: '/api/v1/shifts/:id',
  ORDERS_BY_SHIFT: '/api/v1/orders/shift/:shiftId',
  ORDERS_BY_SHIFT_SALES_SUMMARY: '/api/v1/orders/shift/:shiftId/sales-summary',

  USERS: '/api/v1/users',
  USERS_BY_ID: '/api/v1/users/:id',

  APP_CONFIG: '/api/v1/app-config',

  SYNC_STATUS: '/api/v1/sync-local/status',
  SYNC_ACTIVITY: '/api/v1/sync-local/activity',

  ORDERS_HISTORY: '/api/v1/orders/:orderId/history',
  ORDERS_QUICK_FINALIZE_MULTIPLE: '/api/v1/orders/quick-finalize-multiple',
  ORDERS_PRINT_TICKET: '/api/v1/orders/:orderId/print-ticket',

  FILES_CHECK: '/api/v1/files/',

  AUDIO_ORDERS_PROCESS: '/api/v1/audio-orders/process',
  AUDIO_ORDERS_HEALTH: '/api/v1/audio-orders/health',

  HEALTH: '/api/v1/health',
  DISCOVERY: '/api/v1/discovery',
} as const;

================
File: app/src/modules/areasTables/screens/AreasScreen.tsx
================
import React, { useMemo, useCallback } from 'react';
import { StyleSheet } from 'react-native';
import { IconButton } from 'react-native-paper';
import { useDrawerStatus } from '@react-navigation/drawer';
import { SafeAreaView } from 'react-native-safe-area-context';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '../../../app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '../../../app/components/crud/GenericDetailModal';
import AreaFormModal from '../components/AreaFormModal';
import {
  useGetAreas,
  useCreateArea,
  useUpdateArea,
  useDeleteArea,
} from '../hooks/useAreasQueries';
import { Area, CreateAreaDto, UpdateAreaDto } from '../schema/area.schema';
import { AreasListScreenProps } from '../navigation/types';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';

const AreasScreen: React.FC<AreasListScreenProps> = ({ navigation }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [searchQuery, setSearchQuery] = React.useState('');
  const [filterStatus, setFilterStatus] = React.useState<string>('all');

  const {
    data: areasData = [],
    isLoading: isLoadingAreas,
    isError: isErrorAreas,
    refetch: refetchAreas,
    isRefetching,
  } = useGetAreas(
    {
      name: searchQuery || undefined,
      isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
    },
    { page: 1, limit: 100 },
  );

  const createAreaMutation = useCreateArea();
  const updateAreaMutation = useUpdateArea();
  const { mutateAsync: deleteArea } = useDeleteArea();

  // Refrescar áreas cuando la pantalla recibe foco
  useRefreshModuleOnFocus('areas');

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Area>({
    entityName: 'Área',
    queryKey: [
      'areas',
      {
        name: searchQuery || undefined,
        isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
      },
    ],
    deleteMutationFn: deleteArea,
  });

  const isSubmitting =
    createAreaMutation.isPending || updateAreaMutation.isPending;

  const handleFormSubmit = async (data: CreateAreaDto | UpdateAreaDto) => {
    try {
      if (editingItem) {
        await updateAreaMutation.mutateAsync({
          id: editingItem.id,
          data: data as UpdateAreaDto,
        });
      } else {
        await createAreaMutation.mutateAsync(data as CreateAreaDto);
      }
      handleCloseModals();
    } catch (error) {}
  };

  const handleNavigateToTables = (area: Area) => {
    navigation.navigate(NAVIGATION_PATHS.TABLES_LIST, {
      areaId: area.id,
      areaName: area.name,
    });
  };

  const listRenderConfig: RenderItemConfig<Area> = {
    titleField: 'name',
    descriptionField: 'description',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };

  const areaDetailFields: DisplayFieldConfig<Area>[] = [
    { field: 'description', label: 'Descripción' },
  ];
  const areaDetailStatusConfig = listRenderConfig.statusConfig;

  const filterOptions: FilterOption<string>[] = useMemo(
    () => [
      { label: 'Todas', value: 'all' },
      { label: 'Activas', value: 'true' },
      { label: 'Inactivas', value: 'false' },
    ],
    [],
  );

  const handleFilterChange = (value: string | number) => {
    setFilterStatus(String(value));
  };

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
  };

  const handleRefresh = useCallback(() => {
    setSearchQuery('');
    setFilterStatus('all');
    refetchAreas();
  }, [refetchAreas]);

  const renderItemActions = (item: Area) => (
    <IconButton
      icon="format-list-bulleted"
      size={responsive.isTablet ? 24 : 28}
      onPress={() => handleNavigateToTables(item)}
      iconColor={theme.colors.primary}
    />
  );

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingAreas,
    isError: isErrorAreas,
    data: areasData,
    emptyConfig: {
      title: 'No hay áreas',
      message:
        'No hay áreas registradas. Presiona el botón + para crear la primera.',
      icon: 'map-marker-outline',
    },
    errorConfig: {
      title: 'Error al cargar áreas',
      message: 'No se pudieron cargar las áreas. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchAreas,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Area>
        items={areasData}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        filterOptions={filterOptions}
        filterValue={filterStatus}
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        renderItemActions={renderItemActions}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        isDrawerOpen={isDrawerOpen}
        showImagePlaceholder={false}
      />

      <AreaFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSubmit={handleFormSubmit}
        editingItem={editingItem}
        isSubmitting={isSubmitting}
      />

      <GenericDetailModal<Area>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        statusConfig={areaDetailStatusConfig}
        fieldsToDisplay={areaDetailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        showImage={false}
      />
    </SafeAreaView>
  );
};

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
  });

export default AreasScreen;

================
File: app/src/modules/areasTables/screens/TablesScreen.tsx
================
import React, { useMemo, useCallback } from 'react';
import { StyleSheet } from 'react-native';
import { Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '../../../app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '../../../app/components/crud/GenericDetailModal';
import TableFormModal from '../components/TableFormModal';
import {
  useGetTablesByAreaId,
  useCreateTable,
  useUpdateTable,
  useDeleteTable,
} from '../hooks/useTablesQueries';
import { Table, CreateTableDto, UpdateTableDto } from '../schema/table.schema';
import { TablesListScreenProps } from '../navigation/types';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

const TablesScreen: React.FC<TablesListScreenProps> = ({ route }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const { areaId, areaName } = route.params;
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [searchQuery, setSearchQuery] = React.useState('');
  const [filterStatus, setFilterStatus] = React.useState<string>('all');

  const {
    data: tablesData = [],
    isLoading: isLoadingTables,
    isError: isErrorTables,
    refetch: refetchTables,
    isRefetching,
  } = useGetTablesByAreaId(areaId, { enabled: !!areaId });

  // Recargar automáticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('tables');

  const createTableMutation = useCreateTable();
  const updateTableMutation = useUpdateTable();
  const { mutateAsync: deleteTable } = useDeleteTable();

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Table>({
    entityName: 'Mesa',
    queryKey: ['tables', areaId],
    deleteMutationFn: deleteTable,
  });

  const isSubmitting =
    createTableMutation.isPending || updateTableMutation.isPending;

  const handleFormSubmit = async (data: CreateTableDto | UpdateTableDto) => {
    try {
      const dataWithAreaId = { ...data, areaId: areaId };

      if (editingItem) {
        await updateTableMutation.mutateAsync({
          id: editingItem.id,
          data: dataWithAreaId as UpdateTableDto,
        });
      } else {
        await createTableMutation.mutateAsync(dataWithAreaId as CreateTableDto);
      }
      handleCloseModals();
    } catch (error) {}
  };

  const listRenderConfig: RenderItemConfig<Table> = useMemo(
    () => ({
      titleField: 'name',
      descriptionField: 'capacity',
      descriptionFormatter: (capacity) =>
        capacity
          ? `Capacidad: ${capacity} ${capacity === 1 ? 'persona' : 'personas'}`
          : undefined,
      descriptionMaxLength: 30,
      statusConfig: {
        field: 'isActive',
        activeValue: true,
        activeLabel: 'Activa',
        inactiveLabel: 'Inactiva',
      },
    }),
    [],
  );

  const tableDetailFields: DisplayFieldConfig<Table>[] = useMemo(
    () => [
      {
        field: 'capacity',
        label: 'Capacidad',
        render: (value) => (
          <Text style={styles.fieldValueText}>
            {value !== null && value !== undefined
              ? String(value)
              : 'No especificada'}
          </Text>
        ),
      },
    ],
    [styles.fieldValueText],
  );

  const tableDetailStatusConfig = listRenderConfig.statusConfig;

  const filterOptions: FilterOption<string>[] = useMemo(
    () => [
      { label: 'Todas', value: 'all' },
      { label: 'Activas', value: 'true' },
      { label: 'Inactivas', value: 'false' },
    ],
    [],
  );

  const handleFilterChange = (value: string | number) => {
    setFilterStatus(String(value));
  };

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
  };

  const handleRefresh = useCallback(() => {
    setSearchQuery('');
    setFilterStatus('all');
    refetchTables();
  }, [refetchTables]);

  const filteredAndSearchedTables = useMemo(() => {
    let processed = [...tablesData];

    const isActiveFilter =
      filterStatus === 'all' ? undefined : filterStatus === 'true';
    if (isActiveFilter !== undefined) {
      processed = processed.filter(
        (table) => table.isActive === isActiveFilter,
      );
    }

    if (searchQuery.trim()) {
      const lowerCaseQuery = searchQuery.toLowerCase();
      processed = processed.filter((table) =>
        table.name.toLowerCase().includes(lowerCaseQuery),
      );
    }

    return processed;
  }, [tablesData, filterStatus, searchQuery]);

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingTables,
    isError: isErrorTables,
    data: filteredAndSearchedTables,
    emptyConfig: {
      title: 'No hay mesas',
      message: `No hay mesas registradas en ${areaName}. Presiona el botón + para crear la primera.`,
      icon: 'table-furniture',
    },
    errorConfig: {
      title: 'Error al cargar mesas',
      message: 'No se pudieron cargar las mesas. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchTables,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Table>
        items={filteredAndSearchedTables}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        filterOptions={filterOptions}
        filterValue={filterStatus}
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
      />

      <TableFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSubmit={handleFormSubmit}
        editingItem={editingItem}
        isSubmitting={isSubmitting}
      />

      <GenericDetailModal<Table>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        statusConfig={tableDetailStatusConfig}
        fieldsToDisplay={tableDetailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        showImage={false}
      />
    </SafeAreaView>
  );
};

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
    fieldValueText: {
      flexShrink: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
      fontSize: responsive.fontSize(14),
    },
  });

export default TablesScreen;

================
File: app/src/modules/menu/screens/CategoriesScreen.tsx
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { StyleSheet } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useDrawerStatus } from '@react-navigation/drawer';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, IconButton } from 'react-native-paper';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useAppTheme } from '../../../app/styles/theme';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
import { useListState } from '../../../app/hooks/useListState';
import GenericList from '../../../app/components/crud/GenericList';
import { FilterOption } from '../../../app/components/crud/GenericList';
import GenericDetailModal from '../../../app/components/crud/GenericDetailModal';
import GenericFormModal, {
  FormFieldConfig,
  ImagePickerConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  ImageUploadService,
  FileObject,
} from '../../../app/lib/imageUploadService';
import categoryService from '../services/categoryService';
import {
  Category,
  CategoryFormData,
  CreateCategoryDto,
  UpdateCategoryDto,
  categoryFormSchema,
} from '../schema/category.schema';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';

type RootStackParamList = {
  Categories: undefined;
  SubcategoriesScreen: { categoryId: string; categoryName?: string };
};
type CategoriesScreenNavigationProp = NativeStackNavigationProp<
  RootStackParamList,
  'Categories'
>;

const CategoriesScreen: React.FC = () => {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const navigation = useNavigation<CategoriesScreenNavigationProp>();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [modalVisible, setModalVisible] = useState(false);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(
    null,
  );
  const [activeFilter, setActiveFilter] = useState<string | number>('all');
  const [isUploadingImage, setIsUploadingImage] = useState(false);
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [categoryToDelete, setCategoryToDelete] = useState<string | null>(null);

  const {
    data: categoriesResponse,
    isLoading: isLoadingCategories,
    isError: isErrorCategories,
    refetch: refetchCategories,
    isFetching: isFetchingCategories,
  } = useQuery({
    queryKey: ['categories', { filter: activeFilter }],
    queryFn: () =>
      categoryService.getCategories({
        isActive:
          activeFilter === 'all' ? undefined : activeFilter === 'active',
      }),
  });

  // Refrescar categorías cuando la pantalla recibe foco

  useRefreshModuleOnFocus('categories');

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingCategories,
    isError: isErrorCategories,
    data: categoriesResponse?.data,
    emptyConfig: {
      title: 'No hay categorías',
      message:
        activeFilter !== 'all'
          ? `No hay categorías ${activeFilter === 'active' ? 'activas' : 'inactivas'} registradas.`
          : 'No hay categorías registradas. Presiona el botón + para crear la primera.',
      icon: 'folder-outline',
    },
    errorConfig: {
      title: 'Error al cargar categorías',
      message: 'No se pudieron cargar las categorías. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchCategories,
    },
  });

  const commonMutationOptions = {
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['categories'] });
      closeModals();
    },
    onError: (error: unknown) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      setIsUploadingImage(false);
    },
  };

  const createCategoryMutation = useMutation({
    mutationFn: (data: CreateCategoryDto) =>
      categoryService.createCategory(data),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({
        message: 'Categoría creada exitosamente',
        type: 'success',
      });
    },
  });

  const updateCategoryMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateCategoryDto }) =>
      categoryService.updateCategory(id, data),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({
        message: 'Categoría actualizada exitosamente',
        type: 'success',
      });
    },
  });

  const deleteCategoryMutation = useMutation({
    mutationFn: (id: string) => categoryService.deleteCategory(id),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({ message: 'Categoría eliminada', type: 'success' });
    },
  });
  const openAddModal = useCallback(() => {
    setEditingCategory(null);
    setModalVisible(true);
  }, []);

  const openEditModal = useCallback((category: Category) => {
    setEditingCategory(category);
    setDetailModalVisible(false);
    setModalVisible(true);
  }, []);

  const openDetailModal = useCallback((category: Category) => {
    setSelectedCategory(category);
    setDetailModalVisible(true);
  }, []);

  const closeModals = useCallback(() => {
    setModalVisible(false);
    setDetailModalVisible(false);
    setEditingCategory(null);
    setSelectedCategory(null);
    setIsUploadingImage(false);
  }, []);

  const handleFilterChange = (value: string | number) => {
    setActiveFilter(value);
  };

  const handleFormSubmit = async (
    formData: CategoryFormData,
    photoId: string | null | undefined,
  ) => {
    const { imageUri, ...dataToSubmit } = formData;
    const finalData: any = {
      ...dataToSubmit,
    };

    // Solo incluir photoId si tiene un valor definido (string o null)
    if (photoId !== undefined) {
      finalData.photoId = photoId;
    }

    if (editingCategory) {
      updateCategoryMutation.mutate({
        id: editingCategory.id,
        data: finalData as UpdateCategoryDto,
      });
    } else {
      createCategoryMutation.mutate(finalData as CreateCategoryDto);
    }
  };

  const handleDelete = (id: string) => {
    setCategoryToDelete(id);
    setShowDeleteConfirmation(true);
  };

  const handleConfirmDelete = () => {
    if (categoryToDelete) {
      deleteCategoryMutation.mutate(categoryToDelete);
      setShowDeleteConfirmation(false);
      setCategoryToDelete(null);
    }
  };

  const categories = useMemo(() => {
    return categoriesResponse?.data ?? [];
  }, [categoriesResponse?.data]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        container: { flex: 1, backgroundColor: theme.colors.background },
      }),
    [theme],
  );

  const [formInitialValues, setFormInitialValues] = useState<CategoryFormData>({
    name: '',
    description: null,
    isActive: true,
    sortOrder: 0,
    imageUri: null,
  });

  useEffect(() => {
    const loadFormData = async () => {
      if (editingCategory) {
        let imageUrl = null;
        if (editingCategory.photo?.path) {
          try {
            const { getImageUrl } = await import('@/app/lib/imageUtils');
            imageUrl = await getImageUrl(editingCategory.photo.path);
          } catch (error) {
            imageUrl = editingCategory.photo.path;
          }
        }

        setFormInitialValues({
          name: editingCategory.name,
          description: editingCategory.description ?? null,
          isActive: editingCategory.isActive,
          sortOrder: editingCategory.sortOrder ?? 0,
          imageUri: imageUrl,
        });
      } else {
        setFormInitialValues({
          name: '',
          description: null,
          isActive: true,
          sortOrder: 0,
          imageUri: null,
        });
      }
    };

    loadFormData();
  }, [editingCategory]);

  const selectedCategoryMapped = useMemo(() => {
    if (!selectedCategory) return null;
    return selectedCategory;
  }, [selectedCategory]);

  const filterOptions: FilterOption<string | number>[] = [
    { value: 'all', label: 'Todas' },
    { value: 'active', label: 'Activas' },
    { value: 'inactive', label: 'Inactivas' },
  ];

  const listRenderConfig = {
    titleField: 'name' as keyof Category,
    descriptionField: 'description' as keyof Category,
    descriptionMaxLength: 60,
    imageField: 'photo' as keyof Category,
    sortOrderField: 'sortOrder' as keyof Category,
    statusConfig: {
      field: 'isActive' as keyof Category,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };

  const formFieldsConfig: FormFieldConfig<CategoryFormData>[] = [
    { name: 'name', label: 'Nombre', type: 'text', required: true },
    {
      name: 'description',
      label: 'Descripción',
      type: 'textarea',
      numberOfLines: 3,
    },
    {
      name: 'sortOrder',
      label: 'Orden de visualización',
      type: 'number',
      placeholder: '0',
    },
    {
      name: 'isActive',
      label: 'Estado',
      type: 'switch',
      switchLabel: 'Activa',
    },
  ];

  const imagePickerConfig: ImagePickerConfig<CategoryFormData> = {
    imageUriField: 'imageUri',
    onImageUpload: async (file: FileObject) => {
      setIsUploadingImage(true);
      try {
        const result = await ImageUploadService.uploadImage(file);
        if (result.success && result.photoId) {
          return { id: result.photoId };
        }
        throw new Error(result.error || 'Error desconocido al subir imagen');
      } finally {
        setIsUploadingImage(false);
      }
    },
    determineFinalPhotoId: ImageUploadService.determinePhotoId,
    imagePickerSize: 150,
    placeholderIcon: 'folder-outline',
    placeholderText: 'Imagen de categoría',
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList
        items={categories}
        enableSort={true}
        enableSearch={true}
        searchPlaceholder="Buscar categorías..."
        filterValue={activeFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        renderItemActions={(item: Category) => (
          <IconButton
            icon="format-list-bulleted"
            size={28}
            onPress={() =>
              navigation.navigate('SubcategoriesScreen', {
                categoryId: item.id,
                categoryName: item.name,
              })
            }
            style={{ margin: 0 }}
          />
        )}
        renderConfig={listRenderConfig}
        onItemPress={openDetailModal}
        onRefresh={refetchCategories}
        isRefreshing={isFetchingCategories && !isLoadingCategories}
        ListEmptyComponent={ListEmptyComponent}
        showFab={true}
        onFabPress={openAddModal}
        isModalOpen={modalVisible || detailModalVisible}
        showImagePlaceholder={true}
        placeholderIcon="folder-outline"
        isDrawerOpen={isDrawerOpen} // Pasar estado del drawer
      />

      <Portal>
        <GenericFormModal
          visible={modalVisible}
          onDismiss={closeModals}
          onSubmit={handleFormSubmit}
          formSchema={categoryFormSchema}
          formFields={formFieldsConfig}
          imagePickerConfig={imagePickerConfig}
          initialValues={formInitialValues}
          editingItem={editingCategory}
          isSubmitting={
            createCategoryMutation.isPending ||
            updateCategoryMutation.isPending ||
            isUploadingImage
          }
          modalTitle={(isEditing) =>
            isEditing ? 'Editar Categoría' : 'Nueva Categoría'
          }
          submitButtonLabel={(isEditing) => (isEditing ? 'Guardar' : 'Crear')}
        />

        <GenericDetailModal
          visible={detailModalVisible}
          onDismiss={closeModals}
          item={selectedCategoryMapped}
          titleField="name"
          imageField="photo"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={[
            {
              field: 'sortOrder',
              label: 'Orden de visualización',
              render: (value) => value ?? '0',
            },
            {
              field: 'createdAt',
              label: 'Fecha de creación',
              render: (value) => {
                if (!value) return 'N/A';
                const date = new Date(value as string);
                return date.toLocaleDateString('es-ES', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                });
              },
            },
            {
              field: 'updatedAt',
              label: 'Última actualización',
              render: (value) => {
                if (!value) return 'N/A';
                const date = new Date(value as string);
                return date.toLocaleDateString('es-ES', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                });
              },
            },
          ]}
          onEdit={openEditModal as (item: any) => void}
          onDelete={handleDelete}
          isDeleting={deleteCategoryMutation.isPending}
          showImage={true}
        />

        <ConfirmationModal
          visible={showDeleteConfirmation}
          title="Confirmar Eliminación"
          message="¿Estás seguro de que quieres eliminar esta categoría? Esta acción no se puede deshacer."
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
          onConfirm={handleConfirmDelete}
          onCancel={() => {
            setShowDeleteConfirmation(false);
            setCategoryToDelete(null);
          }}
          onDismiss={() => {
            setShowDeleteConfirmation(false);
            setCategoryToDelete(null);
          }}
        />
      </Portal>
    </SafeAreaView>
  );
};

export default CategoriesScreen;

================
File: app/src/modules/orders/hooks/useOrdersQueries.ts
================
import { useMemo } from 'react';

import {
  useMutation,
  useQuery,
  useQueryClient,
  UseQueryResult,
} from '@tanstack/react-query';
import { orderService } from '../services/orderService';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { OrderDetailsForBackend } from '../components/OrderCartDetail';
import type { FindAllOrdersDto, OrderOpenList } from '../types/orders.types';
import { ApiError } from '@/app/lib/errors';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import type { UpdateOrderPayload } from '../types/update-order.types';

// Query Keys
const orderKeys = {
  all: ['orders'] as const,
  lists: () => [...orderKeys.all, 'list'] as const,
  list: (filters: FindAllOrdersDto) => [...orderKeys.lists(), filters] as const,
  openOrdersList: () => [...orderKeys.all, 'list', 'open-orders-list'] as const,
  details: () => [...orderKeys.all, 'detail'] as const,
  detail: (id: string) => [...orderKeys.details(), id] as const,
};

/**
 * Hook para crear una nueva orden.
 */
export const useCreateOrderMutation = () => {
  const queryClient = useQueryClient();

  return useMutation<Order, ApiError, OrderDetailsForBackend>({
    mutationFn: orderService.createOrder,
    onSuccess: () => {
      // Invalidar queries relevantes si es necesario (ej. lista de órdenes)
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      // Invalidar queries de mesas para reflejar cambios de disponibilidad
      queryClient.invalidateQueries({ queryKey: ['tables'] });
      // El mensaje de éxito se maneja en el componente que llama a la mutación
    },
    onError: (_error) => {
      // El mensaje de error se maneja en el componente que llama a la mutación
    },
  });
};

/**
 * Hook para actualizar una orden existente.
 */
export const useUpdateOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Definir el tipo de las variables de la mutación
  type UpdateVariables = { orderId: string; payload: UpdateOrderPayload };

  return useMutation<Order, ApiError, UpdateVariables>({
    mutationFn: ({ orderId, payload }) =>
      orderService.updateOrder(orderId, payload),
    onSuccess: (updatedOrder, variables) => {
      // Invalidar queries relevantes para refrescar datos
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), variables.orderId],
      });

      // Invalidar queries de mesas para reflejar cambios de disponibilidad
      queryClient.invalidateQueries({ queryKey: ['tables'] });

      showSnackbar({
        message: `Orden #${updatedOrder.shiftOrderNumber} actualizada`,
        type: 'success',
      });
    },
    onError: (error, variables) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al actualizar orden #${variables.orderId}: ${message}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook para cancelar una orden.
 */
export const useCancelOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Order, ApiError, string>({
    mutationFn: (orderId) => orderService.cancelOrder(orderId),
    onSuccess: (cancelledOrder, orderId) => {
      // Invalidar queries relevantes
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), orderId],
      });
      // Invalidar queries de mesas para reflejar cambios de disponibilidad
      queryClient.invalidateQueries({ queryKey: ['tables'] });

      showSnackbar({
        message: `Orden #${cancelledOrder.shiftOrderNumber} cancelada`,
        type: 'info',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al cancelar orden: ${message}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook para completar una orden (cambiar estado a COMPLETED).
 */
export const useCompleteOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Order, ApiError, string>({
    mutationFn: (orderId) =>
      orderService.updateOrder(orderId, { orderStatus: 'COMPLETED' }),
    onSuccess: (completedOrder, orderId) => {
      // Invalidar queries relevantes
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), orderId],
      });

      showSnackbar({
        message: `Orden #${completedOrder.shiftOrderNumber} finalizada exitosamente`,
        type: 'success',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al finalizar orden: ${message}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook optimizado para obtener las órdenes abiertas con campos mínimos.
 */
export const useGetOpenOrdersListQuery = (options?: {
  enabled?: boolean;
}): UseQueryResult<OrderOpenList[], ApiError> => {
  const queryKey = orderKeys.openOrdersList();

  return useQuery<OrderOpenList[], ApiError>({
    queryKey: queryKey,
    queryFn: () => orderService.getOpenOrdersList(),
    enabled: options?.enabled ?? true,
    refetchInterval: 10000, // Actualizar cada 10 segundos
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000,
    gcTime: 10 * 60 * 1000,
    placeholderData: (previousData) => previousData,
  });
};

/**
 * Hook para obtener los detalles completos de una orden por su ID.
 */
export const useGetOrderByIdQuery = (
  orderId: string | null | undefined,
  options?: { enabled?: boolean },
): UseQueryResult<Order, ApiError> => {
  // Definir la clave de detalle usando el orderId
  const detailQueryKey = useMemo(
    () =>
      orderId ? [...orderKeys.details(), orderId] : [...orderKeys.details()],
    [orderId],
  );

  return useQuery<Order, ApiError>({
    queryKey: detailQueryKey,
    queryFn: async () => {
      if (!orderId) {
        // Si no hay orderId, no intentar hacer fetch y devolver un error o estado inicial
        return Promise.reject(new Error('Order ID no proporcionado'));
      }
      const order = await orderService.getOrderById(orderId);
      return order;
    },
    enabled: !!orderId && (options?.enabled ?? true), // Habilitar solo si hay orderId y está habilitado externamente
    staleTime: 0, // Los datos del detalle de la orden siempre deben estar frescos
    gcTime: 0, // No mantener en caché - siempre refetchear cuando se necesite
    refetchOnMount: 'always', // Siempre refetchear cuando el componente se monta
    refetchOnWindowFocus: true, // Refetchear cuando la ventana recupera el foco
  });
};

================
File: app/src/services/shifts.ts
================
import apiClient from '@/app/services/apiClient';
import { handleApiResponse } from '@/app/lib/apiHelpers';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { ShiftSummary, ShiftOrder } from '@/modules/shiftAudit/types';
import type { Order } from '@/app/schemas/domain/order.schema';

export interface ShiftStatus {
  OPEN: 'OPEN';
  CLOSED: 'CLOSED';
}

export interface Shift {
  id: string;
  date: string;
  globalShiftNumber: number;
  shiftNumber: number;
  status: keyof ShiftStatus;
  openedAt: string;
  closedAt: string | null;
  openedBy: {
    id: string;
    firstName: string;
    lastName: string;
  };
  closedBy: {
    id: string;
    firstName: string;
    lastName: string;
  } | null;
  initialCash: number;
  finalCash: number | null;
  totalSales: number | null;
  totalOrders: number | null;
  cashDifference: number | null;
  expectedCash?: number | null;
  notes: string | null;
  closeNotes: string | null;
}

export interface OpenShiftDto {
  initialCash: number;
  notes?: string;
  date?: string;
}

export interface CloseShiftDto {
  finalCash: number;
  closeNotes?: string;
}

class ShiftsService {
  /**
   * Obtener el turno actual
   */
  async getCurrentShift(): Promise<Shift | null> {
    try {
      const response = await apiClient.get(API_PATHS.SHIFTS_CURRENT);
      return response.data;
    } catch (error: any) {
      if (error.response?.status === 404) {
        return null;
      }
      throw error;
    }
  }

  /**
   * Abrir un nuevo turno
   */
  async openShift(data: OpenShiftDto): Promise<Shift> {
    const response = await apiClient.post(API_PATHS.SHIFTS_OPEN, data);

    if (!response.ok) {
      throw (
        response.data ||
        response.originalError ||
        new Error('Error al abrir el turno')
      );
    }

    return response.data;
  }

  /**
   * Cerrar el turno actual
   */
  async closeShift(data: CloseShiftDto): Promise<Shift> {
    const response = await apiClient.post(API_PATHS.SHIFTS_CLOSE, data);

    if (!response.ok) {
      throw (
        response.data ||
        response.originalError ||
        new Error('Error al cerrar el turno')
      );
    }

    return response.data;
  }

  /**
   * Obtener historial de turnos
   */
  async getHistory(params?: {
    startDate?: string;
    endDate?: string;
  }): Promise<Shift[]> {
    const queryParams = new URLSearchParams();

    if (params?.startDate) {
      queryParams.append('startDate', params.startDate);
    }
    if (params?.endDate) {
      queryParams.append('endDate', params.endDate);
    }

    const url = queryParams.toString()
      ? `${API_PATHS.SHIFTS_HISTORY}?${queryParams.toString()}`
      : API_PATHS.SHIFTS_HISTORY;

    const response = await apiClient.get(url);
    return response.data;
  }

  /**
   * Obtener un turno por ID
   */
  async getById(id: string): Promise<Shift> {
    const response = await apiClient.get(
      API_PATHS.SHIFTS_DETAIL.replace(':id', id),
    );
    return response.data;
  }

  /**
   * Verificar si hay un turno abierto
   */
  async isShiftOpen(): Promise<boolean> {
    const currentShift = await this.getCurrentShift();
    return currentShift !== null && currentShift.status === 'OPEN';
  }

  /**
   * Obtiene todas las órdenes de un turno específico
   */
  async getOrdersByShift(shiftId: string): Promise<Order[]> {
    const url = API_PATHS.ORDERS_BY_SHIFT.replace(':shiftId', shiftId);
    const response = await apiClient.get<any>(url);
    const data = handleApiResponse(response);

    // Asegurar que siempre devuelva un array
    return Array.isArray(data) ? data : data?.data || [];
  }

  /**
   * Calcula el resumen de un turno con estadísticas
   */
  calculateShiftSummary(shift: Shift, orders: Order[]): ShiftSummary {
    // Normalizar el shift para que sea compatible con el tipo ShiftSummary
    const normalizedShift = {
      ...shift,
      status: shift.status === 'OPEN' ? ('open' as const) : ('closed' as const),
    };
    const paymentMethodsSummary = new Map<
      string,
      { count: number; total: number }
    >();
    const productsSummary = new Map<
      string,
      { quantity: number; total: number }
    >();

    if (!Array.isArray(orders)) {
      // Orders no es un array en calculateShiftSummary
      return {
        shift,
        ordersCount: 0,
        totalSales: 0,
        paymentMethodsSummary: [],
        productsSummary: [],
      };
    }

    orders.forEach((order) => {
      // Calcular el total de la orden
      const orderTotal =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;

      // Resumen por método de pago
      let paymentMethod = 'Sin pagar';
      if (order.payments && order.payments.length > 0) {
        paymentMethod = order.payments[0].paymentMethod || 'Efectivo';
      }

      const current = paymentMethodsSummary.get(paymentMethod) || {
        count: 0,
        total: 0,
      };
      paymentMethodsSummary.set(paymentMethod, {
        count: current.count + 1,
        total: current.total + orderTotal,
      });

      // Resumen por productos
      order.orderItems?.forEach((item: any) => {
        const productName =
          item.product?.name || item.productName || 'Producto';
        const itemTotal = item.total || item.quantity * item.unitPrice || 0;
        const current = productsSummary.get(productName) || {
          quantity: 0,
          total: 0,
        };
        productsSummary.set(productName, {
          quantity: current.quantity + (item.quantity || 1),
          total: current.total + itemTotal,
        });
      });
    });

    // Calcular el total de ventas correctamente
    const totalSales = orders.reduce((sum, order) => {
      const orderTotal =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;
      return sum + orderTotal;
    }, 0);

    return {
      shift: normalizedShift,
      ordersCount: orders.length,
      totalSales: totalSales,
      paymentMethodsSummary: Array.from(paymentMethodsSummary.entries()).map(
        ([method, data]) => ({
          method,
          count: data.count,
          total: data.total,
        }),
      ),
      productsSummary: Array.from(productsSummary.entries())
        .map(([productName, data]) => ({
          productName,
          quantity: data.quantity,
          total: data.total,
        }))
        .sort((a, b) => b.total - a.total)
        .slice(0, 10), // Top 10 productos
    };
  }

  /**
   * Formatea las órdenes para mostrar en la vista de detalle
   */
  formatOrdersForDetail(orders: Order[]): ShiftOrder[] {
    if (!Array.isArray(orders)) {
      // Orders no es un array
      return [];
    }

    return orders.map((order) => {
      // Calcular el total si no está definido
      const total =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;

      // Determinar el método de pago
      let paymentMethod = 'Sin pagar';
      if (order.payments && order.payments.length > 0) {
        paymentMethod = order.payments[0].paymentMethod || 'Efectivo';
      }

      return {
        id: order.id,
        orderNumber:
          order.orderNumber || `#${order.shiftOrderNumber || order.id}`,
        total: total,
        status: order.orderStatus || 'COMPLETED',
        paymentMethod: paymentMethod,
        customerName: (order.deliveryInfo as any)?.customerName || null,
        createdAt:
          typeof order.createdAt === 'string'
            ? order.createdAt
            : order.createdAt.toISOString(),
        items:
          order.orderItems?.map((item: any) => ({
            id: item.id || String(Math.random()),
            productName: item.product?.name || item.productName || 'Producto',
            quantity: item.quantity || 1,
            unitPrice: item.unitPrice || 0,
            total: item.total || item.quantity * item.unitPrice || 0,
            modifiers:
              item.productModifiers?.map(
                (mod: any) => mod.modifierName || mod.name,
              ) || [],
          })) || [],
      };
    });
  }
}

export const shiftsService = new ShiftsService();

================
File: app/src/modules/auth/screens/LoginScreen.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleSheet,
  View,
  ActivityIndicator,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Text, IconButton, Surface, TouchableRipple } from 'react-native-paper';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import EncryptedStorage from '@/app/services/secureStorageService';
import { STORAGE_KEYS } from '../../../app/constants/storageKeys';
import { useAppTheme } from '../../../app/styles/theme';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
import { useThemeStore } from '../../../app/store/themeStore';
import { useAuthStore } from '../../../app/store/authStore';
import { LoginFormInputs, LoginResponseDto } from '../schema/auth.schema';
import { authService } from '../services/authService';
import LoginForm from '../components/LoginForm';
import { ConnectionIndicator } from '../../../app/components/ConnectionIndicator';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { ConnectionErrorModal } from '../../../app/components/ConnectionErrorModal';
import { useServerConnection } from '../../../app/hooks/useServerConnection';
import { RegisterModal } from '../components/RegisterForm';
import { OrientationTransition } from '../../../app/components/OrientationTransition';
import * as ScreenOrientation from 'expo-screen-orientation';

const LoginScreen = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const queryClient = useQueryClient();
  const { showSnackbar } = useSnackbarStore();
  const { setThemePreference } = useThemeStore();
  const setTokens = useAuthStore((state) => state.setTokens);
  const { isConnected, serverUrl } = useServerConnection();

  const [initialEmailOrUsername, setInitialEmailOrUsername] = useState<
    string | undefined
  >(undefined);
  const [initialPassword, setInitialPassword] = useState<string | undefined>(
    undefined,
  );
  const [initialRememberMe, setInitialRememberMe] = useState(false);
  const [isLoadingCredentials, setIsLoadingCredentials] = useState(true);
  const [showRegisterModal, setShowRegisterModal] = useState(false);

  type LoginMutationVariables = LoginFormInputs & { rememberMe: boolean };

  const loginMutation = useMutation<
    LoginResponseDto,
    Error,
    LoginMutationVariables
  >({
    mutationFn: (variables) =>
      authService.login({
        emailOrUsername: variables.emailOrUsername,
        password: variables.password,
      }),
    onSuccess: async (data, variables) => {
      try {
        // Verificar si el usuario está activo antes de guardar los tokens
        if (data.user && !data.user.isActive) {
          showSnackbar({
            message: 'Tu cuenta está inactiva. Contacta al administrador.',
            type: 'error',
          });
          return;
        }

        await setTokens(data.token, data.refreshToken, data.user ?? null);
        const { emailOrUsername, password, rememberMe } = variables;

        if (rememberMe) {
          const credentialsToSave = JSON.stringify({
            emailOrUsername,
            password,
          });
          await EncryptedStorage.setItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
            credentialsToSave,
          );
          await EncryptedStorage.setItem(
            STORAGE_KEYS.REMEMBER_ME_ENABLED,
            'true',
          );
        } else {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        }

        showSnackbar({
          message: `¡Bienvenido!`,
          type: 'success',
        });
        queryClient.invalidateQueries({ queryKey: ['user', 'me'] });
      } catch (error: any) {
        if (error.message === 'Usuario inactivo') {
          showSnackbar({
            message: 'Tu cuenta está inactiva. Contacta al administrador.',
            type: 'error',
          });
        }

        try {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        } catch (cleanupError) {}

        showSnackbar({
          message: 'Error procesando el inicio de sesión.',
          type: 'error',
        });
      }
    },
    onError: (error: any) => {
      const errorMessage = getApiErrorMessage(error);

      if (
        errorMessage.includes('credenciales') ||
        errorMessage.includes('contraseña') ||
        errorMessage.includes('usuario') ||
        error.response?.status === 401
      ) {
        showSnackbar({
          message: errorMessage,
          type: 'error',
          duration: 5000,
        });
      }
    },
  });

  const handleLoginSubmit = (data: LoginFormInputs, rememberMe: boolean) => {
    loginMutation.mutate({ ...data, rememberMe });
  };

  useEffect(() => {
    const loadCredentials = async () => {
      setIsLoadingCredentials(true);
      try {
        const rememberEnabled = await EncryptedStorage.getItem(
          STORAGE_KEYS.REMEMBER_ME_ENABLED,
        );
        if (rememberEnabled === 'true') {
          const storedCredentialsJson = await EncryptedStorage.getItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          if (storedCredentialsJson) {
            const storedCredentials = JSON.parse(storedCredentialsJson);
            setInitialEmailOrUsername(storedCredentials.emailOrUsername);
            setInitialPassword(storedCredentials.password);
            setInitialRememberMe(true);
          } else {
            setInitialRememberMe(false);
            setInitialEmailOrUsername('');
            setInitialPassword('');
            await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
          }
        } else {
          setInitialRememberMe(false);
          setInitialEmailOrUsername('');
          setInitialPassword('');
        }
      } catch (error) {
        setInitialRememberMe(false);
        setInitialEmailOrUsername('');
        setInitialPassword('');
        try {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        } catch (cleanupError) {}
      } finally {
        setIsLoadingCredentials(false);
      }
    };

    loadCredentials();
  }, []);

  const toggleTheme = () => {
    setThemePreference(theme.dark ? 'light' : 'dark');
  };

  const handleRegisterSuccess = (username: string, password: string) => {
    setInitialEmailOrUsername(username);
    setInitialPassword(password);
    setInitialRememberMe(false);
  };

  const isWeb = Platform.OS === 'web';
  const isDesktop = isWeb && responsive.dimensions.width >= 1024;
  const isTablet =
    isWeb &&
    responsive.dimensions.width >= 768 &&
    responsive.dimensions.width < 1024;

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: theme.colors.background,
        },
        scrollView: {
          flexGrow: 1,
        },
        webContainer: {
          flex: 1,
          flexDirection: isDesktop ? 'row' : 'column',
          minHeight: '100vh',
          width: '100%',
        },
        webLeftPanel: {
          flex: isDesktop ? 1 : undefined,
          backgroundColor: theme.dark
            ? theme.colors.primaryContainer
            : theme.colors.primary,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacingPreset.xl,
          ...(isTablet && {
            paddingVertical: responsive.spacingPreset.xxl,
          }),
        },
        webRightPanel: {
          flex: isDesktop ? 1 : undefined,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacingPreset.xl,
          backgroundColor: theme.colors.background,
          minHeight: isDesktop ? '100vh' : undefined,
          width: '100%',
        },
        webBrandingContainer: {
          alignItems: 'center',
          marginBottom: responsive.spacingPreset.xl,
        },
        webBrandingLogo: {
          width: isDesktop ? 200 : 150,
          height: isDesktop ? 200 : 150,
          marginBottom: responsive.spacingPreset.l,
          borderRadius: isDesktop ? 100 : 75,
          backgroundColor: theme.colors.surface,
          overflow: 'hidden',
          borderWidth: theme.dark ? 2 : 0,
          borderColor: theme.dark ? theme.colors.outline : 'transparent',
        },
        webBrandingTitle: {
          fontSize: isDesktop ? 48 : 36,
          fontWeight: 'bold',
          color: theme.dark
            ? theme.colors.onPrimaryContainer
            : theme.colors.onPrimary,
          marginBottom: responsive.spacingPreset.m,
          textAlign: 'center',
        },
        webBrandingSubtitle: {
          fontSize: isDesktop ? 20 : 18,
          color: theme.dark
            ? theme.colors.onPrimaryContainer
            : theme.colors.onPrimary,
          opacity: theme.dark ? 0.8 : 0.9,
          textAlign: 'center',
          maxWidth: 400,
          lineHeight: 28,
        },
        webFormWrapper: {
          width: '100%',
          maxWidth: isDesktop ? 450 : 400,
          alignItems: 'center',
        },
        container: {
          flex: 1,
          padding: responsive.spacingPreset.l,
          justifyContent: 'space-between',
        },
        logoContainer: {
          alignItems: 'center',
          marginTop: responsive.spacingPreset.xl,
          marginBottom: responsive.spacingPreset.m,
        },
        logo: {
          width: 160,
          height: 160,
          marginBottom: 16,
          borderRadius: 80,
          backgroundColor: 'transparent',
          overflow: 'hidden',
        },
        title: {
          fontSize: 32,
          fontWeight: 'bold',
          color: theme.colors.primary,
          marginBottom: 8,
          textAlign: 'center',
        },
        subtitle: {
          fontSize: responsive.fontSizePreset.m,
          color: theme.colors.onSurfaceVariant,
          marginBottom: responsive.spacingPreset.xl,
          textAlign: 'center',
          paddingHorizontal: responsive.spacingPreset.l,
        },
        formContainer: {
          backgroundColor: theme.colors.surface,
          borderRadius: 16,
          padding: responsive.spacingPreset.m,
          elevation: 2,
          marginBottom: responsive.spacingPreset.m,
          paddingVertical: responsive.spacingPreset.l,
          ...(isWeb && {
            width: '100%',
            shadowColor: theme.dark
              ? 'rgba(255,255,255,0.1)'
              : 'rgba(0,0,0,0.1)',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 1,
            shadowRadius: 8,
            borderWidth: theme.dark ? 1 : 0,
            borderColor: theme.dark
              ? theme.colors.surfaceVariant
              : 'transparent',
          }),
        },
        registerContainer: {
          flexDirection: 'row',
          justifyContent: 'center',
          alignItems: 'center',
          marginTop: responsive.spacingPreset.xl,
        },
        registerText: {
          color: theme.colors.onSurfaceVariant,
          marginRight: 8,
        },
        registerLink: {
          color: theme.colors.primary,
          fontWeight: 'bold',
        },
        bottomThemeToggleContainer: {
          alignItems: 'center',
          marginTop: 20,
          marginBottom: 16,
        },
        webThemeToggle: {
          position: 'absolute',
          top: responsive.spacingPreset.l,
          right: responsive.spacingPreset.l,
          zIndex: 10,
        },
      }),
    [theme, isDesktop, isTablet],
  );

  if (isLoadingCredentials) {
    return (
      <SafeAreaView
        style={[
          styles.safeArea,
          { justifyContent: 'center', alignItems: 'center' },
        ]}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </SafeAreaView>
    );
  }

  const webContent = (
    <View
      style={{
        flex: 1,
        height: '100vh',
        backgroundColor: theme.colors.background,
      }}
    >
      <ConnectionErrorModal />
      <RegisterModal
        visible={showRegisterModal}
        onDismiss={() => setShowRegisterModal(false)}
        onRegisterSuccess={handleRegisterSuccess}
      />

      {/* Theme toggle button */}
      <View style={{ position: 'absolute', top: 20, right: 20, zIndex: 10 }}>
        <IconButton
          icon={theme.dark ? 'weather-night' : 'weather-sunny'}
          size={30}
          onPress={toggleTheme}
          iconColor={theme.colors.onSurfaceVariant}
        />
      </View>

      <ScrollView
        contentContainerStyle={{
          flexGrow: 1,
          justifyContent: 'center',
          alignItems: 'center',
          padding: 20,
        }}
      >
        <View
          style={{
            width: '100%',
            maxWidth: 380,
            alignItems: 'center',
          }}
        >
          {/* Logo */}
          <Image
            source={require('../../../../assets/icon.png')}
            style={{
              width: 200,
              height: 200,
              borderRadius: 100,
              marginBottom: 30,
            }}
            resizeMode="cover"
          />

          {/* Login form card */}
          <View
            style={{
              width: '100%',
              backgroundColor: theme.colors.surface,
              borderRadius: 16,
              padding: 24,
              shadowColor: theme.dark
                ? 'rgba(255,255,255,0.1)'
                : 'rgba(0,0,0,0.1)',
              shadowOffset: { width: 0, height: 4 },
              shadowOpacity: 1,
              shadowRadius: 12,
              elevation: 4,
              borderWidth: theme.dark ? 1 : 0,
              borderColor: theme.dark ? 'rgba(255,255,255,0.1)' : 'transparent',
            }}
          >
            <Text
              style={{
                fontSize: 24,
                fontWeight: 'bold',
                color: theme.colors.onSurface,
                marginBottom: 8,
                textAlign: 'center',
              }}
            >
              Iniciar Sesión
            </Text>
            <Text
              style={{
                fontSize: 14,
                color: theme.colors.onSurfaceVariant,
                marginBottom: 20,
                textAlign: 'center',
              }}
            >
              Ingresa tus credenciales para continuar
            </Text>

            <LoginForm
              onSubmit={handleLoginSubmit}
              isLoading={loginMutation.isPending}
              initialEmailOrUsername={initialEmailOrUsername}
              initialPassword={initialPassword}
              initialRememberMe={initialRememberMe}
            />

            <View
              style={{
                flexDirection: 'row',
                justifyContent: 'center',
                alignItems: 'center',
                marginTop: 16,
              }}
            >
              <Text
                style={{
                  color: theme.colors.onSurfaceVariant,
                  fontSize: 14,
                }}
              >
                ¿No tienes una cuenta?
              </Text>
              <TouchableRipple
                onPress={() => setShowRegisterModal(true)}
                style={{ marginLeft: 5 }}
              >
                <Text
                  style={{
                    color: theme.colors.primary,
                    fontWeight: 'bold',
                    fontSize: 14,
                  }}
                >
                  Regístrate
                </Text>
              </TouchableRipple>
            </View>
          </View>
        </View>
      </ScrollView>
    </View>
  );

  const mobileContent = (
    <SafeAreaView style={styles.safeArea}>
      <ConnectionErrorModal />
      <RegisterModal
        visible={showRegisterModal}
        onDismiss={() => setShowRegisterModal(false)}
        onRegisterSuccess={handleRegisterSuccess}
      />
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        <ScrollView
          contentContainerStyle={styles.scrollView}
          keyboardShouldPersistTaps="handled"
        >
          <View style={styles.container}>
            <View>
              <View
                style={{
                  position: 'absolute',
                  top: -responsive.spacing.s,
                  right: -responsive.spacing.s,
                  zIndex: 1,
                }}
              >
                <ConnectionIndicator />
              </View>
              <View style={styles.logoContainer}>
                <Image
                  source={require('../../../../assets/icon.png')}
                  style={styles.logo}
                  resizeMode="cover"
                />
                <Text style={styles.title}>¡Bienvenido!</Text>
                <Text style={styles.subtitle}>
                  Inicia sesión para gestionar tus pedidos
                </Text>
              </View>

              <Surface style={styles.formContainer}>
                <LoginForm
                  onSubmit={handleLoginSubmit}
                  isLoading={loginMutation.isPending}
                  initialEmailOrUsername={initialEmailOrUsername}
                  initialPassword={initialPassword}
                  initialRememberMe={initialRememberMe}
                />
              </Surface>
            </View>

            <View>
              <View style={styles.registerContainer}>
                <Text style={styles.registerText}>¿No tienes una cuenta?</Text>
                <TouchableRipple onPress={() => setShowRegisterModal(true)}>
                  <Text style={styles.registerLink}>Regístrate</Text>
                </TouchableRipple>
              </View>
              <View style={styles.bottomThemeToggleContainer}>
                <IconButton
                  icon={theme.dark ? 'weather-night' : 'weather-sunny'}
                  size={responsive.dimensions.iconSize.large}
                  onPress={toggleTheme}
                  iconColor={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );

  const content = isWeb ? webContent : mobileContent;

  return Platform.OS === 'web' ? (
    content
  ) : (
    <OrientationTransition
      targetOrientation={ScreenOrientation.OrientationLock.PORTRAIT_UP}
    >
      {content}
    </OrientationTransition>
  );
};

export default LoginScreen;

================
File: app/src/modules/customers/components/AddressFormModal.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  Chip,
  Avatar,
  IconButton,
  Icon,
  ActivityIndicator,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { Address, CreateAddressDto } from '../types/customer.types';
import { addressSchema, AddressFormInputs } from '../schema/customer.schema';
import { WebView } from 'react-native-webview';
import { GOOGLE_MAPS_CONFIG } from '../constants/maps.config';
import { useGoogleMapsConfig } from '@/hooks/useGoogleMapsConfig';
import { useSnackbarStore } from '@/app/store/snackbarStore';

interface AddressFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: CreateAddressDto) => Promise<void>;
  editingItem: Address | null;
  isSubmitting: boolean;
  customerId: string;
}

export default function AddressFormModal({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}: AddressFormModalProps) {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  const showSnackbar = useSnackbarStore((state) => state.show);
  const { config: mapsConfig, loading: isLoadingApiKey } =
    useGoogleMapsConfig();
  const apiKey = mapsConfig?.apiKey;
  const [mapReady, setMapReady] = useState(false);
  const [isMapLoading, setIsMapLoading] = useState(true);
  const [isMapFullscreen, setIsMapFullscreen] = useState(false);
  const webViewRef = useRef<WebView>(null);
  const scrollViewRef = useRef<ScrollView>(null);

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
    watch,
    trigger,
  } = useForm<AddressFormInputs>({
    resolver: zodResolver(addressSchema),
    defaultValues: {
      name: '',
      street: '',
      number: '',
      interiorNumber: '',
      neighborhood: '',
      city: '',
      state: '',
      zipCode: '',
      country: 'México',
      deliveryInstructions: '',
      isDefault: false,
    },
  });

  const latitude = watch('latitude');
  const longitude = watch('longitude');

  useEffect(() => {
    if (editingItem) {
      reset({
        name: editingItem.name,
        street: editingItem.street,
        number: editingItem.number,
        interiorNumber: editingItem.interiorNumber || '',
        neighborhood: editingItem.neighborhood,
        city: editingItem.city,
        state: editingItem.state,
        zipCode: editingItem.zipCode,
        country: editingItem.country || 'México',
        deliveryInstructions: editingItem.deliveryInstructions || '',
        // Convertir a número si existe, undefined si no
        latitude: editingItem.latitude
          ? Number(editingItem.latitude)
          : undefined,
        longitude: editingItem.longitude
          ? Number(editingItem.longitude)
          : undefined,
        isDefault: editingItem.isDefault,
      });
    } else {
      reset({
        name: '',
        street: '',
        number: '',
        interiorNumber: '',
        neighborhood: '',
        city: '',
        state: '',
        zipCode: '',
        country: 'México',
        deliveryInstructions: '',
        isDefault: false,
      });
    }
  }, [editingItem, reset]);

  // HTML del mapa con Google Maps API - Memoizado para evitar recrearlo en cada render
  const mapHtml = React.useMemo(
    () =>
      apiKey
        ? `
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      touch-action: manipulation;
    }
    #map {
      height: 100%;
      width: 100%;
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    let map;
    let marker;
    let currentLocation = null;

    function initMap() {
      // Inicializar el mapa
      const initialLocation = ${
        latitude && longitude
          ? `{ lat: ${latitude}, lng: ${longitude} }`
          : 'null'
      };
      
      // Configurar centro del mapa
      const mapCenter = initialLocation || { lat: ${GOOGLE_MAPS_CONFIG.defaultCenter.lat}, lng: ${GOOGLE_MAPS_CONFIG.defaultCenter.lng} };
      
      map = new google.maps.Map(document.getElementById('map'), {
        center: mapCenter,
        zoom: initialLocation ? ${GOOGLE_MAPS_CONFIG.locationZoom} : ${GOOGLE_MAPS_CONFIG.defaultZoom},
        ...${JSON.stringify(GOOGLE_MAPS_CONFIG.mapOptions)},
        gestureHandling: ${isMapFullscreen ? "'greedy'" : "'cooperative'"}, // Greedy en pantalla completa, cooperative en el modal
      });

      // Solo crear marcador si hay ubicación inicial
      if (initialLocation) {
        marker = new google.maps.Marker({
          position: initialLocation,
          map: map,
          draggable: true,
          animation: google.maps.Animation.DROP,
          title: "Ubicación de la dirección"
        });
        
        currentLocation = initialLocation;
        
        // Actualizar ubicación cuando se arrastra el marcador
        marker.addListener('dragend', function() {
          currentLocation = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          sendMessage('locationUpdated', {
            latitude: currentLocation.lat,
            longitude: currentLocation.lng
          });
        });
      }

      // Actualizar ubicación al hacer click en el mapa
      map.addListener('click', function(event) {
        if (!marker) {
          // Crear marcador si no existe
          marker = new google.maps.Marker({
            position: event.latLng,
            map: map,
            draggable: true,
            animation: google.maps.Animation.DROP,
            title: "Ubicación de la dirección"
          });
          
          // Agregar listener para arrastrar
          marker.addListener('dragend', function() {
            currentLocation = {
              lat: marker.getPosition().lat(),
              lng: marker.getPosition().lng()
            };
            sendMessage('locationUpdated', {
              latitude: currentLocation.lat,
              longitude: currentLocation.lng
            });
          });
        } else {
          // Mover marcador existente
          marker.setPosition(event.latLng);
        }
        
        currentLocation = {
          lat: event.latLng.lat(),
          lng: event.latLng.lng()
        };
        sendMessage('locationUpdated', {
          latitude: currentLocation.lat,
          longitude: currentLocation.lng
        });
      });

      // Escuchar mensajes desde React Native
      window.addEventListener('message', handleMessage);
      
      // Notificar que el mapa está listo
      sendMessage('mapReady', {});
    }

    function handleMessage(event) {
      try {
        const data = JSON.parse(event.data);
        
        switch(data.type) {
          case 'setLocation':
            setLocation(data.latitude, data.longitude);
            break;
          case 'centerOnLocation':
            centerOnLocation();
            break;
        }
      } catch (e) {
      }
    }

    function setLocation(lat, lng) {
      const position = new google.maps.LatLng(lat, lng);
      
      if (!marker) {
        // Crear marcador si no existe
        marker = new google.maps.Marker({
          position: position,
          map: map,
          draggable: true,
          animation: google.maps.Animation.DROP,
          title: "Ubicación de la dirección"
        });
        
        // Agregar listener para arrastrar
        marker.addListener('dragend', function() {
          currentLocation = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          sendMessage('locationUpdated', {
            latitude: currentLocation.lat,
            longitude: currentLocation.lng
          });
        });
      } else {
        marker.setPosition(position);
      }
      
      map.setCenter(position);
      currentLocation = { lat, lng };
    }

    function centerOnLocation() {
      if (currentLocation) {
        map.setCenter(currentLocation);
        map.setZoom(16);
      }
    }

    function sendMessage(type, data) {
      try {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: type,
            ...data
          }));
        }
      } catch (e) {
      }
    }
  </script>
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap">
  </script>
</body>
</html>
  `
        : '',
    [latitude, longitude, isMapFullscreen, apiKey],
  );

  // Manejar mensajes del WebView
  const handleWebViewMessage = React.useCallback(
    (event: any) => {
      try {
        const data = JSON.parse(event.nativeEvent.data);

        switch (data.type) {
          case 'mapReady':
            setMapReady(true);
            setIsMapLoading(false);
            break;
          case 'locationUpdated':
            // Convertir a número antes de guardar
            setValue('latitude', Number(data.latitude));
            setValue('longitude', Number(data.longitude));
            break;
        }
      } catch (e) {
      }
    },
    [setValue],
  );

  // Enviar mensaje al WebView
  const sendMessageToWebView = React.useCallback((type: string, data: any) => {
    if (webViewRef.current) {
      const message = JSON.stringify({ type, ...data });
      webViewRef.current.postMessage(message);
    }
  }, []);

  // Actualizar la ubicación en el mapa cuando cambie
  useEffect(() => {
    if (mapReady && latitude !== undefined && longitude !== undefined) {
      sendMessageToWebView('setLocation', {
        latitude,
        longitude,
      });
    }
  }, [latitude, longitude, mapReady]);

  // Resetear estados cuando el componente se monta
  useEffect(() => {
    if (visible) {
      setIsMapLoading(true);
      setMapReady(false);
    }
  }, [visible]);

  const handleFormSubmit = React.useCallback(
    async (data: AddressFormInputs) => {
      const formattedData: CreateAddressDto = {
        name: data.name,
        street: data.street,
        number: data.number,
        interiorNumber: data.interiorNumber || undefined,
        neighborhood: data.neighborhood,
        city: data.city,
        state: data.state,
        zipCode: data.zipCode,
        country: data.country,
        deliveryInstructions: data.deliveryInstructions || undefined,
        latitude: data.latitude !== undefined ? data.latitude : undefined,
        longitude: data.longitude !== undefined ? data.longitude : undefined,
        isDefault: data.isDefault || false,
      };
      await onSubmit(formattedData);
    },
    [onSubmit],
  );

  const hasValidCoordinates = React.useMemo(() => {
    return (
      latitude !== undefined &&
      longitude !== undefined &&
      !isNaN(Number(latitude)) &&
      !isNaN(Number(longitude)) &&
      Number(latitude) !== 0 &&
      Number(longitude) !== 0
    );
  }, [latitude, longitude]);

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.primary },
              ]}
            >
              <View style={styles.headerLeft}>
                <Avatar.Icon
                  size={28}
                  icon={editingItem ? 'map-marker-radius' : 'map-marker-plus'}
                  style={[
                    styles.headerIcon,
                    { backgroundColor: theme.colors.onPrimary + '20' },
                  ]}
                  color={theme.colors.onPrimary}
                />
                <View style={styles.headerTextContainer}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onPrimary },
                    ]}
                    variant="titleMedium"
                  >
                    {editingItem ? 'Editar Dirección' : 'Nueva Dirección'}
                  </Text>
                </View>
              </View>
              <IconButton
                icon="close"
                size={24}
                onPress={onDismiss}
                disabled={isSubmitting}
                iconColor={theme.colors.onPrimary}
              />
            </View>

            <ScrollView
              ref={scrollViewRef}
              style={styles.formContainer}
              showsVerticalScrollIndicator={false}
              keyboardShouldPersistTaps="handled"
            >
              {/* Switch de dirección predeterminada al inicio */}
              <Controller
                control={control}
                name="isDefault"
                render={({ field: { onChange, value } }) => (
                  <Surface
                    style={[
                      styles.switchContainer,
                      { marginBottom: theme.spacing.m },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.switchContent}>
                      <View style={styles.switchTextContainer}>
                        <Text style={styles.switchLabel} variant="bodyLarge">
                          Dirección predeterminada
                        </Text>
                        <Text
                          style={styles.switchDescription}
                          variant="bodySmall"
                        >
                          Esta será la dirección principal para los pedidos
                        </Text>
                      </View>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                )}
              />

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información de la Dirección
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.requiredChip}
                    textStyle={styles.requiredChipText}
                  >
                    Requerido
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Nombre de la dirección"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.name}
                        mode="outlined"
                        placeholder="Ej: Casa, Oficina, Casa de mamá"
                        left={<TextInput.Icon icon="tag" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.name && (
                        <HelperText type="error" visible={!!errors.name}>
                          {errors.name.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="street"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Calle"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.street}
                        mode="outlined"
                        placeholder="Ej: Av. Insurgentes"
                        left={<TextInput.Icon icon="road" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.street && (
                        <HelperText type="error" visible={!!errors.street}>
                          {errors.street.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <View style={styles.row}>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="number"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Número"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.number}
                            mode="outlined"
                            placeholder="123"
                            left={<TextInput.Icon icon="numeric" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.number && (
                            <HelperText type="error" visible={!!errors.number}>
                              {errors.number.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>

                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="interiorNumber"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Interior"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            mode="outlined"
                            placeholder="Depto 4B"
                            left={<TextInput.Icon icon="home-variant" />}
                            outlineStyle={styles.inputOutline}
                          />
                        </View>
                      )}
                    />
                  </View>
                </View>

                <Controller
                  control={control}
                  name="neighborhood"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Colonia"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.neighborhood}
                        mode="outlined"
                        placeholder="Ej: Roma Norte"
                        left={<TextInput.Icon icon="map" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.neighborhood && (
                        <HelperText
                          type="error"
                          visible={!!errors.neighborhood}
                        >
                          {errors.neighborhood.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="city"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Ciudad"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.city}
                        mode="outlined"
                        placeholder="Ej: Ciudad de México"
                        left={<TextInput.Icon icon="city" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.city && (
                        <HelperText type="error" visible={!!errors.city}>
                          {errors.city.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <View style={styles.row}>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="state"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Estado"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.state}
                            mode="outlined"
                            placeholder="Ej: CDMX"
                            left={<TextInput.Icon icon="map-marker" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.state && (
                            <HelperText type="error" visible={!!errors.state}>
                              {errors.state.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>

                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="zipCode"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="C.P."
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.zipCode}
                            mode="outlined"
                            placeholder="06700"
                            keyboardType="numeric"
                            maxLength={5}
                            left={<TextInput.Icon icon="mailbox" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.zipCode && (
                            <HelperText type="error" visible={!!errors.zipCode}>
                              {errors.zipCode.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>
                </View>

                <Controller
                  control={control}
                  name="country"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="País"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.country}
                        mode="outlined"
                        placeholder="México"
                        left={<TextInput.Icon icon="earth" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.country && (
                        <HelperText type="error" visible={!!errors.country}>
                          {errors.country.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información Adicional
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.optionalChip}
                    textStyle={styles.optionalChipText}
                  >
                    Opcional
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="deliveryInstructions"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Instrucciones de entrega"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Entre calles, color de fachada, etc."
                        multiline
                        numberOfLines={2}
                        left={<TextInput.Icon icon="sign-direction" />}
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />

                {/* Sección de Ubicación con Mapa Integrado */}
                <View style={styles.locationWrapper}>
                  <View style={styles.locationHeader}>
                    <Text style={styles.locationLabel} variant="bodyMedium">
                      Ubicación en el mapa
                    </Text>
                    {hasValidCoordinates && (
                      <Button
                        mode="text"
                        onPress={() => {
                          setValue('latitude', undefined);
                          setValue('longitude', undefined);
                          // Forzar la validación del formulario
                          trigger(['latitude', 'longitude']);
                        }}
                        icon="close"
                        compact
                        style={styles.clearLocationBtn}
                      >
                        Limpiar
                      </Button>
                    )}
                  </View>

                  <Surface style={styles.mapContainer} elevation={1}>
                    <View style={styles.mapInstructions}>
                      <Icon
                        source="gesture-two-double-tap"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text
                        style={styles.mapInstructionText}
                        variant="bodySmall"
                      >
                        Usa dos dedos para mover el mapa • Toca para marcar
                        ubicación
                      </Text>
                    </View>

                    <View style={styles.mapView}>
                      {isLoadingApiKey || !mapHtml ? (
                        <View style={[styles.map, styles.mapLoadingContainer]}>
                          <ActivityIndicator
                            size="large"
                            color={theme.colors.primary}
                          />
                          <Text style={styles.mapLoadingText}>
                            Cargando mapa...
                          </Text>
                        </View>
                      ) : (
                        <WebView
                          ref={webViewRef}
                          source={{ html: mapHtml }}
                          style={styles.map}
                          onMessage={handleWebViewMessage}
                          onError={(_error) => {}}
                          javaScriptEnabled={true}
                          domStorageEnabled={true}
                          startInLoadingState={true}
                          mixedContentMode="compatibility"
                          allowsInlineMediaPlayback={true}
                          originWhitelist={['*']}
                          scalesPageToFit={false}
                          bounces={false}
                          scrollEnabled={false}
                          nestedScrollEnabled={false}
                        />
                      )}

                      {/* Indicador de carga */}
                      {isMapLoading && (
                        <View style={styles.mapLoadingContainer}>
                          <Surface style={styles.mapLoadingCard} elevation={3}>
                            <ActivityIndicator
                              size="large"
                              color={theme.colors.primary}
                            />
                            <Text style={styles.mapLoadingText}>
                              Cargando mapa...
                            </Text>
                          </Surface>
                        </View>
                      )}

                      {/* Botones flotantes */}
                      {mapReady && (
                        <>
                          {/* Botón de expandir */}
                          <View style={styles.expandButtonContainer}>
                            <Button
                              mode="contained"
                              icon={
                                isMapFullscreen
                                  ? 'fullscreen-exit'
                                  : 'fullscreen'
                              }
                              onPress={() =>
                                setIsMapFullscreen(!isMapFullscreen)
                              }
                              style={styles.expandButton}
                              labelStyle={styles.expandButtonLabel}
                            >
                              {isMapFullscreen ? 'Cerrar' : 'Expandir mapa'}
                            </Button>
                          </View>

                          {/* Botón de centrar */}
                          {hasValidCoordinates && (
                            <View style={styles.centerButtonContainer}>
                              <IconButton
                                icon="crosshairs-gps"
                                mode="contained"
                                containerColor={theme.colors.primaryContainer}
                                iconColor={theme.colors.onPrimaryContainer}
                                size={20}
                                onPress={() =>
                                  sendMessageToWebView('centerOnLocation', {})
                                }
                                style={styles.floatingButton}
                              />
                            </View>
                          )}
                        </>
                      )}
                    </View>

                    {/* Mostrar coordenadas */}
                    {hasValidCoordinates && (
                      <View style={styles.coordinatesContainer}>
                        <Text
                          variant="labelSmall"
                          style={styles.coordinatesLabel}
                        >
                          Coordenadas:
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={styles.coordinatesText}
                        >
                          {Number(latitude).toFixed(6)},{' '}
                          {Number(longitude).toFixed(6)}
                        </Text>
                      </View>
                    )}
                  </Surface>
                </View>
              </View>

              {/* Espacio adicional para el teclado */}
              <View style={{ height: 10 }} />
            </ScrollView>

            <Surface style={styles.buttonContainer} elevation={2}>
              <Button
                onPress={onDismiss}
                disabled={isSubmitting}
                style={[styles.button, styles.cancelButton]}
                textColor={theme.colors.onSecondaryContainer}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={() => {
                  handleSubmit(handleFormSubmit, (validationErrors) => {
                    const errorMessages = Object.entries(validationErrors)
                      .map(([field, error]) => {
                        if (error && 'message' in error) {
                          const fieldNames: Record<string, string> = {
                            name: 'Nombre de la dirección',
                            street: 'Calle',
                            number: 'Número',
                            neighborhood: 'Colonia',
                            city: 'Ciudad',
                            state: 'Estado',
                            zipCode: 'Código postal',
                            country: 'País',
                          };
                          const fieldName = fieldNames[field] || field;
                          return `${fieldName}: ${error.message}`;
                        }
                        return null;
                      })
                      .filter(Boolean);

                    if (errorMessages.length > 0) {
                      showSnackbar({
                        message: errorMessages[0],
                        type: 'error',
                      });

                      scrollViewRef.current?.scrollTo({
                        x: 0,
                        y: 0,
                        animated: true,
                      });
                    }
                  })();
                }}
                disabled={isSubmitting}
                loading={isSubmitting}
                style={[styles.button, styles.confirmButton]}
                buttonColor={theme.colors.primary}
              >
                {editingItem ? 'Guardar' : 'Crear'}
              </Button>
            </Surface>
          </Surface>
        </Modal>
      </Portal>

      {/* Modal de mapa en pantalla completa */}
      <Portal>
        <Modal
          visible={isMapFullscreen}
          onDismiss={() => setIsMapFullscreen(false)}
          contentContainerStyle={styles.fullscreenModalContainer}
        >
          <Surface style={styles.fullscreenModalContent} elevation={5}>
            <View style={styles.fullscreenHeader}>
              <Text variant="titleLarge" style={styles.fullscreenTitle}>
                Ubicación
              </Text>
              <IconButton
                icon="close"
                size={28}
                onPress={() => setIsMapFullscreen(false)}
                style={styles.fullscreenCloseButton}
              />
            </View>

            <View style={styles.fullscreenMapContainer}>
              <WebView
                source={{ html: mapHtml }}
                style={styles.map}
                onMessage={handleWebViewMessage}
                javaScriptEnabled={true}
                domStorageEnabled={true}
                startInLoadingState={false}
                mixedContentMode="compatibility"
                allowsInlineMediaPlayback={true}
                originWhitelist={['*']}
                scalesPageToFit={false}
              />

              {hasValidCoordinates && (
                <View style={styles.fullscreenCoordinates}>
                  <Surface style={styles.coordinatesBadge} elevation={3}>
                    <Icon
                      source="map-marker"
                      size={20}
                      color={theme.colors.primary}
                    />
                    <Text variant="bodyLarge" style={styles.coordinatesText}>
                      {Number(latitude).toFixed(6)},{' '}
                      {Number(longitude).toFixed(6)}
                    </Text>
                  </Surface>
                </View>
              )}
            </View>
          </Surface>
        </Modal>
      </Portal>
    </>
  );
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContainer: {
      margin: 10,
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      maxHeight: '95%',
      minHeight: '80%',
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.xs,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: theme.spacing.m,
      paddingTop: theme.spacing.xs,
    },
    sectionContainer: {
      marginBottom: theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 14,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    requiredChipText: {
      color: theme.colors.onErrorContainer,
      fontSize: 11,
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    inputContainer: {
      marginBottom: theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
    row: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    halfInput: {
      flex: 1,
    },
    locationWrapper: {
      marginTop: theme.spacing.m,
    },
    locationHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    locationLabel: {
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    clearLocationBtn: {
      marginRight: -theme.spacing.s,
    },
    mapContainer: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      backgroundColor: theme.colors.surface,
    },
    mapInstructions: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      gap: theme.spacing.s,
    },
    mapInstructionText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
    },
    mapView: {
      height: 300,
      position: 'relative',
    },
    map: {
      ...StyleSheet.absoluteFillObject,
    },
    mapLoadingContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
    },
    mapLoadingCard: {
      padding: theme.spacing.xl,
      borderRadius: 16,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
    },
    mapLoadingText: {
      marginTop: theme.spacing.m,
      fontSize: 14,
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    expandButtonContainer: {
      position: 'absolute',
      top: theme.spacing.s,
      right: theme.spacing.s,
      zIndex: 10,
    },
    expandButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    expandButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
    },
    centerButtonContainer: {
      position: 'absolute',
      bottom: theme.spacing.s,
      right: theme.spacing.s,
    },
    floatingButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    coordinatesContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.xs,
    },
    coordinatesLabel: {
      color: theme.colors.onSurfaceVariant,
    },
    coordinatesText: {
      fontWeight: '500',
      color: theme.colors.onSurface,
      fontFamily: 'monospace',
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.xs,
      marginTop: theme.spacing.xs,
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: 12,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.s,
    },
    button: {
      flex: 1,
      maxWidth: 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    fullscreenModalContainer: {
      flex: 1,
      margin: 0,
    },
    fullscreenModalContent: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    fullscreenHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingLeft: theme.spacing.l,
      paddingRight: theme.spacing.s,
      paddingVertical: theme.spacing.s,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      height: 56,
    },
    fullscreenTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    fullscreenCloseButton: {
      margin: 0,
    },
    fullscreenMapContainer: {
      flex: 1,
      position: 'relative',
    },
    fullscreenCoordinates: {
      position: 'absolute',
      bottom: theme.spacing.m,
      left: theme.spacing.m,
    },
    coordinatesBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      gap: theme.spacing.s,
    },
    coordinatesText: {
      fontFamily: 'monospace',
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
  });

================
File: app/src/modules/kitchen/screens/KitchenOrdersScreen.tsx
================
import React, {
  useEffect,
  useRef,
  useState,
  useMemo,
  useCallback,
} from 'react';
import { View, StyleSheet, ScrollView, Animated, Platform } from 'react-native';
import { Text, ActivityIndicator, Surface } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import {
  useKitchenOrders,
  useStartOrderPreparation,
  useCancelOrderPreparation,
  useCompleteOrderPreparation,
} from '../hooks/useKitchenOrders';
import { useKitchenStore } from '../store/kitchenStore';
import { OrderCard } from '../components/OrderCard';
import * as ScreenOrientation from 'expo-screen-orientation';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useKitchenContext } from '../context/KitchenContext';
import { OrderType } from '../types/kitchen.types';

export default function KitchenOrdersScreen() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { filters } = useKitchenStore();
  const pulseAnim = useRef(new Animated.Value(1)).current;
  const [isSwipingCard, setIsSwipingCard] = useState(false);
  const { refetchRef } = useKitchenContext();

  const { data: orders, isLoading, refetch } = useKitchenOrders(filters);
  const startOrderPreparation = useStartOrderPreparation();
  const cancelOrderPreparation = useCancelOrderPreparation();
  const completeOrderPreparation = useCompleteOrderPreparation();

  useEffect(() => {
    refetchRef.current = refetch;
  }, [refetch, refetchRef]);

  const hasOrders = !!orders?.length;

  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  const cardWidth = useMemo(() => {
    if (responsive.isDesktop) {
      // En desktop, las tarjetas son más grandes
      return responsive.getResponsiveDimension(340, 380);
    }
    if (responsive.isWeb && responsive.isTablet) {
      // En web tablet, tamaño intermedio
      return responsive.getResponsiveDimension(300, 340);
    }
    return responsive.isTablet
      ? responsive.getResponsiveDimension(280, 320)
      : responsive.getResponsiveDimension(240, 280);
  }, [responsive.isTablet, responsive.isDesktop, responsive.isWeb]);

  const handleStartPreparation = useCallback(
    (orderId: string) => {
      startOrderPreparation.mutate(orderId);
    },
    [startOrderPreparation],
  );

  const handleCancelPreparation = useCallback(
    (orderId: string) => {
      cancelOrderPreparation.mutate(orderId);
    },
    [cancelOrderPreparation],
  );

  const handleCompletePreparation = useCallback(
    (orderId: string) => {
      completeOrderPreparation.mutate(orderId);
    },
    [completeOrderPreparation],
  );

  useEffect(() => {
    if (Platform.OS !== 'web') {
      const setLandscape = async () => {
        await ScreenOrientation.lockAsync(
          ScreenOrientation.OrientationLock.LANDSCAPE,
        );
      };
      setLandscape();

      return () => {
        ScreenOrientation.unlockAsync();
      };
    }
  }, []);

  useEffect(() => {
    if (!hasOrders) {
      const animation = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.2,
            duration: 1500,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 1500,
            useNativeDriver: true,
          }),
        ]),
      );
      animation.start();
      return () => animation.stop();
    }
  }, [hasOrders, pulseAnim]);

  const emptyMessage = useMemo(() => {
    const activeFilters = [];

    if (filters.orderType) {
      const typeLabels = {
        [OrderType.DINE_IN]: 'Para Mesa',
        [OrderType.TAKE_AWAY]: 'Para Llevar',
        [OrderType.DELIVERY]: 'Delivery',
      };
      activeFilters.push(`Tipo: ${typeLabels[filters.orderType]}`);
    }

    if (filters.showPrepared) {
      activeFilters.push('Solo órdenes listas');
    }

    if (!filters.showAllProducts && filters.screenId) {
      activeFilters.push('Solo productos de esta pantalla');
    }

    if (activeFilters.length > 0) {
      return {
        title: 'No hay pedidos con los filtros activos',
        subtitle: `Filtros: ${activeFilters.join(', ')}`,
        hint: 'Ajusta los filtros o espera nuevos pedidos',
      };
    }

    return {
      title: 'No hay pedidos pendientes',
      subtitle: 'Los nuevos pedidos aparecerán aquí automáticamente',
      hint: 'Presiona el botón de recargar para verificar nuevos pedidos',
    };
  }, [filters]);

  const handleSwipeStart = useCallback(() => setIsSwipingCard(true), []);
  const handleSwipeEnd = useCallback(() => {
    setTimeout(() => setIsSwipingCard(false), 100);
  }, []);

  if (isLoading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text variant="bodyLarge" style={styles.loadingText}>
          Cargando pedidos...
        </Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {hasOrders ? (
        <ScrollView
          horizontal={!responsive.isWeb || responsive.width < 1200}
          scrollEnabled={!isSwipingCard}
          showsHorizontalScrollIndicator={false}
          pagingEnabled={false}
          contentContainerStyle={[
            styles.horizontalListContainer,
            responsive.isWeb &&
              responsive.width >= 1200 &&
              styles.gridContainer,
          ]}
          snapToInterval={
            responsive.isWeb ? undefined : cardWidth + responsive.spacing.m
          }
          decelerationRate="fast"
          snapToAlignment={responsive.isWeb ? undefined : 'start'}
        >
          {orders.map((item, index) => (
            <View
              key={item.id}
              style={[
                styles.cardContainer,
                {
                  width: cardWidth,
                  marginRight:
                    index === orders.length - 1 ? 0 : responsive.spacing.xxs,
                },
                responsive.isWeb &&
                  responsive.width >= 1200 &&
                  styles.cardContainerWeb,
              ]}
            >
              <OrderCard
                order={item}
                onStartPreparation={handleStartPreparation}
                onCancelPreparation={handleCancelPreparation}
                onCompletePreparation={handleCompletePreparation}
                onSwipeStart={handleSwipeStart}
                onSwipeEnd={handleSwipeEnd}
              />
            </View>
          ))}
        </ScrollView>
      ) : (
        <View style={styles.emptyStateContainer}>
          <Surface style={styles.emptyCard} elevation={4}>
            <Animated.View
              style={[
                styles.emptyIconContainer,
                { transform: [{ scale: pulseAnim }] },
              ]}
            >
              <Icon
                name={
                  filters.orderType ||
                  filters.showPrepared ||
                  !filters.showAllProducts
                    ? 'filter-remove'
                    : 'chef-hat'
                }
                size={
                  responsive.isWeb
                    ? 64
                    : responsive.getResponsiveDimension(32, 40)
                }
                color={theme.colors.primary}
              />
            </Animated.View>
            <Text
              variant="titleMedium"
              style={[styles.emptyText, { color: theme.colors.onSurface }]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.title}
            </Text>
            <Text
              variant="bodyMedium"
              style={[
                styles.emptySubtext,
                { color: theme.colors.onSurfaceVariant },
              ]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.subtitle}
            </Text>
            <Text
              variant="bodySmall"
              style={[
                styles.emptyHint,
                { color: theme.colors.onSurfaceVariant },
              ]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.hint}
            </Text>
          </Surface>
        </View>
      )}
    </View>
  );
}

const createStyles = (theme: any, responsive: any) =>
  StyleSheet.create({
    container: {
      flex: 1,
      position: 'relative',
      backgroundColor: theme.colors.background,
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.background,
    },
    horizontalListContainer: {
      paddingLeft: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.xxs,
      paddingRight: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.xs,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.s
        : responsive.spacing.xxs,
      minHeight: '100%',
      alignItems:
        responsive.isWeb && responsive.width >= 1200 ? 'flex-start' : 'center',
    },
    gridContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      justifyContent: 'flex-start',
      alignItems: 'flex-start',
      paddingHorizontal: responsive.spacing.l,
      paddingVertical: responsive.spacing.m,
    },
    emptyStateContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.spacing.m,
      paddingVertical: responsive.spacing.xs,
      backgroundColor: theme.colors.background,
    },
    emptyCard: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.xl
        : responsive.spacing.m,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.xl
        : responsive.spacing.m,
      borderRadius: theme.roundness * 2,
      alignItems: 'center',
      maxHeight: '70%',
      width: responsive.isWeb
        ? responsive.getResponsiveDimension(400, 480)
        : responsive.getResponsiveDimension(280, 320),
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.1,
      shadowRadius: 4,
      elevation: 3,
    },
    emptyIconContainer: {
      marginBottom: responsive.spacing.s,
      padding: responsive.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: theme.roundness,
    },
    emptyText: {
      textAlign: 'center',
      marginBottom: responsive.spacing.xs,
      fontWeight: '600',
      fontSize: responsive.fontSize.s,
      paddingHorizontal: responsive.spacing.xs,
      maxWidth: '100%',
      color: theme.colors.onSurface,
    },
    emptySubtext: {
      textAlign: 'center',
      lineHeight: responsive.getResponsiveDimension(16, 18),
      opacity: 0.7,
      marginBottom: responsive.spacing.s,
      fontSize: responsive.fontSize.xs,
      paddingHorizontal: responsive.spacing.xs,
      maxWidth: '100%',
      fontWeight: '400',
      color: theme.colors.onSurfaceVariant,
    },
    emptyHint: {
      textAlign: 'center',
      opacity: 0.5,
      fontStyle: 'italic',
      fontSize: responsive.fontSize.xs - 1,
      paddingHorizontal: responsive.spacing.xs,
      maxWidth: '100%',
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingTop: responsive.spacing.s,
      marginTop: responsive.spacing.xs,
      width: '80%',
      fontWeight: '400',
      color: theme.colors.onSurfaceVariant,
    },
    // Estilos adicionales para eliminar inline styles
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onBackground,
    },
    cardContainer: {
      height: '100%',
      paddingVertical: responsive.spacing.xxxs,
    },
    cardContainerWeb: {
      marginRight: responsive.spacing.s,
      marginBottom: responsive.spacing.s,
      height: 'auto',
    },
  });

================
File: app/src/services/audioServiceHealth.ts
================
import axios from 'axios';
import { serverConnectionService } from '@/services/serverConnectionService';
import { useAuthStore } from '@/app/store/authStore';
import NetInfo from '@react-native-community/netinfo';
import { API_PATHS } from '@/app/constants/apiPaths';

export interface AudioServiceHealthStatus {
  isAvailable: boolean;
  hasInternet: boolean;
  serviceStatus: 'ok' | 'error' | 'disabled' | 'misconfigured' | 'checking';
  message?: string;
  lastChecked: Date;
}

class AudioServiceHealthChecker {
  private static instance: AudioServiceHealthChecker;
  private healthStatus: AudioServiceHealthStatus = {
    isAvailable: false,
    hasInternet: false,
    serviceStatus: 'checking',
    lastChecked: new Date(),
  };
  private listeners: ((status: AudioServiceHealthStatus) => void)[] = [];
  private checkInterval: NodeJS.Timeout | null = null;
  private lastCheckTime: number = 0;
  private readonly CHECK_INTERVAL = 30000; // 30 segundos
  private readonly MIN_CHECK_INTERVAL = 5000; // 5 segundos mínimo entre checks
  private isActive: boolean = false;
  private networkListener: (() => void) | null = null;

  private constructor() {
    // NO iniciar verificación automática
    // Solo escuchar cambios de conectividad cuando el servicio esté activo
  }

  static getInstance(): AudioServiceHealthChecker {
    if (!AudioServiceHealthChecker.instance) {
      AudioServiceHealthChecker.instance = new AudioServiceHealthChecker();
    }
    return AudioServiceHealthChecker.instance;
  }

  async checkHealth(force: boolean = false): Promise<AudioServiceHealthStatus> {
    const now = Date.now();

    // Evitar checks muy frecuentes
    if (!force && now - this.lastCheckTime < this.MIN_CHECK_INTERVAL) {
      return this.healthStatus;
    }

    this.lastCheckTime = now;

    try {
      // Primero verificar conexión a internet
      const netInfo = await NetInfo.fetch();
      const hasInternet =
        netInfo.isConnected && netInfo.isInternetReachable !== false;

      if (!hasInternet) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: false,
          serviceStatus: 'error',
          message: 'Sin conexión a internet',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }

      // Luego verificar el servicio
      const accessToken = useAuthStore.getState().accessToken;
      if (!accessToken) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: true,
          serviceStatus: 'error',
          message: 'Usuario no autenticado',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }

      // Obtener la URL del servicio de conexión sin provocar discovery
      const connectionState = serverConnectionService.getState();
      if (!connectionState.currentUrl || !connectionState.isConnected) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: true,
          serviceStatus: 'error',
          message: 'Servidor no conectado',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }

      const apiUrl = connectionState.currentUrl.endsWith('/')
        ? connectionState.currentUrl.slice(0, -1)
        : connectionState.currentUrl;
      const response = await axios.get(
        `${apiUrl}${API_PATHS.AUDIO_ORDERS_HEALTH}`,
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
          timeout: 5000,
        },
      );

      const { available, status, message } = response.data;

      this.updateStatus({
        isAvailable: available,
        hasInternet: true,
        serviceStatus: status,
        message,
        lastChecked: new Date(),
      });
    } catch (error) {
      // Error al verificar servicio de audio en modo desarrollo

      let errorMessage = 'Servicio de voz no disponible';
      if (axios.isAxiosError(error)) {
        if (error.code === 'ECONNABORTED') {
          errorMessage = 'Tiempo de espera agotado';
        } else if (error.response?.status === 503) {
          errorMessage = 'Servicio temporalmente no disponible';
        } else if (error.response?.status === 404) {
          errorMessage = 'Servicio de voz no configurado';
        }
      }

      this.updateStatus({
        isAvailable: false,
        hasInternet: true,
        serviceStatus: 'error',
        message: errorMessage,
        lastChecked: new Date(),
      });
    }

    return this.healthStatus;
  }

  private updateStatus(status: AudioServiceHealthStatus) {
    this.healthStatus = status;
    this.notifyListeners();
  }

  private notifyListeners() {
    this.listeners.forEach((listener) => listener(this.healthStatus));
  }

  subscribe(listener: (status: AudioServiceHealthStatus) => void): () => void {
    this.listeners.push(listener);

    // Notificar inmediatamente con el estado actual
    listener(this.healthStatus);

    // Retornar función para desuscribirse
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }

  startPeriodicCheck() {
    if (this.checkInterval || !this.listeners.length) {
      return;
    }

    // Activar el servicio
    this.isActive = true;

    // Configurar listener de red si no existe
    if (!this.networkListener) {
      this.networkListener = NetInfo.addEventListener((state) => {
        if (
          this.isActive &&
          state.isConnected !== this.healthStatus.hasInternet
        ) {
          this.checkHealth();
        }
      });
    }

    // Hacer verificación inicial
    this.checkHealth();

    // Configurar verificaciones periódicas
    this.checkInterval = setInterval(() => {
      if (this.isActive) {
        this.checkHealth();
      }
    }, this.CHECK_INTERVAL);
  }

  stopPeriodicCheck() {
    // Desactivar el servicio
    this.isActive = false;

    // Limpiar intervalo
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }

    // Limpiar listener de red
    if (this.networkListener) {
      this.networkListener();
      this.networkListener = null;
    }

    // Resetear estado
    this.updateStatus({
      isAvailable: false,
      hasInternet: false,
      serviceStatus: 'checking',
      message: undefined,
      lastChecked: new Date(),
    });
  }

  getStatus(): AudioServiceHealthStatus {
    return this.healthStatus;
  }
}

export const audioServiceHealth = AudioServiceHealthChecker.getInstance();

================
File: app/src/app/components/crud/GenericDetailModal.tsx
================
import React, { useMemo } from 'react';
import {
  View,
  StyleSheet,
  StyleProp,
  ViewStyle,
  TextStyle,
} from 'react-native';
import {
  Text,
  Button,
  Chip,
  ActivityIndicator,
  IconButton,
} from 'react-native-paper';
import AutoImage from '../common/AutoImage';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { ResponsiveModal } from '../responsive/ResponsiveModal';
import { useResponsive } from '../../hooks/useResponsive';
import ConfirmationModal from '../common/ConfirmationModal';

export interface DisplayFieldConfig<TItem> {
  field: keyof TItem;
  label: string;
  render?: (value: TItem[keyof TItem], item: TItem) => React.ReactNode;
}

interface StatusConfig<TItem> {
  field: keyof TItem;
  activeValue: TItem[keyof TItem];
  activeLabel: string;
  inactiveLabel: string;
}

interface DeleteConfirmation {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel: () => void;
  show: (id: string) => void;
}

interface GenericDetailModalProps<TItem extends { id: string }> {
  visible: boolean;
  onDismiss: () => void;
  item: TItem | null;
  titleField: keyof TItem;
  imageField?: keyof TItem;
  descriptionField?: keyof TItem;
  statusConfig?: StatusConfig<TItem>;
  fieldsToDisplay?: DisplayFieldConfig<TItem>[];
  onEdit?: (item: TItem) => void;
  onDelete?: (id: string) => void;
  deleteConfirmation?: DeleteConfirmation;
  isDeleting?: boolean;
  editButtonLabel?: string;
  deleteButtonLabel?: string;
  closeButtonLabel?: string;
  modalStyle?: StyleProp<ViewStyle>;
  titleStyle?: StyleProp<TextStyle>;
  imageStyle?: StyleProp<ViewStyle>;
  descriptionStyle?: StyleProp<TextStyle>;
  fieldLabelStyle?: StyleProp<TextStyle>;
  fieldValueStyle?: StyleProp<TextStyle>;
  actionsContainerStyle?: StyleProp<ViewStyle>;
  showImage?: boolean;
  children?: React.ReactNode;
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) => {
  return StyleSheet.create({
    modalSurface: {
      backgroundColor: theme.colors.elevation.level2,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      shadowColor: theme.colors.shadow,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    modalTitle: {
      marginTop: responsive.spacing(theme.spacing.l),
      marginBottom: responsive.spacing(theme.spacing.m),
      textAlign: 'center',
      fontWeight: '700',
      fontSize: responsive.isTablet ? 22 : 20,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    detailContent: {
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.m),
      width: '100%',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    detailImage: {
      width: responsive.isTablet
        ? responsive.getResponsiveDimension(120, 150)
        : responsive.getResponsiveDimension(150, 180),
      height: responsive.isTablet
        ? responsive.getResponsiveDimension(120, 150)
        : responsive.getResponsiveDimension(150, 180),
      borderRadius: theme.roundness * 2,
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceDisabled,
      elevation: 2,
    },
    detailDescription: {
      marginBottom: responsive.spacing(theme.spacing.m),
      textAlign: 'center',
      lineHeight: responsive.isTablet ? 20 : 18,
      fontSize: responsive.isTablet ? 14 : 13,
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      flexWrap: 'wrap',
      width: '100%',
    },
    statusChipContainer: {
      marginBottom: responsive.spacing(theme.spacing.s),
      marginTop: responsive.spacing(theme.spacing.s),
    },
    statusChip: {
      paddingHorizontal: responsive.spacing(theme.spacing.s),
      height: responsive.isTablet ? 36 : 32,
    },
    fieldsContainer: {
      width: '100%',
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 1.5,
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      marginHorizontal: responsive.spacing(theme.spacing.m),
      alignSelf: 'center',
      maxWidth: '90%',
    },
    fieldRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xxs)
        : responsive.spacing(theme.spacing.xs),
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      flexWrap: 'wrap',
    },
    lastFieldRow: {
      marginBottom: 0,
      borderBottomWidth: 0,
    },
    fieldLabel: {
      fontWeight: '600',
      marginRight: responsive.spacing(theme.spacing.s),
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 13,
      flexBasis: '35%',
      minWidth: 100,
    },
    fieldValue: {
      flex: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 13,
      flexWrap: 'wrap',
      maxWidth: '65%',
    },
    detailActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.m),
      width: '100%',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    closeButton: {
      alignSelf: 'center',
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      minWidth: responsive.isTablet ? 150 : 100,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    loadingContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: 300,
      flex: 1,
    },
    actionButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.s),
      flex: 1,
      maxWidth: responsive.isTablet ? 180 : '48%',
      minHeight: responsive.isTablet ? 48 : 40,
      minWidth: 100,
    },
    buttonContainer: {
      backgroundColor: theme.colors.surface,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.l),
    },
    closeIconButton: {
      position: 'absolute',
      top: responsive.spacing(theme.spacing.xs),
      right: responsive.spacing(theme.spacing.xs),
      zIndex: 1,
    },
  });
};

function GenericDetailModal<TItem extends { id: string }>({
  visible,
  onDismiss,
  item,
  titleField,
  imageField,
  descriptionField,
  statusConfig,
  fieldsToDisplay = [],
  onEdit,
  onDelete,
  deleteConfirmation,
  isDeleting = false,
  editButtonLabel = 'Editar',
  deleteButtonLabel = 'Eliminar',
  closeButtonLabel = 'Cerrar',
  modalStyle,
  titleStyle,
  imageStyle,
  descriptionStyle,
  fieldLabelStyle,
  fieldValueStyle,
  actionsContainerStyle,
  showImage = false,
  children,
}: GenericDetailModalProps<TItem>) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const imageSource = useMemo(() => {
    if (item && imageField && item.hasOwnProperty(imageField)) {
      const imageFieldValue = item[imageField];
      if (
        typeof imageFieldValue === 'object' &&
        imageFieldValue !== null &&
        'path' in imageFieldValue &&
        typeof imageFieldValue.path === 'string'
      ) {
        return imageFieldValue.path;
      } else if (typeof imageFieldValue === 'string') {
        return imageFieldValue;
      }
    }
    return null;
  }, [item, imageField]);

  const handleEdit = () => {
    if (onEdit && item) {
      onEdit(item);
    }
  };

  const handleDelete = () => {
    if (item) {
      if (deleteConfirmation) {
        deleteConfirmation.show(item.id);
      } else if (onDelete) {
        onDelete(item.id);
      }
    }
  };

  const renderContent = () => {
    if (!item) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator animating={true} size="large" />
        </View>
      );
    }

    const title = String(item[titleField] ?? 'Detalle');
    const description =
      descriptionField && item.hasOwnProperty(descriptionField)
        ? String(item[descriptionField] ?? '')
        : null;

    let statusChip = null;
    if (statusConfig && item.hasOwnProperty(statusConfig.field)) {
      const { field, activeValue, activeLabel, inactiveLabel } = statusConfig;
      const isActive = item[field] === activeValue;
      statusChip = (
        <View style={styles.statusChipContainer}>
          <Chip
            mode="flat"
            selectedColor={
              isActive ? theme.colors.success : theme.colors.onSurfaceVariant
            }
            style={[
              styles.statusChip,
              {
                backgroundColor: isActive
                  ? theme.colors.successContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
          >
            {isActive ? activeLabel : inactiveLabel}
          </Chip>
        </View>
      );
    }

    return (
      <>
        <IconButton
          icon="close"
          size={24}
          style={styles.closeIconButton}
          onPress={onDismiss}
          mode="contained-tonal"
        />
        <Text variant="headlineSmall" style={[styles.modalTitle, titleStyle]}>
          {title}
        </Text>
        <View style={styles.detailContent}>
          {showImage && (
            <AutoImage
              source={imageSource}
              placeholderIcon="image-outline"
              style={[styles.detailImage, imageStyle]}
              contentFit="contain"
              transition={300}
            />
          )}
          {statusChip}
          {description && (
            <Text
              style={[styles.detailDescription, descriptionStyle]}
              numberOfLines={4}
              ellipsizeMode="tail"
            >
              {description}
            </Text>
          )}
        </View>

        {fieldsToDisplay.length > 0 && (
          <View style={styles.fieldsContainer}>
            {fieldsToDisplay.map(({ field, label, render }, index) => {
              if (!item || !item.hasOwnProperty(field)) return null;
              const value = item[field];
              const isLastItem = index === fieldsToDisplay.length - 1;

              return (
                <View
                  key={String(field)}
                  style={[styles.fieldRow, isLastItem && styles.lastFieldRow]}
                >
                  <Text style={[styles.fieldLabel, fieldLabelStyle]}>
                    {label}
                  </Text>
                  {render ? (
                    <View
                      style={{
                        flex: 1,
                        flexDirection: 'row',
                        justifyContent: 'flex-end',
                      }}
                    >
                      {(() => {
                        const rendered = render(value, item);
                        // Si el render devuelve un string o número, lo envolvemos en Text
                        if (
                          typeof rendered === 'string' ||
                          typeof rendered === 'number'
                        ) {
                          return (
                            <Text
                              style={[styles.fieldValue, fieldValueStyle]}
                              numberOfLines={3}
                              ellipsizeMode="tail"
                            >
                              {rendered}
                            </Text>
                          );
                        }
                        // Si ya es un elemento React, lo devolvemos tal cual
                        return rendered;
                      })()}
                    </View>
                  ) : (
                    <Text
                      style={[styles.fieldValue, fieldValueStyle]}
                      numberOfLines={3}
                      ellipsizeMode="tail"
                    >
                      {typeof value === 'boolean'
                        ? value
                          ? 'Sí'
                          : 'No'
                        : String(value ?? 'N/A')}
                    </Text>
                  )}
                </View>
              );
            })}
          </View>
        )}

        {children}
      </>
    );
  };

  const renderFooter = () => {
    if (!item) return null;

    return (
      <>
        {(onEdit || onDelete) && (
          <View style={[styles.detailActions, actionsContainerStyle]}>
            {onEdit && (
              <Button
                icon="pencil"
                mode="contained-tonal"
                onPress={handleEdit}
                disabled={isDeleting}
                style={styles.actionButton}
                buttonColor={theme.colors.secondaryContainer}
                textColor={theme.colors.onSecondaryContainer}
                contentStyle={{ flexDirection: 'row' }}
                labelStyle={{ fontSize: responsive.isTablet ? 13 : 12 }}
                compact={!responsive.isTablet}
              >
                {editButtonLabel}
              </Button>
            )}
            {onDelete && (
              <Button
                icon="delete"
                mode="contained-tonal"
                buttonColor={theme.colors.errorContainer}
                textColor={theme.colors.error}
                onPress={handleDelete}
                loading={isDeleting}
                disabled={isDeleting}
                style={styles.actionButton}
                contentStyle={{ flexDirection: 'row' }}
                labelStyle={{ fontSize: responsive.isTablet ? 13 : 12 }}
                compact={!responsive.isTablet}
              >
                {deleteButtonLabel}
              </Button>
            )}
          </View>
        )}

        <Button
          mode="contained-tonal"
          onPress={onDismiss}
          style={styles.closeButton}
          disabled={isDeleting}
          buttonColor={theme.colors.surfaceVariant}
          textColor={theme.colors.onSurfaceVariant}
          labelStyle={{ fontSize: responsive.isTablet ? 14 : 13 }}
          contentStyle={{
            paddingHorizontal: responsive.spacing(theme.spacing.s),
          }}
        >
          {closeButtonLabel}
        </Button>
      </>
    );
  };

  return (
    <>
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        dismissable={!isDeleting}
        dismissableBackButton={!isDeleting}
        scrollable={true}
        maxWidth={responsive.isTablet ? 480 : 400}
        maxHeight={'85%'}
        footer={renderFooter()}
        stickyFooter={true}
        contentContainerStyle={[styles.modalSurface, modalStyle]}
      >
        {renderContent()}
      </ResponsiveModal>

      {deleteConfirmation && (
        <ConfirmationModal
          visible={deleteConfirmation.visible}
          title={deleteConfirmation.title}
          message={deleteConfirmation.message}
          onConfirm={deleteConfirmation.onConfirm}
          onCancel={deleteConfirmation.onCancel}
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
        />
      )}
    </>
  );
}

export default GenericDetailModal;

================
File: app/src/modules/orderFinalization/components/OrderDetailsModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Modal,
  Portal,
  Surface,
  Text,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
} from 'react-native-paper';
import {
  OrderForFinalization,
  OrderItemForFinalization,
} from '../types/orderFinalization.types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

interface OrderDetailsModalProps {
  visible: boolean;
  onDismiss: () => void;
  order: OrderForFinalization | null;
  isLoading?: boolean;
  onPrintPress: (order: OrderForFinalization) => void;
}

const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';

  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalf.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalf.HALF_2
            ? 'HALF_2'
            : 'FULL';

      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }

      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;

      if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationType.INGREDIENT
      ) {
        if (curr.action === CustomizationAction.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }

      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );

  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };

    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';

    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }

  return '';
};

export const OrderDetailsModal: React.FC<OrderDetailsModalProps> = ({
  visible,
  onDismiss,
  order,
  isLoading = false,
  onPrintPress,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [showPrintHistory, setShowPrintHistory] = useState(false);

  if (!order && !isLoading) return null;

  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return '🍽️ Local';
      case 'TAKE_AWAY':
        return '🥡 Llevar';
      case 'DELIVERY':
        return '🚚 Envío';
      default:
        return type;
    }
  };

  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparación';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      default:
        return status;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0'; // Purple - better contrast
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getPaymentStatus = () => {
    if (order?.payments && order.payments.length > 0) {
      const totalPaid = order.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof order.total === 'string' ? parseFloat(order.total) : order.total;

      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };

  const paymentStatus = order
    ? getPaymentStatus()
    : { label: 'Pendiente', color: '#EF4444' };

  const renderItem = (item: OrderItemForFinalization) => {
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * item.quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;

    return (
      <Surface
        key={`${item.product.id}-${item.productVariant?.id || ''}-${item.preparationStatus || ''}`}
        style={[
          styles.itemCard,
          { backgroundColor: theme.colors.elevation.level1, marginBottom: 8 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {item.quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}

            {item.modifiers && item.modifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.modifiers.map((modifier) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      • {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}

            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📝 {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {item.quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total ×{item.quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContent,
          { backgroundColor: theme.colors.background },
        ]}
      >
        {isLoading || !order ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text
              style={[
                styles.loadingText,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Cargando detalles de la orden...
            </Text>
          </View>
        ) : (
          <>
            <View style={styles.header}>
              <View style={styles.headerInfo}>
                <View style={styles.headerTopRow}>
                  <View style={styles.headerLeft}>
                    <Text
                      style={[styles.title, { color: theme.colors.onSurface }]}
                    >
                      Orden #{order?.shiftOrderNumber || ''}
                    </Text>
                    <Text
                      style={[
                        styles.headerSeparator,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      •
                    </Text>
                    <Text
                      style={[
                        styles.orderType,
                        { color: theme.colors.primary },
                      ]}
                    >
                      {order ? getOrderTypeLabel(order.orderType) : ''}
                    </Text>
                    <Text
                      style={[
                        styles.headerSeparator,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      •
                    </Text>
                    <Text
                      style={[
                        styles.headerDate,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {order?.createdAt
                        ? format(new Date(order.createdAt), 'dd/MM HH:mm', {
                            locale: es,
                          })
                        : ''}
                    </Text>
                  </View>
                  <View style={styles.headerActions}>
                    <IconButton
                      icon="close"
                      size={24}
                      onPress={onDismiss}
                      style={styles.closeButton}
                    />
                  </View>
                </View>
                <View style={styles.headerBottomRow}>
                  <View style={styles.chipsRow}>
                    <View
                      style={[
                        styles.headerStatusChip,
                        {
                          backgroundColor: order
                            ? getStatusColor(order.orderStatus, theme)
                            : theme.colors.surfaceVariant,
                        },
                      ]}
                    >
                      <Text style={styles.headerStatusChipText}>
                        {order ? getOrderStatusLabel(order.orderStatus) : ''}
                      </Text>
                    </View>
                    {order?.preparationScreens &&
                      order.preparationScreens.map((screen, index) => (
                        <Chip
                          key={index}
                          mode="outlined"
                          compact
                          style={styles.screenChip}
                          textStyle={styles.screenChipText}
                        >
                          🍳 {screen}
                        </Chip>
                      ))}
                  </View>
                </View>
              </View>
            </View>

            <ScrollView
              style={styles.scrollView}
              showsVerticalScrollIndicator={false}
              contentContainerStyle={styles.scrollContent}
            >
              <View style={styles.infoSection}>
                {order?.deliveryInfo?.recipientName && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      👤 Nombre del Cliente: {order.deliveryInfo.recipientName}
                    </Text>
                  </View>
                )}

                {order?.deliveryInfo?.recipientPhone && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      📞 Teléfono: {order.deliveryInfo.recipientPhone}
                    </Text>
                  </View>
                )}

                {order?.orderType === 'DELIVERY' &&
                  order?.deliveryInfo?.fullAddress && (
                    <View style={styles.infoRow}>
                      <Text
                        style={[
                          styles.addressText,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        📦 Dirección de Entrega:{' '}
                        {order.deliveryInfo.fullAddress}
                      </Text>
                    </View>
                  )}

                {order?.orderType === 'DINE_IN' && order?.table && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.tableText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      🏛️ Mesa: {order.table.area?.name || 'Sin área'} -{' '}
                      {order.table.number}
                    </Text>
                  </View>
                )}

                {order?.scheduledAt && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.primary, fontWeight: '600' },
                      ]}
                    >
                      ⏰ Hora de Entrega Programada:{' '}
                      {format(new Date(order.scheduledAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                )}
              </View>

              <Divider style={styles.divider} />

              <View style={styles.itemsList}>
                {order?.orderItems?.map((item) => renderItem(item)) || []}
              </View>

              <Divider style={styles.divider} />

              {order?.payments && order.payments.length > 0 && (
                <>
                  <View style={styles.paymentsSection}>
                    <View style={styles.paymentSummaryCompact}>
                      <View style={styles.summaryCompactRow}>
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            { color: theme.colors.onSurfaceVariant },
                          ]}
                        >
                          Total: $
                          {typeof order.total === 'string'
                            ? parseFloat(order.total).toFixed(2)
                            : order.total.toFixed(2)}
                        </Text>
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            { color: '#10B981' },
                          ]}
                        >
                          Pagado: $
                          {order.payments
                            .reduce((sum, p) => sum + p.amount, 0)
                            .toFixed(2)}
                        </Text>
                        {(() => {
                          const totalOrder =
                            typeof order.total === 'string'
                              ? parseFloat(order.total)
                              : order.total;
                          const totalPaid = order.payments.reduce(
                            (sum, p) => sum + p.amount,
                            0,
                          );
                          const remaining = totalOrder - totalPaid;
                          if (remaining > 0) {
                            return (
                              <Text
                                style={[
                                  styles.summaryCompactLabel,
                                  {
                                    color: theme.colors.error,
                                    fontWeight: '600',
                                  },
                                ]}
                              >
                                Resta: ${remaining.toFixed(2)}
                              </Text>
                            );
                          }
                          return null;
                        })()}
                      </View>
                    </View>

                    {order.payments.map((payment, index) => {
                      const getPaymentMethodLabel = (method: string) => {
                        switch (method) {
                          case 'CASH':
                            return 'Efectivo';
                          case 'CREDIT_CARD':
                            return 'Tarjeta de Crédito';
                          case 'DEBIT_CARD':
                            return 'Tarjeta de Débito';
                          case 'TRANSFER':
                            return 'Transferencia';
                          case 'OTHER':
                            return 'Otro';
                          default:
                            return method;
                        }
                      };

                      const getPaymentStatusColor = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return '#10B981';
                          case 'PENDING':
                            return '#F59E0B';
                          case 'FAILED':
                            return theme.colors.error;
                          case 'REFUNDED':
                            return '#6B7280';
                          case 'CANCELLED':
                            return theme.colors.error;
                          default:
                            return theme.colors.onSurfaceVariant;
                        }
                      };

                      const getPaymentStatusLabel = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return 'Completado';
                          case 'PENDING':
                            return 'Pendiente';
                          case 'FAILED':
                            return 'Fallido';
                          case 'REFUNDED':
                            return 'Reembolsado';
                          case 'CANCELLED':
                            return 'Cancelado';
                          default:
                            return status;
                        }
                      };

                      return (
                        <View
                          key={payment.id || index}
                          style={styles.paymentRowCompact}
                        >
                          <Text
                            style={[
                              styles.paymentMethodCompact,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            💳 {getPaymentMethodLabel(payment.paymentMethod)}
                          </Text>
                          <Text
                            style={[
                              styles.paymentDateCompact,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {format(new Date(payment.createdAt), 'HH:mm', {
                              locale: es,
                            })}
                          </Text>
                          <View
                            style={[
                              styles.paymentStatusBadgeCompact,
                              {
                                backgroundColor:
                                  getPaymentStatusColor(payment.paymentStatus) +
                                  '20',
                              },
                            ]}
                          >
                            <Text
                              style={[
                                styles.paymentStatusTextCompact,
                                {
                                  color: getPaymentStatusColor(
                                    payment.paymentStatus,
                                  ),
                                },
                              ]}
                            >
                              {getPaymentStatusLabel(payment.paymentStatus)}
                            </Text>
                          </View>
                          <Text
                            style={[
                              styles.paymentAmountCompact,
                              { color: theme.colors.primary },
                            ]}
                          >
                            ${payment.amount.toFixed(2)}
                          </Text>
                        </View>
                      );
                    })}
                  </View>
                  <Divider style={styles.divider} />
                </>
              )}

              {order?.ticketImpressions &&
                order.ticketImpressions.length > 0 && (
                  <>
                    <View style={styles.ticketImpressionsSection}>
                      <TouchableOpacity
                        style={styles.collapsibleHeader}
                        onPress={() => setShowPrintHistory(!showPrintHistory)}
                        activeOpacity={0.7}
                      >
                        <Text
                          style={[
                            styles.sectionTitle,
                            { color: theme.colors.primary },
                          ]}
                        >
                          🖨️ Historial de Impresiones (
                          {order.ticketImpressions.length})
                        </Text>
                        <IconButton
                          icon={
                            showPrintHistory ? 'chevron-up' : 'chevron-down'
                          }
                          size={20}
                          style={styles.collapseIcon}
                        />
                      </TouchableOpacity>

                      {showPrintHistory && (
                        <View style={styles.collapsibleContent}>
                          {order.ticketImpressions.map((impression, index) => {
                            const getTicketTypeLabel = (type: string) => {
                              switch (type) {
                                case 'KITCHEN':
                                  return '🍳 Cocina';
                                case 'BAR':
                                  return '🍺 Barra';
                                case 'BILLING':
                                  return '💵 Cuenta';
                                case 'CUSTOMER_COPY':
                                  return '📄 Copia Cliente';
                                case 'GENERAL':
                                  return '📋 General';
                                default:
                                  return type;
                              }
                            };

                            return (
                              <View
                                key={impression.id || index}
                                style={styles.impressionRow}
                              >
                                <View style={styles.impressionLeft}>
                                  <Text
                                    style={[
                                      styles.impressionType,
                                      { color: theme.colors.onSurface },
                                    ]}
                                  >
                                    {getTicketTypeLabel(impression.ticketType)}
                                  </Text>
                                  <View style={styles.impressionDetails}>
                                    {impression.user && (
                                      <Text
                                        style={[
                                          styles.impressionUser,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        por {impression.user.firstName || ''}{' '}
                                        {impression.user.lastName || ''}
                                      </Text>
                                    )}
                                    {impression.printer && (
                                      <Text
                                        style={[
                                          styles.impressionPrinter,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        🖨️ {impression.printer.name}
                                      </Text>
                                    )}
                                  </View>
                                </View>
                                <Text
                                  style={[
                                    styles.impressionTime,
                                    { color: theme.colors.onSurfaceVariant },
                                  ]}
                                >
                                  {format(
                                    new Date(impression.impressionTime),
                                    'HH:mm:ss',
                                    { locale: es },
                                  )}
                                </Text>
                              </View>
                            );
                          })}
                        </View>
                      )}
                    </View>
                  </>
                )}
            </ScrollView>

            <Divider style={styles.divider} />

            <View style={styles.footer}>
              <View style={styles.footerLeft}>
                <Text
                  style={[
                    styles.totalLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Por pagar:
                </Text>
                <Text
                  style={[
                    styles.totalAmount,
                    {
                      color: (() => {
                        const totalOrder =
                          typeof order.total === 'string'
                            ? parseFloat(order.total)
                            : order.total;
                        const totalPaid =
                          order.payments?.reduce(
                            (sum, p) => sum + p.amount,
                            0,
                          ) || 0;
                        const remaining = totalOrder - totalPaid;
                        return remaining > 0 ? theme.colors.error : '#10B981';
                      })(),
                    },
                  ]}
                >
                  $
                  {(() => {
                    if (!order) return '0.00';
                    const totalOrder =
                      typeof order.total === 'string'
                        ? parseFloat(order.total)
                        : order.total;
                    const totalPaid =
                      order.payments?.reduce((sum, p) => sum + p.amount, 0) ||
                      0;
                    const remaining = totalOrder - totalPaid;
                    return remaining > 0 ? remaining.toFixed(2) : '0.00';
                  })()}
                </Text>
              </View>
              <View
                style={[
                  styles.paymentBadge,
                  { backgroundColor: paymentStatus.color },
                ]}
              >
                <Text style={styles.paymentBadgeText}>
                  💵 {paymentStatus.label}
                </Text>
              </View>
            </View>
          </>
        )}
      </Modal>
    </Portal>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContent: {
      margin: 12,
      borderRadius: 12,
      maxHeight: '90%',
      elevation: 4,
      overflow: 'hidden',
    },
    header: {
      paddingHorizontal: 16,
      paddingTop: 10,
      paddingBottom: 6,
    },
    headerTopRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 6,
    },
    headerLeft: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
    },
    headerBottomRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    chipsRow: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
      flexWrap: 'wrap',
    },
    headerSeparator: {
      fontSize: responsive.fontSize(11),
      marginHorizontal: 6,
    },
    orderType: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    headerDate: {
      fontSize: responsive.fontSize(11),
    },
    infoSection: {
      paddingHorizontal: 16,
      paddingTop: 4,
      paddingBottom: 6,
      gap: 4,
    },
    infoRow: {
      marginVertical: 2,
    },
    contactText: {
      fontSize: responsive.fontSize(12),
    },
    addressText: {
      fontSize: responsive.fontSize(12),
      lineHeight: 16,
    },
    tableText: {
      fontSize: responsive.fontSize(12),
    },
    screenChip: {
      height: 20,
    },
    screenChipText: {
      fontSize: responsive.fontSize(10),
      marginVertical: -2,
    },
    paymentBadge: {
      paddingHorizontal: 10,
      paddingVertical: 4,
      borderRadius: 12,
    },
    paymentBadgeText: {
      color: 'white',
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    totalAmount: {
      fontSize: responsive.fontSize(16),
      fontWeight: '700',
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.08)',
      backgroundColor: 'inherit',
    },
    footerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    totalLabel: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
    },
    divider: {
      marginVertical: 2,
    },
    closeButton: {
      margin: -8,
    },
    headerActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 16,
    },
    headerStatusChip: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 10,
    },
    headerStatusChipText: {
      color: 'white',
      fontSize: responsive.fontSize(11),
      fontWeight: '600',
    },
    title: {
      fontSize: responsive.fontSize(20),
      fontWeight: '700',
    },
    scrollView: {
      flexGrow: 0,
      flexShrink: 1,
      maxHeight: '70%',
    },
    scrollContent: {
      paddingBottom: 8,
    },
    itemsList: {
      padding: 12,
      paddingBottom: 16,
    },
    itemCard: {
      borderRadius: 8,
      overflow: 'hidden',
    },
    itemContent: {
      padding: 10,
    },
    itemHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 6,
    },
    nameContainer: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    itemQuantity: {
      fontSize: responsive.fontSize(14),
      fontWeight: '700',
      marginRight: 6,
    },
    itemName: {
      fontSize: responsive.fontSize(13),
      fontWeight: '600',
      flex: 1,
      lineHeight: 16,
    },
    statusChip: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
    },
    statusChipText: {
      color: 'white',
      fontSize: responsive.fontSize(10),
      fontWeight: '600',
    },
    itemDetailsContainer: {
      marginBottom: 6,
    },
    customizationContainer: {
      marginBottom: 4,
    },
    pizzaCustomizationText: {
      fontSize: responsive.fontSize(11),
      fontStyle: 'italic',
      lineHeight: 14,
    },
    modifiersContainer: {
      marginTop: 2,
    },
    modifierRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 1,
    },
    modifierText: {
      fontSize: responsive.fontSize(11),
      flex: 1,
      lineHeight: 14,
    },
    modifierPrice: {
      fontSize: responsive.fontSize(11),
      fontWeight: '500',
      marginLeft: 4,
    },
    notesContainer: {
      marginTop: 4,
      paddingTop: 4,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.06)',
    },
    notesText: {
      fontSize: responsive.fontSize(11),
      fontStyle: 'italic',
      lineHeight: 14,
    },
    priceContainer: {
      marginTop: 6,
      paddingTop: 6,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.06)',
    },
    priceRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    priceLabel: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    priceValue: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    totalPrice: {
      fontSize: responsive.fontSize(14),
      fontWeight: '700',
    },
    paymentsSection: {
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    paymentSummaryCompact: {
      marginBottom: 8,
    },
    summaryCompactRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    summaryCompactLabel: {
      fontSize: responsive.fontSize(12),
      fontWeight: '500',
    },
    paymentRowCompact: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 6,
      gap: 8,
    },
    paymentMethodCompact: {
      fontSize: responsive.fontSize(11),
      fontWeight: '500',
      flex: 1,
    },
    paymentDateCompact: {
      fontSize: responsive.fontSize(10),
    },
    paymentAmountCompact: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
      minWidth: 50,
      textAlign: 'right',
    },
    paymentStatusBadgeCompact: {
      paddingHorizontal: 6,
      paddingVertical: 1,
      borderRadius: 10,
    },
    paymentStatusTextCompact: {
      fontSize: responsive.fontSize(9),
      fontWeight: '600',
    },
    ticketImpressionsSection: {
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    collapsibleHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingRight: 4,
    },
    collapseIcon: {
      margin: -8,
    },
    collapsibleContent: {
      marginTop: 8,
    },
    sectionTitle: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
      marginBottom: 0,
    },
    impressionRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 8,
      paddingLeft: 8,
    },
    impressionLeft: {
      flex: 1,
      gap: 2,
    },
    impressionType: {
      fontSize: responsive.fontSize(12),
      fontWeight: '500',
    },
    impressionDetails: {
      gap: 2,
    },
    impressionUser: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    impressionPrinter: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
      fontStyle: 'italic',
    },
    impressionTime: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    loadingContainer: {
      minHeight: 200,
      justifyContent: 'center',
      alignItems: 'center',
      paddingVertical: 40,
    },
    loadingText: {
      marginTop: 16,
      fontSize: responsive.fontSize(14),
    },
  });

export default OrderDetailsModal;

================
File: app/src/modules/orderFinalization/types/orderFinalization.types.ts
================
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';

// Tipo ligero para la lista de órdenes (optimizado)
export interface OrderForFinalizationList {
  id: string;
  shiftOrderNumber: number;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN';
  orderStatus:
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'COMPLETED'
    | 'CANCELLED';
  total: string | number;
  createdAt: string;
  scheduledAt?: string;
  paymentsSummary?: {
    totalPaid: number;
  };
  deliveryInfo?: {
    recipientName?: string;
    recipientPhone?: string;
    fullAddress?: string;
  };
  preparationScreens?: string[];
  preparationScreenStatuses?: Array<{
    name: string;
    status: 'PENDING' | 'IN_PROGRESS' | 'READY';
  }>;
  ticketImpressionCount?: number;
  notes?: string;
  table?: {
    number: string;
    name: string;
    isTemporary: boolean;
    area?: {
      name: string;
    };
  };
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
  isFromWhatsApp?: boolean;
}

// Tipo completo para el detalle de orden
export interface OrderForFinalization {
  id: string;
  shiftOrderNumber: number;
  deliveryInfo: DeliveryInfo;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN';
  orderStatus:
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'COMPLETED'
    | 'CANCELLED';
  total: string | number;
  orderItems: OrderItemForFinalization[];
  createdAt: string;
  updatedAt: string;
  scheduledAt?: string;
  tableId?: string;
  user?: {
    id: string;
    firstName?: string;
    lastName?: string;
  };
  table?: {
    id: string;
    number: string;
    area?: {
      name: string;
    };
  } | null;
  isFromWhatsApp?: boolean;
  preparationScreens?: string[];
  payments?: {
    id: string;
    amount: number;
    paymentMethod: string;
    paymentStatus: string;
    createdAt: string;
    updatedAt: string;
  }[];
  notes?: string;
  ticketImpressions?: {
    id: string;
    ticketType: string;
    impressionTime: string;
    user?: {
      id: string;
      firstName?: string;
      lastName?: string;
    };
    printer?: {
      id: string;
      name: string;
    };
  }[];
}

export interface OrderItemForFinalization {
  id: string;
  quantity: number;
  basePrice: string;
  finalPrice: string;
  preparationNotes?: string;
  preparationStatus?: string;
  product: {
    id: string;
    name: string;
    description?: string;
  };
  productVariant?: {
    id: string;
    name: string;
  } | null;
  modifiers: OrderItemModifierForFinalization[];
  selectedPizzaCustomizations?: any[];
}

export interface OrderItemModifierForFinalization {
  id: string;
  name: string;
  price: number | string;
}

export interface OrderSelectionState {
  selectedOrders: Set<string>;
  totalAmount: number;
}

export interface FinalizeOrdersPayload {
  orderIds: string[];
  paymentMethod?: string;
  notes?: string;
}

export type OrderFinalizationFilter = 'delivery' | 'take_away' | 'dine_in';

================
File: app/src/modules/orders/screens/CreateOrderScreen.tsx
================
import React, {
  useState,
  useMemo,
  useRef,
  useCallback,
  useEffect,
} from 'react';
import { StyleSheet, View, FlatList } from 'react-native';
import {
  Text,
  Portal,
  ActivityIndicator,
  Card,
  Title,
  Appbar,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation } from '@react-navigation/native';
import { useGetOrderMenu } from '../hooks/useMenuQueries';
import { useCreateOrderMutation } from '@/modules/orders/hooks/useOrdersQueries';
import { useCartStore, useIsCartEmpty, useCartItemsCount, useClearAll, CartItem, CartItemModifier } from '../stores/useCartStore';
import { useOrderFormStore } from '../stores/useOrderFormStore';
import { Product, Category, SubCategory } from '../types/orders.types';
import { AutoImage } from '@/app/components/common/AutoImage';
import { MaterialCommunityIcons } from '@expo/vector-icons';

import OrderCartDetail from '../components/OrderCartDetail';
import ProductCustomizationModal from '../components/ProductCustomizationModal';
import SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';
import CartButton from '../components/CartButton';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { AudioRecorderWidget } from '@/components/AudioRecorderWidget';
import { AudioOrderModal } from '@/components/AudioOrderModal';
import {
  audioOrderService,
  type AIOrderItem,
} from '@/services/audioOrderService';
import { useAuthStore } from '@/app/store/authStore';
import { canOpenShift } from '@/app/utils/roleUtils';
import { useGlobalShift } from '@/app/hooks/useGlobalShift';

import { useAppTheme } from '@/app/styles/theme';
import type { OrderDetailsForBackend } from '../components/OrderCartDetail';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import { useResponsive } from '@/app/hooks/useResponsive';

interface CartButtonHandle {
  animate: () => void;
}

const CreateOrderScreen = () => {
  const theme = useAppTheme();
  const { colors, fonts } = theme;
  const responsive = useResponsive();
  const navigation = useNavigation();
  const {
    addItem: originalAddItem,
    updateItem,
    isCartVisible,
    showCart,
    hideCart,
  } = useCartStore();
  
  const isCartEmpty = useIsCartEmpty();
  const totalItemsCount = useCartItemsCount();
  const clearAll = useClearAll();
  
  const { setOrderType, setDeliveryInfo } = useOrderFormStore();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const user = useAuthStore((state) => state.user);
  const { data: shift, isLoading: shiftLoading } = useGlobalShift();
  const userCanOpenShift = canOpenShift(user);

  const createOrderMutation = useCreateOrderMutation();

  const cartButtonRef = useRef<CartButtonHandle>(null);

  const [navigationLevel, setNavigationLevel] = useState<
    'categories' | 'subcategories' | 'products'
  >('categories');
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null,
  );
  const [selectedSubcategoryId, setSelectedSubcategoryId] = useState<
    string | null
  >(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [showExitConfirmationModal, setShowExitConfirmationModal] =
    useState(false);
  const [pendingNavigationAction, setPendingNavigationAction] = useState<
    (() => void) | null
  >(null);
  const [isProcessingOrder, setIsProcessingOrder] = useState(false);
  const isProcessingOrderRef = useRef(false);
  const [selectedProductForDescription, setSelectedProductForDescription] =
    useState<Product | null>(null);
  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =
    useState(false);

  // Estados para el widget de audio
  const [showAudioModal, setShowAudioModal] = useState(false);
  const [audioOrderData, setAudioOrderData] = useState<any>(null);
  const [isProcessingAudio, setIsProcessingAudio] = useState(false);
  const [audioError, setAudioError] = useState<string | undefined>();

  const { data: menu, isLoading } = useGetOrderMenu();

  // Calcular número de columnas dinámicamente
  const numColumns = useMemo(() => {
    // Para tablets (ancho >= 600px)
    if (responsive.width >= 600) {
      if (responsive.width >= 1200) return 6; // Tablets muy grandes
      if (responsive.width >= 900) return 5; // Tablets grandes
      if (responsive.width >= 768) return 4; // Tablets medianas
      return 3; // Tablets pequeñas (600-768px)
    }
    // Para móviles (ancho < 600px)
    if (responsive.width >= 480) return 3; // Móviles grandes
    if (responsive.width >= 360) return 2; // Móviles estándar
    return 2; // Móviles pequeños
  }, [responsive.width]);

  // Calcular ancho de items basado en columnas
  const itemWidth = useMemo(() => {
    const padding = responsive.spacing(theme.spacing.m);
    const totalPadding = padding * 2;
    const gap = responsive.spacing(8);
    const totalGaps = gap * (numColumns - 1);
    const availableWidth = responsive.width - totalPadding - totalGaps;
    return Math.floor(availableWidth / numColumns);
  }, [responsive.width, numColumns, theme.spacing.m, responsive]);

  const handleCategorySelect = useCallback((categoryId: string) => {
    setSelectedCategoryId(categoryId);
    setSelectedSubcategoryId(null);
    setNavigationLevel('subcategories');
  }, []);

  const handleSubCategorySelect = useCallback((subcategoryId: string) => {
    setSelectedSubcategoryId(subcategoryId);
    setNavigationLevel('products');
  }, []);

  const productNeedsCustomization = useCallback((product: Product): boolean => {
    if (!product) return false;
    const hasVariants =
      product.hasVariants &&
      product.variants &&
      Array.isArray(product.variants) &&
      product.variants.length > 0;
    const hasModifiers =
      product.modifierGroups &&
      Array.isArray(product.modifierGroups) &&
      product.modifierGroups.length > 0;
    return hasVariants || hasModifiers;
  }, []);

  const handleProductSelect = useCallback(
    (product: Product) => {
      if (productNeedsCustomization(product)) {
        setSelectedProduct(product);
      } else {
        handleAddItem(product, 1);
      }
    },
    [handleAddItem],
  );

  const handleCloseProductModal = useCallback(() => {
    setSelectedProduct(null);
    setEditingItem(null);
    // Si estábamos editando y hay items en el carrito, volver a mostrar el carrito
    if (editingItem && !isCartEmpty) {
      showCart();
    }
  }, [editingItem, isCartEmpty, showCart]);

  const handleEditItem = useCallback(
    (item: CartItem) => {
      // Encontrar el producto completo desde el menú
      if (!menu || !Array.isArray(menu)) {
        showSnackbar({
          message:
            'El menú aún se está cargando. Por favor, intenta nuevamente.',
          type: 'info',
        });
        return;
      }

      // Buscar el producto en la estructura anidada
      let product: Product | undefined;

      for (const category of menu) {
        if (category.subcategories && Array.isArray(category.subcategories)) {
          for (const subcategory of category.subcategories) {
            if (subcategory.products && Array.isArray(subcategory.products)) {
              product = subcategory.products.find(
                (p) => p.id === item.productId,
              );
              if (product) break;
            }
          }
        }
        if (product) break;
      }

      if (product) {
        setEditingItem(item);
        setSelectedProduct(product);
        hideCart(); // Cerrar el carrito para mostrar el modal de personalización
      } else {
        showSnackbar({
          message:
            'No se pudo encontrar el producto. Por favor, recarga la pantalla.',
          type: 'error',
        });
      }
    },
    [menu, showSnackbar, hideCart],
  );

  const handleGoBackInternal = () => {
    if (navigationLevel === 'products') {
      setNavigationLevel('subcategories');
      setSelectedSubcategoryId(null);
    } else if (navigationLevel === 'subcategories') {
      setNavigationLevel('categories');
      setSelectedCategoryId(null);
    }
  };

  const handleAttemptExit = (goBackAction: () => void) => {
    if (isCartEmpty) {
      goBackAction();
    } else {
      setPendingNavigationAction(() => goBackAction);
      setShowExitConfirmationModal(true);
    }
  };

  useEffect(() => {
    const unsubscribe = navigation.addListener('beforeRemove', (e) => {
      // Don't do anything if cart is empty, modal is already showing, or we're processing an order
      if (isCartEmpty || showExitConfirmationModal || isProcessingOrder) {
        return;
      }

      // Prevent default for any navigation away when cart has items
      // This includes back navigation and drawer navigation
      e.preventDefault();
      setPendingNavigationAction(
        () => () => navigation.dispatch(e.data.action),
      );
      setShowExitConfirmationModal(true);
    });

    return unsubscribe;
  }, [navigation, isCartEmpty, showExitConfirmationModal, isProcessingOrder]);

  const handleViewCart = useCallback(() => {
    showCart();
  }, [showCart]);

  const handleCloseCart = useCallback(() => {
    hideCart();
  }, [hideCart]);

  // Actualizar handleConfirmOrder para usar la mutación
  const handleConfirmOrder = async (details: OrderDetailsForBackend) => {
    // Verificación atómica usando ref
    if (isProcessingOrderRef.current) return;
    isProcessingOrderRef.current = true;
    setIsProcessingOrder(true);

    try {
      // Llamar a la mutación para enviar la orden al backend
      const createdOrder = await createOrderMutation.mutateAsync(details);

      // Usar 'shiftOrderNumber' que es lo que devuelve el backend
      showSnackbar({
        message: `Orden #${createdOrder.shiftOrderNumber} creada con éxito`,
        type: 'success',
      });
      hideCart();
      clearAll(); // Limpiar carrito y formulario ANTES de navegar

      // Pequeño delay para asegurar que el estado se actualice antes de navegar
      setTimeout(() => {
        navigation.goBack();
      }, 100);
    } catch (error) {
      // El manejo de errores con snackbar ya debería estar en el hook useCreateOrderMutation
      const message = getApiErrorMessage(error as Error);
      showSnackbar({
        message: `Error al crear orden: ${message}`,
        type: 'error',
      });
    } finally {
      setIsProcessingOrder(false);
      isProcessingOrderRef.current = false;
    }
  };

  const handleAddItem = (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    originalAddItem(
      product,
      quantity,
      selectedVariantId,
      selectedModifiers,
      preparationNotes,
      selectedPizzaCustomizations,
      pizzaExtraCost,
    );
    cartButtonRef.current?.animate();
  };

  // Handlers para el widget de audio
  const handleAudioRecordingComplete = useCallback(
    async (audioUri: string, transcription: string) => {
      setIsProcessingAudio(true);
      setShowAudioModal(true);
      setAudioError(undefined);

      try {
        const response = await audioOrderService.processAudioOrder(
          audioUri,
          transcription,
        );

        if (response.success && response.data) {
          setAudioOrderData(response.data);
        } else {
          setAudioError(response.error?.message || 'Error procesando la orden');
        }
      } catch (error) {
        setAudioError('Error al procesar la orden por voz');
      } finally {
        setIsProcessingAudio(false);
      }
    },
    [],
  );

  const handleAudioError = useCallback(
    (error: string) => {
      showSnackbar({
        message: error,
        type: 'error',
      });
    },
    [showSnackbar],
  );

  const handleConfirmAudioOrder = async (
    items: AIOrderItem[],
    deliveryInfo?: any,
    scheduledDelivery?: any,
    orderType?: 'DELIVERY' | 'TAKE_AWAY' | 'DINE_IN',
  ) => {
    // Procesamos los items detectados por voz y los agregamos al carrito
    try {
      if (!menu) {
        throw new Error('El menú no está disponible');
      }

      let addedCount = 0;
      let failedCount = 0;

      // Procesar cada item detectado
      for (const item of items) {
        let foundProduct: Product | null = null;

        // Buscar el producto en el menú
        outer: for (const category of menu) {
          for (const subcategory of category.subcategories || []) {
            for (const product of subcategory.products || []) {
              if (product.id === item.productId) {
                foundProduct = product;
                break outer;
              }
            }
          }
        }

        if (foundProduct) {
          // Preparar modificadores
          const selectedModifiers: CartItemModifier[] = [];
          if (item.modifiers && item.modifiers.length > 0) {
            for (const modName of item.modifiers) {
              // Buscar el modificador en el producto
              for (const modGroup of foundProduct.modifierGroups || []) {
                const modifier = modGroup.productModifiers?.find(
                  (m) => m.name === modName,
                );
                if (modifier) {
                  selectedModifiers.push({
                    id: modifier.id,
                    modifierGroupId: modGroup.id,
                    name: modifier.name,
                    price: modifier.price || 0,
                  });
                  break;
                }
              }
            }
          }

          // Preparar personalizaciones de pizza
          const pizzaCustomizations = item.pizzaCustomizations?.map((pc) => ({
            pizzaCustomizationId: pc.customizationId,
            half: pc.half as any,
            action: pc.action as any,
          }));

          // Agregar al carrito
          handleAddItem(
            foundProduct,
            item.quantity,
            item.variantId,
            selectedModifiers,
            undefined, // preparationNotes
            pizzaCustomizations,
            0, // pizzaExtraCost (se calculará en el modal si es necesario)
          );

          addedCount++;
        } else {
          failedCount++;
        }
      }

      // Mostrar resultado
      if (addedCount > 0 && failedCount === 0) {
        showSnackbar({
          message: `Se agregaron ${addedCount} producto${addedCount > 1 ? 's' : ''} al carrito`,
          type: 'success',
        });
      } else if (addedCount > 0 && failedCount > 0) {
        showSnackbar({
          message: `Se agregaron ${addedCount} producto${addedCount > 1 ? 's' : ''}, ${failedCount} no se encontraron`,
          type: 'warning',
        });
      } else {
        showSnackbar({
          message: 'No se pudieron agregar los productos al carrito',
          type: 'error',
        });
      }

      // Si hay información de entrega, guardarla en el contexto del carrito
      if (deliveryInfo && Object.keys(deliveryInfo).length > 0) {
        setDeliveryInfo(deliveryInfo);
      }

      // Si se detectó un tipo de orden, actualizarlo en el contexto del carrito

      if (orderType) {
        setOrderType(orderType);
      } else {
        // Order type not changed, keep current value
      }

      setShowAudioModal(false);
      setAudioOrderData(null);

      // Animar el botón del carrito si se agregaron productos
      if (addedCount > 0) {
        cartButtonRef.current?.animate();
      }
    } catch (error) {
      showSnackbar({
        message: 'Error al agregar los productos al carrito',
        type: 'error',
      });
    }
  };

  const getCategories = () => {
    if (!menu || !Array.isArray(menu)) return [];
    return menu;
  };

  const getSubcategories = () => {
    if (!selectedCategory || !Array.isArray(selectedCategory.subcategories))
      return [];
    return selectedCategory.subcategories;
  };

  const getProducts = () => {
    if (!selectedSubCategory || !Array.isArray(selectedSubCategory.products))
      return [];
    return selectedSubCategory.products;
  };

  const selectedCategory =
    menu && Array.isArray(menu)
      ? menu.find((cat: Category) => cat.id === selectedCategoryId)
      : null;

  const selectedSubCategory =
    selectedCategory && Array.isArray(selectedCategory.subcategories) // Corregido a lowercase
      ? selectedCategory.subcategories.find(
          // Corregido a lowercase
          (sub: SubCategory) => sub.id === selectedSubcategoryId,
        )
      : null;

  const getNavTitle = useCallback(() => {
    if (selectedProduct) {
      return selectedProduct.name;
    }
    switch (navigationLevel) {
      case 'categories':
        return 'Categorías';
      case 'subcategories':
        return selectedCategory?.name
          ? `Categoría: ${selectedCategory.name}`
          : 'Subcategorías';
      case 'products':
        return selectedSubCategory?.name
          ? `Subcategoría: ${selectedSubCategory.name}`
          : 'Productos';
      default:
        return 'Categorías';
    }
  }, [navigationLevel, selectedCategory, selectedSubCategory, selectedProduct]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: colors.background,
        },
        container: {
          flex: 1,
        },
        content: {
          flex: 1,
        },
        gridContainer: {
          padding: responsive.spacing(theme.spacing.m),
          paddingBottom: 60,
        },
        row: {
          justifyContent: 'flex-start',
          paddingHorizontal: 0,
          marginBottom: responsive.spacing(8),
          gap: responsive.spacing(8),
        },
        cardItem: {
          width: itemWidth,
          marginHorizontal: 0,
          marginVertical: 0,
          overflow: 'hidden',
          borderRadius: theme.roundness * 2,
          elevation: 2,
          backgroundColor: colors.surface,
          aspectRatio: 0.85,
        },
        cardItemInactive: {
          opacity: 0.5,
        },
        itemImage: {
          width: '100%',
          height: itemWidth * 0.65,
        },
        imageInactive: {
          opacity: 0.6,
        },
        cardContent: {
          paddingHorizontal: responsive.spacing(theme.spacing.s),
          paddingVertical: responsive.spacing(theme.spacing.xs),
          height: itemWidth * 0.35,
          justifyContent: 'center',
        },
        cardTitle: {
          fontSize: responsive.fontSize(responsive.width >= 600 ? 16 : 15),
          fontWeight: '600',
          lineHeight:
            responsive.fontSize(responsive.width >= 600 ? 16 : 15) * 1.2,
          marginBottom: responsive.spacing(2),
        },
        cardHeader: {
          flexDirection: 'row',
          justifyContent: 'space-between',
          alignItems: 'flex-start',
        },
        infoButton: {
          margin: -8,
          marginTop: -12,
          marginRight: -12,
        },
        priceText: {
          color: theme.colors.primary,
          fontWeight: '600',
          fontSize: responsive.fontSize(responsive.width >= 600 ? 14 : 13),
          marginTop: 2,
        },
        noItemsText: {
          textAlign: 'center',
          marginTop: 40,
          fontSize: 16,
          color: '#666',
        },
        loadingContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
        },
        appBar: {
          backgroundColor: colors.elevation.level2,
          alignItems: 'center',
        },
        appBarTitle: {
          ...fonts.titleMedium,
          color: colors.onSurface,
          fontWeight: 'bold',
          textAlign: 'center',
        },
        appBarContent: {},
        spacer: {
          width: 48,
        },
        inactiveBadge: {
          position: 'absolute',
          top: 8,
          right: 8,
          backgroundColor: colors.errorContainer,
          paddingHorizontal: 8,
          paddingVertical: 4,
          borderRadius: 4,
        },
        inactiveBadgeText: {
          fontSize: 12,
          color: colors.onErrorContainer,
          fontWeight: '600',
        },
        emptyStateContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacing.l,
        },
        emptyStateTitle: {
          marginTop: responsive.spacing.l,
          marginBottom: responsive.spacing.m,
          textAlign: 'center',
          color: colors.onSurface,
          fontWeight: '600',
        },
        emptyStateText: {
          textAlign: 'center',
          color: colors.onSurfaceVariant,
          maxWidth: 320,
          lineHeight: 24,
        },
      }),
    [colors, fonts, theme, responsive, itemWidth],
  );

  const handleConfirmExit = () => {
    setShowExitConfirmationModal(false);

    // Store the navigation action before clearing the cart
    const navigationAction =
      pendingNavigationAction || (() => navigation.goBack());

    // Clear the pending action
    setPendingNavigationAction(null);

    // Execute navigation first
    navigationAction();

    // Clear cart after navigation to avoid the beforeRemove check
    setTimeout(() => {
      clearAll();
    }, 100);
  };

  const handleCancelExit = () => {
    setShowExitConfirmationModal(false);
    setPendingNavigationAction(null);
  };

  const handleShowProductDescription = (product: Product) => {
    setSelectedProductForDescription(product);
    setIsDescriptionModalVisible(true);
  };

  const handleCloseDescriptionModal = () => {
    setIsDescriptionModalVisible(false);
    setSelectedProductForDescription(null);
  };

  const blurhash =
    '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';

  const renderItem = useCallback(
    ({ item }: { item: Category | SubCategory | Product }) => {
      const imageSource = item.photo ? item.photo.path : null;
      const isActive = item.isActive !== false; // Por defecto true si no existe la propiedad

      // Verificar si es un producto sin pantalla de preparación
      const isProductWithoutScreen =
        navigationLevel === 'products' &&
        'preparationScreenId' in item &&
        !item.preparationScreenId;

      const handlePress = () => {
        // No hacer nada si el elemento está inactivo o es un producto sin pantalla
        if (!isActive || isProductWithoutScreen) return;

        if (navigationLevel === 'categories') {
          handleCategorySelect(item.id);
        } else if (navigationLevel === 'subcategories') {
          handleSubCategorySelect(item.id);
        } else if ('price' in item) {
          handleProductSelect(item as Product);
        }
      };

      const renderPrice = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          'hasVariants' in item
        ) {
          const productItem = item as Product;
          if (
            !productItem.hasVariants &&
            productItem.price !== null &&
            productItem.price !== undefined
          ) {
            return (
              <Text style={styles.priceText}>
                ${Number(productItem.price).toFixed(2)}
              </Text>
            );
          }
        }
        return null;
      };

      return (
        <Card
          style={[
            styles.cardItem,
            (!isActive || isProductWithoutScreen) && styles.cardItemInactive,
          ]}
          onPress={handlePress}
          disabled={!isActive || isProductWithoutScreen}
        >
          <AutoImage
            source={imageSource}
            style={[
              styles.itemImage,
              (!isActive || isProductWithoutScreen) && styles.imageInactive,
            ]}
            contentFit="cover"
            placeholder={blurhash}
            transition={300}
            placeholderIcon="image-outline"
          />
          {!isActive && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>INACTIVO</Text>
            </View>
          )}
          {isProductWithoutScreen && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>SIN PANTALLA</Text>
            </View>
          )}
          <View style={styles.cardContent}>
            {navigationLevel === 'products' &&
            'price' in item &&
            (item as Product).description ? (
              <View style={styles.cardHeader}>
                <Title
                  style={[styles.cardTitle, { flex: 1 }]}
                  numberOfLines={2}
                  ellipsizeMode="tail"
                >
                  {item.name}
                </Title>
                <IconButton
                  icon="information-outline"
                  size={20}
                  onPress={() => handleShowProductDescription(item as Product)}
                  style={styles.infoButton}
                />
              </View>
            ) : (
              <Title
                style={styles.cardTitle}
                numberOfLines={2}
                ellipsizeMode="tail"
              >
                {item.name}
              </Title>
            )}
            {renderPrice()}
          </View>
        </Card>
      );
    },
    [
      navigationLevel,
      handleCategorySelect,
      handleSubCategorySelect,
      handleProductSelect,
      handleShowProductDescription,
      styles,
      blurhash,
    ],
  );

  const getItemsToDisplay = () => {
    switch (navigationLevel) {
      case 'categories':
        return getCategories();
      case 'subcategories':
        return getSubcategories();
      case 'products':
        return getProducts();
      default:
        return [];
    }
  };

  const itemsToDisplay = getItemsToDisplay();
  const showCartButton = !isCartVisible && !selectedProduct;

  const backAction = selectedProduct
    ? handleCloseProductModal
    : navigationLevel === 'categories'
      ? () => handleAttemptExit(() => navigation.goBack())
      : handleGoBackInternal;

  const renderContent = () => {
    if (isCartVisible) {
      return (
        <SafeAreaView
          style={styles.safeArea}
          edges={['left', 'right', 'bottom']}
        >
          <Appbar.Header style={styles.appBar}>
            <Appbar.BackAction onPress={handleCloseCart} />
            <Appbar.Content
              title="Carrito de Compras"
              titleStyle={styles.appBarTitle}
              style={styles.appBarContent}
            />
            <View style={styles.spacer} />
          </Appbar.Header>
          <OrderCartDetail
            visible={isCartVisible}
            onClose={handleCloseCart}
            onConfirmOrder={handleConfirmOrder}
            onEditItem={handleEditItem}
            isEditMode={false}
          />
        </SafeAreaView>
      );
    }

    // Verificar turno antes de renderizar
    if (!shiftLoading && (!shift || shift.status !== 'OPEN')) {
      return (
        <SafeAreaView
          style={styles.safeArea}
          edges={['left', 'right', 'bottom']}
        >
          <Appbar.Header style={styles.appBar} elevated>
            <Appbar.BackAction onPress={() => navigation.goBack()} />
            <Appbar.Content
              title="Crear Orden"
              titleStyle={styles.appBarTitle}
              style={styles.appBarContent}
            />
          </Appbar.Header>
          <View style={styles.emptyStateContainer}>
            <MaterialCommunityIcons
              name="store-alert"
              size={64}
              color={theme.colors.onSurfaceVariant}
            />
            <Text variant="headlineSmall" style={styles.emptyStateTitle}>
              Turno Cerrado
            </Text>
            <Text variant="bodyLarge" style={styles.emptyStateText}>
              {userCanOpenShift
                ? 'Para crear órdenes, primero debes abrir el turno usando el indicador en la barra superior.'
                : 'El turno debe estar abierto para crear órdenes. Contacta a un administrador.'}
            </Text>
          </View>
        </SafeAreaView>
      );
    }

    return (
      <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction onPress={backAction} />
          <Appbar.Content
            title={getNavTitle()}
            titleStyle={styles.appBarTitle}
            style={styles.appBarContent}
          />
          {showCartButton ? (
            <CartButton
              ref={cartButtonRef}
              itemCount={totalItemsCount}
              onPress={handleViewCart}
            />
          ) : (
            <View style={styles.spacer} />
          )}
        </Appbar.Header>

        <View style={styles.content}>
          {isLoading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color="#2e7d32" />
              <Text>Cargando...</Text>
            </View>
          ) : itemsToDisplay.length > 0 ? (
            <FlatList
              data={itemsToDisplay}
              renderItem={renderItem}
              keyExtractor={(item) => item.id}
              numColumns={numColumns}
              key={numColumns}
              contentContainerStyle={styles.gridContainer}
              columnWrapperStyle={numColumns > 1 ? styles.row : undefined}
              showsVerticalScrollIndicator={false}
            />
          ) : (
            <Text style={styles.noItemsText}>
              {navigationLevel === 'products'
                ? 'No hay productos disponibles'
                : navigationLevel === 'subcategories'
                  ? 'No hay subcategorías disponibles'
                  : 'No hay categorías disponibles'}
            </Text>
          )}
        </View>

        <ConfirmationModal
          visible={showExitConfirmationModal}
          title="¿Descartar Orden?"
          message="Tienes artículos en el carrito. Si sales, se perderán. ¿Estás seguro?"
          confirmText="Salir y Descartar"
          cancelText="Cancelar"
          onConfirm={handleConfirmExit}
          onCancel={handleCancelExit}
        />

        <Portal>
          {selectedProduct && productNeedsCustomization(selectedProduct) && (
            <ProductCustomizationModal
              visible={true}
              product={selectedProduct}
              editingItem={editingItem}
              onAddToCart={handleAddItem}
              onUpdateItem={updateItem}
              onDismiss={handleCloseProductModal}
            />
          )}

          <SimpleProductDescriptionModal
            visible={isDescriptionModalVisible}
            product={selectedProductForDescription}
            onDismiss={handleCloseDescriptionModal}
          />
          <AudioOrderModal
            visible={showAudioModal}
            onDismiss={() => {
              setShowAudioModal(false);
              setAudioOrderData(null);
              setAudioError(undefined);
            }}
            onConfirm={handleConfirmAudioOrder}
            isProcessing={isProcessingAudio}
            orderData={audioOrderData}
            error={audioError}
          />
        </Portal>

        {/* Widget de grabación de audio */}
        {!isCartVisible && !selectedProduct && (
          <AudioRecorderWidget
            onRecordingComplete={handleAudioRecordingComplete}
            onError={handleAudioError}
          />
        )}
      </SafeAreaView>
    );
  };

  return renderContent();
};

export default CreateOrderScreen;

================
File: app/src/modules/restaurantConfig/screens/RestaurantConfigScreen.tsx
================
import React, { useState } from 'react';
import { Portal } from 'react-native-paper';
import {
  View,
  StyleSheet,
  useWindowDimensions,
  BackHandler,
  Pressable,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import {
  Text,
  Switch,
  TextInput,
  Button,
  ActivityIndicator,
  Dialog,
  Surface,
  Chip,
  Icon,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useRestaurantConfigQueries } from '../hooks/useRestaurantConfigQueries';
import {
  UpdateRestaurantConfigDto,
  CreateBusinessHoursDto,
} from '../types/restaurantConfig.types';
import BusinessHoursForm from '../components/BusinessHoursForm';
import TimeZoneSelector from '../components/TimeZoneSelector';
import { WebViewDeliveryCoverageMap } from '../components/WebViewDeliveryCoverageMap';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useNavigation } from '@react-navigation/native';
import { useFocusEffect } from '@react-navigation/native';
import { useRefreshOnFocus } from '@/app/hooks/useRefreshOnFocus';

type TabType = 'basic' | 'operation' | 'schedule';

const RestaurantConfigScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { width, height } = useWindowDimensions();
  const navigation = useNavigation();
  const styles = React.useMemo(
    () => createStyles(theme, responsive, width, height),
    [theme, responsive, width, height],
  );

  const { useGetConfig, useUpdateConfig } = useRestaurantConfigQueries();
  const { data: config, isLoading, error } = useGetConfig();
  const updateConfigMutation = useUpdateConfig();
  const updateDeliveryAreaMutation = useUpdateConfig({
    successMessage: 'Área de cobertura actualizada exitosamente',
  });

  const [activeTab, setActiveTab] = useState<TabType>('basic');
  const [pendingTab, setPendingTab] = useState<TabType | null>(null);
  const [formData, setFormData] = useState<UpdateRestaurantConfigDto>({});
  const [isEditing, setIsEditing] = useState(false);
  const [showDiscardDialog, setShowDiscardDialog] = useState(false);
  const [showDeliveryModal, setShowDeliveryModal] = useState(false);
  const [isEditingDelivery, setIsEditingDelivery] = useState(false);
  const [isNavigatingAway, setIsNavigatingAway] = useState(false);
  const [businessHoursModified, setBusinessHoursModified] = useState(false);
  const [originalDeliveryArea, setOriginalDeliveryArea] = useState<any>(null);
  const [showAreaValidationModal, setShowAreaValidationModal] = useState(false);
  const [showScheduleConflictModal, setShowScheduleConflictModal] =
    useState(false);

  // Refrescar configuración cuando la pantalla recibe foco
  useRefreshOnFocus([['restaurantConfig']]);

  // Función para validar conflictos de horarios
  const hasScheduleConflicts = React.useCallback(() => {
    if (!formData.businessHours) return false;

    for (let i = 0; i < formData.businessHours.length; i++) {
      const currentDay = formData.businessHours[i];
      if (currentDay.isClosed || !currentDay.openingTime) continue;

      // Verificar si el día anterior cierra después de medianoche
      const previousDayIndex = i === 0 ? 6 : i - 1;
      const previousDay = formData.businessHours.find(
        (h) => h.dayOfWeek === previousDayIndex,
      );

      if (
        !previousDay ||
        previousDay.isClosed ||
        !previousDay.closesNextDay ||
        !previousDay.closingTime
      ) {
        continue;
      }

      // Comparar horarios
      const [currentOpenHour, currentOpenMin] = currentDay.openingTime
        .split(':')
        .map(Number);
      const [prevCloseHour, prevCloseMin] = previousDay.closingTime
        .split(':')
        .map(Number);

      const currentOpenMinutes = currentOpenHour * 60 + currentOpenMin;
      const prevCloseMinutes = prevCloseHour * 60 + prevCloseMin;

      // Si el día actual abre antes o exactamente cuando cierre el día anterior
      if (currentOpenMinutes <= prevCloseMinutes) {
        return true;
      }
    }

    return false;
  }, [formData.businessHours]);

  // Función para verificar si hay cambios sin guardar
  const hasChanges = React.useCallback(() => {
    if (!config) return false;

    // Comparación simple de campos individuales
    const simpleFieldsChanged =
      formData.restaurantName !== config.restaurantName ||
      formData.phoneMain !== config.phoneMain ||
      formData.phoneSecondary !== config.phoneSecondary ||
      formData.address !== config.address ||
      formData.city !== config.city ||
      formData.state !== config.state ||
      formData.postalCode !== config.postalCode ||
      formData.country !== config.country ||
      formData.acceptingOrders !== config.acceptingOrders ||
      formData.estimatedPickupTime !== config.estimatedPickupTime ||
      formData.estimatedDeliveryTime !== config.estimatedDeliveryTime ||
      formData.estimatedDineInTime !== config.estimatedDineInTime ||
      formData.openingGracePeriod !== config.openingGracePeriod ||
      formData.closingGracePeriod !== config.closingGracePeriod ||
      formData.timeZone !== config.timeZone ||
      formData.scheduledOrdersLeadTime !== config.scheduledOrdersLeadTime ||
      formData.minimumOrderValueForDelivery !==
        config.minimumOrderValueForDelivery;

    // Comparar área de cobertura
    const deliveryAreaChanged =
      JSON.stringify(formData.deliveryCoverageArea) !==
      JSON.stringify(config.deliveryCoverageArea);

    return simpleFieldsChanged || deliveryAreaChanged || businessHoursModified;
  }, [config, formData, businessHoursModified]);

  // Interceptar navegación cuando hay cambios sin guardar
  useFocusEffect(
    React.useCallback(() => {
      const unsubscribe = navigation.addListener('beforeRemove', (e) => {
        if (!isEditing || !hasChanges()) {
          // Si no está editando o no hay cambios, permitir navegación
          return;
        }

        // Prevenir la navegación por defecto
        e.preventDefault();

        // Mostrar el diálogo de confirmación
        setIsNavigatingAway(true);
        setShowDiscardDialog(true);
      });

      return unsubscribe;
    }, [navigation, isEditing, hasChanges]),
  );

  // Manejar botón de retroceso de Android
  useFocusEffect(
    React.useCallback(() => {
      const onBackPress = () => {
        if (isEditing && hasChanges()) {
          setIsNavigatingAway(true);
          setShowDiscardDialog(true);
          return true; // Prevenir el comportamiento por defecto
        }
        return false;
      };

      const subscription = BackHandler.addEventListener(
        'hardwareBackPress',
        onBackPress,
      );

      return () => subscription.remove();
    }, [isEditing, hasChanges]),
  );

  React.useEffect(() => {
    if (config && !isEditing) {
      // Solo actualizar formData si no estamos editando
      // Si no hay businessHours, inicializar con valores por defecto
      const initialBusinessHours =
        config.businessHours && config.businessHours.length > 0
          ? config.businessHours.map((hour) => ({
              ...hour,
              // Normalizar el formato de tiempo a HH:MM
              openingTime: hour.openingTime
                ? hour.openingTime.substring(0, 5)
                : null,
              closingTime: hour.closingTime
                ? hour.closingTime.substring(0, 5)
                : null,
            }))
          : [0, 1, 2, 3, 4, 5, 6].map((dayOfWeek) => ({
              dayOfWeek,
              openingTime: '09:00',
              closingTime: '22:00',
              isClosed: false,
            }));

      setFormData({
        // Información básica
        restaurantName: config.restaurantName,
        phoneMain: config.phoneMain,
        phoneSecondary: config.phoneSecondary,
        address: config.address,
        city: config.city,
        state: config.state,
        postalCode: config.postalCode,
        country: config.country,
        // Configuración de operación
        acceptingOrders: config.acceptingOrders,
        estimatedPickupTime: config.estimatedPickupTime,
        estimatedDeliveryTime: config.estimatedDeliveryTime,
        estimatedDineInTime: config.estimatedDineInTime,
        openingGracePeriod: config.openingGracePeriod,
        closingGracePeriod: config.closingGracePeriod,
        timeZone: config.timeZone || 'America/Mexico_City',
        scheduledOrdersLeadTime: config.scheduledOrdersLeadTime,
        // Configuración de delivery
        deliveryCoverageArea: config.deliveryCoverageArea,
        minimumOrderValueForDelivery:
          typeof config.minimumOrderValueForDelivery === 'string'
            ? parseFloat(config.minimumOrderValueForDelivery)
            : config.minimumOrderValueForDelivery,
        // Horarios
        businessHours: initialBusinessHours,
      });
    }
  }, [config, isEditing]);

  const handleSubmit = async () => {
    // Validar conflictos de horarios antes de guardar
    if (hasScheduleConflicts()) {
      setShowScheduleConflictModal(true);
      return;
    }

    try {
      // Formatear los datos antes de enviarlos
      const dataToSubmit = {
        ...formData,
        // Formatear businessHours para quitar los segundos
        businessHours: formData.businessHours?.map((hour) => ({
          ...hour,
          openingTime: hour.openingTime
            ? hour.openingTime.substring(0, 5)
            : null,
          closingTime: hour.closingTime
            ? hour.closingTime.substring(0, 5)
            : null,
        })),
        // deliveryCoverageArea se envía tal como está (array de coordenadas)
      };

      await updateConfigMutation.mutateAsync(dataToSubmit);
      setIsEditing(false);
      setBusinessHoursModified(false);
    } catch (error) {
      // Error handling is done in the mutation hook
    }
  };

  const handleSaveDeliveryArea = async () => {
    try {
      // Guardar solo el área de cobertura
      await updateDeliveryAreaMutation.mutateAsync({
        deliveryCoverageArea: formData.deliveryCoverageArea,
      });

      // Actualizar el estado del config con la nueva área
      if (config) {
        // Esto asegura que el estado local se mantenga sincronizado
        setFormData((prev) => ({
          ...prev,
          deliveryCoverageArea: formData.deliveryCoverageArea,
        }));
      }
    } catch (error) {
      // Error handling is done in the mutation hook
    }
  };

  const handleCancel = () => {
    if (hasChanges()) {
      setShowDiscardDialog(true);
    } else {
      resetForm();
    }
  };

  const resetForm = () => {
    if (config) {
      // Usar la misma lógica de inicialización que en useEffect
      const initialBusinessHours =
        config.businessHours && config.businessHours.length > 0
          ? config.businessHours.map((hour) => ({
              ...hour,
              // Normalizar el formato de tiempo a HH:MM
              openingTime: hour.openingTime
                ? hour.openingTime.substring(0, 5)
                : null,
              closingTime: hour.closingTime
                ? hour.closingTime.substring(0, 5)
                : null,
            }))
          : [0, 1, 2, 3, 4, 5, 6].map((dayOfWeek) => ({
              dayOfWeek,
              openingTime: '09:00',
              closingTime: '22:00',
              isClosed: false,
            }));

      setFormData({
        restaurantName: config.restaurantName,
        phoneMain: config.phoneMain,
        phoneSecondary: config.phoneSecondary,
        address: config.address,
        city: config.city,
        state: config.state,
        postalCode: config.postalCode,
        country: config.country,
        acceptingOrders: config.acceptingOrders,
        estimatedPickupTime: config.estimatedPickupTime,
        estimatedDeliveryTime: config.estimatedDeliveryTime,
        estimatedDineInTime: config.estimatedDineInTime,
        openingGracePeriod: config.openingGracePeriod,
        closingGracePeriod: config.closingGracePeriod,
        timeZone: config.timeZone || 'America/Mexico_City',
        scheduledOrdersLeadTime: config.scheduledOrdersLeadTime,
        deliveryCoverageArea: config.deliveryCoverageArea,
        minimumOrderValueForDelivery:
          typeof config.minimumOrderValueForDelivery === 'string'
            ? parseFloat(config.minimumOrderValueForDelivery)
            : config.minimumOrderValueForDelivery,
        businessHours: initialBusinessHours,
      });
    }
    setIsEditing(false);
    setBusinessHoursModified(false);
  };

  const confirmDiscard = () => {
    resetForm();
    setShowDiscardDialog(false);

    // Si estaba navegando fuera de la pantalla
    if (isNavigatingAway) {
      setIsNavigatingAway(false);
      navigation.goBack();
      return;
    }

    // Si hay una pestaña pendiente, cambiar a ella
    if (pendingTab) {
      setActiveTab(pendingTab);
      setPendingTab(null);
    }
  };

  const handleTabChange = (newTab: TabType) => {
    // Permitir cambio libre de tabs, sin importar si está editando
    setActiveTab(newTab);
  };

  const renderBasicInfo = () => (
    <View style={styles.tabContent}>
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="store-outline"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Información del Restaurante</Text>
        </View>

        <View style={styles.sectionContent}>
          <TextInput
            label="Nombre del restaurante"
            value={formData.restaurantName || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, restaurantName: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
          />

          <TextInput
            label="Teléfono principal"
            value={formData.phoneMain || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, phoneMain: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            keyboardType="phone-pad"
            left={<TextInput.Icon icon="phone" />}
          />

          <TextInput
            label="Teléfono secundario"
            value={formData.phoneSecondary || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, phoneSecondary: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            keyboardType="phone-pad"
            left={<TextInput.Icon icon="cellphone" />}
          />

          <TextInput
            label="Dirección"
            value={formData.address || ''}
            onChangeText={(text) => setFormData({ ...formData, address: text })}
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            multiline
            numberOfLines={2}
            left={<TextInput.Icon icon="map-marker" />}
          />

          <View style={styles.row}>
            <TextInput
              label="Ciudad"
              value={formData.city || ''}
              onChangeText={(text) => setFormData({ ...formData, city: text })}
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
            <TextInput
              label="Estado"
              value={formData.state || ''}
              onChangeText={(text) => setFormData({ ...formData, state: text })}
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.row}>
            <TextInput
              label="Código postal"
              value={formData.postalCode || ''}
              onChangeText={(text) =>
                setFormData({ ...formData, postalCode: text })
              }
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
              keyboardType="numeric"
            />
            <TextInput
              label="País"
              value={formData.country || ''}
              onChangeText={(text) =>
                setFormData({ ...formData, country: text })
              }
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
          </View>

          {/* Botón para área de cobertura */}
          <View style={styles.deliveryButtonContainer}>
            <Button
              mode="contained-tonal"
              onPress={() => setShowDeliveryModal(true)}
              icon="map-marker-radius"
              style={styles.deliveryButton}
              contentStyle={styles.deliveryButtonContent}
              labelStyle={styles.deliveryButtonLabel}
            >
              Área de Cobertura
            </Button>
            {formData.deliveryCoverageArea &&
            formData.deliveryCoverageArea.length > 0 ? (
              <Text style={styles.deliveryStatusText}>
                Área de cobertura definida
              </Text>
            ) : (
              <Text
                style={[
                  styles.deliveryStatusText,
                  styles.deliveryStatusWarning,
                ]}
              >
                Sin área de cobertura definida
              </Text>
            )}
          </View>
        </View>
      </Surface>
    </View>
  );

  const renderOperationConfig = () => (
    <View style={styles.tabContent}>
      {/* Service Status Card */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="store-check"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Estado del Servicio</Text>
        </View>

        <View style={styles.sectionContent}>
          <View style={styles.statusRow}>
            <View style={styles.statusInfo}>
              <Text style={styles.statusLabel}>Recepción de Órdenes</Text>
              <Text style={styles.statusDescription}>
                {formData.acceptingOrders
                  ? 'Las órdenes están siendo aceptadas'
                  : 'No se están aceptando órdenes nuevas'}
              </Text>
            </View>
            <Switch
              value={formData.acceptingOrders}
              onValueChange={(value) =>
                setFormData({ ...formData, acceptingOrders: value })
              }
              disabled={!isEditing}
              color={theme.colors.primary}
            />
          </View>
        </View>
      </Surface>

      {/* Delivery Times Card */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="clock-time-four"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Tiempos de Servicio</Text>
        </View>

        <View style={styles.sectionContent}>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="walk"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Para recoger en tienda"
              value={formData.estimatedPickupTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedPickupTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="moped"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Entrega a domicilio"
              value={formData.estimatedDeliveryTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedDeliveryTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="currency-usd"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Valor mínimo para delivery"
              value={formData.minimumOrderValueForDelivery?.toString() || ''}
              onChangeText={(text) => {
                const value = parseFloat(text);
                setFormData({
                  ...formData,
                  minimumOrderValueForDelivery: isNaN(value) ? 0 : value,
                });
              }}
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="$" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="silverware-fork-knife"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Para comer en el local"
              value={formData.estimatedDineInTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedDineInTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="timer"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Periodo de gracia al abrir"
              value={formData.openingGracePeriod?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  openingGracePeriod: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="timer-off-outline"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Periodo de gracia al cerrar"
              value={formData.closingGracePeriod?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  closingGracePeriod: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="calendar-clock"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Anticipación órdenes programadas"
              value={formData.scheduledOrdersLeadTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  scheduledOrdersLeadTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.infoChip}>
            <Chip
              icon="information"
              mode="flat"
              style={styles.chip}
              textStyle={styles.chipText}
            >
              Los tiempos son estimados y pueden variar
            </Chip>
          </View>
        </View>
      </Surface>

      {/* Time Zone */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="earth"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Zona Horaria</Text>
        </View>

        <View style={styles.sectionContent}>
          <TimeZoneSelector
            value={formData.timeZone || 'America/Mexico_City'}
            onChange={(timezone) => {
              setFormData({ ...formData, timeZone: timezone });
            }}
            disabled={!isEditing}
          />
        </View>
      </Surface>
    </View>
  );

  const renderSchedule = () => (
    <View style={styles.tabContent}>
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="calendar-clock"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Horario de Operación</Text>
        </View>

        <View style={styles.sectionContent}>
          <BusinessHoursForm
            businessHours={formData.businessHours || []}
            isEditing={isEditing}
            onChange={(hours: CreateBusinessHoursDto[]) => {
              setFormData((prev) => ({ ...prev, businessHours: hours }));
              setBusinessHoursModified(true);
            }}
          />
        </View>
      </Surface>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>Error al cargar la configuración</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      {/* Tabs */}
      <View style={styles.header}>
        <View style={styles.tabsContainer}>
          <Pressable
            style={[styles.tab, activeTab === 'basic' && styles.tabActive]}
            onPress={() => handleTabChange('basic')}
          >
            <Icon
              source="store"
              size={20}
              color={
                activeTab === 'basic'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'basic' && styles.tabTextActive,
              ]}
            >
              Información
            </Text>
          </Pressable>

          <Pressable
            style={[styles.tab, activeTab === 'operation' && styles.tabActive]}
            onPress={() => handleTabChange('operation')}
          >
            <Icon
              source="cog"
              size={20}
              color={
                activeTab === 'operation'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'operation' && styles.tabTextActive,
              ]}
            >
              Operación
            </Text>
          </Pressable>

          <Pressable
            style={[styles.tab, activeTab === 'schedule' && styles.tabActive]}
            onPress={() => handleTabChange('schedule')}
          >
            <Icon
              source="calendar"
              size={20}
              color={
                activeTab === 'schedule'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'schedule' && styles.tabTextActive,
              ]}
            >
              Horarios
            </Text>
          </Pressable>
        </View>
      </View>

      {/* Content */}
      <KeyboardAvoidingView
        style={{ flex: 1 }}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
          keyboardShouldPersistTaps="handled"
        >
          {activeTab === 'basic' && renderBasicInfo()}
          {activeTab === 'operation' && renderOperationConfig()}
          {activeTab === 'schedule' && renderSchedule()}
        </ScrollView>
      </KeyboardAvoidingView>

      {/* Action Buttons */}
      <View style={styles.actionContainer}>
        {!isEditing ? (
          <Button
            mode="contained"
            onPress={() => {
              setIsEditing(true);
              setBusinessHoursModified(false);
            }}
            style={[
              styles.editButton,
              { backgroundColor: theme.colors.tertiary },
            ]}
            contentStyle={styles.editButtonContent}
            labelStyle={styles.editButtonLabel}
            icon="pencil"
            textColor={theme.colors.onTertiary}
          >
            Editar Configuración
          </Button>
        ) : (
          <View style={styles.editActions}>
            <Button
              mode="outlined"
              onPress={handleCancel}
              style={styles.cancelButton}
              contentStyle={styles.buttonContent}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit}
              loading={updateConfigMutation.isPending}
              disabled={updateConfigMutation.isPending}
              style={styles.saveButton}
              contentStyle={styles.buttonContent}
              icon="check"
            >
              Guardar
            </Button>
          </View>
        )}
      </View>

      {/* System Info Card */}
      {config && (
        <Surface style={styles.infoCard} elevation={1}>
          <View style={styles.infoContent}>
            <MaterialCommunityIcons
              name="information-outline"
              size={20}
              color={theme.colors.onSurfaceVariant}
            />
            <View style={styles.infoTextContainer}>
              <Text style={styles.infoTitle}>Última actualización</Text>
              <Text style={styles.infoText}>
                {new Date(config.updatedAt).toLocaleString('es-MX', {
                  dateStyle: 'medium',
                  timeStyle: 'short',
                  timeZone: config.timeZone || 'America/Mexico_City',
                })}
              </Text>
            </View>
          </View>
        </Surface>
      )}

      <ConfirmationModal
        visible={showDiscardDialog}
        title="Descartar cambios"
        message="¿Estás seguro de que deseas descartar los cambios realizados?"
        onConfirm={confirmDiscard}
        onCancel={() => {
          setShowDiscardDialog(false);
          setIsNavigatingAway(false);
          setPendingTab(null);
        }}
        confirmText="Descartar"
        cancelText="Continuar editando"
        confirmButtonColor={theme.colors.error}
      />

      {/* Modal de Área de Cobertura */}
      <Portal>
        <Dialog
          visible={showDeliveryModal}
          onDismiss={() => {
            if (!updateDeliveryAreaMutation.isPending) {
              if (isEditingDelivery) {
                setFormData({
                  ...formData,
                  deliveryCoverageArea: originalDeliveryArea,
                });
              }
              setShowDeliveryModal(false);
              setIsEditingDelivery(false);
            }
          }}
          style={styles.deliveryDialog}
        >
          <Dialog.Content style={styles.deliveryDialogContent}>
            <Surface style={styles.deliveryMapWrapper} elevation={1}>
              <View style={styles.deliveryMapContainer}>
                <WebViewDeliveryCoverageMap
                  key={`coverage-map-${isEditingDelivery}`}
                  initialPolygon={formData.deliveryCoverageArea}
                  isEditing={isEditingDelivery}
                  onChange={(polygon) =>
                    setFormData({ ...formData, deliveryCoverageArea: polygon })
                  }
                  restaurantLocation={{
                    latitude: 20.5425,
                    longitude: -102.7935,
                  }}
                />
              </View>
            </Surface>
          </Dialog.Content>
          <View style={styles.deliveryDialogActions}>
            <View style={styles.deliveryDialogButtonsContainer}>
              {!isEditingDelivery ? (
                <>
                  <Button
                    onPress={() => setShowDeliveryModal(false)}
                    mode="outlined"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.cancelButtonLabel}
                  >
                    Cerrar
                  </Button>
                  <Button
                    onPress={() => {
                      setOriginalDeliveryArea(formData.deliveryCoverageArea);
                      setIsEditingDelivery(true);
                    }}
                    icon="pencil"
                    mode="contained"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.deliveryButtonLabel}
                  >
                    Editar
                  </Button>
                </>
              ) : (
                <>
                  <Button
                    onPress={() => {
                      setFormData({
                        ...formData,
                        deliveryCoverageArea: originalDeliveryArea,
                      });
                      setIsEditingDelivery(false);
                    }}
                    mode="outlined"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.cancelButtonLabel}
                    disabled={updateDeliveryAreaMutation.isPending}
                  >
                    Cancelar
                  </Button>
                  <Button
                    onPress={async () => {
                      // Validar que haya al menos 3 puntos
                      if (
                        !formData.deliveryCoverageArea ||
                        formData.deliveryCoverageArea.length < 3
                      ) {
                        setShowAreaValidationModal(true);
                        return;
                      }

                      setIsEditingDelivery(false);
                      // Guardar el área de cobertura inmediatamente
                      await handleSaveDeliveryArea();
                      setShowDeliveryModal(false);
                    }}
                    mode="contained"
                    icon="check"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.deliveryButtonLabel}
                    loading={updateDeliveryAreaMutation.isPending}
                    disabled={updateDeliveryAreaMutation.isPending}
                  >
                    Guardar
                  </Button>
                </>
              )}
            </View>
          </View>
        </Dialog>
      </Portal>

      {/* Modal de validación de área */}
      <Portal>
        <Dialog
          visible={showAreaValidationModal}
          onDismiss={() => setShowAreaValidationModal(false)}
          style={styles.validationDialog}
        >
          <View style={styles.validationIconContainer}>
            <Surface style={styles.validationIconWrapper} elevation={0}>
              <MaterialCommunityIcons
                name="map-marker-alert"
                size={36}
                color={theme.colors.error}
              />
            </Surface>
          </View>
          <Dialog.Title style={styles.validationTitle}>
            Área incompleta
          </Dialog.Title>
          <Dialog.Content>
            <Text style={styles.validationMessage}>
              Se requieren al menos 3 puntos para definir un área de cobertura
              válida.
            </Text>
            <Text style={styles.validationHint}>
              Haz clic en el mapa para agregar más puntos o usa el botón de
              dibujar.
            </Text>
          </Dialog.Content>
          <Dialog.Actions style={styles.validationActions}>
            <Button
              onPress={() => setShowAreaValidationModal(false)}
              mode="contained"
              style={styles.validationButton}
              contentStyle={styles.validationButtonContent}
              labelStyle={styles.validationButtonLabel}
            >
              Entendido
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Modal de conflicto de horarios */}
      <Portal>
        <Dialog
          visible={showScheduleConflictModal}
          onDismiss={() => setShowScheduleConflictModal(false)}
          style={styles.validationDialog}
        >
          <View style={styles.validationIconContainer}>
            <Surface style={styles.validationIconWrapper} elevation={0}>
              <MaterialCommunityIcons
                name="clock-alert"
                size={36}
                color={theme.colors.error}
              />
            </Surface>
          </View>
          <Dialog.Title style={styles.validationTitle}>
            Conflicto de horarios
          </Dialog.Title>
          <Dialog.Content>
            <Text style={styles.validationMessage}>
              Hay conflictos en los horarios de operación. Un día no puede abrir
              antes o al mismo tiempo que cierre el día anterior.
            </Text>
            <Text style={styles.validationHint}>
              Debe haber al menos 1 minuto de diferencia entre el cierre y la
              siguiente apertura. Revisa los horarios marcados con advertencia.
            </Text>
          </Dialog.Content>
          <Dialog.Actions style={styles.validationActions}>
            <Button
              onPress={() => setShowScheduleConflictModal(false)}
              mode="contained"
              style={styles.validationButton}
              contentStyle={styles.validationButtonContent}
              labelStyle={styles.validationButtonLabel}
            >
              Revisar horarios
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: any,
  width: number,
  height: number,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: responsive.spacing(theme.spacing.xl),
    },
    deliveryContent: {
      flex: 1,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.xl),
    },
    errorText: {
      fontSize: responsive.fontSize(16),
      color: theme.colors.error,
      textAlign: 'center',
    },
    // Header y Tabs
    header: {
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    tabsContainer: {
      flexDirection: 'row',
      height: responsive.scaleHeight(48),
    },
    tab: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.xs),
    },
    tabActive: {
      borderBottomWidth: 2,
      borderBottomColor: theme.colors.primary,
    },
    tabText: {
      fontSize: responsive.fontSize(14),
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    tabTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    tabContent: {
      padding: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.m),
    },
    // Section styles
    section: {
      borderRadius: 16,
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surface,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.m),
    },
    sectionTitle: {
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginLeft: responsive.spacing(theme.spacing.s),
    },
    sectionContent: {
      gap: responsive.spacing(theme.spacing.m),
    },
    deliveryInfo: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
    // Input styles
    input: {
      backgroundColor: theme.colors.surface,
    },
    inputOutline: {
      borderRadius: 12,
    },
    row: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.s),
    },
    halfInput: {
      flex: 1,
    },
    // Status styles
    statusRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    statusInfo: {
      flex: 1,
      marginRight: responsive.spacing(theme.spacing.m),
    },
    statusLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs),
    },
    statusDescription: {
      fontSize: responsive.fontSize(14),
      color: theme.colors.onSurfaceVariant,
    },
    // Time input styles
    timeInputContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    timeIconWrapper: {
      width: responsive.scaleWidth(40),
      height: responsive.scaleWidth(40),
      borderRadius: responsive.scaleWidth(20),
      backgroundColor: theme.colors.surfaceVariant,
      justifyContent: 'center',
      alignItems: 'center',
    },
    timeInput: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    infoChip: {
      marginTop: responsive.spacing(theme.spacing.xs),
    },
    chip: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    chipText: {
      fontSize: responsive.fontSize(12),
    },
    // Delivery styles
    deliveryInfo: {
      marginTop: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
    },
    // Action styles
    actionContainer: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      marginTop: responsive.spacing(theme.spacing.l),
      alignItems: 'center',
    },
    editButton: {
      borderRadius: 12,
      elevation: 2,
      alignSelf: 'stretch',
    },
    editButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    editButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
    editActions: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.l),
      width: '100%',
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    cancelButton: {
      flex: 1,
      borderRadius: 12,
    },
    saveButton: {
      flex: 1,
      borderRadius: 12,
      elevation: 2,
    },
    buttonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    // Info Card styles
    infoCard: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      marginTop: responsive.spacing(theme.spacing.m),
      borderRadius: 12,
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
    },
    infoContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    infoTextContainer: {
      flex: 1,
    },
    infoTitle: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
      opacity: 0.7,
    },
    infoText: {
      fontSize: responsive.fontSize(14),
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    deliveryContainer: {
      flex: 1,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    deliveryActions: {
      position: 'absolute',
      bottom: 16,
      right: 16,
    },
    deliveryFab: {
      position: 'absolute',
      bottom: 0,
      right: 0,
    },
    deliveryFabSmall: {
      position: 'absolute',
      right: 0,
    },
    mapSection: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
    // Estilos para el botón de área de cobertura
    deliveryButtonContainer: {
      marginTop: responsive.spacing(theme.spacing.l),
      alignItems: 'center',
    },
    deliveryButton: {
      borderRadius: 12,
      width: '100%',
    },
    deliveryButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    deliveryButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
    },
    deliveryStatusText: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.spacing(theme.spacing.xs),
      fontStyle: 'italic',
    },
    deliveryStatusWarning: {
      color: theme.colors.error,
    },
    // Estilos para el modal
    deliveryDialog: {
      maxWidth: width * 0.95,
      width: width * 0.95,
      maxHeight: height * 0.9,
      alignSelf: 'center',
      borderRadius: 20,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 12,
    },
    deliveryDialogContent: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
    deliveryMapWrapper: {
      borderRadius: 12,
      padding: responsive.spacing(theme.spacing.xs),
      backgroundColor: theme.colors.surfaceVariant,
    },
    deliveryMapContainer: {
      height: height * 0.65,
      width: '100%',
      borderRadius: 8,
      overflow: 'hidden',
    },
    deliveryDialogActions: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.l),
    },
    deliveryDialogButtonsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.m),
    },
    deliveryDialogButton: {
      flex: 1,
      borderRadius: 12,
    },
    deliveryButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    deliveryButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
    cancelButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    // Estilos para el modal de validación
    validationDialog: {
      borderRadius: 24,
      backgroundColor: theme.colors.surface,
      maxWidth: 340,
      width: '85%',
      alignSelf: 'center',
      paddingVertical: 0,
    },
    validationIconContainer: {
      alignItems: 'center',
      marginTop: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
    validationIconWrapper: {
      width: responsive.scaleWidth(64),
      height: responsive.scaleWidth(64),
      borderRadius: responsive.scaleWidth(32),
      backgroundColor: theme.colors.errorContainer,
      justifyContent: 'center',
      alignItems: 'center',
    },
    validationTitle: {
      textAlign: 'center',
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    validationMessage: {
      textAlign: 'center',
      fontSize: responsive.fontSize(15),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.s),
      lineHeight: responsive.fontSize(21),
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    validationHint: {
      textAlign: 'center',
      fontSize: responsive.fontSize(13),
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      lineHeight: responsive.fontSize(18),
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    validationActions: {
      paddingBottom: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.xs),
    },
    validationButton: {
      borderRadius: 12,
      minWidth: 120,
    },
    validationButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    validationButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
  });

export default RestaurantConfigScreen;

================
File: app/app.config.js
================
export default {
  expo: {
    name: "CloudBite",
    slug: "cloudbite",
    version: "1.0.0",
    orientation: "default",
    icon: "./assets/icon.png",
    userInterfaceStyle: "automatic",
    splash: {
      image: "./assets/splash.png",
      resizeMode: "cover",
      backgroundColor: "#ffffff"
    },
    web: {
      favicon: "./assets/favicon.png"
    },
    assetBundlePatterns: [
      "**/*"
    ],
    extra: {
      eas: {
        projectId: "556b2536-af8e-4b1c-8013-20f9e876d57e"
      }
    },
    plugins: [
      "expo-speech-recognition",
      "expo-audio",
      [
        "expo-build-properties",
        {
          android: {
            compileSdkVersion: 35,
            targetSdkVersion: 34,
            buildToolsVersion: "35.0.0",
            usesCleartextTraffic: process.env.EAS_BUILD_PROFILE !== 'production',
            newArchEnabled: true
          },
          ios: {
            newArchEnabled: true
          }
        }
      ],
      "./plugins/withCustomIcons"
    ],
    android: {
      permissions: [
        "android.permission.INTERNET",
        "android.permission.ACCESS_NETWORK_STATE",
        "android.permission.ACCESS_WIFI_STATE",
        "android.permission.RECORD_AUDIO",
        "android.permission.MODIFY_AUDIO_SETTINGS"
      ],
      package: "com.viefmoon.cloudbite",
      icon: "./assets/icon.png",
      supportsTablet: true,
      googleServicesFile: process.env.GOOGLE_SERVICES_JSON ? "./google-services.json" : undefined,
      networkSecurityConfig: "./android/app/src/main/res/xml/network_security_config.xml"
    },
    ios: {
      infoPlist: {
        NSSpeechRecognitionUsageDescription: "Allow CloudBite to use speech recognition for voice orders.",
        NSMicrophoneUsageDescription: "Allow CloudBite to use the microphone for voice orders."
      },
      bundleIdentifier: "com.viefmoon.cloudbite",
      supportsTablet: true,
      icon: "./assets/icon.png"
    },
    web: {
      favicon: "./assets/favicon.png"
    },
    owner: "viefmoon"
  }
};

================
File: app/src/app/services/apiClient.ts
================
import axios, {
  AxiosError,
  InternalAxiosRequestConfig,
  AxiosResponse,
} from 'axios';
import { create as createApisauceInstance } from 'apisauce';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useAuthStore } from '../store/authStore';
import { ApiError } from '../lib/errors';
import axiosRetry from 'axios-retry';
import { discoveryService } from './discoveryService';
import { useSnackbarStore } from '../store/snackbarStore';
import { API_PATHS } from '../constants/apiPaths';
import { certificateValidator } from './certificateValidator';

const REFRESH_TOKEN_KEY = 'refresh_token';

// Variables para manejar la inicialización del cliente
let axiosInstance: any = null;
let apiClient: any = null;
let initializationPromise: Promise<void> | null = null;
let currentBaseURL: string | null = null;

// Función para inicializar el cliente con la URL descubierta
async function initializeApiClient(providedUrl?: string) {
  // Si ya está inicializado con la misma URL, no reinicializar
  if (apiClient && currentBaseURL && currentBaseURL === providedUrl) {
    return;
  }

  if (initializationPromise && !providedUrl) {
    return initializationPromise;
  }

  initializationPromise = (async () => {
    try {
      const baseURL = providedUrl || (await discoveryService.getApiUrl());

      if (!baseURL) {
        throw new Error('No se pudo obtener la URL del servidor');
      }

      currentBaseURL = baseURL;

      // Validar la seguridad de la conexión
      try {
        certificateValidator.validateConnection(baseURL);
      } catch (error) {
        console.warn('Advertencia de seguridad:', error.message);
      }

      // Obtener configuración de seguridad
      const securityConfig = certificateValidator.getAxiosSecurityConfig();

      // Crear instancia de Axios
      axiosInstance = axios.create({
        baseURL,
        headers: {
          'Cache-Control': 'no-cache',
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        timeout: 5000, // Reducido a 5 segundos por defecto
        ...securityConfig, // Aplicar configuración de seguridad
      });

      // Configurar retry automático
      configureAxiosRetry();

      // Configurar interceptores
      configureInterceptors();

      // Crear cliente Apisauce
      apiClient = createApisauceInstance({
        baseURL,
        axiosInstance: axiosInstance as any,
      });

      // Agregar transforms
      addResponseTransforms(apiClient);
    } catch (error) {
      // Limpiar la promesa para permitir reintentos manuales
      initializationPromise = null;
      throw error;
    }
  })();

  return initializationPromise;
}

// Función para obtener el cliente inicializado
export async function getApiClient(url?: string) {
  if (!apiClient || (url && url !== currentBaseURL)) {
    await initializeApiClient(url);
  }
  return apiClient;
}

// Función para obtener el axios instance directamente (para debugging)
export async function getAxiosInstance() {
  if (!axiosInstance) {
    await initializeApiClient();
  }
  return axiosInstance;
}

// Función para reinicializar el cliente (útil si cambia la IP del servidor)
export async function reinitializeApiClient(url?: string) {
  axiosInstance = null;
  apiClient = null;
  initializationPromise = null;
  currentBaseURL = null;
  cachedClient = null; // Limpiar también el cache del wrapper
  return initializeApiClient(url);
}

// Configurar retry automático para errores de red
function configureAxiosRetry() {
  if (!axiosInstance) return;

  axiosRetry(axiosInstance, {
    retries: 1,
    retryDelay: () => 500,
    retryCondition: (error: AxiosError) => {
      if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
        return false;
      }
      return (
        error.code === 'ENOTFOUND' ||
        error.code === 'ECONNREFUSED' ||
        error.code === 'ECONNRESET'
      );
    },
    shouldResetTimeout: false,
  });
}

// --- Lógica de Refresco de Token (igual que antes) ---
let isRefreshing = false;
let failedQueue: Array<{
  resolve: (token: string) => void;
  reject: (error: Error) => void;
}> = [];

const processQueue = (error: Error | null, token: string | null = null) => {
  const queue = [...failedQueue];
  failedQueue = [];

  queue.forEach((prom) => {
    error ? prom.reject(error) : prom.resolve(token!);
  });
};

async function refreshToken(): Promise<string> {
  try {
    const [currentRefreshToken, authStore] = await Promise.all([
      EncryptedStorage.getItem(REFRESH_TOKEN_KEY),
      Promise.resolve(useAuthStore.getState()),
    ]);

    if (!currentRefreshToken) {
      throw new Error('No refresh token available.');
    }

    // Obtener base URL del cliente o discovery
    const baseURL =
      axiosInstance?.defaults?.baseURL ||
      (await discoveryService.getApiUrl()) ||
      (await initializeApiClient().then(
        () => axiosInstance?.defaults?.baseURL,
      ));

    if (!baseURL) {
      throw new Error('No base URL available');
    }

    const { data } = await axios.post<{ token: string; refreshToken?: string }>(
      `${baseURL}${API_PATHS.AUTH_REFRESH}`,
      {},
      { headers: { Authorization: `Bearer ${currentRefreshToken}` } },
    );

    // Actualizar tokens en paralelo si es necesario
    const updates = [authStore.setAccessToken(data.token)];

    if (data.refreshToken && data.refreshToken !== currentRefreshToken) {
      updates.push(authStore.setRefreshToken(data.refreshToken));
    }

    await Promise.all(updates);

    return data.token;
  } catch (error: any) {
    if (error.response?.status === 401 || error.response?.status === 404) {
      await useAuthStore.getState().logout();
    }
    throw error;
  }
}

// --- Interceptores de Axios ---
function configureInterceptors() {
  if (!axiosInstance) return;

  // 1. Interceptor de Peticiones
  axiosInstance.interceptors.request.use(
    (config: InternalAxiosRequestConfig) => {
      const accessToken = useAuthStore.getState().accessToken;
      if (accessToken && config.url !== API_PATHS.AUTH_REFRESH) {
        config.headers['Authorization'] = `Bearer ${accessToken}`;
      }

      // Configurar timeouts específicos según el tipo de operación
      // Si ya se especificó un timeout en la config, respetarlo
      if (!config.timeout) {
        const timeouts = {
          get: 5000,
          post: config.url?.includes('/files/upload') ? 30000 : 5000,
          put: 5000,
          patch: 5000,
          delete: 5000,
        };

        config.timeout =
          timeouts[config.method as keyof typeof timeouts] || 5000;
      }

      return config;
    },
    (error: any) => Promise.reject(error),
  );

  // 2. Interceptor de Respuestas
  axiosInstance.interceptors.response.use(
    (response: AxiosResponse) => response, // Pasa respuestas exitosas
    async (error: AxiosError) => {
      // Maneja errores
      const originalRequest = error.config as InternalAxiosRequestConfig & {
        _retry?: boolean;
        _skipQueue?: boolean;
      };

      // Detectar errores de red
      if (!error.response) {
        // Crear error más específico
        let specificError: Error;

        if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
          // Error de timeout - el servidor existe pero no responde
          specificError = new Error('El servidor no responde');
          (specificError as any).code = 'SERVER_TIMEOUT';
        } else if (error.code === 'ECONNREFUSED') {
          // Conexión rechazada - el servidor está apagado
          specificError = new Error('El servidor está apagado o no accesible');
          (specificError as any).code = 'SERVER_DOWN';
        } else if (
          error.message === 'Network Error' ||
          error.code === 'ENETUNREACH'
        ) {
          // Error de red - no se puede alcanzar el servidor
          specificError = new Error(
            'No se pudo encontrar el servidor CloudBite',
          );
          (specificError as any).code = 'SERVER_NOT_FOUND';
        } else {
          // Error genérico de red
          specificError = new Error('Error de conexión de red');
          (specificError as any).code = 'NETWORK_ERROR';
        }

        // Asignar el error específico al error original
        (error as any).specificError = specificError;

        // No mostrar snackbar aquí, dejar que el componente lo maneje
        return Promise.reject(error);
      }

      // No intentar renovar si:
      // 1. No es un error 401
      // 2. Es la propia petición de refresh
      // 3. Es la petición de verificación de token (/auth/me)
      // 4. Ya se intentó renovar antes
      if (
        error.response?.status !== 401 ||
        originalRequest.url === API_PATHS.AUTH_REFRESH ||
        originalRequest.url?.includes('/auth/me') ||
        originalRequest._retry
      ) {
        const apiError = ApiError.fromAxiosError(error);
        return Promise.reject(apiError);
      }

      // --- Manejo del 401 ---
      if (isRefreshing) {
        // Encolar petición para reintentar después del refresh
        return new Promise((resolve, reject) => {
          failedQueue.push({
            resolve: async (token) => {
              originalRequest.headers['Authorization'] = `Bearer ${token}`;
              originalRequest._retry = true;
              try {
                const response = await axiosInstance(originalRequest);
                resolve(response);
              } catch (err) {
                reject(ApiError.fromAxiosError(err as AxiosError));
              }
            },
            reject,
          });
        });
      }

      isRefreshing = true;
      originalRequest._retry = true;

      try {
        const newAccessToken = await refreshToken();
        processQueue(null, newAccessToken);
        originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;
        return axiosInstance(originalRequest);
      } catch (refreshError: any) {
        processQueue(refreshError, null);

        // Si el error es 401 o 404, ya se habrá cerrado la sesión en refreshToken()
        // Solo necesitamos rechazar la promesa
        return Promise.reject(ApiError.fromRefreshError(refreshError));
      } finally {
        isRefreshing = false;
      }
    },
  );
}

// Función para agregar transforms al cliente
function addResponseTransforms(client: any) {
  client.addResponseTransform((response: any) => {
    // Solo mostrar snackbar para errores de red reales (no errores HTTP)
    const isNetworkError =
      response.problem === 'NETWORK_ERROR' ||
      response.problem === 'TIMEOUT_ERROR' ||
      response.problem === 'CONNECTION_ERROR';

    const isHttpError = response.status && response.status >= 400;

    if (isNetworkError && !isHttpError) {
      const showSnackbar = useSnackbarStore.getState().showSnackbar;

      let errorMessage = 'Sin conexión al servidor';
      const method =
        response.config?.method || response.originalError?.config?.method;

      if (method === 'POST') {
        errorMessage = 'No se puede guardar sin conexión';
      } else if (method === 'PUT') {
        errorMessage = 'No se puede actualizar sin conexión';
      } else if (method === 'DELETE') {
        errorMessage = 'No se puede eliminar sin conexión';
      } else if (method === 'GET') {
        errorMessage = 'No se pueden cargar los datos sin conexión';
      }

      // Usar setTimeout para asegurar que se muestre
      setTimeout(() => {
        showSnackbar({
          message: errorMessage,
          type: 'error',
          duration: 5000,
        });
      }, 100);
    }

    // Si la respuesta no es ok y tenemos un error original del interceptor
    if (!response.ok && response.originalError instanceof ApiError) {
      // Preservar el ApiError original
      (response as any).apiError = response.originalError;
    }
  });
}

// Cache para el cliente inicializado
let cachedClient: any = null;

// Función wrapper que devuelve el cliente real
const createApiClientWrapper = () => {
  const handler = {
    get(_target: any, prop: string) {
      // Retornar una función que inicializa el cliente cuando se necesita
      return async (...args: any[]) => {
        if (!cachedClient) {
          cachedClient = await getApiClient();
        }

        const method = cachedClient[prop];
        if (typeof method === 'function') {
          return method.apply(cachedClient, args);
        }

        return method;
      };
    },
  };

  return new Proxy({}, handler);
};

const apiClientProxy = createApiClientWrapper();

export default apiClientProxy;

================
File: app/src/modules/kitchen/components/OrderCard.tsx
================
import React, { useRef, useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Animated,
  Pressable,
  Vibration,
  Platform,
} from 'react-native';
import { Card, Text, Divider, Surface, IconButton } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import {
  KitchenOrder,
  OrderType,
  PreparationStatus,
  PreparationScreenStatus,
} from '../types/kitchen.types';
import { OrderItemRow } from './OrderItemRow';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Swipeable } from 'react-native-gesture-handler';
import { OrderHistoryModal } from '@/modules/shared/components/OrderHistoryModal';
import { useMarkItemPrepared } from '../hooks/useKitchenOrders';

interface OrderCardProps {
  order: KitchenOrder;
  onStartPreparation?: (orderId: string) => void;
  onCancelPreparation?: (orderId: string) => void;
  onCompletePreparation?: (orderId: string) => void;
  onSwipeStart?: () => void;
  onSwipeEnd?: () => void;
}

export const OrderCard: React.FC<OrderCardProps> = ({
  order,
  onStartPreparation,
  onCancelPreparation,
  onCompletePreparation,
  onSwipeStart,
  onSwipeEnd,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = createStyles(responsive, theme);
  const [isSwipeable, setIsSwipeable] = React.useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const swipeableRef = useRef<Swipeable>(null);
  const [isPressing, setIsPressing] = useState(false);
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const animatedValue = useRef(new Animated.Value(0)).current;
  const markItemPrepared = useMarkItemPrepared();

  const getOrderTypeColor = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return theme.colors.error;
      case OrderType.TAKE_AWAY:
        return '#00ACC1'; // Cyan/Turquesa
      case OrderType.DINE_IN:
        return theme.colors.primary;
      default:
        return theme.colors.surface;
    }
  };

  const getOrderTypeLabel = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return 'DOMICILIO';
      case OrderType.TAKE_AWAY:
        return 'PARA LLEVAR';
      case OrderType.DINE_IN:
        return 'MESA';
      default:
        return '';
    }
  };

  const getOrderTypeBackgroundColor = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return '#FFEBEE'; // Rojo muy claro
      case OrderType.TAKE_AWAY:
        return '#E0F2F1'; // Cyan/Turquesa muy claro
      case OrderType.DINE_IN:
        return '#E3F2FD'; // Azul muy claro
      default:
        return theme.colors.surfaceVariant;
    }
  };

  const getOrderTypeTextColor = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return '#C62828'; // Rojo oscuro
      case OrderType.TAKE_AWAY:
        return '#00838F'; // Cyan/Turquesa oscuro
      case OrderType.DINE_IN:
        return '#1565C0'; // Azul oscuro
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getScreenStatusColor = (status: PreparationScreenStatus) => {
    switch (status) {
      case PreparationScreenStatus.READY:
        return theme.colors.success;
      case PreparationScreenStatus.IN_PREPARATION:
        return '#FF6B35';
      default:
        return '#9C27B0';
    }
  };

  const getOrderTypeIcon = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return 'moped'; // O 'bike', 'motorbike'
      case OrderType.TAKE_AWAY:
        return 'shopping-outline'; // O 'bag-checked', 'package-variant'
      case OrderType.DINE_IN:
        return 'silverware-fork-knife'; // O 'food', 'table-chair'
      default:
        return 'help-circle-outline';
    }
  };

  // Calcular el estado de preparación basado en myScreenStatus
  const getOrderPreparationStatus = () => {
    // Primero verificar si hay items
    if (!order.items || order.items.length === 0) {
      return {
        label: 'Sin items',
        color: '#E0E0E0',
        textColor: '#424242',
        borderColor: '#BDBDBD',
      };
    }

    const myItems = order.items.filter((item) => item.belongsToMyScreen);
    if (myItems.length === 0) {
      return {
        label: 'Sin items asignados',
        color: '#E0E0E0',
        textColor: '#424242',
        borderColor: '#BDBDBD',
      };
    }

    // Usar el estado de mi pantalla específica
    switch (order.myScreenStatus) {
      case PreparationScreenStatus.READY:
        return {
          label: 'Lista',
          color: '#4CAF50', // Verde
          textColor: '#FFFFFF',
          borderColor: null,
        };

      case PreparationScreenStatus.IN_PREPARATION:
        return {
          label: 'En preparación',
          color: '#FF6B35', // Naranja
          textColor: '#FFFFFF',
          borderColor: null,
        };

      case PreparationScreenStatus.PENDING:
      default:
        return {
          label: 'Pendiente',
          color: '#9C27B0', // Púrpura
          textColor: '#FFFFFF',
          borderColor: null,
        };
    }
  };

  const hasOrderDetails = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return !!order.deliveryAddress;
      case OrderType.TAKE_AWAY:
        return !!order.receiptName;
      case OrderType.DINE_IN:
        return !!(order.areaName || order.tableName);
      default:
        return false;
    }
  };

  const orderStatus = getOrderPreparationStatus();

  // Verificar si mi pantalla está en preparación
  const isOrderInPreparation =
    order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION;

  const handleToggleItemPrepared = (itemId: string, currentStatus: boolean) => {
    markItemPrepared.mutate({
      itemId,
      isPrepared: !currentStatus,
    });
  };

  // Determinar qué acciones de swipe están disponibles basado en myScreenStatus
  const getSwipeActions = () => {
    const rightAction = (() => {
      // Solo permitir iniciar preparación si mi pantalla está PENDING
      if (order.myScreenStatus === PreparationScreenStatus.PENDING) {
        return {
          type: 'start',
          color: '#FF6B35', // Naranja
          textColor: '#FFFFFF',
          icon: 'chef-hat',
          text: 'En Preparación',
        };
      }
      return null;
    })();

    const leftAction = (() => {
      // Permitir regresar si mi pantalla está en preparación o lista
      if (
        order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION ||
        order.myScreenStatus === PreparationScreenStatus.READY
      ) {
        return {
          type: 'cancel',
          color: '#9C27B0', // Púrpura
          textColor: '#FFFFFF',
          icon: 'arrow-left',
          text: 'Regresar',
        };
      }
      return null;
    })();

    return { rightAction, leftAction };
  };

  const swipeActions = getSwipeActions();

  // Verificar si la orden puede hacer swipe
  React.useEffect(() => {
    setIsSwipeable(!!swipeActions.rightAction || !!swipeActions.leftAction);
  }, [swipeActions.rightAction, swipeActions.leftAction]);

  // Renderizar las acciones del swipe hacia la derecha (lo que aparece detrás)
  const renderRightActions = () => {
    if (!swipeActions.rightAction) return null;

    return (
      <View
        style={[
          styles.swipeAction,
          { backgroundColor: swipeActions.rightAction.color },
        ]}
      >
        <Icon
          name={swipeActions.rightAction.icon}
          size={24}
          color={swipeActions.rightAction.textColor}
        />
        <Text
          style={[
            styles.swipeText,
            { color: swipeActions.rightAction.textColor },
          ]}
        >
          {swipeActions.rightAction.text}
        </Text>
      </View>
    );
  };

  // Renderizar las acciones del swipe hacia la izquierda
  const renderLeftActions = () => {
    if (!swipeActions.leftAction) return null;

    return (
      <View
        style={[
          styles.swipeAction,
          { backgroundColor: swipeActions.leftAction.color },
        ]}
      >
        <Text
          style={[
            styles.swipeText,
            { color: swipeActions.leftAction.textColor },
          ]}
        >
          {swipeActions.leftAction.text}
        </Text>
        <Icon
          name={swipeActions.leftAction.icon}
          size={24}
          color={swipeActions.leftAction.textColor}
        />
      </View>
    );
  };

  // Verificar si la orden puede ser marcada como lista con long press
  const canMarkAsReady = () => {
    // Solo se puede marcar como lista si mi pantalla está en preparación
    return (
      order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION &&
      onCompletePreparation
    );
  };

  // Verificar si la orden puede regresar a en preparación con long press
  const canReturnToInProgress = () => {
    // Solo permitir long press para regresar si mi pantalla está EN PREPARACIÓN (no READY)
    // Si está READY, debe usar el swipe
    return (
      order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION &&
      onCancelPreparation
    );
  };

  // Manejar el inicio del long press
  const handlePressIn = () => {
    const canComplete = canMarkAsReady();
    const canReturn = canReturnToInProgress();

    if (!canComplete && !canReturn) return;

    // Limpiar cualquier timer o animación previa
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      if ((longPressTimer.current as any).interval) {
        clearInterval((longPressTimer.current as any).interval);
      }
      longPressTimer.current = null;
    }

    // Detener cualquier animación en curso y resetear
    animatedValue.stopAnimation();
    animatedValue.setValue(0);

    // Vibración suave al iniciar
    Vibration.vibrate(10);

    setIsPressing(true);

    // Iniciar animación
    Animated.timing(animatedValue, {
      toValue: 1,
      duration: 2000,
      useNativeDriver: false,
    }).start();

    // Timer para completar después de 2 segundos
    longPressTimer.current = setTimeout(() => {
      // Vibración de éxito
      Vibration.vibrate([0, 50, 100, 50]);

      if (canComplete && onCompletePreparation) {
        onCompletePreparation(order.id);
      } else if (canReturn && onCancelPreparation) {
        onCancelPreparation(order.id);
      }

      setIsPressing(false);
      Animated.timing(animatedValue, {
        toValue: 0,
        duration: 200,
        useNativeDriver: false,
      }).start();
    }, 2000);
  };

  // Manejar cuando se suelta la presión
  const handlePressOut = () => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }

    setIsPressing(false);

    // Detener cualquier animación en curso
    animatedValue.stopAnimation();

    // Resetear el valor animado a 0
    animatedValue.setValue(0);
  };

  // Limpiar timer al desmontar
  useEffect(() => {
    return () => {
      if (longPressTimer.current) {
        clearTimeout(longPressTimer.current);
      }
    };
  }, []);

  // Manejar cuando se completa el swipe hacia la derecha
  const handleRightSwipeComplete = () => {
    if (!swipeActions.rightAction) return;

    switch (swipeActions.rightAction.type) {
      case 'start':
        if (onStartPreparation) onStartPreparation(order.id);
        break;
    }

    // Cerrar el swipeable después de ejecutar la acción
    swipeableRef.current?.close();
  };

  // Manejar cuando se completa el swipe hacia la izquierda
  const handleLeftSwipeComplete = () => {
    if (!swipeActions.leftAction) return;

    if (swipeActions.leftAction.type === 'cancel') {
      if (onCancelPreparation) onCancelPreparation(order.id);
    }

    // Cerrar el swipeable después de ejecutar la acción
    swipeableRef.current?.close();
  };

  return (
    <Surface
      style={[styles.card, { backgroundColor: theme.colors.surface }]}
      elevation={1}
    >
      <View style={styles.cardContent}>
        {/* Header */}
        {isSwipeable ? (
          <Swipeable
            ref={swipeableRef}
            renderRightActions={renderRightActions}
            renderLeftActions={renderLeftActions}
            onSwipeableWillOpen={() => onSwipeStart && onSwipeStart()}
            onSwipeableWillClose={() => onSwipeEnd && onSwipeEnd()}
            onSwipeableRightOpen={handleRightSwipeComplete}
            onSwipeableLeftOpen={handleLeftSwipeComplete}
            overshootRight={false}
            overshootLeft={false}
            friction={1.2}
            rightThreshold={50}
            leftThreshold={50}
            activationDistance={15}
          >
            <Pressable
              onPressIn={handlePressIn}
              onPressOut={handlePressOut}
              delayLongPress={0}
            >
              <View
                style={[
                  styles.header,
                  styles.headerSwipeable,
                  { backgroundColor: getOrderTypeColor() },
                ]}
              >
                <View style={styles.headerLeft}>
                  <Text style={[styles.orderNumber, styles.headerText]}>
                    #{order.shiftOrderNumber}
                  </Text>
                  {hasOrderDetails() && (
                    <Text
                      style={[styles.headerDetails, styles.headerText]}
                      numberOfLines={2}
                    >
                      {(() => {
                        switch (order.orderType) {
                          case OrderType.DELIVERY:
                            return `📍 ${order.deliveryAddress}${order.deliveryPhone ? `\n📱 ${order.deliveryPhone}` : ''}`;
                          case OrderType.TAKE_AWAY:
                            return `👤 ${order.receiptName}${order.customerPhone ? `\n📱 ${order.customerPhone}` : ''}`;
                          case OrderType.DINE_IN:
                            return `🪑 ${order.areaName} - ${order.tableName}`;
                          default:
                            return '';
                        }
                      })()}
                    </Text>
                  )}

                  {/* Badge de WhatsApp */}
                  {order.isFromWhatsApp && (
                    <View style={styles.whatsappBadgeContainer}>
                      <View style={styles.whatsappBadge}>
                        <Icon
                          source="whatsapp"
                          size={12}
                          color={theme.colors.surface}
                        />
                      </View>
                    </View>
                  )}
                </View>
                <View style={[styles.headerRight, styles.headerRightSwipeable]}>
                  <View style={[styles.typeChip, styles.typeChipSwipeable]}>
                    <Icon
                      name={getOrderTypeIcon()}
                      size={responsive.isWeb ? 18 : 14}
                      color={theme.colors.surface}
                      style={styles.typeChipIcon}
                    />
                    <Text style={[styles.typeChipText, styles.headerText]}>
                      {getOrderTypeLabel()}
                    </Text>
                  </View>
                  <View
                    style={[
                      styles.statusChip,
                      styles.statusChipSwipeable,
                      {
                        backgroundColor: orderStatus.color,
                        borderWidth:
                          orderStatus.label === 'En progreso' ? 1 : 0,
                        borderColor: theme.colors.outline,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.statusChipText,
                        {
                          color:
                            orderStatus.label === 'En progreso'
                              ? theme.colors.onSurface
                              : theme.colors.surface,
                        },
                      ]}
                    >
                      {orderStatus.label}
                    </Text>
                  </View>
                  <Text style={[styles.headerTime, styles.headerText]}>
                    {format(new Date(order.createdAt), 'HH:mm', { locale: es })}
                  </Text>
                </View>
              </View>
              {/* Indicador de progreso del long press */}
              {isPressing && (canMarkAsReady() || canReturnToInProgress()) && (
                <View style={styles.progressBarContainer}>
                  <Animated.View
                    style={[
                      styles.progressBar,
                      {
                        width: animatedValue.interpolate({
                          inputRange: [0, 1],
                          outputRange: ['0%', '100%'],
                        }),
                        backgroundColor: canMarkAsReady()
                          ? theme.colors.success
                          : '#FF6B35',
                      },
                    ]}
                  />
                </View>
              )}
            </Pressable>
          </Swipeable>
        ) : (
          <View
            style={[
              styles.header,
              styles.headerSwipeable,
              { backgroundColor: getOrderTypeColor() },
            ]}
          >
            <View style={styles.headerLeft}>
              <Text style={[styles.orderNumber, styles.headerText]}>
                #{order.shiftOrderNumber}
              </Text>
              {hasOrderDetails() && (
                <Text
                  style={[styles.headerDetails, styles.headerText]}
                  numberOfLines={2}
                >
                  {(() => {
                    switch (order.orderType) {
                      case OrderType.DELIVERY:
                        return `📍 ${order.deliveryAddress}${order.deliveryPhone ? `\n📱 ${order.deliveryPhone}` : ''}`;
                      case OrderType.TAKE_AWAY:
                        return `👤 ${order.receiptName}${order.customerPhone ? `\n📱 ${order.customerPhone}` : ''}`;
                      case OrderType.DINE_IN:
                        return `🪑 ${order.areaName} - ${order.tableName}`;
                      default:
                        return '';
                    }
                  })()}
                </Text>
              )}
            </View>
            <View style={[styles.headerRight, styles.headerRightNormal]}>
              <View
                style={[
                  styles.typeChip,
                  styles.typeChipNormal,
                  { backgroundColor: getOrderTypeBackgroundColor() },
                ]}
              >
                <Icon
                  name={getOrderTypeIcon()}
                  size={responsive.isTablet ? 13 : 14}
                  color={getOrderTypeTextColor()}
                  style={styles.typeChipIcon}
                />
                <Text
                  style={[
                    styles.typeChipText,
                    { color: getOrderTypeTextColor() },
                  ]}
                >
                  {getOrderTypeLabel()}
                </Text>
              </View>
              <View
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: orderStatus.color,
                    borderWidth: orderStatus.borderColor ? 1 : 0,
                    borderColor: orderStatus.borderColor || 'transparent',
                    marginBottom: 2,
                  },
                ]}
              >
                <Text
                  style={[
                    styles.statusChipText,
                    { color: orderStatus.textColor },
                  ]}
                >
                  {orderStatus.label}
                </Text>
              </View>
              <Text
                style={[styles.headerTime, { color: theme.colors.surface }]}
              >
                {format(new Date(order.createdAt), 'HH:mm', { locale: es })}
              </Text>
            </View>
          </View>
        )}

        {/* Order Notes - Solo mostrar si hay notas */}
        {order.orderNotes && (
          <>
            <View
              style={[
                styles.details,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <Text
                variant="bodyMedium"
                style={[styles.notes, { color: theme.colors.onErrorContainer }]}
              >
                📝 {order.orderNotes}
              </Text>
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {/* Screen Statuses - Mostrar el estado de otras pantallas */}
        {order.screenStatuses && order.screenStatuses.length > 1 && (
          <>
            <View
              style={[
                styles.screenStatusContainer,
                {
                  backgroundColor: theme.colors.surfaceVariant,
                  paddingVertical: 8,
                  paddingHorizontal: 8,
                },
              ]}
            >
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                <View style={[styles.screenStatusList, { gap: 8 }]}>
                  {order.screenStatuses.map((screenStatus) => (
                    <View
                      key={screenStatus.screenId}
                      style={[
                        styles.screenStatusItem,
                        {
                          backgroundColor: (() => {
                            switch (screenStatus.status) {
                              case PreparationScreenStatus.READY:
                                return '#4CAF50';
                              case PreparationScreenStatus.IN_PREPARATION:
                                return '#FF6B35';
                              default:
                                return '#9C27B0';
                            }
                          })(),
                        },
                      ]}
                    >
                      <Text style={styles.screenStatusText}>
                        {screenStatus.screenName}
                      </Text>
                    </View>
                  ))}
                </View>
              </ScrollView>
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {/* Items */}
        <View style={styles.itemsWrapper}>
          {order.items && order.items.length > 0 ? (
            <ScrollView
              style={styles.itemsContainer}
              showsVerticalScrollIndicator={true}
              nestedScrollEnabled={true}
            >
              {(() => {
                // Separar items en grupos
                const myScreenItems = order.items
                  .map((item, originalIndex) => ({ item, originalIndex }))
                  .filter(({ item }) => item.belongsToMyScreen);

                const otherScreenItems = order.items
                  .map((item, originalIndex) => ({ item, originalIndex }))
                  .filter(({ item }) => !item.belongsToMyScreen);

                // Ordenar items de mi pantalla
                const sortedMyScreenItems = myScreenItems.sort((a, b) => {
                  // Los items preparados mantienen su posición relativa
                  const aIsPrepared =
                    a.item.preparationStatus === PreparationStatus.READY;
                  const bIsPrepared =
                    b.item.preparationStatus === PreparationStatus.READY;

                  // Si ambos están preparados o ambos no lo están, mantener orden original
                  if (aIsPrepared === bIsPrepared) {
                    return a.originalIndex - b.originalIndex;
                  }

                  // Si uno está preparado y el otro no, mantener el orden original
                  return a.originalIndex - b.originalIndex;
                });

                // Mantener orden original para items de otras pantallas
                const sortedOtherScreenItems = otherScreenItems;

                // Combinar: primero los de mi pantalla, luego los de otras
                return [...sortedMyScreenItems, ...sortedOtherScreenItems];
              })().map(({ item }, index) => (
                <OrderItemRow
                  key={`${item.id}-${index}`}
                  item={item}
                  onTogglePrepared={handleToggleItemPrepared}
                  isOrderInPreparation={isOrderInPreparation}
                />
              ))}
            </ScrollView>
          ) : (
            <View style={styles.emptyItemsContainer}>
              <Text variant="bodyLarge" style={styles.emptyItemsText}>
                No hay productos para mostrar
              </Text>
            </View>
          )}
        </View>

        {/* Botón flotante con posicionamiento fijo */}
        <View style={styles.floatingButtonContainer}>
          <IconButton
            icon="file-document-multiple-outline"
            size={responsive.isWeb ? 32 : 28}
            iconColor={theme.colors.surface}
            style={[
              styles.floatingButton,
              {
                backgroundColor: theme.colors.primary,
                width: responsive.isWeb ? 56 : 48,
                height: responsive.isWeb ? 56 : 48,
                borderRadius: responsive.isWeb ? 28 : 24,
              },
            ]}
            onPress={() => setShowHistory(true)}
          />
        </View>
      </View>

      {/* Modal de historial */}
      <OrderHistoryModal
        visible={showHistory}
        onDismiss={() => setShowHistory(false)}
        orderId={order.id}
        orderNumber={order.shiftOrderNumber}
        orderData={order}
      />
    </Surface>
  );
};

// Crear estilos responsive
const createStyles = (responsive: any, theme: any) =>
  StyleSheet.create({
    card: {
      width: '100%',
      height: '100%',
      maxHeight:
        responsive.height -
        responsive.dimensions.headerHeight -
        responsive.spacing.s,
      borderRadius: theme.roundness / 2,
      borderWidth: 0.5,
      borderColor: 'rgba(0,0,0,0.05)',
    },
    cardContent: {
      flex: 1,
      display: 'flex',
      flexDirection: 'column',
      position: 'relative',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.l
        : responsive.spacing.m,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.s,
      borderTopLeftRadius: theme.roundness,
      borderTopRightRadius: theme.roundness,
      minHeight: responsive.isWeb
        ? 80
        : responsive.getResponsiveDimension(50, 60),
    },
    headerLeft: {
      flex: 1,
      flexDirection: 'column',
      gap: responsive.spacing.xxxs,
    },
    headerTopRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing.xs,
    },
    headerDetails: {
      fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 12 : 13,
      lineHeight: responsive.isWeb ? 22 : responsive.isTablet ? 16 : 18,
      opacity: 0.95,
      marginTop: responsive.spacing.xxxs,
      fontWeight: '500',
    },
    headerRight: {
      alignItems: 'flex-end',
      gap: responsive.spacing.xs,
      marginLeft: responsive.spacing.xs,
    },
    orderNumber: {
      fontWeight: 'bold',
      fontSize: responsive.isWeb ? 24 : responsive.isTablet ? 18 : 20,
      lineHeight: responsive.isWeb ? 32 : responsive.isTablet ? 24 : 28,
    },
    typeChip: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.s,
      paddingVertical: responsive.isWeb ? 6 : 4,
      minHeight: responsive.isWeb ? 36 : 28,
      borderRadius: theme.roundness / 2,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      alignSelf: 'flex-end',
      marginBottom: responsive.spacing.xxxs,
    },
    typeChipText: {
      fontSize: responsive.isWeb ? 14 : responsive.isTablet ? 11 : 12,
      fontWeight: '700',
      letterSpacing: 0.4,
      textAlign: 'center',
      textAlignVertical: 'center',
      lineHeight: responsive.isTablet ? 16 : 18,
      includeFontPadding: false,
    },
    headerTime: {
      fontWeight: '500',
      fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 12 : 13,
    },
    statusChip: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.xs,
      paddingVertical: responsive.isWeb ? 6 : 4,
      minHeight: responsive.isWeb ? 36 : 28,
      borderRadius: theme.roundness / 2,
      alignItems: 'center',
      justifyContent: 'center',
      alignSelf: 'flex-end',
      marginBottom: responsive.spacing.xxxs,
    },
    statusChipText: {
      fontSize: responsive.isWeb ? 15 : responsive.isTablet ? 12 : 13,
      fontWeight: '600',
      letterSpacing: 0.3,
      textAlign: 'center',
      textAlignVertical: 'center',
      lineHeight: responsive.isWeb ? 22 : responsive.isTablet ? 18 : 20,
      includeFontPadding: false,
    },
    details: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.s,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.s
        : responsive.spacing.xs,
    },
    detailText: {
      marginBottom: 0,
      fontSize: responsive.isWeb ? 15 : responsive.isTablet ? 11 : 12,
      lineHeight: responsive.isWeb ? 20 : responsive.isTablet ? 16 : 14,
    },
    notesContainer: {
      marginTop: responsive.spacing.xxs,
      padding: responsive.spacing.xxs,
      borderRadius: theme.roundness / 2,
    },
    notes: {
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 11 : 12,
      lineHeight: responsive.isTablet ? 16 : 14,
    },
    itemsWrapper: {
      flex: 1,
      minHeight: responsive.isTablet ? 100 : 60,
    },
    itemsContainer: {
      flex: 1,
    },
    emptyItemsContainer: {
      padding: responsive.spacing.s,
      alignItems: 'center',
      justifyContent: 'center',
      minHeight: responsive.getResponsiveDimension(60, 80),
    },
    swipeAction: {
      width: 120,
      height: '100%',
      justifyContent: 'center',
      alignItems: 'center',
      flexDirection: 'row',
      gap: responsive.spacing.xs,
      paddingHorizontal: responsive.spacing.s,
    },
    swipeText: {
      fontWeight: 'bold',
      fontSize: responsive.fontSize.s,
    },
    screenStatusContainer: {
      paddingVertical: responsive.spacing.s,
      paddingHorizontal: responsive.spacing.s,
      paddingRight: responsive.spacing.m,
    },
    screenStatusList: {
      flexDirection: 'row',
      gap: responsive.spacing.s,
      paddingHorizontal: responsive.spacing.xs,
    },
    screenStatusItem: {
      paddingHorizontal: responsive.spacing.s,
      paddingVertical: responsive.spacing.xs,
      borderRadius: theme.roundness / 2,
      minHeight: 24,
      justifyContent: 'center',
    },
    screenStatusText: {
      fontSize: responsive.fontSize.xs,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    whatsappBadgeContainer: {
      marginTop: 4,
      alignItems: 'flex-start',
    },
    whatsappBadge: {
      width: 24,
      height: 24,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
      elevation: 2,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.2,
      shadowRadius: 2,
      backgroundColor: '#25D366',
    },
    // Estilos adicionales para eliminar inline styles
    headerText: {
      color: theme.colors.surface,
    },
    headerSwipeable: {
      paddingHorizontal: responsive.spacing.s,
    },
    headerRightSwipeable: {
      marginLeft: responsive.spacing.xs,
    },
    headerRightNormal: {
      marginLeft: responsive.spacing.m,
    },
    typeChipSwipeable: {
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      marginTop: 2,
      marginBottom: 3,
    },
    typeChipNormal: {
      marginTop: 2,
      marginBottom: 3,
    },
    typeChipIcon: {
      marginRight: 4,
    },
    statusChipSwipeable: {
      marginBottom: 2,
    },
    statusChipNormal: {
      marginBottom: 2,
    },
    progressBarContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      height: 20,
      backgroundColor: 'rgba(0, 0, 0, 0.2)',
      overflow: 'hidden',
    },
    progressBar: {
      height: '100%',
    },
    notesContainer: {
      backgroundColor: theme.colors.errorContainer,
    },
    notesText: {
      color: theme.colors.onErrorContainer,
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 0.5,
    },
    screenStatusContainerStyle: {
      backgroundColor: theme.colors.surfaceVariant,
      paddingVertical: responsive.spacing.s,
      paddingHorizontal: responsive.spacing.s,
    },
    emptyItemsText: {
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
    },
    floatingButtonContainer: {
      position: 'absolute',
      bottom: 10,
      right: 10,
      width: 48,
      height: 48,
    },
    floatingButton: {
      elevation: 6,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 3 },
      shadowOpacity: 0.3,
      shadowRadius: 4.65,
      margin: 0,
      opacity: 0.7,
    },
  });

================
File: app/src/app/navigation/AppDrawerNavigator.tsx
================
import React from 'react';
import {
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  View,
  Text,
} from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { MenuStackNavigator } from '../../modules/menu/navigation/MenuStackNavigator';
import ModifiersStackNavigator from '../../modules/modifiers/navigation/ModifiersStackNavigator';
import PreparationScreensStackNavigator from '../../modules/preparationScreens/navigation/PreparationScreensStackNavigator';
import AreasTablesStackNavigator from '../../modules/areasTables/navigation/AreasTablesStackNavigator';
import OrdersStackNavigator from './OrdersStackNavigator';
import PrintersStackNavigator from '../../modules/printers/navigation/PrintersStackNavigator';
import { ReceiptsStackNavigator } from '../../modules/receipts/navigation/ReceiptsStackNavigator';
import { AvailabilityStackNavigator } from '../../modules/availability/navigation/AvailabilityStackNavigator';
import { OrderFinalizationStackNavigator } from '../../modules/orderFinalization/navigation/OrderFinalizationStackNavigator';
import { RestaurantConfigStackNavigator } from '../../modules/restaurantConfig/navigation/RestaurantConfigStackNavigator';
import { CustomersStackNavigator } from '../../modules/customers/navigation/CustomersStackNavigator';
import { PizzaCustomizationsStackNavigator } from '../../modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator';
import { SyncStackNavigator } from '../../modules/sync/navigation/SyncStackNavigator';
import { UsersStackNavigator } from '../../modules/users/navigation/UsersStackNavigator';
import KitchenNavigator from '../../modules/kitchen/navigation/KitchenNavigator';
import { ShiftAuditStackNavigator } from '../../modules/shiftAudit/navigation/ShiftAuditStackNavigator';
import { SettingsStackNavigator } from '../../modules/settings/navigation/SettingsStackNavigator';
import { ServerSettingsScreen } from '../../modules/settings/screens/ServerSettingsScreen';

import { CustomDrawerContent } from './components/CustomDrawerContent';
import { useAppTheme } from '../styles/theme';
import { Icon, Surface, Checkbox, Text as PaperText } from 'react-native-paper';
import type { AppDrawerParamList } from './types';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { ShiftIndicator } from '../components/ShiftIndicator';
import { useAuthStore } from '../store/authStore';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderType } from '../../modules/kitchen/types/kitchen.types';

const Drawer = createDrawerNavigator<AppDrawerParamList>();

export function AppDrawerNavigator() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const kitchenScreenName =
    user?.preparationScreen?.name || 'Pantalla de Preparación';

  // Obtener el texto del filtro activo
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderType.DINE_IN:
        return ' • Mesa';
      case OrderType.TAKE_AWAY:
        return ' • Llevar';
      case OrderType.DELIVERY:
        return ' • Domicilio';
      default:
        return '';
    }
  };

  // Ruta inicial por defecto (no-kitchen users)
  const initialRouteName = 'OrdersStack';

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        drawerButtonContainer: {
          width: 56,
          height: 56,
          justifyContent: 'center',
          alignItems: 'center',
          marginLeft: 0,
          borderRadius: 28,
        },
        headerStyle: {
          backgroundColor: theme.colors.primary,
          height: responsive.dimensions.headerHeight,
          elevation: 2,
        },
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
          color: theme.colors.onPrimary,
          fontWeight: 'bold',
          fontSize: responsive.isTablet ? 20 : 22,
        },
        drawerStyle: {
          backgroundColor: theme.colors.surface,
          width: responsive.dimensions.drawerWidth,
          borderTopRightRadius: theme.roundness * 2,
          borderBottomRightRadius: theme.roundness * 2,
        },
      }),
    [theme, responsive],
  );

  return (
    <>
      <StatusBar
        backgroundColor={theme.colors.primary}
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
      />
      <Drawer.Navigator
        initialRouteName={initialRouteName}
        drawerContent={(props) => <CustomDrawerContent {...props} />}
        screenOptions={({ navigation, route }) => ({
          headerStyle: styles.headerStyle,
          headerTintColor: theme.colors.onPrimary,
          headerTitleStyle: styles.headerTitleStyle,
          drawerStyle: styles.drawerStyle,
          drawerActiveTintColor: theme.colors.primary,
          drawerInactiveTintColor: theme.colors.onSurfaceVariant,
          drawerLabelStyle: {
            ...theme.fonts.labelLarge,
            fontSize: responsive.fontSize.m,
          },
          drawerItemStyle: {
            marginVertical: responsive.spacing.xxs,
            borderRadius: theme.roundness * 2,
            paddingVertical: responsive.spacing.xxs,
            paddingHorizontal: responsive.spacing.xs,
          },
          headerShown: true,
          drawerType: 'front',
          drawerPosition: 'left',
          headerShadowVisible: false,
          swipeEdgeWidth: 100,
          headerLeft: () => (
            <TouchableOpacity
              style={styles.drawerButtonContainer}
              onPress={() => navigation.openDrawer()}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Icon source="menu" size={32} color={theme.colors.onPrimary} />
            </TouchableOpacity>
          ),
          headerTitle: ({ children }) => {
            let title = '';
            switch (children) {
              case 'MenuStack':
                title = 'Menú';
                break;
              case 'ModifiersStack':
                title = 'Modificadores';
                break;
              case 'PreparationScreensStack':
                title = 'Pantallas Preparación';
                break;
              case 'AreasTablesStack':
                title = 'Áreas y Mesas';
                break;
              case 'OrdersStack':
                title = 'Órdenes';
                break;
              case 'PrintersStack':
                title = 'Impresoras';
                break;
              case 'ReceiptsStack':
                title = 'Recibos';
                break;
              case 'AvailabilityStack':
                title = 'Disponibilidad';
                break;
              case 'OrderFinalizationStack':
                title = 'Finalización';
                break;
              case 'RestaurantConfigStack':
                title = 'Configuración';
                break;
              case 'CustomersStack':
                title = 'Clientes';
                break;
              case 'PizzaCustomizationsStack':
                title = 'Personalizaciones';
                break;
              case 'SyncStack':
                title = 'Sincronización';
                break;
              case 'UsersStack':
                title = 'Usuarios';
                break;
              case 'KitchenStack':
                title =
                  kitchenScreenName +
                  (filters.orderType ? getFilterText() : '');
                break;
              case 'ShiftAuditStack':
                title = 'Historial de Turnos';
                break;
              case 'ServerSettings':
                title = 'Configuración del Servidor';
                break;
              default:
                title = children?.toString() || '';
            }
            return (
              <Surface
                elevation={0}
                style={{
                  backgroundColor: 'transparent',
                }}
              >
                <Text style={styles.headerTitleStyle}>{title}</Text>
              </Surface>
            );
          },
          headerRight: () => {
            // Solo mostrar ShiftIndicator en las secciones de ventas
            const salesScreens = [
              'OrdersStack',
              'ReceiptsStack',
              'OrderFinalizationStack',
            ];
            const showShiftIndicator = salesScreens.includes(route.name);

            return (
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {showShiftIndicator && <ShiftIndicator />}
                <ConnectionIndicator />
              </View>
            );
          },
        })}
      >
        <Drawer.Screen
          name="OrdersStack"
          component={OrdersStackNavigator}
          options={{
            title: 'Órdenes',
            drawerIcon: ({ color }) => (
              <Icon
                source="clipboard-list-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ReceiptsStack"
          component={ReceiptsStackNavigator}
          options={{
            title: 'Recibos',
            drawerIcon: ({ color }) => (
              <Icon
                source="receipt"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="OrderFinalizationStack"
          component={OrderFinalizationStackNavigator}
          options={{
            title: 'Finalización',
            drawerIcon: ({ color }) => (
              <Icon
                source="clipboard-check-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="MenuStack"
          component={MenuStackNavigator}
          options={{
            title: 'Menú',
            drawerIcon: ({ color }) => (
              <Icon
                source="menu"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="AvailabilityStack"
          component={AvailabilityStackNavigator}
          options={{
            title: 'Disponibilidad',
            drawerIcon: ({ color }) => (
              <Icon
                source="eye-off-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ModifiersStack"
          component={ModifiersStackNavigator}
          options={{
            title: 'Modificadores',
            drawerIcon: ({ color }) => (
              <Icon
                source="tune"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="PizzaCustomizationsStack"
          component={PizzaCustomizationsStackNavigator}
          options={{
            title: 'Gestión de Pizzas',
            drawerIcon: ({ color }) => (
              <Icon
                source="pizza"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="PreparationScreensStack"
          component={PreparationScreensStackNavigator}
          options={{
            title: 'Pantallas Preparación',
            drawerIcon: ({ color }) => (
              <Icon
                source="monitor-dashboard"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="AreasTablesStack"
          component={AreasTablesStackNavigator}
          options={{
            title: 'Áreas y Mesas',
            drawerIcon: ({ color }) => (
              <Icon
                source="map-marker-radius-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />

        <Drawer.Screen
          name="PrintersStack"
          component={PrintersStackNavigator}
          options={{
            title: 'Impresoras',
            drawerIcon: ({ color }) => (
              <Icon
                source="printer"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="RestaurantConfigStack"
          component={RestaurantConfigStackNavigator}
          options={{
            title: 'Configuración',
            drawerIcon: ({ color }) => (
              <Icon
                source="cog-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="CustomersStack"
          component={CustomersStackNavigator}
          options={{
            title: 'Clientes',
            drawerIcon: ({ color }) => (
              <Icon
                source="account-group-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="SyncStack"
          component={SyncStackNavigator}
          options={{
            title: 'Sincronización',
            drawerIcon: ({ color }) => (
              <Icon
                source="sync"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="UsersStack"
          component={UsersStackNavigator}
          options={{
            title: 'Usuarios',
            drawerIcon: ({ color }) => (
              <Icon
                source="account-multiple"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ShiftAuditStack"
          component={ShiftAuditStackNavigator}
          options={{
            title: 'Historial de Turnos',
            drawerIcon: ({ color }) => (
              <Icon
                source="history"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="KitchenStack"
          component={KitchenNavigator}
          options={{
            title: kitchenScreenName,
            drawerIcon: ({ color }) => (
              <Icon
                source="chef-hat"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
            headerRight: () => (
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {/* Checkbox para mostrar/ocultar ordenes listas */}
                <TouchableOpacity
                  style={{
                    flexDirection: 'row',
                    alignItems: 'center',
                    paddingHorizontal: 12,
                    paddingVertical: 8,
                    marginRight: 8,
                    backgroundColor: filters.showPrepared
                      ? 'rgba(255,255,255,0.2)'
                      : 'transparent',
                    borderRadius: 20,
                  }}
                  onPress={() =>
                    setFilters({
                      ...filters,
                      showPrepared: !filters.showPrepared,
                    })
                  }
                >
                  <Checkbox
                    status={filters.showPrepared ? 'checked' : 'unchecked'}
                    onPress={() =>
                      setFilters({
                        ...filters,
                        showPrepared: !filters.showPrepared,
                      })
                    }
                    color={theme.colors.onPrimary}
                    uncheckedColor={theme.colors.onPrimary}
                  />
                  <PaperText
                    style={{
                      color: theme.colors.onPrimary,
                      fontSize: 14,
                      marginLeft: 4,
                      fontWeight: filters.showPrepared ? 'bold' : 'normal',
                    }}
                  >
                    Mostrar Listas
                  </PaperText>
                </TouchableOpacity>
                <KitchenFilterButton />
                <ConnectionIndicator />
              </View>
            ),
          }}
        />
        <Drawer.Screen
          name="ServerSettings"
          component={ServerSettingsScreen}
          options={{
            title: 'Configuración del Servidor',
            drawerItemStyle: { display: 'none' }, // Oculto del drawer, solo accesible desde el botón
          }}
        />
      </Drawer.Navigator>
    </>
  );
}

================
File: app/src/modules/receipts/screens/ReceiptsScreen.tsx
================
import React, { useState, useCallback, useMemo } from 'react';
import {
  View,
  FlatList,
  RefreshControl,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import {
  Text,
  Searchbar,
  Chip,
  Surface,
  ActivityIndicator,
  Menu,
  IconButton,
  Divider,
  Badge,
  Icon,
} from 'react-native-paper';
import OrderSummaryCard from '@/modules/shared/components/OrderSummaryCard';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useReceipts, useRecoverOrder } from '../hooks/useReceiptsQueries';
import type { Receipt, ReceiptList } from '../types/receipt.types';
import { getPaymentStatus } from '@/app/utils/orderFormatters';
import { receiptService } from '../services/receiptService';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import EmptyState from '@/app/components/common/EmptyState';
import { ReceiptDetailsModal } from '../components/ReceiptDetailsModal';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { DatePickerModal } from 'react-native-paper-dates';
import { OrderTypeEnum } from '@/modules/orders/types/orders.types';
import { formatOrderTypeShort } from '@/app/utils/orderFormatters';

type StatusFilter = 'all' | 'COMPLETED' | 'CANCELLED';

export const ReceiptsScreen: React.FC = () => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  // Estados para filtros
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [startDate, setStartDate] = useState<Date | undefined>(undefined);
  const [endDate, setEndDate] = useState<Date | undefined>(undefined);
  const [showDateRangePicker, setShowDateRangePicker] = useState(false);
  const [showFilterMenu, setShowFilterMenu] = useState(false);

  // Estado para el modal de detalle
  const [selectedReceipt, setSelectedReceipt] = useState<Receipt | null>(null);
  const [showDetailModal, setShowDetailModal] = useState(false);

  // Estado para recuperación de orden
  const [orderToRecover, setOrderToRecover] = useState<any>(null);
  const [showRecoverConfirm, setShowRecoverConfirm] = useState(false);

  // Mutation para recuperar orden
  const recoverOrderMutation = useRecoverOrder();

  // Preparar filtros para la query
  const filters = useMemo(() => {
    const baseFilters: any = {};

    if (startDate) {
      baseFilters.startDate = startDate.toISOString();
    }

    if (endDate) {
      baseFilters.endDate = endDate.toISOString();
    }

    return baseFilters;
  }, [startDate, endDate]);

  // Query para obtener recibos
  const {
    data: allReceipts,
    isLoading,
    refetch,
    isRefetching,
  } = useReceipts(filters);

  // Recargar automáticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('receipts');

  // Filtrar recibos localmente
  const receipts = useMemo(() => {
    if (!allReceipts) return [];

    let filtered = [...allReceipts];

    // Filtro por estado
    if (statusFilter !== 'all') {
      filtered = filtered.filter(
        (receipt) => receipt.orderStatus === statusFilter,
      );
    }

    // Filtro por búsqueda
    if (searchQuery.trim()) {
      const search = searchQuery.toLowerCase().trim();
      filtered = filtered.filter((receipt) => {
        // Buscar por número de orden
        if (receipt.shiftOrderNumber.toString().includes(search)) return true;

        // Buscar en información de entrega
        if (receipt.deliveryInfo) {
          const { recipientName, recipientPhone, fullAddress } =
            receipt.deliveryInfo;
          if (recipientName?.toLowerCase().includes(search)) return true;
          if (recipientPhone?.includes(search)) return true;
          if (fullAddress?.toLowerCase().includes(search)) return true;
        }

        // Buscar en notas
        if (receipt.notes?.toLowerCase().includes(search)) return true;

        return false;
      });
    }

    return filtered;
  }, [allReceipts, statusFilter, searchQuery]);

  // Handlers
  const handleReceiptPress = useCallback((receipt: ReceiptList) => {
    receiptService.getReceiptById(receipt.id).then((fullOrder) => {
      setSelectedReceipt(fullOrder);
      setShowDetailModal(true);
    });
  }, []);

  const handleClearFilters = useCallback(() => {
    setSearchQuery('');
    setStatusFilter('all');
    setStartDate(undefined);
    setEndDate(undefined);
  }, []);

  const handleRecoverPress = useCallback((receipt: ReceiptList) => {
    receiptService.getReceiptById(receipt.id).then((fullOrder) => {
      setOrderToRecover(fullOrder as any);
      setShowRecoverConfirm(true);
    });
  }, []);

  const handleConfirmRecover = useCallback(async () => {
    if (!orderToRecover) return;

    try {
      await recoverOrderMutation.mutateAsync(orderToRecover.id);
      setShowRecoverConfirm(false);
      setOrderToRecover(null);
    } catch (error) {
      // Error ya manejado por el mutation hook
    }
  }, [orderToRecover, recoverOrderMutation]);

  // Función específica para el color de estado en recibos
  const getReceiptStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return theme.colors.primary;
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceDisabled;
    }
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      default:
        return status;
    }
  };

  const hasActiveFilters = statusFilter !== 'all' || startDate || endDate;

  // Renderizar botón de restaurar
  const renderRestoreAction = (item: ReceiptList) => (
    <TouchableOpacity
      style={styles.restoreContainer}
      onPress={() => handleRecoverPress(item)}
      activeOpacity={0.7}
    >
      <Surface style={styles.restoreButtonSurface} elevation={2}>
        <IconButton
          icon="restore"
          size={36}
          iconColor={theme.colors.primary}
          style={styles.restoreButton}
        />
      </Surface>
    </TouchableOpacity>
  );

  // Renderizar item de recibo usando el componente compartido
  const renderReceiptItem = ({ item }: { item: ReceiptList }) => (
    <OrderSummaryCard
      item={item}
      onPress={() => handleReceiptPress(item)}
      renderActions={renderRestoreAction}
      getStatusColor={getReceiptStatusColor}
      getStatusLabel={getStatusLabel}
    />
  );

  // Renderizar lista vacía

  // Renderizar lista vacía
  const renderEmptyComponent = () => {
    if (isLoading) {
      return (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    return (
      <EmptyState
        icon="receipt"
        title="No hay recibos"
        message={
          hasActiveFilters
            ? 'No se encontraron recibos con los filtros seleccionados'
            : 'Los recibos de órdenes completadas o canceladas aparecerán aquí'
        }
        actionLabel={hasActiveFilters ? 'Limpiar filtros' : undefined}
        onAction={hasActiveFilters ? handleClearFilters : undefined}
      />
    );
  };

  return (
    <View style={styles.container}>
      {/* Header con búsqueda y filtros */}
      <Surface style={styles.header} elevation={2}>
        <Surface style={styles.shiftIndicator} elevation={1}>
          <Icon source="cash-register" size={20} color={theme.colors.primary} />
          <Text style={styles.shiftText}>Recibos del turno actual</Text>
          <View style={styles.shiftBadge}>
            <Text style={styles.shiftBadgeText}>ACTIVO</Text>
          </View>
        </Surface>
        <View style={styles.searchContainer}>
          <Searchbar
            placeholder="Buscar por nombre, teléfono o dirección..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
          />
          <View style={styles.filterButton}>
            <Menu
              visible={showFilterMenu}
              onDismiss={() => setShowFilterMenu(false)}
              anchor={
                <IconButton
                  icon="filter-variant"
                  onPress={() => setShowFilterMenu(true)}
                  style={[
                    styles.filterIconButton,
                    hasActiveFilters && styles.filterIconButtonActive,
                  ]}
                />
              }
            >
              <Menu.Item
                title="Todos los estados"
                onPress={() => {
                  setStatusFilter('all');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'all' ? 'check' : undefined}
              />
              <Menu.Item
                title="Completadas"
                onPress={() => {
                  setStatusFilter('COMPLETED');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'COMPLETED' ? 'check' : undefined}
              />
              <Menu.Item
                title="Canceladas"
                onPress={() => {
                  setStatusFilter('CANCELLED');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'CANCELLED' ? 'check' : undefined}
              />
              <Divider />
              <Menu.Item
                title={
                  startDate && endDate
                    ? `${format(startDate, 'd/M/yyyy')} - ${format(endDate, 'd/M/yyyy')}`
                    : 'Seleccionar rango de fechas'
                }
                onPress={() => {
                  setShowDateRangePicker(true);
                  setShowFilterMenu(false);
                }}
                leadingIcon="calendar-range"
              />
              {hasActiveFilters && (
                <>
                  <Divider />
                  <Menu.Item
                    title="Limpiar filtros"
                    onPress={() => {
                      handleClearFilters();
                      setShowFilterMenu(false);
                    }}
                    leadingIcon="filter-remove"
                  />
                </>
              )}
            </Menu>
            {hasActiveFilters && <Badge size={8} style={styles.filterBadge} />}
          </View>
        </View>

        {/* Chips de filtros activos */}
        {hasActiveFilters && (
          <View style={styles.activeFilters}>
            {statusFilter !== 'all' && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setStatusFilter('all')}
                style={styles.filterChip}
              >
                {statusFilter === 'COMPLETED' ? 'Completadas' : 'Canceladas'}
              </Chip>
            )}
            {startDate && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setStartDate(undefined)}
                style={styles.filterChip}
              >
                Desde: {format(startDate, 'd/M')}
              </Chip>
            )}
            {endDate && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setEndDate(undefined)}
                style={styles.filterChip}
              >
                Hasta: {format(endDate, 'd/M')}
              </Chip>
            )}
          </View>
        )}
      </Surface>

      {/* Lista de recibos */}
      <FlatList
        data={receipts}
        renderItem={renderReceiptItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={refetch}
            colors={[theme.colors.primary]}
          />
        }
        ListEmptyComponent={renderEmptyComponent}
      />

      {/* Modal de detalle */}
      <ReceiptDetailsModal
        visible={showDetailModal}
        onDismiss={() => {
          setShowDetailModal(false);
          setSelectedReceipt(null);
        }}
        receipt={selectedReceipt}
      />

      {/* Modal de confirmación de recuperación */}
      <ConfirmationModal
        visible={showRecoverConfirm}
        title="Recuperar Orden"
        message={`¿Estás seguro de que deseas recuperar la orden #${orderToRecover?.shiftOrderNumber}?\n\nLa orden se marcará como entregada y volverá a estar visible en las órdenes activas.`}
        onConfirm={handleConfirmRecover}
        onCancel={() => {
          setShowRecoverConfirm(false);
          setOrderToRecover(null);
        }}
        confirmText="Confirmar"
        cancelText="Cancelar"
      />

      {/* Date range picker */}
      <DatePickerModal
        visible={showDateRangePicker}
        mode="range"
        onDismiss={() => setShowDateRangePicker(false)}
        startDate={startDate}
        endDate={endDate}
        onConfirm={(params) => {
          setStartDate(params.startDate);
          setEndDate(params.endDate);
          setShowDateRangePicker(false);
        }}
        validRange={{
          endDate: new Date(),
        }}
        locale="es"
        saveLabel="Confirmar"
        startLabel="Desde"
        endLabel="Hasta"
        label="Seleccionar rango de fechas"
      />
    </View>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: 16,
      paddingVertical: 12,
    },
    searchContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    searchbar: {
      flex: 1,
    },
    filterButton: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
    },
    filterIconButtonActive: {
      backgroundColor: 'rgba(0, 0, 0, 0.08)',
    },
    filterBadge: {
      position: 'absolute',
      top: 8,
      right: 8,
    },
    activeFilters: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: 8,
      marginTop: 12,
    },
    filterChip: {
      height: 32,
    },
    listContent: {
      padding: theme.spacing.s,
      paddingBottom: theme.spacing.l * 2,
      flexGrow: 1,
    },
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 12,
      flexShrink: 1,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: 120,
      gap: 8,
      flexShrink: 0,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 15,
      fontWeight: '700',
    },
    orderTime: {
      fontSize: 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: 14,
      marginLeft: 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: 11,
      fontWeight: '600',
      lineHeight: 14,
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: 8,
      marginTop: 4,
    },
    restoreContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    restoreButtonSurface: {
      borderRadius: 20,
      backgroundColor: theme.colors.primaryContainer,
      overflow: 'hidden',
    },
    restoreButton: {
      margin: 0,
      width: 44,
      height: 44,
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 32,
    },
    shiftIndicator: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
      paddingVertical: 8,
      paddingHorizontal: 16,
      marginBottom: 8,
      borderRadius: 20,
      backgroundColor: theme.colors.primaryContainer,
    },
    shiftText: {
      ...theme.fonts.bodyMedium,
      color: theme.colors.onPrimaryContainer,
      fontWeight: '600',
    },
    shiftBadge: {
      backgroundColor: theme.colors.primary,
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 10,
    },
    shiftBadgeText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: theme.colors.onPrimary,
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 4,
    },
    miniPreparationText: {
      fontSize: 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginLeft: 4,
    },
    createdByText: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
      textAlign: 'right',
    },
  });

================
File: app/src/modules/orderFinalization/screens/OrderFinalizationScreen.tsx
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { FlashList } from '@shopify/flash-list';
import {
  Surface,
  Text,
  ActivityIndicator,
  Icon,
  Button,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { OrderCard } from '../components/OrderCard';
import { OrderDetailsModal } from '../components/OrderDetailsModal';
import { PrintTicketModal } from '@/modules/shared/components/PrintTicketModal';
import {
  useOrdersForFinalizationList,
  useOrderForFinalizationDetail,
} from '../hooks/useOrderFinalizationQueries';
import {
  OrderFinalizationFilter,
  OrderSelectionState,
  OrderForFinalizationList,
} from '../types/orderFinalization.types';
import EmptyState from '@/app/components/common/EmptyState';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { orderFinalizationService } from '../services/orderFinalizationService';

export const OrderFinalizationScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [filter, setFilter] = useState<OrderFinalizationFilter>('delivery');
  const [selectionState, setSelectionState] = useState<OrderSelectionState>({
    selectedOrders: new Set(),
    totalAmount: 0,
  });
  const [selectedOrderIdForDetails, setSelectedOrderIdForDetails] = useState<
    string | null
  >(null);
  const [showConfirmationModal, setShowConfirmationModal] = useState(false);
  const [isFinalizingOrders, setIsFinalizingOrders] = useState(false);
  const [showPrintModal, setShowPrintModal] = useState(false);
  const [selectedOrderForPrint, setSelectedOrderForPrint] =
    useState<OrderForFinalizationList | null>(null);

  const {
    data: orders = [],
    isLoading,
    refetch,
  } = useOrdersForFinalizationList();

  const { data: selectedOrderDetails, isLoading: isLoadingDetails } =
    useOrderForFinalizationDetail(selectedOrderIdForDetails);

  const { data: orderForPrint } = useOrderForFinalizationDetail(
    selectedOrderForPrint?.id || null,
  );

  const filteredOrders = useMemo(() => {
    if (!orders || !Array.isArray(orders)) return [];

    return orders.filter((order) => {
      switch (filter) {
        case 'delivery':
          return order.orderType === 'DELIVERY';
        case 'take_away':
          return order.orderType === 'TAKE_AWAY';
        case 'dine_in':
          return order.orderType === 'DINE_IN';
        default:
          return false;
      }
    });
  }, [orders, filter]);

  const orderCounts = useMemo(() => {
    if (!orders || !Array.isArray(orders)) {
      return {
        delivery: 0,
        take_away: 0,
        dine_in: 0,
      };
    }

    return orders.reduce(
      (counts, order) => {
        switch (order.orderType) {
          case 'DELIVERY':
            counts.delivery++;
            break;
          case 'TAKE_AWAY':
            counts.take_away++;
            break;
          case 'DINE_IN':
            counts.dine_in++;
            break;
        }
        return counts;
      },
      { delivery: 0, take_away: 0, dine_in: 0 },
    );
  }, [orders]);

  useEffect(() => {
    setSelectionState({
      selectedOrders: new Set(),
      totalAmount: 0,
    });
  }, [filter]);

  const handleToggleOrderSelection = useCallback(
    (orderId: string) => {
      if (!orders || !Array.isArray(orders)) return;

      const order = orders.find((o) => o.id === orderId);
      if (!order) return;

      setSelectionState((prevState) => {
        const newSelectedOrders = new Set(prevState.selectedOrders);
        let newTotalAmount = prevState.totalAmount;
        const orderTotal =
          typeof order.total === 'string'
            ? parseFloat(order.total)
            : order.total;
        const paymentsSummary = order.paymentsSummary;
        const paid = paymentsSummary?.totalPaid || 0;
        const pendingAmount = orderTotal - paid;

        if (newSelectedOrders.has(orderId)) {
          newSelectedOrders.delete(orderId);
          newTotalAmount -= pendingAmount;
        } else {
          newSelectedOrders.add(orderId);
          newTotalAmount += pendingAmount;
        }

        return {
          selectedOrders: newSelectedOrders,
          totalAmount: newTotalAmount,
        };
      });
    },
    [orders],
  );

  const ordersNotReady = useMemo(() => {
    if (selectionState.selectedOrders.size === 0) return [];

    const selectedOrdersList = Array.from(selectionState.selectedOrders)
      .map((id) => orders.find((o) => o.id === id))
      .filter(Boolean) as OrderForFinalizationList[];

    return selectedOrdersList.filter((order) => order.orderStatus !== 'READY');
  }, [selectionState.selectedOrders, orders]);

  const confirmationMessage = useMemo(() => {
    let message = `¿Desea finalizar ${selectionState.selectedOrders.size} ${
      selectionState.selectedOrders.size === 1 ? 'orden' : 'órdenes'
    }?\n\nTotal a cobrar: $${selectionState.totalAmount.toFixed(2)}`;

    if (ordersNotReady.length > 0) {
      message += `\n\n⚠️ ADVERTENCIA: ${ordersNotReady.length} ${
        ordersNotReady.length === 1 ? 'orden no está' : 'órdenes no están'
      } en estado "Listo"`;
    }

    return message;
  }, [selectionState, ordersNotReady]);

  const handleQuickFinalizeOrders = useCallback(() => {
    if (selectionState.selectedOrders.size === 0) return;
    setShowConfirmationModal(true);
  }, [selectionState.selectedOrders.size]);

  const handleConfirmFinalization = useCallback(async () => {
    setIsFinalizingOrders(true);
    try {
      await orderFinalizationService.quickFinalizeMultipleOrders(
        Array.from(selectionState.selectedOrders),
      );

      showSnackbar({
        message: 'Órdenes finalizadas exitosamente',
        type: 'success',
      });

      setSelectionState({
        selectedOrders: new Set(),
        totalAmount: 0,
      });

      setShowConfirmationModal(false);
      refetch();
    } catch (error) {
      showSnackbar({
        message: 'Error al finalizar las órdenes',
        type: 'error',
      });
    } finally {
      setIsFinalizingOrders(false);
    }
  }, [selectionState.selectedOrders, showSnackbar, refetch]);

  const handleShowOrderDetails = useCallback(
    (order: OrderForFinalizationList) => {
      setSelectedOrderIdForDetails(null);
      setTimeout(() => {
        setSelectedOrderIdForDetails(order.id);
      }, 50);
    },
    [],
  );

  const handlePrintPress = useCallback(() => {
    setShowPrintModal(true);
  }, []);

  const handlePrintFromList = useCallback(
    async (order: OrderForFinalizationList) => {
      setSelectedOrderForPrint(order);
      setShowPrintModal(true);
    },
    [],
  );

  const handlePrint = useCallback(
    async (printerId: string, ticketType: 'GENERAL' | 'BILLING') => {
      const orderToUse = orderForPrint || selectedOrderDetails;
      if (!orderToUse) return;

      try {
        await orderFinalizationService.printTicket(orderToUse.id, {
          printerId,
          ticketType,
        });

        showSnackbar({
          message: 'Ticket impreso exitosamente',
          type: 'success',
        });

        await refetch();
        setSelectedOrderForPrint(null);
      } catch (error) {
        showSnackbar({
          message: 'Error al imprimir el ticket',
          type: 'error',
        });
      }
    },
    [orderForPrint, selectedOrderDetails, showSnackbar, refetch],
  );

  const renderOrderCard = useCallback(
    ({ item }) => (
      <OrderCard
        order={item}
        isSelected={selectionState.selectedOrders.has(item.id)}
        onToggleSelection={handleToggleOrderSelection}
        onShowDetails={handleShowOrderDetails}
        onPrintPress={handlePrintFromList}
      />
    ),
    [
      selectionState.selectedOrders,
      handleToggleOrderSelection,
      handleShowOrderDetails,
      handlePrintFromList,
    ],
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text
          style={[styles.loadingText, { color: theme.colors.onSurfaceVariant }]}
        >
          Cargando órdenes...
        </Text>
      </View>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      edges={['top']}
    >
      <Surface style={styles.header}>
        <View style={styles.headerContent}>
          <View style={styles.filterContainer}>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'delivery' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'delivery'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('delivery')}
            >
              <Icon
                source="moped"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'delivery'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.delivery > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'delivery'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'delivery'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'delivery'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.delivery}
                  </Text>
                </View>
              )}
            </Pressable>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'take_away' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'take_away'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('take_away')}
            >
              <Icon
                source="bag-personal"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'take_away'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.take_away > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'take_away'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'take_away'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'take_away'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.take_away}
                  </Text>
                </View>
              )}
            </Pressable>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'dine_in' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'dine_in'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('dine_in')}
            >
              <Icon
                source="silverware-fork-knife"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'dine_in'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.dine_in > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'dine_in'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'dine_in'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'dine_in'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.dine_in}
                  </Text>
                </View>
              )}
            </Pressable>
          </View>
          <View style={styles.refreshButtonContainer}>
            <IconButton
              icon="refresh"
              size={responsive.isTablet ? 20 : 24}
              mode="contained"
              containerColor={theme.colors.surfaceVariant}
              iconColor={theme.colors.onSurfaceVariant}
              onPress={() => refetch()}
              style={styles.refreshButton}
            />
          </View>
        </View>
      </Surface>

      <View style={styles.content}>
        {filteredOrders.length === 0 ? (
          <EmptyState
            title="No hay órdenes para finalizar"
            description="Las órdenes aparecerán aquí cuando estén listas para finalizar"
            icon="clipboard-check-outline"
          />
        ) : (
          <FlashList
            data={filteredOrders}
            keyExtractor={(item) => item.id}
            renderItem={renderOrderCard}
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => null}
            onRefresh={refetch}
            refreshing={isLoading}
            estimatedItemSize={150}
            removeClippedSubviews={true}
          />
        )}
      </View>

      {selectionState.selectedOrders.size > 0 && (
        <Surface style={styles.floatingButton} elevation={8}>
          <Button
            mode="contained"
            onPress={handleQuickFinalizeOrders}
            style={styles.finalizeButton}
            labelStyle={styles.finalizeButtonLabel}
            disabled={isFinalizingOrders}
          >
            Finalizar ({selectionState.selectedOrders.size}) - $
            {(selectionState.totalAmount || 0).toFixed(2)}
          </Button>
        </Surface>
      )}

      <OrderDetailsModal
        visible={selectedOrderIdForDetails !== null}
        onDismiss={() => setSelectedOrderIdForDetails(null)}
        order={selectedOrderDetails}
        isLoading={isLoadingDetails}
        onPrintPress={handlePrintPress}
      />

      <PrintTicketModal
        visible={showPrintModal}
        onDismiss={() => {
          setShowPrintModal(false);
          setSelectedOrderForPrint(null);
        }}
        order={orderForPrint || selectedOrderDetails}
        onPrint={handlePrint}
      />

      <ConfirmationModal
        visible={showConfirmationModal}
        title="Finalizar Órdenes"
        message={confirmationMessage}
        onConfirm={handleConfirmFinalization}
        onCancel={() => setShowConfirmationModal(false)}
        onDismiss={() => setShowConfirmationModal(false)}
        confirmText={isFinalizingOrders ? 'Finalizando...' : 'Finalizar'}
        confirmButtonColor={
          ordersNotReady.length > 0 ? theme.colors.error : theme.colors.primary
        }
      />
    </SafeAreaView>
  );
};

const createStyles = (
  theme: typeof useAppTheme,
  responsive: typeof useResponsive,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: 0,
      paddingVertical: 0,
      backgroundColor: 'transparent',
      elevation: 0,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    filterContainer: {
      flex: 1,
      flexDirection: 'row',
      gap: 0,
    },
    refreshButtonContainer: {
      paddingHorizontal: responsive.isTablet ? 6 : 8,
    },
    refreshButton: {
      margin: 0,
    },
    filterButton: {
      flex: 1,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 0,
      elevation: 1,
      position: 'relative',
    },
    filterButtonActive: {
      elevation: 3,
    },
    countBadge: {
      position: 'absolute',
      top: responsive.isTablet ? 4 : 6,
      right: responsive.isTablet ? 4 : 6,
      minWidth: responsive.isTablet ? 18 : 22,
      height: responsive.isTablet ? 18 : 22,
      borderRadius: responsive.isTablet ? 9 : 11,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      borderWidth: 1,
      elevation: 2,
    },
    countBadgeText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '700',
    },
    floatingButton: {
      position: 'absolute',
      bottom: responsive.isTablet ? 12 : 16,
      left: responsive.isTablet ? 12 : 16,
      right: responsive.isTablet ? 12 : 16,
      borderRadius: responsive.isTablet ? 12 : 16,
      padding: responsive.isTablet ? 6 : 8,
      elevation: 8,
    },
    finalizeButton: {
      borderRadius: responsive.isTablet ? 10 : 12,
      paddingVertical: responsive.isTablet ? 3 : 4,
    },
    finalizeButtonLabel: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: '700',
      letterSpacing: 0.5,
    },
    content: {
      flex: 1,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.isTablet ? 8 : 12,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    listContent: {
      padding: responsive.isTablet ? 6 : 8,
      paddingBottom: responsive.isTablet ? 80 : 100,
    },
  });

================
File: app/src/modules/orders/components/OrderCartDetail.tsx
================
import React, { useState, useMemo, useEffect, useCallback } from 'react';
import { Portal } from 'react-native-paper';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  TouchableWithoutFeedback,
  Keyboard,
  Animated,
} from 'react-native';
import {
  Swipeable,
  GestureHandlerRootView,
} from 'react-native-gesture-handler';
import {
  Text,
  Divider,
  List,
  Button,
  RadioButton,
  HelperText,
  Menu,
  IconButton,
  Modal,
  Checkbox,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { OrderTypeEnum, type OrderType } from '../types/orders.types'; // Importar OrderTypeEnum y el tipo OrderType
import { useGetAreas } from '@/modules/areasTables/services/areaService';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';
import OrderHeader from './OrderHeader';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import ProductCustomizationModal from './ProductCustomizationModal';
import type { FullMenuProduct as Product } from '../types/orders.types';
import { useGetTablesByArea } from '@/modules/areasTables/services/tableService';
import type { Table } from '@/modules/areasTables/types/areasTables.types';
import { canRegisterPayments as checkCanRegisterPayments } from '@/app/utils/roleUtils';
import { useCartStore, CartItem, CartItemModifier } from '../stores/useCartStore'; // Importar CartItem y CartItemModifier
import { useOrderFormStore } from '../stores/useOrderFormStore';
import { useAuthStore } from '@/app/store/authStore'; // Importar authStore
import { useSnackbarStore } from '@/app/store/snackbarStore'; // Importar snackbar store
import { useGetOrderByIdQuery } from '../hooks/useOrdersQueries'; // Para cargar datos en modo edición
import { useGetOrderMenu } from '../hooks/useMenuQueries'; // Para obtener productos completos
import type { FullMenuCategory } from '../types/orders.types'; // Tipo con subcategorías
import OrderHistoryModal from '@/modules/shared/components/OrderHistoryModal'; // Modal de historial
import { OrderDetailModal } from './OrderDetailModal'; // Modal de detalles
import PaymentModal from './PaymentModal'; // Modal de pagos
import { FAB } from 'react-native-paper'; // Para el floating action button
import { AdjustmentFormModal } from './AdjustmentFormModal'; // Modal de ajustes
import type { OrderAdjustment } from '../types/adjustments.types'; // Tipo para ajustes
import { useGetPaymentsByOrderIdQuery } from '../hooks/usePaymentQueries'; // Para consultar pagos existentes
import { PaymentStatusEnum } from '../types/payment.types'; // Para verificar estados de pago
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema'; // Para personalizaciones de pizza
import { prepaymentService } from '@/modules/payments/services/prepaymentService'; // Servicio de prepagos
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';

// Importar tipos desde update-order.types.ts
import type {
  OrderItemDtoForBackend,
  OrderItemModifierDto,
} from '../types/update-order.types';

// Definir la estructura completa del payload para onConfirmOrder (y exportarla)
export interface OrderDetailsForBackend {
  userId?: string;
  orderType: OrderType;
  subtotal: number;
  total: number;
  items: OrderItemDtoForBackend[];
  tableId?: string;
  isTemporaryTable?: boolean;
  temporaryTableName?: string;
  temporaryTableAreaId?: string;
  scheduledAt?: Date;
  deliveryInfo: DeliveryInfo;
  notes?: string;
  payment?: {
    amount: number;
    method: 'CASH' | 'CARD' | 'TRANSFER';
  };
  adjustments?: {
    orderId?: string;
    name: string;
    description?: string;
    isPercentage: boolean;
    value?: number;
    amount?: number;
  }[];
  customerId?: string;
  isFromWhatsApp?: boolean;
  prepaymentId?: string;
}

// Helper para formatear el estado de la orden
const formatOrderStatus = (status: string): string => {
  switch (status) {
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En Progreso';
    case 'IN_PREPARATION':
      return 'En Preparación';
    case 'READY':
      return 'Lista';
    case 'DELIVERED':
      return 'Entregada';
    case 'COMPLETED':
      return 'Completada';
    case 'CANCELLED':
      return 'Cancelada';
    default:
      return status;
  }
};

// Helper para obtener el color del estado de preparación
const getPreparationStatusColor = (status: string | undefined, theme: any) => {
  switch (status) {
    case 'NEW':
      return '#2196F3'; // Azul brillante para nuevo
    case 'PENDING':
      return theme.colors.error; // Rojo para pendiente
    case 'IN_PROGRESS':
      return '#FFA000'; // Naranja para en progreso
    case 'READY':
      return '#4CAF50'; // Verde para listo
    case 'DELIVERED':
      return theme.colors.tertiary; // Color terciario para entregado
    case 'CANCELLED':
      return theme.colors.onSurfaceDisabled; // Gris para cancelado
    default:
      return theme.colors.onSurfaceVariant;
  }
};

// Helper para obtener el texto del estado de preparación
const getPreparationStatusText = (status: string | undefined): string => {
  switch (status) {
    case 'NEW':
      return 'Nuevo';
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En Preparación';
    case 'READY':
      return 'Listo';
    case 'DELIVERED':
      return 'Entregado';
    case 'CANCELLED':
      return 'Cancelado';
    default:
      return '';
  }
};

interface OrderCartDetailProps {
  visible: boolean;
  onConfirmOrder: (details: OrderDetailsForBackend) => void;
  onClose?: () => void;
  onEditItem?: (item: CartItem) => void;
  isEditMode?: boolean;
  orderId?: string | null;
  orderNumber?: number;
  orderDate?: Date;
  onCancelOrder?: () => void; // Función para cancelar la orden
  navigation?: any; // Prop de navegación opcional para añadir productos
  onAddProducts?: () => void; // Callback para añadir productos
  pendingProductsToAdd?: CartItem[]; // Productos pendientes de añadir
  onItemsCountChanged?: (count: number) => void; // Callback cuando cambia el conteo de items
}

// Helper para obtener el color del estado de la orden
const getOrderStatusColor = (status: string, theme: any) => {
  switch (status) {
    case 'PENDING':
      return '#FFA000'; // Orange
    case 'IN_PROGRESS':
      return theme.colors.primary;
    case 'IN_PREPARATION':
      return '#FF6B35'; // Orange más oscuro
    case 'READY':
      return '#4CAF50'; // Green
    case 'DELIVERED':
      return theme.colors.tertiary;
    case 'COMPLETED':
      return '#10B981'; // Verde más brillante
    case 'CANCELLED':
      return theme.colors.error;
    default:
      return theme.colors.onSurfaceVariant;
  }
};

const OrderCartDetail: React.FC<OrderCartDetailProps> = ({
  visible,
  onConfirmOrder,
  onClose,
  onEditItem,
  isEditMode = false,
  orderId,
  orderNumber,
  orderDate,
  onCancelOrder,
  navigation,
  onAddProducts,
  pendingProductsToAdd = [],
  onItemsCountChanged,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  // Query para cargar datos de la orden en modo edición
  const {
    data: orderData,
    isLoading: isLoadingOrder,
    isError: isErrorOrder,
    isSuccess: _isSuccessOrder,
    refetch: _refetchOrder,
  } = useGetOrderByIdQuery(orderId, {
    enabled: isEditMode && !!orderId && visible,
  });

  // Query para obtener el menú completo (para poder editar productos)
  const { data: menu } = useGetOrderMenu();

  // Query para obtener los pagos de la orden (solo en modo edición)
  const { data: payments = [] } = useGetPaymentsByOrderIdQuery(orderId || '', {
    enabled: isEditMode && !!orderId && visible,
  });

  // Estados locales para modo edición (cuando no usamos el contexto del carrito)
  const [editItems, setEditItems] = useState<CartItem[]>([]);
  const [editOrderType, setEditOrderType] = useState<OrderType>(
    OrderTypeEnum.DINE_IN,
  );
  const [editSelectedAreaId, setEditSelectedAreaId] = useState<string | null>(
    null,
  );
  const [editSelectedTableId, setEditSelectedTableId] = useState<string | null>(
    null,
  );
  const [editScheduledTime, setEditScheduledTime] = useState<Date | null>(null);
  const [editDeliveryInfo, setEditDeliveryInfo] = useState<DeliveryInfo>({});
  const [editOrderNotes, setEditOrderNotes] = useState<string>('');
  const [editAdjustments, setEditAdjustments] = useState<OrderAdjustment[]>([]);
  const [editIsTemporaryTable, setEditIsTemporaryTable] =
    useState<boolean>(false);
  const [editTemporaryTableName, setEditTemporaryTableName] =
    useState<string>('');

  // Estados para controlar si ya procesamos los productos pendientes y si los datos de la orden ya se cargaron
  const [processedPendingProductsIds, setProcessedPendingProductsIds] =
    useState<string[]>([]);
  const [orderDataLoaded, setOrderDataLoaded] = useState(false);

  // Usar los stores separados en lugar del contexto unificado
  const cartStore = useCartStore();
  const orderFormStore = useOrderFormStore();

  const cartItems = !isEditMode ? cartStore.items : [];
  const removeCartItem = !isEditMode ? cartStore.removeItem : () => {};
  const updateCartItemQuantity = !isEditMode ? cartStore.updateItemQuantity : () => {};
  const isCartVisible = !isEditMode ? cartStore.isCartVisible : false;
  
  const cartOrderType = !isEditMode ? orderFormStore.orderType : OrderTypeEnum.DINE_IN;
  const setCartOrderType = !isEditMode ? orderFormStore.setOrderType : () => {};
  const cartSelectedAreaId = !isEditMode ? orderFormStore.selectedAreaId : null;
  const setCartSelectedAreaId = !isEditMode ? orderFormStore.setSelectedAreaId : () => {};
  const cartSelectedTableId = !isEditMode ? orderFormStore.selectedTableId : null;
  const setCartSelectedTableId = !isEditMode ? orderFormStore.setSelectedTableId : () => {};
  const cartIsTemporaryTable = !isEditMode ? orderFormStore.isTemporaryTable : false;
  const setCartIsTemporaryTable = !isEditMode ? orderFormStore.setIsTemporaryTable : () => {};
  const cartTemporaryTableName = !isEditMode ? orderFormStore.temporaryTableName : '';
  const setCartTemporaryTableName = !isEditMode ? orderFormStore.setTemporaryTableName : () => {};
  const cartScheduledTime = !isEditMode ? orderFormStore.scheduledTime : null;
  const setCartScheduledTime = !isEditMode ? orderFormStore.setScheduledTime : () => {};
  const cartDeliveryInfo = !isEditMode ? orderFormStore.deliveryInfo : {};
  const setCartDeliveryInfo = orderFormStore.setDeliveryInfo;
  const cartOrderNotes = orderFormStore.orderNotes;
  const setCartOrderNotes = orderFormStore.setOrderNotes;

  // Usar valores del contexto o locales según el modo
  const items = isEditMode ? editItems : cartItems;
  const orderType = isEditMode ? editOrderType : cartOrderType;
  const selectedAreaId = isEditMode ? editSelectedAreaId : cartSelectedAreaId;
  const selectedTableId = isEditMode
    ? editSelectedTableId
    : cartSelectedTableId;
  const isTemporaryTable = isEditMode
    ? editIsTemporaryTable
    : cartIsTemporaryTable;
  const temporaryTableName = isEditMode
    ? editTemporaryTableName
    : cartTemporaryTableName;
  const scheduledTime = isEditMode ? editScheduledTime : cartScheduledTime;
  const deliveryInfo = isEditMode ? editDeliveryInfo : cartDeliveryInfo;
  const orderNotes = isEditMode ? editOrderNotes : cartOrderNotes;
  const adjustments = isEditMode ? editAdjustments : [];

  const setOrderType = isEditMode ? setEditOrderType : setCartOrderType;
  const setSelectedAreaId = isEditMode
    ? setEditSelectedAreaId
    : setCartSelectedAreaId;
  const setSelectedTableId = isEditMode
    ? setEditSelectedTableId
    : setCartSelectedTableId;
  const setIsTemporaryTable = isEditMode
    ? setEditIsTemporaryTable
    : setCartIsTemporaryTable;
  const setTemporaryTableName = isEditMode
    ? setEditTemporaryTableName
    : setCartTemporaryTableName;
  const setScheduledTime = isEditMode
    ? setEditScheduledTime
    : setCartScheduledTime;
  const setDeliveryInfo = isEditMode
    ? setEditDeliveryInfo
    : setCartDeliveryInfo;
  const setOrderNotes = isEditMode ? setEditOrderNotes : setCartOrderNotes;

  const removeItem = useCallback(
    (itemId: string) => {
      if (isEditMode) {
        const item = editItems.find((i) => i.id === itemId);
        if (!item) return;

        // Verificar el estado del item
        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          // No permitir eliminar items listos o entregados
          showSnackbar({
            message: `No se puede eliminar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,
            type: 'error',
          });
          return;
        }

        if (item.preparationStatus === 'IN_PROGRESS') {
          // Pedir confirmación para items en preparación
          setModifyingItemName(item.productName);
          setPendingModifyAction(() => () => {
            setEditItems((prev) => prev.filter((i) => i.id !== itemId));
          });
          setShowModifyInProgressConfirmation(true);
        } else {
          // Permitir eliminar items pendientes o cancelados sin confirmación
          setEditItems((prev) => prev.filter((i) => i.id !== itemId));
        }
      } else {
        removeCartItem(itemId);
      }
    },
    [isEditMode, editItems, showSnackbar, removeCartItem],
  );

  const updateItemQuantity = useCallback(
    (itemId: string, quantity: number) => {
      if (isEditMode) {
        if (quantity <= 0) {
          removeItem(itemId);
          return;
        }

        const item = editItems.find((i) => i.id === itemId);
        if (!item) return;

        // Verificar el estado del item
        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          // No permitir modificar items listos o entregados
          showSnackbar({
            message: `No se puede modificar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,
            type: 'error',
          });
          return;
        }

        const updateQuantity = () => {
          setEditItems((prev) =>
            prev.map((item) => {
              if (item.id === itemId) {
                const modifiersPrice = item.modifiers.reduce(
                  (sum, mod) => sum + Number(mod.price || 0),
                  0,
                );
                const newTotalPrice =
                  (item.unitPrice + modifiersPrice) * quantity;
                return {
                  ...item,
                  quantity,
                  totalPrice: newTotalPrice,
                };
              }
              return item;
            }),
          );
        };

        if (item.preparationStatus === 'IN_PROGRESS') {
          // Pedir confirmación para items en preparación
          setModifyingItemName(item.productName);
          setPendingModifyAction(() => updateQuantity);
          setShowModifyInProgressConfirmation(true);
        } else {
          // Permitir modificar items pendientes o cancelados sin confirmación
          updateQuantity();
        }
      } else {
        updateCartItemQuantity(itemId, quantity);
      }
    },
    [isEditMode, editItems, removeItem, showSnackbar, updateCartItemQuantity],
  );

  // Calcular totales
  const subtotal = useMemo(() => {
    if (!items || !Array.isArray(items)) return 0;
    return items.reduce((sum, item) => sum + (item.totalPrice || 0), 0);
  }, [items]);

  // Calcular total de ajustes
  const totalAdjustments = useMemo(() => {
    if (!isEditMode) return 0;
    return editAdjustments
      .filter((adj) => !adj.isDeleted)
      .reduce((sum, adj) => sum + (adj.amount || 0), 0);
  }, [isEditMode, editAdjustments]);

  const total = useMemo(() => {
    return subtotal + totalAdjustments;
  }, [subtotal, totalAdjustments]);

  const totalItemsCount = useMemo(() => {
    return items.reduce((sum, item) => sum + item.quantity, 0);
  }, [items]);

  // Calcular conteo de items existentes (no temporales)
  const existingItemsCount = useMemo(() => {
    if (!isEditMode) return 0;
    return editItems
      .filter((item) => !item.id.startsWith('new-'))
      .reduce((sum, item) => sum + item.quantity, 0);
  }, [isEditMode, editItems]);

  // Notificar cambios en el conteo de items (solo en modo edición)
  const [lastNotifiedCount, setLastNotifiedCount] = useState<number | null>(
    null,
  );

  useEffect(() => {
    if (isEditMode && onItemsCountChanged && visible && orderDataLoaded) {
      // Solo notificar si el conteo realmente cambió
      if (existingItemsCount !== lastNotifiedCount) {
        onItemsCountChanged(existingItemsCount);
        setLastNotifiedCount(existingItemsCount);
      }
    }
  }, [
    isEditMode,
    existingItemsCount,
    visible,
    orderDataLoaded,
    lastNotifiedCount,
    onItemsCountChanged,
  ]);

  // Calcular total pagado
  const totalPaid = useMemo(() => {
    if (!isEditMode || !payments) return 0;
    return payments
      .filter((p) => p.paymentStatus === PaymentStatusEnum.COMPLETED)
      .reduce((sum, payment) => sum + (Number(payment.amount) || 0), 0);
  }, [payments, isEditMode]);

  const pendingAmount = useMemo(() => {
    return Math.max(0, total - totalPaid);
  }, [total, totalPaid]);

  const { user } = useAuthStore(); // Obtener usuario autenticado
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar); // Hook para snackbar

  // Verificar si el usuario puede registrar pagos usando la utilidad centralizada
  const canRegisterPayments = useMemo(() => {
    return checkCanRegisterPayments(user);
  }, [user]);

  // Estados locales solo para UI (errores, visibilidad de menús/modales)
  const [areaMenuVisible, setAreaMenuVisible] = useState(false);
  const [tableMenuVisible, setTableMenuVisible] = useState(false);
  const [areaError, setAreaError] = useState<string | null>(null);
  const [tableError, setTableError] = useState<string | null>(null);
  const [recipientNameError, setRecipientNameError] = useState<string | null>(
    null,
  );
  const [recipientPhoneError, setRecipientPhoneError] = useState<string | null>(
    null,
  );
  const [addressError, setAddressError] = useState<string | null>(null);
  const [isTimePickerVisible, setTimePickerVisible] = useState(false);
  const [isTimeAlertVisible, setTimeAlertVisible] = useState(false);
  const [isConfirming, setIsConfirming] = useState(false);
  const [showExitConfirmation, setShowExitConfirmation] = useState(false);
  const [editingItemFromList, setEditingItemFromList] =
    useState<CartItem | null>(null);
  const [editingProduct, setEditingProduct] = useState<Product | null>(null);
  const [isModalReady, setIsModalReady] = useState(false);
  const [showOptionsMenu, setShowOptionsMenu] = useState(false);
  const [showCancelConfirmation, setShowCancelConfirmation] = useState(false);
  const [
    showModifyInProgressConfirmation,
    setShowModifyInProgressConfirmation,
  ] = useState(false);
  const [pendingModifyAction, setPendingModifyAction] = useState<
    (() => void) | null
  >(null);
  const [modifyingItemName, setModifyingItemName] = useState<string>('');
  const [showHistoryModal, setShowHistoryModal] = useState(false);
  const [showDetailModal, setShowDetailModal] = useState(false);
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [showAdjustmentModal, setShowAdjustmentModal] = useState(false);
  const [adjustmentToEdit, setAdjustmentToEdit] =
    useState<OrderAdjustment | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [paymentAmount, setPaymentAmount] = useState<string>('');
  const [_paymentMethod, _setPaymentMethod] = useState<
    'CASH' | 'CARD' | 'TRANSFER' | null
  >('CASH');
  const [prepaymentId, setPrepaymentId] = useState<string | null>(null);
  const [showPrepaymentModal, setShowPrepaymentModal] = useState(false);
  const [showDeletePrepaymentConfirm, setShowDeletePrepaymentConfirm] =
    useState(false);

  // Estado original de la orden para detectar cambios
  const [originalOrderState, setOriginalOrderState] = useState<{
    items: CartItem[];
    orderType: OrderType;
    tableId: string | null;
    isTemporaryTable: boolean;
    temporaryTableName: string;
    deliveryInfo: DeliveryInfo;
    notes: string;
    scheduledAt: Date | null;
    adjustments: OrderAdjustment[];
  } | null>(null);

  // --- Queries para Áreas y Mesas (sin cambios) ---
  const {
    data: areasData,
    isLoading: isLoadingAreas,
    error: errorAreas,
  } = useGetAreas();
  const {
    data: tablesData,
    isLoading: isLoadingTables,
    error: errorTables,
  } = useGetTablesByArea(selectedAreaId);

  // Función helper para buscar información de un modifier por su ID
  const findModifierById = useCallback(
    (modifierId: string): CartItemModifier | null => {
      if (!menu) return null;

      for (const category of menu) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            for (const modifierGroup of product.modifierGroups || []) {
              const modifier = modifierGroup.productModifiers?.find(
                (mod) => mod.id === modifierId,
              );
              if (modifier) {
                return {
                  id: modifier.id,
                  modifierGroupId: modifierGroup.id,
                  name: modifier.name,
                  price: modifier.price,
                };
              }
            }
          }
        }
      }
      return null;
    },
    [menu],
  );

  // Cargar datos de la orden cuando esté en modo edición
  useEffect(() => {
    if (!isEditMode || !orderData || !visible) return;

    // Establecer los valores del formulario
    setEditOrderType(orderData.orderType);
    setEditSelectedTableId(orderData.tableId ?? null);
    setEditScheduledTime(
      orderData.scheduledAt ? new Date(orderData.scheduledAt) : null,
    );
    // Cargar deliveryInfo
    setEditDeliveryInfo(orderData.deliveryInfo || {});
    setEditOrderNotes(orderData.notes ?? '');

    // Cargar ajustes si existen
    if (orderData.adjustments && Array.isArray(orderData.adjustments)) {
      const mappedAdjustments = orderData.adjustments.map((adj) => ({
        id: adj.id,
        name: adj.name,
        description: adj.description || '',
        isPercentage: adj.isPercentage,
        value: adj.value,
        amount: adj.amount,
        isDeleted: false, // Importante: establecer como no eliminado
        isNew: false, // No es nuevo, viene del backend
      }));
      setEditAdjustments(mappedAdjustments);
    } else {
      setEditAdjustments([]);
    }

    // Si hay una mesa, necesitamos encontrar el área
    if (orderData.tableId && orderData.table) {
      // Intentar obtener el areaId de diferentes formas
      const areaId = orderData.table.areaId || orderData.table.area?.id;
      if (areaId) {
        setEditSelectedAreaId(areaId);
      }

      // Verificar si es una mesa temporal
      if (orderData.table.isTemporary) {
        setEditIsTemporaryTable(true);
        setEditTemporaryTableName(orderData.table.name || '');
      } else {
        setEditIsTemporaryTable(false);
        setEditTemporaryTableName('');
      }
    } else {
      setEditIsTemporaryTable(false);
      setEditTemporaryTableName('');
    }

    // Mapa para agrupar items idénticos
    const groupedItemsMap = new Map<string, CartItem>();

    // Mapear y agrupar los items de la orden
    if (orderData.orderItems && Array.isArray(orderData.orderItems)) {
      orderData.orderItems.forEach((item: any) => {
        // Mapear los modificadores desde el nuevo formato (productModifiers)
        const modifiers: CartItemModifier[] = [];

        // Si vienen en el formato antiguo (item.modifiers con objetos)
        if (item.modifiers && Array.isArray(item.modifiers)) {
          item.modifiers.forEach((mod: any) => {
            modifiers.push({
              id: mod.productModifierId,
              modifierGroupId: mod.productModifier?.modifierGroupId || '',
              name: mod.productModifier?.name || 'Modificador',
              price: parseFloat(mod.price) || 0,
            });
          });
        }
        // Si vienen en el nuevo formato (item.productModifiers como array de entidades)
        else if (
          item.productModifiers &&
          Array.isArray(item.productModifiers)
        ) {
          item.productModifiers.forEach((mod: any) => {
            const modifierInfo = findModifierById(mod.id) || {
              id: mod.id,
              modifierGroupId: mod.modifierGroupId || '',
              name: mod.name || 'Modificador',
              price: parseFloat(mod.price) || 0,
            };
            modifiers.push(modifierInfo);
          });
        }

        const modifiersPrice = modifiers.reduce(
          (sum: number, mod: any) => sum + (parseFloat(mod.price) || 0),
          0,
        );
        const unitPrice = parseFloat(item.basePrice || '0');

        // Crear una clave única para agrupar items idénticos (incluye estado de preparación)
        const modifierIds = modifiers
          .map((m) => m.id)
          .sort()
          .join(',');
        const pizzaCustomizationIds = item.selectedPizzaCustomizations
          ? item.selectedPizzaCustomizations
              .map((c) => `${c.pizzaCustomizationId}-${c.half}-${c.action}`)
              .sort()
              .join(',')
          : '';
        const groupKey = `${item.productId}-${item.productVariantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;

        const existingItem = groupedItemsMap.get(groupKey);

        if (
          existingItem &&
          existingItem.preparationStatus === item.preparationStatus
        ) {
          // Si ya existe un item idéntico con el mismo estado, incrementar la cantidad
          existingItem.quantity += 1;
          existingItem.totalPrice =
            (unitPrice + modifiersPrice) * existingItem.quantity;
          existingItem.id = `${existingItem.id},${item.id}`;
        } else {
          // Si es un nuevo item, agregarlo al mapa

          const cartItem: CartItem = {
            id: item.id,
            productId: item.productId,
            productName: item.product?.name || 'Producto desconocido',
            quantity: 1, // Empezar con 1, el backend ya no envía quantity
            unitPrice,
            totalPrice: unitPrice + modifiersPrice,
            modifiers,
            variantId: item.productVariantId || undefined,
            variantName: item.productVariant?.name || undefined,
            preparationNotes: item.preparationNotes || undefined,
            preparationStatus: item.preparationStatus || 'PENDING', // Incluir estado de preparación
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined, // Incluir personalizaciones de pizza
          };
          groupedItemsMap.set(groupKey, cartItem);
        }
      });

      // Convertir el mapa a array
      const mappedItems = Array.from(groupedItemsMap.values());

      setEditItems(mappedItems);
    }

    // Marcar que los datos de la orden ya se cargaron
    setOrderDataLoaded(true);

    // Guardar el estado original de la orden para detectar cambios
    const originalItems = Array.from(groupedItemsMap.values());
    const originalAdjustments =
      orderData.adjustments?.map((adj) => ({
        id: adj.id,
        name: adj.name,
        // description: adj.description, // No existe en el tipo Adjustment
        isPercentage: adj.isPercentage,
        value: adj.value,
        amount: adj.amount,
      })) || [];

    setOriginalOrderState({
      items: originalItems,
      orderType: orderData.orderType,
      tableId: orderData.tableId ?? null,
      isTemporaryTable: orderData.table?.isTemporary || false,
      temporaryTableName: orderData.table?.isTemporary
        ? orderData.table.name
        : '',
      deliveryInfo: orderData.deliveryInfo || {},
      notes: orderData.notes ?? '',
      scheduledAt: orderData.scheduledAt
        ? new Date(orderData.scheduledAt)
        : null,
      adjustments: originalAdjustments,
    });

    // Resetear el flag de cambios no guardados
    setHasUnsavedChanges(false);
  }, [isEditMode, orderData, visible]);

  // Función para formatear las personalizaciones de pizza
  const formatPizzaCustomizations = (
    customizations: SelectedPizzaCustomization[],
  ): string => {
    if (!customizations || customizations.length === 0) return '';

    // Agrupar por mitad y tipo
    const groupedByHalf = customizations.reduce(
      (acc, curr) => {
        const half =
          curr.half === PizzaHalf.HALF_1
            ? 'HALF_1'
            : curr.half === PizzaHalf.HALF_2
              ? 'HALF_2'
              : 'FULL';

        if (!acc[half]) {
          acc[half] = {
            flavors: [],
            addedIngredients: [],
            removedIngredients: [],
          };
        }

        // Primero intentar obtener la información de pizzaCustomization si está disponible
        let name = '';
        let type = null;

        if (curr.pizzaCustomization) {
          // Si viene la información completa del backend
          name = curr.pizzaCustomization.name;
          type = curr.pizzaCustomization.type;
        } else if (menu) {
          // Si no viene la información completa, buscarla en el menú
          outer: for (const category of menu) {
            for (const subcategory of category.subcategories || []) {
              for (const product of subcategory.products || []) {
                if (product.pizzaCustomizations) {
                  const customization = product.pizzaCustomizations.find(
                    (pc) => pc.id === curr.pizzaCustomizationId,
                  );
                  if (customization) {
                    name = customization.name;
                    type = customization.type;
                    break outer;
                  }
                }
              }
            }
          }
        }

        // Si aún no tenemos el nombre, usar el ID como fallback
        if (!name) {
          name = curr.pizzaCustomizationId;
        }

        if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
          acc[half].flavors.push(name);
        } else if (
          type === 'INGREDIENT' ||
          type === CustomizationType.INGREDIENT
        ) {
          if (curr.action === CustomizationAction.ADD) {
            acc[half].addedIngredients.push(name);
          } else {
            acc[half].removedIngredients.push(name);
          }
        }

        return acc;
      },
      {} as Record<
        string,
        {
          flavors: string[];
          addedIngredients: string[];
          removedIngredients: string[];
        }
      >,
    );

    // Formatear según el tipo de pizza
    if (groupedByHalf.FULL) {
      // Pizza completa
      const parts: string[] = [];
      if (groupedByHalf.FULL.flavors.length > 0) {
        parts.push(groupedByHalf.FULL.flavors.join(', '));
      }
      if (groupedByHalf.FULL.addedIngredients.length > 0) {
        parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
      }
      if (groupedByHalf.FULL.removedIngredients.length > 0) {
        parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
      // Pizza mitad y mitad
      const formatHalf = (halfData: {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }) => {
        const parts: string[] = [];
        if (halfData.flavors.length > 0) {
          parts.push(halfData.flavors.join(', '));
        }
        if (halfData.addedIngredients.length > 0) {
          parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
        }
        if (halfData.removedIngredients.length > 0) {
          parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
        }
        return parts.join(' - ');
      };

      const half1 = groupedByHalf.HALF_1
        ? formatHalf(groupedByHalf.HALF_1)
        : '';
      const half2 = groupedByHalf.HALF_2
        ? formatHalf(groupedByHalf.HALF_2)
        : '';

      return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
    }

    return '';
  };

  // Función para agrupar items idénticos
  const groupIdenticalItems = useCallback((items: CartItem[]): CartItem[] => {
    const groupedMap = new Map<string, CartItem>();

    items.forEach((item) => {
      // Crear una clave única basada en todas las propiedades que deben ser idénticas
      const modifierIds = item.modifiers
        .map((m) => m.id)
        .sort()
        .join(',');

      // Incluir personalizaciones de pizza en la clave
      const pizzaCustomizationIds = item.selectedPizzaCustomizations
        ? item.selectedPizzaCustomizations
            .map((pc) => `${pc.pizzaCustomizationId}-${pc.half}-${pc.action}`)
            .sort()
            .join(',')
        : '';

      const groupKey = `${item.productId}-${item.variantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;

      const existingItem = groupedMap.get(groupKey);

      if (existingItem) {
        // Si ya existe un item idéntico, incrementar la cantidad
        existingItem.quantity += item.quantity;
        // Recalcular el precio total considerando modificadores
        const modifiersPrice = existingItem.modifiers.reduce(
          (sum, mod) => sum + (mod.price || 0),
          0,
        );
        existingItem.totalPrice =
          (existingItem.unitPrice + modifiersPrice) * existingItem.quantity;

        // Concatenar IDs si ambos items tienen IDs reales (no temporales)
        if (
          !existingItem.id.startsWith('new-') &&
          !item.id.startsWith('new-')
        ) {
          const existingIds = existingItem.id.split(',');
          const newIds = item.id.split(',');
          const allIds = [...new Set([...existingIds, ...newIds])];
          existingItem.id = allIds.join(',');
        }
      } else {
        // Si es nuevo, agregarlo al mapa con una copia completa
        groupedMap.set(groupKey, { ...item });
      }
    });

    const result = Array.from(groupedMap.values());

    return result;
  }, []);

  // Estado para controlar si ya procesamos los productos pendientes (declarado arriba)
  // const [processedPendingProductsIds, setProcessedPendingProductsIds] =
  //   useState<string[]>([]);
  // Estado para controlar si los datos de la orden ya se cargaron (declarado arriba)
  // const [orderDataLoaded, setOrderDataLoaded] = useState(false);

  // Manejar productos pendientes de añadir
  useEffect(() => {
    // Solo procesar cuando:
    // 1. Hay productos pendientes
    // 2. Estamos en modo edición
    // 3. El modal es visible
    // 4. Los datos de la orden ya se cargaron
    if (
      pendingProductsToAdd.length > 0 &&
      isEditMode &&
      visible &&
      orderDataLoaded
    ) {
      // Filtrar productos que no han sido procesados aún
      const unprocessedProducts = pendingProductsToAdd.filter((item) => {
        // Usar una clave única para cada producto basada en sus propiedades
        const productKey = `${item.productId}-${item.variantId || 'null'}-${JSON.stringify(item.modifiers.map((m) => m.id).sort())}-${item.preparationNotes || ''}`;
        return !processedPendingProductsIds.includes(productKey);
      });

      if (unprocessedProducts.length > 0) {
        // Marcar los nuevos productos con estado "NEW" temporal
        const newProductsWithStatus = unprocessedProducts.map((item) => ({
          ...item,
          preparationStatus: 'NEW' as const,
          id: `new-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
        }));

        // Combinar con items existentes y agrupar
        setEditItems((prevItems) => {
          const allItems = [...prevItems, ...newProductsWithStatus];
          const grouped = groupIdenticalItems(allItems);

          return grouped;
        });

        // Marcar estos productos como procesados
        const newProcessedIds = unprocessedProducts.map(
          (item) =>
            `${item.productId}-${item.variantId || 'null'}-${JSON.stringify(item.modifiers.map((m) => m.id).sort())}-${item.preparationNotes || ''}`,
        );
        setProcessedPendingProductsIds((prev) => [...prev, ...newProcessedIds]);

        // Calcular cuántos items únicos se añadieron
        const uniqueNewItems = newProductsWithStatus.length;
        showSnackbar({
          message: `${uniqueNewItems} producto${uniqueNewItems > 1 ? 's' : ''} añadido${uniqueNewItems > 1 ? 's' : ''}`,
          type: 'success',
        });
      }
    }
  }, [
    pendingProductsToAdd,
    isEditMode,
    visible,
    orderDataLoaded,
    processedPendingProductsIds,
    groupIdenticalItems,
    showSnackbar,
  ]);

  // Resetear los IDs procesados cuando el modal se cierre o cambie de orden
  // (esto se maneja en el useEffect de reseteo de estados)

  // Limpiar errores locales al cambiar tipo de orden (más simple)
  useEffect(() => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
  }, [orderType]);

  // Detectar cambios sin guardar
  useEffect(() => {
    if (!isEditMode || !originalOrderState || !visible) {
      setHasUnsavedChanges(false);
      return;
    }

    // Comparar el estado actual con el original
    const hasChanges =
      // Cambios en items
      JSON.stringify(editItems) !== JSON.stringify(originalOrderState.items) ||
      // Cambios en tipo de orden
      editOrderType !== originalOrderState.orderType ||
      // Cambios en mesa
      editSelectedTableId !== originalOrderState.tableId ||
      // Cambios en mesa temporal
      editIsTemporaryTable !== originalOrderState.isTemporaryTable ||
      editTemporaryTableName !== originalOrderState.temporaryTableName ||
      // Cambios en datos del cliente
      JSON.stringify(editDeliveryInfo) !==
        JSON.stringify(originalOrderState.deliveryInfo) ||
      editOrderNotes !== originalOrderState.notes ||
      // Cambios en hora programada (comparar valores de tiempo, no referencias)
      (editScheduledTime?.getTime() ?? null) !==
        (originalOrderState.scheduledAt?.getTime() ?? null) ||
      // Cambios en ajustes
      JSON.stringify(editAdjustments) !==
        JSON.stringify(originalOrderState.adjustments);

    setHasUnsavedChanges(hasChanges);
  }, [
    isEditMode,
    originalOrderState,
    visible,
    editItems,
    editOrderType,
    editSelectedTableId,
    editIsTemporaryTable,
    editTemporaryTableName,
    editDeliveryInfo,
    editOrderNotes,
    editScheduledTime,
    editAdjustments,
  ]);

  // Resetear estados cuando el modal se cierre
  useEffect(() => {
    if (!visible && isEditMode) {
      // Resetear estados de edición cuando el modal se cierre
      setEditOrderType(OrderTypeEnum.DINE_IN);
      setEditSelectedAreaId(null);
      setEditSelectedTableId(null);
      setEditScheduledTime(null);
      setEditDeliveryInfo({});
      setEditOrderNotes('');
      setEditItems([]);
      setShowExitConfirmation(false);
      setEditingItemFromList(null);
      setEditingProduct(null);
      setIsModalReady(false);
      setOrderDataLoaded(false); // Resetear el flag de datos cargados
      setProcessedPendingProductsIds([]); // Resetear los IDs de productos procesados
      setLastNotifiedCount(null); // Resetear el conteo notificado
      setOriginalOrderState(null); // Resetear el estado original
      setHasUnsavedChanges(false); // Resetear el flag de cambios
    }
  }, [visible, isEditMode]);

  // Manejar la preparación del modal con un pequeño delay
  useEffect(() => {
    if (visible && !isModalReady) {
      const timer = setTimeout(() => {
        setIsModalReady(true);
      }, 100); // 100ms delay para evitar conflictos de focus
      return () => clearTimeout(timer);
    }
  }, [visible, isModalReady]);

  // Funciones para manejar ajustes
  const handleAddAdjustment = useCallback(
    (adjustment: OrderAdjustment) => {
      if (isEditMode) {
        // Asegurar que el ajuste tenga un ID único
        const newAdjustment = {
          ...adjustment,
          id:
            adjustment.id ||
            `new-adjustment-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
          isNew: true,
        };
        setEditAdjustments((prev) => [...prev, newAdjustment]);
      }
    },
    [isEditMode],
  );

  const handleUpdateAdjustment = useCallback(
    (id: string, updatedAdjustment: OrderAdjustment) => {
      if (isEditMode) {
        setEditAdjustments((prev) =>
          prev.map((adj) =>
            adj.id === id ? { ...adj, ...updatedAdjustment, id } : adj,
          ),
        );
      }
    },
    [isEditMode],
  );

  const handleRemoveAdjustment = useCallback(
    (id: string) => {
      if (isEditMode) {
        setEditAdjustments((prev) => prev.filter((adj) => adj.id !== id));
      }
    },
    [isEditMode],
  );

  // Función para limpiar datos según el tipo de orden (solo se ejecuta al guardar)
  const cleanOrderDataForSubmission = useCallback(
    (
      orderType: OrderType,
      deliveryInfo: DeliveryInfo,
      selectedTableId: string | null,
      selectedAreaId: string | null,
      isTemporaryTable: boolean,
      temporaryTableName: string,
    ) => {
      const cleanedData: {
        deliveryInfo: DeliveryInfo;
        tableId?: string;
        isTemporaryTable?: boolean;
        temporaryTableName?: string;
        temporaryTableAreaId?: string;
      } = {
        deliveryInfo: {},
      };

      // Limpiar deliveryInfo según el tipo de orden
      if (orderType === OrderTypeEnum.DINE_IN) {
        // DINE_IN: No necesita deliveryInfo, pero sí mesa
        cleanedData.deliveryInfo = {};
        if (isTemporaryTable) {
          cleanedData.isTemporaryTable = true;
          cleanedData.temporaryTableName = temporaryTableName;
          cleanedData.temporaryTableAreaId = selectedAreaId || undefined;
        } else {
          cleanedData.tableId = selectedTableId || undefined;
        }
      } else if (orderType === OrderTypeEnum.TAKE_AWAY) {
        // TAKE_AWAY: Solo recipientName, recipientPhone y deliveryInstructions
        cleanedData.deliveryInfo = {
          recipientName: deliveryInfo.recipientName,
          recipientPhone: deliveryInfo.recipientPhone,
          deliveryInstructions: deliveryInfo.deliveryInstructions,
        };
        // No necesita mesa ni área
      } else if (orderType === OrderTypeEnum.DELIVERY) {
        // DELIVERY: Solo campos de dirección y recipientPhone
        cleanedData.deliveryInfo = {
          fullAddress: deliveryInfo.fullAddress,
          street: deliveryInfo.street,
          number: deliveryInfo.number,
          interiorNumber: deliveryInfo.interiorNumber,
          neighborhood: deliveryInfo.neighborhood,
          city: deliveryInfo.city,
          state: deliveryInfo.state,
          zipCode: deliveryInfo.zipCode,
          country: deliveryInfo.country,
          latitude: deliveryInfo.latitude,
          longitude: deliveryInfo.longitude,
          recipientPhone: deliveryInfo.recipientPhone,
          deliveryInstructions: deliveryInfo.deliveryInstructions,
        };
        // No necesita mesa ni área
      }

      return cleanedData;
    },
    [],
  );

  const handleConfirm = async () => {
    if (isConfirming) return; // Prevenir múltiples clics

    // Resetear errores
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);

    if (items.length === 0) {
      return;
    }

    let isValid = true;

    // Validaciones según el tipo de orden
    if (orderType === OrderTypeEnum.DINE_IN) {
      if (!selectedAreaId) {
        setAreaError('Debe seleccionar un área');
        isValid = false;
      }
      if (isTemporaryTable) {
        if (!temporaryTableName || temporaryTableName.trim() === '') {
          setTableError('Debe ingresar un nombre para la mesa temporal');
          isValid = false;
        }
      } else {
        if (!selectedTableId) {
          setTableError('Debe seleccionar una mesa');
          isValid = false;
        }
      }
    } else if (orderType === OrderTypeEnum.TAKE_AWAY) {
      if (
        !deliveryInfo.recipientName ||
        deliveryInfo.recipientName.trim() === ''
      ) {
        setRecipientNameError('El nombre del cliente es obligatorio');
        isValid = false;
      }
      // Si se proporciona teléfono, validar que tenga al menos 10 dígitos
      if (
        deliveryInfo.recipientPhone &&
        deliveryInfo.recipientPhone.trim() !== ''
      ) {
        const phoneDigits = deliveryInfo.recipientPhone.replace(/\D/g, '');
        if (phoneDigits.length < 10) {
          setRecipientPhoneError('El teléfono debe tener al menos 10 dígitos');
          isValid = false;
        }
      }
    } else if (orderType === OrderTypeEnum.DELIVERY) {
      if (!deliveryInfo.fullAddress || deliveryInfo.fullAddress.trim() === '') {
        setAddressError('La dirección es obligatoria para Domicilio');
        isValid = false;
      }
      if (
        !deliveryInfo.recipientPhone ||
        deliveryInfo.recipientPhone.trim() === ''
      ) {
        setRecipientPhoneError('El teléfono es obligatorio para Domicilio');
        isValid = false;
      } else {
        // Validar que tenga al menos 10 dígitos
        const phoneDigits = deliveryInfo.recipientPhone.replace(/\D/g, '');
        if (phoneDigits.length < 10) {
          setRecipientPhoneError('El teléfono debe tener al menos 10 dígitos');
          isValid = false;
        }
      }
    }

    if (!isValid) {
      return;
    }

    // Limpiar datos según el tipo de orden SOLO AL GUARDAR
    const cleanedData = cleanOrderDataForSubmission(
      orderType,
      deliveryInfo,
      selectedTableId,
      selectedAreaId,
      isTemporaryTable,
      temporaryTableName,
    );

    // Mapear items del carrito al formato esperado por el DTO del backend
    const itemsForBackend: OrderItemDtoForBackend[] = [];

    // Mapear items según el modo (creación o edición)
    items.forEach((item: CartItem) => {
      if (isEditMode && item.id && !item.id.startsWith('new-')) {
        // En modo edición, expandir items con ID real según la cantidad
        const existingIds = item.id
          .split(',')
          .filter((id) => id.trim() && !id.startsWith('new-'));
        const requiredQuantity = item.quantity;

        // Enviar cada item individualmente
        for (let i = 0; i < requiredQuantity; i++) {
          const isExistingItem = i < existingIds.length;

          itemsForBackend.push({
            id: isExistingItem ? existingIds[i] : undefined,
            productId: item.productId,
            productVariantId: item.variantId || null,
            basePrice: Number(item.unitPrice),
            finalPrice: Number(item.totalPrice / item.quantity),
            preparationNotes: item.preparationNotes || null,
            productModifiers:
              item.modifiers && item.modifiers.length > 0
                ? item.modifiers.map((mod) => ({
                    modifierId: mod.id,
                  }))
                : undefined,
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          });
        }
      } else {
        // Items nuevos se expanden según cantidad
        for (let i = 0; i < item.quantity; i++) {
          itemsForBackend.push({
            productId: item.productId,
            productVariantId: item.variantId || null,
            basePrice: Number(item.unitPrice),
            finalPrice: Number(item.totalPrice / item.quantity),
            preparationNotes: item.preparationNotes || null,
            productModifiers:
              item.modifiers && item.modifiers.length > 0
                ? item.modifiers.map((mod) => ({
                    modifierId: mod.id,
                  }))
                : undefined,
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          });
        }
      }
    });

    // Formatear el número de teléfono para el backend
    let formattedPhone: string | undefined = undefined;
    if (
      cleanedData.deliveryInfo.recipientPhone &&
      cleanedData.deliveryInfo.recipientPhone.trim() !== ''
    ) {
      formattedPhone = cleanedData.deliveryInfo.recipientPhone.trim();
    }

    const orderDetails: OrderDetailsForBackend = {
      userId: user?.id,
      orderType,
      subtotal,
      total,
      items: itemsForBackend,
      tableId: cleanedData.tableId,
      isTemporaryTable: cleanedData.isTemporaryTable,
      temporaryTableName: cleanedData.temporaryTableName,
      temporaryTableAreaId: cleanedData.temporaryTableAreaId,
      scheduledAt: scheduledTime ? scheduledTime : undefined,
      deliveryInfo: {
        ...cleanedData.deliveryInfo,
        recipientPhone: formattedPhone,
      },
      notes: orderNotes || undefined,
      adjustments: isEditMode
        ? editAdjustments
            .filter((adj) => !adj.isDeleted)
            .map((adj) => {
              return {
                orderId: orderId || undefined,
                name: adj.name,
                isPercentage: adj.isPercentage,
                value: adj.value,
                amount: adj.amount,
              };
            })
        : undefined,
    };

    if (!orderDetails.userId) {
      // Usuario no autenticado
      return;
    }

    setIsConfirming(true);

    // Si hay un pre-pago creado, incluir su ID
    if (!isEditMode && prepaymentId) {
      orderDetails.prepaymentId = prepaymentId;
    }

    try {
      await onConfirmOrder(orderDetails);
      setIsConfirming(false);

      if (isEditMode) {
        setOriginalOrderState({
          items: [...editItems],
          orderType: editOrderType,
          tableId: editSelectedTableId,
          isTemporaryTable: editIsTemporaryTable,
          temporaryTableName: editTemporaryTableName,
          deliveryInfo: editDeliveryInfo,
          notes: editOrderNotes,
          scheduledAt: editScheduledTime,
          adjustments: editAdjustments,
        });
        setHasUnsavedChanges(false);

        showSnackbar({
          message: 'Cambios guardados exitosamente',
          type: 'success',
        });

        onClose?.();
      }
    } catch (error) {
      setIsConfirming(false);
      // Error manejado por el componente padre
    }
  };

  const selectedAreaName = useMemo(
    () => areasData?.find((a: any) => a.id === selectedAreaId)?.name,
    [areasData, selectedAreaId],
  );
  const selectedTableName = useMemo(() => {
    return tablesData?.find((t) => t.id === selectedTableId)?.name;
  }, [tablesData, selectedTableId]);

  const showTimePicker = () => {
    setTimePickerVisible(true);
  };

  const hideTimePicker = () => setTimePickerVisible(false);

  const handlePrepaymentCreated = async (
    prepaymentIdCreated: string,
    amount: number,
    method: 'CASH' | 'CARD' | 'TRANSFER',
  ) => {
    const isUpdate = prepaymentId === prepaymentIdCreated;

    setPrepaymentId(prepaymentIdCreated);
    setPaymentAmount(amount.toFixed(2));
    setPaymentMethod(method);
    setShowPrepaymentModal(false);

    showSnackbar({
      message: isUpdate
        ? 'Pago actualizado correctamente'
        : 'Pago registrado correctamente',
      type: 'success',
    });
  };

  const handleDeletePrepayment = () => {
    if (!prepaymentId) return;

    setShowDeletePrepaymentConfirm(true);
  };

  const confirmDeletePrepayment = async () => {
    if (!prepaymentId) return;

    try {
      await prepaymentService.deletePrepayment(prepaymentId);
      setPrepaymentId(null);
      setPaymentAmount('');
      setPaymentMethod(null);

      showSnackbar({
        message: 'Prepago eliminado correctamente',
        type: 'success',
      });
    } catch (error: any) {
      let errorMessage = 'Error al eliminar el prepago';

      // Manejar específicamente el error 404
      if (error?.response?.status === 404) {
        errorMessage = 'El prepago ya no existe o fue eliminado previamente';
        // Limpiar el estado local si el prepago ya no existe
        setPrepaymentId(null);
        setPaymentAmount('');
        setPaymentMethod(null);
      } else if (error?.response?.data?.message) {
        errorMessage = error.response.data.message;
      }

      showSnackbar({
        message: errorMessage,
        type: 'error',
      });
    } finally {
      setShowDeletePrepaymentConfirm(false);
    }
  };

  const handlePrepaymentDeleted = () => {
    setPrepaymentId(null);
    setPaymentAmount('');
    setPaymentMethod('CASH');
    setShowPrepaymentModal(false);

    showSnackbar({
      message: 'Pago eliminado correctamente',
      type: 'success',
    });
  };

  const handleTimeConfirm = (date: Date) => {
    const now = new Date();
    now.setSeconds(0, 0);

    if (date < now) {
      hideTimePicker();
      setTimeAlertVisible(true);
    } else {
      if (isEditMode) {
        setEditScheduledTime(date);
      } else {
        setScheduledTime(date);
      }
      hideTimePicker();
    }
  };

  const formattedScheduledTime = useMemo(() => {
    if (!scheduledTime) return null;
    try {
      return format(scheduledTime, 'h:mm a').toLowerCase(); // Formato 12 horas con am/pm
    } catch (error) {
      // Error al formatear fecha
      return 'Hora inválida';
    }
  }, [scheduledTime]);

  // [HELPER MOVIDO A dateTimeHelpers.ts para evitar problemas con Hermes]

  // Función para manejar la edición de un item del carrito
  const handleEditCartItem = useCallback(
    (item: CartItem) => {
      if (!isEditMode) {
        // En modo creación, usar la función pasada por props
        if (onEditItem) {
          onEditItem(item);
        }
      } else {
        // Verificar el estado del item antes de permitir edición
        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          // No permitir editar items listos o entregados
          showSnackbar({
            message: `No se puede editar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,
            type: 'error',
          });
          return;
        }

        const proceedWithEdit = () => {
          // En modo edición, buscar el producto real del menú
          if (!menu || !Array.isArray(menu)) {
            return;
          }

          // Buscar el producto en la estructura anidada del menú
          let product: Product | undefined;

          for (const category of menu as FullMenuCategory[]) {
            if (
              category.subcategories &&
              Array.isArray(category.subcategories)
            ) {
              for (const subcategory of category.subcategories) {
                if (
                  subcategory.products &&
                  Array.isArray(subcategory.products)
                ) {
                  product = subcategory.products.find(
                    (p: Product) => p.id === item.productId,
                  );
                  if (product) break;
                }
              }
            }
            if (product) break;
          }

          if (product) {
            setEditingItemFromList(item);
            setEditingProduct(product);
          } else {
            // Si no encontramos el producto en el menú, crear uno temporal
            setEditingItemFromList(item);

            const tempProduct: Product = {
              id: item.productId,
              name: item.productName,
              price: item.unitPrice,
              hasVariants: !!item.variantId,
              variants: item.variantId
                ? [
                    {
                      id: item.variantId,
                      name: item.variantName || '',
                      price: item.unitPrice,
                    },
                  ]
                : [],
              modifierGroups: [], // Sin grupos de modificadores
              photo: null,
              subcategoryId: '',
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            setEditingProduct(tempProduct);
          }
        };

        if (item.preparationStatus === 'IN_PROGRESS') {
          // Pedir confirmación para items en preparación
          setModifyingItemName(item.productName);
          setPendingModifyAction(() => proceedWithEdit);
          setShowModifyInProgressConfirmation(true);
        } else {
          // Permitir editar items pendientes o cancelados sin confirmación
          proceedWithEdit();
        }
      }
    },
    [isEditMode, onEditItem, menu, showSnackbar],
  );

  // Función para actualizar un item editado
  const handleUpdateEditedItem = useCallback(
    (
      itemId: string,
      quantity: number,
      modifiers: CartItemModifier[],
      preparationNotes?: string,
      variantId?: string,
      variantName?: string,
      unitPrice?: number,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
      pizzaExtraCost?: number,
    ) => {
      if (!isEditMode) return;

      setEditItems((prev) =>
        prev.map((item) => {
          if (item.id === itemId) {
            const modifiersPrice = modifiers.reduce(
              (sum, mod) => sum + Number(mod.price || 0),
              0,
            );
            const finalUnitPrice =
              unitPrice !== undefined ? unitPrice : item.unitPrice;
            const extraCost = pizzaExtraCost || 0;
            const newTotalPrice =
              (finalUnitPrice + modifiersPrice + extraCost) * quantity;

            return {
              ...item,
              quantity,
              modifiers,
              preparationNotes:
                preparationNotes !== undefined
                  ? preparationNotes
                  : item.preparationNotes,
              variantId: variantId !== undefined ? variantId : item.variantId,
              variantName:
                variantName !== undefined ? variantName : item.variantName,
              unitPrice: finalUnitPrice,
              totalPrice: newTotalPrice,
              selectedPizzaCustomizations:
                selectedPizzaCustomizations !== undefined
                  ? selectedPizzaCustomizations
                  : item.selectedPizzaCustomizations,
            };
          }
          return item;
        }),
      );

      // Cerrar el modal de edición
      setEditingItemFromList(null);
      setEditingProduct(null);
    },
    [isEditMode],
  );

  // Helper function to render fields in order
  const renderFields = () => {
    switch (orderType) {
      case OrderTypeEnum.DINE_IN: // Usar Enum
        return (
          <>
            {/* 1. Área */}
            <View style={styles.dineInSelectorsRow}>
              <View style={styles.dineInSelectorContainer}>
                <Menu
                  visible={areaMenuVisible}
                  onDismiss={() => setAreaMenuVisible(false)}
                  anchor={
                    <AnimatedLabelSelector
                      label="Área *"
                      value={selectedAreaName}
                      onPress={() => setAreaMenuVisible(true)}
                      isLoading={isLoadingAreas}
                      error={!!areaError || !!errorAreas}
                      disabled={isLoadingAreas}
                    />
                  }
                >
                  {areasData?.map((area: any) => (
                    <Menu.Item
                      key={area.id}
                      onPress={() => {
                        setSelectedAreaId(area.id);
                        setSelectedTableId(null);
                        setAreaMenuVisible(false);
                        setAreaError(null);
                      }}
                      title={area.name}
                    />
                  ))}
                  {errorAreas && (
                    <Menu.Item title="Error al cargar áreas" disabled />
                  )}
                </Menu>
                {areaError && !errorAreas && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    {areaError}
                  </HelperText>
                )}
                {errorAreas && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    Error al cargar áreas
                  </HelperText>
                )}
              </View>

              {/* 2. Mesa */}
              <View style={styles.dineInSelectorContainer}>
                <Menu
                  visible={tableMenuVisible}
                  onDismiss={() => setTableMenuVisible(false)}
                  anchor={
                    <AnimatedLabelSelector
                      label="Mesa *"
                      value={selectedTableName}
                      onPress={() => setTableMenuVisible(true)}
                      isLoading={isLoadingTables}
                      error={!!tableError || !!errorTables}
                      disabled={
                        !selectedAreaId ||
                        isLoadingTables ||
                        isLoadingAreas ||
                        isTemporaryTable
                      }
                    />
                  }
                >
                  {tablesData?.map((table: Table) => {
                    // En modo edición, permitir seleccionar la mesa actual aunque esté ocupada
                    const isCurrentTable =
                      isEditMode && orderData?.tableId === table.id;
                    const canSelect = table.isAvailable || isCurrentTable;

                    return (
                      <Menu.Item
                        key={table.id}
                        onPress={() => {
                          if (canSelect) {
                            setSelectedTableId(table.id);
                            setTableMenuVisible(false);
                            setTableError(null);
                          }
                        }}
                        title={`${table.name}${!table.isAvailable && !isCurrentTable ? ' (Ocupada)' : ''}`}
                        disabled={!canSelect}
                        titleStyle={
                          !canSelect ? { color: theme.colors.error } : undefined
                        }
                      />
                    );
                  })}
                  {selectedAreaId &&
                    tablesData?.length === 0 &&
                    !isLoadingTables &&
                    !errorTables && <Menu.Item title="No hay mesas" disabled />}
                  {errorTables && (
                    <Menu.Item title="Error al cargar mesas" disabled />
                  )}
                </Menu>
                {tableError && !errorTables && !isTemporaryTable && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    {tableError}
                  </HelperText>
                )}
                {errorTables && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    Error al cargar mesas
                  </HelperText>
                )}
              </View>
            </View>

            {/* Opción de mesa temporal */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <TouchableOpacity
                onPress={() => {
                  setIsTemporaryTable(!isTemporaryTable);
                  if (!isTemporaryTable) {
                    // Si activamos mesa temporal, limpiar la selección de mesa
                    setSelectedTableId(null);
                    setTableError(null);
                  } else {
                    // Si desactivamos mesa temporal, limpiar el nombre
                    setTemporaryTableName('');
                  }
                }}
                style={styles.checkboxContainer}
              >
                <Checkbox.Android
                  status={isTemporaryTable ? 'checked' : 'unchecked'}
                  onPress={() => {
                    setIsTemporaryTable(!isTemporaryTable);
                    if (!isTemporaryTable) {
                      // Si activamos mesa temporal, limpiar la selección de mesa
                      setSelectedTableId(null);
                      setTableError(null);
                    } else {
                      // Si desactivamos mesa temporal, limpiar el nombre
                      setTemporaryTableName('');
                    }
                  }}
                  color={theme.colors.primary}
                />
                <Text style={styles.checkboxLabel}>
                  {isEditMode && isTemporaryTable
                    ? 'Mesa temporal'
                    : 'Crear mesa temporal'}
                </Text>
              </TouchableOpacity>

              {/* Campo para nombre de mesa temporal */}
              {(isTemporaryTable || (isEditMode && editIsTemporaryTable)) && (
                <View style={styles.temporaryTableInputContainer}>
                  <SpeechRecognitionInput
                    key={`temporary-table-name-${isEditMode ? 'edit' : 'create'}`}
                    label="Nombre de la Mesa Temporal *"
                    value={temporaryTableName}
                    onChangeText={(text) => {
                      setTemporaryTableName(text);
                      if (tableError) setTableError(null);
                    }}
                    error={!!tableError && isTemporaryTable}
                    speechLang="es-MX"
                    autoCapitalize="words"
                    autoCorrect={false}
                    placeholder="Ej: Mesa Terraza 1"
                    editable={true} // Editable tanto en creación como en edición
                  />
                  {tableError && isTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                </View>
              )}
            </View>

            {/* 3. Notas */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="notes-input-dine-in"
                label="Notas de la Orden (Opcional)"
                value={orderNotes}
                onChangeText={setOrderNotes}
                multiline
                speechLang="es-MX"
              />
            </View>

            {/* 4. Programar Hora */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <AnimatedLabelSelector
                label="Programar Hora (Opcional)"
                value={formattedScheduledTime}
                onPress={showTimePicker}
                onClear={() => setScheduledTime(null)}
              />
            </View>
          </>
        );
      case OrderTypeEnum.TAKE_AWAY: // Usar Enum
        return (
          <>
            {/* 1. Nombre Cliente */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key={`customer-name-input-${orderType}`}
                label="Nombre del Cliente *"
                value={deliveryInfo.recipientName || ''}
                onChangeText={(text) => {
                  setDeliveryInfo({ ...deliveryInfo, recipientName: text });
                  if (recipientNameError) setRecipientNameError(null);
                }}
                error={!!recipientNameError}
                speechLang="es-MX"
                autoCapitalize="words"
                autoCorrect={false}
              />
              {recipientNameError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientNameError}
                </HelperText>
              )}
            </View>

            {/* 2. Teléfono */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <View style={styles.phoneInputWrapper}>
                <SpeechRecognitionInput
                  key={`phone-input-takeaway-${orderType}`}
                  label="Teléfono (Opcional)"
                  value={deliveryInfo.recipientPhone || ''}
                  onChangeText={(text) => {
                    setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });
                    if (recipientPhoneError) setRecipientPhoneError(null);
                  }}
                  keyboardType="phone-pad"
                  error={!!recipientPhoneError} // Aunque opcional, puede tener errores de formato si se ingresa
                  speechLang="es-MX"
                  autoCorrect={false}
                />
                {(deliveryInfo.recipientPhone || '').length > 0 &&
                  !recipientPhoneError && (
                    <Text style={styles.digitCounterAbsolute}>
                      {
                        (deliveryInfo.recipientPhone || '').replace(/\D/g, '')
                          .length
                      }{' '}
                      dígitos
                    </Text>
                  )}
              </View>
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>

            {/* 3. Notas */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="notes-input-takeaway"
                label="Notas de la Orden (Opcional)"
                value={orderNotes}
                onChangeText={setOrderNotes}
                multiline
                speechLang="es-MX"
              />
            </View>

            {/* 4. Programar Hora */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <AnimatedLabelSelector
                label="Programar Hora Recolección (Opcional)"
                value={formattedScheduledTime}
                onPress={showTimePicker}
                onClear={() => setScheduledTime(null)}
              />
            </View>
          </>
        );
      case OrderTypeEnum.DELIVERY: // Usar Enum
        return (
          <>
            {/* 1. Dirección */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="address-input-delivery"
                label="Dirección de Entrega *"
                value={deliveryInfo.fullAddress || ''}
                onChangeText={(text) => {
                  setDeliveryInfo({ ...deliveryInfo, fullAddress: text });
                  if (addressError) setAddressError(null);
                }}
                error={!!addressError}
                speechLang="es-MX"
                multiline
                isInModal={true}
              />
              {addressError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {addressError}
                </HelperText>
              )}
            </View>

            {/* 2. Teléfono */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key={`phone-input-delivery-${orderType}`} // Key única y específica
                label="Teléfono *"
                value={deliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  // Asegurar que la función esté bien definida aquí
                  setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });
                  if (recipientPhoneError) {
                    setRecipientPhoneError(null);
                  }
                }}
                keyboardType="phone-pad"
                error={!!recipientPhoneError}
                speechLang="es-MX"
                autoCorrect={false}
              />
              <View style={styles.phoneHelperContainer}>
                {recipientPhoneError ? (
                  <HelperText
                    type="error"
                    visible={true}
                    style={[styles.helperTextFix, styles.recipientPhoneError]}
                  >
                    {recipientPhoneError}
                  </HelperText>
                ) : (
                  (deliveryInfo.recipientPhone || '').length > 0 && (
                    <Text style={styles.digitCounter}>
                      {
                        (deliveryInfo.recipientPhone || '').replace(/\D/g, '')
                          .length
                      }{' '}
                      dígitos
                    </Text>
                  )
                )}
              </View>
            </View>

            {/* 3. Notas */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="notes-input-delivery" // Key única y específica
                label="Notas de la Orden (Opcional)"
                value={orderNotes}
                onChangeText={setOrderNotes}
                multiline
                speechLang="es-MX"
              />
            </View>

            {/* 4. Programar Hora */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <AnimatedLabelSelector
                label="Programar Hora Entrega (Opcional)"
                value={formattedScheduledTime}
                onPress={showTimePicker}
                onClear={() => setScheduledTime(null)}
              />
            </View>
          </>
        );
      default:
        return null;
    }
  };

  // Mostrar loading si estamos en modo edición y aún cargando
  if (isEditMode && isLoadingOrder) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onClose}
          contentContainerStyle={styles.modalContent}
        >
          <View style={[styles.container, styles.loadingContainer]}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando orden...</Text>
          </View>
        </Modal>
      </Portal>
    );
  }

  // Mostrar error si falló la carga en modo edición
  if (isEditMode && isErrorOrder) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onClose}
          contentContainerStyle={styles.errorModalContent}
        >
          <View style={styles.errorModalContainer}>
            {/* Icono de error */}
            <View
              style={[
                styles.errorIconContainer,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <IconButton
                icon="alert-circle-outline"
                size={48}
                iconColor={theme.colors.error}
                style={styles.iconButtonNoMargin}
              />
            </View>

            {/* Título del error */}
            <Text
              style={[
                styles.errorModalTitle,
                { color: theme.colors.onSurface },
              ]}
            >
              No se pudo cargar la orden
            </Text>

            {/* Mensaje descriptivo */}
            <Text
              style={[
                styles.errorModalMessage,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Ha ocurrido un error al intentar cargar los datos de la orden. Por
              favor, intenta nuevamente más tarde.
            </Text>

            {/* Botón de cerrar */}
            <Button
              mode="contained"
              onPress={onClose}
              style={styles.errorModalButton}
              contentStyle={styles.errorModalButtonContent}
              labelStyle={styles.errorModalButtonLabel}
            >
              Entendido
            </Button>
          </View>
        </Modal>
      </Portal>
    );
  }

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (isEditMode && hasUnsavedChanges) {
            setShowExitConfirmation(true);
          } else {
            onClose?.();
          }
        }}
        contentContainerStyle={styles.modalContent}
        dismissable={true}
        dismissableBackButton={false}
      >
        <GestureHandlerRootView style={styles.container}>
          <TouchableWithoutFeedback
            onPress={Keyboard.dismiss}
            accessible={false}
          >
            <View>
              {isEditMode ? (
                <View style={styles.customHeader}>
                  <IconButton
                    icon="arrow-left"
                    size={24}
                    onPress={() => {
                      if (hasUnsavedChanges) {
                        setShowExitConfirmation(true);
                      } else {
                        onClose?.();
                      }
                    }}
                    iconColor={theme.colors.onSurface}
                  />

                  <View style={styles.headerTitleContainer}>
                    <Text style={styles.headerTitle}>
                      {orderNumber && orderDate
                        ? `Editar Orden #${orderNumber} - ${format(orderDate, 'dd/MM/yyyy', { locale: es })}`
                        : orderNumber
                          ? `Editando Orden #${orderNumber}`
                          : 'Editar Orden'}
                    </Text>
                    {orderData?.orderStatus && (
                      <View
                        style={[
                          styles.orderStatusBadge,
                          {
                            backgroundColor: getOrderStatusColor(
                              orderData.orderStatus,
                              theme,
                            ),
                          },
                        ]}
                      >
                        <Text style={styles.orderStatusText}>
                          {formatOrderStatus(orderData.orderStatus)}
                        </Text>
                      </View>
                    )}
                  </View>

                  <Menu
                    visible={showOptionsMenu}
                    onDismiss={() => setShowOptionsMenu(false)}
                    anchor={
                      <IconButton
                        icon="dots-vertical"
                        size={24}
                        onPress={() => setShowOptionsMenu(true)}
                        iconColor={theme.colors.onSurface}
                      />
                    }
                  >
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        setShowDetailModal(true);
                      }}
                      title="Ver Detalles"
                      leadingIcon="file-document-outline"
                    />
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        setShowHistoryModal(true);
                      }}
                      title="Ver Historial"
                      leadingIcon="history"
                    />
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        setShowCancelConfirmation(true);
                      }}
                      title="Cancelar Orden"
                      leadingIcon="cancel"
                    />
                  </Menu>
                </View>
              ) : (
                <OrderHeader
                  title={
                    orderNumber ? `Orden #${orderNumber}` : 'Resumen de Orden'
                  }
                  onBackPress={() => onClose?.()}
                  itemCount={totalItemsCount}
                  onCartPress={() => {}}
                  isCartVisible={isCartVisible}
                />
              )}
            </View>
          </TouchableWithoutFeedback>

          <ScrollView
            style={styles.scrollView}
            keyboardShouldPersistTaps="handled"
            keyboardDismissMode="on-drag"
          >
            {/* Order Type Selection */}
            <View style={styles.sectionCompact}>
              <RadioButton.Group
                onValueChange={(newValue) =>
                  setOrderType(newValue as OrderType)
                }
                value={orderType}
              >
                <View style={styles.radioGroupHorizontal}>
                  <RadioButton.Item
                    label="COMER AQUÍ"
                    value={OrderTypeEnum.DINE_IN} // Usar Enum
                    style={styles.radioButtonItem}
                    labelStyle={styles.radioLabel}
                    position="leading"
                  />
                  <RadioButton.Item
                    label="PARA LLEVAR"
                    value={OrderTypeEnum.TAKE_AWAY} // Usar Enum
                    style={styles.radioButtonItem}
                    labelStyle={styles.radioLabel}
                    position="leading"
                  />
                  <RadioButton.Item
                    label="DOMICILIO"
                    value={OrderTypeEnum.DELIVERY} // Usar Enum
                    style={styles.radioButtonItem}
                    labelStyle={styles.radioLabel}
                    position="leading"
                  />
                </View>
              </RadioButton.Group>
            </View>

            {/* Render fields based on order type */}
            {renderFields()}

            <Divider style={styles.divider} />

            {/* Cart Items */}
            <List.Section>
              {items.map((item) => {
                // Crear función de renderizado de acción de eliminar
                const renderRightActions = (progress, dragX) => {
                  const translateX = dragX.interpolate({
                    inputRange: [-100, 0],
                    outputRange: [0, 100],
                    extrapolate: 'clamp',
                  });

                  const scale = dragX.interpolate({
                    inputRange: [-100, -50, 0],
                    outputRange: [1, 0.8, 0.5],
                    extrapolate: 'clamp',
                  });

                  const opacity = dragX.interpolate({
                    inputRange: [-100, -20, 0],
                    outputRange: [1, 0.5, 0],
                    extrapolate: 'clamp',
                  });

                  return (
                    <Animated.View
                      style={[
                        styles.deleteActionContainer,
                        {
                          opacity,
                          transform: [{ translateX }],
                        },
                      ]}
                    >
                      <Animated.View
                        style={[
                          styles.deleteAction,
                          {
                            backgroundColor: theme.colors.error,
                            transform: [{ scale }],
                          },
                        ]}
                      >
                        <View style={styles.deleteIconContainer}>
                          <IconButton
                            icon="delete-sweep"
                            size={28}
                            iconColor="white"
                            style={styles.deleteIcon}
                          />
                        </View>
                        <Text style={styles.deleteActionText}>ELIMINAR</Text>
                      </Animated.View>
                    </Animated.View>
                  );
                };

                return (
                  <Swipeable
                    key={item.id}
                    renderRightActions={renderRightActions}
                    overshootRight={false}
                    friction={2}
                    rightThreshold={90}
                    leftThreshold={100}
                    onSwipeableOpen={(direction) => {
                      if (direction === 'right') {
                        // Pequeño delay para que se vea la animación completa
                        setTimeout(() => {
                          removeItem(item.id);
                        }, 150);
                      }
                    }}
                  >
                    <TouchableOpacity
                      onPress={() => handleEditCartItem(item)}
                      disabled={!onEditItem && !isEditMode}
                      activeOpacity={0.7}
                    >
                      <List.Item
                        // Mover title y description a un View contenedor para controlar el ancho
                        title={() => (
                          <View style={styles.itemTextContainer}>
                            <View>
                              <Text style={styles.itemTitleText}>
                                {`${item.quantity}x ${item.variantName ? String(item.variantName ?? '') : String(item.productName ?? '')}`}
                              </Text>
                              {/* Mostrar estado de preparación solo en modo edición - siempre en nueva línea */}
                              {isEditMode && item.preparationStatus && (
                                <View style={styles.statusContainer}>
                                  <View
                                    style={[
                                      styles.statusBadge,
                                      {
                                        backgroundColor:
                                          getPreparationStatusColor(
                                            item.preparationStatus,
                                            theme,
                                          ) + '20',
                                      },
                                    ]}
                                  >
                                    <View
                                      style={[
                                        styles.statusDot,
                                        {
                                          backgroundColor:
                                            getPreparationStatusColor(
                                              item.preparationStatus,
                                              theme,
                                            ),
                                        },
                                      ]}
                                    />
                                    <Text
                                      style={[
                                        styles.statusText,
                                        {
                                          color: getPreparationStatusColor(
                                            item.preparationStatus,
                                            theme,
                                          ),
                                        },
                                      ]}
                                    >
                                      {getPreparationStatusText(
                                        item.preparationStatus,
                                      )}
                                    </Text>
                                  </View>
                                </View>
                              )}
                            </View>
                            {(() => {
                              // Render description condicionalmente
                              const hasModifiers =
                                item.modifiers && item.modifiers.length > 0;
                              const hasNotes =
                                item.preparationNotes &&
                                item.preparationNotes.trim() !== '';
                              const hasPizzaCustomizations =
                                item.selectedPizzaCustomizations &&
                                item.selectedPizzaCustomizations.length > 0;

                              return (
                                <View>
                                  {/* Renderizar personalizaciones de pizza */}
                                  {hasPizzaCustomizations && (
                                    <Text style={styles.itemDescription}>
                                      {formatPizzaCustomizations(
                                        item.selectedPizzaCustomizations,
                                      )}
                                    </Text>
                                  )}

                                  {/* Renderizar modificadores */}
                                  {hasModifiers &&
                                    item.modifiers.map(
                                      (mod: any, index: number) => (
                                        <Text
                                          key={mod.id || index}
                                          style={styles.itemDescription}
                                        >
                                          • {mod.name}{' '}
                                          {mod.price && Number(mod.price) > 0
                                            ? `(+$${Number(mod.price).toFixed(2)})`
                                            : ''}
                                        </Text>
                                      ),
                                    )}

                                  {/* Renderizar notas */}
                                  {hasNotes && (
                                    <Text
                                      style={[
                                        styles.itemDescription,
                                        styles.notesText,
                                      ]}
                                    >
                                      Notas: {item.preparationNotes}
                                    </Text>
                                  )}
                                </View>
                              );
                            })()}
                          </View>
                        )}
                        // titleNumberOfLines y description ya no se usan directamente aquí
                        right={() => (
                          // Usar paréntesis para retorno implícito si es una sola expresión
                          <View style={styles.itemActionsContainer}>
                            <View style={styles.quantityActions}>
                              <IconButton
                                icon="minus-circle-outline"
                                size={20} // Reducir tamaño de icono
                                onPress={() =>
                                  updateItemQuantity(item.id, item.quantity - 1)
                                }
                                style={styles.quantityButton}
                                disabled={item.quantity <= 1} // Deshabilitar si es 1
                              />
                              <Text style={styles.quantityText}>
                                {item.quantity}
                              </Text>
                              <IconButton
                                icon="plus-circle-outline"
                                size={20} // Reducir tamaño de icono
                                onPress={() =>
                                  updateItemQuantity(item.id, item.quantity + 1)
                                }
                                style={styles.quantityButton}
                              />
                            </View>
                            <View style={styles.priceContainer}>
                              <Text style={styles.itemPrice}>
                                ${Number(item.totalPrice || 0).toFixed(2)}
                              </Text>
                              {item.quantity > 1 && (
                                <Text style={styles.unitPriceText}>
                                  ($
                                  {(
                                    Number(item.unitPrice || 0) +
                                    (item.modifiers || []).reduce(
                                      (sum, mod) =>
                                        sum + Number(mod.price || 0),
                                      0,
                                    )
                                  ).toFixed(2)}{' '}
                                  c/u)
                                </Text>
                              )}
                            </View>
                          </View>
                        )}
                        style={styles.listItem}
                      />
                    </TouchableOpacity>
                  </Swipeable>
                );
              })}

              {/* Renderizar ajustes como OrderItems - dentro del mismo List.Section */}
              {isEditMode &&
                adjustments
                  .filter((adj) => !adj.isDeleted)
                  .map((adjustment, index) => {
                    const renderRightActions = (progress, dragX) => {
                      const translateX = dragX.interpolate({
                        inputRange: [-100, 0],
                        outputRange: [0, 100],
                        extrapolate: 'clamp',
                      });

                      const scale = dragX.interpolate({
                        inputRange: [-100, -50, 0],
                        outputRange: [1, 0.8, 0.5],
                        extrapolate: 'clamp',
                      });

                      const opacity = dragX.interpolate({
                        inputRange: [-100, -20, 0],
                        outputRange: [1, 0.5, 0],
                        extrapolate: 'clamp',
                      });

                      return (
                        <Animated.View
                          style={[
                            styles.deleteActionContainer,
                            {
                              opacity,
                              transform: [{ translateX }],
                            },
                          ]}
                        >
                          <Animated.View
                            style={[
                              styles.deleteAction,
                              {
                                backgroundColor: theme.colors.error,
                                transform: [{ scale }],
                              },
                            ]}
                          >
                            <View style={styles.deleteIconContainer}>
                              <IconButton
                                icon="delete-sweep"
                                size={28}
                                iconColor="white"
                                style={styles.deleteIcon}
                              />
                            </View>
                            <Text style={styles.deleteActionText}>
                              ELIMINAR
                            </Text>
                          </Animated.View>
                        </Animated.View>
                      );
                    };

                    return (
                      <Swipeable
                        key={adjustment.id || `new-${index}`}
                        renderRightActions={renderRightActions}
                        overshootRight={false}
                        friction={2}
                        rightThreshold={90}
                        leftThreshold={100}
                        onSwipeableOpen={(direction) => {
                          if (direction === 'right') {
                            setTimeout(() => {
                              if (adjustment.id) {
                                handleRemoveAdjustment(adjustment.id);
                              }
                            }, 150);
                          }
                        }}
                      >
                        <TouchableOpacity
                          onPress={() => {
                            setAdjustmentToEdit(adjustment);
                            setShowAdjustmentModal(true);
                          }}
                          activeOpacity={0.7}
                        >
                          <List.Item
                            title={() => (
                              <View style={styles.itemTextContainer}>
                                <Text
                                  style={[
                                    styles.itemTitleText,
                                    {
                                      color:
                                        adjustment.amount < 0
                                          ? theme.colors.error
                                          : theme.colors.primary,
                                    },
                                  ]}
                                >
                                  {adjustment.name}
                                  {adjustment.isPercentage
                                    ? ` (${adjustment.value}%)`
                                    : ''}
                                </Text>
                              </View>
                            )}
                            right={() => (
                              <View style={styles.itemActionsContainer}>
                                <View style={styles.priceContainer}>
                                  <Text
                                    style={[
                                      styles.itemPrice,
                                      {
                                        color:
                                          adjustment.amount < 0
                                            ? theme.colors.error
                                            : theme.colors.primary,
                                      },
                                    ]}
                                  >
                                    {adjustment.amount < 0 ? '-' : '+'}$
                                    {Math.abs(adjustment.amount || 0).toFixed(
                                      2,
                                    )}
                                  </Text>
                                </View>
                              </View>
                            )}
                            style={styles.listItem}
                          />
                        </TouchableOpacity>
                      </Swipeable>
                    );
                  })}
            </List.Section>

            {/* Botón de ajustes - Solo en modo edición */}
            {isEditMode && (
              <Button
                onPress={() => setShowAdjustmentModal(true)}
                mode="outlined"
                style={styles.adjustmentButton}
                icon="calculator-variant"
              >
                Ajustes
              </Button>
            )}

            {/* Botón para añadir productos en modo edición */}
            {isEditMode && (
              <Button
                onPress={() => {
                  if (onAddProducts) {
                    // Si tenemos un callback personalizado, usarlo
                    onAddProducts();
                  } else if (navigation && orderId && orderNumber) {
                    // Si no, usar navegación directa
                    try {
                      navigation.navigate('AddProductsToOrder', {
                        orderId,
                        orderNumber,
                        // Pasar el conteo de items existentes (no incluir los temporales "NEW")
                        existingOrderItemsCount: editItems
                          .filter((item) => !item.id.startsWith('new-'))
                          .reduce((sum, item) => sum + item.quantity, 0),
                        onProductsAdded: (newProducts: CartItem[]) => {
                          // Marcar los nuevos productos con estado "NEW"
                          const newProductsWithStatus = newProducts.map(
                            (item) => ({
                              ...item,
                              preparationStatus: 'NEW' as const,
                              id: `new-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
                            }),
                          );

                          // Combinar con items existentes y agrupar
                          const allItems = [
                            ...editItems,
                            ...newProductsWithStatus,
                          ];
                          const groupedItems = groupIdenticalItems(allItems);

                          setEditItems(groupedItems);
                          showSnackbar({
                            message: `${newProducts.length} producto${newProducts.length > 1 ? 's' : ''} añadido${newProducts.length > 1 ? 's' : ''}`,
                            type: 'success',
                          });
                        },
                      });
                    } catch (error) {
                      // Error al navegar
                    }
                  }
                }}
                mode="outlined"
                style={styles.addProductsButton}
                icon="plus-circle-outline"
              >
                Añadir Productos
              </Button>
            )}

            <Divider style={styles.divider} />

            {/* Totals */}
            <View style={styles.totalsContainer}>
              <Text style={styles.totalsText}>Subtotal:</Text>
              <Text style={styles.totalsValue}>
                ${(subtotal || 0).toFixed(2)}
              </Text>
            </View>
            {isEditMode && totalAdjustments !== 0 && (
              <View style={styles.totalsContainer}>
                <Text style={styles.totalsText}>Ajustes:</Text>
                <Text
                  style={[
                    styles.totalsValue,
                    {
                      color:
                        totalAdjustments < 0
                          ? theme.colors.error
                          : theme.colors.primary,
                    },
                  ]}
                >
                  {totalAdjustments < 0 ? '-' : '+'}$
                  {Math.abs(totalAdjustments || 0).toFixed(2)}
                </Text>
              </View>
            )}
            <View style={styles.totalsContainer}>
              <Text style={[styles.totalsText, styles.totalLabel]}>Total:</Text>
              <Text style={[styles.totalsValue, styles.totalValue]}>
                ${(total || 0).toFixed(2)}
              </Text>
            </View>

            {/* Mostrar desglose de pago cuando hay pre-pago registrado */}
            {!isEditMode && prepaymentId && (
              <>
                <View style={styles.prepaymentSection}>
                  <View style={styles.prepaymentHeader}>
                    <Text style={styles.prepaymentTitle}>
                      Prepago registrado
                    </Text>
                    <View style={styles.prepaymentActions}>
                      <IconButton
                        icon="pencil"
                        size={28}
                        iconColor={theme.colors.primary}
                        onPress={() => setShowPrepaymentModal(true)}
                        style={styles.prepaymentIconButton}
                      />
                      <IconButton
                        icon="delete"
                        size={28}
                        iconColor={theme.colors.error}
                        onPress={handleDeletePrepayment}
                        style={styles.prepaymentIconButton}
                      />
                    </View>
                  </View>
                  <View style={styles.totalsContainer}>
                    <Text style={styles.totalsText}>Monto pagado:</Text>
                    <Text style={[styles.totalsValue, { color: '#4CAF50' }]}>
                      ${parseFloat(paymentAmount || '0').toFixed(2)}
                    </Text>
                  </View>
                  {/* Mostrar advertencia si el prepago excede el total */}
                  {parseFloat(paymentAmount || '0') > total && (
                    <View style={styles.prepaymentWarning}>
                      <IconButton
                        icon="alert-circle"
                        size={16}
                        iconColor={theme.colors.error}
                        style={styles.iconButtonNoMargin}
                      />
                      <Text style={styles.prepaymentWarningText}>
                        El prepago excede el total de la orden. Edite el pago
                        antes de continuar.
                      </Text>
                    </View>
                  )}
                </View>
                <View style={styles.totalsContainer}>
                  <Text style={[styles.totalsText, { fontWeight: '600' }]}>
                    Restante:
                  </Text>
                  <Text
                    style={[
                      styles.totalsValue,
                      {
                        fontWeight: 'bold',
                        color:
                          total - parseFloat(paymentAmount || '0') <= 0
                            ? '#4CAF50'
                            : theme.colors.error,
                      },
                    ]}
                  >
                    $
                    {Math.max(
                      0,
                      total - parseFloat(paymentAmount || '0'),
                    ).toFixed(2)}
                  </Text>
                </View>
              </>
            )}

            {/* Mostrar información de pagos solo en modo edición */}
            {isEditMode && (
              <>
                <View style={styles.totalsContainer}>
                  <Text style={styles.totalsText}>Pagado:</Text>
                  <Text style={[styles.totalsValue, { color: '#4CAF50' }]}>
                    ${(totalPaid || 0).toFixed(2)}
                  </Text>
                </View>
                <View style={styles.totalsContainer}>
                  <Text style={[styles.totalsText, { fontWeight: 'bold' }]}>
                    Restante:
                  </Text>
                  <Text
                    style={[
                      styles.totalsValue,
                      {
                        fontWeight: 'bold',
                        color:
                          pendingAmount > 0 ? theme.colors.error : '#4CAF50',
                      },
                    ]}
                  >
                    ${(pendingAmount || 0).toFixed(2)}
                  </Text>
                </View>
              </>
            )}
          </ScrollView>

          {/* Botón de pago - solo mostrar si es creación y el usuario tiene permisos y no hay pre-pago */}
          {!isEditMode && canRegisterPayments && !prepaymentId && (
            <View style={styles.paymentButtonContainer}>
              <Button
                mode="outlined"
                onPress={() => setShowPrepaymentModal(true)}
                style={styles.paymentButton}
                icon="credit-card"
              >
                💵 Registrar pago con la orden
              </Button>
            </View>
          )}

          <View style={styles.footer}>
            <Button
              mode="contained"
              onPress={handleConfirm}
              disabled={
                isConfirming || // Deshabilitar mientras se procesa
                items.length === 0 ||
                (isEditMode && !hasUnsavedChanges) || // Deshabilitar si estamos en modo edición y no hay cambios
                (orderType === OrderTypeEnum.DINE_IN &&
                  (!selectedAreaId ||
                    (isTemporaryTable
                      ? !temporaryTableName || temporaryTableName.trim() === ''
                      : !selectedTableId))) || // Usar Enum
                (orderType === OrderTypeEnum.TAKE_AWAY &&
                  (!deliveryInfo.recipientName ||
                    deliveryInfo.recipientName.trim() === '')) || // Usar Enum
                (orderType === OrderTypeEnum.DELIVERY &&
                  (!deliveryInfo.fullAddress ||
                    deliveryInfo.fullAddress.trim() === '')) || // Usar Enum
                (orderType === OrderTypeEnum.DELIVERY &&
                  (!deliveryInfo.recipientPhone ||
                    deliveryInfo.recipientPhone.trim() === '')) // Usar Enum
              }
              style={[
                styles.confirmButton,
                isEditMode &&
                  hasUnsavedChanges && {
                    backgroundColor: '#FF6B35', // Naranja vibrante para indicar acción requerida
                  },
              ]}
              loading={isConfirming} // Mostrar indicador de carga
            >
              {isConfirming
                ? isEditMode
                  ? 'Guardando...'
                  : 'Enviando...'
                : isEditMode
                  ? hasUnsavedChanges
                    ? '⚠️ Guardar Cambios'
                    : 'Guardar Cambios'
                  : 'Enviar Orden'}
            </Button>
          </View>

          {/* Modals */}
          <Portal>
            <DateTimePickerSafe
              visible={isTimePickerVisible}
              mode="time"
              value={scheduledTime}
              onConfirm={handleTimeConfirm}
              onCancel={hideTimePicker}
              minimumDate={new Date()}
              minuteInterval={5}
              title={
                orderType === OrderTypeEnum.DELIVERY
                  ? 'Seleccionar Hora de Entrega'
                  : orderType === OrderTypeEnum.TAKE_AWAY
                    ? 'Seleccionar Hora de Recolección'
                    : 'Seleccionar Hora'
              }
              allowManualInput={true} // Habilita entrada manual en Android
            />
          </Portal>

          <ConfirmationModal
            visible={isTimeAlertVisible}
            title="Hora Inválida"
            message="No puedes seleccionar una hora que ya ha pasado. Por favor, elige una hora futura."
            confirmText="Entendido"
            onConfirm={() => setTimeAlertVisible(false)}
          />

          {/* Modal de confirmación para descartar cambios */}
          <ConfirmationModal
            visible={showExitConfirmation}
            title="¿Descartar cambios?"
            message="Tienes cambios sin guardar. ¿Estás seguro de que quieres salir?"
            confirmText="Descartar"
            cancelText="Cancelar"
            onConfirm={() => {
              setShowExitConfirmation(false);
              onClose?.();
            }}
            onCancel={() => setShowExitConfirmation(false)}
          />

          {/* Modal de confirmación para cancelar la orden */}
          <ConfirmationModal
            visible={showCancelConfirmation}
            title="¿Cancelar orden?"
            message={`¿Estás seguro de que quieres cancelar la orden #${orderNumber}? Esta acción no se puede deshacer.`}
            confirmText="Cancelar Orden"
            cancelText="No, mantener"
            onConfirm={() => {
              setShowCancelConfirmation(false);
              if (onCancelOrder) {
                onCancelOrder();
              }
            }}
            onCancel={() => setShowCancelConfirmation(false)}
          />

          {/* Modal de confirmación para modificar items en preparación */}
          <ConfirmationModal
            visible={showModifyInProgressConfirmation}
            title="¿Modificar producto en preparación?"
            message={`El producto "${modifyingItemName}" está actualmente en preparación. ¿Estás seguro de que quieres modificarlo?`}
            confirmText="Sí, modificar"
            cancelText="No, cancelar"
            onConfirm={() => {
              setShowModifyInProgressConfirmation(false);
              if (pendingModifyAction) {
                pendingModifyAction();
                setPendingModifyAction(null);
              }
              setModifyingItemName('');
            }}
            onCancel={() => {
              setShowModifyInProgressConfirmation(false);
              setPendingModifyAction(null);
              setModifyingItemName('');
            }}
          />

          {/* Modal de personalización de producto para edición */}
          {isEditMode && editingProduct && editingItemFromList && (
            <ProductCustomizationModal
              visible={true}
              product={editingProduct}
              editingItem={editingItemFromList}
              onDismiss={() => {
                setEditingItemFromList(null);
                setEditingProduct(null);
              }}
              onAddToCart={() => {}} // No usado en modo edición
              onUpdateItem={handleUpdateEditedItem}
            />
          )}

          {/* Modal de detalles de orden */}
          {isEditMode && (
            <OrderDetailModal
              visible={showDetailModal}
              onDismiss={() => setShowDetailModal(false)}
              orderId={orderId}
              orderNumber={orderNumber}
              orderData={orderData}
            />
          )}

          {/* Modal de historial de cambios */}
          {isEditMode && (
            <OrderHistoryModal
              visible={showHistoryModal}
              onDismiss={() => setShowHistoryModal(false)}
              orderId={orderId}
              orderNumber={orderNumber}
            />
          )}

          {/* FAB para pagos - solo en modo edición */}
          {isEditMode && orderId && visible && (
            <FAB
              icon="cash-multiple"
              style={[
                styles.paymentFab,
                {
                  backgroundColor: hasUnsavedChanges
                    ? '#9CA3AF' // Gris sólido pero visible
                    : pendingAmount <= 0
                      ? '#4CAF50'
                      : theme.colors.primary,
                },
              ]}
              color="white"
              onPress={() => {
                if (hasUnsavedChanges) {
                  showSnackbar({
                    message:
                      'Debes guardar los cambios antes de registrar pagos',
                    type: 'warning',
                  });
                } else {
                  setShowPaymentModal(true);
                }
              }}
              visible={true}
            />
          )}

          {/* Modal de pagos */}
          {showPaymentModal && isEditMode && orderId && (
            <PaymentModal
              visible={showPaymentModal}
              onDismiss={() => setShowPaymentModal(false)}
              orderId={orderId}
              orderTotal={total}
              orderNumber={orderNumber}
              orderStatus={orderData?.orderStatus}
              onOrderCompleted={() => {
                // Cerrar el modal de pagos
                setShowPaymentModal(false);
                // Cerrar el modal de edición de orden
                onClose?.();
              }}
            />
          )}

          {/* Modal de ajustes */}
          {showAdjustmentModal && isEditMode && (
            <AdjustmentFormModal
              visible={showAdjustmentModal}
              onDismiss={() => {
                setShowAdjustmentModal(false);
                setAdjustmentToEdit(null);
              }}
              onSave={(adjustment: OrderAdjustment) => {
                if (adjustmentToEdit) {
                  handleUpdateAdjustment(adjustmentToEdit.id!, adjustment);
                } else {
                  handleAddAdjustment(adjustment);
                }
                setShowAdjustmentModal(false);
                setAdjustmentToEdit(null);
              }}
              adjustment={adjustmentToEdit}
              orderSubtotal={subtotal}
            />
          )}

          {/* Modal de pago para pre-pagos */}
          <PaymentModal
            visible={showPrepaymentModal}
            onDismiss={() => setShowPrepaymentModal(false)}
            orderTotal={total}
            mode="prepayment"
            onPrepaymentCreated={handlePrepaymentCreated}
            existingPrepaymentId={prepaymentId || undefined}
            onPrepaymentDeleted={handlePrepaymentDeleted}
          />

          {/* Modal de confirmación para eliminar prepago */}
          <ConfirmationModal
            visible={showDeletePrepaymentConfirm}
            onDismiss={() => setShowDeletePrepaymentConfirm(false)}
            title="¿Eliminar prepago?"
            message="¿Estás seguro de que deseas eliminar este prepago? Esta acción no se puede deshacer."
            confirmText="Eliminar"
            cancelText="Cancelar"
            onConfirm={confirmDeletePrepayment}
            onCancel={() => setShowDeletePrepaymentConfirm(false)}
          />
        </GestureHandlerRootView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '100%',
      height: '100%',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0,
    },
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
      paddingHorizontal: theme.spacing.s, // Restaurar padding pequeño
    },
    divider: {
      marginVertical: theme.spacing.s,
    },
    // List Item Styles
    listItem: {
      flexDirection: 'row', // 1) Fila
      alignItems: 'center',
      justifyContent: 'space-between', // 2) Separar título y acciones
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.s, // controla el "gap" desde el borde
      backgroundColor: theme.colors.surface,
      minHeight: 80, // Altura mínima para mejor experiencia de swipe
    },

    itemTextContainer: {
      // Contenedor para título y descripción
      flex: 3, // Darle aún más espacio al texto ahora que no hay botón de eliminar
      marginRight: theme.spacing.xs, // Pequeño margen para separar de las acciones
      justifyContent: 'center', // Centrar texto verticalmente
      // backgroundColor: 'lightyellow', // Debug
    },
    itemTitleText: {
      // Estilo para el texto del título
      fontSize: 15, // Aumentar tamaño del título
      fontWeight: '500',
      color: theme.colors.onSurface,
      flexWrap: 'wrap', // Permitir que el texto se ajuste
      lineHeight: 20, // Ajustar altura de línea
    },
    itemDescription: {
      fontSize: 13, // Aumentar tamaño de descripción
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      flexWrap: 'wrap', // Permitir que el texto se ajuste
      lineHeight: 18, // Ajustar altura de línea
    },
    itemActionsContainer: {
      // Contenedor para acciones (cantidad, precio, borrar)
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      flexShrink: 0, // No permitir que se encoja
      // backgroundColor: 'lightblue', // Debug
    },
    quantityActions: {
      flexDirection: 'row',
      alignItems: 'center',
      // marginRight: theme.spacing.s, // Adjust spacing as needed
    }, // <<< COMA RESTAURADA
    // quantityButton: { // <<< ESTILO DUPLICADO/INCORRECTO ELIMINADO
    //    margin: 0,
    //    // backgroundColor: 'lightgreen',
    // },
    //   flexDirection: "row", // <<< CÓDIGO INCORRECTO ELIMINADO
    //   alignItems: "center",
    //   // marginRight: theme.spacing.xs,
    // },
    quantityButton: {
      // <<< ESTILO CORRECTO
      marginHorizontal: -4, // Reducir espacio horizontal entre botones
      padding: 0, // Eliminar padding interno
      // backgroundColor: 'lightgreen', // Debug
    }, // <<< COMA RESTAURADA
    quantityText: {
      fontSize: 14, // Aumentar tamaño
      fontWeight: 'bold',
      minWidth: 20, // Ajustar ancho mínimo
      textAlign: 'center',
      marginHorizontal: 2, // Ajustar margen horizontal
      // backgroundColor: 'pink', // Debug
    }, // <<< COMA RESTAURADA
    itemPrice: {
      alignSelf: 'center',
      marginRight: theme.spacing.xs, // Reducir espacio
      color: theme.colors.onSurfaceVariant,
      fontSize: 15, // Aumentar tamaño
      fontWeight: 'bold',
      minWidth: 55, // Ajustar ancho mínimo
      textAlign: 'right',
      // backgroundColor: 'lightcoral', // Debug
    }, // <<< COMA RESTAURADA
    priceContainer: {
      flexDirection: 'column',
      alignItems: 'flex-end',
      marginRight: theme.spacing.xs,
    },
    unitPriceText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    deleteActionContainer: {
      width: 120,
      height: '100%',
      justifyContent: 'center',
      alignItems: 'flex-end',
      paddingRight: theme.spacing.m,
    },
    deleteAction: {
      backgroundColor: theme.colors.error,
      justifyContent: 'center',
      alignItems: 'center',
      width: 90,
      height: '90%',
      borderRadius: theme.roundness * 2,
      flexDirection: 'column',
      shadowColor: theme.colors.error,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      elevation: 5,
    },
    deleteIconContainer: {
      width: 50,
      height: 50,
      borderRadius: 25,
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: 4,
    },
    deleteIcon: {
      margin: 0,
      padding: 0,
    },
    deleteActionText: {
      color: 'white',
      fontSize: 11,
      fontWeight: '700',
      letterSpacing: 1,
      textTransform: 'uppercase',
    }, // <<< COMA RESTAURADA
    // End List Item Styles
    totalsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    totalsText: {
      fontSize: 16,
    }, // <<< COMA RESTAURADA
    totalsValue: {
      fontSize: 16,
      fontWeight: 'bold',
    }, // <<< COMA RESTAURADA
    totalLabel: {
      fontWeight: 'bold',
      fontSize: 18,
    }, // <<< COMA RESTAURADA
    totalValue: {
      fontSize: 18,
      color: theme.colors.primary,
    }, // <<< COMA RESTAURADA
    section: {
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.s,
    }, // <<< COMA RESTAURADA
    sectionCompact: {
      marginBottom: 0,
      paddingBottom: 0,
    }, // <<< COMA RESTAURADA
    dineInSelectorsRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: 0,
      gap: theme.spacing.s,
      marginTop: theme.spacing.s,
    }, // <<< COMA RESTAURADA
    dineInSelectorContainer: {
      flex: 1,
    }, // <<< COMA RESTAURADA
    selectorLoader: {}, // <<< COMA RESTAURADA
    sectionTitleContainer: {
      flexDirection: 'row',
      alignItems: 'baseline',
      marginBottom: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    sectionTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    sectionTitleOptional: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
      marginLeft: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    radioGroupHorizontal: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      alignItems: 'center',
      width: '100%',
      paddingVertical: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    radioLabel: {
      marginLeft: 0,
      fontSize: 11,
      textTransform: 'uppercase',
      textAlign: 'center',
    }, // <<< COMA RESTAURADA
    radioButtonItem: {
      paddingHorizontal: 0,
      paddingVertical: 4,
      flexShrink: 1,
      flex: 1,
      marginHorizontal: 2,
    }, // <<< COMA RESTAURADA
    dropdownAnchor: {}, // <<< COMA RESTAURADA
    dropdownContent: {}, // <<< COMA RESTAURADA
    dropdownLabel: {}, // <<< COMA RESTAURADA
    helperTextFix: {
      marginTop: -6,
      marginBottom: 0,
      paddingHorizontal: 12,
    }, // <<< COMA RESTAURADA
    footer: {
      padding: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    }, // <<< COMA RESTAURADA
    confirmButton: {
      paddingVertical: theme.spacing.xs,
    },
    input: {}, // <<< COMA RESTAURADA
    fieldContainer: {
      marginTop: theme.spacing.s,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: theme.spacing.m,
    },
    phoneHelperContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginTop: 2,
      paddingHorizontal: 12,
      minHeight: 20,
    },
    recipientPhoneError: {
      flex: 1,
      marginBottom: 0,
      marginTop: 0,
    },
    digitCounter: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
      marginLeft: theme.spacing.xs,
      marginTop: 2,
    },
    phoneInputWrapper: {
      position: 'relative',
    },
    digitCounterAbsolute: {
      position: 'absolute',
      right: 50, // Mover más a la izquierda para evitar el botón de micrófono
      top: 10, // Ajustar para estar en la parte superior del input
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.7,
      backgroundColor: theme.colors.background,
      paddingHorizontal: 8,
      paddingVertical: 3,
      borderRadius: 12,
      zIndex: 1,
    },
    notesText: {
      fontStyle: 'italic',
      marginTop: 4,
      paddingTop: 4,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    customHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 4,
      paddingVertical: 8,
      backgroundColor: theme.colors.elevation.level2,
    },
    headerTitleContainer: {
      flex: 1,
      alignItems: 'center',
      gap: 4,
    },
    headerTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
    },
    orderStatusBadge: {
      paddingHorizontal: 12,
      paddingVertical: 4,
      borderRadius: 12,
    },
    orderStatusText: {
      ...theme.fonts.labelSmall,
      color: 'white',
      fontWeight: '600',
      fontSize: 11,
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 2, // Pequeño margen para separar del nombre
      justifyContent: 'flex-start', // Alinear a la izquierda
    },
    statusBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.s,
      paddingVertical: 2, // Reducido de 4 a 2 para ser más compacto
      borderRadius: 12,
      gap: 4,
    },
    statusDot: {
      width: 6,
      height: 6,
      borderRadius: 3,
    },
    statusText: {
      fontSize: 11,
      fontWeight: '600',
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    paymentFab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 140, // Más arriba para mejor visibilidad
      zIndex: 1000,
      elevation: 6,
      width: 56, // Tamaño estándar para FAB pequeño
      height: 56,
      justifyContent: 'center',
      alignItems: 'center',
    },
    paymentConfigButton: {
      marginTop: theme.spacing.s,
    },
    paymentButtonContainer: {
      paddingHorizontal: theme.spacing.s,
      paddingVertical: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    paymentButton: {
      marginVertical: theme.spacing.xs,
    },
    paymentValueContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    editPaymentButton: {
      margin: 0,
      marginLeft: theme.spacing.xs,
      width: 28,
      height: 28,
    },
    checkboxContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: theme.spacing.s,
      marginBottom: theme.spacing.xs,
    },
    checkboxLabel: {
      fontSize: 16,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    temporaryTableInputContainer: {
      marginTop: theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    prepaymentSection: {
      marginBottom: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    prepaymentHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    prepaymentTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    prepaymentActions: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
    },
    prepaymentIconButton: {
      margin: 0,
    },
    prepaymentWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.errorContainer,
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    prepaymentWarningText: {
      flex: 1,
      fontSize: 14,
      color: theme.colors.onErrorContainer,
      marginLeft: theme.spacing.xs,
    },
    errorModalContent: {
      backgroundColor: 'transparent',
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.m,
    },
    errorModalContainer: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      padding: theme.spacing.xl,
      alignItems: 'center',
      width: '90%',
      maxWidth: 400,
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    errorIconContainer: {
      width: 80,
      height: 80,
      borderRadius: 40,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    errorModalTitle: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: theme.spacing.s,
      textAlign: 'center',
    },
    errorModalMessage: {
      fontSize: 16,
      textAlign: 'center',
      marginBottom: theme.spacing.l,
      lineHeight: 22,
    },
    errorModalButton: {
      marginTop: theme.spacing.m,
      minWidth: 120,
    },
    errorModalButtonContent: {
      paddingHorizontal: theme.spacing.l,
    },
    errorModalButtonLabel: {
      fontSize: 16,
    },
    // Estilos adicionales para eliminar inline styles
    iconButtonNoMargin: {
      margin: 0,
    },
    adjustmentButton: {
      marginTop: theme.spacing.m,
      marginBottom: theme.spacing.s,
    },
    addProductsButton: {
      marginTop: theme.spacing.m,
      marginBottom: theme.spacing.m,
    },
  });
export default OrderCartDetail;

================
File: app/src/modules/orderFinalization/components/OrderCard.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Card,
  Text,
  Checkbox,
  Chip,
  IconButton,
  Icon,
} from 'react-native-paper';
import { OrderForFinalizationList } from '../types/orderFinalization.types';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import {
  formatOrderTypeShort,
  formatOrderStatus,
  getStatusColor,
  getPaymentStatus,
} from '@/app/utils/orderFormatters';

interface OrderCardProps {
  order: OrderForFinalizationList;
  isSelected: boolean;
  onToggleSelection: (orderId: string) => void;
  onShowDetails: (order: OrderForFinalizationList) => void;
  onPrintPress?: (order: OrderForFinalizationList) => void;
}

export const OrderCard = React.memo<OrderCardProps>(
  ({ order, isSelected, onToggleSelection, onShowDetails, onPrintPress }) => {
    const theme = useAppTheme();
    const responsive = useResponsive();
    const styles = React.useMemo(() => createStyles(responsive), [responsive]);

    let orderTitle = `#${order.shiftOrderNumber} • ${formatOrderTypeShort(order.orderType)}`;

    if (order.orderType === 'DINE_IN' && order.table) {
      const tableDisplay = order.table.isTemporary
        ? order.table.name
        : `Mesa ${order.table.name || order.table.number || 'N/A'}`;
      orderTitle += ` • ${order.table.area?.name || 'Sin área'} • ${tableDisplay}`;
    } else if (order.orderType === 'TAKE_AWAY') {
      if (order.deliveryInfo?.recipientName) {
        orderTitle += ` • ${order.deliveryInfo.recipientName}`;
      }
      if (order.deliveryInfo?.recipientPhone) {
        orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;
      }
    } else if (order.orderType === 'DELIVERY') {
      if (order.deliveryInfo?.fullAddress) {
        orderTitle += ` • ${order.deliveryInfo.fullAddress}`;
      }
      if (order.deliveryInfo?.recipientPhone) {
        orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;
      }
    }

    const totalAmount =
      typeof order.total === 'string' ? parseFloat(order.total) : order.total;
    const totalPaid = order.paymentsSummary?.totalPaid || 0;
    const pendingAmount = totalAmount - totalPaid;

    const paymentStatus = getPaymentStatus(order);

    return (
      <TouchableOpacity
        activeOpacity={0.95}
        onPress={() => onShowDetails(order)}
      >
        <Card
          style={[
            styles.orderCard,
            {
              backgroundColor: isSelected
                ? theme.colors.primaryContainer
                : theme.colors.surface,
              borderColor: isSelected ? theme.colors.primary : 'transparent',
              borderWidth: isSelected ? 2 : 0,
            },
          ]}
          mode="elevated"
        >
          <Card.Content style={styles.cardContent}>
            <View style={styles.mainContainer}>
              <View style={styles.leftContainer}>
                <Text
                  style={[
                    styles.orderNumber,
                    {
                      color: isSelected
                        ? theme.colors.onPrimaryContainer
                        : theme.colors.onSurface,
                    },
                  ]}
                >
                  {orderTitle}
                  <Text
                    style={[
                      styles.orderPrice,
                      {
                        color:
                          pendingAmount > 0 ? theme.colors.error : '#10B981',
                      },
                    ]}
                  >
                    {' • '}
                    {pendingAmount > 0
                      ? `Por pagar: $${pendingAmount.toFixed(2)}`
                      : `Pagado: $${totalAmount.toFixed(2)}`}
                  </Text>
                  {order.notes && (
                    <Text
                      style={[
                        styles.notesInline,
                        {
                          color: isSelected
                            ? theme.colors.onPrimaryContainer
                            : theme.colors.onSurfaceVariant,
                        },
                      ]}
                      numberOfLines={1}
                    >
                      {' • '}
                      {order.notes}
                    </Text>
                  )}
                </Text>
                <View style={styles.timeAndPaymentRow}>
                  <Text
                    style={[
                      styles.orderTime,
                      {
                        color: isSelected
                          ? theme.colors.primary
                          : theme.colors.primary,
                      },
                    ]}
                  >
                    {format(new Date(order.createdAt), 'p', { locale: es })}
                  </Text>
                  {(() => {
                    const color =
                      paymentStatus === 'paid'
                        ? '#10B981'
                        : paymentStatus === 'partial'
                          ? '#F59E0B'
                          : '#EF4444';
                    const icon =
                      paymentStatus === 'paid'
                        ? '✓'
                        : paymentStatus === 'partial'
                          ? '½'
                          : '•';
                    return (
                      <View
                        style={[
                          styles.miniPaymentBadge,
                          { backgroundColor: color },
                        ]}
                      >
                        <Text style={styles.miniPaymentText}>{icon}</Text>
                      </View>
                    );
                  })()}

                  {/* Badge de WhatsApp */}
                  {order.isFromWhatsApp && (
                    <View
                      style={[
                        styles.inlinePreparationBadge,
                        {
                          backgroundColor: '#25D366',
                          borderColor: '#25D366',
                        },
                      ]}
                    >
                      <Icon source="whatsapp" size={12} color="#FFFFFF" />
                    </View>
                  )}

                  {order.preparationScreenStatuses &&
                    order.preparationScreenStatuses.length > 0 && (
                      <>
                        {order.preparationScreenStatuses.map(
                          (screen, index) => {
                            const backgroundColor =
                              screen.status === 'READY'
                                ? '#4CAF50'
                                : screen.status === 'IN_PROGRESS'
                                  ? '#FFA000'
                                  : isSelected
                                    ? theme.colors.primaryContainer
                                    : theme.colors.surfaceVariant;

                            const textColor =
                              screen.status === 'READY' ||
                              screen.status === 'IN_PROGRESS'
                                ? '#FFFFFF'
                                : isSelected
                                  ? theme.colors.onPrimaryContainer
                                  : theme.colors.onSurfaceVariant;

                            return (
                              <View
                                key={`${order.id}-screen-${index}`}
                                style={[
                                  styles.inlinePreparationBadge,
                                  {
                                    backgroundColor,
                                    borderColor:
                                      backgroundColor ===
                                      theme.colors.surfaceVariant
                                        ? theme.colors.outline
                                        : backgroundColor,
                                  },
                                ]}
                              >
                                <Text
                                  style={[
                                    styles.inlinePreparationText,
                                    { color: textColor },
                                  ]}
                                >
                                  {screen.status === 'READY'
                                    ? '✓ '
                                    : screen.status === 'IN_PROGRESS'
                                      ? '⏳ '
                                      : ''}
                                  🍳 {screen.name}
                                </Text>
                              </View>
                            );
                          },
                        )}
                      </>
                    )}
                </View>
              </View>

              <View style={styles.rightContainer}>
                {order.createdBy && (
                  <Text
                    style={[
                      styles.createdByText,
                      {
                        color: isSelected
                          ? theme.colors.onPrimaryContainer
                          : theme.colors.onSurfaceVariant,
                      },
                    ]}
                    numberOfLines={1}
                  >
                    {order.createdBy.firstName && order.createdBy.lastName
                      ? `${order.createdBy.firstName} ${order.createdBy.lastName}`
                      : order.createdBy.username}
                  </Text>
                )}
                <Chip
                  mode="flat"
                  compact
                  style={[
                    styles.statusChip,
                    {
                      backgroundColor: getStatusColor(order.orderStatus, theme),
                    },
                  ]}
                  textStyle={styles.statusChipText}
                >
                  {formatOrderStatus(order.orderStatus)}
                </Chip>
                <View style={styles.actionsContainer}>
                  {onPrintPress && (
                    <TouchableOpacity
                      style={styles.printContainer}
                      onPress={() => onPrintPress(order)}
                      activeOpacity={0.7}
                    >
                      <IconButton
                        icon="printer"
                        size={32}
                        style={styles.printButton}
                        disabled
                      />
                      {(order.ticketImpressionCount ?? 0) > 0 && (
                        <View style={styles.printCountBadge}>
                          <Text style={styles.printCountText}>
                            {order.ticketImpressionCount}
                          </Text>
                        </View>
                      )}
                    </TouchableOpacity>
                  )}
                  <View style={styles.checkboxContainer}>
                    <Checkbox
                      status={isSelected ? 'checked' : 'unchecked'}
                      onPress={() => {
                        onToggleSelection(order.id);
                      }}
                      color={theme.colors.primary}
                      style={styles.checkbox}
                    />
                  </View>
                </View>
              </View>
            </View>
          </Card.Content>
        </Card>
      </TouchableOpacity>
    );
  },
);

OrderCard.displayName = 'OrderCard';

const createStyles = (responsive: ReturnType<typeof useResponsive>) =>
  StyleSheet.create({
    orderCard: {
      marginBottom: responsive.isTablet ? 6 : 8,
    },
    cardContent: {
      paddingBottom: responsive.isTablet ? 6 : 8,
      paddingTop: responsive.isTablet ? 8 : 12,
      paddingHorizontal: responsive.isTablet ? 12 : 16,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 8,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: responsive.isTablet ? 120 : 140,
      gap: responsive.isTablet ? 4 : 8,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: 4,
    },
    orderNumber: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: 'bold',
      lineHeight: responsive.isTablet ? 18 : 22,
      marginBottom: responsive.isTablet ? 2 : 4,
    },
    orderPrice: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '700',
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 12 : 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    orderTime: {
      fontSize: responsive.isTablet ? 13 : 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: 14,
      marginLeft: 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: 11,
      fontWeight: '600',
      lineHeight: 14,
    },
    checkboxContainer: {
      padding: 8,
      marginLeft: -8,
      marginRight: -12,
    },
    checkbox: {
      margin: 0,
      transform: [{ scale: 1.5 }],
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
      marginLeft: 4,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 4,
    },
    miniPreparationText: {
      fontSize: 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: 10,
      marginLeft: 4,
    },
    createdByText: {
      fontSize: 10,
      marginBottom: 4,
      textAlign: 'right',
    },
    rightTopRow: {
      width: '100%',
    },
    printButton: {
      margin: -4,
    },
    printContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: '#3B82F6',
      borderRadius: 10,
      minWidth: 20,
      height: 20,
      paddingHorizontal: 4,
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountText: {
      color: '#FFFFFF',
      fontSize: 10,
      fontWeight: 'bold',
    },
  });

================
File: app/src/app/services/discoveryService.ts
================
import NetInfo from '@react-native-community/netinfo';
import EncryptedStorage from '@/app/services/secureStorageService';
import { NETWORK_CONFIG } from '../constants/network';
import { API_PATHS } from '../constants/apiPaths';
import { Platform } from 'react-native';

const DISCOVERY_ENDPOINT = API_PATHS.DISCOVERY.substring(1); // Quitar / inicial
const STORAGE_KEY = 'last_known_api_url';

interface DiscoveryResponse {
  type: string;
  name: string;
  version: string;
  port: number;
  features: string[];
  timestamp: number;
  remoteUrl?: string;
  tunnelEnabled?: boolean;
}

export class DiscoveryService {
  private static instance: DiscoveryService;
  private cachedUrl: string | null = null;
  private discovering = false;
  private discoveryPromise: Promise<string | null> | null = null;
  private lastDiscoveryTime = 0;
  private logCallback: ((message: string) => void) | null = null;
  private manualUrl: string | null = null;
  private progressCallback:
    | ((progress: { current: number; total: number; message: string }) => void)
    | null = null;

  private constructor() {}

  /**
   * Establece un callback para logs
   */
  setLogCallback(callback: ((message: string) => void) | null) {
    this.logCallback = callback;
  }

  /**
   * Establece un callback para el progreso del discovery
   */
  setProgressCallback(
    callback:
      | ((progress: {
          current: number;
          total: number;
          message: string;
        }) => void)
      | null,
  ) {
    this.progressCallback = callback;
  }

  private log(message: string) {
    if (this.logCallback) {
      this.logCallback(message);
    }
  }

  private updateProgress(current: number, total: number, message: string) {
    if (this.progressCallback) {
      this.progressCallback({ current, total, message });
    }
  }

  static getInstance(): DiscoveryService {
    if (!DiscoveryService.instance) {
      DiscoveryService.instance = new DiscoveryService();
    }
    return DiscoveryService.instance;
  }

  /**
   * Obtiene la URL del API desde cache o almacenamiento
   * Solo verifica si la URL almacenada sigue funcionando
   * @returns string si encuentra una URL válida, null si no encuentra ninguna
   */
  async getApiUrl(): Promise<string | null> {
    // Si hay URL manual configurada, usarla
    if (this.manualUrl) {
      return this.manualUrl;
    }

    // En web, intentar recuperar URL manual guardada
    if (Platform.OS === 'web') {
      try {
        const savedUrl = await EncryptedStorage.getItem('manual_server_url');
        if (savedUrl) {
          this.manualUrl = savedUrl;
          return savedUrl;
        }
      } catch {}
      return null;
    }

    // Si ya tenemos una URL en cache, devolverla sin verificar
    // La verificación se hace en otros lugares (health monitoring)
    if (this.cachedUrl) {
      return this.cachedUrl;
    }

    // Intentar con la última URL conocida almacenada
    try {
      const lastKnown = await EncryptedStorage.getItem(STORAGE_KEY);
      if (lastKnown) {
        this.cachedUrl = lastKnown;
        return lastKnown;
      }
    } catch {}

    // Si no hay URL válida, devolver null
    return null;
  }

  /**
   * Fuerza un nuevo descubrimiento del backend
   * IMPORTANTE: Solo debe llamarse después de múltiples health checks fallidos
   */
  async forceRediscovery(): Promise<string> {
    // Si hay un descubrimiento en progreso, esperar a que termine
    if (this.discoveryPromise && this.discovering) {
      const result = await this.discoveryPromise;
      if (result) return result;
    }

    // FORZAR nueva búsqueda - limpiar cache SIEMPRE en forceRediscovery
    await this.clearCache();

    // Verificar que no se esté llamando muy frecuentemente
    const timeSinceLastDiscovery = Date.now() - this.lastDiscoveryTime;
    if (timeSinceLastDiscovery < NETWORK_CONFIG.MIN_DISCOVERY_INTERVAL) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }

    const discoveredUrl = await this.discoverBackend();
    if (!discoveredUrl) {
      throw new Error(
        'No se pudo encontrar el servidor CloudBite en la red local',
      );
    }

    return discoveredUrl;
  }

  async clearCache(): Promise<void> {
    this.cachedUrl = null;
    try {
      await EncryptedStorage.removeItem(STORAGE_KEY);
    } catch {}
  }

  /**
   * Obtiene la última URL conocida sin hacer discovery
   */
  async getLastKnownUrl(): Promise<string | null> {
    if (this.cachedUrl) {
      return this.cachedUrl;
    }

    try {
      const lastKnown = await EncryptedStorage.getItem(STORAGE_KEY);
      return lastKnown;
    } catch {
      return null;
    }
  }

  /**
   * Verifica si un servidor está disponible
   */
  private async checkServer(url: string): Promise<boolean> {
    const controller = new AbortController();
    const timeoutId = setTimeout(
      () => controller.abort(),
      NETWORK_CONFIG.DISCOVERY_TIMEOUT,
    );

    try {
      const response = await fetch(`${url}${DISCOVERY_ENDPOINT}`, {
        method: 'GET',
        signal: controller.signal,
        headers: {
          Accept: 'application/json',
        },
      });

      if (!response.ok) return false;

      const data: DiscoveryResponse = await response.json();
      return data.type === 'cloudbite-api';
    } catch (error) {
      return false;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  private async discoverBackend(): Promise<string | null> {
    // Si ya hay un descubrimiento en progreso, devolver la promesa existente
    if (this.discoveryPromise && this.discovering) {
      return this.discoveryPromise;
    }

    this.lastDiscoveryTime = Date.now();
    this.discovering = true;

    // Crear nueva promesa de descubrimiento
    this.discoveryPromise = this.performDiscovery()
      .then(async (result) => {
        if (result) {
          // Usar el método unificado para guardar la URL descubierta
          await this.setServerUrl(result, false);
        }
        return result;
      })
      .finally(() => {
        this.discoveryPromise = null;
        this.discovering = false;
      });

    return this.discoveryPromise;
  }

  private async performDiscovery(): Promise<string | null> {
    try {
      // En web no podemos hacer descubrimiento
      if (Platform.OS === 'web') {
        this.log('❌ El descubrimiento automático no está disponible en web');
        return null;
      }

      // Obtener información de red
      const netInfo = await NetInfo.fetch();

      if (!netInfo.isConnected) {
        throw new Error('No hay conexión de red disponible');
      }

      this.log(
        `🔧 Buscando servidor en puerto ${NETWORK_CONFIG.DISCOVERY_PORT}`,
      );

      const subnets = this.detectCurrentSubnet();
      this.log(`📡 Iniciando búsqueda en redes: ${subnets.join(', ')}`);

      // Calcular total de IPs a escanear
      let totalIps = 0;
      for (const subnet of subnets) {
        totalIps += 254; // IPs de .1 a .254
      }
      this.updateProgress(0, totalIps, 'Iniciando búsqueda...');

      let globalIpsScanned = 0;

      // Probar cada subnet hasta encontrar el servidor
      for (const subnet of subnets) {
        this.log(`🔍 Escaneando red ${subnet}.*`);
        this.updateProgress(
          globalIpsScanned,
          totalIps,
          `Escaneando red ${subnet}.*`,
        );

        const ips = this.generateIpRange(subnet);
        const chunks = this.chunkArray(
          ips,
          NETWORK_CONFIG.MAX_CONCURRENT_REQUESTS,
        );

        let totalIpsScanned = 0;

        for (let i = 0; i < chunks.length; i++) {
          const currentIps = chunks[i];

          const results = await Promise.allSettled(
            currentIps.map((ip) => this.probeServer(ip)),
          );

          totalIpsScanned += currentIps.length;
          globalIpsScanned += currentIps.length;

          // Actualizar progreso
          this.updateProgress(
            globalIpsScanned,
            totalIps,
            `Escaneando ${subnet}.* (${Math.round((globalIpsScanned / totalIps) * 100)}%)`,
          );

          // Buscar si alguna petición fue exitosa
          for (let j = 0; j < results.length; j++) {
            const result = results[j];
            if (result.status === 'fulfilled' && result.value) {
              const foundIp = currentIps[j];
              this.log(`✅ ¡SERVIDOR ENCONTRADO EN ${foundIp}!`);
              this.updateProgress(
                globalIpsScanned,
                totalIps,
                `¡Servidor encontrado en ${foundIp}!`,
              );
              return result.value;
            }
          }

          // Mostrar progreso cada 10 IPs
          if (totalIpsScanned % 10 === 0) {
            const lastIp = currentIps[currentIps.length - 1];
            this.log(
              `  ▶ Escaneadas ${totalIpsScanned} IPs (última: ${lastIp})`,
            );
          }
        }

        this.log(`  ❌ No encontrado en ${subnet}.*`);
      }

      return null;
    } catch (error) {
      this.log(
        `❌ Error durante el descubrimiento: ${error instanceof Error ? error.message : 'Error desconocido'}`,
      );
      return null;
    }
  }

  /**
   * Prueba si una IP específica tiene el servidor CloudBite
   */
  private async probeServer(ip: string): Promise<string | null> {
    const url = `http://${ip}:${NETWORK_CONFIG.DISCOVERY_PORT}`;
    const fullUrl = `http://${ip}:${NETWORK_CONFIG.DISCOVERY_PORT}${API_PATHS.DISCOVERY}`;

    // Crear AbortController para timeout real
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
    }, NETWORK_CONFIG.DISCOVERY_TIMEOUT);

    try {
      const response = await fetch(fullUrl, {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (response.ok) {
        const text = await response.text();
        try {
          const data = JSON.parse(text);
          if (data.type === 'cloudbite-api') {
            this.log(`✅ ¡SERVIDOR ENCONTRADO!`);
            this.log(`📍 IP: ${ip}`);
            this.log(`🔗 URL: ${url}`);
            return url;
          }
        } catch {
          // No es el servidor que buscamos
        }
      }
    } catch {
    } finally {
      clearTimeout(timeoutId);
    }

    return null;
  }

  private detectCurrentSubnet(): string[] {
    return NETWORK_CONFIG.COMMON_SUBNETS;
  }

  /**
   * Genera un rango de IPs para escanear
   */
  private generateIpRange(subnet: string): string[] {
    const ips: string[] = [];
    for (let i = 1; i <= 254; i++) {
      ips.push(`${subnet}.${i}`);
    }
    return ips;
  }

  /**
   * Divide un array en chunks más pequeños
   */
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }

  /**
   * Guarda la URL en almacenamiento seguro
   */
  private async saveUrl(url: string): Promise<void> {
    try {
      await EncryptedStorage.setItem(STORAGE_KEY, url);
    } catch {}
  }

  /**
   * Establece la URL del servidor y la guarda
   * @param url - La URL del servidor (null para limpiar URL manual)
   * @param isManual - Si es true, se marca como configuración manual
   */
  async setServerUrl(
    url: string | null,
    isManual: boolean = false,
  ): Promise<void> {
    if (url) {
      // Actualizar cache en memoria
      this.cachedUrl = url;

      // Si es manual, guardar referencia especial
      if (isManual) {
        this.manualUrl = url;
      }

      // Persistir en almacenamiento seguro
      await this.saveUrl(url);
    } else if (isManual) {
      // Solo limpiar manual URL si explícitamente se pide
      this.manualUrl = null;
    }
  }

  async discoverServer(): Promise<string | null> {
    return this.discoverBackend();
  }

  /**
   * Obtiene información del servidor incluyendo URL remota si está disponible
   */
  async getServerInfo(): Promise<DiscoveryResponse | null> {
    const url = await this.getApiUrl();
    if (!url) return null;

    try {
      const response = await fetch(`${url}${DISCOVERY_ENDPOINT}`, {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
      });

      if (response.ok) {
        const data: DiscoveryResponse = await response.json();
        return data;
      }
    } catch (error) {
      console.error('Error getting server info:', error);
    }

    return null;
  }
}

// Exportar instancia singleton
export const discoveryService = DiscoveryService.getInstance();

================
File: app/src/modules/orders/screens/OpenOrdersScreen.tsx
================
import React, { useCallback, useEffect, useState } from 'react';
import {
  StyleSheet,
  View,
  Pressable,
  TouchableOpacity,
  Animated,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { FlashList } from '@shopify/flash-list';
import {
  Text,
  ActivityIndicator,
  Appbar,
  IconButton,
  Portal,
  Card,
  Chip,
  Icon,
  Surface,
  Button,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { OrdersStackParamList } from '../../../app/navigation/types';
import { useAuthStore } from '../../../app/store/authStore';
import { canOpenShift } from '../../../app/utils/roleUtils';
import { useGlobalShift } from '../../../app/hooks/useGlobalShift';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';
import {
  useGetOpenOrdersListQuery,
  useUpdateOrderMutation,
  useCancelOrderMutation,
} from '../hooks/useOrdersQueries';
import {
  OrderOpenList,
  OrderType,
  OrderTypeEnum,
  OrderStatusEnum,
} from '../types/orders.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { PrintTicketModal } from '@/modules/shared/components/PrintTicketModal';
import { orderPrintService } from '../services/orderPrintService';
import OrderCartDetail from '../components/OrderCartDetail';
import { useListState } from '../../../app/hooks/useListState';
import { CartItem } from '../stores/useCartStore';
import {
  formatOrderStatus,
  formatOrderType,
  formatOrderTypeShort,
  getPaymentStatus,
  getStatusColor,
} from '../../../app/utils/orderFormatters';

type OpenOrdersScreenProps = NativeStackScreenProps<
  OrdersStackParamList,
  'OpenOrders'
>;

const OpenOrdersScreen: React.FC<OpenOrdersScreenProps> = ({ navigation }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [isPrintModalVisible, setIsPrintModalVisible] = useState(false);
  const [orderToPrint, setOrderToPrint] = useState<OrderOpenList | null>(null);
  const [acceptingOrderId, setAcceptingOrderId] = useState<string | null>(null);

  const user = useAuthStore((state) => state.user);
  const { data: shift, isLoading: shiftLoading } = useGlobalShift();
  const userCanOpenShift = canOpenShift(user);

  const [isEditModalVisible, setIsEditModalVisible] = useState(false);
  const [editingOrderId, setEditingOrderId] = useState<string | null>(null);
  const [pendingProductsToAdd, setPendingProductsToAdd] = useState<CartItem[]>(
    [],
  );
  const [temporaryProducts, setTemporaryProducts] = useState<{
    [orderId: string]: CartItem[];
  }>({});
  const [existingItemsCount, setExistingItemsCount] = useState<{
    [orderId: string]: number;
  }>({});

  const [selectedOrderType, setSelectedOrderType] = useState<
    OrderType | 'ALL' | 'WHATSAPP'
  >('ALL');

  const updateOrderMutation = useUpdateOrderMutation();
  const cancelOrderMutation = useCancelOrderMutation();

  const {
    data: ordersData,
    isLoading,
    isError,
    refetch,
    isFetching,
  } = useGetOpenOrdersListQuery();
  const filteredOrders = React.useMemo(() => {
    if (!ordersData) return [];

    if (selectedOrderType === 'ALL') {
      // En ALL, excluir pedidos de WhatsApp pendientes
      return ordersData.filter(
        (order) =>
          !(
            order.isFromWhatsApp &&
            order.orderStatus === OrderStatusEnum.PENDING
          ),
      );
    }

    if (selectedOrderType === 'WHATSAPP') {
      // Filtrar solo pedidos de WhatsApp con estado PENDING
      return ordersData.filter(
        (order) =>
          order.isFromWhatsApp && order.orderStatus === OrderStatusEnum.PENDING,
      );
    }

    // Para otros filtros (DINE_IN, TAKE_AWAY, DELIVERY), excluir pedidos de WhatsApp pendientes
    return ordersData.filter(
      (order) =>
        order.orderType === selectedOrderType &&
        !(
          order.isFromWhatsApp && order.orderStatus === OrderStatusEnum.PENDING
        ),
    );
  }, [ordersData, selectedOrderType]);

  const handleRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Función para abrir el modal de impresión
  const handleOpenPrintModal = useCallback((order: OrderOpenList) => {
    setOrderToPrint(order);
    setIsPrintModalVisible(true);
  }, []);

  const handleOrderItemPress = (order: OrderOpenList) => {
    // Guardar solo el ID y abrir el modal
    setEditingOrderId(order.id);
    setIsEditModalVisible(true);
  };

  const renderOrderItem = useCallback(
    ({ item: order }: { item: OrderOpenList }) => {
      // Construir el título según el tipo de orden
      let orderTitle = `#${order.shiftOrderNumber} • ${formatOrderTypeShort(order.orderType)}`;

      if (order.orderType === OrderTypeEnum.DINE_IN && order.table) {
        // Para mesas temporales, mostrar solo el nombre sin prefijo "Mesa"
        const tableDisplay = order.table.isTemporary
          ? order.table.name
          : `Mesa ${order.table.name || order.table.number || 'N/A'}`;
        orderTitle += ` • ${order.table.area?.name || 'Sin área'} • ${tableDisplay}`;
      } else if (order.orderType === OrderTypeEnum.TAKE_AWAY) {
        if (order.deliveryInfo?.recipientName) {
          orderTitle += ` • ${order.deliveryInfo.recipientName}`;
        }
        if (order.deliveryInfo?.recipientPhone) {
          orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;
        }
      } else if (order.orderType === OrderTypeEnum.DELIVERY) {
        if (order.deliveryInfo?.fullAddress) {
          orderTitle += ` • ${order.deliveryInfo.fullAddress}`;
        }
        if (order.deliveryInfo?.recipientPhone) {
          orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;
        }
      }

      const totalAmount =
        typeof order.total === 'string' ? parseFloat(order.total) : order.total;
      const totalPaid = order.paymentsSummary?.totalPaid || 0;
      const pendingAmount = totalAmount - totalPaid;

      return (
        <TouchableOpacity
          activeOpacity={0.95}
          onPress={() => handleOrderItemPress(order)}
        >
          <Card
            style={[
              styles.orderCard,
              {
                backgroundColor: theme.colors.surface,
              },
            ]}
            mode="elevated"
          >
            <Card.Content style={styles.cardContent}>
              <View style={styles.mainContainer}>
                <View style={styles.leftContainer}>
                  <Text
                    style={[
                      styles.orderNumber,
                      { color: theme.colors.onSurface },
                    ]}
                  >
                    {orderTitle}
                    <Text
                      style={[
                        styles.orderPrice,
                        {
                          color:
                            pendingAmount > 0 ? theme.colors.error : '#10B981',
                        },
                      ]}
                    >
                      {' • '}
                      {pendingAmount > 0
                        ? `Por pagar: $${pendingAmount.toFixed(2)}`
                        : `Pagado: $${totalAmount.toFixed(2)}`}
                    </Text>
                    {order.notes && (
                      <Text
                        style={[
                          styles.notesInline,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                        numberOfLines={1}
                      >
                        {' • '}
                        {order.notes}
                      </Text>
                    )}
                  </Text>
                  <View style={styles.timeAndPaymentRow}>
                    <Text
                      style={[
                        styles.orderTime,
                        { color: theme.colors.primary },
                      ]}
                    >
                      {format(new Date(order.createdAt), 'p', { locale: es })}
                    </Text>
                    {(() => {
                      const paymentStatus = getPaymentStatus(order);
                      const color =
                        paymentStatus === 'paid'
                          ? '#10B981'
                          : paymentStatus === 'partial'
                            ? '#F59E0B'
                            : '#EF4444';
                      const icon =
                        paymentStatus === 'paid'
                          ? '✓'
                          : paymentStatus === 'partial'
                            ? '½'
                            : '•';
                      return (
                        <View
                          style={[
                            styles.miniPaymentBadge,
                            { backgroundColor: color },
                          ]}
                        >
                          <Text style={styles.miniPaymentText}>{icon}</Text>
                        </View>
                      );
                    })()}

                    {/* Badge de WhatsApp */}
                    {order.isFromWhatsApp && (
                      <View
                        style={[
                          styles.inlinePreparationBadge,
                          {
                            backgroundColor: '#25D366',
                            borderColor: '#25D366',
                          },
                        ]}
                      >
                        <Icon source="whatsapp" size={12} color="#FFFFFF" />
                      </View>
                    )}

                    {order.preparationScreenStatuses &&
                      order.preparationScreenStatuses.length > 0 && (
                        <>
                          {order.preparationScreenStatuses.map(
                            (screen, index) => {
                              const backgroundColor =
                                screen.status === 'READY'
                                  ? '#4CAF50'
                                  : screen.status === 'IN_PROGRESS'
                                    ? '#FFA000'
                                    : theme.colors.surfaceVariant;

                              const textColor =
                                screen.status === 'READY' ||
                                screen.status === 'IN_PROGRESS'
                                  ? '#FFFFFF'
                                  : theme.colors.onSurfaceVariant;

                              return (
                                <View
                                  key={`${order.id}-screen-${index}`}
                                  style={[
                                    styles.inlinePreparationBadge,
                                    {
                                      backgroundColor,
                                      borderColor:
                                        backgroundColor ===
                                        theme.colors.surfaceVariant
                                          ? theme.colors.outline
                                          : backgroundColor,
                                    },
                                  ]}
                                >
                                  <Text
                                    style={[
                                      styles.inlinePreparationText,
                                      { color: textColor },
                                    ]}
                                  >
                                    {screen.status === 'READY'
                                      ? '✓ '
                                      : screen.status === 'IN_PROGRESS'
                                        ? '⏳ '
                                        : ''}
                                    🍳 {screen.name}
                                  </Text>
                                </View>
                              );
                            },
                          )}
                        </>
                      )}
                  </View>
                </View>

                <View style={styles.rightContainer}>
                  {order.createdBy && (
                    <Text style={styles.createdByText} numberOfLines={1}>
                      {order.createdBy.firstName && order.createdBy.lastName
                        ? `${order.createdBy.firstName} ${order.createdBy.lastName}`
                        : order.createdBy.username}
                    </Text>
                  )}
                  <Chip
                    mode="flat"
                    compact
                    style={[
                      styles.statusChip,
                      {
                        backgroundColor: getStatusColor(
                          order.orderStatus,
                          theme,
                        ),
                      },
                    ]}
                    textStyle={styles.statusChipText}
                  >
                    {formatOrderStatus(order.orderStatus)}
                  </Chip>
                  <View style={styles.actionsContainer}>
                    {selectedOrderType === 'WHATSAPP' &&
                    order.orderStatus === OrderStatusEnum.PENDING ? (
                      <Button
                        mode="contained"
                        icon="check"
                        onPress={() => handleAcceptWhatsAppOrder(order.id)}
                        disabled={acceptingOrderId === order.id}
                        loading={acceptingOrderId === order.id}
                        compact
                      >
                        Aceptar
                      </Button>
                    ) : (
                      <TouchableOpacity
                        style={styles.printContainer}
                        onPress={() => handleOpenPrintModal(order)}
                        activeOpacity={0.7}
                      >
                        <IconButton
                          icon="printer"
                          size={32}
                          style={styles.printButton}
                          disabled
                        />
                        {(order.ticketImpressionCount ?? 0) > 0 && (
                          <View style={styles.printCountBadge}>
                            <Text style={styles.printCountText}>
                              {order.ticketImpressionCount}
                            </Text>
                          </View>
                        )}
                      </TouchableOpacity>
                    )}
                  </View>
                </View>
              </View>
            </Card.Content>
          </Card>
        </TouchableOpacity>
      );
    },
    [
      handleOrderItemPress,
      handleOpenPrintModal,
      handleAcceptWhatsAppOrder,
      selectedOrderType,
      acceptingOrderId,
      theme,
      styles,
    ],
  );

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: filteredOrders,
    emptyConfig: {
      title:
        selectedOrderType === 'ALL'
          ? 'No hay órdenes abiertas'
          : selectedOrderType === 'WHATSAPP'
            ? 'No hay pedidos de WhatsApp pendientes'
            : `No hay órdenes de tipo ${formatOrderType(
                selectedOrderType as OrderType,
              )
                .replace(/[\u{1F37D}]|[\u{FE0F}]|[\u{1F961}]|[\u{1F69A}]/gu, '')
                .trim()}`,
      message:
        selectedOrderType === 'ALL'
          ? 'No hay órdenes abiertas en este momento.'
          : selectedOrderType === 'WHATSAPP'
            ? 'No hay pedidos de WhatsApp esperando aceptación.'
            : `No hay órdenes de este tipo en este momento.`,
      icon:
        selectedOrderType === 'WHATSAPP'
          ? 'whatsapp'
          : 'clipboard-text-outline',
    },
    errorConfig: {
      title: 'Error al cargar órdenes',
      message: 'No se pudieron cargar las órdenes. Verifica tu conexión.',
      icon: 'wifi-off',
      actionLabel: 'Reintentar',
      onAction: () => refetch(),
    },
  });

  // Efecto para configurar el botón de refrescar en el header
  useEffect(() => {
    navigation.setOptions({
      headerRight: () => (
        <Appbar.Action
          icon="refresh"
          iconColor={theme.colors.onPrimary}
          size={28}
          onPress={handleRefresh}
          disabled={isFetching} // Deshabilitar mientras se refresca
          style={styles.headerRefreshButton} // Agregar margen para mejor accesibilidad
        />
      ),
    });
  }, [navigation, handleRefresh, isFetching, theme.colors.onPrimary]); // Añadir dependencias

  // Efecto para sincronizar productos temporales con pendientes
  useEffect(() => {
    if (
      isEditModalVisible &&
      editingOrderId &&
      temporaryProducts[editingOrderId]
    ) {
      setPendingProductsToAdd(temporaryProducts[editingOrderId]);
    }
  }, [isEditModalVisible, editingOrderId, temporaryProducts]);

  // Función para manejar la impresión del ticket
  const handlePrint = useCallback(
    async (printerId: string, ticketType: 'GENERAL' | 'BILLING') => {
      if (!orderToPrint) return;

      try {
        await orderPrintService.printTicket(orderToPrint.id, {
          printerId,
          ticketType,
        });

        showSnackbar({
          message: 'Ticket impreso exitosamente',
          type: 'success',
        });

        // Refrescar la lista
        refetch();

        // Limpiar estado
        setOrderToPrint(null);
      } catch (error) {
        showSnackbar({
          message: 'Error al imprimir el ticket',
          type: 'error',
        });
      }
    },
    [orderToPrint, refetch, showSnackbar],
  );

  // Función para aceptar un pedido de WhatsApp
  const handleAcceptWhatsAppOrder = useCallback(
    async (orderId: string) => {
      if (acceptingOrderId !== null) return;

      setAcceptingOrderId(orderId);

      try {
        await updateOrderMutation.mutateAsync({
          orderId,
          payload: {
            orderStatus: OrderStatusEnum.IN_PROGRESS,
          },
        });

        showSnackbar({
          message: 'Pedido aceptado exitosamente',
          type: 'success',
        });

        refetch();
      } catch (error) {
        showSnackbar({
          message: 'Error al aceptar el pedido',
          type: 'error',
        });
      } finally {
        setAcceptingOrderId(null);
      }
    },
    [acceptingOrderId, updateOrderMutation, refetch, showSnackbar],
  );

  // Función para manejar la cancelación de una orden
  const handleCancelOrder = useCallback(
    async (orderId: string) => {
      try {
        await cancelOrderMutation.mutateAsync(orderId);
        // Cerrar el modal después de cancelar exitosamente
        setIsEditModalVisible(false);
        setEditingOrderId(null);
      } catch (error) {
        // El error se muestra a través del hook useCancelOrderMutation
      }
    },
    [cancelOrderMutation],
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      {!shiftLoading && (!shift || shift.status !== 'OPEN') ? (
        <View style={styles.container}>
          <View style={styles.emptyStateContainer}>
            <Icon
              source="store-alert"
              size={64}
              color={theme.colors.onSurfaceVariant}
            />
            <Text variant="headlineSmall" style={styles.emptyStateTitle}>
              Turno Cerrado
            </Text>
            <Text variant="bodyLarge" style={styles.emptyStateText}>
              {userCanOpenShift
                ? 'Para ver las órdenes abiertas, primero debes abrir el turno usando el indicador en la barra superior.'
                : 'El turno debe estar abierto para ver las órdenes. Contacta a un administrador.'}
            </Text>
          </View>
        </View>
      ) : isLoading && !ordersData ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>Cargando órdenes...</Text>
        </View>
      ) : (
        <>
          {/* Filtros de tipo de orden con el mismo diseño que finalización */}
          <Surface style={styles.header}>
            <View style={styles.headerContent}>
              <View style={styles.filterContainer}>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === 'ALL' && styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === 'ALL'
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType('ALL')}
                >
                  <Icon
                    source="view-grid"
                    size={26}
                    color={
                      selectedOrderType === 'ALL'
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === 'ALL'
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === 'ALL'
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === 'ALL'
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.DINE_IN &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.DINE_IN
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.DINE_IN)}
                >
                  <Icon
                    source="silverware-fork-knife"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.DINE_IN
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.DINE_IN &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.DINE_IN
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.DINE_IN
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.DINE_IN
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.DINE_IN &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.TAKE_AWAY &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.TAKE_AWAY
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.TAKE_AWAY)}
                >
                  <Icon
                    source="bag-personal"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.TAKE_AWAY
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.TAKE_AWAY &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.TAKE_AWAY &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.DELIVERY &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.DELIVERY
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.DELIVERY)}
                >
                  <Icon
                    source="moped"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.DELIVERY
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.DELIVERY &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.DELIVERY
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.DELIVERY
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.DELIVERY
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.DELIVERY &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === 'WHATSAPP' &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === 'WHATSAPP'
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType('WHATSAPP')}
                >
                  <Icon
                    source="whatsapp"
                    size={26}
                    color={
                      selectedOrderType === 'WHATSAPP'
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.isFromWhatsApp &&
                        o.orderStatus === OrderStatusEnum.PENDING,
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === 'WHATSAPP'
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === 'WHATSAPP'
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === 'WHATSAPP'
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.isFromWhatsApp &&
                                o.orderStatus === OrderStatusEnum.PENDING,
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
              </View>
            </View>
          </Surface>

          {/* Lista de órdenes */}
          <View style={styles.listContainer}>
            <FlashList
              data={filteredOrders}
              keyExtractor={(item) => item.id}
              renderItem={renderOrderItem}
              refreshing={isFetching}
              onRefresh={handleRefresh}
              contentContainerStyle={styles.listContentContainer}
              ListEmptyComponent={ListEmptyComponent}
              estimatedItemSize={120}
              removeClippedSubviews={true}
            />
          </View>
        </>
      )}
      {/* Modal de Impresión de Ticket */}
      <Portal>
        <PrintTicketModal
          visible={isPrintModalVisible}
          onDismiss={() => {
            setIsPrintModalVisible(false);
            setOrderToPrint(null);
          }}
          order={orderToPrint}
          onPrint={handlePrint}
        />
        {/* Modal de Edición de Orden usando OrderCartDetail */}
        {editingOrderId && (
            <OrderCartDetail
              visible={isEditModalVisible}
              isEditMode={true}
              orderId={editingOrderId}
              orderNumber={
                ordersData?.find((o) => o.id === editingOrderId)
                  ?.shiftOrderNumber
              }
              orderDate={
                ordersData?.find((o) => o.id === editingOrderId)?.createdAt
                  ? new Date(
                      ordersData.find(
                        (o) => o.id === editingOrderId,
                      )!.createdAt,
                    )
                  : undefined
              }
              navigation={navigation}
              pendingProductsToAdd={
                editingOrderId && temporaryProducts[editingOrderId]
                  ? temporaryProducts[editingOrderId]
                  : pendingProductsToAdd
              }
              onItemsCountChanged={(count) => {
                // Actualizar el conteo de items existentes para esta orden
                setExistingItemsCount((prev) => ({
                  ...prev,
                  [editingOrderId]: count,
                }));
              }}
              onClose={() => {
                setIsEditModalVisible(false);
                setEditingOrderId(null);
                setPendingProductsToAdd([]);
                // NO limpiar temporaryProducts aquí para mantener los productos
                // NO llamar refetch() aquí porque ya se maneja con invalidateQueries
                // y el refetchInterval automático
              }}
              onAddProducts={() => {
                // Cerrar el modal temporalmente para navegar
                setIsEditModalVisible(false);

                const orderNumber = ordersData?.find(
                  (o) => o.id === editingOrderId,
                )?.shiftOrderNumber;

                // Navegar a añadir productos
                setTimeout(() => {
                  const existingProducts =
                    temporaryProducts[editingOrderId!] || [];
                  navigation.navigate(NAVIGATION_PATHS.ADD_PRODUCTS_TO_ORDER, {
                    orderId: editingOrderId!,
                    orderNumber: orderNumber!,
                    // Pasar productos temporales existentes si los hay
                    existingTempProducts: existingProducts,
                    existingOrderItemsCount:
                      existingItemsCount[editingOrderId!] || 0, // Usar el conteo rastreado
                    onProductsAdded: (newProducts) => {
                      // Actualizar productos temporales para esta orden
                      setTemporaryProducts((prev) => ({
                        ...prev,
                        [editingOrderId!]: newProducts,
                      }));
                      // NO establecer pendingProductsToAdd aquí, se hará en el useEffect
                      // Reabrir el modal cuando regresemos
                      setIsEditModalVisible(true);
                    },
                  });
                }, 100);
              }}
              onConfirmOrder={async (details: OrderDetailsForBackend) => {
                // Adaptar el formato de OrderDetailsForBackend a UpdateOrderPayload
                const payload = {
                  orderType: details.orderType,
                  items: details.items, // Enviar items para actualizar
                  tableId: details.tableId || null,
                  isTemporaryTable: details.isTemporaryTable || false,
                  temporaryTableName: details.temporaryTableName || null,
                  temporaryTableAreaId: details.temporaryTableAreaId || null,
                  scheduledAt: details.scheduledAt || null,
                  // Enviar null cuando deliveryInfo está vacío para indicar limpieza
                  deliveryInfo: (() => {
                    if (!details.deliveryInfo) return null;

                    // Filtrar solo las propiedades que tienen valores reales (no undefined)
                    const filteredDeliveryInfo = Object.entries(
                      details.deliveryInfo,
                    )
                      .filter(([_, value]) => value !== undefined)
                      .reduce(
                        (acc, [key, value]) => ({ ...acc, [key]: value }),
                        {},
                      );

                    // Si no quedan propiedades con valores, enviar null
                    return Object.keys(filteredDeliveryInfo).length > 0
                      ? filteredDeliveryInfo
                      : null;
                  })(),
                  notes: details.notes || null,
                  total: details.total,
                  subtotal: details.subtotal,
                  adjustments: details.adjustments || [], // Incluir ajustes en el payload
                };

                try {
                  // Actualizar la orden (ahora incluye los ajustes)
                  await updateOrderMutation.mutateAsync({
                    orderId: editingOrderId,
                    payload,
                  });

                  // Limpiar estados después de actualización exitosa
                  setIsEditModalVisible(false);
                  setEditingOrderId(null);
                  // Limpiar productos temporales y conteo para esta orden
                  if (editingOrderId) {
                    setTemporaryProducts((prev) => {
                      const newState = { ...prev };
                      delete newState[editingOrderId];
                      return newState;
                    });
                    setExistingItemsCount((prev) => {
                      const newState = { ...prev };
                      delete newState[editingOrderId];
                      return newState;
                    });
                  }
                } catch (error) {
                  // No cerrar el modal en caso de error para que el usuario pueda reintentar
                }
              }}
              onCancelOrder={() => {
                if (editingOrderId) {
                  handleCancelOrder(editingOrderId);
                }
              }}
            />
        )}
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.isTablet ? theme.spacing.s : theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 16,
    },
    header: {
      paddingHorizontal: 0,
      paddingVertical: 0,
      backgroundColor: 'transparent',
      elevation: 0,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    filterContainer: {
      flex: 1,
      flexDirection: 'row',
      gap: 0,
    },
    filterButton: {
      flex: 1,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 0,
      elevation: 1,
      position: 'relative',
    },
    filterButtonActive: {
      elevation: 3,
    },
    countBadge: {
      position: 'absolute',
      top: responsive.isTablet ? 3 : 6,
      right: responsive.isTablet ? 3 : 6,
      minWidth: responsive.isTablet ? 18 : 22,
      height: responsive.isTablet ? 18 : 22,
      borderRadius: responsive.isTablet ? 9 : 11,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      borderWidth: 1,
      elevation: 2,
    },
    countBadgeText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '700',
    },
    listContainer: {
      flex: 1,
    },
    listContentContainer: {
      padding: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
      paddingBottom: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.l * 2,
    },
    orderCard: {
      marginBottom: responsive.isTablet ? 6 : 8,
    },
    cardContent: {
      paddingBottom: responsive.isTablet ? 6 : 8,
      paddingHorizontal: responsive.isTablet ? 12 : 16,
      paddingTop: responsive.isTablet ? 12 : 16,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: responsive.isTablet ? 6 : 8,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: responsive.isTablet ? 120 : 140,
      gap: responsive.isTablet ? 6 : 8,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: responsive.isTablet ? 2 : 4,
    },
    orderNumber: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: 'bold',
      lineHeight: responsive.isTablet ? 20 : 22,
      marginBottom: responsive.isTablet ? 2 : 4,
    },
    orderPrice: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '700',
    },
    statusChip: {
      minHeight: responsive.isTablet ? 22 : 24,
      alignSelf: 'flex-end',
      paddingVertical: responsive.isTablet ? 1 : 2,
    },
    statusChipText: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 13 : 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    paidChip: {
      height: responsive.isTablet ? 24 : 28,
      minHeight: responsive.isTablet ? 24 : 28,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    paidChipText: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 14 : 16,
    },
    orderTime: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: responsive.isTablet ? 12 : 14,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: responsive.isTablet ? 6 : 8,
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: responsive.isTablet ? 10 : 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: responsive.isTablet ? 10 : 11,
      fontWeight: '600',
      lineHeight: responsive.isTablet ? 12 : 14,
    },
    printButton: {
      margin: responsive.isTablet ? -6 : -4,
    },
    printContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: '#3B82F6',
      borderRadius: responsive.isTablet ? 8 : 10,
      minWidth: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      paddingHorizontal: responsive.isTablet ? 3 : 4,
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountText: {
      color: '#FFFFFF',
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: 'bold',
    },
    customerInfo: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.isTablet ? 13 : 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    phoneInfo: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    notesInline: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: responsive.isTablet ? 8 : 10,
      borderWidth: 0.5,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    inlinePreparationText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      borderRadius: responsive.isTablet ? 9 : 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: responsive.isTablet ? 4 : 6,
    },
    miniPaymentText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      borderRadius: responsive.isTablet ? 9 : 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    miniPreparationText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onSurfaceVariant,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    createdByText: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet ? 3 : 4,
      textAlign: 'right',
    },
    emptyStateContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.l,
    },
    emptyStateTitle: {
      marginTop: responsive.isTablet ? theme.spacing.m : theme.spacing.l,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.onSurface,
      fontWeight: '600',
      fontSize: responsive.isTablet ? 20 : 24,
    },
    emptyStateText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      maxWidth: responsive.isTablet ? 280 : 320,
      lineHeight: responsive.isTablet ? 20 : 24,
      fontSize: responsive.isTablet ? 14 : 16,
    },
    // Estilo adicional para eliminar inline style
    headerRefreshButton: {
      marginRight: 8,
    },
  });

export default OpenOrdersScreen;




================================================================
End of Codebase
================================================================
