================================================================
Directory Structure
================================================================
.claude/coomands/explore-plan-code-test.md
.claude/settings.local.json
.gitignore
.repomix/bundles.json
app/.eslintignore
app/.eslintrc.js
app/.gitignore
app/.prettierrc
app/android/app/src/main/res/xml/network_security_config.xml
app/app.config.js
app/App.tsx
app/babel.config.js
app/docs/guides/BUILD_LOCAL_GUIDE.md
app/docs/guides/BUILD_QUICKSTART.md
app/docs/guides/EAS_PROJECT_SETUP_GUIDE.md
app/docs/guides/FIRST_UPLOAD_GUIDE.md
app/docs/guides/PLAY_STORE_PUBLISHING.md
app/eas.json
app/index.ts
app/ios/.gitignore
app/ios/.xcode.env
app/ios/pizza.xcodeproj/project.pbxproj
app/ios/pizza.xcodeproj/xcshareddata/xcschemes/pizza.xcscheme
app/ios/pizza/AppDelegate.swift
app/ios/pizza/Images.xcassets/AppIcon.appiconset/Contents.json
app/ios/pizza/Images.xcassets/Contents.json
app/ios/pizza/Images.xcassets/SplashScreenBackground.colorset/Contents.json
app/ios/pizza/Info.plist
app/ios/pizza/pizza-Bridging-Header.h
app/ios/pizza/pizza.entitlements
app/ios/pizza/SplashScreen.storyboard
app/ios/pizza/Supporting/Expo.plist
app/ios/Podfile
app/ios/Podfile.properties.json
app/metro.config.js
app/package.json
app/plugins/withCustomIcons.js
app/scripts/check-new-arch-compatibility.js
app/scripts/dev/reset-project.sh
app/scripts/install-android-sdk.sh
app/scripts/install-java.sh
app/scripts/release-to-playstore.sh
app/scripts/verify-android-setup.sh
app/src/app/components/common/AdaptiveModal.tsx
app/src/app/components/common/AnimatedLabelInput.tsx
app/src/app/components/common/AnimatedLabelSelector.tsx
app/src/app/components/common/AutoImage.tsx
app/src/app/components/common/ConfirmationModal.tsx
app/src/app/components/common/CustomImagePicker.tsx
app/src/app/components/common/EmptyState.tsx
app/src/app/components/common/GlobalSnackbar.tsx
app/src/app/components/common/PhoneNumberInput.tsx
app/src/app/components/common/SpeechRecognitionInput.tsx
app/src/app/components/ConnectionErrorModal.tsx
app/src/app/components/ConnectionIndicator.tsx
app/src/app/components/crud/GenericDetailModal.tsx
app/src/app/components/crud/GenericFormModal.tsx
app/src/app/components/crud/GenericList.tsx
app/src/app/components/DateTimePickerSafe.tsx
app/src/app/components/OrientationTransition.tsx
app/src/app/components/responsive/index.ts
app/src/app/components/responsive/ResponsiveGrid.tsx
app/src/app/components/responsive/ResponsiveImage.tsx
app/src/app/components/responsive/ResponsiveModal.tsx
app/src/app/components/responsive/ResponsiveView.tsx
app/src/app/components/ServerConfigModal.tsx
app/src/app/components/ShiftIndicator.tsx
app/src/app/constants/apiErrorCodes.ts
app/src/app/constants/apiPaths.ts
app/src/app/constants/navigationPaths.ts
app/src/app/constants/network.ts
app/src/app/constants/rolePermissions.ts
app/src/app/constants/storageKeys.ts
app/src/app/docs/DateTimePickerUsage.md
app/src/app/docs/RESPONSIVE_GUIDE.md
app/src/app/hooks/useCrudScreenLogic.ts
app/src/app/hooks/useGlobalShift.ts
app/src/app/hooks/useInitializeAuth.ts
app/src/app/hooks/useListState.ts
app/src/app/hooks/useNativeDriver.ts
app/src/app/hooks/useRefreshOnFocus.ts
app/src/app/hooks/useResponsive.ts
app/src/app/hooks/useServerConnection.ts
app/src/app/lib/errorMapping.ts
app/src/app/lib/errors.ts
app/src/app/lib/formatters.ts
app/src/app/lib/IMAGE_CACHE_GUIDE.md
app/src/app/lib/imageCache.ts
app/src/app/lib/imageUploadService.ts
app/src/app/lib/imageUtils.ts
app/src/app/lib/zodResolver.ts
app/src/app/navigation/AppDrawerNavigator.tsx
app/src/app/navigation/AppNavigator.tsx
app/src/app/navigation/AuthStack.tsx
app/src/app/navigation/components/CustomDrawerContent.tsx
app/src/app/navigation/components/WebDrawer.tsx
app/src/app/navigation/components/WebDrawerContent.tsx
app/src/app/navigation/ConditionalAppNavigator.tsx
app/src/app/navigation/helpers/navigationHelpers.ts
app/src/app/navigation/KitchenOnlyNavigator.tsx
app/src/app/navigation/KitchenWebNavigator.tsx
app/src/app/navigation/options.ts
app/src/app/navigation/OrdersStackNavigator.tsx
app/src/app/navigation/types.ts
app/src/app/schemas/domain/adjustment.schema.ts
app/src/app/schemas/domain/area.schema.ts
app/src/app/schemas/domain/category.schema.ts
app/src/app/schemas/domain/delivery-info.schema.ts
app/src/app/schemas/domain/modifier-group.schema.ts
app/src/app/schemas/domain/modifier.schema.ts
app/src/app/schemas/domain/order.schema.ts
app/src/app/schemas/domain/photo.schema.ts
app/src/app/schemas/domain/preparation-screen.schema.ts
app/src/app/schemas/domain/product-variant.schema.ts
app/src/app/schemas/domain/product.schema.ts
app/src/app/schemas/domain/subcategory.schema.ts
app/src/app/schemas/domain/table.schema.ts
app/src/app/services/apiClient.ts
app/src/app/services/certificateValidator.ts
app/src/app/services/discoveryService.ts
app/src/app/services/secureStorageService.ts
app/src/app/store/authStore.ts
app/src/app/store/snackbarStore.ts
app/src/app/store/themeStore.ts
app/src/app/styles/colors.ts
app/src/app/styles/responsive.ts
app/src/app/styles/theme.ts
app/src/app/styles/typography.ts
app/src/app/types/api.types.ts
app/src/app/types/query.types.ts
app/src/app/types/theme.types.ts
app/src/app/utils/__tests__/dateTimeHelpers.test.ts
app/src/app/utils/dateTimeHelpers.ts
app/src/app/utils/orderFormatters.ts
app/src/app/utils/roleUtils.ts
app/src/app/utils/tokenVerification.ts
app/src/components/AudioOrderModal.tsx
app/src/components/AudioRecorderWidget.tsx
app/src/components/index.ts
app/src/hooks/useAudioRecorder.ts
app/src/hooks/useGoogleMapsConfig.ts
app/src/hooks/useOrientation.ts
app/src/hooks/useResponsiveFontScale.ts
app/src/hooks/useSnackbar.ts
app/src/modules/areasTables/components/AreaFormModal.tsx
app/src/modules/areasTables/components/TableFormModal.tsx
app/src/modules/areasTables/hooks/useAreasQueries.ts
app/src/modules/areasTables/hooks/useTablesQueries.ts
app/src/modules/areasTables/navigation/AreasTablesStackNavigator.tsx
app/src/modules/areasTables/navigation/types.ts
app/src/modules/areasTables/schema/area.schema.ts
app/src/modules/areasTables/schema/table.schema.ts
app/src/modules/areasTables/screens/AreasScreen.tsx
app/src/modules/areasTables/screens/TablesScreen.tsx
app/src/modules/areasTables/services/areaService.ts
app/src/modules/areasTables/services/tableService.ts
app/src/modules/areasTables/types/areasTables.types.ts
app/src/modules/auth/components/LoginForm.tsx
app/src/modules/auth/components/RegisterForm.tsx
app/src/modules/auth/schema/auth.schema.ts
app/src/modules/auth/screens/LoginScreen.tsx
app/src/modules/auth/services/authService.ts
app/src/modules/auth/types/auth.types.ts
app/src/modules/availability/components/AvailabilityListItem.tsx
app/src/modules/availability/components/CategoryAvailabilityItem.tsx
app/src/modules/availability/components/ModifierGroupAvailabilityItem.tsx
app/src/modules/availability/components/PizzaCustomizationAvailabilityItem.tsx
app/src/modules/availability/hooks/useAvailabilityQueries.ts
app/src/modules/availability/hooks/useOptimisticAvailability.ts
app/src/modules/availability/hooks/usePizzaCustomizationsAvailability.ts
app/src/modules/availability/navigation/AvailabilityStackNavigator.tsx
app/src/modules/availability/navigation/types.ts
app/src/modules/availability/screens/AvailabilityScreen.tsx
app/src/modules/availability/services/availabilityService.ts
app/src/modules/availability/types/availability.types.ts
app/src/modules/customers/components/AddressFormModal.tsx
app/src/modules/customers/components/CustomerFormModal.tsx
app/src/modules/customers/components/LocationPicker.tsx
app/src/modules/customers/constants/maps.config.ts
app/src/modules/customers/hooks/useCustomersQueries.ts
app/src/modules/customers/navigation/CustomersStackNavigator.tsx
app/src/modules/customers/schema/customer.schema.ts
app/src/modules/customers/screens/CustomersScreen.tsx
app/src/modules/customers/services/addressesService.ts
app/src/modules/customers/services/customersService.ts
app/src/modules/customers/types/customer.types.ts
app/src/modules/kitchen/components/KitchenFilterButton.tsx
app/src/modules/kitchen/components/OrderCard.tsx
app/src/modules/kitchen/components/OrderItemRow.tsx
app/src/modules/kitchen/components/RefreshButton.tsx
app/src/modules/kitchen/context/KitchenContext.tsx
app/src/modules/kitchen/hooks/useKitchenOrders.ts
app/src/modules/kitchen/hooks/useKitchenSnackbar.ts
app/src/modules/kitchen/navigation/KitchenNavigator.tsx
app/src/modules/kitchen/screens/KitchenOrdersScreen.tsx
app/src/modules/kitchen/services/kitchenService.ts
app/src/modules/kitchen/store/kitchenStore.ts
app/src/modules/kitchen/types/kitchen.types.ts
app/src/modules/menu/components/ProductFormModal.tsx
app/src/modules/menu/components/VariantFormModal.tsx
app/src/modules/menu/hooks/useProductsQueries.ts
app/src/modules/menu/hooks/useSubcategoriesQueries.ts
app/src/modules/menu/navigation/MenuStackNavigator.tsx
app/src/modules/menu/navigation/types.ts
app/src/modules/menu/schema/category.schema.ts
app/src/modules/menu/schema/products.schema.ts
app/src/modules/menu/schema/subcategories.schema.ts
app/src/modules/menu/screens/CategoriesScreen.tsx
app/src/modules/menu/screens/ProductsScreen.tsx
app/src/modules/menu/screens/SubcategoriesScreen.tsx
app/src/modules/menu/services/categoryService.ts
app/src/modules/menu/services/fileService.ts
app/src/modules/menu/services/productsService.ts
app/src/modules/menu/services/subcategoriesService.ts
app/src/modules/menu/types/category.types.ts
app/src/modules/menu/types/subcategories.types.ts
app/src/modules/modifiers/components/ModifierFormModal.tsx
app/src/modules/modifiers/components/ModifierGroupFormModal.tsx
app/src/modules/modifiers/hooks/useModifierGroupsQuery.ts
app/src/modules/modifiers/navigation/ModifiersStackNavigator.tsx
app/src/modules/modifiers/schema/modifier.schema.ts
app/src/modules/modifiers/schema/modifierGroup.schema.ts
app/src/modules/modifiers/screens/ModifierGroupsScreen.tsx
app/src/modules/modifiers/screens/ModifiersScreen.tsx
app/src/modules/modifiers/services/modifierGroupService.ts
app/src/modules/modifiers/services/modifierService.ts
app/src/modules/modifiers/types/modifier.types.ts
app/src/modules/orderFinalization/components/OrderCard.tsx
app/src/modules/orderFinalization/components/OrderDetailsModal.tsx
app/src/modules/orderFinalization/hooks/useOrderFinalizationQueries.ts
app/src/modules/orderFinalization/navigation/OrderFinalizationStackNavigator.tsx
app/src/modules/orderFinalization/navigation/types.ts
app/src/modules/orderFinalization/screens/OrderFinalizationScreen.tsx
app/src/modules/orderFinalization/services/orderFinalizationService.ts
app/src/modules/orderFinalization/types/orderFinalization.types.ts
app/src/modules/orders/components/AdjustmentFormModal.tsx
app/src/modules/orders/components/CartButton.tsx
app/src/modules/orders/components/ChangeCalculatorModal.tsx
app/src/modules/orders/components/CloseShiftModal.tsx
app/src/modules/orders/components/MenuItemCard.tsx
app/src/modules/orders/components/OpenShiftModal.tsx
app/src/modules/orders/components/OrderCartDetail.tsx
app/src/modules/orders/components/OrderDetailModal.tsx
app/src/modules/orders/components/OrderHeader.tsx
app/src/modules/orders/components/PaymentModal.tsx
app/src/modules/orders/components/PizzaCustomizationSection.tsx
app/src/modules/orders/components/PrinterSelectionModal.tsx
app/src/modules/orders/components/ProductCustomizationModal.tsx
app/src/modules/orders/components/ShiftStatusBanner.tsx
app/src/modules/orders/components/ShiftStatusModal.tsx
app/src/modules/orders/components/SimpleProductDescriptionModal.tsx
app/src/modules/orders/hooks/useAdjustmentQueries.ts
app/src/modules/orders/hooks/useMenuQueries.ts
app/src/modules/orders/hooks/useOrdersQueries.ts
app/src/modules/orders/hooks/usePaymentQueries.ts
app/src/modules/orders/screens/AddProductsToOrderScreen.tsx
app/src/modules/orders/screens/CreateOrderScreen.tsx
app/src/modules/orders/screens/OpenOrdersScreen.tsx
app/src/modules/orders/screens/OrdersScreen.tsx
app/src/modules/orders/services/adjustmentService.ts
app/src/modules/orders/services/orderPrintService.ts
app/src/modules/orders/services/orderService.ts
app/src/modules/orders/services/paymentService.ts
app/src/modules/orders/stores/useCartStore.ts
app/src/modules/orders/stores/useOrderFormStore.ts
app/src/modules/orders/types/adjustments.types.ts
app/src/modules/orders/types/orders.types.ts
app/src/modules/orders/types/payment.types.ts
app/src/modules/orders/types/update-order.types.ts
app/src/modules/payments/services/prepaymentService.ts
app/src/modules/pizzaCustomizations/components/AssociatePizzaToppingsModal.tsx
app/src/modules/pizzaCustomizations/components/index.ts
app/src/modules/pizzaCustomizations/components/PizzaConfigurationModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationCard.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationDetailModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationFormModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationsTab.tsx
app/src/modules/pizzaCustomizations/components/PizzaProductsTab.tsx
app/src/modules/pizzaCustomizations/hooks/usePizzaCustomizationsQueries.ts
app/src/modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator.tsx
app/src/modules/pizzaCustomizations/navigation/types.ts
app/src/modules/pizzaCustomizations/schema/pizzaConfiguration.schema.ts
app/src/modules/pizzaCustomizations/schema/pizzaCustomization.schema.ts
app/src/modules/pizzaCustomizations/screens/PizzaManagementScreen.tsx
app/src/modules/pizzaCustomizations/services/pizzaConfigurationsService.ts
app/src/modules/pizzaCustomizations/services/pizzaCustomizationsService.ts
app/src/modules/pizzaCustomizations/types/pizzaConfiguration.types.ts
app/src/modules/pizzaCustomizations/types/pizzaCustomization.types.ts
app/src/modules/preparationScreens/components/PreparationScreenDetailModalSimple.tsx
app/src/modules/preparationScreens/components/PreparationScreenFormModal.tsx
app/src/modules/preparationScreens/components/PreparationScreenListItem.tsx
app/src/modules/preparationScreens/components/ProductSelectionModal.tsx
app/src/modules/preparationScreens/hooks/usePreparationScreensQueries.ts
app/src/modules/preparationScreens/navigation/PreparationScreensStackNavigator.tsx
app/src/modules/preparationScreens/navigation/types.ts
app/src/modules/preparationScreens/schema/preparationScreen.schema.ts
app/src/modules/preparationScreens/screens/PreparationScreensScreen.tsx
app/src/modules/preparationScreens/services/preparationScreenService.ts
app/src/modules/printers/components/NumericField.tsx
app/src/modules/printers/components/PrinterAdvancedConfig.tsx
app/src/modules/printers/components/PrinterDetailModal.tsx
app/src/modules/printers/components/PrinterDiscoveryModal.tsx
app/src/modules/printers/components/PrinterFormModal.tsx
app/src/modules/printers/components/PrinterListItem.tsx
app/src/modules/printers/hooks/usePrintersQueries.ts
app/src/modules/printers/navigation/PrintersStackNavigator.tsx
app/src/modules/printers/navigation/types.ts
app/src/modules/printers/schema/printer.schema.ts
app/src/modules/printers/screens/PrintersScreen.tsx
app/src/modules/printers/services/printerService.ts
app/src/modules/printers/types/printer.types.ts
app/src/modules/receipts/components/ReceiptDetailsModal.tsx
app/src/modules/receipts/hooks/useReceiptsQueries.ts
app/src/modules/receipts/navigation/ReceiptsStackNavigator.tsx
app/src/modules/receipts/navigation/types.ts
app/src/modules/receipts/screens/ReceiptsScreen.tsx
app/src/modules/receipts/services/receiptService.ts
app/src/modules/receipts/types/receipt.types.ts
app/src/modules/restaurantConfig/components/BusinessHoursForm.tsx
app/src/modules/restaurantConfig/components/TimeZoneSelector.tsx
app/src/modules/restaurantConfig/components/WebViewDeliveryCoverageMap.tsx
app/src/modules/restaurantConfig/hooks/useRestaurantConfigQueries.ts
app/src/modules/restaurantConfig/navigation/RestaurantConfigStackNavigator.tsx
app/src/modules/restaurantConfig/navigation/types.ts
app/src/modules/restaurantConfig/screens/RestaurantConfigScreen.tsx
app/src/modules/restaurantConfig/services/restaurantConfigService.ts
app/src/modules/restaurantConfig/types/restaurantConfig.types.ts
app/src/modules/settings/navigation/SettingsStackNavigator.tsx
app/src/modules/settings/navigation/types.ts
app/src/modules/settings/screens/ServerSettingsScreen.tsx
app/src/modules/shared/components/OrderHistoryModal.tsx
app/src/modules/shared/components/OrderSummaryCard.tsx
app/src/modules/shared/components/PrintTicketModal.tsx
app/src/modules/shiftAudit/components/index.ts
app/src/modules/shiftAudit/components/OrderDetailsView.tsx
app/src/modules/shiftAudit/components/OrderHistoryView.tsx
app/src/modules/shiftAudit/components/ShiftOrdersModal.tsx
app/src/modules/shiftAudit/components/ShiftSalesSummaryView.tsx
app/src/modules/shiftAudit/hooks/useShiftOrders.ts
app/src/modules/shiftAudit/hooks/useShifts.ts
app/src/modules/shiftAudit/hooks/useShiftSalesSummary.ts
app/src/modules/shiftAudit/navigation/ShiftAuditStackNavigator.tsx
app/src/modules/shiftAudit/navigation/types.ts
app/src/modules/shiftAudit/screens/index.ts
app/src/modules/shiftAudit/screens/ShiftsListScreen.tsx
app/src/modules/shiftAudit/types/index.ts
app/src/modules/sync/navigation/SyncStackNavigator.tsx
app/src/modules/sync/screens/SyncStatusScreen.tsx
app/src/modules/sync/services/syncService.ts
app/src/modules/sync/types/sync.types.ts
app/src/modules/users/components/index.ts
app/src/modules/users/components/UserDetailModal.tsx
app/src/modules/users/components/UserFormModal.tsx
app/src/modules/users/hooks/index.ts
app/src/modules/users/hooks/useUsers.tsx
app/src/modules/users/navigation/UsersStackNavigator.tsx
app/src/modules/users/screens/index.ts
app/src/modules/users/screens/UsersListScreen.tsx
app/src/modules/users/services/index.ts
app/src/modules/users/services/usersApi.service.ts
app/src/modules/users/types/index.ts
app/src/modules/users/types/user.types.ts
app/src/services/appConfig.ts
app/src/services/audioOrderService.ts
app/src/services/audioServiceHealth.ts
app/src/services/autoReconnectService.ts
app/src/services/healthMonitoringService.ts
app/src/services/reconnectionSnackbarService.ts
app/src/services/serverConnectionService.ts
app/src/services/shifts.ts
app/tsconfig.json
backend/.cloudflared/config.yml
backend/.dockerignore
backend/.editorconfig
backend/.env.example
backend/.gitignore
backend/.hygen.js
backend/.hygen/generate/relational-resource/app-module-import.ejs.t
backend/.hygen/generate/relational-resource/app-module.ejs.t
backend/.hygen/generate/relational-resource/controller.ejs.t
backend/.hygen/generate/relational-resource/domain/domain.ejs.t
backend/.hygen/generate/relational-resource/dto/create.dto.ejs.t
backend/.hygen/generate/relational-resource/dto/domain.dto.ejs.t
backend/.hygen/generate/relational-resource/dto/find-all.dto.ejs.t
backend/.hygen/generate/relational-resource/dto/update.dto.ejs.t
backend/.hygen/generate/relational-resource/infrastructure/persistence/relational/entities/entity.ejs.t
backend/.hygen/generate/relational-resource/infrastructure/persistence/relational/mappers/mapper.ejs.t
backend/.hygen/generate/relational-resource/infrastructure/persistence/relational/relational-persistence.module.ejs.t
backend/.hygen/generate/relational-resource/infrastructure/persistence/relational/repositories/repository.ejs.t
backend/.hygen/generate/relational-resource/infrastructure/persistence/repository.ejs.t
backend/.hygen/generate/relational-resource/module.ejs.t
backend/.hygen/generate/relational-resource/service.ejs.t
backend/.hygen/property/add-to-relational/domain/domain-import.ejs.t
backend/.hygen/property/add-to-relational/domain/domain.ejs.t
backend/.hygen/property/add-to-relational/dto/01-create.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/02-create-import-class-transformer.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/03-create-import-class-validator.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/04-create-import-swagger.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/05-create-boolean.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/06-create-number.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/07-create-string.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/08-create-api-property.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/09-create-class-transformer-type.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/10-create-validate-is-array.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/11-create-validate-nested.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/12-create-validate-not-empty-object.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/13-create-type-dto-import.ejs.t
backend/.hygen/property/add-to-relational/dto/14-create-optional.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/15-create-date.dto.ejs.t
backend/.hygen/property/add-to-relational/dto/16-create-class-transformer-transform.dto.ejs.t
backend/.hygen/property/add-to-relational/index.js
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-column.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-join-column.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-many-to-many.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-many-to-one.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-one-to-many.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-one-to-one.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/type-import.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/mappers/mapper-domain.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/mappers/mapper-import.ejs.t
backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/mappers/mapper-persistence.ejs.t
backend/.hygen/property/add-to-relational/module-import.ejs.t
backend/.hygen/property/add-to-relational/module.ejs.t
backend/.hygen/property/add-to-relational/service-create-payload.ejs.t
backend/.hygen/property/add-to-relational/service-create.ejs.t
backend/.hygen/property/add-to-relational/service-import-http-code.ejs.t
backend/.hygen/property/add-to-relational/service-import-type-domain.ejs.t
backend/.hygen/property/add-to-relational/service-import.ejs.t
backend/.hygen/property/add-to-relational/service-inject.ejs.t
backend/.hygen/property/add-to-relational/service-update-payload.ejs.t
backend/.hygen/property/add-to-relational/service-update.ejs.t
backend/.hygen/seeds/create-relational/module.ejs.t
backend/.hygen/seeds/create-relational/run-seed-import.ejs.t
backend/.hygen/seeds/create-relational/run-seed-service.ejs.t
backend/.hygen/seeds/create-relational/seed-module-import.ejs.t
backend/.hygen/seeds/create-relational/seed-module.ejs.t
backend/.hygen/seeds/create-relational/service.ejs.t
backend/.nvmrc
backend/.prettierrc
backend/commitlint.config.js
backend/docker-compose.relational.ci.yaml
backend/docker-compose.relational.test.yaml
backend/docker-compose.yaml
backend/Dockerfile
backend/docs/architecture.md
backend/docs/auth.md
backend/docs/cli.md
backend/docs/CLOUDFLARE_TUNNEL_SETUP.md
backend/docs/database.md
backend/docs/file-uploading.md
backend/docs/installing-and-running.md
backend/docs/introduction.md
backend/docs/serialization.md
backend/eslint.config.mjs
backend/LICENSE
backend/maildev.Dockerfile
backend/nest-cli.json
backend/package.json
backend/Procfile
backend/relational.e2e.Dockerfile
backend/relational.test.Dockerfile
backend/renovate.json
backend/scripts/clear-migrations.ts
backend/scripts/drop-all-tables.ts
backend/scripts/reset-database.ts
backend/scripts/run-migrations.ts
backend/scripts/setup-cloudflare-tunnel.js
backend/scripts/start-with-tunnel.bat
backend/src/adjustments/adjustments.controller.ts
backend/src/adjustments/adjustments.module.ts
backend/src/adjustments/adjustments.service.ts
backend/src/adjustments/domain/adjustment.ts
backend/src/adjustments/dto/create-adjustment.dto.ts
backend/src/adjustments/dto/find-all-adjustments.dto.ts
backend/src/adjustments/dto/update-adjustment.dto.ts
backend/src/adjustments/infrastructure/persistence/adjustment.repository.ts
backend/src/adjustments/infrastructure/persistence/relational/entities/adjustment.entity.ts
backend/src/adjustments/infrastructure/persistence/relational/mappers/adjustment.mapper.ts
backend/src/adjustments/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/adjustments/infrastructure/persistence/relational/repositories/adjustment.repository.ts
backend/src/app-config/app-config.controller.ts
backend/src/app-config/app-config.module.ts
backend/src/app.module.ts
backend/src/areas/areas.controller.ts
backend/src/areas/areas.module.ts
backend/src/areas/areas.service.ts
backend/src/areas/domain/area.ts
backend/src/areas/dto/create-area.dto.ts
backend/src/areas/dto/find-all-areas.dto.ts
backend/src/areas/dto/update-area.dto.ts
backend/src/areas/infrastructure/persistence/area.repository.ts
backend/src/areas/infrastructure/persistence/relational/entities/area.entity.ts
backend/src/areas/infrastructure/persistence/relational/mappers/area.mapper.ts
backend/src/areas/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/areas/infrastructure/persistence/relational/repositories/area.repository.ts
backend/src/audio-order-processing/audio-order-processing.module.ts
backend/src/audio-order-processing/config/audio-order-config.type.ts
backend/src/audio-order-processing/config/audio-order.config.ts
backend/src/audio-order-processing/controllers/audio-order-processing.controller.ts
backend/src/audio-order-processing/dto/process-audio-order.dto.ts
backend/src/audio-order-processing/README.md
backend/src/audio-order-processing/services/audio-order-processing.service.ts
backend/src/auth/auth-providers.enum.ts
backend/src/auth/auth.controller.ts
backend/src/auth/auth.module.ts
backend/src/auth/auth.service.ts
backend/src/auth/config/auth-config.type.ts
backend/src/auth/config/auth.config.ts
backend/src/auth/decorators/current-user.decorator.ts
backend/src/auth/dto/auth-confirm-email.dto.ts
backend/src/auth/dto/auth-email-login.dto.ts
backend/src/auth/dto/auth-forgot-password.dto.ts
backend/src/auth/dto/auth-register-login.dto.ts
backend/src/auth/dto/auth-reset-password.dto.ts
backend/src/auth/dto/auth-update.dto.ts
backend/src/auth/dto/login-response.dto.ts
backend/src/auth/dto/refresh-response.dto.ts
backend/src/auth/strategies/anonymous.strategy.ts
backend/src/auth/strategies/jwt-refresh.strategy.ts
backend/src/auth/strategies/jwt.strategy.ts
backend/src/auth/strategies/types/jwt-payload.type.ts
backend/src/auth/strategies/types/jwt-refresh-payload.type.ts
backend/src/availability/availability.controller.ts
backend/src/availability/availability.module.ts
backend/src/availability/availability.service.ts
backend/src/availability/dto/availability-update.dto.ts
backend/src/availability/dto/menu-availability.dto.ts
backend/src/categories/categories.controller.ts
backend/src/categories/categories.module.ts
backend/src/categories/categories.service.ts
backend/src/categories/domain/category.ts
backend/src/categories/dto/create-category.dto.ts
backend/src/categories/dto/find-all-categories.dto.ts
backend/src/categories/dto/update-category.dto.ts
backend/src/categories/infrastructure/persistence/category.repository.ts
backend/src/categories/infrastructure/persistence/relational/entities/category.entity.ts
backend/src/categories/infrastructure/persistence/relational/mappers/category.mapper.ts
backend/src/categories/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/categories/infrastructure/persistence/relational/repositories/categories.repository.ts
backend/src/common/application/base-crud.service.ts
backend/src/common/common.module.ts
backend/src/common/constants/error-codes.constants.ts
backend/src/common/domain/repositories/base.repository.ts
backend/src/common/dto/pagination-query.dto.ts
backend/src/common/exceptions/custom-conflict.exception.ts
backend/src/common/filters/http-exception.filter.ts
backend/src/common/filters/unique-violation.filter.ts
backend/src/common/infrastructure/persistence/relational/base-relational.repository.ts
backend/src/common/interceptors/user-context.interceptor.ts
backend/src/common/mappers/base.mapper.ts
backend/src/common/presentation/crud-controller.factory.ts
backend/src/common/services/custom-id.service.ts
backend/src/common/services/user-context.service.ts
backend/src/common/tokens.ts
backend/src/common/types/paginated.type.ts
backend/src/config/app-config.type.ts
backend/src/config/app.config.ts
backend/src/config/config.type.ts
backend/src/customers/addresses.controller.ts
backend/src/customers/addresses.service.ts
backend/src/customers/customers.controller.ts
backend/src/customers/customers.module.ts
backend/src/customers/customers.service.ts
backend/src/customers/domain/address.ts
backend/src/customers/domain/customer.ts
backend/src/customers/dto/ban-customer.dto.ts
backend/src/customers/dto/create-address.dto.ts
backend/src/customers/dto/create-customer.dto.ts
backend/src/customers/dto/find-all-addresses.dto.ts
backend/src/customers/dto/find-all-customers.dto.ts
backend/src/customers/dto/update-address.dto.ts
backend/src/customers/dto/update-customer.dto.ts
backend/src/customers/infrastructure/persistence/address.repository.ts
backend/src/customers/infrastructure/persistence/customer.repository.ts
backend/src/customers/infrastructure/persistence/relational/entities/address.entity.ts
backend/src/customers/infrastructure/persistence/relational/entities/customer.entity.ts
backend/src/customers/infrastructure/persistence/relational/mappers/address.mapper.ts
backend/src/customers/infrastructure/persistence/relational/mappers/customer.mapper.ts
backend/src/customers/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/customers/infrastructure/persistence/relational/repositories/address.repository.ts
backend/src/customers/infrastructure/persistence/relational/repositories/customer.repository.ts
backend/src/database/config/database-config.type.ts
backend/src/database/config/database.config.ts
backend/src/database/data-source.ts
backend/src/database/migrations/1737313200000-AddMinimumOrderValueForDelivery.ts
backend/src/database/migrations/1752788001059-InitialSchema.ts
backend/src/database/seeds/relational/area/area-seed.module.ts
backend/src/database/seeds/relational/area/area-seed.service.ts
backend/src/database/seeds/relational/insert-missing-roles.ts
backend/src/database/seeds/relational/preparation-screen/preparation-screen-seed.module.ts
backend/src/database/seeds/relational/preparation-screen/preparation-screen-seed.service.ts
backend/src/database/seeds/relational/product/product-seed.module.ts
backend/src/database/seeds/relational/product/product-seed.service.ts
backend/src/database/seeds/relational/restaurant-config/restaurant-config-seed.module.ts
backend/src/database/seeds/relational/restaurant-config/restaurant-config-seed.service.ts
backend/src/database/seeds/relational/role/role-seed.module.ts
backend/src/database/seeds/relational/role/role-seed.service.ts
backend/src/database/seeds/relational/run-seed.ts
backend/src/database/seeds/relational/seed.module.ts
backend/src/database/seeds/relational/table/table-seed.module.ts
backend/src/database/seeds/relational/table/table-seed.service.ts
backend/src/database/seeds/relational/user/user-seed.module.ts
backend/src/database/seeds/relational/user/user-seed.service.ts
backend/src/database/typeorm-config.service.ts
backend/src/discovery/discovery.controller.ts
backend/src/discovery/discovery.module.ts
backend/src/files/config/file-config.type.ts
backend/src/files/config/file.config.ts
backend/src/files/domain/file.ts
backend/src/files/dto/file.dto.ts
backend/src/files/files.module.ts
backend/src/files/files.service.ts
backend/src/files/infrastructure/persistence/file.repository.ts
backend/src/files/infrastructure/persistence/relational/entities/file.entity.ts
backend/src/files/infrastructure/persistence/relational/mappers/file.mapper.ts
backend/src/files/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/files/infrastructure/persistence/relational/repositories/file.repository.ts
backend/src/files/infrastructure/uploader/local/dto/file-response.dto.ts
backend/src/files/infrastructure/uploader/local/files.controller.ts
backend/src/files/infrastructure/uploader/local/files.module.ts
backend/src/files/infrastructure/uploader/local/files.service.ts
backend/src/files/infrastructure/uploader/s3-presigned/dto/file-response.dto.ts
backend/src/files/infrastructure/uploader/s3-presigned/dto/file.dto.ts
backend/src/files/infrastructure/uploader/s3-presigned/files.controller.ts
backend/src/files/infrastructure/uploader/s3-presigned/files.module.ts
backend/src/files/infrastructure/uploader/s3-presigned/files.service.ts
backend/src/files/infrastructure/uploader/s3/dto/file-response.dto.ts
backend/src/files/infrastructure/uploader/s3/files.controller.ts
backend/src/files/infrastructure/uploader/s3/files.module.ts
backend/src/files/infrastructure/uploader/s3/files.service.ts
backend/src/files/infrastructure/uploader/upload.middleware.ts
backend/src/health/health.controller.ts
backend/src/health/health.module.ts
backend/src/home/home.controller.ts
backend/src/home/home.module.ts
backend/src/home/home.service.ts
backend/src/kitchen/controllers/kitchen.controller.ts
backend/src/kitchen/dto/kitchen-order-filter.dto.ts
backend/src/kitchen/dto/kitchen-order-optimized.dto.ts
backend/src/kitchen/dto/kitchen-order-response.dto.ts
backend/src/kitchen/dto/mark-item-prepared.dto.ts
backend/src/kitchen/kitchen.module.ts
backend/src/kitchen/services/kitchen.service.ts
backend/src/mail/config/mail-config.type.ts
backend/src/mail/config/mail.config.ts
backend/src/mail/interfaces/mail-data.interface.ts
backend/src/mail/mail-templates/activation.hbs
backend/src/mail/mail-templates/confirm-new-email.hbs
backend/src/mail/mail-templates/reset-password.hbs
backend/src/mail/mail.module.ts
backend/src/mail/mail.service.ts
backend/src/mailer/mailer.module.ts
backend/src/mailer/mailer.service.ts
backend/src/main.ts
backend/src/modifier-groups/domain/modifier-group.ts
backend/src/modifier-groups/dto/create-modifier-group.dto.ts
backend/src/modifier-groups/dto/find-all-modifier-groups.dto.ts
backend/src/modifier-groups/dto/update-modifier-group.dto.ts
backend/src/modifier-groups/infrastructure/persistence/modifier-group.repository.ts
backend/src/modifier-groups/infrastructure/persistence/relational/entities/modifier-group.entity.ts
backend/src/modifier-groups/infrastructure/persistence/relational/mappers/modifier-group.mapper.ts
backend/src/modifier-groups/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/modifier-groups/infrastructure/persistence/relational/repositories/modifier-group.repository.ts
backend/src/modifier-groups/modifier-groups.controller.ts
backend/src/modifier-groups/modifier-groups.module.ts
backend/src/modifier-groups/modifier-groups.service.ts
backend/src/orders/domain/delivery-info.ts
backend/src/orders/domain/enums/order-status.enum.ts
backend/src/orders/domain/enums/order-type.enum.ts
backend/src/orders/domain/enums/ticket-type.enum.ts
backend/src/orders/domain/order-item.ts
backend/src/orders/domain/order-preparation-screen-status.ts
backend/src/orders/domain/order.ts
backend/src/orders/domain/ticket-impression.ts
backend/src/orders/dto/create-order-item.dto.ts
backend/src/orders/dto/create-order.dto.ts
backend/src/orders/dto/delivery-info.dto.ts
backend/src/orders/dto/finalize-orders.dto.ts
backend/src/orders/dto/find-all-orders.dto.ts
backend/src/orders/dto/order-for-finalization-list.dto.ts
backend/src/orders/dto/order-for-finalization.dto.ts
backend/src/orders/dto/order-item-input.dto.ts
backend/src/orders/dto/order-open-list.dto.ts
backend/src/orders/dto/product-modifier.dto.ts
backend/src/orders/dto/receipt-detail.dto.ts
backend/src/orders/dto/receipt-list.dto.ts
backend/src/orders/dto/recover-order.dto.ts
backend/src/orders/dto/sales-summary.dto.ts
backend/src/orders/dto/update-order-item.dto.ts
backend/src/orders/dto/update-order.dto.ts
backend/src/orders/infrastructure/persistence/order-history.repository.ts
backend/src/orders/infrastructure/persistence/order-item.repository.ts
backend/src/orders/infrastructure/persistence/order-preparation-screen-status.repository.ts
backend/src/orders/infrastructure/persistence/order.repository.ts
backend/src/orders/infrastructure/persistence/relational/entities/delivery-info.entity.ts
backend/src/orders/infrastructure/persistence/relational/entities/order-history.entity.ts
backend/src/orders/infrastructure/persistence/relational/entities/order-item.entity.ts
backend/src/orders/infrastructure/persistence/relational/entities/order-preparation-screen-status.entity.ts
backend/src/orders/infrastructure/persistence/relational/entities/order.entity.ts
backend/src/orders/infrastructure/persistence/relational/entities/ticket-impression.entity.ts
backend/src/orders/infrastructure/persistence/relational/mappers/delivery-info.mapper.ts
backend/src/orders/infrastructure/persistence/relational/mappers/order-item.mapper.ts
backend/src/orders/infrastructure/persistence/relational/mappers/order-preparation-screen-status.mapper.ts
backend/src/orders/infrastructure/persistence/relational/mappers/order.mapper.ts
backend/src/orders/infrastructure/persistence/relational/mappers/ticket-impression.mapper.ts
backend/src/orders/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/orders/infrastructure/persistence/relational/repositories/order-history.repository.ts
backend/src/orders/infrastructure/persistence/relational/repositories/order-item.repository.ts
backend/src/orders/infrastructure/persistence/relational/repositories/order-preparation-screen-status.repository.ts
backend/src/orders/infrastructure/persistence/relational/repositories/order.repository.ts
backend/src/orders/infrastructure/persistence/relational/repositories/ticket-impression-relational.repository.ts
backend/src/orders/infrastructure/persistence/relational/subscribers/order.subscriber.ts
backend/src/orders/infrastructure/persistence/ticket-impression.repository.ts
backend/src/orders/order-change-log.service.ts
backend/src/orders/orders.controller.ts
backend/src/orders/orders.module.ts
backend/src/orders/orders.service.ts
backend/src/orders/services/order-change-tracker-v2.service.ts
backend/src/orders/services/pizza-price-calculator.service.ts
backend/src/orders/ticket-impressions.controller.ts
backend/src/payments/domain/enums/payment-method.enum.ts
backend/src/payments/domain/enums/payment-status.enum.ts
backend/src/payments/domain/payment.ts
backend/src/payments/dto/create-payment.dto.ts
backend/src/payments/dto/create-prepayment.dto.ts
backend/src/payments/dto/find-all-payments.dto.ts
backend/src/payments/dto/update-payment.dto.ts
backend/src/payments/infrastructure/persistence/payment.repository.ts
backend/src/payments/infrastructure/persistence/relational/entities/payment.entity.ts
backend/src/payments/infrastructure/persistence/relational/mappers/payment.mapper.ts
backend/src/payments/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/payments/infrastructure/persistence/relational/repositories/payment.repository.ts
backend/src/payments/payments.controller.ts
backend/src/payments/payments.module.ts
backend/src/payments/payments.service.ts
backend/src/pizza-configurations/domain/pizza-configuration.ts
backend/src/pizza-configurations/dto/create-pizza-configuration.dto.ts
backend/src/pizza-configurations/dto/update-pizza-configuration.dto.ts
backend/src/pizza-configurations/infrastructure/persistence/pizza-configuration.repository.ts
backend/src/pizza-configurations/infrastructure/persistence/relational/entities/pizza-configuration.entity.ts
backend/src/pizza-configurations/infrastructure/persistence/relational/mappers/pizza-configuration.mapper.ts
backend/src/pizza-configurations/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/pizza-configurations/infrastructure/persistence/relational/repositories/pizza-configuration.repository.ts
backend/src/pizza-configurations/pizza-configurations.controller.ts
backend/src/pizza-configurations/pizza-configurations.module.ts
backend/src/pizza-configurations/pizza-configurations.service.ts
backend/src/pizza-customizations/domain/enums/customization-type.enum.ts
backend/src/pizza-customizations/domain/pizza-customization.ts
backend/src/pizza-customizations/dto/create-pizza-customization.dto.ts
backend/src/pizza-customizations/dto/find-all-pizza-customizations.dto.ts
backend/src/pizza-customizations/dto/update-pizza-customization.dto.ts
backend/src/pizza-customizations/infrastructure/persistence/pizza-customization.repository.ts
backend/src/pizza-customizations/infrastructure/persistence/relational/entities/pizza-customization.entity.ts
backend/src/pizza-customizations/infrastructure/persistence/relational/mappers/pizza-customization.mapper.ts
backend/src/pizza-customizations/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/pizza-customizations/infrastructure/persistence/relational/repositories/pizza-customization.repository.ts
backend/src/pizza-customizations/pizza-customizations.controller.ts
backend/src/pizza-customizations/pizza-customizations.module.ts
backend/src/pizza-customizations/pizza-customizations.service.ts
backend/src/preparation-screens/domain/preparation-screen.ts
backend/src/preparation-screens/dto/assign-users.dto.ts
backend/src/preparation-screens/dto/associate-products.dto.ts
backend/src/preparation-screens/dto/create-preparation-screen.dto.ts
backend/src/preparation-screens/dto/find-all-preparation-screens.dto.ts
backend/src/preparation-screens/dto/update-preparation-screen.dto.ts
backend/src/preparation-screens/infrastructure/persistence/preparation-screen.repository.ts
backend/src/preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity.ts
backend/src/preparation-screens/infrastructure/persistence/relational/mappers/preparation-screen.mapper.ts
backend/src/preparation-screens/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/preparation-screens/infrastructure/persistence/relational/repositories/preparation-screen.repository.ts
backend/src/preparation-screens/preparation-screens.controller.ts
backend/src/preparation-screens/preparation-screens.module.ts
backend/src/preparation-screens/preparation-screens.service.ts
backend/src/product-modifiers/domain/product-modifier.ts
backend/src/product-modifiers/dto/create-product-modifier.dto.ts
backend/src/product-modifiers/dto/find-all-product-modifiers.dto.ts
backend/src/product-modifiers/dto/update-product-modifier.dto.ts
backend/src/product-modifiers/infrastructure/persistence/product-modifier.repository.ts
backend/src/product-modifiers/infrastructure/persistence/relational/entities/product-modifier.entity.ts
backend/src/product-modifiers/infrastructure/persistence/relational/mappers/product-modifier.mapper.ts
backend/src/product-modifiers/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/product-modifiers/product-modifiers.controller.ts
backend/src/product-modifiers/product-modifiers.module.ts
backend/src/product-modifiers/product-modifiers.service.ts
backend/src/product-variants/domain/product-variant.ts
backend/src/product-variants/dto/create-product-variant.dto.ts
backend/src/product-variants/dto/find-all-product-variants.dto.ts
backend/src/product-variants/dto/update-product-variant.dto.ts
backend/src/product-variants/infrastructure/persistence/product-variant.repository.ts
backend/src/product-variants/infrastructure/persistence/relational/entities/product-variant.entity.ts
backend/src/product-variants/infrastructure/persistence/relational/mappers/product-variant.mapper.ts
backend/src/product-variants/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/product-variants/infrastructure/persistence/relational/repositories/product-variant.repository.ts
backend/src/product-variants/product-variants.controller.ts
backend/src/product-variants/product-variants.module.ts
backend/src/product-variants/product-variants.service.ts
backend/src/products/domain/product.ts
backend/src/products/dto/assign-modifier-groups.dto.ts
backend/src/products/dto/create-product.dto.ts
backend/src/products/dto/find-all-products.dto.ts
backend/src/products/dto/update-product.dto.ts
backend/src/products/infrastructure/persistence/product.repository.ts
backend/src/products/infrastructure/persistence/relational/entities/product.entity.ts
backend/src/products/infrastructure/persistence/relational/mappers/product.mapper.ts
backend/src/products/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/products/infrastructure/persistence/relational/repositories/product.repository.ts
backend/src/products/products.controller.ts
backend/src/products/products.module.ts
backend/src/products/products.service.ts
backend/src/restaurant-config/domain/business-hours.ts
backend/src/restaurant-config/domain/restaurant-config.ts
backend/src/restaurant-config/dto/business-hours.dto.ts
backend/src/restaurant-config/dto/create-business-hours.dto.ts
backend/src/restaurant-config/dto/restaurant-config.dto.ts
backend/src/restaurant-config/dto/update-business-hours.dto.ts
backend/src/restaurant-config/dto/update-restaurant-config.dto.ts
backend/src/restaurant-config/infrastructure/persistence/relational/entities/business-hours.entity.ts
backend/src/restaurant-config/infrastructure/persistence/relational/entities/restaurant-config.entity.ts
backend/src/restaurant-config/infrastructure/persistence/relational/mappers/business-hours.mapper.ts
backend/src/restaurant-config/infrastructure/persistence/relational/mappers/restaurant-config.mapper.ts
backend/src/restaurant-config/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/restaurant-config/infrastructure/persistence/relational/repositories/restaurant-config.repository.ts
backend/src/restaurant-config/infrastructure/persistence/restaurant-config.repository.ts
backend/src/restaurant-config/restaurant-config.controller.ts
backend/src/restaurant-config/restaurant-config.module.ts
backend/src/restaurant-config/restaurant-config.service.ts
backend/src/roles/domain/role.ts
backend/src/roles/dto/role.dto.ts
backend/src/roles/infrastructure/persistence/relational/entities/role.entity.ts
backend/src/roles/roles.decorator.ts
backend/src/roles/roles.enum.ts
backend/src/roles/roles.guard.ts
backend/src/selected-pizza-customizations/domain/enums/customization-action.enum.ts
backend/src/selected-pizza-customizations/domain/enums/pizza-half.enum.ts
backend/src/selected-pizza-customizations/domain/selected-pizza-customization.ts
backend/src/selected-pizza-customizations/dto/create-selected-pizza-customization.dto.ts
backend/src/selected-pizza-customizations/infrastructure/persistence/relational/entities/selected-pizza-customization.entity.ts
backend/src/session/domain/session.ts
backend/src/session/infrastructure/persistence/relational/entities/session.entity.ts
backend/src/session/infrastructure/persistence/relational/mappers/session.mapper.ts
backend/src/session/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/session/infrastructure/persistence/relational/repositories/session.repository.ts
backend/src/session/infrastructure/persistence/session.repository.ts
backend/src/session/session.module.ts
backend/src/session/session.service.ts
backend/src/shifts/domain/shift.ts
backend/src/shifts/dto/close-shift.dto.ts
backend/src/shifts/dto/open-shift.dto.ts
backend/src/shifts/dto/shift-summary.dto.ts
backend/src/shifts/infrastructure/persistence/relational/entities/shift.entity.ts
backend/src/shifts/infrastructure/persistence/relational/mappers/shift.mapper.ts
backend/src/shifts/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/shifts/infrastructure/persistence/relational/repositories/shift.repository.ts
backend/src/shifts/infrastructure/persistence/shift.repository.ts
backend/src/shifts/shifts.controller.ts
backend/src/shifts/shifts.module.ts
backend/src/shifts/shifts.service.ts
backend/src/subcategories/domain/subcategory.ts
backend/src/subcategories/dto/create-subcategory.dto.ts
backend/src/subcategories/dto/find-all-subcategories.dto.ts
backend/src/subcategories/dto/update-subcategory.dto.ts
backend/src/subcategories/infrastructure/persistence/relational/entities/subcategory.entity.ts
backend/src/subcategories/infrastructure/persistence/relational/mappers/subcategory.mapper.ts
backend/src/subcategories/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/subcategories/infrastructure/persistence/relational/repositories/subcategories.repository.ts
backend/src/subcategories/infrastructure/persistence/subcategory.repository.ts
backend/src/subcategories/subcategories.controller.ts
backend/src/subcategories/subcategories.module.ts
backend/src/subcategories/subcategories.service.ts
backend/src/sync/config/sync-config.type.ts
backend/src/sync/config/sync.config.ts
backend/src/sync/controllers/sync.controller.ts
backend/src/sync/dto/pull-changes-request.dto.ts
backend/src/sync/dto/pull-changes-response.dto.ts
backend/src/sync/dto/restaurant-data-query.dto.ts
backend/src/sync/dto/restaurant-data-response.dto.ts
backend/src/sync/dto/update-order-status-response.dto.ts
backend/src/sync/dto/update-order-status.dto.ts
backend/src/sync/infrastructure/persistence/relational/entities/sync-activity.entity.ts
backend/src/sync/services/local-sync.service.ts
backend/src/sync/sync.module.ts
backend/src/tables/domain/table.ts
backend/src/tables/dto/create-table.dto.ts
backend/src/tables/dto/find-all-tables.dto.ts
backend/src/tables/dto/update-table.dto.ts
backend/src/tables/infrastructure/persistence/relational/entities/table.entity.ts
backend/src/tables/infrastructure/persistence/relational/mappers/table.mapper.ts
backend/src/tables/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/tables/infrastructure/persistence/relational/repositories/table.repository.ts
backend/src/tables/infrastructure/persistence/table.repository.ts
backend/src/tables/tables.controller.ts
backend/src/tables/tables.module.ts
backend/src/tables/tables.service.ts
backend/src/thermal-printers/automatic-printing.service.ts
backend/src/thermal-printers/discovery.service.ts
backend/src/thermal-printers/domain/thermal-printer.ts
backend/src/thermal-printers/dto/create-thermal-printer.dto.ts
backend/src/thermal-printers/dto/discovered-printer.dto.ts
backend/src/thermal-printers/dto/find-all-thermal-printers.dto.ts
backend/src/thermal-printers/dto/print-order.dto.ts
backend/src/thermal-printers/dto/update-thermal-printer.dto.ts
backend/src/thermal-printers/infrastructure/persistence/relational/entities/thermal-printer.entity.ts
backend/src/thermal-printers/infrastructure/persistence/relational/mappers/thermal-printer.mapper.ts
backend/src/thermal-printers/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/thermal-printers/infrastructure/persistence/relational/repositories/thermal-printer.repository.ts
backend/src/thermal-printers/infrastructure/persistence/thermal-printer.repository.ts
backend/src/thermal-printers/printing.controller.ts
backend/src/thermal-printers/printing.service.ts
backend/src/thermal-printers/thermal-printers.controller.ts
backend/src/thermal-printers/thermal-printers.module.ts
backend/src/thermal-printers/thermal-printers.service.ts
backend/src/thermal-printers/utils/advanced-ticket-example.ts
backend/src/thermal-printers/utils/ticket-formatter.ts
backend/src/users/domain/user.ts
backend/src/users/dto/create-user.dto.ts
backend/src/users/dto/query-user.dto.ts
backend/src/users/dto/update-user-preparation-screens.dto.ts
backend/src/users/dto/update-user.dto.ts
backend/src/users/dto/user.dto.ts
backend/src/users/enums/gender.enum.ts
backend/src/users/infrastructure/persistence/relational/entities/user.entity.ts
backend/src/users/infrastructure/persistence/relational/mappers/user.mapper.ts
backend/src/users/infrastructure/persistence/relational/relational-persistence.module.ts
backend/src/users/infrastructure/persistence/relational/repositories/user.repository.ts
backend/src/users/infrastructure/persistence/user.repository.ts
backend/src/users/users.controller.ts
backend/src/users/users.module.ts
backend/src/users/users.service.ts
backend/src/utils/deep-resolver.ts
backend/src/utils/dto/infinity-pagination-response.dto.ts
backend/src/utils/infinity-pagination.ts
backend/src/utils/relational-entity-helper.ts
backend/src/utils/serializer.interceptor.ts
backend/src/utils/transformers/lower-case.transformer.ts
backend/src/utils/transformers/transform-default.decorator.ts
backend/src/utils/types/deep-partial.type.ts
backend/src/utils/types/maybe.type.ts
backend/src/utils/types/nullable.type.ts
backend/src/utils/types/or-never.type.ts
backend/src/utils/types/pagination-options.ts
backend/src/utils/types/pagination-params.ts
backend/src/utils/validate-config.ts
backend/src/utils/validation-options.ts
backend/test/admin/auth.e2e-spec.ts
backend/test/admin/users.e2e-spec.ts
backend/test/jest-e2e.json
backend/test/user/auth.e2e-spec.ts
backend/test/utils/constants.ts
backend/tsconfig.build.json
backend/tsconfig.cli.json
backend/tsconfig.json
CLAUDE.md
Dockerfile
package.json
railway.json
shared/package.json
shared/src/index.ts
shared/src/types/customer.types.ts
shared/src/types/index.ts
shared/src/types/order.types.ts
shared/src/types/webhook.types.ts
shared/tsconfig.json

================================================================
Files
================================================================

================
File: .claude/coomands/explore-plan-code-test.md
================
At the end of this message, I will ask you to do something.
Please follow the "Explore, Plan, Code, Test" workflow when you start.

# Explore
First, use parallel subagents to find and read all files that may be useful for implementing the ticket, either as examples or as edit targets. The subagents should return relevant file paths, and any other info that may be useful.

# Plan
Next, think hard and write up a detailed implementation plan. Don’t forget to include tests, lookbook components, and documentation. Use your judgement as to what is necessary, given the standards of this repo.

If there are things you are not sure about, use parallel subagents to do some web research. They should only return useful information, no noise.

If there are things you still do not understand or questions you have for the user, pause here to ask them before continuing.

# Code
When you have a thorough implementation plan, you are ready to start writing code. Follow the style of the existing codebase (e.g. we prefer clearly named variables and methods to extensive comments). Make sure to run our autoformatting script when you're done, and fix linter warnings that seem reasonable to you.

# Test
Use parallel subagents to run tests, and make sure they all pass.

If your changes touch the UX in a major way, use the browser to make sure that everything works correctly. Make a list of what to test for, and use a subagent for this step.

If your testing shows problems, go back to the planning stage and think ultrahard.

# Write up your work
When you are happy with your work, write up a short report that could be used as the PR description. Include what you set out to do, the choices you made with their brief justification, and any commands you ran in the process that may be useful for future developers to know about.

================
File: .gitignore
================
# Root .gitignore for bite project

# OS Files
.DS_Store
Thumbs.db
*.swp
*.swo
*~
.AppleDouble
.LSOverride

# IDE and Editors
.idea/
.vscode/
*.sublime-project
*.sublime-workspace
.project
.classpath
.c9/
*.launch
.settings/

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/
.nyc_output/

# Build outputs
dist/
build/
out/
.next/
.nuxt/
.cache/

# Temporary files
tmp/
temp/
*.tmp
*.temp

# Package manager files
.npm/
.yarn-integrity
.yarn/

# Misc
*.pid
*.seed
*.pid.lock
.eslintcache
lint-results.json
*.backup.*
*.backup.tsx
*.backup.ts

# Backend specific (if running from root)
/backend/dist/
/backend/node_modules/
/backend/.env
/backend/files/
/backend/.data/
/backend/ormconfig.json
/backend/backend.log
/backend/*.log

# App specific (if running from root)
/app/node_modules/
/app/.expo/
/app/dist/
/app/web-build/
/app/ios/build/
/app/android/build/
/app/android/.gradle/
/app/*.jks
/app/*.p8
/app/*.p12
/app/*.key
/app/*.mobileprovision
/app/*.apk
/app/build-*.apk

# Documentation builds
docs/_build/
docs/.vuepress/dist/

# Certificates and keys
*.pem
*.crt
*.cer
*.pfx

# Archives
*.zip
*.tar.gz
*.rar
*.7z

# Database
*.sqlite
*.sqlite3
*.db

# Lock files (optional - uncomment if you don't want to track them)
# package-lock.json
# yarn.lock
# pnpm-lock.yaml

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: app/.eslintignore
================
node_modules/
android/
ios/
.expo/
dist/
build/
coverage/
*.config.js
*.config.ts
babel.config.js
metro.config.js
.eslintrc.js
fix-*.js
fix-*.sh
scripts/

================
File: app/.gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files


# Node
node_modules/

# Prebuild
# android/

# ios/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# Archivos específicos
roo-code-messages.log
repomix-output.txt
bundles.json

# Ignorar carpeta .repomix y su archivo bundles.json
.repomix/
.repomix/bundles.json

# @generated expo-cli sync-8d4afeec25ea8a192358fae2f8e2fc766bdce4ec
# The following patterns were generated by expo-cli

# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# @end expo-cli

*.apk

# Build files
build-*.apk
build-*.aab
build-*.ipa

# Google Play Service Account
google-play-service-account.json

# Temporary files
tmp/
temp/

================
File: app/.prettierrc
================
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "endOfLine": "lf"
}

================
File: app/docs/guides/BUILD_LOCAL_GUIDE.md
================
# Guía para Builds Locales con EAS

## Instalación Rápida (Scripts Automatizados)

Esta app incluye scripts automatizados para configurar todo el entorno necesario:

### 1. **Configuración Completa de Java y Expo**
```bash
cd app
./scripts/install-java.sh
source ~/.bashrc
```

### 2. **Instalación de Android SDK**
```bash
./scripts/install-android-sdk.sh
source ~/.bashrc
```

### 3. **Verificar el Entorno (Opcional)**
```bash
./scripts/verify-android-setup.sh  # Verifica la configuración
```

## Requisitos Previos (Instalación Manual)

### Para Android:

1. **Java Development Kit (JDK)**
   ```bash
   # Instalar OpenJDK 17 (recomendado para React Native)
   sudo apt update
   sudo apt install openjdk-17-jdk
   ```

2. **Android SDK**
   - Opción 1: Usar el script automatizado `./scripts/install-android-sdk.sh`
   - Opción 2: Instalar manualmente:
   ```bash
   # Crear directorio para Android SDK
   mkdir -p ~/Android/Sdk
   cd ~/Android/Sdk
   
   # Descargar herramientas de línea de comandos
   wget https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip
   unzip commandlinetools-linux-11076708_latest.zip
   mkdir -p cmdline-tools/latest
   mv cmdline-tools/* cmdline-tools/latest/
   ```

3. **Configurar variables de entorno**
   Agrega esto a tu `~/.bashrc` o `~/.zshrc`:
   ```bash
   export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
   export ANDROID_HOME=$HOME/Android/Sdk
   export ANDROID_SDK_ROOT=$HOME/Android/Sdk
   export PATH=$PATH:$JAVA_HOME/bin
   export PATH=$PATH:$ANDROID_HOME/emulator
   export PATH=$PATH:$ANDROID_HOME/platform-tools
   export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
   export PATH=$PATH:$ANDROID_HOME/tools
   export PATH=$PATH:$ANDROID_HOME/tools/bin
   ```

4. **Instalar componentes de Android SDK**
   ```bash
   # Después de configurar las variables de entorno
   source ~/.bashrc  # o ~/.zshrc
   
   # Instalar componentes necesarios
   sdkmanager "platform-tools" "platforms;android-34" "build-tools;34.0.0"
   sdkmanager "ndk;25.1.8937393"  # NDK necesario para React Native
   ```

5. **Configurar local.properties**
   ```bash
   echo "sdk.dir=$HOME/Android/Sdk" > android/local.properties
   ```

### Para iOS (solo en macOS):

1. **Xcode**
   - Instala desde App Store
   - Instala las herramientas de línea de comandos:
   ```bash
   xcode-select --install
   ```

2. **CocoaPods**
   ```bash
   sudo gem install cocoapods
   ```

## Construcción de Builds Locales

### Android

#### APK de Desarrollo (para pruebas):
```bash
cd app
npm run build:android:sim
```

#### APK para Dispositivo:
```bash
npm run build:android:dev
```

#### APK/AAB de Producción:
```bash
npm run build:android:prod
```

### iOS (solo en macOS)

#### Build para Simulador:
```bash
npm run build:ios:sim
```

#### Build para Dispositivo:
```bash
npm run build:ios:dev
```

#### Build de Producción:
```bash
npm run build:ios:prod
```

## Proceso de Build

1. **Primera vez**: EAS te pedirá autenticarte
   ```bash
   npx eas login
   ```

2. **Durante el build local**:
   - EAS descargará las herramientas necesarias
   - Compilará tu aplicación localmente
   - El archivo generado estará en la carpeta del proyecto

3. **Ubicación de los archivos generados**:
   - Android: `build-*.apk` o `build-*.aab`
   - iOS: `build-*.tar.gz` (contiene el .app o .ipa)

## Instalación en Dispositivos

### Android:

#### Instalar en Dispositivo Físico:
```bash
# 1. Habilita el modo desarrollador en tu dispositivo Android
# 2. Habilita la depuración USB
# 3. Conecta el dispositivo por USB
# 4. Verifica que el dispositivo esté conectado:
adb devices

# 5. Instalar el APK generado:
adb install build-*.apk
# o específicamente:
adb install build-1748967974325.apk
```

#### Instalar en Emulador:
```bash
# 1. Abrir emulador (si tienes Android Studio):
emulator -avd Pixel_6_API_34  # Reemplaza con el nombre de tu AVD

# 2. Instalar APK:
adb install build-*.apk
```

#### Ejecutar la App con Expo Dev Client:
```bash
# Una vez instalada la build de desarrollo, puedes ejecutar:
npm start

# Esto abrirá el servidor de desarrollo de Expo
# Escanea el código QR con la app instalada o presiona 'a' para Android
```

### iOS:
- Para simulador: Arrastra el .app al simulador
- Para dispositivo: Usa Xcode o herramientas como ios-deploy

## Solución de Problemas

### Error: "ANDROID_HOME not set"
Asegúrate de haber configurado las variables de entorno correctamente.

### Error: "SDK location not found"
Crea el archivo `local.properties` en `android/`:
```
sdk.dir=/home/tu-usuario/Android/Sdk
```

### Error de memoria durante el build
Aumenta la memoria de Gradle en `android/gradle.properties`:
```
org.gradle.jvmargs=-Xmx4096m -XX:MaxPermSize=1024m
```

## Notas Importantes

- Las builds locales requieren más recursos que las builds en la nube
- El primer build descargará muchas dependencias (puede tomar tiempo)
- Asegúrate de tener al menos 10GB de espacio libre
- Para producción, considera usar certificados y keystore apropiados

================
File: app/docs/guides/BUILD_QUICKSTART.md
================
# 🚀 Guía Rápida - Builds Locales

## Primera vez (Configuración)

```bash
# 1. Ejecutar scripts de instalación
cd app
./scripts/install-java.sh
./scripts/install-android-sdk.sh
source ~/.bashrc

# 2. Instalar EAS CLI y login
npm install -g eas-cli
eas login
```

## Crear Build Local

```bash
# Build de desarrollo para dispositivo Android
npm run build:android:sim

# El APK se generará como: build-[timestamp].apk
```

## Instalar en Dispositivo

```bash
# Ver dispositivos conectados
adb devices

# Instalar APK
adb install build-*.apk
```

## Ejecutar la App

```bash
# Para Expo Go
npx expo start

# Para Development Build (APK instalado)
npx expo start --dev-client

# Si tienes problemas de conexión de red, usa modo tunnel
npx expo start --tunnel          # Para Expo Go
npx expo start --dev-client --tunnel  # Para Development Build
```

**Nota:** El modo tunnel es más confiable para problemas de red aunque ligeramente más lento.

## Scripts Disponibles

| Script | Descripción |
|--------|-------------|
| `scripts/install-java.sh` | Instala Java 17 |
| `scripts/install-android-sdk.sh` | Instala Android SDK y configura el entorno |
| `scripts/verify-android-setup.sh` | Verifica la configuración del entorno |
| `scripts/fix-expo-packages.sh` | Actualiza y corrige versiones de paquetes Expo |

## Comandos de Build

| Comando | Descripción |
|---------|-------------|
| `npm run build:android:sim` | Build para emulador Android |
| `npm run build:android:dev` | Build para dispositivo Android (desarrollo) |
| `npm run build:android:prod` | Build de producción Android |

## Requisitos del Sistema

- Ubuntu/Debian
- Node.js >=18.18.0
- Java JDK 17
- Android SDK con API 34
- ~10GB de espacio libre

## Notas Importantes

- Las variables de entorno de Android SDK pueden no persistir entre sesiones
- Si encuentras errores de SDK, ejecuta `source ~/.bashrc` o crea el archivo `android/local.properties`
- Los builds locales con EAS pueden fallar si no se aceptan todas las licencias del Android SDK

## Troubleshooting

### Error: Cannot determine which native SDK version (expo module not installed)
```bash
# Este error ocurre cuando el módulo expo no está instalado
# Solución:
npm install expo
npx expo install --fix
```

### Error: could not determine executable to run (npx eas)
```bash
# Este error ocurre cuando EAS CLI no está instalado
# Solución:
npm install -g eas-cli
eas login  # En lugar de npx eas login
```

### Java no encontrado
```bash
./scripts/install-java.sh
source ~/.bashrc
```

### Android SDK no encontrado (Build local con EAS)
```bash
# 1. Instalar Android SDK
./scripts/install-android-sdk.sh
source ~/.bashrc

# 2. Si el error persiste, configurar variables en la sesión actual:
export ANDROID_HOME=$HOME/android-sdk
export ANDROID_SDK_ROOT=$HOME/android-sdk
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools

# 3. Crear local.properties
echo "sdk.dir=$HOME/android-sdk" > android/local.properties

# 4. Alternativa: Usar una shell con las variables cargadas
bash -c "source ~/.bashrc && npm run build:android:sim"

# 5. Si nada funciona, considerar usar build en la nube:
eas build --platform android --profile development  # Sin --local
```

### Dispositivo no detectado
```bash
# Verificar modo desarrollador y depuración USB
adb devices
adb kill-server
adb start-server
```

### Error: expo doctor failed
```bash
# Este error puede ignorarse si el resto del build funciona
# Es causado por tener carpetas android/ios en un proyecto Expo
# Si necesitas solucionarlo, añade a .gitignore:
/android
/ios
```

## Build Exitosa

Cuando la build sea exitosa verás:
```
Build successful
You can find the build artifacts in app/build-1748967974325.apk
```

================
File: app/docs/guides/EAS_PROJECT_SETUP_GUIDE.md
================
# Guía para Crear un Nuevo Proyecto EAS

Esta guía te ayudará a desvincular el proyecto actual de EAS y crear uno nuevo con el slug "bite-restaurant".

## Prerrequisitos

- Tener instalado EAS CLI: `npm install -g eas-cli`
- Estar logueado en tu cuenta de Expo: `eas login`
- Tener el proyecto React Native/Expo funcionando localmente

## Paso 1: Verificar el Estado Actual del Proyecto

```bash
cd app
eas project:info
```

Esto mostrará información sobre el proyecto actual vinculado a EAS (si existe).

## Paso 2: Desvincular el Proyecto Actual

### Opción A: Limpiar completamente la configuración (recomendado)

1. Eliminar el ID del proyecto del archivo `app.json`:
   ```json
   {
     "expo": {
       // Eliminar esta línea si existe:
       "extra": {
         "eas": {
           "projectId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
         }
       }
     }
   }
   ```

2. Eliminar la carpeta .expo si existe:
   ```bash
   rm -rf .expo
   ```

3. Verificar que no hay archivos de configuración EAS locales:
   ```bash
   # Estos archivos normalmente no existen, pero verificar por si acaso
   ls -la .easignore .eas.json 2>/dev/null
   ```

## Paso 3: Actualizar app.json con el Nuevo Slug

Editar `app/app.json` y asegurarse de que tenga la configuración correcta:

```json
{
  "expo": {
    "name": "Bite Restaurant",
    "slug": "bite-restaurant",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#FF6B6B"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.biterestaurant.app"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#FF6B6B"
      },
      "package": "com.biterestaurant.app"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "backgroundColor": "#FF6B6B",
          "image": "./assets/splash-icon.png",
          "imageWidth": 200
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    },
    "scheme": "bite-restaurant"
  }
}
```

## Paso 4: Crear el Nuevo Proyecto en EAS

```bash
# Inicializar EAS con el nuevo proyecto
eas init

# Si ya tienes un proyecto vinculado, usa:
eas project:init
```

Durante este proceso:
1. EAS detectará el slug "bite-restaurant"
2. Te preguntará si quieres crear un nuevo proyecto
3. Selecciona "Yes" para crear el nuevo proyecto
4. EAS generará un nuevo project ID y lo agregará a tu app.json

## Paso 5: Verificar la Configuración de EAS

Asegúrate de que `app/eas.json` esté configurado correctamente:

```json
{
  "cli": {
    "version": ">= 5.2.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "android": {
        "gradleCommand": ":app:assembleDebug"
      },
      "ios": {
        "buildConfiguration": "Debug"
      }
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
```

## Paso 6: Verificar el Nuevo Proyecto

```bash
# Verificar que el proyecto esté correctamente vinculado
eas project:info

# Debería mostrar:
# Project: bite-restaurant
# ID: [nuevo-project-id]
# Owner: [tu-usuario]
```

## Paso 7: Configurar los Secretos del Proyecto (Opcional)

Si tu proyecto necesita variables de entorno secretas:

```bash
# Configurar secretos para el nuevo proyecto
eas secret:create --name API_URL --value "https://tu-api.com"
eas secret:create --name OTRO_SECRETO --value "valor-secreto"

# Listar secretos configurados
eas secret:list
```

## Paso 8: Realizar una Build de Prueba

Para verificar que todo esté funcionando correctamente:

```bash
# Build de desarrollo para Android
eas build --platform android --profile development

# Build de desarrollo para iOS
eas build --platform ios --profile development
```

## Troubleshooting

### Error: "Project already exists"
Si EAS dice que el proyecto ya existe con ese slug:
1. Intenta con un slug diferente (ej: "bite-restaurant-app")
2. O contacta al soporte de Expo para liberar el slug si es tuyo

### Error: "Invalid project ID"
Si hay problemas con el project ID:
1. Elimina completamente la sección `extra.eas` de app.json
2. Ejecuta `eas init` nuevamente

### Error: "Authentication required"
Si tienes problemas de autenticación:
```bash
eas logout
eas login
```

## Notas Importantes

1. **Backup**: Antes de desvincular, asegúrate de tener un backup de cualquier configuración importante
2. **Builds anteriores**: Las builds del proyecto anterior seguirán disponibles en tu cuenta de Expo
3. **Colaboradores**: Si tienes colaboradores, deberán actualizar su configuración local después del cambio
4. **CI/CD**: Si usas CI/CD, actualiza las variables de entorno con el nuevo project ID

## Comandos Útiles

```bash
# Ver todos tus proyectos en EAS
eas project:list

# Ver información detallada del proyecto actual
eas project:info

# Ver el estado de las builds
eas build:list

# Cancelar una build en progreso
eas build:cancel [build-id]
```

## Siguiente Paso

Una vez completada la configuración, puedes continuar con el desarrollo normal:

```bash
# Desarrollo local
npm start

# Crear builds
npm run build:android:dev
npm run build:ios:dev
```

================
File: app/docs/guides/FIRST_UPLOAD_GUIDE.md
================
# Guía para la Primera Subida a Play Store

## Generar y subir tu primer AAB (Android App Bundle)

### 1. Generar el AAB de producción

```bash
cd app

# Asegúrate de estar logueado en EAS
eas login

# Generar el AAB de producción
eas build --platform android --profile production
```

### 2. Descargar el AAB

Una vez que el build termine (aproximadamente 15-20 minutos):

1. Ve a https://expo.dev y busca tu build
2. Descarga el archivo `.aab` 
3. O usa el comando: `eas build:download --platform android`

### 3. Subir a Play Store

En la pantalla que estás viendo:

1. Haz clic en "Subir" (el botón junto a "Suelta los paquetes de aplicaciones aquí para subirlos")
2. Selecciona el archivo `.aab` que descargaste
3. Espera a que se procese

### 4. Completar información de la versión

Después de subir el AAB:

1. **Nombre de la versión**: Se llenará automáticamente (ej: "1.0.0")
2. **Notas de la versión**: Escribe algo como:
   ```
   - Versión inicial de Bite
   - Sistema de gestión de restaurante
   - Gestión de pedidos y mesas
   - Impresión térmica
   ```

3. Haz clic en "Guardar"

### 5. Configurar el lanzamiento

1. Ve a "Pruebas" → "Prueba interna"
2. Crea un nuevo lanzamiento
3. Agrega el AAB que subiste
4. Completa las notas de la versión
5. Revisa y lanza

## Importante

- Esta primera subida DEBE hacerse manualmente
- Después de esta primera subida, podrás usar la automatización con EAS Submit
- El AAB debe estar firmado (EAS lo hace automáticamente)
- Google Play procesará el AAB y generará APKs optimizados para cada dispositivo

## Próximos pasos

Una vez que hayas subido el primer AAB:

1. Completa todas las secciones requeridas en Play Console:
   - Descripción de la app
   - Capturas de pantalla
   - Categorización
   - Clasificación de contenido
   - Política de privacidad

2. Configura el Service Account para automatización futura
3. Usa `npm run release:playstore` para publicaciones futuras

================
File: app/docs/guides/PLAY_STORE_PUBLISHING.md
================
# Guía de Publicación en Google Play Store

Esta guía te ayudará a publicar tu app Bite en Google Play Store de forma automatizada usando EAS (Expo Application Services).

## Requisitos Previos

1. **Cuenta de Google Play Console** ($25 único pago)
   - Crear cuenta en: https://play.google.com/console
   - Crear tu primera aplicación en la consola

2. **Configuración inicial en Play Console**:
   - Crear aplicación nueva
   - Completar todas las secciones requeridas:
     - Detalles de la app
     - Clasificación de contenido
     - Política de privacidad
     - Información de contacto
   - Subir al menos un APK/AAB manualmente la primera vez

3. **Service Account para automatización**:
   - Ve a Play Console → Configuración → Acceso a API
   - Crear proyecto en Google Cloud Console
   - Habilitar Google Play Android Developer API
   - Crear Service Account con permisos de "Release Manager"
   - Descargar el archivo JSON de credenciales

## Configuración del Proyecto

### 1. Preparar app.json para producción

```json
{
  "expo": {
    "name": "Bite",
    "slug": "bite-restaurant",
    "version": "1.0.0",
    "android": {
      "package": "com.tuempresa.bite",
      "versionCode": 1,
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "permissions": []
    }
  }
}
```

### 2. Configurar eas.json para Play Store

```json
{
  "build": {
    "production": {
      "android": {
        "buildType": "app-bundle",
        "env": {
          "API_URL": "https://tu-api-produccion.com"
        }
      }
    }
  },
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "./google-play-service-account.json",
        "track": "internal",
        "releaseStatus": "draft",
        "changesNotSentForReview": false
      }
    }
  }
}
```

### 3. Variables de entorno para producción

Crear archivo `.env.production`:
```
API_URL=https://tu-api-produccion.com
```

## Proceso de Publicación Automatizado

### Método 1: Script NPM (Recomendado)

Agregar estos scripts a tu `package.json`:

```json
{
  "scripts": {
    "build:prod": "eas build --platform android --profile production",
    "submit:prod": "eas submit --platform android --profile production",
    "release:prod": "npm run build:prod && npm run submit:prod",
    "release:prod:auto": "eas build --platform android --profile production --auto-submit"
  }
}
```

### Método 2: GitHub Actions (CI/CD)

Crear `.github/workflows/release.yml`:

```yaml
name: Release to Play Store

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-submit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18
          
      - name: Setup Expo
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build and Submit
        run: eas build --platform android --profile production --auto-submit --non-interactive
```

## Pasos para Publicar

### Primera vez (configuración):

```bash
# 1. Login en EAS
eas login

# 2. Configurar el proyecto
eas build:configure

# 3. Guardar el service account JSON
cp ~/Downloads/tu-service-account.json ./google-play-service-account.json

# 4. Agregar a .gitignore
echo "google-play-service-account.json" >> .gitignore
```

### Publicación regular:

```bash
# Opción 1: Build y submit por separado
npm run build:prod
# Esperar a que termine el build
npm run submit:prod

# Opción 2: Todo automatizado
npm run release:prod:auto

# Opción 3: Con versión específica
eas build --platform android --profile production --auto-submit --message "Version 1.0.1: Bug fixes"
```

## Configuración de Tracks en Play Store

- **internal**: Testing interno (recomendado para empezar)
- **alpha**: Testing cerrado
- **beta**: Testing abierto
- **production**: Producción

Modificar en `eas.json`:
```json
"track": "internal"  // cambiar según necesites
```

## Automatización Completa con Script

Crear `scripts/release-to-playstore.sh`:

```bash
#!/bin/bash

# Colores para output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}🚀 Iniciando release a Play Store...${NC}"

# 1. Verificar que estamos en main
BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH" != "main" ]; then
    echo "❌ Debes estar en la rama main para hacer release"
    exit 1
fi

# 2. Actualizar version en app.json
echo -e "${YELLOW}📝 Ingresa la nueva versión (actual: $(node -p "require('./app.json').expo.version")):${NC}"
read VERSION

# 3. Actualizar versionCode
CURRENT_VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))

# 4. Actualizar app.json
node -e "
const fs = require('fs');
const appJson = require('./app.json');
appJson.expo.version = '$VERSION';
appJson.expo.android.versionCode = $NEW_VERSION_CODE;
fs.writeFileSync('./app.json', JSON.stringify(appJson, null, 2));
"

echo -e "${GREEN}✅ Versión actualizada a $VERSION (versionCode: $NEW_VERSION_CODE)${NC}"

# 5. Commit cambios
git add app.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# 6. Build y submit
echo -e "${YELLOW}🏗️  Iniciando build y submit...${NC}"
eas build --platform android --profile production --auto-submit --non-interactive

# 7. Push cambios
git push origin main --tags

echo -e "${GREEN}✅ Release completado!${NC}"
```

Hacer ejecutable:
```bash
chmod +x scripts/release-to-playstore.sh
```

## Tips y Mejores Prácticas

1. **Versionado**: Siempre incrementa `versionCode` para cada build
2. **Testing**: Usa track "internal" primero antes de producción
3. **Changelogs**: Mantén un CHANGELOG.md actualizado
4. **Assets**: Prepara todos los assets requeridos:
   - Screenshots (mínimo 2)
   - Feature graphic (1024x500)
   - Icono alta resolución (512x512)
5. **Monitoreo**: Configura Sentry o similar para crashes en producción

## Troubleshooting

- **Error de permisos**: Verifica que el Service Account tenga rol "Release Manager"
- **Build fallido**: Revisa los logs en https://expo.dev
- **Versión rechazada**: Incrementa `versionCode` e intenta de nuevo

================
File: app/ios/.gitignore
================
# OSX
#
.DS_Store

# Xcode
#
build/
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
xcuserdata
*.xccheckout
*.moved-aside
DerivedData
*.hmap
*.ipa
*.xcuserstate
project.xcworkspace
.xcode.env.local

# Bundle artifacts
*.jsbundle

# CocoaPods
/Pods/

================
File: app/ios/.xcode.env
================
# This `.xcode.env` file is versioned and is used to source the environment
# used when running script phases inside Xcode.
# To customize your local environment, you can create an `.xcode.env.local`
# file that is not versioned.

# NODE_BINARY variable contains the PATH to the node executable.
#
# Customize the NODE_BINARY variable here.
# For example, to use nvm with brew, add the following line
# . "$(brew --prefix nvm)/nvm.sh" --no-use
export NODE_BINARY=$(command -v node)

================
File: app/ios/pizza.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		13B07FBF1A68108700A75B9A /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 13B07FB51A68108700A75B9A /* Images.xcassets */; };
		3E461D99554A48A4959DE609 /* SplashScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */; };
		BB2F792D24A3F905000567C9 /* Expo.plist in Resources */ = {isa = PBXBuildFile; fileRef = BB2F792C24A3F905000567C9 /* Expo.plist */; };
		F11748422D0307B40044C1D9 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = F11748412D0307B40044C1D9 /* AppDelegate.swift */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		13B07F961A680F5B00A75B9A /* pizza.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = pizza.app; sourceTree = BUILT_PRODUCTS_DIR; };
		13B07FB51A68108700A75B9A /* Images.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Images.xcassets; path = pizza/Images.xcassets; sourceTree = "<group>"; };
		13B07FB61A68108700A75B9A /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = Info.plist; path = pizza/Info.plist; sourceTree = "<group>"; };
		AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.storyboard; name = SplashScreen.storyboard; path = pizza/SplashScreen.storyboard; sourceTree = "<group>"; };
		BB2F792C24A3F905000567C9 /* Expo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Expo.plist; sourceTree = "<group>"; };
		ED297162215061F000B7C4FE /* JavaScriptCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = JavaScriptCore.framework; path = System/Library/Frameworks/JavaScriptCore.framework; sourceTree = SDKROOT; };
		F11748412D0307B40044C1D9 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = AppDelegate.swift; path = pizza/AppDelegate.swift; sourceTree = "<group>"; };
		F11748442D0722820044C1D9 /* pizza-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = "pizza-Bridging-Header.h"; path = "pizza/pizza-Bridging-Header.h"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		13B07F8C1A680F5B00A75B9A /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		13B07FAE1A68108700A75B9A /* pizza */ = {
			isa = PBXGroup;
			children = (
				F11748412D0307B40044C1D9 /* AppDelegate.swift */,
				F11748442D0722820044C1D9 /* pizza-Bridging-Header.h */,
				BB2F792B24A3F905000567C9 /* Supporting */,
				13B07FB51A68108700A75B9A /* Images.xcassets */,
				13B07FB61A68108700A75B9A /* Info.plist */,
				AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */,
			);
			name = pizza;
			sourceTree = "<group>";
		};
		2D16E6871FA4F8E400B85C8A /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				ED297162215061F000B7C4FE /* JavaScriptCore.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		832341AE1AAA6A7D00B99B32 /* Libraries */ = {
			isa = PBXGroup;
			children = (
			);
			name = Libraries;
			sourceTree = "<group>";
		};
		83CBB9F61A601CBA00E9B192 = {
			isa = PBXGroup;
			children = (
				13B07FAE1A68108700A75B9A /* pizza */,
				832341AE1AAA6A7D00B99B32 /* Libraries */,
				83CBBA001A601CBA00E9B192 /* Products */,
				2D16E6871FA4F8E400B85C8A /* Frameworks */,
			);
			indentWidth = 2;
			sourceTree = "<group>";
			tabWidth = 2;
			usesTabs = 0;
		};
		83CBBA001A601CBA00E9B192 /* Products */ = {
			isa = PBXGroup;
			children = (
				13B07F961A680F5B00A75B9A /* pizza.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		BB2F792B24A3F905000567C9 /* Supporting */ = {
			isa = PBXGroup;
			children = (
				BB2F792C24A3F905000567C9 /* Expo.plist */,
			);
			name = Supporting;
			path = pizza/Supporting;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		13B07F861A680F5B00A75B9A /* pizza */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 13B07F931A680F5B00A75B9A /* Build configuration list for PBXNativeTarget "pizza" */;
			buildPhases = (
				08A4A3CD28434E44B6B9DE2E /* [CP] Check Pods Manifest.lock */,
				13B07F871A680F5B00A75B9A /* Sources */,
				13B07F8C1A680F5B00A75B9A /* Frameworks */,
				13B07F8E1A680F5B00A75B9A /* Resources */,
				00DD1BFF1BD5951E006B06BC /* Bundle React Native code and images */,
				800E24972A6A228C8D4807E9 /* [CP] Copy Pods Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = pizza;
			productName = pizza;
			productReference = 13B07F961A680F5B00A75B9A /* pizza.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		83CBB9F71A601CBA00E9B192 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastUpgradeCheck = 1130;
				TargetAttributes = {
					13B07F861A680F5B00A75B9A = {
						LastSwiftMigration = 1250;
					};
				};
			};
			buildConfigurationList = 83CBB9FA1A601CBA00E9B192 /* Build configuration list for PBXProject "pizza" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 83CBB9F61A601CBA00E9B192;
			productRefGroup = 83CBBA001A601CBA00E9B192 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				13B07F861A680F5B00A75B9A /* pizza */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		13B07F8E1A680F5B00A75B9A /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				BB2F792D24A3F905000567C9 /* Expo.plist in Resources */,
				13B07FBF1A68108700A75B9A /* Images.xcassets in Resources */,
				3E461D99554A48A4959DE609 /* SplashScreen.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		00DD1BFF1BD5951E006B06BC /* Bundle React Native code and images */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Bundle React Native code and images";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "if [[ -f \"$PODS_ROOT/../.xcode.env\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env\"\nfi\nif [[ -f \"$PODS_ROOT/../.xcode.env.local\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.local\"\nfi\n\n# The project root by default is one level up from the ios directory\nexport PROJECT_ROOT=\"$PROJECT_DIR\"/..\n\nif [[ \"$CONFIGURATION\" = *Debug* ]]; then\n  export SKIP_BUNDLING=1\nfi\nif [[ -z \"$ENTRY_FILE\" ]]; then\n  # Set the entry JS file using the bundler's entry resolution.\n  export ENTRY_FILE=\"$(\"$NODE_BINARY\" -e \"require('expo/scripts/resolveAppEntry')\" \"$PROJECT_ROOT\" ios absolute | tail -n 1)\"\nfi\n\nif [[ -z \"$CLI_PATH\" ]]; then\n  # Use Expo CLI\n  export CLI_PATH=\"$(\"$NODE_BINARY\" --print \"require.resolve('@expo/cli', { paths: [require.resolve('expo/package.json')] })\")\"\nfi\nif [[ -z \"$BUNDLE_COMMAND\" ]]; then\n  # Default Expo CLI command for bundling\n  export BUNDLE_COMMAND=\"export:embed\"\nfi\n\n# Source .xcode.env.updates if it exists to allow\n# SKIP_BUNDLING to be unset if needed\nif [[ -f \"$PODS_ROOT/../.xcode.env.updates\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.updates\"\nfi\n# Source local changes to allow overrides\n# if needed\nif [[ -f \"$PODS_ROOT/../.xcode.env.local\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.local\"\nfi\n\n`\"$NODE_BINARY\" --print \"require('path').dirname(require.resolve('react-native/package.json')) + '/scripts/react-native-xcode.sh'\"`\n\n";
		};
		08A4A3CD28434E44B6B9DE2E /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-pizza-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		800E24972A6A228C8D4807E9 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-pizza/Pods-pizza-resources.sh",
				"${PODS_CONFIGURATION_BUILD_DIR}/EXConstants/EXConstants.bundle",
				"${PODS_CONFIGURATION_BUILD_DIR}/EXUpdates/EXUpdates.bundle",
				"${PODS_CONFIGURATION_BUILD_DIR}/React-Core/RCTI18nStrings.bundle",
			);
			name = "[CP] Copy Pods Resources";
			outputPaths = (
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/EXConstants.bundle",
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/EXUpdates.bundle",
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/RCTI18nStrings.bundle",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-pizza/Pods-pizza-resources.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		13B07F871A680F5B00A75B9A /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				F11748422D0307B40044C1D9 /* AppDelegate.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		13B07F941A680F5B00A75B9A /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				ENABLE_BITCODE = NO;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"$(inherited)",
					"FB_SONARKIT_ENABLED=1",
				);
				INFOPLIST_FILE = pizza/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "com.viefmoon.pizza";
				PRODUCT_NAME = "pizza";
				SWIFT_OBJC_BRIDGING_HEADER = "pizza/pizza-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
				TARGETED_DEVICE_FAMILY = "1";
				CODE_SIGN_ENTITLEMENTS = pizza/pizza.entitlements;
			};
			name = Debug;
		};
		13B07F951A680F5B00A75B9A /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				INFOPLIST_FILE = pizza/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "com.viefmoon.pizza";
				PRODUCT_NAME = "pizza";
				SWIFT_OBJC_BRIDGING_HEADER = "pizza/pizza-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
				TARGETED_DEVICE_FAMILY = "1";
				CODE_SIGN_ENTITLEMENTS = pizza/pizza.entitlements;
			};
			name = Release;
		};
		83CBBA201A601CBA00E9B192 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "c++20";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					/usr/lib/swift,
					"$(inherited)",
				);
				LIBRARY_SEARCH_PATHS = "\"$(inherited)\"";
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
			};
			name = Debug;
		};
		83CBBA211A601CBA00E9B192 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "c++20";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = YES;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					/usr/lib/swift,
					"$(inherited)",
				);
				LIBRARY_SEARCH_PATHS = "\"$(inherited)\"";
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		13B07F931A680F5B00A75B9A /* Build configuration list for PBXNativeTarget "pizza" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				13B07F941A680F5B00A75B9A /* Debug */,
				13B07F951A680F5B00A75B9A /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		83CBB9FA1A601CBA00E9B192 /* Build configuration list for PBXProject "pizza" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				83CBBA201A601CBA00E9B192 /* Debug */,
				83CBBA211A601CBA00E9B192 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 83CBB9F71A601CBA00E9B192 /* Project object */;
}

================
File: app/ios/pizza.xcodeproj/xcshareddata/xcschemes/pizza.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1130"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
               BuildableName = "pizza.app"
               BlueprintName = "pizza"
               ReferencedContainer = "container:pizza.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
         <TestableReference
            skipped = "NO">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "00E356ED1AD99517003FC87E"
               BuildableName = "pizzaTests.xctest"
               BlueprintName = "pizzaTests"
               ReferencedContainer = "container:pizza.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "pizza.app"
            BlueprintName = "pizza"
            ReferencedContainer = "container:pizza.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "pizza.app"
            BlueprintName = "pizza"
            ReferencedContainer = "container:pizza.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: app/ios/pizza/AppDelegate.swift
================
import Expo
import React
import ReactAppDependencyProvider
@UIApplicationMain
public class AppDelegate: ExpoAppDelegate {
  var window: UIWindow?
  var reactNativeDelegate: ExpoReactNativeFactoryDelegate?
  var reactNativeFactory: RCTReactNativeFactory?
  public override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
    let delegate = ReactNativeDelegate()
    let factory = ExpoReactNativeFactory(delegate: delegate)
    delegate.dependencyProvider = RCTAppDependencyProvider()
    reactNativeDelegate = delegate
    reactNativeFactory = factory
    bindReactNativeFactory(factory)
#if os(iOS) || os(tvOS)
    window = UIWindow(frame: UIScreen.main.bounds)
    factory.startReactNative(
      withModuleName: "main",
      in: window,
      launchOptions: launchOptions)
#endif
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
  public override func application(
    _ app: UIApplication,
    open url: URL,
    options: [UIApplication.OpenURLOptionsKey: Any] = [:]
  ) -> Bool {
    return super.application(app, open: url, options: options) || RCTLinkingManager.application(app, open: url, options: options)
  }
  public override func application(
    _ application: UIApplication,
    continue userActivity: NSUserActivity,
    restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void
  ) -> Bool {
    let result = RCTLinkingManager.application(application, continue: userActivity, restorationHandler: restorationHandler)
    return super.application(application, continue: userActivity, restorationHandler: restorationHandler) || result
  }
}
class ReactNativeDelegate: ExpoReactNativeFactoryDelegate {
  override func sourceURL(for bridge: RCTBridge) -> URL? {
    bridge.bundleURL ?? bundleURL()
  }
  override func bundleURL() -> URL? {
#if DEBUG
    return RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: ".expo/.virtual-metro-entry")
#else
    return Bundle.main.url(forResource: "main", withExtension: "jsbundle")
#endif
  }
}

================
File: app/ios/pizza/Images.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images": [
    {
      "filename": "App-Icon-1024x1024@1x.png",
      "idiom": "universal",
      "platform": "ios",
      "size": "1024x1024"
    }
  ],
  "info": {
    "version": 1,
    "author": "expo"
  }
}

================
File: app/ios/pizza/Images.xcassets/Contents.json
================
{
  "info" : {
    "version" : 1,
    "author" : "expo"
  }
}

================
File: app/ios/pizza/Images.xcassets/SplashScreenBackground.colorset/Contents.json
================
{
  "colors": [
    {
      "color": {
        "components": {
          "alpha": "1.000",
          "blue": "1.00000000000000",
          "green": "1.00000000000000",
          "red": "1.00000000000000"
        },
        "color-space": "srgb"
      },
      "idiom": "universal"
    }
  ],
  "info": {
    "version": 1,
    "author": "expo"
  }
}

================
File: app/ios/pizza/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>CADisableMinimumFrameDurationOnPhone</key>
    <true/>
    <key>CFBundleDevelopmentRegion</key>
    <string>$(DEVELOPMENT_LANGUAGE)</string>
    <key>CFBundleDisplayName</key>
    <string>CloudBite</string>
    <key>CFBundleExecutable</key>
    <string>$(EXECUTABLE_NAME)</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundlePackageType</key>
    <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0.0</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleURLTypes</key>
    <array>
      <dict>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>com.viefmoon.cloudbite</string>
        </array>
      </dict>
      <dict>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>exp+cloudbite</string>
        </array>
      </dict>
    </array>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>LSMinimumSystemVersion</key>
    <string>12.0</string>
    <key>LSRequiresIPhoneOS</key>
    <true/>
    <key>NSAppTransportSecurity</key>
    <dict>
      <key>NSAllowsArbitraryLoads</key>
      <false/>
      <key>NSAllowsLocalNetworking</key>
      <true/>
    </dict>
    <key>NSCameraUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to access your camera</string>
    <key>NSMicrophoneUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to use the microphone.</string>
    <key>NSPhotoLibraryUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to access your photos</string>
    <key>NSSpeechRecognitionUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to use speech recognition.</string>
    <key>UILaunchStoryboardName</key>
    <string>SplashScreen</string>
    <key>UIRequiredDeviceCapabilities</key>
    <array>
      <string>arm64</string>
    </array>
    <key>UIRequiresFullScreen</key>
    <false/>
    <key>UIStatusBarStyle</key>
    <string>UIStatusBarStyleDefault</string>
    <key>UISupportedInterfaceOrientations</key>
    <array>
      <string>UIInterfaceOrientationPortrait</string>
      <string>UIInterfaceOrientationPortraitUpsideDown</string>
      <string>UIInterfaceOrientationLandscapeLeft</string>
      <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
    <key>UIUserInterfaceStyle</key>
    <string>Light</string>
    <key>UIViewControllerBasedStatusBarAppearance</key>
    <false/>
  </dict>
</plist>

================
File: app/ios/pizza/pizza-Bridging-Header.h
================


================
File: app/ios/pizza/pizza.entitlements
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict/>
</plist>

================
File: app/ios/pizza/SplashScreen.storyboard
================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="32700.99.1234" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="EXPO-VIEWCONTROLLER-1">
    <device id="retina6_12" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="22685"/>
        <capability name="Named colors" minToolsVersion="9.0"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <scene sceneID="EXPO-SCENE-1">
            <objects>
                <viewController storyboardIdentifier="SplashScreenViewController" id="EXPO-VIEWCONTROLLER-1" sceneMemberID="viewController">
                    <view key="view" userInteractionEnabled="NO" contentMode="scaleToFill" insetsLayoutMarginsFromSafeArea="NO" id="EXPO-ContainerView" userLabel="ContainerView">
                        <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMaxY="YES"/>
                        <subviews/>
                        <viewLayoutGuide key="safeArea" id="Rmq-lb-GrQ"/>
                        <constraints>
                            <constraint firstItem="EXPO-SplashScreen" firstAttribute="centerY" secondItem="EXPO-ContainerView" secondAttribute="centerY" id="0VC-Wk-OaO"/>
                            <constraint firstItem="EXPO-SplashScreen" firstAttribute="centerX" secondItem="EXPO-ContainerView" secondAttribute="centerX" id="zR4-NK-mVN"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="EXPO-PLACEHOLDER-1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="0.0" y="0.0"/>
        </scene>
    </scenes>
    <resources>
        <image name="SplashScreenLogo" width="100" height="90.333335876464844"/>
    </resources>
</document>

================
File: app/ios/pizza/Supporting/Expo.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>EXUpdatesCheckOnLaunch</key>
    <string>ALWAYS</string>
    <key>EXUpdatesEnabled</key>
    <false/>
    <key>EXUpdatesLaunchWaitMs</key>
    <integer>0</integer>
  </dict>
</plist>

================
File: app/ios/Podfile
================
require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

require 'json'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

ENV['RCT_NEW_ARCH_ENABLED'] = '0' if podfile_properties['newArchEnabled'] == 'false'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] = podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']

platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'
install! 'cocoapods',
  :deterministic_uuids => false

prepare_react_native_project!

target 'pizza' do
  use_expo_modules!

  if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
    config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
  else
    config_command = [
      'npx',
      'expo-modules-autolinking',
      'react-native-config',
      '--json',
      '--platform',
      'ios'
    ]
  end

  config = use_native_modules!(config_command)

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
  )

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      :ccache_enabled => podfile_properties['apple.ccacheEnabled'] == 'true',
    )

    # This is necessary for Xcode 14, because it signs resource bundles by default
    # when building for devices.
    installer.target_installation_results.pod_target_installation_results
      .each do |pod_name, target_installation_result|
      target_installation_result.resource_bundle_targets.each do |resource_bundle_target|
        resource_bundle_target.build_configurations.each do |config|
          config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'
        end
      end
    end
  end
end

================
File: app/ios/Podfile.properties.json
================
{
  "expo.jsEngine": "hermes",
  "EX_DEV_CLIENT_NETWORK_INSPECTOR": "true"
}

================
File: app/scripts/dev/reset-project.sh
================
echo "🧹 Limpiando proyecto React Native..."
echo "Deteniendo Metro bundler..."
pkill -f "react-native.*metro" || true
echo "Limpiando watchman..."
watchman watch-del-all 2>/dev/null || true
echo "Limpiando caches..."
rm -rf $TMPDIR/react-* 2>/dev/null || true
rm -rf $TMPDIR/metro-* 2>/dev/null || true
rm -rf $TMPDIR/haste-* 2>/dev/null || true
echo "Eliminando node_modules..."
rm -rf node_modules
rm -rf package-lock.json
echo "Limpiando cache de npm..."
npm cache clean --force
echo "Reinstalando dependencias..."
npm install
echo "Limpiando cache de Expo..."
npx expo start --clear
echo "✅ Limpieza completa!"

================
File: app/scripts/install-android-sdk.sh
================
echo "=== Instalación de Android SDK para builds locales ==="
echo ""
# Crear directorio para Android SDK
ANDROID_SDK_ROOT="$HOME/Android/Sdk"
mkdir -p "$ANDROID_SDK_ROOT"
if ! command -v unzip &> /dev/null; then
    echo "📦 Instalando unzip..."
    sudo apt install -y unzip
fi
if [ ! -d "$ANDROID_SDK_ROOT/cmdline-tools" ]; then
    echo "📦 Descargando Android Command Line Tools..."
    cd "$ANDROID_SDK_ROOT"
    TOOLS_URL="https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip"
    echo "Descargando desde: $TOOLS_URL"
    wget -q --show-progress "$TOOLS_URL" -O cmdline-tools.zip
    echo "Extrayendo herramientas..."
    unzip -q cmdline-tools.zip
    mkdir -p cmdline-tools/latest
    mv cmdline-tools/* cmdline-tools/latest/ 2>/dev/null || true
    rm -f cmdline-tools.zip
    echo "✅ Android Command Line Tools instaladas"
else
    echo "✅ Android Command Line Tools ya existen"
fi
echo ""
echo "🔧 Configurando variables de entorno..."
# Detectar shell
SHELL_CONFIG="$HOME/.bashrc"
if [ -n "$ZSH_VERSION" ]; then
    SHELL_CONFIG="$HOME/.zshrc"
fi
if ! grep -q "ANDROID_HOME" "$SHELL_CONFIG"; then
    echo "" >> "$SHELL_CONFIG"
    echo "# Android SDK" >> "$SHELL_CONFIG"
    echo "export ANDROID_HOME=$ANDROID_SDK_ROOT" >> "$SHELL_CONFIG"
    echo "export ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/emulator" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/platform-tools" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/cmdline-tools/latest/bin" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/tools" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/tools/bin" >> "$SHELL_CONFIG"
fi
export ANDROID_HOME=$ANDROID_SDK_ROOT
export ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
export PATH=$PATH:$ANDROID_HOME/tools
export PATH=$PATH:$ANDROID_HOME/tools/bin
if ! command -v sdkmanager &> /dev/null; then
    echo "❌ Error: sdkmanager no se encuentra. Verificando instalación..."
    ls -la "$ANDROID_HOME/cmdline-tools/latest/bin/"
    exit 1
fi
echo ""
echo "📦 Instalando componentes de Android SDK..."
echo "Esto puede tomar varios minutos..."
# Aceptar licencias
yes | sdkmanager --licenses 2>/dev/null || true
# Instalar componentes esenciales
sdkmanager "platform-tools"
sdkmanager "platforms;android-34"
sdkmanager "build-tools;34.0.0"
sdkmanager "ndk;25.1.8937393"
echo ""
echo "📝 Actualizando local.properties..."
echo "sdk.dir=$ANDROID_SDK_ROOT" > "$HOME/bite/app/android/local.properties"
echo ""
echo "✅ ¡Android SDK instalado y configurado!"
echo ""
echo "📋 Resumen de la configuración:"
echo "   ANDROID_HOME=$ANDROID_HOME"
echo "   JAVA_HOME=$JAVA_HOME"
echo ""
echo "⚠️  IMPORTANTE: Ejecuta este comando para cargar las variables:"
echo "    source $SHELL_CONFIG"
echo ""
echo "🚀 Luego puedes ejecutar tu build con:"
echo "    npm run build:android:dev"

================
File: app/scripts/install-java.sh
================
echo "Installing OpenJDK 17..."
sudo apt update
sudo apt install -y openjdk-17-jdk
echo -e "\nVerifying Java installation..."
java -version
javac -version
JAVA_PATH=$(update-alternatives --list java | grep java-17)
if [ -z "$JAVA_PATH" ]; then
    echo "Error: Java 17 installation not found"
    exit 1
fi
JAVA_HOME_PATH=$(dirname $(dirname $JAVA_PATH))
echo -e "\nJava installed at: $JAVA_HOME_PATH"
echo -e "\nConfiguring environment variables..."
if ! grep -q "export JAVA_HOME=" ~/.bashrc; then
    echo "" >> ~/.bashrc
    echo "
    echo "export JAVA_HOME=$JAVA_HOME_PATH" >> ~/.bashrc
    echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.bashrc
    echo "Environment variables added to ~/.bashrc"
else
    echo "JAVA_HOME already exists in ~/.bashrc, updating..."
    sed -i "s|export JAVA_HOME=.*|export JAVA_HOME=$JAVA_HOME_PATH|" ~/.bashrc
fi
if ! grep -q "export JAVA_HOME=" ~/.profile; then
    echo "" >> ~/.profile
    echo "
    echo "export JAVA_HOME=$JAVA_HOME_PATH" >> ~/.profile
    echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.profile
fi
export JAVA_HOME=$JAVA_HOME_PATH
export PATH=$JAVA_HOME/bin:$PATH
echo -e "\nJava installation complete!"
echo "JAVA_HOME set to: $JAVA_HOME"
echo -e "\nPlease run: source ~/.bashrc"
echo "Or restart your terminal for changes to take effect."

================
File: app/scripts/release-to-playstore.sh
================
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'
echo -e "${YELLOW}🚀 Iniciando release a Play Store...${NC}"
BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH" != "main" ]; then
    echo -e "${RED}❌ Debes estar en la rama main para hacer release${NC}"
    exit 1
fi
if ! git diff-index --quiet HEAD --; then
    echo -e "${RED}❌ Hay cambios sin commitear. Por favor commitea o stashea los cambios primero.${NC}"
    exit 1
fi
CURRENT_VERSION=$(node -p "require('./app.json').expo.version")
echo -e "${GREEN}Versión actual: $CURRENT_VERSION${NC}"
echo -e "${YELLOW}📝 Ingresa la nueva versión (formato: X.Y.Z):${NC}"
read VERSION
if ! [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo -e "${RED}❌ Formato de versión inválido. Usa X.Y.Z (ej: 1.0.1)${NC}"
    exit 1
fi
CURRENT_VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))
node -e "
const fs = require('fs');
const appJson = require('./app.json');
appJson.expo.version = '$VERSION';
appJson.expo.android.versionCode = $NEW_VERSION_CODE;
fs.writeFileSync('./app.json', JSON.stringify(appJson, null, 2));
"
echo -e "${GREEN}✅ Versión actualizada a $VERSION (versionCode: $NEW_VERSION_CODE)${NC}"
echo -e "${YELLOW}📝 Ingresa una descripción breve de los cambios:${NC}"
read RELEASE_MESSAGE
git add app.json
git commit -m "Release v$VERSION: $RELEASE_MESSAGE"
git tag "v$VERSION"
if [ ! -f "./google-play-service-account.json" ]; then
    echo -e "${RED}❌ No se encontró google-play-service-account.json${NC}"
    echo -e "${YELLOW}Por favor, descarga el archivo de credenciales de Google Play Console y guárdalo como google-play-service-account.json${NC}"
    exit 1
fi
echo -e "${YELLOW}¿Deseas continuar con el build y publicación? (s/n)${NC}"
read CONFIRM
if [ "$CONFIRM" != "s" ]; then
    echo -e "${RED}❌ Release cancelado${NC}"
    git reset --hard HEAD~1
    git tag -d "v$VERSION"
    exit 1
fi
echo -e "${YELLOW}🏗️  Iniciando build y submit a Play Store...${NC}"
eas build --platform android --profile production --auto-submit --non-interactive --message "v$VERSION: $RELEASE_MESSAGE"
if [ $? -eq 0 ]; then
    echo -e "${YELLOW}📤 Subiendo cambios a repositorio...${NC}"
    git push origin main --tags
    echo -e "${GREEN}✅ Release v$VERSION completado exitosamente!${NC}"
    echo -e "${GREEN}📱 Tu app será revisada y publicada en el track 'internal' de Play Store${NC}"
else
    echo -e "${RED}❌ Error en el build. Los cambios locales no se han subido.${NC}"
    echo -e "${YELLOW}Para revertir los cambios locales, ejecuta:${NC}"
    echo "git reset --hard HEAD~1 && git tag -d v$VERSION"
fi

================
File: app/scripts/verify-android-setup.sh
================
echo "=== Android Development Environment Verification ==="
echo
echo "1. Java Installation:"
if command -v java &> /dev/null; then
    java -version
    echo "✓ Java is installed"
else
    echo "✗ Java is not installed or not in PATH"
fi
echo
echo "2. JAVA_HOME Environment Variable:"
if [ -n "$JAVA_HOME" ]; then
    echo "JAVA_HOME is set to: $JAVA_HOME"
    if [ -d "$JAVA_HOME" ]; then
        echo "✓ JAVA_HOME directory exists"
    else
        echo "✗ JAVA_HOME directory does not exist"
    fi
else
    echo "✗ JAVA_HOME is not set"
fi
echo
echo "3. Android SDK:"
if [ -n "$ANDROID_HOME" ] || [ -n "$ANDROID_SDK_ROOT" ]; then
    if [ -n "$ANDROID_HOME" ]; then
        echo "ANDROID_HOME is set to: $ANDROID_HOME"
    fi
    if [ -n "$ANDROID_SDK_ROOT" ]; then
        echo "ANDROID_SDK_ROOT is set to: $ANDROID_SDK_ROOT"
    fi
    echo "✓ Android SDK environment variables are set"
else
    echo "✗ Android SDK environment variables not set (this is OK if using EAS Build)"
fi
echo
echo "4. Node.js:"
if command -v node &> /dev/null; then
    echo "Node version: $(node --version)"
    echo "✓ Node.js is installed"
else
    echo "✗ Node.js is not installed"
fi
echo
echo "5. npm:"
if command -v npm &> /dev/null; then
    echo "npm version: $(npm --version)"
    echo "✓ npm is installed"
else
    echo "✗ npm is not installed"
fi
echo
echo "6. EAS CLI:"
if command -v eas &> /dev/null; then
    echo "EAS CLI version: $(eas --version)"
    echo "✓ EAS CLI is installed"
else
    echo "✗ EAS CLI is not installed"
    echo "  Install with: npm install -g eas-cli"
fi
echo
echo "7. Expo CLI:"
if npx expo --version &> /dev/null 2>&1; then
    echo "Expo CLI version: $(npx expo --version)"
    echo "✓ Expo CLI is available"
else
    echo "✗ Expo CLI is not available"
fi
echo
echo "=== Summary ==="
echo "Run the following commands to complete setup:"
echo "1. ./scripts/install-java.sh          # Install Java JDK 17"
echo "2. source ~/.bashrc                  # Reload environment variables"
echo "3. ./scripts/fix-expo-packages.sh     # Fix Expo package versions"
echo "4. npm install -g eas-cli            # Install EAS CLI if needed"

================
File: app/src/app/components/common/CustomImagePicker.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  Alert,
  TouchableOpacity,
  StyleProp,
  ViewStyle,
} from 'react-native';
import {
  ActivityIndicator,
  Avatar,
  IconButton,
  Surface,
  Text,
  useTheme,
} from 'react-native-paper';
import * as ImagePicker from 'expo-image-picker';
import { Image } from 'expo-image';
import { AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
export interface FileObject {
  uri: string;
  name: string;
  type: string;
}
interface CustomImagePickerProps {
  value?: string | null;
  onImageSelected?: (imageUri: string, file: FileObject) => void;
  onImageRemoved?: () => void;
  style?: StyleProp<ViewStyle>;
  size?: number;
  placeholderIcon?: string;
  placeholderText?: string;
  isLoading?: boolean;
  disabled?: boolean;
}
export const CustomImagePicker: React.FC<CustomImagePickerProps> = ({
  value,
  onImageSelected,
  onImageRemoved,
  style,
  size = 150,
  placeholderIcon = 'camera-plus-outline',
  placeholderText = 'Añadir imagen',
  isLoading = false,
  disabled = false,
}) => {
  const theme = useTheme<AppTheme>();
  const responsive = useResponsive();
  const [imageUri, setImageUri] = useState<string | null | undefined>(value);
  const [hasPermission, setHasPermission] = useState<boolean | null>(null);
  const [imageLoadError, setImageLoadError] = useState(false);
  useEffect(() => {
    let isMounted = true;
    (async () => {
      try {
        const { status } = await ImagePicker.getMediaLibraryPermissionsAsync();
        if (isMounted) {
          setHasPermission(status === 'granted');
        }
      } catch {
        if (isMounted) {
          setHasPermission(false);
        }
      }
    })();
    return () => {
      isMounted = false;
    };
  }, []);
  useEffect(() => {
    setImageUri(value);
    setImageLoadError(false);
  }, [value]);
  const requestPermission = async (): Promise<boolean> => {
    if (hasPermission) return true;
    try {
      const { status } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status === 'granted') {
        setHasPermission(true);
        return true;
      } else {
        Alert.alert(
          'Permiso requerido',
          'Se necesita acceso a la galería para seleccionar imágenes.',
        );
        setHasPermission(false);
        return false;
      }
    } catch (e) {
      Alert.alert(
        'Error',
        'No se pudieron solicitar los permisos de la galería.',
      );
      setHasPermission(false);
      return false;
    }
  };
  const handlePickImage = async () => {
    if (isLoading || disabled) return;
    const permissionGranted = await requestPermission();
    if (!permissionGranted) return;
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: 'images',
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.8,
      });
      if (!result.canceled && result.assets && result.assets.length > 0) {
        const selectedAsset = result.assets[0];
        const selectedUri = selectedAsset.uri;
        const fileName = selectedUri.split('/').pop() || 'image.jpg';
        const fileType =
          selectedAsset.mimeType ||
          (fileName.toLowerCase().endsWith('.png')
            ? 'image/png'
            : 'image/jpeg');
        const fileObject: FileObject = {
          uri: selectedUri,
          name: fileName,
          type: fileType,
        };
        setImageUri(selectedUri);
        onImageSelected?.(selectedUri, fileObject);
      }
    } catch (error) {
      Alert.alert(
        'Error',
        `No se pudo abrir la galería: ${error instanceof Error ? error.message : 'Inténtalo de nuevo.'}`,
      );
    }
  };
  const handleRemoveImage = () => {
    if (isLoading || disabled) return;
    setImageUri(null);
    onImageRemoved?.();
  };
  const responsiveSize = responsive.getResponsiveDimension(size, size * 1.2);
  const styles = StyleSheet.create({
    container: {
      width: responsiveSize,
      height: responsiveSize,
      borderRadius: theme.roundness * 1.5,
      justifyContent: 'center',
      alignItems: 'center',
      overflow: 'hidden',
      position: 'relative',
      backgroundColor: theme.colors.surfaceVariant,
    },
    touchable: {
      width: '100%',
      height: '100%',
      justifyContent: 'center',
      alignItems: 'center',
    },
    image: {
      width: '100%',
      height: '100%',
    },
    placeholderContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing.s,
    },
    placeholderText: {
      marginTop: responsive.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      fontSize: responsive.fontSize.s,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0,0,0,0.4)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 1.5,
    },
    removeButton: {
      position: 'absolute',
      top: responsive.spacing.xs,
      right: responsive.spacing.xs,
      backgroundColor: 'rgba(0, 0, 0, 0.6)',
    },
  });
  return (
    <Surface style={[styles.container, style]} elevation={1}>
      <TouchableOpacity
        style={styles.touchable}
        onPress={handlePickImage}
        disabled={isLoading || disabled}
      >
        {imageUri && !imageLoadError ? (
          <Image
            source={{ uri: imageUri }}
            style={styles.image}
            contentFit="cover"
            onError={() => setImageLoadError(true)}
          />
        ) : (
          <View style={styles.placeholderContainer}>
            <Avatar.Icon
              size={responsiveSize * 0.4}
              icon={placeholderIcon}
              style={{ backgroundColor: 'transparent' }}
              color={theme.colors.onSurfaceVariant}
            />
            <Text style={styles.placeholderText} variant="bodySmall">
              {placeholderText}
            </Text>
          </View>
        )}
        {isLoading && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
          </View>
        )}
        {imageUri && !imageLoadError && !isLoading && !disabled && (
          <IconButton
            icon="close-circle"
            size={responsive.dimensions.iconSize.medium}
            iconColor={theme.colors.onErrorContainer}
            style={styles.removeButton}
            onPress={handleRemoveImage}
            rippleColor="rgba(255, 255, 255, 0.32)"
          />
        )}
      </TouchableOpacity>
    </Surface>
  );
};
export default CustomImagePicker;

================
File: app/src/app/components/common/SpeechRecognitionInput.tsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { View, StyleSheet, Animated } from 'react-native';
import { IconButton } from 'react-native-paper';
import {
  ExpoSpeechRecognitionModule,
  useSpeechRecognitionEvent,
} from 'expo-speech-recognition';
import AnimatedLabelInput from './AnimatedLabelInput';
import { useAppTheme } from '../../styles/theme';
class RecognitionInstance {
  private static instances = new Map<string, RecognitionInstance>();
  private static activeInstanceId: string | null = null;
  private id: string;
  private isActive: boolean = false;
  private onResultCallback: ((text: string) => void) | null = null;
  private onErrorCallback: ((error: string) => void) | null = null;
  private onStartCallback: (() => void) | null = null;
  private onEndCallback: (() => void) | null = null;
  constructor(id: string) {
    this.id = id;
    RecognitionInstance.instances.set(id, this);
  }
  static getInstance(id: string): RecognitionInstance {
    if (!RecognitionInstance.instances.has(id)) {
      new RecognitionInstance(id);
    }
    return RecognitionInstance.instances.get(id)!;
  }
  static removeInstance(id: string) {
    const instance = RecognitionInstance.instances.get(id);
    if (instance && instance.isActive) {
      instance.stop();
    }
    RecognitionInstance.instances.delete(id);
  }
  static getActiveInstance(): RecognitionInstance | null {
    if (RecognitionInstance.activeInstanceId) {
      return (
        RecognitionInstance.instances.get(
          RecognitionInstance.activeInstanceId,
        ) || null
      );
    }
    return null;
  }
  setCallbacks(callbacks: {
    onResult?: (text: string) => void;
    onError?: (error: string) => void;
    onStart?: () => void;
    onEnd?: () => void;
  }) {
    this.onResultCallback = callbacks.onResult || null;
    this.onErrorCallback = callbacks.onError || null;
    this.onStartCallback = callbacks.onStart || null;
    this.onEndCallback = callbacks.onEnd || null;
  }
  async start(lang: string) {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance && activeInstance.id !== this.id) {
      await activeInstance.stop();
    }
    try {
      const permissions =
        await ExpoSpeechRecognitionModule.requestPermissionsAsync();
      if (!permissions.granted) {
        this.onErrorCallback?.('Permiso de micrófono denegado');
        return;
      }
      RecognitionInstance.activeInstanceId = this.id;
      this.isActive = true;
      await ExpoSpeechRecognitionModule.start({
        lang,
        interimResults: false,
        continuous: false,
      });
      this.onStartCallback?.();
    } catch (error: any) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onErrorCallback?.(
        error.message || 'Error al iniciar reconocimiento',
      );
    }
  }
  async stop() {
    if (this.isActive) {
      try {
        await ExpoSpeechRecognitionModule.stop();
      } catch (error) {
      } finally {
        this.isActive = false;
        if (RecognitionInstance.activeInstanceId === this.id) {
          RecognitionInstance.activeInstanceId = null;
        }
        this.onEndCallback?.();
      }
    }
  }
  handleResult(transcript: string) {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.onResultCallback?.(transcript);
    }
  }
  handleError(error: string) {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onErrorCallback?.(error);
    }
  }
  handleEnd() {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onEndCallback?.();
    }
  }
}
interface SpeechRecognitionInputProps
  extends Omit<
    React.ComponentProps<typeof AnimatedLabelInput>,
    'value' | 'onChangeText'
  > {
  value: string;
  onChangeText: (text: string) => void;
  label: string;
  speechLang?: string;
  clearOnStart?: boolean;
  replaceContent?: boolean;
  onError?: (error: string) => void;
}
const SpeechRecognitionInput: React.FC<SpeechRecognitionInputProps> = ({
  value,
  onChangeText,
  label,
  speechLang = 'es-MX',
  clearOnStart = false,
  replaceContent = true,
  onError,
  error,
  errorColor,
  activeBorderColor,
  containerStyle,
  inputStyle,
  labelStyle,
  style,
  ...rest
}) => {
  const theme = useAppTheme();
  const [isRecognizingSpeech, setIsRecognizingSpeech] = useState(false);
  const [localValue, setLocalValue] = useState(value);
  const instanceId = useRef(
    `speech-${Date.now()}-${Math.floor(Math.random() * 10000)}`,
  ).current;
  const recognitionInstance = useRef<RecognitionInstance | null>(null);
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const lastProcessedValue = useRef(value);
  const isUpdatingFromSpeech = useRef(false);
  useEffect(() => {
    if (!isUpdatingFromSpeech.current && value !== lastProcessedValue.current) {
      setLocalValue(value);
      lastProcessedValue.current = value;
    }
  }, [value]);
  useEffect(() => {
    recognitionInstance.current = RecognitionInstance.getInstance(instanceId);
    recognitionInstance.current.setCallbacks({
      onStart: () => {
        setIsRecognizingSpeech(true);
        if (clearOnStart) {
          setLocalValue('');
          lastProcessedValue.current = '';
          onChangeText('');
        }
      },
      onEnd: () => {
        setIsRecognizingSpeech(false);
      },
      onResult: (transcript: string) => {
        let newValue: string;
        if (replaceContent) {
          if (rest.keyboardType === 'phone-pad') {
            newValue = transcript.replace(/\D/g, '');
          } else {
            newValue = transcript;
          }
        } else {
          // Usar el valor local más actualizado
          newValue = localValue ? localValue + ' ' + transcript : transcript;
        }
        isUpdatingFromSpeech.current = true;
        setLocalValue(newValue);
        lastProcessedValue.current = newValue;
        onChangeText(newValue);
        // Resetear flag después de un breve delay
        setTimeout(() => {
          isUpdatingFromSpeech.current = false;
        }, 100);
      },
      onError: (errorMsg: string) => {
        setIsRecognizingSpeech(false);
        onError?.(errorMsg);
      },
    });
    return () => {
      RecognitionInstance.removeInstance(instanceId);
    };
  }, [
    instanceId,
    clearOnStart,
    onChangeText,
    replaceContent,
    rest.keyboardType,
    onError,
    localValue,
  ]);
  // Animación del botón
  useEffect(() => {
    Animated.spring(scaleAnim, {
      toValue: isRecognizingSpeech ? 1.2 : 1,
      friction: 3,
      useNativeDriver: true,
    }).start();
  }, [isRecognizingSpeech, scaleAnim]);
  // Event listeners globales - solo procesan si la instancia activa coincide
  useSpeechRecognitionEvent('start', () => {
  });
  useSpeechRecognitionEvent('end', () => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId) {
      activeInstance.handleEnd();
    }
  });
  useSpeechRecognitionEvent('result', (event) => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId && event.results?.[0]) {
      activeInstance.handleResult(event.results[0].transcript);
    }
  });
  useSpeechRecognitionEvent('error', (event) => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId) {
      activeInstance.handleError(
        event.message || event.error || 'Error desconocido',
      );
    }
  });
  const toggleRecognition = async () => {
    if (!recognitionInstance.current) return;
    if (isRecognizingSpeech) {
      await recognitionInstance.current.stop();
    } else {
      await recognitionInstance.current.start(speechLang);
    }
  };
  const micIconColor = isRecognizingSpeech
    ? theme.colors.error
    : theme.colors.primary;
  const handleTextChange = useCallback(
    (text: string) => {
      setLocalValue(text);
      lastProcessedValue.current = text;
      onChangeText(text);
    },
    [onChangeText],
  );
  return (
    <View style={styles.wrapper}>
      <AnimatedLabelInput
        label={label}
        value={localValue}
        onChangeText={handleTextChange}
        error={error}
        errorColor={errorColor}
        activeBorderColor={activeBorderColor}
        containerStyle={[containerStyle, { flex: 1 }]}
        inputStyle={inputStyle}
        labelStyle={labelStyle}
        style={style}
        {...rest}
      />
      <Animated.View style={{ transform: [{ scale: scaleAnim }] }}>
        <IconButton
          key={isRecognizingSpeech ? 'mic-active' : 'mic-inactive'}
          icon={isRecognizingSpeech ? 'microphone-off' : 'microphone'}
          size={24}
          iconColor={micIconColor}
          onPress={toggleRecognition}
          style={styles.iconButton}
        />
      </Animated.View>
    </View>
  );
};
const styles = StyleSheet.create({
  wrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconButton: {
    marginLeft: 8,
    marginVertical: 0,
    padding: 0,
  },
});
export default SpeechRecognitionInput;

================
File: app/src/app/components/responsive/index.ts
================
export {
  ResponsiveView,
  ResponsiveRow,
  ResponsiveColumn,
} from './ResponsiveView';
export { ResponsiveGrid, ResponsiveFlexGrid, GridItem } from './ResponsiveGrid';
export {
  ResponsiveImage,
  ResponsiveAvatar,
  ResponsiveThumbnail,
} from './ResponsiveImage';
export { ResponsiveModal, ResponsiveConfirmModal } from './ResponsiveModal';

================
File: app/src/app/components/responsive/ResponsiveView.tsx
================
import React, { ReactNode, useMemo } from 'react';
import {
  View,
  ViewStyle,
  StyleProp,
  ViewProps,
  DimensionValue,
} from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';
interface ResponsiveViewProps extends ViewProps {
  children?: ReactNode;
  style?: StyleProp<ViewStyle>;
  xsStyle?: ViewStyle;
  smStyle?: ViewStyle;
  mdStyle?: ViewStyle;
  lgStyle?: ViewStyle;
  xlStyle?: ViewStyle;
  xxlStyle?: ViewStyle;
  mobileStyle?: ViewStyle;
  tabletStyle?: ViewStyle;
  portraitStyle?: ViewStyle;
  landscapeStyle?: ViewStyle;
  direction?: 'row' | 'column' | 'row-reverse' | 'column-reverse';
  directionTablet?: 'row' | 'column' | 'row-reverse' | 'column-reverse';
  padding?: number | 'auto';
  paddingHorizontal?: number | 'auto';
  paddingVertical?: number | 'auto';
  margin?: number | 'auto';
  marginHorizontal?: number | 'auto';
  marginVertical?: number | 'auto';
  gap?: number | 'auto';
  gapTablet?: number;
  align?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  alignTablet?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justify?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';
  justifyTablet?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';
  flex?: number;
  flexTablet?: number;
  wrap?: boolean;
  wrapTablet?: boolean;
  width?: number | string | 'auto';
  widthTablet?: number | string | 'auto';
  height?: number | string | 'auto';
  heightTablet?: number | string | 'auto';
  maxWidth?: number | string;
  maxWidthTablet?: number | string;
  maxHeight?: number | string;
  maxHeightTablet?: number | string;
  minWidth?: number | string;
  minWidthTablet?: number | string;
  minHeight?: number | string;
  minHeightTablet?: number | string;
  hideOnMobile?: boolean;
  hideOnTablet?: boolean;
  hideOnPortrait?: boolean;
  hideOnLandscape?: boolean;
}
export const ResponsiveView: React.FC<ResponsiveViewProps> = ({
  children,
  style,
  xsStyle,
  smStyle,
  mdStyle,
  lgStyle,
  xlStyle,
  xxlStyle,
  mobileStyle,
  tabletStyle,
  portraitStyle,
  landscapeStyle,
  direction = 'column',
  directionTablet,
  padding,
  paddingHorizontal,
  paddingVertical,
  margin,
  marginHorizontal,
  marginVertical,
  gap,
  gapTablet,
  align,
  alignTablet,
  justify,
  justifyTablet,
  flex,
  flexTablet,
  wrap = false,
  wrapTablet,
  width,
  widthTablet,
  height,
  heightTablet,
  maxWidth,
  maxWidthTablet,
  maxHeight,
  maxHeightTablet,
  minWidth,
  minWidthTablet,
  minHeight,
  minHeightTablet,
  hideOnMobile = false,
  hideOnTablet = false,
  hideOnPortrait = false,
  hideOnLandscape = false,
  ...restProps
}) => {
  const responsive = useResponsive();
  const responsiveStyles = useMemo(() => {
    if (
      (hideOnMobile && responsive.isMobile) ||
      (hideOnTablet && responsive.isTablet) ||
      (hideOnPortrait && responsive.isPortrait) ||
      (hideOnLandscape && responsive.isLandscape)
    ) {
      return { display: 'none' } as ViewStyle;
    }
    const baseStyle: ViewStyle = {
      flexDirection:
        responsive.isTablet && directionTablet ? directionTablet : direction,
      flex: responsive.isTablet && flexTablet !== undefined ? flexTablet : flex,
      flexWrap:
        responsive.isTablet && wrapTablet !== undefined
          ? wrapTablet
            ? 'wrap'
            : 'nowrap'
          : wrap
            ? 'wrap'
            : 'nowrap',
      alignItems: responsive.isTablet && alignTablet ? alignTablet : align,
      justifyContent:
        responsive.isTablet && justifyTablet ? justifyTablet : justify,
      width: (responsive.isTablet && widthTablet !== undefined
        ? widthTablet
        : width) as any,
      height: (responsive.isTablet && heightTablet !== undefined
        ? heightTablet
        : height) as DimensionValue,
      maxWidth: (responsive.isTablet && maxWidthTablet !== undefined
        ? maxWidthTablet
        : maxWidth) as DimensionValue,
      maxHeight: (responsive.isTablet && maxHeightTablet !== undefined
        ? maxHeightTablet
        : maxHeight) as DimensionValue,
      minWidth: (responsive.isTablet && minWidthTablet !== undefined
        ? minWidthTablet
        : minWidth) as DimensionValue,
      minHeight: (responsive.isTablet && minHeightTablet !== undefined
        ? minHeightTablet
        : minHeight) as DimensionValue,
    };
    if (padding !== undefined) {
      const paddingValue =
        padding === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(padding);
      baseStyle.padding = paddingValue;
    }
    if (paddingHorizontal !== undefined) {
      const paddingValue =
        paddingHorizontal === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(paddingHorizontal);
      baseStyle.paddingHorizontal = paddingValue;
    }
    if (paddingVertical !== undefined) {
      const paddingValue =
        paddingVertical === 'auto'
          ? responsive.spacing.m
          : responsive.scaleHeight(paddingVertical);
      baseStyle.paddingVertical = paddingValue;
    }
    if (margin !== undefined) {
      const marginValue =
        margin === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(margin);
      baseStyle.margin = marginValue;
    }
    if (marginHorizontal !== undefined) {
      const marginValue =
        marginHorizontal === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(marginHorizontal);
      baseStyle.marginHorizontal = marginValue;
    }
    if (marginVertical !== undefined) {
      const marginValue =
        marginVertical === 'auto'
          ? responsive.spacing.m
          : responsive.scaleHeight(marginVertical);
      baseStyle.marginVertical = marginValue;
    }
    if (gap !== undefined || gapTablet !== undefined) {
      const gapValue =
        responsive.isTablet && gapTablet !== undefined
          ? gapTablet
          : gap === 'auto'
            ? responsive.spacing.m
            : gap;
      baseStyle.gap = responsive.scaleWidth(gapValue as number);
    }
    const breakpointStyle = responsive.applyResponsiveStyle({
      xs: xsStyle,
      sm: smStyle,
      md: mdStyle,
      lg: lgStyle,
      xl: xlStyle,
      xxl: xxlStyle,
    });
    const deviceStyle = responsive.isTablet ? tabletStyle : mobileStyle;
    const orientationStyle = responsive.isPortrait
      ? portraitStyle
      : landscapeStyle;
    return [
      baseStyle,
      breakpointStyle,
      deviceStyle,
      orientationStyle,
      style,
    ].filter(Boolean);
  }, [
    responsive,
    style,
    xsStyle,
    smStyle,
    mdStyle,
    lgStyle,
    xlStyle,
    xxlStyle,
    mobileStyle,
    tabletStyle,
    portraitStyle,
    landscapeStyle,
    direction,
    directionTablet,
    padding,
    paddingHorizontal,
    paddingVertical,
    margin,
    marginHorizontal,
    marginVertical,
    gap,
    gapTablet,
    align,
    alignTablet,
    justify,
    justifyTablet,
    flex,
    flexTablet,
    wrap,
    wrapTablet,
    width,
    widthTablet,
    height,
    heightTablet,
    maxWidth,
    maxWidthTablet,
    maxHeight,
    maxHeightTablet,
    minWidth,
    minWidthTablet,
    minHeight,
    minHeightTablet,
    hideOnMobile,
    hideOnTablet,
    hideOnPortrait,
    hideOnLandscape,
  ]);
  return (
    <View style={responsiveStyles} {...restProps}>
      {children}
    </View>
  );
};
export const ResponsiveRow: React.FC<ResponsiveViewProps> = (props) => {
  return <ResponsiveView direction="row" {...props} />;
};
export const ResponsiveColumn: React.FC<ResponsiveViewProps> = (props) => {
  return <ResponsiveView direction="column" {...props} />;
};

================
File: app/src/app/constants/storageKeys.ts
================
export const STORAGE_KEYS = {
  REMEMBERED_CREDENTIALS: 'user_credentials',
  REMEMBER_ME_ENABLED: 'remember_me_preference',
  AUTH_TOKEN: 'auth_token',
} as const;

================
File: app/src/app/docs/DateTimePickerUsage.md
================
# Uso del DateTimePickerSafe

## Problema Original

El error "Loss of precision during arithmetic conversion" ocurre cuando React Native con Hermes intenta hacer conversiones aritméticas con objetos Date, especialmente al usar librerías como `@react-native-community/datetimepicker` o `react-native-modal-datetime-picker`.

## Solución

Hemos creado dos utilidades para manejar fechas/horas de forma segura:

1. **DateTimePickerSafe**: Un componente selector de fecha/hora que evita conversiones problemáticas
2. **dateTimeHelpers**: Funciones helper para conversiones seguras

## Ejemplo de Uso

### 1. Reemplazar TimePickerModal actual

```tsx
// Antes (problemático)
import DateTimePicker from '@react-native-community/datetimepicker';

// Después (seguro)
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';

// En tu componente:
const [showPicker, setShowPicker] = useState(false);
const [selectedDateTime, setSelectedDateTime] = useState<Date | null>(null);

return (
  <>
    <Button onPress={() => setShowPicker(true)}>
      Seleccionar Fecha/Hora
    </Button>
    
    <DateTimePickerSafe
      visible={showPicker}
      onDismiss={() => setShowPicker(false)}
      onConfirm={(date) => {
        setSelectedDateTime(date);
        setShowPicker(false);
      }}
      mode="datetime" // o "date" o "time"
      initialDate={selectedDateTime || undefined}
      title="Seleccionar hora de entrega"
    />
  </>
);
```

### 2. Usar los helpers seguros

```tsx
import {
  safeTimeStringToDate,
  safeDateToTimeString,
  getNextAvailableTime,
  parseDateFromBackend
} from '@/app/utils/dateTimeHelpers';

// Convertir string de hora a Date
const date = safeTimeStringToDate("14:30"); // Hoy a las 14:30

// Convertir Date a string de hora
const timeStr = safeDateToTimeString(new Date()); // "14:30"

// Obtener próxima hora disponible (redondeada a 5 min)
const nextTime = getNextAvailableTime(30); // 30 min en el futuro

// Parsear fecha del backend de forma segura
const backendDate = parseDateFromBackend(orderData.scheduledAt);
if (backendDate) {
  const timeString = safeDateToTimeString(backendDate);
}
```

### 3. Integración en OrderCartDetail

```tsx
// Para hora programada de pedidos
const handleScheduleTime = () => {
  setShowDateTimePicker(true);
};

const handleConfirmScheduledTime = (date: Date) => {
  const timeString = safeDateToTimeString(date);
  setScheduledTime(timeString);
  setShowDateTimePicker(false);
};

// En el render:
<DateTimePickerSafe
  visible={showDateTimePicker}
  onDismiss={() => setShowDateTimePicker(false)}
  onConfirm={handleConfirmScheduledTime}
  mode="time"
  title="Hora de entrega"
  initialDate={scheduledTime ? safeTimeStringToDate(scheduledTime) : undefined}
/>
```

## Ventajas

1. **Sin pérdida de precisión**: Evita conversiones aritméticas problemáticas
2. **Compatible con Hermes**: Usa operaciones seguras y date-fns
3. **UX mejorada**: Interfaz nativa de selección sin dependencias problemáticas
4. **Validación incluida**: Maneja errores y casos edge automáticamente
5. **Localización**: Soporta español por defecto con date-fns/locale

## Migración

Para migrar del componente actual:

1. Reemplaza `TimePickerModal` por `DateTimePickerSafe` con `mode="time"`
2. Reemplaza `convertTimeStringToDate` por `safeTimeStringToDate`
3. Reemplaza `format(new Date(date), 'HH:mm')` por `safeDateToTimeString(parseDateFromBackend(date))`
4. Usa `getDateTimeForBackend(date)` al enviar fechas al backend

================
File: app/src/app/docs/RESPONSIVE_GUIDE.md
================
# Guía del Sistema Responsive

## Introducción

Este documento describe cómo utilizar el sistema responsive implementado en la aplicación para garantizar una experiencia óptima en diferentes tamaños de pantalla y dispositivos.

## Conceptos Clave

### Breakpoints
```typescript
xs: 0     // Extra pequeño (móviles pequeños)
sm: 360   // Pequeño (móviles estándar)
md: 600   // Mediano (móviles grandes y tablets pequeñas)
lg: 900   // Grande (tablets)
xl: 1200  // Extra grande (tablets grandes)
xxl: 1536 // Doble extra grande (tablets pro)
```

### Hook useResponsive

El hook principal que proporciona toda la información responsive:

```typescript
const responsive = useResponsive();

// Propiedades disponibles:
responsive.window          // Dimensiones de la ventana
responsive.isTablet        // true si es tablet
responsive.spacing         // Espaciado responsive
responsive.fontSize        // Tamaños de fuente responsive
responsive.dimensions      // Dimensiones comunes responsive
responsive.getResponsiveDimension(mobile, tablet) // Dimensión adaptativa
responsive.getGridColumns(minWidth, gap, padding) // Columnas dinámicas
responsive.scaleFont(size) // Escalar fuente según DPI
responsive.scaleSize(size) // Escalar tamaño según DPI
```

## Componentes Responsive

### ResponsiveView
Componente base para layouts responsive:

```tsx
<ResponsiveView
  breakpoints={{
    xs: { padding: 16 },
    md: { padding: 24 },
    lg: { padding: 32 }
  }}
  mobileProps={{ flexDirection: 'column' }}
  tabletProps={{ flexDirection: 'row' }}
>
  {/* Contenido */}
</ResponsiveView>
```

### ResponsiveGrid
Grid con columnas dinámicas:

```tsx
<ResponsiveGrid
  columns={3}
  columnsTablet={4}
  gap={responsive.spacing.m}
  minItemWidth={150}
>
  {/* Items del grid */}
</ResponsiveGrid>
```

### ResponsiveImage
Imágenes con escalado automático:

```tsx
<ResponsiveImage
  source={require('./image.png')}
  baseWidth={200}
  baseHeight={150}
  maxScale={1.5}
/>
```

### ResponsiveModal
Modales con tamaño adaptativo:

```tsx
<ResponsiveModal
  visible={visible}
  onDismiss={onDismiss}
  size="medium" // small, medium, large, fullscreen
>
  {/* Contenido del modal */}
</ResponsiveModal>
```

## Mejores Prácticas

### 1. Siempre usa valores responsive

❌ **Evitar:**
```tsx
style={{ padding: 16, fontSize: 14 }}
```

✅ **Preferir:**
```tsx
style={{ 
  padding: responsive.spacing.m,
  fontSize: responsive.fontSize.m 
}}
```

### 2. Diseña mobile-first

Comienza con el diseño móvil y añade mejoras para tablets:

```tsx
const styles = StyleSheet.create({
  container: {
    // Base móvil
    flexDirection: 'column',
    padding: responsive.spacing.m,
    
    // Mejoras para tablet
    ...(responsive.isTablet && {
      flexDirection: 'row',
      padding: responsive.spacing.xl,
    }),
  },
});
```

### 3. Usa grids dinámicos

Para listas de items, usa ResponsiveGrid o calcula columnas dinámicamente:

```tsx
const numColumns = useMemo(() => {
  return responsive.getGridColumns(150, responsive.spacing.m, responsive.spacing.m);
}, [responsive]);

<FlatList
  numColumns={numColumns}
  key={numColumns} // Importante para re-render
  // ...
/>
```

### 4. Considera la orientación

Para pantallas específicas como cocina:

```tsx
useEffect(() => {
  // Forzar orientación horizontal
  ScreenOrientation.lockAsync(ScreenOrientation.OrientationLock.LANDSCAPE);
  
  return () => {
    ScreenOrientation.unlockAsync();
  };
}, []);
```

### 5. Optimiza imágenes

Usa dimensiones responsive para imágenes:

```tsx
<AutoImage
  source={imageUrl}
  maxWidth={responsive.getResponsiveDimension(300, 500)}
  maxHeight={responsive.getResponsiveDimension(200, 350)}
/>
```

### 6. Tipografía responsive

Usa la escala de fuentes predefinida:

```tsx
responsive.fontSize.xs  // 10
responsive.fontSize.s   // 12
responsive.fontSize.m   // 14
responsive.fontSize.l   // 16
responsive.fontSize.xl  // 20
responsive.fontSize.xxl // 24
responsive.fontSize.xxxl // 32
```

### 7. Espaciado consistente

Usa la escala de espaciado:

```tsx
responsive.spacing.xs  // 4
responsive.spacing.s   // 8
responsive.spacing.m   // 16
responsive.spacing.l   // 24
responsive.spacing.xl  // 32
responsive.spacing.xxl // 48
```

## Patrones Comunes

### Layout Lado a Lado en Tablets

```tsx
if (responsive.isTablet && responsive.window.width > responsive.window.height) {
  return (
    <View style={{ flexDirection: 'row' }}>
      <View style={{ flex: 1 }}>{/* Panel izquierdo */}</View>
      <View style={{ flex: 1 }}>{/* Panel derecho */}</View>
    </View>
  );
}
```

### Modal Adaptativo

```tsx
const modalWidth = responsive.isTablet 
  ? Math.min(600, responsive.window.width * 0.8)
  : responsive.window.width * 0.9;
```

### Grid con Mínimo de Items

```tsx
const columns = Math.max(2, responsive.getGridColumns(100));
```

## Pruebas Recomendadas

1. **Dispositivos móviles:** 
   - iPhone SE (375x667)
   - iPhone 14 (390x844)
   - Pixel 5 (393x851)

2. **Tablets:**
   - iPad Mini (768x1024)
   - iPad Pro 11" (834x1194)
   - iPad Pro 12.9" (1024x1366)

3. **Orientaciones:**
   - Portrait y Landscape
   - Cambios dinámicos de orientación

4. **Densidades de píxeles:**
   - @1x, @2x, @3x
   - Verificar escalado de fuentes e iconos

================
File: app/src/app/hooks/useCrudScreenLogic.ts
================
import { useState, useCallback } from 'react';
import { useMutation, useQueryClient, QueryKey } from '@tanstack/react-query';
import { Alert } from 'react-native';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
interface CrudLogicParams {
  entityName: string;
  queryKey: QueryKey;
  deleteMutationFn: (id: string) => Promise<void>;
}
export function useCrudScreenLogic<TItem extends { id: string }>({
  entityName,
  queryKey,
  deleteMutationFn,
}: CrudLogicParams) {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((s) => s.showSnackbar);
  const [isFormModalVisible, setIsFormModalVisible] = useState(false);
  const [isDetailModalVisible, setIsDetailModalVisible] = useState(false);
  const [editingItem, setEditingItem] = useState<TItem | null>(null);
  const [selectedItem, setSelectedItem] = useState<TItem | null>(null);
  const deleteMutation = useMutation({
    mutationFn: deleteMutationFn,
    onSuccess: (_, _deletedId) => {
      queryClient.invalidateQueries({ queryKey });
      showSnackbar({
        message: `${entityName} eliminado con éxito`,
        type: 'success',
      });
      handleCloseModals();
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al eliminar ${entityName}: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
  const handleOpenCreateModal = useCallback(() => {
    setEditingItem(null);
    setSelectedItem(null);
    setIsFormModalVisible(true);
    setIsDetailModalVisible(false);
  }, []);
  const handleOpenEditModal = useCallback((item: TItem) => {
    setEditingItem(item);
    setSelectedItem(null);
    setIsFormModalVisible(true);
    setIsDetailModalVisible(false);
  }, []);
  const handleOpenDetailModal = useCallback((item: TItem) => {
    setSelectedItem(item);
    setEditingItem(null);
    setIsDetailModalVisible(true);
    setIsFormModalVisible(false);
  }, []);
  const handleCloseModals = useCallback(() => {
    setIsFormModalVisible(false);
    setIsDetailModalVisible(false);
    setEditingItem(null);
    setSelectedItem(null);
  }, []);
  const handleDeleteItem = useCallback(
    (id: string) => {
      Alert.alert(
        `Confirmar Eliminación`,
        `¿Estás seguro de que deseas eliminar este ${entityName.toLowerCase()}?`,
        [
          { text: 'Cancelar', style: 'cancel' },
          {
            text: 'Eliminar',
            style: 'destructive',
            onPress: () => deleteMutation.mutate(id),
          },
        ],
      );
    },
    [deleteMutation, entityName],
  );
  const [deleteConfirmationState, setDeleteConfirmationState] = useState<{
    visible: boolean;
    itemId: string | null;
  }>({
    visible: false,
    itemId: null,
  });
  const showDeleteConfirmation = useCallback((id: string) => {
    setDeleteConfirmationState({ visible: true, itemId: id });
  }, []);
  const hideDeleteConfirmation = useCallback(() => {
    setDeleteConfirmationState({ visible: false, itemId: null });
  }, []);
  const confirmDelete = useCallback(() => {
    if (deleteConfirmationState.itemId) {
      deleteMutation.mutate(deleteConfirmationState.itemId);
      hideDeleteConfirmation();
    }
  }, [deleteConfirmationState.itemId, deleteMutation, hideDeleteConfirmation]);
  return {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting: deleteMutation.isPending,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    handleDeleteItem,
    deleteConfirmation: {
      visible: deleteConfirmationState.visible,
      title: 'Confirmar Eliminación',
      message: `¿Estás seguro de que deseas eliminar este ${entityName.toLowerCase()}?`,
      onConfirm: confirmDelete,
      onCancel: hideDeleteConfirmation,
      show: showDeleteConfirmation,
    },
  };
}

================
File: app/src/app/hooks/useListState.ts
================
import React, { useMemo } from 'react';
import EmptyState from '../components/common/EmptyState';
interface UseListStateProps {
  isLoading: boolean;
  isError: boolean;
  data: any[] | undefined;
  emptyConfig: {
    title: string;
    message?: string;
    actionLabel?: string;
    onAction?: () => void;
    icon?: string;
  };
  errorConfig?: {
    title?: string;
    message?: string;
    actionLabel?: string;
    onAction?: () => void;
    icon?: string;
  };
}
export const useListState = ({
  isLoading,
  isError,
  data,
  emptyConfig,
  errorConfig,
}: UseListStateProps) => {
  const isEmpty = useMemo(() => {
    return !isLoading && !isError && data && data.length === 0;
  }, [isLoading, isError, data]);
  const ListEmptyComponent = useMemo(() => {
    return () => {
      if (isLoading) return null;
      if (isError) {
        return React.createElement(EmptyState, {
          icon: errorConfig?.icon || 'alert-circle',
          title: errorConfig?.title || 'Error al cargar los datos',
          message:
            errorConfig?.message ||
            'Ocurrió un error al cargar la información. Por favor, intenta de nuevo.',
          actionLabel: errorConfig?.actionLabel || 'Reintentar',
          onAction: errorConfig?.onAction || emptyConfig.onAction,
        });
      }
      if (isEmpty) {
        return React.createElement(EmptyState, {
          icon: emptyConfig.icon || 'folder-open',
          title: emptyConfig.title,
          message: emptyConfig.message,
          actionLabel: emptyConfig.actionLabel,
          onAction: emptyConfig.onAction,
        });
      }
      return null;
    };
  }, [isLoading, isError, isEmpty, emptyConfig, errorConfig]);
  return {
    isEmpty,
    ListEmptyComponent,
  };
};

================
File: app/src/app/lib/errors.ts
================
import { ERROR_CODES, ApiErrorCode } from '../constants/apiErrorCodes';
import { BackendErrorResponse } from '../types/api.types';
import { AxiosError } from 'axios';
export class ApiError extends Error {
  public readonly code: ApiErrorCode | string;
  public readonly status: number;
  public readonly details?: any;
  public readonly originalMessage: string;
  constructor(
    code: ApiErrorCode | string = ERROR_CODES.UNKNOWN_API_ERROR,
    backendMessage: string = 'Ocurrió un error en la API',
    status: number = 500,
    details?: any,
  ) {
    super(backendMessage);
    this.code = code;
    this.status = status;
    this.details = details;
    this.originalMessage = backendMessage;
    this.name = 'ApiError';
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ApiError);
    }
  }
  static fromApiResponse(
    responseData: BackendErrorResponse | any,
    responseStatus?: number,
  ): ApiError {
    const status = responseStatus ?? responseData?.statusCode ?? 500;
    const code = responseData?.code ?? ERROR_CODES.UNKNOWN_API_ERROR;
    const message = responseData?.message ?? 'Error desconocido de la API.';
    const details = responseData?.details;
    return new ApiError(code, message, status, details);
  }
  static fromAxiosError(error: any): ApiError {
    if (error instanceof ApiError) {
      return error;
    }
    const axiosError = error as AxiosError;
    const responseData = axiosError.response?.data as
      | BackendErrorResponse
      | any;
    const status = axiosError.response?.status ?? 500;
    if (axiosError.code === 'ERR_NETWORK' || !axiosError.response) {
      return new ApiError(
        ERROR_CODES.NETWORK_ERROR,
        'Error de conexión. Verifica tu conexión a internet e intenta nuevamente.',
        0,
        { originalError: axiosError.message },
      );
    }
    if (
      axiosError.code === 'ECONNABORTED' ||
      axiosError.message.includes('timeout')
    ) {
      return new ApiError(
        ERROR_CODES.NETWORK_ERROR,
        'La solicitud tardó demasiado tiempo. Intenta nuevamente con una conexión más estable.',
        0,
        { originalError: axiosError.message },
      );
    }
    const code =
      responseData?.code ||
      responseData?.error?.code ||
      responseData?.errors?.[0]?.code ||
      ERROR_CODES.UNKNOWN_API_ERROR;
    const message =
      responseData?.message ||
      responseData?.error?.message ||
      responseData?.errors?.[0]?.message ||
      axiosError.message ||
      'Error desconocido de la API.';
    const details = responseData?.details ?? responseData;
    return new ApiError(code, message, status, details);
  }
  static fromRefreshError(error: any): ApiError {
    return new ApiError(
      ERROR_CODES.REFRESH_FAILED,
      error?.message || 'La sesión ha expirado o no se pudo renovar.',
      401,
      error,
    );
  }
}

================
File: app/src/app/lib/IMAGE_CACHE_GUIDE.md
================
# 🖼️ Sistema de Cache de Imágenes Optimizado

## 📋 Resumen de Optimizaciones Implementadas

### ✅ **Correcciones Críticas**
1. **Eliminación de doble resolución de URLs**
   - Componentes ahora pasan `path` directamente a `AutoImage`
   - `AutoImage` maneja internamente la resolución con `getImageUrl()`
   - Eliminado uso innecesario de `await getImageUrl()` en componentes

2. **Archivos corregidos:**
   - `GenericDetailModal.tsx`: Usa `imageSource` en lugar de `imageUrl`
   - `CategoriesScreen.tsx`: Pasa `photo.path` directamente al formulario
   - `ProductFormModal.tsx`: Pasa `photo.path` directamente al formulario
   - `SubcategoriesScreen.tsx`: Pasa `photo.path` directamente al formulario

### 🔧 **Optimizaciones Implementadas**

#### 1. **Logging Optimizado (Solo Errores)**
```typescript
// Logs reducidos a lo esencial:
- CACHE_MISS_FAILED: Fallo en descarga
- CACHE_CLEANED: Limpieza exitosa (con detalles)
- CACHE_CLEAN_ERROR: Error en limpieza
- CACHE_ITEM_REMOVE_FAILED: Error al remover item
- CACHE_CLEAR_FAILED: Error al limpiar cache
- PREFETCH_FAILED: Fallos en prefetch
```

#### 2. **Retry Logic con Backoff Exponencial**
```typescript
// Configuración:
- MAX_RETRIES: 3 intentos
- BASE_RETRY_DELAY: 1000ms
- Backoff: 1s, 2s, 4s, 8s...
- Límite de cache: 500MB (aumentado desde 100MB)
```

#### 3. **Prefetching Inteligente**
```typescript
// Funciones disponibles:
- prefetchImages(): Prefetch genérico
- prefetchMenuImages(): Específico para menús
- Integración automática en useGetFullMenu()
```

#### 4. **Limpieza de Cache Optimizada**
```typescript
// Estrategia mejorada:
- Fase 1: Eliminación por edad (más eficiente)
- Fase 2: Eliminación por tamaño (LRU)
- Margen del 10% para evitar limpiezas frecuentes
- Logging detallado con métricas
```

### 📊 **Impacto en Rendimiento**

#### **Antes:**
- ❌ Doble resolución de URLs (componente + AutoImage)
- ❌ Sin retry en descargas fallidas
- ❌ Sin prefetch automático
- ❌ Limpieza básica de cache
- ❌ Logs excesivos para cada operación

#### **Después:**
- ✅ Resolución única de URLs (solo AutoImage)
- ✅ Retry automático con backoff exponencial
- ✅ Prefetch automático en background
- ✅ Limpieza inteligente con métricas
- ✅ Logging optimizado (solo errores y operaciones críticas)

### 🎯 **Beneficios Esperados**
- **30-50% reducción** en tiempo de carga de imágenes
- **60-80% reducción** en uso de ancho de banda
- **Mejor experiencia** en menús largos
- **Mayor confiabilidad** en conexiones inestables
- **Performance mejorada** sin logs innecesarios
- **Límite de cache aumentado** a 500MB para casos extremos

### 💡 **Uso Recomendado**

#### Para Desarrolladores:
```typescript
// ✅ Correcto - Usar AutoImage con path
<AutoImage source={item.photo?.path} />

// ❌ Incorrecto - No resolver URL manualmente
const imageUrl = await getImageUrl(item.photo.path);
<AutoImage source={imageUrl} />
```

#### Para Prefetch Manual:
```typescript
// Prefetch específico para menús
await prefetchMenuImages(menuData, {
  maxConcurrent: 3,
  onProgress: (completed, total) => console.log(`${completed}/${total}`)
});
```

### 📝 **Logs de Ejemplo (Solo Errores)**
```
[ImageCache] CACHE_MISS_FAILED: {
  url: "https://api.example.com/image.jpg",
  filename: "abc123.jpg",
  error: "Download failed after all retries"
}

[ImageCache] CACHE_CLEANED: {
  filesDeleted: 45,
  sizeCleaned: "123.45MB",
  totalFilesRemaining: 155,
  totalSizeRemaining: "376.55MB",
  originalSize: "500.00MB",
  spaceFreed: "123.45MB",
  cacheUtilization: "75.3%"
}

[ImageCache] PREFETCH_FAILED: {
  totalImages: 25,
  failed: 2,
  successRate: "92.0%"
}
```

## 🔍 **Monitoreo**

Para monitorear el rendimiento del cache, busca en los logs:
- Fallos en `CACHE_MISS_FAILED` 
- Limpiezas en `CACHE_CLEANED` para verificar uso de espacio
- Tasas de error en `PREFETCH_FAILED`
- Errores de sistema en `CACHE_*_ERROR`

## 🚀 **Activación**

El sistema está **completamente activado** y funcionando automáticamente:
- Cache se inicializa al arrancar la app
- Prefetch se ejecuta automáticamente al cargar menús
- Retry funciona automáticamente en descargas fallidas
- Limpieza se ejecuta automáticamente en segundo plano

================
File: app/src/app/navigation/OrdersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import OrdersScreen from '../../modules/orders/screens/OrdersScreen';
import CreateOrderScreen from '../../modules/orders/screens/CreateOrderScreen';
import OpenOrdersScreen from '../../modules/orders/screens/OpenOrdersScreen';
import AddProductsToOrderScreen from '../../modules/orders/screens/AddProductsToOrderScreen';
import type { OrdersStackParamList } from './types';
import { useAppTheme } from '../styles/theme';
import { getStackHeaderOptions } from './options';
const Stack = createNativeStackNavigator<OrdersStackParamList>();
function OrdersStackNavigator() {
  const theme = useAppTheme();
  return (
    <Stack.Navigator
      initialRouteName="Orders"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="Orders"
        component={OrdersScreen}
        options={{ title: 'Órdenes' }}
      />
      <Stack.Screen
        name="CreateOrder"
        component={CreateOrderScreen}
        options={{ title: 'Crear Nueva Orden', headerShown: false }}
      />
      <Stack.Screen
        name="OpenOrders"
        component={OpenOrdersScreen}
        options={{ title: 'Órdenes Abiertas' }}
      />
      <Stack.Screen
        name="AddProductsToOrder"
        component={AddProductsToOrderScreen}
        options={{ title: 'Añadir Productos', headerShown: false }}
      />
    </Stack.Navigator>
  );
}
export default OrdersStackNavigator;

================
File: app/src/app/schemas/domain/adjustment.schema.ts
================
import { z } from 'zod';
export const adjustmentSchema = z.object({
  id: z.string(),
  orderId: z.string().nullable().optional(),
  orderItemId: z.string().nullable().optional(),
  name: z.string(),
  isPercentage: z.boolean(),
  value: z.number(),
  amount: z.number(),
  appliedById: z.string(),
  appliedAt: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  deletedAt: z.string().nullable().optional(),
  order: z.any().optional(),
  orderItem: z.any().optional(),
  appliedBy: z.any().optional(),
});
export type Adjustment = z.infer<typeof adjustmentSchema>;
const createAdjustmentBaseSchema = z.object({
  orderId: z.string().uuid().optional(),
  orderItemId: z.string().uuid().optional(),
  name: z.string().max(100),
  isPercentage: z.boolean(),
  value: z.number().min(0).max(100).optional(),
  amount: z.number().optional(),
});
export const createAdjustmentSchema = createAdjustmentBaseSchema
  .refine(
    (data) => {
      return (
        (data.orderId && !data.orderItemId) ||
        (!data.orderId && data.orderItemId)
      );
    },
    {
      message:
        'El ajuste debe aplicarse a una orden o a un item de orden, pero no a ambos',
    },
  )
  .refine(
    (data) => {
      if (data.isPercentage) {
        return data.value !== undefined;
      } else {
        return data.amount !== undefined;
      }
    },
    {
      message:
        "Si es porcentaje debe incluir 'value', si no debe incluir 'amount'",
    },
  );
export type CreateAdjustment = z.infer<typeof createAdjustmentSchema>;
export const updateAdjustmentSchema = createAdjustmentBaseSchema.partial();
export type UpdateAdjustment = z.infer<typeof updateAdjustmentSchema>;

================
File: app/src/app/schemas/domain/area.schema.ts
================
import { z } from 'zod';
export const areaSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});
export type Area = z.infer<typeof areaSchema>;

================
File: app/src/app/schemas/domain/category.schema.ts
================
import { z } from 'zod';
export const categoryPhotoSchema = z.object({
  id: z.string(),
  path: z.string(),
});
export const categorySchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  sortOrder: z.number(),
  photo: categoryPhotoSchema.nullable().optional(),
});
export type CategoryPhoto = z.infer<typeof categoryPhotoSchema>;
export type Category = z.infer<typeof categorySchema>;

================
File: app/src/app/schemas/domain/delivery-info.schema.ts
================
import { z } from 'zod';
export const DeliveryInfoSchema = z.object({
  id: z.string().optional(),
  orderId: z.string().optional(),
  fullAddress: z.string().optional(),
  street: z.string().optional(),
  number: z.string().optional(),
  interiorNumber: z.string().optional(),
  neighborhood: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zipCode: z.string().optional(),
  country: z.string().optional(),
  recipientName: z.string().optional(),
  recipientPhone: z.string().optional(),
  deliveryInstructions: z.string().optional(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});
export type DeliveryInfo = z.infer<typeof DeliveryInfoSchema>;

================
File: app/src/app/schemas/domain/modifier-group.schema.ts
================
import { z } from 'zod';
export const modifierGroupSchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  minSelections: z.number().int().min(0).optional(),
  maxSelections: z.number().int().min(1).optional(),
  isRequired: z.boolean().optional(),
  allowMultipleSelections: z.boolean().optional(),
  isActive: z.boolean().optional(),
  sortOrder: z.number(),
});
export type ModifierGroup = z.infer<typeof modifierGroupSchema>;

================
File: app/src/app/schemas/domain/modifier.schema.ts
================
import { z } from 'zod';
export const modifierSchema = z.object({
  id: z.string(),
  modifierGroupId: z.string().min(1, 'El ID del grupo no es válido'),
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.coerce.number().nullable().optional(),
  sortOrder: z.number().int().default(0),
  isDefault: z.boolean().default(false),
  isActive: z.boolean().default(true),
});
export type Modifier = z.infer<typeof modifierSchema>;

================
File: app/src/app/schemas/domain/photo.schema.ts
================
import { z } from 'zod';
export const photoSchema = z.object({
  id: z.string().uuid(),
  path: z.string().url(),
});
export type Photo = z.infer<typeof photoSchema>;

================
File: app/src/app/schemas/domain/product-variant.schema.ts
================
import { z } from 'zod';
export const productVariantSchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce.number({
    invalid_type_error: 'El precio debe ser un número',
    required_error: 'El precio es requerido',
  }),
  isActive: z.boolean(),
  sortOrder: z.number(),
});
export type ProductVariant = z.infer<typeof productVariantSchema>;
export const productVariantInputSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce.number({
    invalid_type_error: 'El precio debe ser un número',
    required_error: 'El precio es requerido',
  }),
  isActive: z.boolean(),
  sortOrder: z.number(),
});
export type ProductVariantInput = z.infer<typeof productVariantInputSchema>;

================
File: app/src/app/schemas/domain/product.schema.ts
================
import { z } from 'zod';
import { photoSchema } from './photo.schema';
import { productVariantSchema } from './product-variant.schema';
import { modifierGroupSchema } from './modifier-group.schema';
import { preparationScreenSchema } from './preparation-screen.schema';
export const productSchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  price: z
    .number()
    .positive('El precio debe ser positivo')
    .refine((val) => /^\d+(\.\d{1,2})?$/.test(String(val)), {
      message: 'El precio debe tener como máximo dos decimales',
    })
    .optional()
    .nullable(),
  hasVariants: z.boolean(),
  isActive: z.boolean(),
  isPizza: z.boolean(),
  subcategoryId: z.string().min(1, 'La subcategoría es requerida'),
  sortOrder: z.number(),
  photo: photoSchema.optional().nullable(),
  estimatedPrepTime: z
    .number()
    .min(1, 'El tiempo debe ser al menos 1 minuto')
    .optional(),
  preparationScreenId: z.string().optional().nullable(),
  preparationScreen: preparationScreenSchema.optional().nullable(),
  variants: z.array(productVariantSchema).optional(),
  modifierGroups: z.array(modifierGroupSchema).optional(),
  pizzaCustomizations: z.array(z.any()).optional(),
  pizzaConfiguration: z.any().optional(),
  createdAt: z.union([z.string().datetime(), z.date()]).optional(),
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(),
});
export type Product = z.infer<typeof productSchema> & {
  pizzaCustomizations?: any[];
  pizzaConfiguration?: any;
};

================
File: app/src/app/schemas/domain/subcategory.schema.ts
================
import { z } from 'zod';
import { photoSchema } from './photo.schema';
export const subCategorySchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  categoryId: z.string().min(1, 'El ID de categoría no es válido'),
  sortOrder: z.number(),
  photo: photoSchema.nullable().optional(),
  createdAt: z.union([z.string().datetime(), z.date()]).optional(),
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(),
});
export type SubCategory = z.infer<typeof subCategorySchema>;

================
File: app/src/app/store/snackbarStore.ts
================
import { create } from 'zustand';
export type SnackbarType = 'info' | 'success' | 'error' | 'warning';
export interface SnackbarState {
  visible: boolean;
  message: string;
  type: SnackbarType;
  duration?: number;
  showSnackbar: (params: {
    message: string;
    type?: SnackbarType;
    duration?: number;
  }) => void;
  hideSnackbar: () => void;
}
export const useSnackbarStore = create<SnackbarState>((set) => ({
  visible: false,
  message: '',
  type: 'info',
  duration: 2000,
  showSnackbar: ({ message, type = 'info', duration = 2000 }) =>
    set({ visible: true, message, type, duration }),
  hideSnackbar: () => set({ visible: false }),
}));

================
File: app/src/app/styles/colors.ts
================
export const lightColors = {
  primary: '#1976D2',
  primaryContainer: '#BBDEFB',
  onPrimary: '#FFFFFF',
  onPrimaryContainer: '#004C8B',
  secondary: '#FF9800',
  secondaryContainer: '#FFE0B2',
  onSecondary: '#FFFFFF',
  onSecondaryContainer: '#562800',
  tertiary: '#43A047',
  tertiaryContainer: '#C8E6C9',
  onTertiary: '#FFFFFF',
  onTertiaryContainer: '#002411',
  background: '#F8F9FA',
  onBackground: '#202124',
  surface: '#FFFFFF',
  onSurface: '#202124',
  surfaceVariant: '#E4E6EB',
  onSurfaceVariant: '#44464F',
  error: '#B00020',
  errorContainer: '#FFDAD6',
  onError: '#FFFFFF',
  onErrorContainer: '#410002',
  outline: '#74777F',
  outlineVariant: '#C4C7C5',
  inverseSurface: '#2E3133',
  inverseOnSurface: '#F2F2F2',
  inversePrimary: '#80CBC4',
  success: '#2E7D32',
  successContainer: '#C8E6C9',
  onSuccessContainer: '#0D3912',
  warning: '#F57C00',
  warningContainer: '#FFE0B2',
  onWarningContainer: '#662D00',
  info: '#1976D2',
  infoContainer: '#BBDEFB',
  onInfoContainer: '#00325B',
};
export const darkColors = {
  primary: '#FF7043',
  primaryContainer: '#662E1A',
  onPrimary: '#FFFFFF',
  onPrimaryContainer: '#FFDACF',
  secondary: '#FFB74D',
  secondaryContainer: '#774B1F',
  onSecondary: '#000000',
  onSecondaryContainer: '#FFE0B2',
  tertiary: '#FFD54F',
  tertiaryContainer: '#775B25',
  onTertiary: '#000000',
  onTertiaryContainer: '#FFF3C4',
  background: '#121212',
  onBackground: '#FFFFFF',
  surface: '#1E1E1E',
  onSurface: '#FFFFFF',
  surfaceVariant: '#2C2C2C',
  onSurfaceVariant: '#9E9E9E',
  error: '#FF6B6B',
  errorContainer: '#4D2626',
  onError: '#FFFFFF',
  onErrorContainer: '#FFE5E5',
  outline: '#4F4F4F',
  outlineVariant: '#3D3D3D',
  inverseSurface: '#FFFFFF',
  inverseOnSurface: '#121212',
  inversePrimary: '#FF5722',
  success: '#69F0AE',
  successContainer: '#1B5E20',
  onSuccessContainer: '#B3FFD1',
  warning: '#FFC107',
  warningContainer: '#795548',
  onWarningContainer: '#FFE0B2',
  info: '#64B5F6',
  infoContainer: '#1565C0',
  onInfoContainer: '#B3E5FC',
};

================
File: app/src/app/styles/theme.ts
================
import { MD3LightTheme, MD3DarkTheme, useTheme } from 'react-native-paper';
import type { MD3Typescale } from 'react-native-paper/lib/typescript/types';
import { lightColors, darkColors } from './colors';
import { typography } from './typography';
import { BREAKPOINTS, DEVICE_TYPES, RESPONSIVE_DIMENSIONS } from './responsive';
declare global {
  namespace ReactNativePaper {
    interface MD3Colors {
      success: string;
      successContainer: string;
      onSuccessContainer: string;
      warning: string;
      warningContainer: string;
      onWarningContainer: string;
      info: string;
      infoContainer: string;
      onInfoContainer: string;
    }
  }
}
const spacing = {
  xs: 4,
  s: 8,
  m: 16,
  l: 24,
  xl: 32,
  xxl: 40,
};
const responsive = {
  breakpoints: BREAKPOINTS,
  deviceTypes: DEVICE_TYPES,
  dimensions: RESPONSIVE_DIMENSIONS,
};
const typescale: MD3Typescale = {
  default: {
    fontFamily: typography.bodyMedium.fontFamily,
    fontWeight: 'normal',
    letterSpacing: typography.bodyMedium.letterSpacing,
  },
  displayLarge: { ...typography.displayLarge, fontWeight: 'normal' },
  displayMedium: { ...typography.displayMedium, fontWeight: 'normal' },
  displaySmall: { ...typography.displaySmall, fontWeight: 'normal' },
  headlineLarge: { ...typography.headlineLarge, fontWeight: 'normal' },
  headlineMedium: { ...typography.headlineMedium, fontWeight: 'normal' },
  headlineSmall: { ...typography.headlineSmall, fontWeight: 'normal' },
  titleLarge: { ...typography.titleLarge, fontWeight: 'normal' },
  titleMedium: { ...typography.titleMedium, fontWeight: '500' },
  titleSmall: { ...typography.titleSmall, fontWeight: '500' },
  bodyLarge: { ...typography.bodyLarge, fontWeight: 'normal' },
  bodyMedium: { ...typography.bodyMedium, fontWeight: 'normal' },
  bodySmall: { ...typography.bodySmall, fontWeight: 'normal' },
  labelLarge: { ...typography.labelLarge, fontWeight: '500' },
  labelMedium: { ...typography.labelMedium, fontWeight: '500' },
  labelSmall: { ...typography.labelSmall, fontWeight: '500' },
};
export const lightTheme = {
  ...MD3LightTheme,
  colors: {
    ...MD3LightTheme.colors,
    ...lightColors,
  },
  fonts: typescale,
  spacing,
  responsive,
  roundness: 8,
};
export const darkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...MD3DarkTheme.colors,
    ...darkColors,
  },
  fonts: typescale,
  spacing,
  responsive,
  roundness: 8,
};
export type AppTheme = typeof lightTheme;
export const useAppTheme = () => {
  try {
    const theme = useTheme();
    if (!theme || typeof theme !== 'object') {
      return lightTheme;
    }
    return theme as AppTheme;
  } catch (error) {
    return lightTheme;
  }
};

================
File: app/src/app/styles/typography.ts
================
import { Platform } from 'react-native';
export const typography = {
  fonts: {
    regular: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    medium: Platform.select({
      ios: 'SF Pro Text-Medium',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    light: Platform.select({
      ios: 'SF Pro Text-Light',
      android: 'Roboto-Light',
      default: 'System-Light',
    }),
    thin: Platform.select({
      ios: 'SF Pro Text-Thin',
      android: 'Roboto-Thin',
      default: 'System-Thin',
    }),
  },
  displayLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 57,
    lineHeight: 64,
    letterSpacing: -0.25,
  },
  displayMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 45,
    lineHeight: 52,
    letterSpacing: 0,
  },
  displaySmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 36,
    lineHeight: 44,
    letterSpacing: 0,
  },
  headlineLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 32,
    lineHeight: 40,
    letterSpacing: 0,
  },
  headlineMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 28,
    lineHeight: 36,
    letterSpacing: 0,
  },
  headlineSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 24,
    lineHeight: 32,
    letterSpacing: 0,
  },
  titleLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 22,
    lineHeight: 28,
    letterSpacing: 0,
  },
  titleMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.15,
  },
  titleSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  labelSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 11,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  bodyLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.5,
  },
  bodyMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.25,
  },
  bodySmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.4,
  },
};
export const iosFontFamily = {
  regular: 'System',
  medium: 'System',
  light: 'System',
  thin: 'System',
};
export const androidFontFamily = {
  regular: 'sans-serif',
  medium: 'sans-serif-medium',
  light: 'sans-serif-light',
  thin: 'sans-serif-thin',
};

================
File: app/src/app/types/api.types.ts
================
import { z } from 'zod';
export interface BackendErrorResponse {
  statusCode: number;
  code: string;
  message: string;
  details?: any;
  timestamp?: string;
  path?: string;
}
export const baseListQuerySchema = z.object({
  page: z.coerce.number().int().positive().optional().default(1),
  limit: z.coerce.number().int().positive().optional().default(10),
});
export type BaseListQueryDto = {
  page?: number;
  limit?: number;
};
export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

================
File: app/src/app/types/query.types.ts
================
import { z } from 'zod';
export const baseListQuerySchema = z.object({
  page: z.number().int().positive().optional().default(1),
  limit: z.number().int().positive().optional().default(10),
  search: z.string().optional(),
});
export type BaseListQuery = z.infer<typeof baseListQuerySchema>;

================
File: app/src/app/utils/dateTimeHelpers.ts
================
import { format, parse, setHours, setMinutes, isValid } from 'date-fns';
import { es } from 'date-fns/locale';
export const safeTimeStringToDate = (
  timeString: string,
  baseDate?: Date,
): Date => {
  if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) {
    throw new Error('Formato de hora inválido. Use HH:mm');
  }
  const [hourStr, minuteStr] = timeString.split(':');
  const hour = parseInt(hourStr, 10);
  const minute = parseInt(minuteStr, 10);
  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
    throw new Error('Hora o minutos fuera de rango');
  }
  let date = baseDate ? new Date(baseDate) : new Date();
  date = setHours(date, hour);
  date = setMinutes(date, minute);
  date.setSeconds(0);
  date.setMilliseconds(0);
  return date;
};
export const safeDateToTimeString = (date: Date): string => {
  if (!date || !isValid(date)) {
    throw new Error('Fecha inválida');
  }
  return format(date, 'HH:mm');
};
export const createScheduledDateTime = (
  dateStr: string | Date,
  timeStr: string,
): Date => {
  let baseDate: Date;
  if (typeof dateStr === 'string') {
    baseDate = parse(dateStr, 'yyyy-MM-dd', new Date());
    if (!isValid(baseDate)) {
      throw new Error('Fecha inválida');
    }
  } else {
    baseDate = new Date(dateStr);
  }
  return safeTimeStringToDate(timeStr, baseDate);
};
export const formatDateTimeDisplay = (
  date: Date,
  includeTime: boolean = true,
): string => {
  if (!date || !isValid(date)) {
    return '';
  }
  if (includeTime) {
    return format(date, "d 'de' MMMM 'a las' HH:mm", { locale: es });
  }
  return format(date, "d 'de' MMMM 'de' yyyy", { locale: es });
};
export const getDateTimeForBackend = (date: Date): string => {
  if (!date || !isValid(date)) {
    throw new Error('Fecha inválida para backend');
  }
  return date.toISOString();
};
export const parseDateFromBackend = (
  dateStr: string | null | undefined,
): Date | null => {
  if (!dateStr) {
    return null;
  }
  try {
    const date = new Date(dateStr);
    return isValid(date) ? date : null;
  } catch {
    return null;
  }
};
export const roundMinutesToFive = (minutes: number): number => {
  const quotient = Math.floor(minutes / 5);
  const remainder = minutes - quotient * 5;
  if (remainder >= 3) {
    return (quotient + 1) * 5;
  }
  return quotient * 5;
};
export const isFutureDateTime = (date: Date): boolean => {
  if (!date || !isValid(date)) {
    return false;
  }
  const now = new Date();
  return date.getTime() > now.getTime();
};
export const getNextAvailableTime = (
  minimumMinutesAhead: number = 30,
): Date => {
  const now = new Date();
  const futureTime = new Date(now.getTime() + minimumMinutesAhead * 60 * 1000);
  const roundedMinutes = roundMinutesToFive(futureTime.getMinutes());
  let result = setMinutes(futureTime, roundedMinutes);
  result.setSeconds(0);
  result.setMilliseconds(0);
  if (result.getTime() <= now.getTime()) {
    result = new Date(result.getTime() + 5 * 60 * 1000);
  }
  return result;
};

================
File: app/src/components/index.ts
================
export { AudioRecorderWidget } from './AudioRecorderWidget';
export { AudioOrderModal } from './AudioOrderModal';

================
File: app/src/hooks/useOrientation.ts
================
import { useState, useEffect } from 'react';
import { Dimensions } from 'react-native';
export function useOrientation() {
  const [isLandscape, setIsLandscape] = useState(
    Dimensions.get('window').width > Dimensions.get('window').height,
  );
  useEffect(() => {
    const updateOrientation = () => {
      const { width, height } = Dimensions.get('window');
      setIsLandscape(width > height);
    };
    const subscription = Dimensions.addEventListener(
      'change',
      updateOrientation,
    );
    return () => subscription?.remove();
  }, []);
  return isLandscape;
}

================
File: app/src/hooks/useSnackbar.ts
================
import { useSnackbarStore, SnackbarType } from '@/app/store/snackbarStore';
export function useSnackbar() {
  const { showSnackbar: show, hideSnackbar } = useSnackbarStore();
  const showSnackbar = (
    message: string,
    type: SnackbarType = 'info',
    duration?: number,
  ) => {
    show({ message, type, duration });
  };
  return {
    showSnackbar,
    hideSnackbar,
  };
}

================
File: app/src/modules/areasTables/components/AreaFormModal.tsx
================
import React from 'react';
import GenericFormModal, {
  FormFieldConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  CreateAreaSchema,
  UpdateAreaSchema,
} from '../schema/area.schema';
import { z } from 'zod';
const areaFormFields: FormFieldConfig<CreateAreaDto | UpdateAreaDto>[] = [
  {
    name: 'name',
    label: 'Nombre del Área',
    type: 'text',
    placeholder: 'Ej: Terraza, Salón Principal',
    required: true,
  },
  {
    name: 'description',
    label: 'Descripción (Opcional)',
    type: 'textarea',
    placeholder: 'Ej: Área al aire libre con vista',
    numberOfLines: 3,
  },
  {
    name: 'isActive',
    label: '¿Está activa?',
    type: 'switch',
    switchLabel: 'Activa',
    defaultValue: true,
  },
];
interface AreaFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: CreateAreaDto | UpdateAreaDto,
    photoId: string | null | undefined,
  ) => Promise<void>;
  editingItem: Area | null;
  isSubmitting: boolean;
}
const AreaFormModal: React.FC<AreaFormModalProps> = ({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}) => {
  const isEditing = !!editingItem;
  const formSchema = isEditing ? UpdateAreaSchema : CreateAreaSchema;
  const initialValues = isEditing
    ? {
        name: editingItem?.name,
        description: editingItem?.description ?? undefined,
        isActive: editingItem?.isActive,
      }
    : {
        name: '',
        description: undefined,
        isActive: true,
      };
  return (
    <GenericFormModal<CreateAreaDto | UpdateAreaDto, Area>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={onSubmit}
      formSchema={formSchema as z.ZodSchema<CreateAreaDto | UpdateAreaDto>}
      formFields={areaFormFields}
      initialValues={initialValues}
      editingItem={editingItem}
      isSubmitting={isSubmitting}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Área' : 'Crear Nueva Área'
      }
    />
  );
};
export default AreaFormModal;

================
File: app/src/modules/areasTables/components/TableFormModal.tsx
================
import React from 'react';
import GenericFormModal, {
  FormFieldConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  CreateTableSchema,
  UpdateTableSchema,
} from '../schema/table.schema';
import { z } from 'zod';
const tableFormFields: FormFieldConfig<CreateTableDto | UpdateTableDto>[] = [
  {
    name: 'name',
    label: 'Nombre de la Mesa',
    type: 'text',
    placeholder: 'Ej: Mesa 1, Barra 2',
    required: true,
  },
  {
    name: 'capacity',
    label: 'Capacidad (Opcional)',
    type: 'number',
    placeholder: 'Ej: 4',
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'isActive',
    label: '¿Está activa?',
    type: 'switch',
    switchLabel: 'Activa',
    defaultValue: true,
  },
];
interface TableFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: CreateTableDto | UpdateTableDto,
    photoId: string | null | undefined,
  ) => Promise<void>;
  editingItem: Table | null;
  isSubmitting: boolean;
}
const TableFormModal: React.FC<TableFormModalProps> = ({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}) => {
  const isEditing = !!editingItem;
  const formSchema = isEditing ? UpdateTableSchema : CreateTableSchema;
  const initialValues = isEditing
    ? {
        name: editingItem?.name,
        capacity: editingItem?.capacity ?? undefined,
        isActive: editingItem?.isActive,
      }
    : {
        name: '',
        capacity: undefined,
        isActive: true,
      };
  return (
    <GenericFormModal<CreateTableDto | UpdateTableDto, Table>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={onSubmit}
      formSchema={formSchema as z.ZodSchema<CreateTableDto | UpdateTableDto>}
      formFields={tableFormFields}
      initialValues={initialValues}
      editingItem={editingItem}
      isSubmitting={isSubmitting}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Mesa' : 'Crear Nueva Mesa'
      }
    />
  );
};
export default TableFormModal;

================
File: app/src/modules/areasTables/navigation/AreasTablesStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AreasTablesStackParamList } from './types';
import AreasScreen from '../screens/AreasScreen';
import TablesScreen from '../screens/TablesScreen';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';
const Stack = createNativeStackNavigator<AreasTablesStackParamList>();
const AreasTablesStackNavigator = () => {
  const theme = useAppTheme();
  return (
    <Stack.Navigator
      initialRouteName="AreasList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="AreasList"
        component={AreasScreen}
        options={{
          title: 'Áreas',
        }}
      />
      <Stack.Screen
        name="TablesList"
        component={TablesScreen}
        options={({ route }) => ({
          title: `Mesas de ${route.params.areaName || 'Área'}`,
        })}
      />
    </Stack.Navigator>
  );
};
export default AreasTablesStackNavigator;

================
File: app/src/modules/areasTables/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '../../../app/navigation/types';
export type AreasTablesStackParamList = {
  AreasList: undefined;
  TablesList: { areaId: string; areaName: string };
};
export type AreasListScreenProps = NativeStackScreenProps<
  AreasTablesStackParamList,
  'AreasList'
>;
export type TablesListScreenProps = NativeStackScreenProps<
  AreasTablesStackParamList,
  'TablesList'
>;
export type AreasTablesDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'AreasTablesStack'
>;

================
File: app/src/modules/areasTables/schema/area.schema.ts
================
import { z } from 'zod';
import type { Area } from '../../../app/schemas/domain/area.schema';
export const CreateAreaSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().optional(),
  isActive: z.boolean().optional().default(true),
});
export const UpdateAreaSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').optional(),
  description: z.string().optional(),
  isActive: z.boolean().optional(),
});
export type CreateAreaDto = z.infer<typeof CreateAreaSchema>;
export type UpdateAreaDto = z.infer<typeof UpdateAreaSchema>;
export const FindAllAreasSchema = z.object({
  name: z.string().optional(),
  isActive: z.boolean().optional(),
});
export type FindAllAreasDto = z.infer<typeof FindAllAreasSchema>;
export type { Area };

================
File: app/src/modules/areasTables/schema/table.schema.ts
================
import { z } from 'zod';
import type { Table } from '../../../app/schemas/domain/table.schema';
export const CreateTableSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  capacity: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce
      .number()
      .int()
      .positive('La capacidad debe ser un número positivo')
      .nullable()
      .optional(),
  ),
  isActive: z.boolean().optional().default(true),
});
export const UpdateTableSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').optional(),
  capacity: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce
      .number()
      .int()
      .positive('La capacidad debe ser un número positivo')
      .nullable()
      .optional(),
  ),
  isActive: z.boolean().optional(),
});
export type CreateTableDto = z.infer<typeof CreateTableSchema>;
export type UpdateTableDto = z.infer<typeof UpdateTableSchema>;
const transformBoolean = (val: unknown) => {
  if (val === 'true') return true;
  if (val === 'false') return false;
  return val;
};
export const FindAllTablesSchema = z.object({
  name: z.string().optional(),
  areaId: z.string().uuid().optional(),
  capacity: z.coerce.number().int().optional(),
  isActive: z.preprocess(transformBoolean, z.boolean().optional()),
  isAvailable: z.preprocess(transformBoolean, z.boolean().optional()),
  isTemporary: z.preprocess(transformBoolean, z.boolean().optional()),
});
export type FindAllTablesDto = z.infer<typeof FindAllTablesSchema>;
export type { Table };

================
File: app/src/modules/areasTables/types/areasTables.types.ts
================
import type { Area } from '../schema/area.schema';
import type { Table } from '../schema/table.schema';
export type { Area, Table };

================
File: app/src/modules/auth/schema/auth.schema.ts
================
import { z } from 'zod';
export const loginSchema = z.object({
  emailOrUsername: z
    .string()
    .min(1, 'El correo o nombre de usuario es requerido'),
  password: z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
});
export type LoginFormInputs = z.infer<typeof loginSchema>;
export const authResponseSchema = z.object({
  token: z.string(),
  user: z.object({
    id: z.string(),
    email: z.string().email(),
    username: z.string(),
    role: z.enum(['admin', 'staff']),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().url().optional(),
  }),
});
export type AuthResponse = z.infer<typeof authResponseSchema>;
export const authEmailLoginDtoSchema = z.object({
  email: z.string().email().optional(),
  username: z.string().optional(),
  password: z.string(),
});
export type AuthEmailLoginDto = z.infer<typeof authEmailLoginDtoSchema>;
export const userSchema = z.object({
  id: z.string().uuid('El ID de usuario debe ser un UUID válido'),
  email: z.string().email().nullable(),
  username: z.string().nullable(),
  firstName: z.string().nullable(),
  lastName: z.string().nullable(),
  role: z
    .object({
      id: z.number(),
      name: z.string(),
    })
    .optional(),
  isActive: z.boolean().optional(),
  preparationScreen: z
    .object({
      id: z.string(),
      name: z.string(),
      description: z.string().nullable(),
      isActive: z.boolean(),
    })
    .nullable()
    .optional(),
});
export type User = z.infer<typeof userSchema>;
export const loginResponseDtoSchema = z.object({
  token: z.string(),
  refreshToken: z.string(),
  tokenExpires: z.number(),
  user: userSchema,
});
export type LoginResponseDto = z.infer<typeof loginResponseDtoSchema>;
export const registerSchema = z.object({
  email: z.string().email('Correo electrónico inválido'),
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .regex(
      /^[a-zA-Z0-9_]+$/,
      'Solo se permiten letras, números y guiones bajos',
    ),
  password: z.string().min(8, 'La contraseña debe tener al menos 8 caracteres'),
  firstName: z.string().min(1, 'El nombre es requerido'),
  lastName: z.string().min(1, 'El apellido es requerido'),
});
export type RegisterFormInputs = z.infer<typeof registerSchema>;

================
File: app/src/modules/auth/types/auth.types.ts
================
import type { AuthResponse, LoginFormInputs } from '../schema/auth.schema';
export interface AuthState {
  token: string | null;
  user: AuthResponse['user'] | null;
  isLoading: boolean;
  error: string | null;
  login: (credentials: LoginFormInputs) => Promise<void>;
  logout: () => void;
  clearError: () => void;
}
export interface RegisterResponseDto {
  message: string;
}

================
File: app/src/modules/availability/hooks/useAvailabilityQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { availabilityService } from '../services/availabilityService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
export const useMenuAvailability = () => {
  return useQuery({
    queryKey: ['availability', 'menu'],
    queryFn: availabilityService.getMenuAvailability,
  });
};
export const useModifierGroupsAvailability = () => {
  return useQuery({
    queryKey: ['availability', 'modifierGroups'],
    queryFn: availabilityService.getModifierGroupsAvailability,
  });
};
export const useUpdateAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: availabilityService.updateAvailability,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: () => {
      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
  });
};
export const useBulkUpdateAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: availabilityService.bulkUpdateAvailability,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: () => {
      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/availability/hooks/usePizzaCustomizationsAvailability.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { PizzaCustomizationGroupAvailability } from '../types/availability.types';
export function usePizzaCustomizationsAvailability(search?: string) {
  return useQuery({
    queryKey: ['availability', 'pizzaCustomizations', search],
    queryFn: async () => {
      const response = await apiClient.get<
        PizzaCustomizationGroupAvailability[]
      >(API_PATHS.AVAILABILITY_PIZZA_CUSTOMIZATIONS);
      if (!response.ok || !response.data) {
        throw new Error('Failed to fetch pizza customizations availability');
      }
      let data = response.data;
      if (search) {
        const searchLower = search.toLowerCase();
        data = data
          .map((group) => ({
            ...group,
            items: group.items.filter((item) =>
              item.name.toLowerCase().includes(searchLower),
            ),
          }))
          .filter((group) => group.items.length > 0);
      }
      return data;
    },
  });
}

================
File: app/src/modules/availability/navigation/AvailabilityStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AvailabilityScreen } from '../screens/AvailabilityScreen';
import { AvailabilityStackParamList } from './types';
import { getStackHeaderOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';
const Stack = createNativeStackNavigator<AvailabilityStackParamList>();
export const AvailabilityStackNavigator = () => {
  const theme = useAppTheme();
  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="AvailabilityScreen"
        component={AvailabilityScreen}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/availability/navigation/types.ts
================
import { NativeStackScreenProps } from '@react-navigation/native-stack';
export type AvailabilityStackParamList = {
  AvailabilityScreen: undefined;
};
export type AvailabilityScreenProps = NativeStackScreenProps<
  AvailabilityStackParamList,
  'AvailabilityScreen'
>;

================
File: app/src/modules/availability/services/availabilityService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  AvailabilityUpdatePayload,
  CategoryAvailability,
  ModifierGroupAvailability,
} from '../types/availability.types';
export const availabilityService = {
  async getMenuAvailability(): Promise<CategoryAvailability[]> {
    const response = await apiClient.get<CategoryAvailability[]>(
      API_PATHS.AVAILABILITY_MENU,
    );
    return response.data || [];
  },
  async getModifierGroupsAvailability(): Promise<ModifierGroupAvailability[]> {
    const response = await apiClient.get<ModifierGroupAvailability[]>(
      API_PATHS.AVAILABILITY_MODIFIER_GROUPS,
    );
    return response.data || [];
  },
  async updateAvailability(payload: AvailabilityUpdatePayload): Promise<void> {
    await apiClient.patch(API_PATHS.AVAILABILITY_UPDATE, payload);
  },
  async bulkUpdateAvailability(
    updates: AvailabilityUpdatePayload[],
  ): Promise<void> {
    await apiClient.patch(API_PATHS.AVAILABILITY_BULK_UPDATE, { updates });
  },
};

================
File: app/src/modules/availability/types/availability.types.ts
================
export interface CategoryAvailability {
  id: string;
  name: string;
  isActive: boolean;
  subcategories: SubcategoryAvailability[];
}
export interface SubcategoryAvailability {
  id: string;
  name: string;
  isActive: boolean;
  categoryId: string;
  products: ProductAvailability[];
}
export interface ProductAvailability {
  id: string;
  name: string;
  isActive: boolean;
  subcategoryId: string;
  modifierGroups?: ModifierGroupAvailability[];
}
export interface ModifierGroupAvailability {
  id: string;
  name: string;
  isActive: boolean;
  modifiers: ModifierAvailability[];
}
export interface ModifierAvailability {
  id: string;
  name: string;
  isActive: boolean;
  modifierGroupId: string;
}
export interface PizzaCustomizationAvailability {
  id: string;
  name: string;
  type: 'FLAVOR' | 'INGREDIENT';
  isActive: boolean;
  sortOrder: number;
}
export interface PizzaCustomizationGroupAvailability {
  type: string;
  items: PizzaCustomizationAvailability[];
}
export interface AvailabilityUpdatePayload {
  type:
    | 'category'
    | 'subcategory'
    | 'product'
    | 'modifierGroup'
    | 'modifier'
    | 'pizzaCustomization';
  id: string;
  isActive: boolean;
  cascade?: boolean;
}
export interface AvailabilityFilter {
  search?: string;
  showOnlyUnavailable?: boolean;
  categoryId?: string;
  subcategoryId?: string;
}

================
File: app/src/modules/customers/navigation/CustomersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import CustomersScreen from '../screens/CustomersScreen';
export type CustomersStackParamList = {
  Customers: undefined;
  CustomerDetail?: { customerId: string };
  CustomerAddresses?: { customerId: string };
  CustomerChatHistory?: { customerId: string };
};
const Stack = createNativeStackNavigator<CustomersStackParamList>();
export function CustomersStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="Customers"
        component={CustomersScreen}
        options={{
          title: 'Clientes',
        }}
      />
      {
}
    </Stack.Navigator>
  );
}

================
File: app/src/modules/kitchen/components/KitchenFilterButton.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  Dimensions,
  TouchableOpacity,
  Animated,
  ScrollView,
} from 'react-native';
import { Portal, Modal, Surface, Text, Switch } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useKitchenStore } from '../store/kitchenStore';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { OrderType } from '../types/kitchen.types';
const { width: screenWidth, height: screenHeight } = Dimensions.get('window');
export const KitchenFilterButton: React.FC = () => {
  const theme = useAppTheme();
  const [visible, setVisible] = useState(false);
  const { filters, setFilters } = useKitchenStore();
  const scaleAnim = React.useRef(new Animated.Value(1)).current;
  const activeFiltersCount = [
    filters.showPrepared,
    filters.showAllProducts,
    filters.ungroupProducts,
    filters.orderType !== undefined,
  ].filter(Boolean).length;
  const handleToggleFilter = (filterName: keyof typeof filters) => {
    setFilters({
      ...filters,
      [filterName]: !filters[filterName],
    });
  };
  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: 0.9,
      useNativeDriver: true,
    }).start();
  };
  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      useNativeDriver: true,
    }).start();
  };
  return (
    <>
      <TouchableOpacity
        onPress={() => setVisible(true)}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        activeOpacity={0.8}
        style={styles.buttonContainer}
      >
        <Animated.View
          style={[
            styles.filterButton,
            {
              backgroundColor:
                activeFiltersCount > 0
                  ? theme.colors.primaryContainer
                  : 'rgba(255,255,255,0.2)',
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <Icon
            name="tune-variant"
            size={24}
            color={
              activeFiltersCount > 0
                ? theme.colors.onPrimaryContainer
                : theme.colors.onPrimary
            }
          />
          {activeFiltersCount > 0 && (
            <View
              style={[
                styles.badge,
                {
                  backgroundColor: theme.colors.error,
                },
              ]}
            >
              <Text style={[styles.badgeText, { color: theme.colors.onError }]}>
                {activeFiltersCount}
              </Text>
            </View>
          )}
        </Animated.View>
      </TouchableOpacity>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={() => setVisible(false)}
          contentContainerStyle={[
            styles.modalContent,
            {
              backgroundColor: theme.colors.surface,
            },
          ]}
        >
          <ScrollView
            style={{
              maxHeight: screenHeight < 400 ? screenHeight - 80 : undefined,
            }}
            showsVerticalScrollIndicator={false}
          >
            <Surface
              style={[
                styles.modalSurface,
                { backgroundColor: theme.colors.surface },
              ]}
              elevation={3}
            >
              <View
                style={[
                  styles.modalHeader,
                  { backgroundColor: theme.colors.primaryContainer },
                ]}
              >
                <View style={styles.headerContent}>
                  <Icon
                    name="tune-variant"
                    size={24}
                    color={theme.colors.onPrimaryContainer}
                  />
                  <View style={styles.headerTextContainer}>
                    <Text
                      variant="titleMedium"
                      style={[
                        styles.modalTitle,
                        { color: theme.colors.onPrimaryContainer },
                      ]}
                    >
                      Filtros de visualización
                    </Text>
                  </View>
                </View>
                <TouchableOpacity
                  onPress={() => setVisible(false)}
                  style={styles.closeButton}
                >
                  <Icon
                    name="close"
                    size={22}
                    color={theme.colors.onPrimaryContainer}
                  />
                </TouchableOpacity>
              </View>
              <View style={styles.filtersList}>
                {}
                <View style={styles.sectionHeader}>
                  <Text
                    variant="titleMedium"
                    style={{ color: theme.colors.onSurface, fontWeight: '600' }}
                  >
                    Tipo de orden
                  </Text>
                </View>
                <View style={styles.orderTypeContainer}>
                  {[
                    { value: undefined, label: 'Todos', icon: 'check-all' },
                    {
                      value: OrderType.DINE_IN,
                      label: 'Mesa',
                      icon: 'table-chair',
                    },
                    {
                      value: OrderType.TAKE_AWAY,
                      label: 'Llevar',
                      icon: 'bag-checked',
                    },
                    {
                      value: OrderType.DELIVERY,
                      label: 'Domicilio',
                      icon: 'moped',
                    },
                  ].map((option) => {
                    const isSelected = filters.orderType === option.value;
                    return (
                      <TouchableOpacity
                        key={option.label}
                        style={[
                          styles.orderTypeButton,
                          isSelected && {
                            backgroundColor: theme.colors.primaryContainer,
                            borderColor: theme.colors.primary,
                          },
                          !isSelected && {
                            backgroundColor: theme.colors.surfaceVariant,
                            borderColor: 'transparent',
                          },
                        ]}
                        onPress={() =>
                          setFilters({ ...filters, orderType: option.value })
                        }
                        activeOpacity={0.8}
                      >
                        <Icon
                          name={option.icon}
                          size={20}
                          color={
                            isSelected
                              ? theme.colors.onPrimaryContainer
                              : theme.colors.onSurfaceVariant
                          }
                        />
                        <Text
                          variant="labelMedium"
                          style={{
                            color: isSelected
                              ? theme.colors.onPrimaryContainer
                              : theme.colors.onSurfaceVariant,
                            fontWeight: isSelected ? '700' : '500',
                            marginTop: 4,
                          }}
                        >
                          {option.label}
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </View>
                <View
                  style={[
                    styles.divider,
                    { backgroundColor: theme.colors.outlineVariant },
                  ]}
                />
                {}
                <View style={styles.sectionHeader}>
                  <Text
                    variant="titleMedium"
                    style={{ color: theme.colors.onSurface, fontWeight: '600' }}
                  >
                    Opciones de visualización
                  </Text>
                </View>
                <TouchableOpacity
                  onPress={() => handleToggleFilter('showPrepared')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.showPrepared && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.showPrepared
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="check-circle-outline"
                          size={22}
                          color={
                            filters.showPrepared
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={{
                            color: theme.colors.onSurface,
                            fontWeight: '600',
                          }}
                        >
                          Mostrar listas
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={{ color: theme.colors.onSurfaceVariant }}
                        >
                          Muestra solo las órdenes listas
                        </Text>
                      </View>
                      <Switch
                        value={filters.showPrepared}
                        onValueChange={() => handleToggleFilter('showPrepared')}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>
                <TouchableOpacity
                  onPress={() => handleToggleFilter('showAllProducts')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.showAllProducts && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.showAllProducts
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="eye-outline"
                          size={22}
                          color={
                            filters.showAllProducts
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={{
                            color: theme.colors.onSurface,
                            fontWeight: '600',
                          }}
                        >
                          Ver todos los productos
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={{ color: theme.colors.onSurfaceVariant }}
                        >
                          Muestra productos de todas las órdenes
                        </Text>
                      </View>
                      <Switch
                        value={filters.showAllProducts}
                        onValueChange={() =>
                          handleToggleFilter('showAllProducts')
                        }
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>
                <TouchableOpacity
                  onPress={() => handleToggleFilter('ungroupProducts')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.ungroupProducts && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.ungroupProducts
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="ungroup"
                          size={22}
                          color={
                            filters.ungroupProducts
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={{
                            color: theme.colors.onSurface,
                            fontWeight: '600',
                          }}
                        >
                          Desagrupar productos
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={{ color: theme.colors.onSurfaceVariant }}
                        >
                          Muestra cada producto individualmente
                        </Text>
                      </View>
                      <Switch
                        value={filters.ungroupProducts}
                        onValueChange={() =>
                          handleToggleFilter('ungroupProducts')
                        }
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>
              </View>
            </Surface>
          </ScrollView>
        </Modal>
      </Portal>
    </>
  );
};
const styles = StyleSheet.create({
  buttonContainer: {
    marginRight: 12,
  },
  filterButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
    width: 20,
    height: 20,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
  },
  badgeText: {
    fontSize: 11,
    fontWeight: 'bold',
  },
  modalContent: {
    margin: screenHeight < 400 ? 10 : 20,
    maxWidth: screenHeight < 400 ? screenWidth - 40 : 380,
    maxHeight: screenHeight < 400 ? screenHeight - 60 : undefined,
    alignSelf: 'center',
    width: Math.min(screenWidth - (screenHeight < 400 ? 40 : 60), 380),
    borderRadius: 20,
    overflow: 'hidden',
  },
  modalSurface: {
    borderRadius: 20,
    overflow: 'hidden',
    maxHeight: screenHeight < 400 ? screenHeight - 60 : undefined,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: screenHeight < 400 ? 12 : 16,
    paddingBottom: screenHeight < 400 ? 8 : 12,
    marginBottom: 4,
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  headerTextContainer: {
    marginLeft: 10,
    flex: 1,
  },
  modalTitle: {
    fontWeight: '700',
  },
  closeButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 8,
  },
  filtersList: {
    padding: screenHeight < 400 ? 8 : 12,
    paddingTop: screenHeight < 400 ? 4 : 8,
    gap: screenHeight < 400 ? 6 : 10,
  },
  filterItem: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'transparent',
    overflow: 'hidden',
  },
  filterItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: screenHeight < 400 ? 8 : 12,
    gap: screenHeight < 400 ? 8 : 10,
  },
  iconContainer: {
    width: screenHeight < 400 ? 32 : 40,
    height: screenHeight < 400 ? 32 : 40,
    borderRadius: screenHeight < 400 ? 16 : 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  filterTextContent: {
    flex: 1,
    gap: 2,
  },
  sectionHeader: {
    marginBottom: screenHeight < 400 ? 8 : 12,
    paddingHorizontal: 4,
  },
  orderTypeContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
    gap: 8,
  },
  orderTypeButton: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: screenHeight < 400 ? 8 : 12,
    paddingHorizontal: screenHeight < 400 ? 4 : 8,
    borderRadius: 12,
    borderWidth: 1.5,
  },
  divider: {
    height: 1,
    marginVertical: screenHeight < 400 ? 8 : 16,
    marginHorizontal: screenHeight < 400 ? -8 : -12,
  },
});

================
File: app/src/modules/kitchen/components/RefreshButton.tsx
================
import React, { useState } from 'react';
import { View, TouchableOpacity, Animated, StyleSheet } from 'react-native';
import { ActivityIndicator } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useKitchenContext } from '../context/KitchenContext';
export const RefreshButton: React.FC = () => {
  const { refetchRef } = useKitchenContext();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const scaleAnim = new Animated.Value(1);
  const handleRefresh = async () => {
    if (refetchRef.current && !isRefreshing) {
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 0.9,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();
      setIsRefreshing(true);
      try {
        await refetchRef.current();
      } finally {
        setTimeout(() => setIsRefreshing(false), 500);
      }
    }
  };
  return (
    <Animated.View
      style={[styles.container, { transform: [{ scale: scaleAnim }] }]}
    >
      <TouchableOpacity
        style={[styles.button, isRefreshing && styles.buttonRefreshing]}
        onPress={handleRefresh}
        disabled={isRefreshing}
        activeOpacity={0.8}
      >
        <View style={styles.iconContainer}>
          {isRefreshing ? (
            <ActivityIndicator size={26} color="white" />
          ) : (
            <Icon name="refresh" size={26} color="white" />
          )}
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};
const styles = StyleSheet.create({
  container: {
    marginHorizontal: 8,
  },
  button: {
    backgroundColor: 'rgba(255, 255, 255, 0.25)',
    borderRadius: 22,
    width: 44,
    height: 44,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1.5,
    borderColor: 'rgba(255, 255, 255, 0.4)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  buttonRefreshing: {
    backgroundColor: 'rgba(255, 255, 255, 0.15)',
    borderColor: 'rgba(255, 255, 255, 0.3)',
  },
  iconContainer: {
    width: 26,
    height: 26,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

================
File: app/src/modules/kitchen/context/KitchenContext.tsx
================
import React, {
  createContext,
  useContext,
  useRef,
  MutableRefObject,
} from 'react';
interface KitchenContextType {
  refetchRef: MutableRefObject<(() => void) | null>;
}
const KitchenContext = createContext<KitchenContextType | undefined>(undefined);
export const KitchenProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const refetchRef = useRef<(() => void) | null>(null);
  return (
    <KitchenContext.Provider value={{ refetchRef }}>
      {children}
    </KitchenContext.Provider>
  );
};
export const useKitchenContext = () => {
  const context = useContext(KitchenContext);
  if (!context) {
    throw new Error('useKitchenContext must be used within a KitchenProvider');
  }
  return context;
};

================
File: app/src/modules/kitchen/navigation/KitchenNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import KitchenOrdersScreen from '../screens/KitchenOrdersScreen';
export type KitchenStackParamList = {
  KitchenOrders: undefined;
};
const Stack = createNativeStackNavigator<KitchenStackParamList>();
export default function KitchenNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen name="KitchenOrders" component={KitchenOrdersScreen} />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/menu/navigation/MenuStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';
import type { MenuStackParamList } from './types.ts';
import CategoriesScreen from '../screens/CategoriesScreen';
import SubcategoriesScreen from '../screens/SubcategoriesScreen';
import ProductsScreen from '../screens/ProductsScreen';
const Stack = createNativeStackNavigator<MenuStackParamList>();
export const MenuStackNavigator: React.FC = () => {
  const theme = useAppTheme();
  return (
    <Stack.Navigator
      screenOptions={{
        ...getStackHeaderOptions(theme),
        headerShown: true,
      }}
    >
      <Stack.Screen
        name="CategoriesScreen"
        component={CategoriesScreen}
        options={{
          title: 'Categorías',
        }}
      />
      <Stack.Screen
        name="SubcategoriesScreen"
        component={SubcategoriesScreen}
        options={({ route }) => ({
          title: route.params?.categoryName
            ? `Subcategorías de ${route.params.categoryName}`
            : 'Subcategorías',
        })}
      />
      <Stack.Screen
        name="Products"
        component={ProductsScreen}
        options={({ route }) => ({
          title: route.params?.subCategoryName
            ? `Productos de ${route.params.subCategoryName}`
            : 'Productos',
        })}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/menu/navigation/types.ts
================
export type MenuStackParamList = {
  CategoriesScreen: undefined;
  SubcategoriesScreen: { categoryId: string; categoryName: string };
  Products: { subcategoryId: string; subCategoryName: string };
};

================
File: app/src/modules/menu/schema/category.schema.ts
================
import { z } from 'zod';
import type { Category } from '../../../app/schemas/domain/category.schema';
import { type Photo } from '../../../app/schemas/domain/photo.schema';
export const createCategoryDtoSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean().optional().default(true),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  sortOrder: z.number().optional().default(0),
});
export const updateCategoryDtoSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').optional(),
  description: z.string().optional().nullable(),
  isActive: z.boolean().optional(),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  sortOrder: z.number().optional(),
});
export const categoryFormSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  sortOrder: z.number().optional().default(0),
  imageUri: z
    .union([
      z.string().url(),
      z.string().startsWith('file://'),
      z.string().startsWith('http://'),
      z.string().startsWith('https://'),
      z.null(),
    ])
    .optional(),
});
export type CreateCategoryDto = z.infer<typeof createCategoryDtoSchema>;
export type UpdateCategoryDto = z.infer<typeof updateCategoryDtoSchema>;
export type CategoryFormData = z.infer<typeof categoryFormSchema>;
export type { Category, Photo };

================
File: app/src/modules/menu/schema/subcategories.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/api.types';
import { type Photo } from '../../../app/schemas/domain/photo.schema';
import type { SubCategory } from '../../../app/schemas/domain/subcategory.schema';
export const createSubCategoryDtoSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().optional().nullable(),
  isActive: z.boolean().optional().default(true),
  categoryId: z.string().min(1, 'Debe seleccionar una categoría válida'),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  imageUri: z
    .union([
      z.string().url(),
      z.string().startsWith('file://'),
      z.string().startsWith('http://'),
      z.string().startsWith('https://'),
      z.null(),
    ])
    .optional(),
  sortOrder: z.number().optional().default(0),
});
export type CreateSubCategoryDto = z.infer<typeof createSubCategoryDtoSchema>;
export const updateSubCategoryDtoSchema = createSubCategoryDtoSchema.partial();
export type UpdateSubCategoryDto = z.infer<typeof updateSubCategoryDtoSchema>;
export const findAllSubcategoriesDtoSchema = baseListQuerySchema.extend({
  categoryId: z.string().optional(),
  isActive: z.boolean().optional(),
});
export type SubCategoryFormInputs = CreateSubCategoryDto;
export type UpdateSubCategoryFormInputs = UpdateSubCategoryDto;
export type { Photo, SubCategory };

================
File: app/src/modules/menu/types/category.types.ts
================
export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}
export type ActiveFilter = 'all' | 'active' | 'inactive';

================
File: app/src/modules/menu/types/subcategories.types.ts
================
import type { BaseListQueryDto } from '../../../app/types/api.types';
export type FindAllSubcategoriesDto = BaseListQueryDto & {
  categoryId?: string;
  isActive?: boolean;
};

================
File: app/src/modules/modifiers/navigation/ModifiersStackNavigator.tsx
================
import React from 'react';
import {
  createNativeStackNavigator,
  NativeStackNavigationOptions,
} from '@react-navigation/native-stack';
import { ModifiersStackParamList } from '@/app/navigation/types';
import ModifierGroupsScreen from '../screens/ModifierGroupsScreen';
import ModifiersScreen from '../screens/ModifiersScreen';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';
const Stack = createNativeStackNavigator<ModifiersStackParamList>();
const ModifiersStackNavigator = () => {
  const theme = useAppTheme();
  return (
    <Stack.Navigator
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="ModifierGroupsScreen"
        component={ModifierGroupsScreen}
        options={(): NativeStackNavigationOptions => ({
          title: 'Grupos de Modificadores',
        })}
      />
      <Stack.Screen
        name="ModifiersScreen"
        component={ModifiersScreen}
        options={{ title: 'Modificadores' }}
      />
    </Stack.Navigator>
  );
};
export default ModifiersStackNavigator;

================
File: app/src/modules/modifiers/schema/modifier.schema.ts
================
import { z } from 'zod';
import { modifierSchema as domainModifierSchema } from '../../../app/schemas/domain/modifier.schema';
import type { Modifier } from '../../../app/schemas/domain/modifier.schema';
export const createModifierSchema = z.object({
  modifierGroupId: z.string().min(1, 'El ID del grupo no es válido'),
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.coerce.number().nullable().optional(),
  sortOrder: z.number().int().default(0),
  isDefault: z.boolean().default(false),
  isActive: z.boolean().default(true),
});
export type CreateModifierInput = z.infer<typeof createModifierSchema>;
export const updateModifierSchema = z
  .object({
    name: z.string().min(1, 'El nombre es requerido').max(100),
    description: z.string().max(255).nullable().optional(),
    price: z.coerce.number().nullable().optional(),
    sortOrder: z.number().int().default(0),
    isDefault: z.boolean().default(false),
    isActive: z.boolean().default(true),
  })
  .partial();
export type UpdateModifierInput = z.infer<typeof updateModifierSchema>;
export const modifierFormValidationSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce.number().nullable().optional(),
  ),
  sortOrder: z.preprocess(
    (val) => (val === '' || val === null ? 0 : val),
    z.coerce.number().int().optional().default(0),
  ),
  isDefault: z.boolean().optional().default(false),
  isActive: z.boolean().optional().default(true),
});
export const modifierApiSchema = domainModifierSchema.extend({
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
  deletedAt: z.string().datetime().nullable().optional(),
});
export type { Modifier };

================
File: app/src/modules/modifiers/schema/modifierGroup.schema.ts
================
import { z } from 'zod';
import { modifierGroupSchema as domainModifierGroupSchema } from '../../../app/schemas/domain/modifier-group.schema';
import type { ModifierGroup } from '../../../app/schemas/domain/modifier-group.schema';
const modifierGroupBaseSchemaForForm = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  minSelections: z.number().int().min(0).optional(),
  maxSelections: z.number().int().min(1).optional(),
  isRequired: z.boolean().optional(),
  allowMultipleSelections: z.boolean().optional(),
  isActive: z.boolean().optional(),
  sortOrder: z.number().optional().default(0),
});
export const modifierGroupFormValidationSchema =
  modifierGroupBaseSchemaForForm.superRefine((data, ctx) => {
    if (data.allowMultipleSelections) {
      if (data.maxSelections === undefined || data.maxSelections === null) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['maxSelections'],
          message:
            'Máx. selecciones es requerido si se permiten múltiples selecciones.',
        });
      } else {
        if (data.maxSelections <= 1) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['maxSelections'],
            message:
              'Máx. selecciones debe ser mayor que 1 si se permiten múltiples selecciones.',
          });
        }
        const min = data.minSelections ?? 0;
        if (data.maxSelections > 1 && min > data.maxSelections) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['minSelections'],
            message:
              'Mín. selecciones no puede ser mayor que Máx. selecciones.',
          });
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['maxSelections'],
            message:
              'Máx. selecciones no puede ser menor que Mín. selecciones.',
          });
        }
      }
    } else {
    }
  });
export type ModifierGroupFormInputs = z.infer<
  typeof modifierGroupFormValidationSchema
>;
export const createModifierGroupSchema =
  modifierGroupBaseSchemaForForm.transform((data) => ({
    ...data,
    minSelections: data.minSelections ?? 0,
    isRequired: data.isRequired ?? false,
    allowMultipleSelections: data.allowMultipleSelections ?? false,
    isActive: data.isActive ?? true,
    sortOrder: data.sortOrder ?? 0,
    maxSelections: data.allowMultipleSelections ? (data.maxSelections ?? 1) : 1,
  }));
export type CreateModifierGroupInput = z.infer<
  typeof createModifierGroupSchema
>;
export const updateModifierGroupSchema =
  modifierGroupBaseSchemaForForm.partial();
export type UpdateModifierGroupInput = z.infer<
  typeof updateModifierGroupSchema
>;
export const modifierGroupApiSchema = domainModifierGroupSchema.extend({
  id: z.string(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  deletedAt: z.string().datetime().nullable().optional(),
  productModifiers: z.array(z.any()).optional(),
  products: z.array(z.any()).optional(),
});
export type { ModifierGroup };
export const modifierGroupSchema = modifierGroupFormValidationSchema;
export const modifierGroupBaseSchema = modifierGroupBaseSchemaForForm;

================
File: app/src/modules/modifiers/types/modifier.types.ts
================
export type ModifierFormInputs = {
  name: string;
  description?: string | null;
  price?: number | null;
  sortOrder?: number;
  isDefault?: boolean;
  isActive?: boolean;
};

================
File: app/src/modules/orderFinalization/navigation/OrderFinalizationStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { OrderFinalizationScreen } from '../screens/OrderFinalizationScreen';
import { OrderFinalizationStackParamList } from './types';
import { defaultScreenOptions } from '@/app/navigation/options';
const Stack = createNativeStackNavigator<OrderFinalizationStackParamList>();
export const OrderFinalizationStackNavigator = () => {
  return (
    <Stack.Navigator screenOptions={defaultScreenOptions}>
      <Stack.Screen
        name="OrderFinalizationScreen"
        component={OrderFinalizationScreen}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/orderFinalization/navigation/types.ts
================
export type OrderFinalizationStackParamList = {
  OrderFinalizationScreen: undefined;
};

================
File: app/src/modules/orders/components/MenuItemCard.tsx
================
import React, { useMemo } from 'react';
import { StyleSheet, View } from 'react-native';
import { Card, Title, Text, IconButton } from 'react-native-paper';
import { AutoImage } from '@/app/components/common/AutoImage';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import type { Product, Category, SubCategory } from '../types/orders.types';
interface MenuItemCardProps {
  item: Category | SubCategory | Product;
  onPress: () => void;
  onLongPress?: () => void;
  onInfoPress?: () => void;
  navigationLevel: 'categories' | 'subcategories' | 'products';
  disabled?: boolean;
  showPrice?: boolean;
}
const MenuItemCard = React.memo<MenuItemCardProps>(
  ({
    item,
    onPress,
    onLongPress,
    onInfoPress,
    navigationLevel,
    disabled = false,
    showPrice = true,
  }) => {
    const theme = useAppTheme();
    const { colors, fonts } = theme;
    const responsive = useResponsive();
    const blurhash =
      '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';
    const styles = useMemo(
      () =>
        StyleSheet.create({
          cardItem: {
            flex: 1,
            minWidth: 120,
            overflow: 'hidden',
            borderRadius: theme.roundness,
            elevation: 2,
          },
          cardItemInactive: {
            opacity: 0.5,
          },
          itemImage: {
            width: '100%',
            height: responsive.getResponsiveDimension(120, 160),
          },
          imageInactive: {
            opacity: 0.6,
          },
          cardContent: {
            paddingHorizontal: responsive.spacing.s,
            paddingVertical: responsive.spacing.xs,
          },
          cardTitle: {
            fontSize: responsive.fontSize.m,
            fontWeight: '600',
            lineHeight: responsive.fontSize.m * 1.2,
            marginBottom: responsive.spacing.xs,
          },
          cardHeader: {
            flexDirection: 'row',
            justifyContent: 'space-between',
            alignItems: 'flex-start',
          },
          infoButton: {
            margin: -4,
            marginTop: -6,
            marginRight: -6,
          },
          priceText: {
            color: theme.colors.primary,
            fontWeight: '600',
            fontSize: responsive.fontSize.s,
            marginTop: 2,
          },
          inactiveBadge: {
            position: 'absolute',
            top: 8,
            right: 8,
            backgroundColor: colors.errorContainer,
            paddingHorizontal: 8,
            paddingVertical: 4,
            borderRadius: 4,
          },
          inactiveBadgeText: {
            fontSize: 12,
            color: colors.onErrorContainer,
            fontWeight: '600',
          },
          warningMessage: {
            backgroundColor: colors.warningContainer || colors.errorContainer,
            paddingHorizontal: responsive.spacing.s,
            paddingVertical: responsive.spacing.xs,
            marginTop: responsive.spacing.xs,
          },
          warningMessageText: {
            fontSize: responsive.fontSize.xs,
            color: colors.onWarningContainer || colors.onErrorContainer,
            textAlign: 'center',
            lineHeight: responsive.fontSize.xs * 1.3,
          },
        }),
      [colors, fonts, theme, responsive],
    );
    const isActive = item.isActive !== false;
    const isProductWithoutScreen =
      navigationLevel === 'products' &&
      'preparationScreenId' in item &&
      !item.preparationScreenId;
    const isDisabled = disabled || !isActive || isProductWithoutScreen;
    const imageSource = item.photo ? item.photo.path : null;
    const shouldShowPrice = () => {
      if (!showPrice) return false;
      if (
        navigationLevel === 'products' &&
        'price' in item &&
        'hasVariants' in item
      ) {
        const productItem = item as Product;
        return (
          !productItem.hasVariants &&
          productItem.price !== null &&
          productItem.price !== undefined
        );
      }
      return false;
    };
    const shouldShowInfoButton = () => {
      return (
        navigationLevel === 'products' &&
        'price' in item &&
        'description' in item &&
        (item as Product).description &&
        (item as Product).description.trim() !== '' &&
        onInfoPress
      );
    };
    // Obtener el texto del badge
    const getBadgeText = () => {
      if (!isActive) return 'INACTIVO';
      if (isProductWithoutScreen) return 'NO DISPONIBLE';
      return null;
    };
    const badgeText = getBadgeText();
    return (
      <Card
        style={[styles.cardItem, isDisabled && styles.cardItemInactive]}
        onPress={isDisabled ? undefined : onPress}
        onLongPress={isDisabled ? undefined : onLongPress}
        disabled={isDisabled}
      >
        <AutoImage
          source={imageSource}
          style={[styles.itemImage, isDisabled && styles.imageInactive]}
          contentFit="cover"
          placeholder={blurhash}
          transition={300}
          placeholderIcon="image-outline"
        />
        {badgeText && (
          <View style={styles.inactiveBadge}>
            <Text style={styles.inactiveBadgeText}>{badgeText}</Text>
          </View>
        )}
        <View style={styles.cardContent}>
          {shouldShowInfoButton() ? (
            <View style={styles.cardHeader}>
              <Title style={[styles.cardTitle, { flex: 1 }]}>{item.name}</Title>
              <IconButton
                icon="information-outline"
                size={20}
                onPress={onInfoPress}
                style={styles.infoButton}
              />
            </View>
          ) : (
            <Title style={styles.cardTitle}>{item.name}</Title>
          )}
          {shouldShowPrice() && (
            <Text style={styles.priceText}>
              ${Number((item as Product).price).toFixed(2)}
            </Text>
          )}
          {isProductWithoutScreen && (
            <View style={styles.warningMessage}>
              <Text style={styles.warningMessageText}>
                Sin pantalla de preparación
              </Text>
            </View>
          )}
        </View>
      </Card>
    );
  },
);
MenuItemCard.displayName = 'MenuItemCard';
export default MenuItemCard;

================
File: app/src/modules/orders/components/OrderHeader.tsx
================
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Text, IconButton } from 'react-native-paper';
import CartButton from './CartButton';
import { useAppTheme } from '@/app/styles/theme';
interface OrderHeaderProps {
  title: string;
  itemCount: number;
  onBackPress?: () => void;
  onCartPress: () => void;
  isCartVisible: boolean;
}
const OrderHeader = ({
  title,
  itemCount,
  onBackPress,
  onCartPress,
  isCartVisible,
}: OrderHeaderProps) => {
  const theme = useAppTheme();
  const styles = StyleSheet.create({
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 4,
      paddingVertical: 8,
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      shadowOpacity: 0,
    },
    headerTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
      flex: 1,
    },
    headerSpacer: {
      width: 48,
    },
  });
  return (
    <View style={styles.header}>
      {onBackPress ? (
        <IconButton
          icon="arrow-left"
          size={24}
          onPress={onBackPress}
          iconColor={theme.colors.onSurface}
        />
      ) : (
        <View style={styles.headerSpacer} />
      )}
      <Text style={styles.headerTitle}>{title}</Text>
      {!isCartVisible ? (
        <CartButton itemCount={itemCount} onPress={onCartPress} />
      ) : (
        <View style={styles.headerSpacer} />
      )}
    </View>
  );
};
export default OrderHeader;

================
File: app/src/modules/orders/components/SimpleProductDescriptionModal.tsx
================
import React from 'react';
import { StyleSheet, ScrollView } from 'react-native';
import { Portal, Modal, Text, Title } from 'react-native-paper';
import type { Product } from '@/app/schemas/domain/product.schema';
import { useAppTheme } from '@/app/styles/theme';
interface SimpleProductDescriptionModalProps {
  visible: boolean;
  product: Product | null;
  onDismiss: () => void;
}
const SimpleProductDescriptionModal: React.FC<
  SimpleProductDescriptionModalProps
> = ({ visible, product, onDismiss }) => {
  const theme = useAppTheme();
  const styles = StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: 20,
      padding: 20,
      borderRadius: 8,
      maxHeight: '60%',
    },
    title: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: 16,
      color: theme.colors.onBackground,
    },
    description: {
      fontSize: 16,
      lineHeight: 24,
      color: theme.colors.onSurfaceVariant,
    },
  });
  if (!product || !product.description) return null;
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modal}
      >
        <ScrollView>
          <Title style={styles.title}>{product.name}</Title>
          <Text style={styles.description}>{product.description}</Text>
        </ScrollView>
      </Modal>
    </Portal>
  );
};
export default SimpleProductDescriptionModal;

================
File: app/src/modules/orders/hooks/useAdjustmentQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { adjustmentService } from '../services/adjustmentService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { OrderAdjustmentDto } from '../types/update-order.types';
export const useCreateBulkAdjustmentsMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: (adjustments: OrderAdjustmentDto[]) =>
      adjustmentService.createBulkAdjustments(adjustments),
    onSuccess: (data, variables) => {
      if (variables.length > 0 && variables[0].orderId) {
        queryClient.invalidateQueries({
          queryKey: ['orders', variables[0].orderId],
        });
        queryClient.invalidateQueries({
          queryKey: ['adjustments', 'order', variables[0].orderId],
        });
      }
      showSnackbar({
        message: 'Ajustes aplicados correctamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al aplicar ajustes',
        type: 'error',
      });
    },
  });
};
export const useOrderAdjustmentsQuery = (orderId: string, enabled = true) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useQuery({
    queryKey: ['adjustments', 'order', orderId],
    queryFn: () => adjustmentService.getOrderAdjustments(orderId),
    enabled: enabled && !!orderId,
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al cargar ajustes',
        type: 'error',
      });
    },
  });
};
export const useDeleteAdjustmentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: (adjustmentId: string) =>
      adjustmentService.deleteAdjustment(adjustmentId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adjustments'] });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Ajuste eliminado correctamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al eliminar ajuste',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/orders/hooks/usePaymentQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { paymentService } from '../services/paymentService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type {
  CreatePaymentDto,
  UpdatePaymentDto,
  PaymentMethod,
  PaymentStatus,
} from '../types/payment.types';
export const paymentKeys = {
  all: ['payments'] as const,
  lists: () => [...paymentKeys.all, 'list'] as const,
  list: (filters?: {
    orderId?: string;
    paymentMethod?: PaymentMethod;
    paymentStatus?: PaymentStatus;
  }) => [...paymentKeys.lists(), filters] as const,
  details: () => [...paymentKeys.all, 'detail'] as const,
  detail: (id: string) => [...paymentKeys.details(), id] as const,
  byOrder: (orderId: string) => [...paymentKeys.all, 'order', orderId] as const,
};
export const useGetPaymentsQuery = (filters?: {
  orderId?: string;
  paymentMethod?: PaymentMethod;
  paymentStatus?: PaymentStatus;
}) => {
  return useQuery({
    queryKey: paymentKeys.list(filters),
    queryFn: () => paymentService.getPayments(filters),
  });
};
export const useGetPaymentByIdQuery = (id: string) => {
  return useQuery({
    queryKey: paymentKeys.detail(id),
    queryFn: () => paymentService.getPaymentById(id),
    enabled: !!id,
  });
};
export const useGetPaymentsByOrderIdQuery = (
  orderId: string,
  options?: { enabled?: boolean },
) => {
  return useQuery({
    queryKey: paymentKeys.byOrder(orderId),
    queryFn: () => paymentService.getPaymentsByOrderId(orderId),
    enabled: options?.enabled !== undefined ? options.enabled : !!orderId,
    initialData: [],
  });
};
export const useCreatePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: (dto: CreatePaymentDto) => paymentService.createPayment(dto),
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: paymentKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: paymentKeys.byOrder(data.orderId),
      });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Pago registrado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al registrar el pago',
        type: 'error',
      });
    },
  });
};
export const useUpdatePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: ({ id, dto }: { id: string; dto: UpdatePaymentDto }) =>
      paymentService.updatePayment(id, dto),
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: paymentKeys.lists() });
      queryClient.invalidateQueries({ queryKey: paymentKeys.detail(data.id) });
      queryClient.invalidateQueries({
        queryKey: paymentKeys.byOrder(data.orderId),
      });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Pago actualizado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al actualizar el pago',
        type: 'error',
      });
    },
  });
};
export const useDeletePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: (id: string) => paymentService.deletePayment(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: paymentKeys.all });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Pago eliminado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al eliminar el pago',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/orders/types/adjustments.types.ts
================
export interface OrderAdjustment {
  id?: string;
  name: string;
  isPercentage: boolean;
  value?: number;
  amount?: number;
  isNew?: boolean;
  isDeleted?: boolean;
}
export interface AdjustmentFormData {
  name: string;
  isPercentage: boolean;
  value?: number;
  amount?: number;
}

================
File: app/src/modules/orders/types/update-order.types.ts
================
import type { OrderType } from './orders.types';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';
export interface ProductModifierDto {
  modifierId: string;
}
export interface SelectedPizzaCustomizationDto {
  pizzaCustomizationId: string;
  half: 'FULL' | 'HALF_1' | 'HALF_2';
  action: 'ADD' | 'REMOVE';
}
export interface OrderItemDtoForBackend {
  id?: string;
  productId: string;
  productVariantId?: string | null;
  quantity: number;
  basePrice: number;
  finalPrice: number;
  preparationNotes?: string | null;
  productModifiers?: ProductModifierDto[];
  selectedPizzaCustomizations?: SelectedPizzaCustomizationDto[];
}
export interface OrderAdjustmentDto {
  orderId?: string;
  name: string;
  isPercentage: boolean;
  value?: number;
  amount?: number;
}
export interface UpdateOrderPayload {
  orderType?: OrderType;
  items?: OrderItemDtoForBackend[];
  tableId?: string | null;
  scheduledAt?: Date | null;
  deliveryInfo?: DeliveryInfo;
  notes?: string | null;
  status?: Order['orderStatus'];
  total?: number;
  subtotal?: number;
  adjustments?: OrderAdjustmentDto[];
}

================
File: app/src/modules/pizzaCustomizations/components/index.ts
================
export { PizzaProductsTab } from './PizzaProductsTab';
export { PizzaCustomizationsTab } from './PizzaCustomizationsTab';
export { PizzaCustomizationFormModal } from './PizzaCustomizationFormModal';

================
File: app/src/modules/pizzaCustomizations/components/PizzaProductsTab.tsx
================
import React, { useState, useMemo } from 'react';
import { View, StyleSheet, FlatList, RefreshControl } from 'react-native';
import {
  Surface,
  Text,
  IconButton,
  Chip,
  ActivityIndicator,
  Menu,
  Searchbar,
  Badge,
  Avatar,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import { productsService } from '@/modules/menu/services/productsService';
import EmptyState from '@/app/components/common/EmptyState';
import { Product } from '@/modules/menu/schema/products.schema';
import { getImageUrl } from '@/app/lib/imageUtils';
import { PizzaConfigurationModal } from './PizzaConfigurationModal';
import { AssociatePizzaToppingsModal } from './AssociatePizzaToppingsModal';
export function PizzaProductsTab() {
  const theme = useAppTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const [filter, setFilter] = useState<'all' | 'configured' | 'not_configured'>(
    'all',
  );
  const [configModalVisible, setConfigModalVisible] = useState(false);
  const [ingredientsModalVisible, setIngredientsModalVisible] = useState(false);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const { data, isLoading, refetch, isRefetching } = useQuery({
    queryKey: ['pizza-products', filter],
    queryFn: async () => {
      const pizzaProducts = await productsService.findAllPizzas();
      return pizzaProducts;
    },
  });
  const filteredProducts = useMemo(() => {
    if (!data) return [];
    let filtered = data.filter((product) =>
      product.name.toLowerCase().includes(searchQuery.toLowerCase()),
    );
    if (filter === 'configured') {
      filtered = filtered.filter((product) => product.pizzaConfiguration);
    } else if (filter === 'not_configured') {
      filtered = filtered.filter((product) => !product.pizzaConfiguration);
    }
    return filtered;
  }, [data, searchQuery, filter]);
  const renderProductItem = ({ item }: { item: Product }) => {
    const isConfigured = !!item.pizzaConfiguration;
    const customizations = item.pizzaCustomizations || [];
    const flavorsCount = customizations.filter(
      (c: any) => c.type === 'FLAVOR',
    ).length;
    const ingredientsCount = customizations.filter(
      (c: any) => c.type === 'INGREDIENT',
    ).length;
    const imageUrl = item.photo?.path ? getImageUrl(item.photo.path) : null;
    const variantsCount = item.variants?.length || 0;
    return (
      <Surface style={styles.productCard} elevation={2}>
        <View style={styles.productHeader}>
          <View style={styles.productTitleRow}>
            {imageUrl ? (
              <Avatar.Image
                size={48}
                source={{ uri: imageUrl }}
                style={styles.productImage}
              />
            ) : (
              <Avatar.Icon
                size={48}
                icon="pizza"
                style={[
                  styles.productImage,
                  { backgroundColor: theme.colors.primaryContainer },
                ]}
              />
            )}
            <View style={styles.productInfo}>
              <Text
                variant="titleMedium"
                style={styles.productName}
                numberOfLines={1}
              >
                {item.name}
              </Text>
              <Text variant="bodySmall" style={styles.variantText}>
                {variantsCount > 0
                  ? `${variantsCount} variantes`
                  : 'Sin variantes'}
              </Text>
            </View>
            <View style={styles.productActions}>
              <IconButton
                icon="cog"
                mode="contained-tonal"
                size={28}
                onPress={() => {
                  setSelectedProduct(item);
                  setConfigModalVisible(true);
                }}
                style={styles.actionButton}
              />
              <IconButton
                icon="cheese"
                mode="contained-tonal"
                size={28}
                onPress={() => {
                  setSelectedProduct(item);
                  setIngredientsModalVisible(true);
                }}
                style={styles.actionButton}
              />
            </View>
          </View>
        </View>
        <View style={styles.productStatus}>
          <Chip
            mode="flat"
            compact
            icon={isConfigured ? 'check-circle' : 'alert-circle'}
            style={[
              styles.statusChip,
              {
                backgroundColor: isConfigured
                  ? theme.colors.primaryContainer
                  : theme.colors.errorContainer,
              },
            ]}
            textStyle={styles.chipText}
          >
            {isConfigured ? 'Configurada' : 'Sin configurar'}
          </Chip>
          <View style={styles.countsContainer}>
            <Text variant="bodySmall" style={styles.countText}>
              {flavorsCount} sabores
            </Text>
            <Text variant="bodySmall" style={styles.countDivider}>
              •
            </Text>
            <Text variant="bodySmall" style={styles.countText}>
              {ingredientsCount} ingredientes
            </Text>
          </View>
        </View>
      </Surface>
    );
  };
  const hasActiveFilter = filter !== 'all';
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      padding: theme.spacing.m,
      backgroundColor: theme.colors.background,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: theme.spacing.xs,
    },
    content: {
      flex: 1,
    },
    listContent: {
      paddingVertical: theme.spacing.m,
    },
    productCard: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      overflow: 'hidden',
      elevation: 1,
    },
    productHeader: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    productTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    productImage: {
      marginRight: theme.spacing.m,
    },
    productInfo: {
      flex: 1,
    },
    productName: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: 2,
    },
    variantText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    productStatus: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: theme.spacing.m,
      paddingBottom: theme.spacing.m,
    },
    statusChip: {
      height: 28,
    },
    chipText: {
      fontSize: 12,
      marginHorizontal: theme.spacing.xs,
      marginVertical: 2,
    },
    ingredientCount: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    countsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    countText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    countDivider: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginHorizontal: 2,
    },
    productActions: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      marginLeft: theme.spacing.s,
    },
    actionButton: {
      margin: 0,
      width: 48,
      height: 48,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
  });
  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }
  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder="Buscar pizzas..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={hasActiveFilter ? 'filter-check' : 'filter-variant'}
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                  iconColor={
                    hasActiveFilter
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setFilter('all');
                  setFilterMenuVisible(false);
                }}
                title="Todas"
                leadingIcon="filter-variant"
                trailingIcon={filter === 'all' ? 'check' : undefined}
                titleStyle={
                  filter === 'all'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setFilter('configured');
                  setFilterMenuVisible(false);
                }}
                title="Configuradas"
                leadingIcon="check-circle"
                trailingIcon={filter === 'configured' ? 'check' : undefined}
                titleStyle={
                  filter === 'configured'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setFilter('not_configured');
                  setFilterMenuVisible(false);
                }}
                title="Sin Configurar"
                leadingIcon="alert-circle"
                trailingIcon={filter === 'not_configured' ? 'check' : undefined}
                titleStyle={
                  filter === 'not_configured'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
            </Menu>
            {hasActiveFilter && <Badge style={styles.filterBadge} size={8} />}
          </View>
        </View>
      </View>
      <FlatList
        data={filteredProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={refetch}
            colors={[theme.colors.primary]}
          />
        }
        ListEmptyComponent={
          <EmptyState
            title="No hay pizzas"
            message={
              filter === 'not_configured'
                ? 'No hay pizzas sin configurar'
                : filter === 'configured'
                  ? 'No hay pizzas configuradas'
                  : 'No hay productos tipo pizza creados'
            }
            icon="pizza"
          />
        }
      />
      <PizzaConfigurationModal
        visible={configModalVisible}
        onDismiss={() => {
          setConfigModalVisible(false);
          setSelectedProduct(null);
        }}
        product={selectedProduct}
      />
      <AssociatePizzaToppingsModal
        visible={ingredientsModalVisible}
        onDismiss={() => {
          setIngredientsModalVisible(false);
          setSelectedProduct(null);
        }}
        product={selectedProduct}
      />
    </View>
  );
}

================
File: app/src/modules/pizzaCustomizations/hooks/usePizzaCustomizationsQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { pizzaCustomizationsService } from '../services/pizzaCustomizationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { FindAllPizzaCustomizationsQuery } from '../schema/pizzaCustomization.schema';
const PIZZA_CUSTOMIZATIONS_QUERY_KEYS = {
  all: ['pizzaCustomizations'] as const,
  lists: () => [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.all, 'list'] as const,
  list: (params?: FindAllPizzaCustomizationsQuery) =>
    [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(), params] as const,
  details: () => [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.all, 'detail'] as const,
  detail: (id: string) =>
    [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.details(), id] as const,
};
export function usePizzaCustomizationsList(
  params?: FindAllPizzaCustomizationsQuery,
) {
  return useQuery({
    queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.list(params),
    queryFn: () => pizzaCustomizationsService.findAll(params),
  });
}
export function usePizzaCustomization(id: string) {
  return useQuery({
    queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.detail(id),
    queryFn: () => pizzaCustomizationsService.findOne(id),
    enabled: !!id,
  });
}
export function useCreatePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: pizzaCustomizationsService.create,
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      showSnackbar({
        message: 'Personalización creada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al crear personalización',
        type: 'error',
      });
    },
  });
}
export function useUpdatePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: ({
      id,
      data,
    }: {
      id: string;
      data: Parameters<typeof pizzaCustomizationsService.update>[1];
    }) => pizzaCustomizationsService.update(id, data),
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.detail(variables.id),
      });
      showSnackbar({
        message: 'Personalización actualizada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al actualizar personalización',
        type: 'error',
      });
    },
  });
}
export function useDeletePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: pizzaCustomizationsService.remove,
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      showSnackbar({
        message: 'Personalización eliminada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al eliminar personalización',
        type: 'error',
      });
    },
  });
}

================
File: app/src/modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PizzaManagementScreen } from '../screens/PizzaManagementScreen';
import type { PizzaCustomizationsStackParamList } from './types';
const Stack = createNativeStackNavigator<PizzaCustomizationsStackParamList>();
export function PizzaCustomizationsStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="PizzaCustomizationsList"
        component={PizzaManagementScreen}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/pizzaCustomizations/navigation/types.ts
================
export type PizzaCustomizationsStackParamList = {
  PizzaCustomizationsList: undefined;
};

================
File: app/src/modules/pizzaCustomizations/schema/pizzaConfiguration.schema.ts
================
import { z } from 'zod';
export const pizzaConfigurationFormSchema = z.object({
  productId: z.string().min(1, 'El producto es requerido'),
  includedToppings: z
    .number()
    .min(0, 'Los toppings incluidos deben ser mayor o igual a 0')
    .default(4),
  extraToppingCost: z
    .number()
    .min(0, 'El costo extra debe ser mayor o igual a 0')
    .default(20),
});
export type PizzaConfigurationFormInputs = z.infer<
  typeof pizzaConfigurationFormSchema
>;
export const updatePizzaConfigurationSchema = z.object({
  includedToppings: z.number().min(0).optional(),
  extraToppingCost: z.number().min(0).optional(),
});
export type UpdatePizzaConfigurationInputs = z.infer<
  typeof updatePizzaConfigurationSchema
>;

================
File: app/src/modules/pizzaCustomizations/schema/pizzaCustomization.schema.ts
================
import { z } from 'zod';
import { CustomizationType } from '../types/pizzaCustomization.types';
export const pizzaCustomizationFormSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  type: z.nativeEnum(CustomizationType),
  ingredients: z.string().optional().nullable(),
  toppingValue: z
    .number()
    .min(0, 'El valor debe ser mayor o igual a 0')
    .default(1),
  isActive: z.boolean().default(true),
  sortOrder: z.number().default(0),
});
export type PizzaCustomizationFormInputs = z.infer<
  typeof pizzaCustomizationFormSchema
>;
export const findAllPizzaCustomizationsQuerySchema = z.object({
  page: z.number().optional(),
  limit: z.number().optional(),
  search: z.string().optional(),
  type: z.nativeEnum(CustomizationType).optional(),
  isActive: z.boolean().optional(),
});
export type FindAllPizzaCustomizationsQuery = z.infer<
  typeof findAllPizzaCustomizationsQuerySchema
>;

================
File: app/src/modules/pizzaCustomizations/types/pizzaConfiguration.types.ts
================
export interface PizzaConfiguration {
  id: string;
  productId: string;
  includedToppings: number;
  extraToppingCost: number;
  createdAt: string;
  updatedAt: string;
}
export interface CreatePizzaConfigurationInput {
  productId: string;
  includedToppings: number;
  extraToppingCost: number;
}
export interface UpdatePizzaConfigurationInput {
  includedToppings?: number;
  extraToppingCost?: number;
}

================
File: app/src/modules/pizzaCustomizations/types/pizzaCustomization.types.ts
================
export enum CustomizationType {
  FLAVOR = 'FLAVOR',
  INGREDIENT = 'INGREDIENT',
}
export enum PizzaHalf {
  FULL = 'FULL',
  HALF_1 = 'HALF_1',
  HALF_2 = 'HALF_2',
}
export enum CustomizationAction {
  ADD = 'ADD',
  REMOVE = 'REMOVE',
}
export interface PizzaCustomization {
  id: string;
  name: string;
  type: CustomizationType;
  ingredients?: string | null;
  toppingValue: number;
  isActive: boolean;
  sortOrder: number;
  productIds?: string[];
  products?: { id: string; name: string }[];
  createdAt: string;
  updatedAt: string;
}
export interface SelectedPizzaCustomization {
  id: string;
  orderItemId: string;
  pizzaCustomizationId: string;
  pizzaCustomization?: PizzaCustomization;
  half: PizzaHalf;
  action: CustomizationAction;
  createdAt: string;
  updatedAt: string;
}

================
File: app/src/modules/preparationScreens/navigation/PreparationScreensStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PreparationScreensStackParamList } from './types';
import PreparationScreensScreen from '../screens/PreparationScreensScreen';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';
const Stack = createNativeStackNavigator<PreparationScreensStackParamList>();
const PreparationScreensStackNavigator = () => {
  const theme = useAppTheme();
  return (
    <Stack.Navigator
      initialRouteName="PreparationScreensList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="PreparationScreensList"
        component={PreparationScreensScreen}
        options={{
          title: 'Pantallas de Preparación',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};
export default PreparationScreensStackNavigator;

================
File: app/src/modules/preparationScreens/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '../../../app/navigation/types';
export type PreparationScreensStackParamList = {
  PreparationScreensList: undefined;
};
export type PreparationScreensListScreenProps = NativeStackScreenProps<
  PreparationScreensStackParamList,
  'PreparationScreensList'
>;
export type PreparationScreensDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'PreparationScreensStack'
>;

================
File: app/src/modules/printers/navigation/PrintersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PrintersStackParamList } from './types';
import PrintersScreen from '../screens/PrintersScreen';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';
const Stack = createNativeStackNavigator<PrintersStackParamList>();
const PrintersStackNavigator = () => {
  const theme = useAppTheme();
  return (
    <Stack.Navigator
      initialRouteName="PrintersList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="PrintersList"
        component={PrintersScreen}
        options={{
          title: 'Impresoras',
        }}
      />
    </Stack.Navigator>
  );
};
export default PrintersStackNavigator;

================
File: app/src/modules/printers/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '@/app/navigation/types';
export type PrintersStackParamList = {
  PrintersList: undefined;
};
export type PrintersListScreenProps = NativeStackScreenProps<
  PrintersStackParamList,
  'PrintersList'
>;
export type PrintersDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'PrintersStack'
>;

================
File: app/src/modules/printers/types/printer.types.ts
================
import { z } from 'zod';
import {
  thermalPrinterSchema,
  createThermalPrinterDtoSchema,
  updateThermalPrinterDtoSchema,
  findAllThermalPrintersFilterSchema,
  discoveredPrinterSchema,
  PrinterConnectionTypeSchema,
} from '../schema/printer.schema';
import type { BaseListQueryDto } from '../../../app/types/api.types';
export type ThermalPrinter = z.infer<typeof thermalPrinterSchema>;
export type CreateThermalPrinterDto = z.infer<
  typeof createThermalPrinterDtoSchema
>;
export type UpdateThermalPrinterDto = z.infer<
  typeof updateThermalPrinterDtoSchema
>;
export type FindAllThermalPrintersDto = z.infer<
  typeof findAllThermalPrintersFilterSchema
> &
  BaseListQueryDto;
export type DiscoveredPrinter = z.infer<typeof discoveredPrinterSchema>;
export type PrinterConnectionType = z.infer<typeof PrinterConnectionTypeSchema>;

================
File: app/src/modules/receipts/navigation/ReceiptsStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ReceiptsScreen } from '../screens/ReceiptsScreen';
import { getStackHeaderOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';
export type ReceiptsStackParamList = {
  ReceiptsList: undefined;
};
const Stack = createNativeStackNavigator<ReceiptsStackParamList>();
export const ReceiptsStackNavigator = () => {
  const theme = useAppTheme();
  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="ReceiptsList"
        component={ReceiptsScreen}
        options={{
          title: 'Recibos',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/receipts/navigation/types.ts
================
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RouteProp } from '@react-navigation/native';
export type ReceiptsStackParamList = {
  ReceiptsList: undefined;
};
export type ReceiptsListScreenNavigationProp = NativeStackNavigationProp<
  ReceiptsStackParamList,
  'ReceiptsList'
>;
export type ReceiptsListScreenRouteProp = RouteProp<
  ReceiptsStackParamList,
  'ReceiptsList'
>;

================
File: app/src/modules/restaurantConfig/hooks/useRestaurantConfigQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { restaurantConfigService } from '../services/restaurantConfigService';
import { UpdateRestaurantConfigDto } from '../types/restaurantConfig.types';
import { useSnackbarStore } from '@/app/store/snackbarStore';
const QUERY_KEYS = {
  config: ['restaurantConfig'],
};
export const useRestaurantConfigQueries = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const useGetConfig = () => {
    return useQuery({
      queryKey: QUERY_KEYS.config,
      queryFn: restaurantConfigService.getConfig,
    });
  };
  const useUpdateConfig = (options?: { successMessage?: string }) => {
    return useMutation({
      mutationFn: (data: UpdateRestaurantConfigDto) =>
        restaurantConfigService.updateConfig(data),
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: QUERY_KEYS.config });
        showSnackbar({
          message:
            options?.successMessage || 'Configuración actualizada exitosamente',
          type: 'success',
        });
      },
      onError: (error: any) => {
        showSnackbar({
          message:
            error.response?.data?.message ||
            'Error al actualizar la configuración',
          type: 'error',
        });
      },
    });
  };
  return {
    useGetConfig,
    useUpdateConfig,
  };
};

================
File: app/src/modules/restaurantConfig/navigation/RestaurantConfigStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';
import RestaurantConfigScreen from '../screens/RestaurantConfigScreen';
import { RestaurantConfigStackParamList } from './types';
const Stack = createNativeStackNavigator<RestaurantConfigStackParamList>();
export const RestaurantConfigStackNavigator = () => {
  const theme = useAppTheme();
  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="RestaurantConfig"
        component={RestaurantConfigScreen}
        options={{
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/restaurantConfig/navigation/types.ts
================
export type RestaurantConfigStackParamList = {
  RestaurantConfig: undefined;
};

================
File: app/src/modules/restaurantConfig/services/restaurantConfigService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  RestaurantConfig,
  UpdateRestaurantConfigDto,
} from '../types/restaurantConfig.types';
export const restaurantConfigService = {
  getConfig: async (): Promise<RestaurantConfig> => {
    const response = await apiClient.get<RestaurantConfig>(
      API_PATHS.RESTAURANT_CONFIG,
    );
    if (!response.data) {
      throw new Error('No se pudo obtener la configuración del restaurante');
    }
    return response.data;
  },
  updateConfig: async (
    data: UpdateRestaurantConfigDto,
  ): Promise<RestaurantConfig> => {
    const response = await apiClient.put<RestaurantConfig>(
      API_PATHS.RESTAURANT_CONFIG,
      data,
    );
    if (!response.data) {
      throw new Error('No se pudo actualizar la configuración del restaurante');
    }
    return response.data;
  },
};

================
File: app/src/modules/users/components/index.ts
================
export * from './UserFormModal';
export * from './UserDetailModal';

================
File: app/src/modules/users/hooks/index.ts
================
export * from './useUsers';

================
File: app/src/modules/users/hooks/useUsers.tsx
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { usersApiService } from '../services';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { CreateUserDto, UpdateUserDto, UsersQuery } from '../types';
const USERS_QUERY_KEY = 'users';
export function useGetUsers(params?: UsersQuery) {
  return useQuery({
    queryKey: [USERS_QUERY_KEY, params],
    queryFn: () => usersApiService.findAll(params),
    staleTime: 5 * 60 * 1000,
  });
}
export function useGetUser(id?: string) {
  return useQuery({
    queryKey: [USERS_QUERY_KEY, id],
    queryFn: () => (id ? usersApiService.findOne(id) : Promise.resolve(null)),
    enabled: !!id,
    staleTime: 5 * 60 * 1000,
  });
}
export function useCreateUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: (data: CreateUserDto) => usersApiService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      showSnackbar({
        message: 'Usuario creado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al crear usuario',
        type: 'error',
      });
    },
  });
}
export function useUpdateUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateUserDto }) =>
      usersApiService.update(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      queryClient.invalidateQueries({
        queryKey: [USERS_QUERY_KEY, variables.id],
      });
      showSnackbar({
        message: 'Usuario actualizado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al actualizar usuario',
        type: 'error',
      });
    },
  });
}
export function useDeleteUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: async (id: string) => {
      await usersApiService.remove(id);
      return id;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      showSnackbar({
        message: 'Usuario eliminado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al eliminar usuario',
        type: 'error',
      });
    },
  });
}
export function useResetPassword() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: ({ id, password }: { id: string; password: string }) =>
      usersApiService.resetPassword(id, password),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: [USERS_QUERY_KEY, variables.id],
      });
      showSnackbar({
        message: 'Contraseña actualizada exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al cambiar contraseña',
        type: 'error',
      });
    },
  });
}
export function useToggleUserActive() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: ({ id, isActive }: { id: string; isActive: boolean }) =>
      usersApiService.toggleActive(id, isActive),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      queryClient.invalidateQueries({
        queryKey: [USERS_QUERY_KEY, variables.id],
      });
      showSnackbar({
        message: `Usuario ${variables.isActive ? 'activado' : 'desactivado'} exitosamente`,
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message:
          error.response?.data?.message ||
          'Error al cambiar estado del usuario',
        type: 'error',
      });
    },
  });
}

================
File: app/src/modules/users/navigation/UsersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { UsersListScreen } from '../screens';
export type UsersStackParamList = {
  UsersList: undefined;
};
const Stack = createNativeStackNavigator<UsersStackParamList>();
export function UsersStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="UsersList"
        component={UsersListScreen}
        options={{
          title: 'Usuarios',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/users/screens/index.ts
================
export * from './UsersListScreen';

================
File: app/src/modules/users/services/index.ts
================
export * from './usersApi.service';

================
File: app/src/modules/users/types/index.ts
================
export * from './user.types';

================
File: app/src/modules/users/types/user.types.ts
================
export enum GenderEnum {
  MALE = 'male',
  FEMALE = 'female',
  OTHER = 'other',
}
export interface User {
  id: string;
  email?: string | null;
  username: string;
  firstName?: string | null;
  lastName?: string | null;
  birthDate?: string | null;
  gender?: GenderEnum | null;
  phoneNumber?: string | null;
  address?: string | null;
  city?: string | null;
  state?: string | null;
  country?: string | null;
  zipCode?: string | null;
  emergencyContact?: {
    name?: string;
    phone?: string;
    relationship?: string;
  } | null;
  isActive: boolean;
  role?: Role;
  preparationScreen?: {
    id: string;
    name: string;
    description?: string | null;
  } | null;
  createdAt: string;
  updatedAt: string;
}
export interface Role {
  id: number;
  name: string;
}
export enum RoleEnum {
  ADMIN = 1,
  MANAGER = 2,
  CASHIER = 3,
  WAITER = 4,
  KITCHEN = 5,
  DELIVERY = 6,
}
export interface CreateUserDto {
  email?: string;
  username: string;
  password: string;
  firstName: string;
  lastName: string;
  birthDate?: string;
  gender?: GenderEnum;
  phoneNumber?: string;
  address?: string;
  city?: string;
  state?: string;
  country?: string;
  zipCode?: string;
  emergencyContact?: {
    name?: string;
    phone?: string;
    relationship?: string;
  };
  role: {
    id: number;
  };
}
export interface UpdateUserDto {
  email?: string;
  username?: string;
  password?: string;
  firstName?: string;
  lastName?: string;
  birthDate?: string;
  gender?: GenderEnum;
  phoneNumber?: string;
  address?: string;
  city?: string;
  state?: string;
  country?: string;
  zipCode?: string;
  emergencyContact?: {
    name?: string;
    phone?: string;
    relationship?: string;
  };
  isActive?: boolean;
  role?: {
    id: number;
  };
}
export interface UsersQuery {
  page?: number;
  limit?: number;
  filters?: {
    isActive?: boolean;
    roles?: { id: number }[];
  };
  search?: string;
  sortBy?: string;
  sortOrder?: 'ASC' | 'DESC';
}
export interface UsersResponse {
  data: User[];
  hasNextPage: boolean;
}

================
File: app/src/services/reconnectionSnackbarService.ts
================
import { autoReconnectService } from './autoReconnectService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useAuthStore } from '@/app/store/authStore';
class ReconnectionSnackbarService {
  private unsubscribe: (() => void) | null = null;
  private lastLogCount = 0;
  private lastStatus: string | null = null;
  private snackbarTimeouts: Map<string, NodeJS.Timeout> = new Map();
  start() {
    this.stop();
    this.unsubscribe = autoReconnectService.subscribe((state) => {
      const isLoggedIn = !!useAuthStore.getState().user;
      if (!isLoggedIn) return;
      if (!state.isReconnecting && state.status !== 'connected') {
        this.clearAllSnackbars();
        return;
      }
      if (state.status !== this.lastStatus) {
        this.lastStatus = state.status;
        this.showStatusSnackbar(state.status, state.attempts);
      }
      if (state.logs.length > this.lastLogCount) {
        const newLogs = state.logs.slice(
          0,
          state.logs.length - this.lastLogCount,
        );
        this.processNewLogs(newLogs);
      }
      this.lastLogCount = state.logs.length;
    });
  }
  stop() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }
    this.clearAllSnackbars();
    this.lastLogCount = 0;
    this.lastStatus = null;
  }
  private showStatusSnackbar(status: string, attempts: number) {
    const { showSnackbar } = useSnackbarStore.getState();
    this.clearSnackbar('status');
    let message = '';
    let type: 'info' | 'error' | 'success' | 'warning' = 'info';
    let duration = 3000;
    switch (status) {
      case 'checking-network':
        message = '📡 Verificando conexión WiFi...';
        type = 'info';
        break;
      case 'checking-health':
        message = `🏥 Verificando servidor (intento #${attempts})`;
        type = 'info';
        break;
      case 'running-discovery':
        message = '🔍 Buscando servidor en la red...';
        type = 'warning';
        duration = 5000;
        break;
      case 'no-wifi':
        message = '📡 Sin conexión WiFi';
        type = 'error';
        duration = 5000;
        break;
      case 'failed':
        message = `❌ Reconexión fallida (intento #${attempts})`;
        type = 'error';
        break;
      case 'connected':
        message = '✅ ¡Conexión restablecida!';
        type = 'success';
        duration = 4000;
        break;
    }
    if (message) {
      showSnackbar({ message, type, duration });
      const timeout = setTimeout(() => {
        this.snackbarTimeouts.delete('status');
      }, duration);
      this.snackbarTimeouts.set('status', timeout);
    }
  }
  private processNewLogs(logs: string[]) {
    const { showSnackbar } = useSnackbarStore.getState();
    logs.forEach((log) => {
      if (
        log.includes('CICLO DE RECONEXIÓN') ||
        log.includes('════════') ||
        log.includes('PASO 1:') ||
        log.includes('PASO 2:') ||
        log.includes('PASO 3:')
      ) {
        return;
      }
      if (
        log.includes('ERROR:') &&
        (log.includes('Health check falló') ||
          log.includes('No se encontró servidor') ||
          log.includes('Ciclo fallido'))
      ) {
        showSnackbar({
          message: this.cleanLogMessage(log),
          type: 'error',
          duration: 4000,
        });
      }
      else if (
        log.includes('SUCCESS:') &&
        (log.includes('WiFi conectado') ||
          log.includes('Health check exitoso') ||
          log.includes('Servidor encontrado') ||
          log.includes('RECONEXIÓN EXITOSA'))
      ) {
        showSnackbar({
          message: this.cleanLogMessage(log),
          type: 'success',
          duration: 3000,
        });
      }
    });
  }
  private cleanLogMessage(log: string): string {
    return log
      .replace(/\[[^\]]+\]\s*(INFO|ERROR|SUCCESS):\s*/, '')
      .replace(/\s*→\s*/, ' ')
      .trim();
  }
  private clearSnackbar(key: string) {
    const timeout = this.snackbarTimeouts.get(key);
    if (timeout) {
      clearTimeout(timeout);
      this.snackbarTimeouts.delete(key);
    }
  }
  private clearAllSnackbars() {
    this.snackbarTimeouts.forEach((timeout) => clearTimeout(timeout));
    this.snackbarTimeouts.clear();
  }
}
export const reconnectionSnackbarService = new ReconnectionSnackbarService();

================
File: app/tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true, // Report errors on unused local variables
    "noUnusedParameters": true, // Report errors on unused parameters
    "moduleResolution": "bundler", // Añadido para resolver tipos de navegación
    "baseUrl": ".", // O "./" - Directorio base para los paths
    "paths": {
      "@/*": ["src/*"] // Define el alias @/ para apuntar a src/
    }
  }
}

================
File: backend/.dockerignore
================
/node_modules
/.data
/dist
/files

================
File: backend/.editorconfig
================
# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
end_of_line = lf
insert_final_newline = true
charset = utf-8
indent_style = space
indent_size = 2
trim_trailing_whitespace = true

# Markdown files
[*.md]
trim_trailing_whitespace = false

================
File: backend/.gitignore
================
# Backend specific .gitignore

# Compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# OS
.DS_Store
Thumbs.db
*.swp
*.swo
*~

# Tests
/coverage
/.nyc_output
*.lcov

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace
*.sublime-project

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
.data
/ormconfig.json
*.sqlite
*.sqlite3
*.db

# Uploaded files
/files
/uploads
/public/uploads

# TypeORM
ormconfig.json
ormconfig.js

# Build files
*.pid
*.seed
*.pid.lock

# Dependencies
.pnp
.pnp.js

# Cache
.eslintcache
.cache
*.tsbuildinfo

# Temporary files
tmp/
temp/
*.tmp
*.temp

# Documentation
/docs/_build
/documentation

# Certificates
*.pem
*.key
*.crt
*.cer

# Misc
.codegpt
.repomix/
repomix-output.txt

# Docker volumes (if any)
postgres-data/
redis-data/

================
File: backend/.hygen.js
================
module.exports = {
  templates: `${__dirname}/.hygen`,
};

================
File: backend/.hygen/generate/relational-resource/app-module-import.ejs.t
================
---
inject: true
to: src/app.module.ts
before: \@Module
---
import { <%= h.inflection.transform(name, ['pluralize']) %>Module } from './<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.module';

================
File: backend/.hygen/generate/relational-resource/app-module.ejs.t
================
---
inject: true
to: src/app.module.ts
after: imports
---
    <%= h.inflection.transform(name, ['pluralize']) %>Module,

================
File: backend/.hygen/generate/relational-resource/controller.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.controller.ts
---
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Query,
} from '@nestjs/common';
import { <%= h.inflection.transform(name, ['pluralize']) %>Service } from './<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service';
import { Create<%= name %>Dto } from './dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto';
import { Update<%= name %>Dto } from './dto/update-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto';
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
  ApiParam,
  ApiTags,
} from '@nestjs/swagger';
import { <%= name %> } from './domain/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>';
import { AuthGuard } from '@nestjs/passport';
import {
  InfinityPaginationResponse,
  InfinityPaginationResponseDto,
} from '../utils/dto/infinity-pagination-response.dto';
import { infinityPagination } from '../utils/infinity-pagination';
import { FindAll<%= h.inflection.transform(name, ['pluralize']) %>Dto } from './dto/find-all-<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.dto';

@ApiTags('<%= h.inflection.transform(name, ['pluralize', 'humanize']) %>')
@ApiBearerAuth()
@UseGuards(AuthGuard('jwt'))
@Controller({
  path: '<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>',
  version: '1',
})
export class <%= h.inflection.transform(name, ['pluralize']) %>Controller {
  constructor(private readonly <%= h.inflection.camelize(h.inflection.pluralize(name), true) %>Service: <%= h.inflection.transform(name, ['pluralize']) %>Service) {}

  @Post()
  @ApiCreatedResponse({
    type: <%= name %>,
  })
  create(@Body() create<%= name %>Dto: Create<%= name %>Dto) {
    return this.<%= h.inflection.camelize(h.inflection.pluralize(name), true) %>Service.create(create<%= name %>Dto);
  }

  @Get()
  @ApiOkResponse({
    type: InfinityPaginationResponse(<%= name %>),
  })
  async findAll(
    @Query() query: FindAll<%= h.inflection.transform(name, ['pluralize']) %>Dto,
  ): Promise<InfinityPaginationResponseDto<<%= name %>>> {
    const page = query?.page ?? 1;
    let limit = query?.limit ?? 10;
    if (limit > 50) {
      limit = 50;
    }

    return infinityPagination(
      await this.<%= h.inflection.camelize(h.inflection.pluralize(name), true) %>Service.findAllWithPagination({
        paginationOptions: {
          page,
          limit,
        },
      }),
      { page, limit },
    );
  }

  @Get(':id')
  @ApiParam({
    name: 'id',
    type: String,
    required: true,
  })
  @ApiOkResponse({
    type: <%= name %>,
  })
  findById(@Param('id') id: string) {
    return this.<%= h.inflection.camelize(h.inflection.pluralize(name), true) %>Service.findById(id);
  }

  @Patch(':id')
  @ApiParam({
    name: 'id',
    type: String,
    required: true,
  })
  @ApiOkResponse({
    type: <%= name %>,
  })
  update(
    @Param('id') id: string,
    @Body() update<%= name %>Dto: Update<%= name %>Dto,
  ) {
    return this.<%= h.inflection.camelize(h.inflection.pluralize(name), true) %>Service.update(id, update<%= name %>Dto);
  }

  @Delete(':id')
  @ApiParam({
    name: 'id',
    type: String,
    required: true,
  })
  remove(@Param('id') id: string) {
    return this.<%= h.inflection.camelize(h.inflection.pluralize(name), true) %>Service.remove(id);
  }
}

================
File: backend/.hygen/generate/relational-resource/domain/domain.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/domain/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.ts
---
import { ApiProperty } from '@nestjs/swagger';

export class <%= name %> {
  @ApiProperty({
    type: String,
  })
  id: string;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  updatedAt: Date;
}

================
File: backend/.hygen/generate/relational-resource/dto/create.dto.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
---
export class Create<%= name %>Dto {
  // Don't forget to use the class-validator decorators in the DTO properties.
}

================
File: backend/.hygen/generate/relational-resource/dto/domain.dto.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
---
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class <%= name %>Dto {
  @ApiProperty()
  @IsString()
  @IsNotEmpty()
  id: string;
}

================
File: backend/.hygen/generate/relational-resource/dto/find-all.dto.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/find-all-<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.dto.ts
---
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsNumber, IsOptional } from 'class-validator';
import { Transform } from 'class-transformer';

export class FindAll<%= h.inflection.transform(name, ['pluralize']) %>Dto {
  @ApiPropertyOptional()
  @Transform(({ value }) => (value ? Number(value) : 1))
  @IsNumber()
  @IsOptional()
  page?: number;

  @ApiPropertyOptional()
  @Transform(({ value }) => (value ? Number(value) : 10))
  @IsNumber()
  @IsOptional()
  limit?: number;
}

================
File: backend/.hygen/generate/relational-resource/dto/update.dto.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/update-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
---
// Don't forget to use the class-validator decorators in the DTO properties.
// import { Allow } from 'class-validator';

import { PartialType } from '@nestjs/swagger';
import { Create<%= name %>Dto } from './create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto';

export class Update<%= name %>Dto extends PartialType(Create<%= name %>Dto) {}

================
File: backend/.hygen/generate/relational-resource/infrastructure/persistence/relational/entities/entity.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity.ts
---
import {
  CreateDateColumn,
  Entity,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';

@Entity({
  name: '<%= h.inflection.transform(name, ['underscore']) %>',
})
export class <%= name %>Entity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

================
File: backend/.hygen/generate/relational-resource/infrastructure/persistence/relational/mappers/mapper.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/mappers/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.mapper.ts
---
import { <%= name %> } from '../../../../domain/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>';
import { <%= name %>Entity } from '../entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity';

export class <%= name %>Mapper {
  static toDomain(raw: <%= name %>Entity): <%= name %> {
    const domainEntity = new <%= name %>();
    domainEntity.id = raw.id;
    domainEntity.createdAt = raw.createdAt;
    domainEntity.updatedAt = raw.updatedAt;

    return domainEntity;
  }

  static toEntity(domainEntity: <%= name %>): <%= name %>Entity {
    const persistenceEntity = new <%= name %>Entity();
    if (domainEntity.id) {
      persistenceEntity.id = domainEntity.id;
    }
    persistenceEntity.createdAt = domainEntity.createdAt;
    persistenceEntity.updatedAt = domainEntity.updatedAt;

    return persistenceEntity;
  }
}

================
File: backend/.hygen/generate/relational-resource/infrastructure/persistence/relational/relational-persistence.module.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/relational-persistence.module.ts
---
import { Module } from '@nestjs/common';
import { <%= name %>Repository } from '../<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.repository';
import { <%= name %>RelationalRepository } from './repositories/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.repository';
import { TypeOrmModule } from '@nestjs/typeorm';
import { <%= name %>Entity } from './entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity';

@Module({
  imports: [TypeOrmModule.forFeature([<%= name %>Entity])],
  providers: [
    {
      provide: <%= name %>Repository,
      useClass: <%= name %>RelationalRepository,
    },
  ],
  exports: [<%= name %>Repository],
})
export class Relational<%= name %>PersistenceModule {}

================
File: backend/.hygen/generate/relational-resource/infrastructure/persistence/relational/repositories/repository.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/repositories/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.repository.ts
---
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';
import { <%= name %>Entity } from '../entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity';
import { NullableType } from '../../../../../utils/types/nullable.type';
import { <%= name %> } from '../../../../domain/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>';
import { <%= name %>Repository } from '../../<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.repository';
import { <%= name %>Mapper } from '../mappers/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.mapper';
import { IPaginationOptions } from '../../../../../utils/types/pagination-options';

@Injectable()
export class <%= name %>RelationalRepository implements <%= name %>Repository {
  constructor(
    @InjectRepository(<%= name %>Entity)
    private readonly <%= h.inflection.camelize(name, true) %>Repository: Repository<<%= name %>Entity>,
  ) {}

  async create(data: <%= name %>): Promise<<%= name %>> {
    const persistenceModel = <%= name %>Mapper.toEntity(data);
    const newEntity = await this.<%= h.inflection.camelize(name, true) %>Repository.save(
      this.<%= h.inflection.camelize(name, true) %>Repository.create(persistenceModel),
    );
    return <%= name %>Mapper.toDomain(newEntity);
  }

  async findAllWithPagination({
    paginationOptions,
  }: {
    paginationOptions: IPaginationOptions;
  }): Promise<<%= name %>[]> {
    const entities = await this.<%= h.inflection.camelize(name, true) %>Repository.find({
      skip: (paginationOptions.page - 1) * paginationOptions.limit,
      take: paginationOptions.limit,
    });

    return entities.map((entity) => <%= name %>Mapper.toDomain(entity));
  }

  async findById(id: <%= name %>['id']): Promise<NullableType<<%= name %>>> {
    const entity = await this.<%= h.inflection.camelize(name, true) %>Repository.findOne({
      where: { id },
    });

    return entity ? <%= name %>Mapper.toDomain(entity) : null;
  }

  async findByIds(ids: <%= name %>['id'][]): Promise<<%= name %>[]> {
    const entities = await this.<%= h.inflection.camelize(name, true) %>Repository.find({
      where: { id: In(ids) },
    });

    return entities.map((entity) => <%= name %>Mapper.toDomain(entity));
  }

  async update(
    id: <%= name %>['id'],
    payload: Partial<<%= name %>>,
  ): Promise<<%= name %>> {
    const entity = await this.<%= h.inflection.camelize(name, true) %>Repository.findOne({
      where: { id },
    });

    if (!entity) {
      throw new Error('Record not found');
    }

    const updatedEntity = await this.<%= h.inflection.camelize(name, true) %>Repository.save(
      this.<%= h.inflection.camelize(name, true) %>Repository.create(
        <%= name %>Mapper.toEntity({
          ...<%= name %>Mapper.toDomain(entity),
          ...payload,
        }),
      ),
    );

    return <%= name %>Mapper.toDomain(updatedEntity);
  }

  async remove(id: <%= name %>['id']): Promise<void> {
    await this.<%= h.inflection.camelize(name, true) %>Repository.delete(id);
  }
}

================
File: backend/.hygen/generate/relational-resource/infrastructure/persistence/repository.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.repository.ts
---
import { DeepPartial } from '../../../utils/types/deep-partial.type';
import { NullableType } from '../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../utils/types/pagination-options';
import { <%= name %> } from '../../domain/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>';

export abstract class <%= name %>Repository {
  abstract create(
    data: Omit<<%= name %>, 'id' | 'createdAt' | 'updatedAt'>,
  ): Promise<<%= name %>>;

  abstract findAllWithPagination({
    paginationOptions,
  }: {
    paginationOptions: IPaginationOptions;
  }): Promise<<%= name %>[]>;

  abstract findById(id: <%= name %>['id']): Promise<NullableType<<%= name %>>>;

  abstract findByIds(ids: <%= name %>['id'][]): Promise<<%= name %>[]>;

  abstract update(
    id: <%= name %>['id'],
    payload: DeepPartial<<%= name %>>,
  ): Promise<<%= name %> | null>;

  abstract remove(id: <%= name %>['id']): Promise<void>;
}

================
File: backend/.hygen/generate/relational-resource/module.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.module.ts
---
import { Module } from '@nestjs/common';
import { <%= h.inflection.transform(name, ['pluralize']) %>Service } from './<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service';
import { <%= h.inflection.transform(name, ['pluralize']) %>Controller } from './<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.controller';
import { Relational<%= name %>PersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';

@Module({
  imports: [
    // import modules, etc.
    Relational<%= name %>PersistenceModule,
  ],
  controllers: [<%= h.inflection.transform(name, ['pluralize']) %>Controller],
  providers: [<%= h.inflection.transform(name, ['pluralize']) %>Service],
  exports: [<%= h.inflection.transform(name, ['pluralize']) %>Service, Relational<%= name %>PersistenceModule],
})
export class <%= h.inflection.transform(name, ['pluralize']) %>Module {}

================
File: backend/.hygen/generate/relational-resource/service.ejs.t
================
---
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service.ts
---
import { Injectable } from '@nestjs/common';
import { Create<%= name %>Dto } from './dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto';
import { Update<%= name %>Dto } from './dto/update-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto';
import { <%= name %>Repository } from './infrastructure/persistence/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.repository';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { <%= name %> } from './domain/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>';

@Injectable()
export class <%= h.inflection.transform(name, ['pluralize']) %>Service {
  constructor(
    // Dependencies here
    private readonly <%= h.inflection.camelize(name, true) %>Repository: <%= name %>Repository,
  ) {}

  async create(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    create<%= name %>Dto: Create<%= name %>Dto
  ) {
    // Do not remove comment below.
    // <creating-property />

    return this.<%= h.inflection.camelize(name, true) %>Repository.create({
      // Do not remove comment below.
      // <creating-property-payload />
    });
  }

  findAllWithPagination({
    paginationOptions,
  }: {
    paginationOptions: IPaginationOptions;
  }) {
    return this.<%= h.inflection.camelize(name, true) %>Repository.findAllWithPagination({
      paginationOptions: {
        page: paginationOptions.page,
        limit: paginationOptions.limit,
      },
    });
  }

  findById(id: <%= name %>['id']) {
    return this.<%= h.inflection.camelize(name, true) %>Repository.findById(id);
  }

  findByIds(ids: <%= name %>['id'][]) {
    return this.<%= h.inflection.camelize(name, true) %>Repository.findByIds(ids);
  }

  async update(
    id: <%= name %>['id'],
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    update<%= name %>Dto: Update<%= name %>Dto,
  ) {
    // Do not remove comment below.
    // <updating-property />

    return this.<%= h.inflection.camelize(name, true) %>Repository.update(id, {
      // Do not remove comment below.
      // <updating-property-payload />
    });
  }

  remove(id: <%= name %>['id']) {
    return this.<%= h.inflection.camelize(name, true) %>Repository.remove(id);
  }
}

================
File: backend/.hygen/property/add-to-relational/domain/domain-import.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/domain/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.ts
at_line: 0
skip_if: import { <%= type %><% if (type === 'File') { -%>Type<% } -%>
---
<% if (kind === 'reference' || kind === 'duplication') { -%>import { <%= type %><% if (type === 'File') { -%>Type<% } -%> } from '../../<%= h.inflection.transform(type, ['pluralize', 'underscore', 'dasherize']) %>/domain/<%= h.inflection.transform(type, ['underscore', 'dasherize']) %>';<% } -%>

================
File: backend/.hygen/property/add-to-relational/domain/domain.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/domain/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.ts
after: export class <%= name %> {
---

@ApiProperty({
  type: () => 
    <% if (kind === 'primitive') { -%>
      <% if (type === 'string') { -%>
        String,
      <% } else if (type === 'number') { -%>
        Number,
      <% } else if (type === 'boolean') { -%>
        Boolean,
      <% } else if (type === 'Date') { -%>
        Date,
      <% } -%>
    <% } else if (kind === 'reference' || kind === 'duplication') { -%>
      <% if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>
        [<%= type %><% if (type === 'File') { -%>Type<% } -%>],
      <% } else { -%>
        <%= type %><% if (type === 'File') { -%>Type<% } -%>,
      <% } -%>
    <% } -%>
  nullable: <%= isNullable %>,
})

<% if (kind === 'reference' || kind === 'duplication') { -%>
  <%= property %><% if (!isAddToDto || isOptional) { -%>?<% } -%>: <%= type %><% if (type === 'File') { -%>Type<% } -%><% if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>[]<% } -%> <% if (isNullable) { -%> | null<% } -%>;
<% } else { -%>
  <%= property %><% if (!isAddToDto || isOptional) { -%>?<% } -%>: <%= type %> <% if (isNullable) { -%> | null<% } -%>;
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/01-create.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
after: export class Create<%= name %>Dto
---

<% if (isAddToDto) { -%>
  @ApiProperty({
    required: <%= !(isOptional || isNullable) %>,
    type: () => 
      <% if (kind === 'primitive') { -%>
        <% if (type === 'string') { -%>
          String,
        <% } else if (type === 'number') { -%>
          Number,
        <% } else if (type === 'boolean') { -%>
          Boolean,
        <% } else if (type === 'Date') { -%>
          Date,
        <% } -%>
      <% } else if (kind === 'reference' || kind === 'duplication') { -%>
        <% if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>
          [<%= type %>Dto],
        <% } else { -%>
          <%= type %>Dto,
        <% } -%>
      <% } -%>
  })
<% } -%>

<% if (isAddToDto) { -%>
  <% if (isOptional || isNullable) { -%>
    @IsOptional()
  <% } -%>
  <% if (kind === 'primitive') { -%>
    <% if (type === 'string') { -%>
      @IsString()
    <% } else if (type === 'number') { -%>
      @IsNumber()
    <% } else if (type === 'boolean') { -%>
      @IsBoolean()
    <% } else if (type === 'Date') { -%>
      @Transform(({ value }) => new Date(value))
      @IsDate()
    <% } -%>
  <% } else if (kind === 'reference' || kind === 'duplication') { -%>
    @ValidateNested()
    @Type(() => <%= type %>Dto)
    <% if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>
      @IsArray()
    <% } else { -%>
      @IsNotEmptyObject()
    <% } -%>
  <% } -%>
<% } -%>

<% if (kind === 'reference' || kind === 'duplication') { -%>
  <%= property %><% if (!isAddToDto || isOptional) { -%>?<% } -%>: <%= type %>Dto<% if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>[]<% } -%> <% if (isNullable) { -%> | null<% } -%>;
<% } else { -%>
  <%= property %><% if (!isAddToDto || isOptional) { -%>?<% } -%>: <%= type %> <% if (isNullable) { -%> | null<% } -%>;
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/02-create-import-class-transformer.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: export class Create<%= name %>Dto
skip_if: "} from 'class-transformer'"
---
<% if (isAddToDto && (kind === 'reference' || kind === 'duplication' || (kind === 'primitive' && type === 'Date'))) { -%>
  import {
    // decorators here
  } from 'class-transformer';
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/03-create-import-class-validator.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: export class Create<%= name %>Dto
skip_if: "} from 'class-validator'"
---
<% if (isAddToDto) { -%>
  import {
    // decorators here
  } from 'class-validator';
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/04-create-import-swagger.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: export class Create<%= name %>Dto
skip_if: "} from '@nestjs/swagger'"
---
<% if (isAddToDto) { -%>
  import { 
    // decorators here
  } from '@nestjs/swagger';
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/05-create-boolean.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-validator'"
skip_if: \IsBoolean,
---
<% if (isAddToDto && type === 'boolean') { -%>
  IsBoolean,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/06-create-number.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-validator'"
skip_if: \IsNumber,
---
<% if (isAddToDto && type === 'number') { -%>
  IsNumber,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/07-create-string.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-validator'"
skip_if: \IsString,
---
<% if (isAddToDto && type === 'string') { -%>
  IsString,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/08-create-api-property.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from '@nestjs/swagger'"
skip_if: \ApiProperty,
---
<% if (isAddToDto) { -%>
  ApiProperty,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/09-create-class-transformer-type.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-transformer'"
skip_if: \Type,
---
<% if (isAddToDto && (kind === 'reference' || kind === 'duplication')) { -%>
  Type,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/10-create-validate-is-array.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-validator'"
skip_if: \IsArray,
---
<% if (isAddToDto && (kind === 'reference' || kind === 'duplication') && (referenceType === 'oneToMany' || referenceType === 'manyToMany')) { -%>
  IsArray,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/11-create-validate-nested.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-validator'"
skip_if: \ValidateNested,
---
<% if (isAddToDto && (kind === 'reference' || kind === 'duplication')) { -%>
  ValidateNested,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/12-create-validate-not-empty-object.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-validator'"
skip_if: \IsNotEmptyObject,
---
<% if (isAddToDto && ((kind === 'reference' || kind === 'duplication') && (referenceType === 'oneToOne' || referenceType === 'manyToOne'))) { -%>
  IsNotEmptyObject,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/13-create-type-dto-import.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
at_line: 0
skip_if: import { <%= type %>Dto
---
<% if (kind === 'reference' || kind === 'duplication') { -%>
  import { <%= type %>Dto } from '../../<%= h.inflection.transform(type, ['pluralize', 'underscore', 'dasherize']) %>/dto/<%= h.inflection.transform(type, ['underscore', 'dasherize']) %>.dto';
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/14-create-optional.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-validator'"
skip_if: \IsOptional,
---
<% if (isAddToDto && (isOptional || isNullable)) { -%>
  IsOptional,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/15-create-date.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-validator'"
skip_if: \IsDate,
---
<% if (isAddToDto && type === 'Date') { -%>
  IsDate,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/dto/16-create-class-transformer-transform.dto.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/dto/create-<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.dto.ts
before: "} from 'class-transformer'"
skip_if: \Transform,
---
<% if (isAddToDto && (kind === 'primitive' && type === 'Date')) { -%>
  Transform,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/index.js
================
const { execSync } = require('child_process');
const collectPromisesResults = (callback) => async (prevValues) => {
  const results = await callback(prevValues);
  return { ...prevValues, ...results };
};
module.exports = {
  prompt: async ({ prompter, args }) => {
    if (Object.keys(args).length) {
      return Promise.resolve({
        name: args.name,
        property: args.property,
        kind: args.kind,
        type: args.type,
        referenceType: args.referenceType,
        propertyInReference: args.propertyInReference,
        isAddToDto: args.isAddToDto === 'true',
        isOptional: args.isOptional === 'true',
        isNullable: args.isNullable === 'true',
      });
    }
    const result = await prompter
      .prompt({
        type: 'input',
        name: 'name',
        message: "Entity name (e.g. 'User')",
        validate: (input) => {
          if (!input.trim()) {
            return 'Entity name is required';
          }
          return true;
        },
        format: (input) => {
          return input.trim();
        },
      })
      .then(
        collectPromisesResults(() => {
          return prompter.prompt({
            type: 'input',
            name: 'property',
            message: "Property name (e.g. 'firstName')",
            validate: (input) => {
              if (!input.trim()) {
                return 'Property name is required';
              }
              return true;
            },
            format: (input) => {
              return input.trim();
            },
          });
        }),
      )
      .then(
        collectPromisesResults((rootValues) => {
          return prompter
            .prompt({
              type: 'select',
              name: 'kind',
              message: 'Select kind of type',
              choices: [
                {
                  message: 'Primitive and Date (string, number, Date, etc)',
                  value: 'primitive',
                },
                { message: 'Reference to entity', value: 'reference' },
                {
                  message: 'Duplication data from entity',
                  value: 'duplication',
                },
              ],
            })
            .then(
              collectPromisesResults((values) => {
                if (
                  values.kind === 'reference' ||
                  values.kind === 'duplication'
                ) {
                  return prompter
                    .prompt({
                      type: 'input',
                      name: 'type',
                      message: "Entity name (e.g. 'File')",
                      validate: (input) => {
                        if (!input.trim()) {
                          return 'Entity name is required';
                        }
                        return true;
                      },
                      format: (input) => {
                        return input.trim();
                      },
                    })
                    .then(
                      collectPromisesResults((referenceValues) => {
                        return prompter
                          .prompt({
                            type: 'select',
                            name: 'referenceType',
                            message: 'Select type of reference',
                            choices: [
                              {
                                message: `One to one (${rootValues.name} contains only one instance of ${referenceValues.type}, and ${referenceValues.type} contains only one instance of ${rootValues.name}. ${rootValues.property}: ${referenceValues.type})`,
                                value: 'oneToOne',
                              },
                              {
                                message: `One to many (${rootValues.name} contains multiple instances of ${referenceValues.type}, but ${referenceValues.type} contains only one instance of ${rootValues.name}. ${rootValues.property}: ${referenceValues.type}[])`,
                                value: 'oneToMany',
                              },
                              {
                                message: `Many to one (${rootValues.name} contains only one instance of ${referenceValues.type}, but ${referenceValues.type} contains multiple instances of ${rootValues.name}. ${rootValues.property}: ${referenceValues.type})`,
                                value: 'manyToOne',
                              },
                              {
                                message: `Many to many (${rootValues.name} contains multiple instances of ${referenceValues.type}, and ${referenceValues.type} contains multiple instances of ${rootValues.name}. ${rootValues.property}: ${referenceValues.type}[])`,
                                value: 'manyToMany',
                              },
                            ],
                          })
                          .then(
                            collectPromisesResults((referenceTypeValues) => {
                              if (
                                referenceTypeValues.referenceType ===
                                'oneToMany'
                              ) {
                                return prompter.prompt({
                                  type: 'input',
                                  name: 'propertyInReference',
                                  message: `Property name in ${referenceValues.type} (e.g. 'createdBy')`,
                                  validate: (input) => {
                                    if (!input.trim()) {
                                      return `Property name in ${referenceValues.type} is required`;
                                    }
                                    return true;
                                  },
                                  format: (input) => {
                                    return input.trim();
                                  },
                                });
                              }
                              return referenceTypeValues;
                            }),
                          );
                      }),
                    );
                }
                return prompter.prompt({
                  type: 'select',
                  name: 'type',
                  message: 'Property type',
                  choices: ['string', 'number', 'boolean', 'Date'],
                });
              }),
            );
        }),
      )
      .then(
        collectPromisesResults(() => {
          return prompter.prompt({
            type: 'confirm',
            name: 'isAddToDto',
            message: 'Add to DTO?',
            initial: true,
          });
        }),
      )
      .then(
        collectPromisesResults(() => {
          return prompter.prompt({
            type: 'confirm',
            name: 'isOptional',
            message: 'Is the property optional?',
            initial: true,
          });
        }),
      )
      .then(
        collectPromisesResults((values) => {
          if (!values.isOptional) {
            return { isNullable: false };
          }
          return prompter.prompt({
            type: 'confirm',
            name: 'isNullable',
            message: 'Can the property be nullable??',
            initial: true,
          });
        }),
      );
    if (!result.propertyInReference) {
      result.propertyInReference = '';
    }
    if (
      (result.kind === 'reference' || result.kind === 'duplication') &&
      result.referenceType === 'oneToMany'
    ) {
      execSync(
        `npm run add:property:to-relational -- --name ${result.type} --property ${result.propertyInReference} --propertyInReference ${result.property} --kind ${result.kind} --type ${result.name} --referenceType manyToOne --isAddToDto ${result.isAddToDto} --isOptional false --isNullable false`,
        {
          stdio: 'inherit',
        },
      );
    }
    return result;
  },
};

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-column.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity.ts
before: from \'typeorm\'
skip_if: \sColumn,
---
<% if (kind === 'primitive' || kind === 'duplication') { -%>
  Column,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-join-column.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity.ts
before: from \'typeorm\'
skip_if: \sJoinColumn,
---
<% if (kind === 'reference' && (referenceType === 'oneToOne' || referenceType === 'manyToMany')) { -%>
  JoinColumn,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-many-to-many.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity.ts
before: from \'typeorm\'
skip_if: \ManyToMany,
---
<% if (kind === 'reference' && referenceType === 'manyToMany') { -%>
  ManyToMany,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-many-to-one.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity.ts
before: from \'typeorm\'
skip_if: \sManyToOne,
---
<% if (kind === 'reference' && referenceType === 'manyToOne') { -%>
  ManyToOne,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-one-to-many.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity.ts
before: from \'typeorm\'
skip_if: \sOneToMany,
---
<% if (kind === 'reference' && referenceType === 'oneToMany') { -%>
  OneToMany,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity-one-to-one.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity.ts
before: from \'typeorm\'
skip_if: \sOneToOne,
---
<% if (kind === 'reference' && referenceType === 'oneToOne') { -%>
  OneToOne,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/entity.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity.ts
after: export class <%= name %>Entity
---

<% if (kind === 'primitive') { -%>
  @Column({
    nullable: <%= isNullable %>,
    type:
      <% if (type === 'string') { -%>
        String,
      <% } else if (type === 'number') { -%>
        Number,
      <% } else if (type === 'boolean') { -%>
        Boolean,
      <% } else if (type === 'Date') { -%>
        Date,
      <% } -%>
  })
<% } -%>

<% if (kind === 'duplication') { -%>
  @Column({
    nullable: <%= isNullable %>,
    type: 'jsonb',
  })
<% } -%>

<% if (kind === 'reference') { -%>
  <% if (referenceType === 'oneToOne') { -%>
    @OneToOne(() => <%= type %>Entity, { eager: true, nullable: <%= isNullable %> })
  <% } else if (referenceType === 'oneToMany') { -%>
    @OneToMany(() => <%= type %>Entity, (childEntity) => childEntity.<%= propertyInReference %>, { eager: true, nullable: <%= isNullable %> })
  <% } else if (referenceType === 'manyToOne') { -%>
    @ManyToOne(
      () => <%= type %>Entity,
      <% if (propertyInReference) { -%>
        (parentEntity) => parentEntity.<%= propertyInReference %>,
      <% } -%>
      { eager: <% if (propertyInReference) { -%>false<% } else { -%>true<% } -%>, nullable: <%= isNullable %> }
    )
  <% } else if (referenceType === 'manyToMany') { -%>
    @ManyToMany(() => <%= type %>Entity, { eager: true, nullable: <%= isNullable %> })
  <% } -%>

  <% if (referenceType === 'oneToOne' || referenceType === 'manyToMany') { -%>
    @JoinColumn()
  <% } -%>

  <%= property %><% if (!isAddToDto || isOptional) { -%>?<% } -%>: <%= type %>Entity<% if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>[]<% } -%> <% if (isNullable) { -%> | null<% } -%>;
<% } else if (kind === 'duplication') { -%>
  <%= property %><% if (!isAddToDto || isOptional) { -%>?<% } -%>: <%= type %>Entity<% if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>[]<% } -%> <% if (isNullable) { -%> | null<% } -%>;
<% } else { -%>
  <%= property %><% if (!isAddToDto || isOptional) { -%>?<% } -%>: <%= type %> <% if (isNullable) { -%> | null<% } -%>;
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/entities/type-import.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity.ts
at_line: 0
skip_if: <% if (kind === 'reference' || kind === 'duplication') { -%>import { <%= type %>Entity<% } else { -%><%= true %><% } -%>
---
<% if (kind === 'reference' || kind === 'duplication') { -%>
  import { <%= type %>Entity } from '../../../../../<%= h.inflection.transform(type, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(type, ['underscore', 'dasherize']) %>.entity';
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/mappers/mapper-domain.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/mappers/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.mapper.ts
after: new <%= name %>\(\)
---
<% if (kind === 'primitive') { -%>
  domainEntity.<%= property %> = raw.<%= property %>;
<% } else if (kind === 'reference' || kind === 'duplication') { -%>
  <% if (referenceType === 'oneToOne' || referenceType === 'manyToOne') { -%>
    if (raw.<%= property %>) {
      domainEntity.<%= property %> = <%= type %>Mapper.toDomain(raw.<%= property %>);
    }
    <% if (isNullable) { -%>
      else if (raw.<%= property %> === null) {
        domainEntity.<%= property %> = null;
      }
    <% } -%>
  <% } else if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>
    if (raw.<%= property %>) {
      domainEntity.<%= property %> = raw.<%= property %>.map((item) => <%= type %>Mapper.toDomain(item));
    }
    <% if (isNullable) { -%>
      else if (raw.<%= property %> === null) {
        domainEntity.<%= property %> = null;
      }
    <% } -%>
  <% } -%>
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/mappers/mapper-import.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/mappers/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.mapper.ts
at_line: 1
skip_if: import { <%= type %>Mapper
---
<% if (kind === 'reference' || kind === 'duplication') { -%>
  import { <%= type %>Mapper } from '../../../../../<%= h.inflection.transform(type, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/mappers/<%= h.inflection.transform(type, ['underscore', 'dasherize']) %>.mapper';
<% } -%>

================
File: backend/.hygen/property/add-to-relational/infrastructure/persistence/relational/mappers/mapper-persistence.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/mappers/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.mapper.ts
after: new <%= name %>Entity\(\)
---
<% if (kind === 'primitive') { -%>
  persistenceEntity.<%= property %> = domainEntity.<%= property %>;
<% } else if (kind === 'reference' || kind === 'duplication') { -%>
  <% if (referenceType === 'oneToOne' || referenceType === 'manyToOne') { -%>
    if (domainEntity.<%= property %>) {
      persistenceEntity.<%= property %> = <%= type %>Mapper.toEntity(domainEntity.<%= property %>);
    }
    <% if (isNullable) { -%>
      else if (domainEntity.<%= property %> === null) {
        persistenceEntity.<%= property %> = null;
      }
    <% } -%>
  <% } else if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>
    if (domainEntity.<%= property %>) {
      persistenceEntity.<%= property %> = domainEntity.<%= property %>.map((item) => <%= type %>Mapper.toEntity(item));
    }
    <% if (isNullable) { -%>
      else if (domainEntity.<%= property %> === null) {
        persistenceEntity.<%= property %> = null;
      }
    <% } -%>
  <% } -%>
<% } -%>

================
File: backend/.hygen/property/add-to-relational/module-import.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.module.ts
at_line: 0
skip_if: import { <%= h.inflection.transform(type, ['pluralize']) %>Module
---
<% if (kind === 'reference' || kind === 'duplication') { -%>import { <%= h.inflection.transform(type, ['pluralize']) %>Module } from '../<%= h.inflection.transform(type, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(type, ['pluralize', 'underscore', 'dasherize']) %>.module';<% } -%>

================
File: backend/.hygen/property/add-to-relational/module.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.module.ts
after: imports.*\[
skip_if: <%= h.inflection.transform(type, ['pluralize']) %>Module,
---

<% if (kind === 'reference' || kind === 'duplication') { -%>
  <%= h.inflection.transform(type, ['pluralize']) %>Module,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/service-create-payload.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service.ts
after: \<creating\-property\-payload \/\>
---

<% if (kind === 'reference' || kind === 'duplication') { -%>
  <%= property %>,
<% } else { -%>
  <%= property %>: create<%= name %>Dto.<%= property %>,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/service-create.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service.ts
after: \<creating\-property \/\>
---
<% if (isAddToDto && !isOptional && !isNullable) { -%>
  <% if (kind === 'reference' || kind === 'duplication') { -%>
    <% if (referenceType === 'oneToOne' || referenceType === 'manyToOne') { -%>
      const <%= property %>Object = await this.<%= h.inflection.camelize(type, true) %>Service.findById(
        create<%= name %>Dto.<%= property %>.id,
      );
      if (!<%= property %>Object) {
        throw new UnprocessableEntityException({
          status: HttpStatus.UNPROCESSABLE_ENTITY,
          errors: {
            <%= property %>: 'notExists',
          },
        });
      }
      const <%= property %> = <%= property %>Object;
    <% } else if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>
      const <%= property %>Objects = await this.<%= h.inflection.camelize(type, true) %>Service.findByIds(
        create<%= name %>Dto.<%= property %>.map((entity) => entity.id),
      );
      if (<%= property %>Objects.length !== create<%= name %>Dto.<%= property %>.length) {
        throw new UnprocessableEntityException({
          status: HttpStatus.UNPROCESSABLE_ENTITY,
          errors: {
            <%= property %>: 'notExists',
          },
        });
      }
      const <%= property %> = <%= property %>Objects;
    <% } -%>
  <% } -%>
<% } else { -%>
  <% if (kind === 'reference' || kind === 'duplication') { -%>
    <% if (referenceType === 'oneToOne' || referenceType === 'manyToOne') { -%>
      let <%= property %>: <%= type %><% if (type === 'File') { -%>Type<% } -%> <% if (isNullable) { -%> | null<% } -%> | undefined = undefined;

      if (create<%= name %>Dto.<%= property %>) {
        const <%= property %>Object = await this.<%= h.inflection.camelize(type, true) %>Service.findById(
          create<%= name %>Dto.<%= property %>.id,
        );
        if (!<%= property %>Object) {
          throw new UnprocessableEntityException({
            status: HttpStatus.UNPROCESSABLE_ENTITY,
            errors: {
              <%= property %>: 'notExists',
            },
          });
        }
        <%= property %> = <%= property %>Object;
      }
      <% if (isNullable) { -%>
        else if (create<%= name %>Dto.<%= property %> === null) {
          <%= property %> = null;
        }
      <% } -%>
    <% } else if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>
      let <%= property %>: <%= type %><% if (type === 'File') { -%>Type<% } -%>[] <% if (isNullable) { -%> | null<% } -%> | undefined = undefined;

      if (create<%= name %>Dto.<%= property %>) {
        const <%= property %>Objects = await this.<%= h.inflection.camelize(type, true) %>Service.findByIds(
          create<%= name %>Dto.<%= property %>.map((entity) => entity.id),
        );
        if (<%= property %>Objects.length !== create<%= name %>Dto.<%= property %>.length) {
          throw new UnprocessableEntityException({
            status: HttpStatus.UNPROCESSABLE_ENTITY,
            errors: {
              <%= property %>: 'notExists',
            },
          });
        }
        <%= property %> = <%= property %>Objects;
      }
      <% if (isNullable) { -%>
        else if (create<%= name %>Dto.<%= property %> === null) {
          <%= property %> = null;
        }
      <% } -%>
    <% } -%>
  <% } -%>
<% } -%>

================
File: backend/.hygen/property/add-to-relational/service-import-http-code.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service.ts
at_line: 0
skip_if: HttpStatus,
---
<% if (kind === 'reference' || kind === 'duplication') { -%>
  import { HttpStatus, UnprocessableEntityException } from '@nestjs/common';
<% } -%>

================
File: backend/.hygen/property/add-to-relational/service-import-type-domain.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service.ts
at_line: 0
skip_if: import { <%= type %><% if (type === 'File') { -%>Type<% } -%>
---
<% if (kind === 'reference' || kind === 'duplication') { -%>
  import { <%= type %><% if (type === 'File') { -%>Type<% } -%> } from '../<%= h.inflection.transform(type, ['pluralize', 'underscore', 'dasherize']) %>/domain/<%= h.inflection.transform(type, ['underscore', 'dasherize']) %>';
<% } -%>

================
File: backend/.hygen/property/add-to-relational/service-import.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service.ts
at_line: 0
skip_if: import { <%= h.inflection.transform(type, ['pluralize']) %>Service
---
<% if (kind === 'reference' || kind === 'duplication') { -%>import { <%= h.inflection.transform(type, ['pluralize']) %>Service } from '../<%= h.inflection.transform(type, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(type, ['pluralize', 'underscore', 'dasherize']) %>.service';<% } -%>

================
File: backend/.hygen/property/add-to-relational/service-inject.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service.ts
after: constructor
skip_if: private readonly <%= h.inflection.camelize(type, true) %>Service
---
<% if (kind === 'reference' || kind === 'duplication') { -%>
  private readonly <%= h.inflection.camelize(type, true) %>Service: <%= h.inflection.transform(type, ['pluralize']) %>Service,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/service-update-payload.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service.ts
after: \<updating\-property\-payload \/\>
---
<% if (kind === 'reference' || kind === 'duplication') { -%>
  <%= property %>,
<% } else { -%>
  <%= property %>: update<%= name %>Dto.<%= property %>,
<% } -%>

================
File: backend/.hygen/property/add-to-relational/service-update.ejs.t
================
---
inject: true
to: src/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>.service.ts
after: \<updating\-property \/\>
---
<% if (kind === 'reference' || kind === 'duplication') { -%>
  <% if (referenceType === 'oneToOne' || referenceType === 'manyToOne') { -%>
    let <%= property %>: <%= type %><% if (type === 'File') { -%>Type<% } -%> <% if (isNullable) { -%> | null<% } -%> | undefined = undefined;

    if (update<%= name %>Dto.<%= property %>) {
      const <%= property %>Object = await this.<%= h.inflection.camelize(type, true) %>Service.findById(
        update<%= name %>Dto.<%= property %>.id,
      );
      if (!<%= property %>Object) {
        throw new UnprocessableEntityException({
          status: HttpStatus.UNPROCESSABLE_ENTITY,
          errors: {
            <%= property %>: 'notExists',
          },
        });
      }
      <%= property %> = <%= property %>Object;
    }
    <% if (isNullable) { -%>
      else if (update<%= name %>Dto.<%= property %> === null) {
        <%= property %> = null;
      }
    <% } -%>
  <% } else if (referenceType === 'oneToMany' || referenceType === 'manyToMany') { -%>
    let <%= property %>: <%= type %><% if (type === 'File') { -%>Type<% } -%>[] <% if (isNullable) { -%> | null<% } -%> | undefined = undefined;

    if (update<%= name %>Dto.<%= property %>) {
      const <%= property %>Objects = await this.<%= h.inflection.camelize(type, true) %>Service.findByIds(
        update<%= name %>Dto.<%= property %>.map((entity) => entity.id),
      );
      if (<%= property %>Objects.length !== update<%= name %>Dto.<%= property %>.length) {
        throw new UnprocessableEntityException({
          status: HttpStatus.UNPROCESSABLE_ENTITY,
          errors: {
            <%= property %>: 'notExists',
          },
        });
      }
      <%= property %> = <%= property %>Objects;
    }
    <% if (isNullable) { -%>
      else if (update<%= name %>Dto.<%= property %> === null) {
        <%= property %> = null;
      }
    <% } -%>
  <% } -%>
<% } -%>

================
File: backend/.hygen/seeds/create-relational/module.ejs.t
================
---
to: src/database/seeds/relational/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>-seed.module.ts
---
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { <%= name %>Entity } from '../../../../<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity';
import { <%= name %>SeedService } from './<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>-seed.service';

@Module({
  imports: [TypeOrmModule.forFeature([<%= name %>Entity])],
  providers: [<%= name %>SeedService],
  exports: [<%= name %>SeedService],
})
export class <%= name %>SeedModule {}

================
File: backend/.hygen/seeds/create-relational/run-seed-import.ejs.t
================
---
inject: true
to: src/database/seeds/relational/run-seed.ts
after: \@nestjs\/core
---
import { <%= name %>SeedService } from './<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>-seed.service';

================
File: backend/.hygen/seeds/create-relational/run-seed-service.ejs.t
================
---
inject: true
to: src/database/seeds/relational/run-seed.ts
before: close
---
  await app.get(<%= name %>SeedService).run();

================
File: backend/.hygen/seeds/create-relational/seed-module-import.ejs.t
================
---
inject: true
to: src/database/seeds/relational/seed.module.ts
before: \@Module
---
import { <%= name %>SeedModule } from './<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>-seed.module';

================
File: backend/.hygen/seeds/create-relational/seed-module.ejs.t
================
---
inject: true
to: src/database/seeds/relational/seed.module.ts
after: imports
---
    <%= name %>SeedModule,

================
File: backend/.hygen/seeds/create-relational/service.ejs.t
================
---
to: src/database/seeds/relational/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>-seed.service.ts
---
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { <%= name %>Entity } from '../../../../<%= h.inflection.transform(name, ['pluralize', 'underscore', 'dasherize']) %>/infrastructure/persistence/relational/entities/<%= h.inflection.transform(name, ['underscore', 'dasherize']) %>.entity';
import { Repository } from 'typeorm';

@Injectable()
export class <%= name %>SeedService {
  constructor(
    @InjectRepository(<%= name %>Entity)
    private repository: Repository<<%= name %>Entity>,
  ) {}

  async run() {
    const count = await this.repository.count();

    if (count === 0) {
      await this.repository.save(this.repository.create({}));
    }
  }
}

================
File: backend/.nvmrc
================
22.14.0

================
File: backend/.prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all",
  "endOfLine": "lf"
}

================
File: backend/commitlint.config.js
================
module.exports = {
  extends: ['@commitlint/config-conventional'],
};

================
File: backend/docker-compose.relational.ci.yaml
================
services:
  postgres:
    image: postgres:17.0-alpine
    expose:
      - 5432
    environment:
      POSTGRES_USER: ${DATABASE_USERNAME}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_DB: ${DATABASE_NAME}
  maildev:
    build:
      context: .
      dockerfile: maildev.Dockerfile
    expose:
      - 1080
      - 1025
  api:
    build:
      context: .
      dockerfile: relational.e2e.Dockerfile
    env_file:
      - env-example-relational

================
File: backend/docker-compose.relational.test.yaml
================
services:
  postgres:
    image: postgres:17.0-alpine
    expose:
      - 5432
    environment:
      POSTGRES_USER: ${DATABASE_USERNAME}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_DB: ${DATABASE_NAME}
  maildev:
    build:
      context: .
      dockerfile: maildev.Dockerfile
    expose:
      - 1080
      - 1025
  api:
    build:
      context: .
      dockerfile: relational.test.Dockerfile
    env_file:
      - env-example-relational
    volumes:
      - ./src:/usr/src/app/src
      - ./test:/usr/src/app/test

================
File: backend/docker-compose.yaml
================
services:
  postgres:
    image: postgres:17.0-alpine
    ports:
      - ${DATABASE_PORT}:5432
    volumes:
      - boilerplate-db:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: ${DATABASE_USERNAME}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_DB: ${DATABASE_NAME}
  maildev:
    build:
      context: .
      dockerfile: maildev.Dockerfile
    ports:
      - ${MAIL_CLIENT_PORT}:1080
      - ${MAIL_PORT}:1025
  adminer:
    image: adminer
    restart: always
    ports:
      - 8080:8080
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - ${APP_PORT}:${APP_PORT}
volumes:
  boilerplate-db:

================
File: backend/Dockerfile
================
FROM node:22.14.0-alpine

RUN apk add --no-cache bash
RUN npm i -g @nestjs/cli typescript ts-node

COPY package*.json /tmp/app/
RUN cd /tmp/app && npm install

COPY . /usr/src/app
RUN cp -a /tmp/app/node_modules /usr/src/app
COPY ./wait-for-it.sh /opt/wait-for-it.sh
RUN chmod +x /opt/wait-for-it.sh
COPY ./startup.relational.dev.sh /opt/startup.relational.dev.sh
RUN chmod +x /opt/startup.relational.dev.sh
RUN sed -i 's/\r//g' /opt/wait-for-it.sh
RUN sed -i 's/\r//g' /opt/startup.relational.dev.sh

WORKDIR /usr/src/app
RUN if [ ! -f .env ]; then cp env-example-relational .env; fi
RUN npm run build

CMD ["/opt/startup.relational.dev.sh"]

================
File: backend/docs/architecture.md
================
# Architecture

---

## Table of Contents <!-- omit in toc -->

- [Hexagonal Architecture](#hexagonal-architecture)
- [Motivation](#motivation)
- [Description of the module structure](#description-of-the-module-structure)
- [Recommendations](#recommendations)
  - [Repository](#repository)
- [FAQ](#faq)
  - [Is there a way to generate a new resource (controller, service, DTOs, etc) with Hexagonal Architecture?](#is-there-a-way-to-generate-a-new-resource-controller-service-dtos-etc-with-hexagonal-architecture)
- [Links](#links)

---

## Hexagonal Architecture

NestJS Boilerplate is based on [Hexagonal Architecture](<https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)>). This architecture is also known as Ports and Adapters.

![Hexagonal Architecture Diagram](https://github.com/brocoders/nestjs-boilerplate/assets/6001723/6a6a763e-d1c9-43cc-910a-617cda3a71db)

## Motivation

The main reason for using Hexagonal Architecture is to separate the business logic from the infrastructure. This separation allows us to easily change the database, the way of uploading files, or any other infrastructure without changing the business logic.

## Description of the module structure

```txt
.
├── domain
│   └── [DOMAIN_ENTITY].ts
├── dto
│   ├── create.dto.ts
│   ├── find-all.dto.ts
│   └── update.dto.ts
├── infrastructure
│   └── persistence
│       ├── document
│       │   ├── document-persistence.module.ts
│       │   ├── entities
│       │   │   └── [SCHEMA].ts
│       │   ├── mappers
│       │   │   └── [MAPPER].ts
│       │   └── repositories
│       │       └── [ADAPTER].repository.ts
│       ├── relational
│       │   ├── entities
│       │   │   └── [ENTITY].ts
│       │   ├── mappers
│       │   │   └── [MAPPER].ts
│       │   ├── relational-persistence.module.ts
│       │   └── repositories
│       │       └── [ADAPTER].repository.ts
│       └── [PORT].repository.ts
├── controller.ts
├── module.ts
└── service.ts
```

`[DOMAIN ENTITY].ts` represents an entity used in the business logic. Domain entity has no dependencies on the database or any other infrastructure.

`[ENTITY].ts` represents the **database structure**. It is used in the relational database (PostgreSQL).

`[MAPPER].ts` is a mapper that converts **database entity** to **domain entity** and vice versa.

`[PORT].repository.ts` is a repository **port** that defines the methods for interacting with the database.

`[ADAPTER].repository.ts` is a repository that implements the `[PORT].repository.ts`. It is used to interact with the database.

`infrastructure` folder - contains all the infrastructure-related components such as `persistence`, `uploader`, `senders`, etc.

Each component has `port` and `adapters`. `Port` is interface that define the methods for interacting with the infrastructure. `Adapters` are implementations of the `port`.

## Recommendations

### Repository

Don't try to create universal methods in the repository because they are difficult to extend during the project's life. Instead of this create methods with a single responsibility.

```typescript
// ❌
export class UsersRelationalRepository implements UserRepository {
  async find(condition: UniversalConditionInterface): Promise<User> {
    // ...
  }
}

// ✅
export class UsersRelationalRepository implements UserRepository {
  async findByEmail(email: string): Promise<User> {
    // ...
  }

  async findByRoles(roles: string[]): Promise<User> {
    // ...
  }

  async findByIds(ids: string[]): Promise<User> {
    // ...
  }
}
```

---

## FAQ

### Is there a way to generate a new resource (controller, service, DTOs, etc) with Hexagonal Architecture?

Yes, you can use the [CLI](cli.md) to generate a new resource with Hexagonal Architecture.

---

## Links

- [Dependency Inversion Principle](https://trilon.io/blog/dependency-inversion-principle) with NestJS.

---

Previous: [Installing and Running](installing-and-running.md)

Next: [Command Line Interface](cli.md)

================
File: backend/docs/auth.md
================
# Auth

## Table of Contents <!-- omit in toc -->

- [General info](#general-info)
  - [Auth via email flow](#auth-via-email-flow)
- [Configure Auth](#configure-auth)
- [About JWT strategy](#about-jwt-strategy)
- [Refresh token flow](#refresh-token-flow)
  - [Video example](#video-example)
  - [Support login for multiple devices / Sessions](#support-login-for-multiple-devices--sessions)
- [Logout](#logout)
- [Q\&A](#qa)
  - [After `POST /api/v1/auth/logout` or removing session from the database, the user can still make requests with an `access token` for some time. Why?](#after-post-apiv1authlogout-or-removing-session-from-the-database-the-user-can-still-make-requests-with-an-access-token-for-some-time-why)

---

## General info

### Auth via email flow

By default boilerplate used sign in and sign up via email and password.

```mermaid
sequenceDiagram
    participant A as Fronted App (Web, Mobile, Desktop)
    participant B as Backend App

    A->>B: 1. Sign up via email and password
    A->>B: 2. Sign in via email and password
    B->>A: 3. Get a JWT token
    A->>B: 4. Make any requests using a JWT token
```

<https://user-images.githubusercontent.com/6001723/224566194-1c1f4e98-5691-4703-b30e-92f99ec5d929.mp4>

1. Make any requests using a JWT token

---

## Configure Auth

1. Generate secret keys for `access token` and `refresh token`:

   ```bash
   node -e "console.log('\nAUTH_JWT_SECRET=' + require('crypto').randomBytes(256).toString('base64') + '\n\nAUTH_REFRESH_SECRET=' + require('crypto').randomBytes(256).toString('base64') + '\n\nAUTH_FORGOT_SECRET=' + require('crypto').randomBytes(256).toString('base64') + '\n\nAUTH_CONFIRM_EMAIL_SECRET=' + require('crypto').randomBytes(256).toString('base64'));"
   ```

1. Go to `/.env` and replace `AUTH_JWT_SECRET` and `AUTH_REFRESH_SECRET` with output from step 1.

   ```text
   AUTH_JWT_SECRET=HERE_SECRET_KEY_FROM_STEP_1
   AUTH_REFRESH_SECRET=HERE_SECRET_KEY_FROM_STEP_1
   ```

## About JWT strategy

In the `validate` method of the `src/auth/strategies/jwt.strategy.ts` file, you can see that we do not check if the user exists in the database because it is redundant, it may lose the benefits of the JWT approach and can affect the application performance.

To better understand how JWT works, watch the video explanation https://www.youtube.com/watch?v=Y2H3DXDeS3Q and read this article https://jwt.io/introduction/

```typescript
// src/auth/strategies/jwt.strategy.ts

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  // ...

  public validate(payload) {
    if (!payload.id) {
      throw new UnauthorizedException();
    }

    return payload;
  }
}
```

> If you need to get full user information, get it in services.

## Refresh token flow

1. On sign in (`POST /api/v1/auth/email/login`) you will receive `token`, `tokenExpires` and `refreshToken` in response.
1. On each regular request you need to send `token` in `Authorization` header.
1. If `token` is expired (check with `tokenExpires` property on client app) you need to send `refreshToken` to `POST /api/v1/auth/refresh` in `Authorization` header to refresh `token`. You will receive new `token`, `tokenExpires` and `refreshToken` in response.

### Video example

https://github.com/brocoders/nestjs-boilerplate/assets/6001723/f6fdcc89-5ec6-472b-a6fc-d24178ad1bbb

### Support login for multiple devices / Sessions

Boilerplate supports login for multiple devices with a Refresh Token flow. This is possible due to `sessions`. When a user logs in, a new session is created and stored in the database. The session record contains `sessionId (id)`, `userId`, and `hash`.

On each `POST /api/v1/auth/refresh` request we check `hash` from the database with `hash` from the Refresh Token. If they are equal, we return new `token`, `tokenExpires`, and `refreshToken`. Then we update `hash` in the database to disallow the use of the previous Refresh Token.

## Logout

1. Call following endpoint:

   ```text
   POST /api/v1/auth/logout
   ```

2. Remove `access token` and `refresh token` from your client app (cookies, localStorage, etc).

## Q&A

### After `POST /api/v1/auth/logout` or removing session from the database, the user can still make requests with an `access token` for some time. Why?

It's because we use `JWT`. `JWTs` are stateless, so we can't revoke them, but don't worry, this is the correct behavior and the access token will expire after the time specified in `AUTH_JWT_TOKEN_EXPIRES_IN` (the default value is 15 minutes). If you still need to revoke `JWT` tokens immediately, you can check if a session exists in [jwt.strategy.ts](https://github.com/brocoders/nestjs-boilerplate/blob/2896589f52d2df025f12069ba82ba4fac1db8ebd/src/auth/strategies/jwt.strategy.ts#L20-L26) on each request. However, it's not recommended because it can affect the application's performance.

---

Previous: [Working with database](database.md)

Next: [Serialization](serialization.md)

================
File: backend/docs/cli.md
================
# Command Line Interface (CLI)

---

## Table of Contents <!-- omit in toc -->

- [Generate resource](#generate-resource)
  - [For PostgreSQL + TypeORM](#for-postgresql--typeorm)
    - [Video guideline](#video-guideline)
- [Add property to resource](#add-property-to-resource)
  - [Property for PostgreSQL + TypeORM](#property-for-postgresql--typeorm)
    - [Video guideline for adding properties](#video-guideline-for-adding-properties)

---

## Generate resource

Generate resource with the following command:

### For PostgreSQL + TypeORM

```bash
npm run generate:resource:relational -- --name ResourceName
```

Example:

```bash
npm run generate:resource:relational -- --name Category
```

#### Video guideline

<https://github.com/user-attachments/assets/f7f91a7d-f9ff-4653-a78a-152ac5e7a95d>

## Add property to resource

### Property for PostgreSQL + TypeORM

```bash
npm run add:property:to-relational
```

#### Video guideline for adding properties

<https://github.com/user-attachments/assets/95b9d70a-70cf-442a-b8bf-a73d32810e0c>

---

Previous: [Architecture](architecture.md)

Next: [Working with database](database.md)

================
File: backend/docs/database.md
================
# Work with database

---

## Table of Contents <!-- omit in toc -->

- [Working with database schema (TypeORM)](#working-with-database-schema-typeorm)
  - [Generate migration](#generate-migration)
  - [Run migration](#run-migration)
  - [Revert migration](#revert-migration)
  - [Drop all tables in database](#drop-all-tables-in-database)
- [Seeding (TypeORM)](#seeding-typeorm)
  - [Creating seeds](#creating-seeds)
  - [Run seed](#run-seed)
  - [Factory and Faker](#factory-and-faker)
- [Performance optimization](#performance-optimization)
  - [Indexes and Foreign Keys](#indexes-and-foreign-keys)
  - [Max connections](#max-connections)

---

## Working with database schema (TypeORM)

### Generate migration

1. Create entity file with extension `.entity.ts`. For example `post.entity.ts`:

   ```ts
   // /src/posts/infrastructure/persistence/relational/entities/post.entity.ts

   import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';
   import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';

   @Entity()
   export class Post extends EntityRelationalHelper {
     @PrimaryGeneratedColumn()
     id: number;

     @Column()
     title: string;

     @Column()
     body: string;

     // Here any fields that you need
   }
   ```

1. Next, generate migration file:

   ```bash
   npm run migration:generate -- src/database/migrations/CreateInitialTables
   ```

1. Apply this migration to database via [npm run migration:run](#run-migration).

### Run migration

```bash
npm run migration:run
```

### Revert migration

```bash
npm run migration:revert
```

### Drop all tables in database

```bash
npm run schema:drop
```

## Seeding (TypeORM)

### Creating seeds

1. Create seed file with `npm run seed:create:relational -- --name Post`. Where `Post` is name of entity.
1. Go to `src/database/seeds/relational/post/post-seed.service.ts`.
1. In `run` method extend your logic.
1. Run [npm run seed:run](#run-seed)

### Run seed

```bash
npm run seed:run:relational
```

### Factory and Faker

1. Install faker:

   ```bash
   npm i --save-dev @faker-js/faker
   ```

1. Create `src/database/seeds/relational/user/user.factory.ts`:

   ```ts
   import { faker } from '@faker-js/faker';
   import { RoleEnum } from '../../../../roles/roles.enum';
   import { StatusEnum } from '../../../../statuses/statuses.enum';
   import { Injectable } from '@nestjs/common';
   import { InjectRepository } from '@nestjs/typeorm';
   import { Repository } from 'typeorm';
   import { RoleEntity } from '../../../../roles/infrastructure/persistence/relational/entities/role.entity';
   import { UserEntity } from '../../../../users/infrastructure/persistence/relational/entities/user.entity';
   import { StatusEntity } from '../../../../statuses/infrastructure/persistence/relational/entities/status.entity';

   @Injectable()
   export class UserFactory {
     constructor(
       @InjectRepository(UserEntity)
       private repositoryUser: Repository<UserEntity>,
       @InjectRepository(RoleEntity)
       private repositoryRole: Repository<RoleEntity>,
       @InjectRepository(StatusEntity)
       private repositoryStatus: Repository<StatusEntity>,
     ) {}

     createRandomUser() {
       // Need for saving "this" context
       return () => {
         return this.repositoryUser.create({
           firstName: faker.person.firstName(),
           lastName: faker.person.lastName(),
           email: faker.internet.email(),
           password: faker.internet.password(),
           role: this.repositoryRole.create({
             id: RoleEnum.user,
             name: 'User',
           }),
           status: this.repositoryStatus.create({
             id: StatusEnum.active,
             name: 'Active',
           }),
         });
       };
     }
   }
   ```

1. Make changes in `src/database/seeds/relational/user/user-seed.service.ts`:

   ```ts
   // Some code here...
   import { UserFactory } from './user.factory';
   import { faker } from '@faker-js/faker';

   @Injectable()
   export class UserSeedService {
     constructor(
       // Some code here...
       private userFactory: UserFactory,
     ) {}

     async run() {
       // Some code here...

       await this.repository.save(
         faker.helpers.multiple(this.userFactory.createRandomUser(), {
           count: 5,
         }),
       );
     }
   }
   ```

1. Make changes in `src/database/seeds/relational/user/user-seed.module.ts`:

   ```ts
   import { Module } from '@nestjs/common';
   import { TypeOrmModule } from '@nestjs/typeorm';

   import { UserSeedService } from './user-seed.service';
   import { UserFactory } from './user.factory';

   import { UserEntity } from '../../../../users/infrastructure/persistence/relational/entities/user.entity';
   import { RoleEntity } from '../../../../roles/infrastructure/persistence/relational/entities/role.entity';
   import { StatusEntity } from '../../../../statuses/infrastructure/persistence/relational/entities/status.entity';

   @Module({
     imports: [TypeOrmModule.forFeature([UserEntity, Role, Status])],
     providers: [UserSeedService, UserFactory],
     exports: [UserSeedService, UserFactory],
   })
   export class UserSeedModule {}
   ```

1. Run seed:

   ```bash
   npm run seed:run
   ```

## Performance optimization

### Indexes and Foreign Keys

Don't forget to create `indexes` on the Foreign Keys (FK) columns (if needed), because by default PostgreSQL [does not automatically add indexes to FK](https://stackoverflow.com/a/970605/18140714).

### Max connections

Set the optimal number of [max connections](https://node-postgres.com/apis/pool) to database for your application in `/.env`:

```txt
DATABASE_MAX_CONNECTIONS=100
```

You can think of this parameter as how many concurrent database connections your application can handle.

---

Previous: [Command Line Interface](cli.md)

Next: [Auth](auth.md)

================
File: backend/docs/file-uploading.md
================
# File uploading

---

## Table of Contents <!-- omit in toc -->

- [Drivers support](#drivers-support)
- [Uploading and attach file flow for `local` driver](#uploading-and-attach-file-flow-for-local-driver)
  - [An example of uploading an avatar to a user profile (local)](#an-example-of-uploading-an-avatar-to-a-user-profile-local)
  - [Video example](#video-example)
- [Uploading and attach file flow for `s3` driver](#uploading-and-attach-file-flow-for-s3-driver)
  - [Configuration for `s3` driver](#configuration-for-s3-driver)
  - [An example of uploading an avatar to a user profile (S3)](#an-example-of-uploading-an-avatar-to-a-user-profile-s3)
- [Uploading and attach file flow for `s3-presigned` driver](#uploading-and-attach-file-flow-for-s3-presigned-driver)
  - [Configuration for `s3-presigned` driver](#configuration-for-s3-presigned-driver)
  - [An example of uploading an avatar to a user profile (S3 Presigned URL)](#an-example-of-uploading-an-avatar-to-a-user-profile-s3-presigned-url)
- [How to delete files?](#how-to-delete-files)

---

## Drivers support

Out-of-box boilerplate supports the following drivers: `local`, `s3`, and `s3-presigned`. You can set it in the `.env` file, variable `FILE_DRIVER`. If you want to use another service for storing files, you can extend it.

> For production we recommend using the "s3-presigned" driver to offload your server.

---

## Uploading and attach file flow for `local` driver

Endpoint `/api/v1/files/upload` is used for uploading files, which returns `File` entity with `id` and `path`. After receiving `File` entity you can attach this to another entity.

### An example of uploading an avatar to a user profile (local)

```mermaid
sequenceDiagram
    participant A as Fronted App
    participant B as Backend App

    A->>B: Upload file via POST /api/v1/files/upload
    B->>A: Receive File entity with "id" and "path" properties
    note left of A: Attach File entity to User entity
    A->>B: Update user via PATCH /api/v1/auth/me
```

### Video example

<https://user-images.githubusercontent.com/6001723/224558636-d22480e4-f70a-4789-b6fc-6ea343685dc7.mp4>

## Uploading and attach file flow for `s3` driver

Endpoint `/api/v1/files/upload` is used for uploading files, which returns `File` entity with `id` and `path`. After receiving `File` entity you can attach this to another entity.

### Configuration for `s3` driver

1. Open https://s3.console.aws.amazon.com/s3/buckets
1. Click "Create bucket"
1. Create bucket (for example, `your-unique-bucket-name`)
1. Open your bucket
1. Click "Permissions" tab
1. Find "Cross-origin resource sharing (CORS)" section
1. Click "Edit"
1. Paste the following configuration

    ```json
    [
      {
        "AllowedHeaders": ["*"],
        "AllowedMethods": ["GET"],
        "AllowedOrigins": ["*"],
        "ExposeHeaders": []
      }
    ]
    ```

1. Click "Save changes"
1. Update `.env` file with the following variables:

    ```dotenv
    FILE_DRIVER=s3
    ACCESS_KEY_ID=YOUR_ACCESS_KEY_ID
    SECRET_ACCESS_KEY=YOUR_SECRET_ACCESS_KEY
    AWS_S3_REGION=YOUR_AWS_S3_REGION
    AWS_DEFAULT_S3_BUCKET=YOUR_AWS_DEFAULT_S3_BUCKET
    ```

### An example of uploading an avatar to a user profile (S3)

```mermaid
sequenceDiagram
    participant A as Fronted App
    participant B as Backend App
    participant C as AWS S3

    A->>B: Upload file via POST /api/v1/files/upload
    B->>C: Upload file to S3
    B->>A: Receive File entity with "id" and "path" properties
    note left of A: Attach File entity to User entity
    A->>B: Update user via PATCH /api/v1/auth/me
```

## Uploading and attach file flow for `s3-presigned` driver

Endpoint `/api/v1/files/upload` is used for uploading files. In this case `/api/v1/files/upload` receives only `fileName` property (without binary file), and returns the `presigned URL` and `File` entity with `id` and `path`. After receiving the `presigned URL` and `File` entity you need to upload your file to the `presigned URL` and after that attach `File` to another entity.

### Configuration for `s3-presigned` driver

1. Open https://s3.console.aws.amazon.com/s3/buckets
1. Click "Create bucket"
1. Create bucket (for example, `your-unique-bucket-name`)
1. Open your bucket
1. Click "Permissions" tab
1. Find "Cross-origin resource sharing (CORS)" section
1. Click "Edit"
1. Paste the following configuration

    ```json
    [
      {
        "AllowedHeaders": ["*"],
        "AllowedMethods": ["GET", "PUT"],
        "AllowedOrigins": ["*"],
        "ExposeHeaders": []
      }
    ]
    ```

   For production we recommend to use more strict configuration:

   ```json
   [
     {
       "AllowedHeaders": ["*"],
       "AllowedMethods": ["PUT"],
       "AllowedOrigins": ["https://your-domain.com"],
       "ExposeHeaders": []
     },
      {
        "AllowedHeaders": ["*"],
        "AllowedMethods": ["GET"],
        "AllowedOrigins": ["*"],
        "ExposeHeaders": []
      }
   ]
   ```

1. Click "Save changes"
1. Update `.env` file with the following variables:

    ```dotenv
    FILE_DRIVER=s3-presigned
    ACCESS_KEY_ID=YOUR_ACCESS_KEY_ID
    SECRET_ACCESS_KEY=YOUR_SECRET_ACCESS_KEY
    AWS_S3_REGION=YOUR_AWS_S3_REGION
    AWS_DEFAULT_S3_BUCKET=YOUR_AWS_DEFAULT_S3_BUCKET
    ```

### An example of uploading an avatar to a user profile (S3 Presigned URL)

```mermaid
sequenceDiagram
    participant C as AWS S3
    participant A as Fronted App
    
    participant B as Backend App

    A->>B: Send file name (not binary file) via POST /api/v1/files/upload
    note right of B: Generate presigned URL
    B->>A: Receive presigned URL and File entity with "id" and "path" properties
    A->>C: Upload file to S3 via presigned URL
    note right of A: Attach File entity to User entity
    A->>B: Update user via PATCH /api/v1/auth/me
```

## How to delete files?

We prefer not to delete files, as this may have negative experience during restoring data. Also for this reason we also use [Soft-Delete](https://orkhan.gitbook.io/typeorm/docs/delete-query-builder#soft-delete) approach in database. However, if you need to delete files you can create your own handler, cronjob, etc.

---

Previous: [Serialization](serialization.md)

Next: [Tests](tests.md)

================
File: backend/docs/introduction.md
================
# Introduction

## Online demo

Demo: <https://nestjs-boilerplate-test.herokuapp.com/docs>

Frontend (React, Next.js): <https://github.com/brocoders/extensive-react-boilerplate>

<https://github.com/user-attachments/assets/a66f114a-c714-4036-8eeb-20cbf04ae985>

## Features

- [x] Database. Support [TypeORM](https://www.npmjs.com/package/typeorm)
- [x] Seeding.
- [x] Config Service ([@nestjs/config](https://www.npmjs.com/package/@nestjs/config)).
- [x] Mailing ([nodemailer](https://www.npmjs.com/package/nodemailer)).
- [x] Sign in and sign up via email.
- [x] Admin and User roles.
- [x] Internationalization/Translations (I18N) ([nestjs-i18n](https://www.npmjs.com/package/nestjs-i18n)).
- [x] File uploads. Support local and Amazon S3 drivers.
- [x] Swagger.
- [x] Support E2E and units tests.
- [x] Docker.
- [x] CI (Github Actions).

---

Previous: [Main](readme.md)

Next: [Installing and Running](installing-and-running.md)

================
File: backend/docs/serialization.md
================
# Serialization

For serialization boilerplate use [class-transformer](https://www.npmjs.com/package/class-transformer) and global interceptor `ClassSerializerInterceptor`.

---

## Table of Contents <!-- omit in toc -->

- [Hide private property](#hide-private-property)
- [Show private property for admins](#show-private-property-for-admins)

---

## Hide private property

If you need to hide some property in the entity you can use `@Exclude({ toPlainOnly: true })` on the column.

```ts
// /src/users/entities/user.entity.ts

import { Exclude } from 'class-transformer';

@Entity()
export class User extends EntityRelationalHelper {
  // Some code here...

  @Column({ nullable: true })
  @Exclude({ toPlainOnly: true })
  password: string;

  // Some code here...
}
```

## Show private property for admins

1. Create a controller that returns data only for admin and add `@SerializeOptions({ groups: ['admin'] })` to method:

   ```ts
   // /src/users/users.controller.ts

   // Some code here...

   @ApiBearerAuth()
   @Roles(RoleEnum.admin)
   @UseGuards(AuthGuard('jwt'), RolesGuard)
   @Controller({
     path: 'users',
     version: '1',
   })
   export class UsersController {
     constructor(private readonly usersService: UsersService) {}

     // Some code here...

     @SerializeOptions({
       groups: ['admin'],
     })
     @Get(':id')
     @HttpCode(HttpStatus.OK)
     findOne(@Param('id') id: string) {
       return this.usersService.findOne({ id: +id });
     }

     // Some code here...
   }
   ```

1. In the entity add `@Expose({ groups: ['admin'] })` to the column that should be exposed for admin:

   ```ts
   // /src/users/entities/user.entity.ts

   // Some code here...

   import { Expose } from 'class-transformer';

   @Entity()
   export class User extends EntityRelationalHelper {
     // Some code here...

     @Column({ unique: true, nullable: true })
     @Expose({ groups: ['admin'] })
     email: string | null;

     // Some code here...
   }
   ```

---

Previous: [Auth](auth.md)

Next: [File uploading](file-uploading.md)

================
File: backend/eslint.config.mjs
================
import tsEslintPlugin from '@typescript-eslint/eslint-plugin';
import globals from 'globals';
import tsParser from '@typescript-eslint/parser';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import js from '@eslint/js';
import { FlatCompat } from '@eslint/eslintrc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all,
});

export default [
  ...compat.extends(
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ),
  {
    plugins: {
      '@typescript-eslint': tsEslintPlugin,
    },
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      parser: tsParser,
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        project: 'tsconfig.json',
        tsconfigRootDir: __dirname,
      },
    },
    rules: {
      '@typescript-eslint/interface-name-prefix': 'off',
      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
      'no-unused-vars': 'off',
      '@typescript-eslint/no-unused-vars': ['error'],
      'require-await': 'off',
      '@typescript-eslint/require-await': 'error',
      '@typescript-eslint/no-floating-promises': 'error',
      'no-restricted-syntax': [
        'error',
        {
          selector:
            'CallExpression[callee.object.name=configService][callee.property.name=/^(get|getOrThrow)$/]:not(:has([arguments.1] Property[key.name=infer][value.value=true])), CallExpression[callee.object.property.name=configService][callee.property.name=/^(get|getOrThrow)$/]:not(:has([arguments.1] Property[key.name=infer][value.value=true]))',
          message:
            'Add "{ infer: true }" to configService.get() for correct typechecking. Example: configService.get("database.port", { infer: true })',
        },
        {
          selector:
            'CallExpression[callee.name=it][arguments.0.value!=/^should/]',
          message: '"it" should start with "should"',
        },
      ],
    },
  },
];

================
File: backend/LICENSE
================
MIT License

Copyright (c) 2023 Brocoders

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: backend/maildev.Dockerfile
================
FROM node:22.14.0-alpine

RUN npm i -g maildev@2.0.5

CMD maildev

================
File: backend/nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "assets": [{ "include": "i18n/**/*", "watchAssets": true }]
  }
}

================
File: backend/Procfile
================
web: npm run start:prod
release: echo '' > .env && npm run migration:run && npm run seed:run:relational

================
File: backend/relational.e2e.Dockerfile
================
FROM node:22.14.0-alpine

RUN apk add --no-cache bash
RUN npm i -g @nestjs/cli typescript ts-node

COPY package*.json /tmp/app/
RUN cd /tmp/app && npm install

COPY . /usr/src/app
RUN cp -a /tmp/app/node_modules /usr/src/app
COPY ./wait-for-it.sh /opt/wait-for-it.sh
RUN chmod +x /opt/wait-for-it.sh
COPY ./startup.relational.ci.sh /opt/startup.relational.ci.sh
RUN chmod +x /opt/startup.relational.ci.sh
RUN sed -i 's/\r//g' /opt/wait-for-it.sh
RUN sed -i 's/\r//g' /opt/startup.relational.ci.sh

WORKDIR /usr/src/app
RUN echo "" > .env
RUN npm run build

CMD ["/opt/startup.relational.ci.sh"]

================
File: backend/relational.test.Dockerfile
================
FROM node:22.14.0-alpine

RUN apk add --no-cache bash
RUN npm i -g @nestjs/cli typescript ts-node

COPY package*.json /tmp/app/
RUN cd /tmp/app && npm install

COPY . /usr/src/app

COPY ./wait-for-it.sh /opt/wait-for-it.sh
RUN chmod +x /opt/wait-for-it.sh
COPY ./startup.relational.test.sh /opt/startup.relational.test.sh
RUN chmod +x /opt/startup.relational.test.sh
RUN sed -i 's/\r//g' /opt/wait-for-it.sh
RUN sed -i 's/\r//g' /opt/startup.relational.test.sh

WORKDIR /usr/src/app

RUN echo "" > .env

CMD ["/opt/startup.relational.test.sh"]

================
File: backend/renovate.json
================
{
  "extends": [
    "config:base"
  ]
}

================
File: backend/scripts/clear-migrations.ts
================
import { AppDataSource } from '../src/database/data-source';
async function clearMigrations() {
  try {
    console.log('🔄 Limpiando historial de migraciones...');
    await AppDataSource.initialize();
    console.log('✅ Conexión establecida');
    await AppDataSource.query('DROP TABLE IF EXISTS "migrations" CASCADE');
    console.log('🗑️  Tabla de migraciones eliminada');
    await AppDataSource.destroy();
    console.log('✅ Conexión cerrada');
    console.log('🎉 Historial de migraciones limpiado!');
    console.log('📝 Ahora puedes ejecutar: npm run migration:run');
  } catch (error) {
    console.error('❌ Error al limpiar migraciones:', error);
    process.exit(1);
  }
}
if (require.main === module) {
  clearMigrations();
}

================
File: backend/scripts/reset-database.ts
================
import { AppDataSource } from '../src/database/data-source';
async function resetDatabase() {
  try {
    console.log('🔄 Iniciando reset de la base de datos...');
    await AppDataSource.initialize();
    console.log('✅ Conexión establecida');
    await AppDataSource.dropDatabase();
    console.log('🗑️  Base de datos eliminada');
    await AppDataSource.destroy();
    console.log('✅ Conexión cerrada');
    console.log('🎉 Reset completado exitosamente!');
    console.log('📝 Ahora puedes ejecutar las migraciones con: npm run migration:run');
  } catch (error) {
    console.error('❌ Error durante el reset:', error);
    process.exit(1);
  }
}
if (require.main === module) {
  resetDatabase();
}

================
File: backend/src/adjustments/adjustments.module.ts
================
import { Module } from '@nestjs/common';
import { AdjustmentsController } from './adjustments.controller';
import { AdjustmentsService } from './adjustments.service';
import { AdjustmentsRelationalPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { CommonModule } from '../common/common.module';
@Module({
  imports: [AdjustmentsRelationalPersistenceModule, CommonModule],
  controllers: [AdjustmentsController],
  providers: [AdjustmentsService],
  exports: [AdjustmentsService],
})
export class AdjustmentsModule {}

================
File: backend/src/adjustments/adjustments.service.ts
================
import { Inject, Injectable, BadRequestException } from '@nestjs/common';
import { BaseCrudService } from '../common/application/base-crud.service';
import { ADJUSTMENT_REPOSITORY } from '../common/tokens';
import { UserContextService } from '../common/services/user-context.service';
import { Adjustment } from './domain/adjustment';
import { CreateAdjustmentDto } from './dto/create-adjustment.dto';
import { FindAllAdjustmentsDto } from './dto/find-all-adjustments.dto';
import { UpdateAdjustmentDto } from './dto/update-adjustment.dto';
import { AdjustmentRepository } from './infrastructure/persistence/adjustment.repository';
@Injectable()
export class AdjustmentsService extends BaseCrudService<
  Adjustment,
  CreateAdjustmentDto,
  UpdateAdjustmentDto,
  FindAllAdjustmentsDto
> {
  constructor(
    @Inject(ADJUSTMENT_REPOSITORY)
    private readonly adjustmentRepository: AdjustmentRepository,
    private readonly userContextService: UserContextService,
  ) {
    super(adjustmentRepository);
  }
  async create(createAdjustmentDto: CreateAdjustmentDto): Promise<Adjustment> {
    if (!createAdjustmentDto.orderId && !createAdjustmentDto.orderItemId) {
      throw new BadRequestException(
        'Either orderId or orderItemId must be provided',
      );
    }
    if (createAdjustmentDto.orderId && createAdjustmentDto.orderItemId) {
      throw new BadRequestException(
        'Cannot provide both orderId and orderItemId',
      );
    }
    let amount = createAdjustmentDto.amount || 0;
    if (createAdjustmentDto.isPercentage) {
      amount = createAdjustmentDto.value;
    }
    const currentUser = this.userContextService.getCurrentUser();
    if (!currentUser) {
      throw new BadRequestException('User context not found');
    }
    const adjustmentData = {
      ...createAdjustmentDto,
      amount,
      appliedById: currentUser.userId,
      appliedAt: new Date(),
    };
    return super.create(adjustmentData as CreateAdjustmentDto);
  }
  async findByOrderId(orderId: string): Promise<Adjustment[]> {
    return this.adjustmentRepository.findByOrderId(orderId);
  }
  async findByOrderItemId(orderItemId: string): Promise<Adjustment[]> {
    return this.adjustmentRepository.findByOrderItemId(orderItemId);
  }
  async calculateOrderAdjustments(orderId: string): Promise<number> {
    return this.adjustmentRepository.calculateOrderAdjustments(orderId);
  }
  async calculateOrderItemAdjustments(orderItemId: string): Promise<number> {
    return this.adjustmentRepository.calculateOrderItemAdjustments(orderItemId);
  }
  async applyBulkAdjustments(
    adjustments: CreateAdjustmentDto[],
  ): Promise<Adjustment[]> {
    const results: Adjustment[] = [];
    for (const adjustment of adjustments) {
      const created = await this.create(adjustment);
      results.push(created);
    }
    return results;
  }
}

================
File: backend/src/adjustments/domain/adjustment.ts
================
import { Order } from '../../orders/domain/order';
import { OrderItem } from '../../orders/domain/order-item';
import { User } from '../../users/domain/user';
export class Adjustment {
  id: string;
  orderId?: string | null;
  orderItemId?: string | null;
  name: string;
  isPercentage: boolean;
  value: number;
  amount: number;
  appliedById: string;
  appliedAt: Date;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
  order?: Order | null;
  orderItem?: OrderItem | null;
  appliedBy?: User | null;
}

================
File: backend/src/adjustments/dto/create-adjustment.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsNotEmpty,
  IsBoolean,
  IsNumber,
  IsString,
  MaxLength,
  Min,
  Max,
  ValidateIf,
} from 'class-validator';
export class CreateAdjustmentDto {
  @ApiProperty({
    description: 'Order ID (required for order-level adjustments)',
    required: false,
  })
  @ValidateIf((o) => !o.orderItemId)
  @IsString()
  @IsNotEmpty()
  orderId?: string;
  @ApiProperty({
    description: 'Order Item ID (required for item-level adjustments)',
    required: false,
  })
  @ValidateIf((o) => !o.orderId)
  @IsString()
  @IsNotEmpty()
  orderItemId?: string;
  @ApiProperty({
    description: 'Name of the adjustment',
    maxLength: 100,
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(100)
  name: string;
  @ApiProperty({
    description: 'Whether the adjustment is a percentage',
    default: false,
  })
  @IsBoolean()
  @IsNotEmpty()
  isPercentage: boolean;
  @ApiProperty({
    description: 'Value of the adjustment (percentage if isPercentage is true)',
    minimum: 0,
  })
  @IsNumber()
  @Min(0)
  @ValidateIf((o) => o.isPercentage)
  @Max(100)
  value: number;
  @ApiProperty({
    description: 'Fixed amount of the adjustment (negative for discounts)',
  })
  @IsNumber()
  @ValidateIf((o) => !o.isPercentage)
  @IsNotEmpty()
  amount?: number;
}

================
File: backend/src/adjustments/dto/find-all-adjustments.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';
import { PaginationParams } from '../../utils/types/pagination-params';
export class FindAllAdjustmentsDto extends PaginationParams {
  @ApiPropertyOptional({
    description: 'Filter by order ID',
  })
  @IsOptional()
  @IsString()
  orderId?: string;
  @ApiPropertyOptional({
    description: 'Filter by order item ID',
  })
  @IsOptional()
  @IsString()
  orderItemId?: string;
  @ApiPropertyOptional({
    description: 'Filter by user who applied the adjustment',
  })
  @IsOptional()
  @IsString()
  appliedById?: string;
}

================
File: backend/src/adjustments/dto/update-adjustment.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { PartialType } from '@nestjs/swagger';
import { CreateAdjustmentDto } from './create-adjustment.dto';
export class UpdateAdjustmentDto extends PartialType(CreateAdjustmentDto) {
  @ApiPropertyOptional()
  id?: string;
}

================
File: backend/src/adjustments/infrastructure/persistence/adjustment.repository.ts
================
import { IBaseRepository } from '../../../common/domain/repositories/base.repository';
import { Adjustment } from '../../domain/adjustment';
import { CreateAdjustmentDto } from '../../dto/create-adjustment.dto';
import { FindAllAdjustmentsDto } from '../../dto/find-all-adjustments.dto';
import { UpdateAdjustmentDto } from '../../dto/update-adjustment.dto';
import { NullableType } from '../../../utils/types/nullable.type';
export abstract class AdjustmentRepository
  implements
    IBaseRepository<
      Adjustment,
      FindAllAdjustmentsDto,
      CreateAdjustmentDto,
      UpdateAdjustmentDto
    >
{
  abstract create(data: CreateAdjustmentDto): Promise<Adjustment>;
  abstract findById(id: string): Promise<NullableType<Adjustment>>;
  abstract findAll(filter?: FindAllAdjustmentsDto): Promise<Adjustment[]>;
  abstract update(
    id: string,
    payload: UpdateAdjustmentDto,
  ): Promise<NullableType<Adjustment>>;
  abstract remove(id: string): Promise<void>;
  abstract findByOrderId(orderId: string): Promise<Adjustment[]>;
  abstract findByOrderItemId(orderItemId: string): Promise<Adjustment[]>;
  abstract calculateOrderAdjustments(orderId: string): Promise<number>;
  abstract calculateOrderItemAdjustments(orderItemId: string): Promise<number>;
}

================
File: backend/src/adjustments/infrastructure/persistence/relational/entities/adjustment.entity.ts
================
import {
  Column,
  CreateDateColumn,
  Entity,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  JoinColumn,
  Index,
} from 'typeorm';
import { OrderEntity } from '../../../../../orders/infrastructure/persistence/relational/entities/order.entity';
import { OrderItemEntity } from '../../../../../orders/infrastructure/persistence/relational/entities/order-item.entity';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
@Entity({
  name: 'adjustment',
})
@Index(['orderId'])
@Index(['orderItemId'])
export class AdjustmentEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ type: 'uuid', nullable: true })
  orderId?: string | null;
  @ManyToOne(() => OrderEntity, (order) => order.adjustments, {
    onDelete: 'CASCADE',
  })
  @JoinColumn({ name: 'orderId' })
  order?: OrderEntity;
  @Column({ type: 'uuid', nullable: true })
  orderItemId?: string | null;
  @ManyToOne(() => OrderItemEntity, (orderItem) => orderItem.adjustments, {
    onDelete: 'CASCADE',
  })
  @JoinColumn({ name: 'orderItemId' })
  orderItem?: OrderItemEntity;
  @Column({ type: 'varchar', length: 100 })
  name: string;
  @Column({ type: 'boolean', default: false })
  isPercentage: boolean;
  @Column({ type: 'decimal', precision: 10, scale: 2, default: 0 })
  value: number;
  @Column({ type: 'decimal', precision: 10, scale: 2 })
  amount: number;
  @Column({ type: 'uuid' })
  appliedById: string;
  @ManyToOne(() => UserEntity)
  @JoinColumn({ name: 'appliedById' })
  appliedBy: UserEntity;
  @Column({ type: 'timestamp' })
  appliedAt: Date;
  @CreateDateColumn()
  createdAt: Date;
  @UpdateDateColumn()
  updatedAt: Date;
  @DeleteDateColumn()
  deletedAt?: Date | null;
}

================
File: backend/src/adjustments/infrastructure/persistence/relational/mappers/adjustment.mapper.ts
================
import { Inject, Injectable, forwardRef } from '@nestjs/common';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
import { Adjustment } from '../../../../domain/adjustment';
import { AdjustmentEntity } from '../entities/adjustment.entity';
import { OrderMapper } from '../../../../../orders/infrastructure/persistence/relational/mappers/order.mapper';
import { OrderItemMapper } from '../../../../../orders/infrastructure/persistence/relational/mappers/order-item.mapper';
import { UserMapper } from '../../../../../users/infrastructure/persistence/relational/mappers/user.mapper';
@Injectable()
export class AdjustmentMapper extends BaseMapper<AdjustmentEntity, Adjustment> {
  constructor(
    @Inject(forwardRef(() => OrderMapper))
    private readonly orderMapper: OrderMapper,
    @Inject(forwardRef(() => OrderItemMapper))
    private readonly orderItemMapper: OrderItemMapper,
    @Inject(forwardRef(() => UserMapper))
    private readonly userMapper: UserMapper,
  ) {
    super();
  }
  toDomain(entity: AdjustmentEntity | null): Adjustment | null {
    if (!entity) {
      return null;
    }
    const domain = new Adjustment();
    domain.id = entity.id;
    domain.orderId = entity.orderId;
    domain.orderItemId = entity.orderItemId;
    domain.name = entity.name;
    domain.isPercentage = entity.isPercentage;
    domain.value = Number(entity.value);
    domain.amount = Number(entity.amount);
    domain.appliedById = entity.appliedById;
    domain.appliedAt = entity.appliedAt;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    if (entity.order) {
      domain.order = this.orderMapper.toDomain(entity.order);
    }
    if (entity.orderItem) {
      domain.orderItem = this.orderItemMapper.toDomain(entity.orderItem);
    }
    if (entity.appliedBy) {
      domain.appliedBy = this.userMapper.toDomain(entity.appliedBy);
    }
    return domain;
  }
  toEntity(domain: Adjustment | null): AdjustmentEntity | null {
    if (!domain) {
      return null;
    }
    const entity = new AdjustmentEntity();
    entity.id = domain.id;
    entity.orderId = domain.orderId;
    entity.orderItemId = domain.orderItemId;
    entity.name = domain.name;
    entity.isPercentage = domain.isPercentage;
    entity.value = domain.value;
    entity.amount = domain.amount;
    entity.appliedById = domain.appliedById;
    entity.appliedAt = domain.appliedAt;
    entity.createdAt = domain.createdAt;
    entity.updatedAt = domain.updatedAt;
    entity.deletedAt = domain.deletedAt;
    return entity;
  }
}

================
File: backend/src/adjustments/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ADJUSTMENT_REPOSITORY } from '../../../../common/tokens';
import { AdjustmentEntity } from './entities/adjustment.entity';
import { AdjustmentMapper } from './mappers/adjustment.mapper';
import { AdjustmentRelationalRepository } from './repositories/adjustment.repository';
import { RelationalOrderPersistenceModule } from '../../../../orders/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalUserPersistenceModule } from '../../../../users/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([AdjustmentEntity]),
    forwardRef(() => RelationalOrderPersistenceModule),
    forwardRef(() => RelationalUserPersistenceModule),
  ],
  providers: [
    {
      provide: ADJUSTMENT_REPOSITORY,
      useClass: AdjustmentRelationalRepository,
    },
    AdjustmentMapper,
  ],
  exports: [ADJUSTMENT_REPOSITORY, AdjustmentMapper],
})
export class AdjustmentsRelationalPersistenceModule {}

================
File: backend/src/adjustments/infrastructure/persistence/relational/repositories/adjustment.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FindOptionsWhere, Repository } from 'typeorm';
import { BaseRelationalRepository } from '../../../../../common/infrastructure/persistence/relational/base-relational.repository';
import { Adjustment } from '../../../../domain/adjustment';
import { FindAllAdjustmentsDto } from '../../../../dto/find-all-adjustments.dto';
import { AdjustmentEntity } from '../entities/adjustment.entity';
import { AdjustmentMapper } from '../mappers/adjustment.mapper';
import { AdjustmentRepository } from '../../adjustment.repository';
import { mapArray } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class AdjustmentRelationalRepository
  extends BaseRelationalRepository<
    AdjustmentEntity,
    Adjustment,
    FindAllAdjustmentsDto
  >
  implements AdjustmentRepository
{
  constructor(
    @InjectRepository(AdjustmentEntity)
    repository: Repository<AdjustmentEntity>,
    mapper: AdjustmentMapper,
  ) {
    super(repository, mapper);
  }
  protected buildWhere(
    filters: FindAllAdjustmentsDto,
  ): FindOptionsWhere<AdjustmentEntity> {
    const where: FindOptionsWhere<AdjustmentEntity> = {};
    if (filters.orderId) {
      where.orderId = filters.orderId;
    }
    if (filters.orderItemId) {
      where.orderItemId = filters.orderItemId;
    }
    if (filters.appliedById) {
      where.appliedById = filters.appliedById;
    }
    return where;
  }
  async findByOrderId(orderId: string): Promise<Adjustment[]> {
    const entities = await this.ormRepo.find({
      where: {
        orderId,
      },
      relations: ['appliedBy'],
      order: {
        appliedAt: 'DESC',
      },
    });
    return mapArray(entities, (entity) => this.mapper.toDomain(entity));
  }
  async findByOrderItemId(orderItemId: string): Promise<Adjustment[]> {
    const entities = await this.ormRepo.find({
      where: {
        orderItemId,
      },
      relations: ['appliedBy'],
      order: {
        appliedAt: 'DESC',
      },
    });
    return mapArray(entities, (entity) => this.mapper.toDomain(entity));
  }
  async calculateOrderAdjustments(orderId: string): Promise<number> {
    const result = await this.ormRepo
      .createQueryBuilder('adjustment')
      .select('SUM(adjustment.amount)', 'total')
      .where('adjustment.orderId = :orderId', { orderId })
      .andWhere('adjustment.deletedAt IS NULL')
      .getRawOne();
    return Number(result?.total || 0);
  }
  async calculateOrderItemAdjustments(orderItemId: string): Promise<number> {
    const result = await this.ormRepo
      .createQueryBuilder('adjustment')
      .select('SUM(adjustment.amount)', 'total')
      .where('adjustment.orderItemId = :orderItemId', { orderItemId })
      .andWhere('adjustment.deletedAt IS NULL')
      .getRawOne();
    return Number(result?.total || 0);
  }
}

================
File: backend/src/areas/areas.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpCode,
  HttpStatus,
  UseGuards,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiBearerAuth } from '@nestjs/swagger';
import { AreasService } from './areas.service';
import { Area } from './domain/area';
import { CreateAreaDto } from './dto/create-area.dto';
import { FindAllAreasDto } from './dto/find-all-areas.dto';
import { UpdateAreaDto } from './dto/update-area.dto';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { Paginated } from '../common/types/paginated.type';
@ApiTags('Areas')
@Controller({ path: 'areas', version: '1' })
export class AreasController {
  constructor(private readonly service: AreasService) {}
  @Post()
  @ApiOperation({ summary: 'Create a new area' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.CREATED)
  create(@Body() dto: CreateAreaDto): Promise<Area> {
    return this.service.create(dto);
  }
  @Get()
  @ApiOperation({ summary: 'Find all areas' })
  @HttpCode(HttpStatus.OK)
  findAll(@Query() q: FindAllAreasDto): Promise<Paginated<Area>> {
    return this.service.findAllPaginated(q);
  }
  @Get(':id')
  @ApiOperation({ summary: 'Find one area by ID' })
  @HttpCode(HttpStatus.OK)
  findOne(@Param('id') id: string): Promise<Area> {
    return this.service.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({ summary: 'Update an area' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  update(
    @Param('id') id: string,
    @Body() dto: UpdateAreaDto,
  ): Promise<Area | null> {
    return this.service.update(id, dto);
  }
  @Delete(':id')
  @ApiOperation({ summary: 'Remove an area' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async remove(@Param('id') id: string): Promise<void> {
    await this.service.remove(id);
  }
}

================
File: backend/src/areas/areas.module.ts
================
import { Module } from '@nestjs/common';
import { AreasController } from './areas.controller';
import { AreasService } from './areas.service';
import { RelationalAreaPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { AuthModule } from '../auth/auth.module';
@Module({
  imports: [RelationalAreaPersistenceModule, AuthModule],
  controllers: [AreasController],
  providers: [AreasService],
  exports: [AreasService, RelationalAreaPersistenceModule],
})
export class AreasModule {}

================
File: backend/src/areas/domain/area.ts
================
import { Table } from '../../tables/domain/table';
export class Area {
  id: string;
  name: string;
  description?: string;
  isActive: boolean;
  tables: Table[];
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/areas/dto/create-area.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { TransformDefault } from '../../utils/transformers/transform-default.decorator';
export class CreateAreaDto {
  @ApiProperty({
    type: String,
    example: 'Terraza',
  })
  @IsNotEmpty()
  @IsString()
  name: string;
  @ApiProperty({
    type: String,
    example: 'Área al aire libre con vista panorámica',
    required: false,
  })
  @IsOptional()
  @IsString()
  description?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
    default: true,
  })
  @TransformDefault(true)
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

================
File: backend/src/areas/dto/find-all-areas.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString } from 'class-validator';
import { Transform } from 'class-transformer';
import { PaginationParams } from '../../utils/types/pagination-params';
export class FindAllAreasDto extends PaginationParams {
  @ApiProperty({
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: Boolean,
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
}

================
File: backend/src/areas/dto/update-area.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString } from 'class-validator';
export class UpdateAreaDto {
  @ApiProperty({
    type: String,
    example: 'Terraza',
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: String,
    example: 'Área al aire libre con vista panorámica',
    required: false,
  })
  @IsOptional()
  @IsString()
  description?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

================
File: backend/src/areas/infrastructure/persistence/area.repository.ts
================
import { Area } from '../../domain/area';
import { IBaseRepository } from '../../../common/domain/repositories/base.repository';
import { FindAllAreasDto } from '../../dto/find-all-areas.dto';
import { CreateAreaDto } from '../../dto/create-area.dto';
import { UpdateAreaDto } from '../../dto/update-area.dto';
export interface AreaRepository
  extends IBaseRepository<
    Area,
    FindAllAreasDto,
    CreateAreaDto,
    UpdateAreaDto
  > {}

================
File: backend/src/areas/infrastructure/persistence/relational/entities/area.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  OneToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { TableEntity } from '../../../../../tables/infrastructure/persistence/relational/entities/table.entity';
@Entity({
  name: 'area',
})
export class AreaEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ unique: true })
  name: string;
  @Column({ type: 'varchar', default: '' })
  description?: string;
  @Column({ default: true })
  isActive: boolean;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
  @OneToMany(() => TableEntity, (table) => table.area)
  tables: TableEntity[];
}

================
File: backend/src/areas/infrastructure/persistence/relational/mappers/area.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { Area } from '../../../../domain/area';
import { AreaEntity } from '../entities/area.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class AreaMapper extends BaseMapper<AreaEntity, Area> {
  override toDomain(entity: AreaEntity): Area | null {
    if (!entity) return null;
    const domain = new Area();
    domain.id = entity.id;
    domain.name = entity.name;
    domain.description = entity.description;
    domain.isActive = entity.isActive;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: Area): AreaEntity | null {
    if (!domain) return null;
    const entity = new AreaEntity();
    if (domain.id) entity.id = domain.id;
    entity.name = domain.name;
    entity.description = domain.description;
    entity.isActive = domain.isActive;
    return entity;
  }
}

================
File: backend/src/areas/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AREA_REPOSITORY } from '../../../../common/tokens';
import { AreaEntity } from './entities/area.entity';
import { AreasRelationalRepository } from './repositories/area.repository';
import { AreaMapper } from './mappers/area.mapper';
@Module({
  imports: [TypeOrmModule.forFeature([AreaEntity])],
  providers: [
    {
      provide: AREA_REPOSITORY,
      useClass: AreasRelationalRepository,
    },
    AreaMapper,
  ],
  exports: [AREA_REPOSITORY, AreaMapper],
})
export class RelationalAreaPersistenceModule {}

================
File: backend/src/areas/infrastructure/persistence/relational/repositories/area.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FindOptionsWhere, Repository, ILike } from 'typeorm';
import { Area } from '../../../../domain/area';
import { FindAllAreasDto } from '../../../../dto/find-all-areas.dto';
import { AreaRepository } from '../../area.repository';
import { AreaEntity } from '../entities/area.entity';
import { AreaMapper } from '../mappers/area.mapper';
import { BaseRelationalRepository } from '../../../../../common/infrastructure/persistence/relational/base-relational.repository';
import { CreateAreaDto } from '../../../../dto/create-area.dto';
import { UpdateAreaDto } from '../../../../dto/update-area.dto';
@Injectable()
export class AreasRelationalRepository
  extends BaseRelationalRepository<
    AreaEntity,
    Area,
    FindAllAreasDto,
    CreateAreaDto,
    UpdateAreaDto
  >
  implements AreaRepository
{
  constructor(
    @InjectRepository(AreaEntity)
    ormRepo: Repository<AreaEntity>,
    mapper: AreaMapper,
  ) {
    super(ormRepo, mapper);
  }
  protected override buildWhere(
    filter?: FindAllAreasDto,
  ): FindOptionsWhere<AreaEntity> | undefined {
    if (!filter) return undefined;
    const where: FindOptionsWhere<AreaEntity> = {};
    if (filter.name) {
      where.name = ILike(`%${filter.name}%`);
    }
    if (filter.isActive !== undefined) {
      where.isActive = filter.isActive;
    }
    return Object.keys(where).length > 0 ? where : undefined;
  }
}

================
File: backend/src/audio-order-processing/config/audio-order-config.type.ts
================
export type AudioOrderConfig = {
  enabled: boolean;
  cloudApiUrl: string;
  cloudApiKey: string;
  maxAudioSizeMb: number;
  supportedFormats: string[];
  timeout: number;
};

================
File: backend/src/audio-order-processing/config/audio-order.config.ts
================
import { registerAs } from '@nestjs/config';
import { AudioOrderConfig } from './audio-order-config.type';
export default registerAs<AudioOrderConfig>('audioOrder', () => {
  return {
    enabled: true,
    cloudApiUrl: process.env.CLOUD_API_URL || '',
    cloudApiKey: process.env.CLOUD_API_KEY || '',
    maxAudioSizeMb: 50, // Hasta 50MB para audio de 5 minutos
    supportedFormats: [
      'audio/webm',
      'audio/ogg',
      'audio/mpeg',
      'audio/wav',
      'audio/mp4',
    ],
    timeout: 300000,
  };
});

================
File: backend/src/audio-order-processing/dto/process-audio-order.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsString,
  IsNotEmpty,
  IsOptional,
  IsNumber,
  IsUUID,
  IsEnum,
} from 'class-validator';
import { OrderType } from '../../orders/domain/enums/order-type.enum';
export class ProcessAudioOrderDto {
  @ApiProperty({
    description: 'Audio file in base64 format',
    example: 'data:audio/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2...',
  })
  @IsString()
  @IsNotEmpty()
  audioData: string;
  @ApiProperty({
    description: 'Transcription of the audio',
    example: 'Quiero una pizza familiar de pepperoni',
  })
  @IsString()
  @IsNotEmpty()
  transcription: string;
  @ApiPropertyOptional({
    description: 'Audio format',
    example: 'audio/webm',
  })
  @IsString()
  @IsOptional()
  audioFormat?: string;
  @ApiPropertyOptional({
    description: 'Duration of the audio in seconds',
    example: 5.2,
  })
  @IsNumber()
  @IsOptional()
  duration?: number;
  @ApiPropertyOptional({
    description: 'Customer ID if identified',
  })
  @IsUUID()
  @IsOptional()
  customerId?: string;
  @ApiPropertyOptional({
    description: 'Order ID if modifying existing order',
  })
  @IsUUID()
  @IsOptional()
  orderId?: string;
  @ApiPropertyOptional({
    description: 'Type of order',
    enum: OrderType,
    example: OrderType.DELIVERY,
  })
  @IsEnum(OrderType)
  @IsOptional()
  orderType?: OrderType;
}
export class AudioOrderResponseDto {
  @ApiProperty({
    description: 'Success status',
    example: true,
  })
  success: boolean;
  @ApiProperty({
    description: 'Processing result message',
    example: 'Orden procesada correctamente',
  })
  message: string;
  @ApiPropertyOptional({
    description: 'Created or updated order data',
  })
  order?: any;
  @ApiPropertyOptional({
    description: 'Structured data extracted from audio',
    example: {
      orderItems: [
        {
          productId: 'PR-39',
          variantId: 'PVA-20',
          quantity: 1,
        },
      ],
      deliveryInfo: {
        fullAddress: 'Nicolás Bravo 165',
      },
      orderType: 'DELIVERY',
      warnings: null,
      processingTime: 1500,
    },
  })
  extractedData?: {
    orderItems?: Array<{
      productId: string;
      variantId?: string;
      quantity: number;
      modifiers?: string[];
      pizzaCustomizations?: Array<{
        customizationId: string;
        half: string;
        action: string;
      }>;
    }>;
    deliveryInfo?: {
      fullAddress?: string;
      recipientName?: string;
      recipientPhone?: string;
    };
    scheduledDelivery?: {
      time?: string;
    };
    orderType?: OrderType;
    warnings?: string;
    processingTime?: number;
  };
  @ApiPropertyOptional({
    description: 'Error details if processing failed',
  })
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}
export class CloudApiRequestDto {
  audio: string;
  transcript: string;
  metadata?: {
    customerId?: string;
    orderId?: string;
    timestamp: string;
    orderType?: OrderType;
  };
}
export class CloudApiResponseDto {
  success: boolean;
  data?: {
    action: string;
    entities: any;
    confidence: number;
  };
  error?: {
    code: string;
    message: string;
  };
}

================
File: backend/src/audio-order-processing/README.md
================
# Módulo de Procesamiento de Audio para Órdenes

Este módulo permite procesar órdenes a través de comandos de voz, integrándose con un servidor en la nube de procesamiento de audio.

## Configuración

### Variables de Entorno

El módulo utiliza las siguientes variables de entorno para conectarse al servidor remoto:

```env
# Configuración del servidor en la nube
CLOUD_API_URL=http://tu-servidor-remoto:8000
CLOUD_API_KEY=tu-api-key
```

**Nota:** Los valores de tamaño máximo (10MB) y timeout (30 segundos) están definidos directamente en el código para simplificar la configuración.

### Endpoint

El módulo expone el siguiente endpoint:

```
POST /api/audio-orders/process
```

#### Request Body

```json
{
  "audioData": "data:audio/mp4;base64,AAAA...",
  "transcription": "Quiero una pizza familiar de pepperoni",
  "audioFormat": "audio/mp4",
  "duration": 5.2,
  "customerId": "uuid-del-cliente",
  "orderId": "uuid-de-orden-existente"
}
```

#### Response

```json
{
  "success": true,
  "message": "Orden procesada correctamente",
  "order": { /* datos de la orden */ },
  "extractedData": {
    "action": "create_order",
    "products": [
      {
        "name": "Pizza Familiar Pepperoni",
        "quantity": 1,
        "variant": "familiar"
      }
    ]
  }
}
```

## Arquitectura

1. **Frontend**: Captura el audio y la transcripción, luego envía al backend
2. **Backend**: 
   - Valida los datos recibidos
   - Envía al servidor en la nube de procesamiento
   - Procesa la respuesta y ejecuta acciones (crear orden, modificar, consultar)
3. **Servidor en la Nube**: Analiza el audio y extrae las intenciones y entidades

## Seguridad

- El endpoint requiere autenticación JWT
- El tamaño máximo de audio es 10MB
- La comunicación con el servidor en la nube usa API Key
- Timeout de 30 segundos para evitar bloqueos

## Desarrollo

Para agregar nuevas acciones de procesamiento:

1. Actualiza el método `processRemoteResponse` en `audio-order-processing.service.ts`
2. Implementa el método correspondiente para la nueva acción
3. Actualiza los DTOs si es necesario

================
File: backend/src/auth/auth-providers.enum.ts
================
export enum AuthProvidersEnum {
  email = 'email',
}

================
File: backend/src/auth/auth.controller.ts
================
import {
  Body,
  Controller,
  Get,
  HttpCode,
  HttpStatus,
  Request,
  Post,
  UseGuards,
  Patch,
  Delete,
  SerializeOptions,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { ApiBearerAuth, ApiOkResponse, ApiTags } from '@nestjs/swagger';
import { AuthEmailLoginDto } from './dto/auth-email-login.dto';
import { AuthForgotPasswordDto } from './dto/auth-forgot-password.dto';
import { AuthConfirmEmailDto } from './dto/auth-confirm-email.dto';
import { AuthResetPasswordDto } from './dto/auth-reset-password.dto';
import { AuthUpdateDto } from './dto/auth-update.dto';
import { AuthGuard } from '@nestjs/passport';
import { AuthRegisterLoginDto } from './dto/auth-register-login.dto';
import { LoginResponseDto } from './dto/login-response.dto';
import { NullableType } from '../utils/types/nullable.type';
import { User } from '../users/domain/user';
import { RefreshResponseDto } from './dto/refresh-response.dto';
@ApiTags('Auth')
@Controller({
  path: 'auth',
  version: '1',
})
export class AuthController {
  constructor(private readonly service: AuthService) {}
  @SerializeOptions({
    groups: ['me'],
  })
  @Post('email/login')
  @ApiOkResponse({
    type: LoginResponseDto,
  })
  @HttpCode(HttpStatus.OK)
  public login(@Body() loginDto: AuthEmailLoginDto): Promise<LoginResponseDto> {
    return this.service.validateLogin(loginDto);
  }
  @Post('email/register')
  @HttpCode(HttpStatus.NO_CONTENT)
  async register(@Body() createUserDto: AuthRegisterLoginDto): Promise<void> {
    return this.service.register(createUserDto);
  }
  @Post('email/confirm')
  @HttpCode(HttpStatus.NO_CONTENT)
  async confirmEmail(
    @Body() confirmEmailDto: AuthConfirmEmailDto,
  ): Promise<void> {
    return this.service.confirmEmail(confirmEmailDto.hash);
  }
  @Post('email/confirm/new')
  @HttpCode(HttpStatus.NO_CONTENT)
  async confirmNewEmail(
    @Body() confirmEmailDto: AuthConfirmEmailDto,
  ): Promise<void> {
    return this.service.confirmNewEmail(confirmEmailDto.hash);
  }
  @Post('forgot/password')
  @HttpCode(HttpStatus.NO_CONTENT)
  async forgotPassword(
    @Body() forgotPasswordDto: AuthForgotPasswordDto,
  ): Promise<void> {
    return this.service.forgotPassword(forgotPasswordDto.email);
  }
  @Post('reset/password')
  @HttpCode(HttpStatus.NO_CONTENT)
  resetPassword(@Body() resetPasswordDto: AuthResetPasswordDto): Promise<void> {
    return this.service.resetPassword(
      resetPasswordDto.hash,
      resetPasswordDto.password,
    );
  }
  @ApiBearerAuth()
  @SerializeOptions({
    groups: ['me'],
  })
  @Get('me')
  @UseGuards(AuthGuard('jwt'))
  @ApiOkResponse({
    type: User,
  })
  @HttpCode(HttpStatus.OK)
  public me(@Request() request): Promise<NullableType<User>> {
    return this.service.me(request.user);
  }
  @ApiBearerAuth()
  @ApiOkResponse({
    type: RefreshResponseDto,
  })
  @SerializeOptions({
    groups: ['me'],
  })
  @Post('refresh')
  @UseGuards(AuthGuard('jwt-refresh'))
  @HttpCode(HttpStatus.OK)
  public refresh(@Request() request): Promise<RefreshResponseDto> {
    return this.service.refreshToken({
      sessionId: request.user.sessionId,
      hash: request.user.hash,
    });
  }
  @ApiBearerAuth()
  @Post('logout')
  @UseGuards(AuthGuard('jwt'))
  @HttpCode(HttpStatus.NO_CONTENT)
  public async logout(@Request() request): Promise<void> {
    await this.service.logout({
      sessionId: request.user.sessionId,
    });
  }
  @ApiBearerAuth()
  @SerializeOptions({
    groups: ['me'],
  })
  @Patch('me')
  @UseGuards(AuthGuard('jwt'))
  @HttpCode(HttpStatus.OK)
  @ApiOkResponse({
    type: User,
  })
  public update(
    @Request() request,
    @Body() userDto: AuthUpdateDto,
  ): Promise<NullableType<User>> {
    return this.service.update(request.user, userDto);
  }
  @ApiBearerAuth()
  @Delete('me')
  @UseGuards(AuthGuard('jwt'))
  @HttpCode(HttpStatus.NO_CONTENT)
  public async delete(@Request() request): Promise<void> {
    return this.service.softDelete(request.user);
  }
}

================
File: backend/src/auth/auth.module.ts
================
import { Module } from '@nestjs/common';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { JwtStrategy } from './strategies/jwt.strategy';
import { AnonymousStrategy } from './strategies/anonymous.strategy';
import { JwtRefreshStrategy } from './strategies/jwt-refresh.strategy';
import { MailModule } from '../mail/mail.module';
import { SessionModule } from '../session/session.module';
import { UsersModule } from '../users/users.module';
@Module({
  imports: [
    UsersModule,
    SessionModule,
    PassportModule,
    MailModule,
    JwtModule.register({}),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, JwtRefreshStrategy, AnonymousStrategy],
  exports: [AuthService],
})
export class AuthModule {}

================
File: backend/src/auth/config/auth-config.type.ts
================
import ms from 'ms';
export type AuthConfig = {
  secret?: string;
  expires?: ms.StringValue;
  refreshSecret?: string;
  refreshExpires?: ms.StringValue;
  forgotSecret?: string;
  forgotExpires?: ms.StringValue;
  confirmEmailSecret?: string;
  confirmEmailExpires?: ms.StringValue;
};

================
File: backend/src/auth/config/auth.config.ts
================
import { registerAs } from '@nestjs/config';
import { IsString } from 'class-validator';
import validateConfig from '../../utils/validate-config';
import { AuthConfig } from './auth-config.type';
import ms from 'ms';
class EnvironmentVariablesValidator {
  @IsString()
  AUTH_JWT_SECRET: string;
  @IsString()
  AUTH_JWT_TOKEN_EXPIRES_IN: string;
  @IsString()
  AUTH_REFRESH_SECRET: string;
  @IsString()
  AUTH_REFRESH_TOKEN_EXPIRES_IN: string;
  @IsString()
  AUTH_FORGOT_SECRET: string;
  @IsString()
  AUTH_FORGOT_TOKEN_EXPIRES_IN: string;
  @IsString()
  AUTH_CONFIRM_EMAIL_SECRET: string;
  @IsString()
  AUTH_CONFIRM_EMAIL_TOKEN_EXPIRES_IN: string;
}
export default registerAs<AuthConfig>('auth', () => {
  validateConfig(process.env, EnvironmentVariablesValidator);
  return {
    secret: process.env.AUTH_JWT_SECRET,
    expires: process.env.AUTH_JWT_TOKEN_EXPIRES_IN as ms.StringValue,
    refreshSecret: process.env.AUTH_REFRESH_SECRET,
    refreshExpires: process.env.AUTH_REFRESH_TOKEN_EXPIRES_IN as ms.StringValue,
    forgotSecret: process.env.AUTH_FORGOT_SECRET,
    forgotExpires: process.env.AUTH_FORGOT_TOKEN_EXPIRES_IN as ms.StringValue,
    confirmEmailSecret: process.env.AUTH_CONFIRM_EMAIL_SECRET,
    confirmEmailExpires: process.env
      .AUTH_CONFIRM_EMAIL_TOKEN_EXPIRES_IN as ms.StringValue,
  };
});

================
File: backend/src/auth/decorators/current-user.decorator.ts
================
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
export const CurrentUser = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;
    return data ? user?.[data] : user;
  },
);

================
File: backend/src/auth/dto/auth-confirm-email.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty } from 'class-validator';
export class AuthConfirmEmailDto {
  @ApiProperty()
  @IsNotEmpty()
  hash: string;
}

================
File: backend/src/auth/dto/auth-email-login.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsOptional, IsString } from 'class-validator';
export class AuthEmailLoginDto {
  @ApiProperty({ example: 'johndoe', required: false })
  @IsOptional()
  @IsString()
  username?: string;
  @ApiProperty({ example: 'john@example.com', required: false })
  @IsOptional()
  @IsEmail()
  email?: string;
  @ApiProperty()
  @IsNotEmpty()
  password: string;
}

================
File: backend/src/auth/dto/auth-forgot-password.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail } from 'class-validator';
import { Transform } from 'class-transformer';
import { lowerCaseTransformer } from '../../utils/transformers/lower-case.transformer';
export class AuthForgotPasswordDto {
  @ApiProperty({ example: 'test1@example.com', type: String })
  @Transform(lowerCaseTransformer)
  @IsEmail()
  email: string;
}

================
File: backend/src/auth/dto/auth-register-login.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  MinLength,
  IsEnum,
  IsISO8601,
  IsString,
  IsObject,
} from 'class-validator';
import { Transform } from 'class-transformer';
import { lowerCaseTransformer } from '../../utils/transformers/lower-case.transformer';
import { GenderEnum } from '../../users/enums/gender.enum';
export class AuthRegisterLoginDto {
  @ApiPropertyOptional({ example: 'test1@example.com', type: String })
  @Transform(lowerCaseTransformer)
  @IsOptional()
  @IsEmail()
  email?: string;
  @ApiProperty({ example: 'johndoe', type: String })
  @IsNotEmpty()
  username: string;
  @ApiProperty()
  @MinLength(6)
  password: string;
  @ApiProperty({ example: 'John' })
  @IsNotEmpty()
  firstName: string;
  @ApiProperty({ example: 'Doe' })
  @IsNotEmpty()
  lastName: string;
  @ApiPropertyOptional({ example: '1990-01-01' })
  @IsOptional()
  @IsISO8601()
  birthDate?: string;
  @ApiPropertyOptional({ enum: GenderEnum, enumName: 'GenderEnum' })
  @IsOptional()
  @IsEnum(GenderEnum)
  gender?: GenderEnum;
  @ApiPropertyOptional({ example: '+1234567890' })
  @IsOptional()
  @IsString()
  phoneNumber?: string;
  @ApiPropertyOptional({ example: '123 Main St' })
  @IsOptional()
  @IsString()
  address?: string;
  @ApiPropertyOptional({ example: 'New York' })
  @IsOptional()
  @IsString()
  city?: string;
  @ApiPropertyOptional({ example: 'NY' })
  @IsOptional()
  @IsString()
  state?: string;
  @ApiPropertyOptional({ example: 'USA' })
  @IsOptional()
  @IsString()
  country?: string;
  @ApiPropertyOptional({ example: '10001' })
  @IsOptional()
  @IsString()
  zipCode?: string;
  @ApiPropertyOptional({
    example: {
      name: 'Jane Doe',
      relationship: 'Spouse',
      phoneNumber: '+1987654321',
    },
  })
  @IsOptional()
  @IsObject()
  emergencyContact?: Record<string, any>;
}

================
File: backend/src/auth/dto/auth-reset-password.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty } from 'class-validator';
export class AuthResetPasswordDto {
  @ApiProperty()
  @IsNotEmpty()
  password: string;
  @ApiProperty()
  @IsNotEmpty()
  hash: string;
}

================
File: backend/src/auth/dto/auth-update.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  MinLength,
  IsEnum,
  IsISO8601,
  IsString,
  IsObject,
} from 'class-validator';
import { FileDto } from '../../files/dto/file.dto';
import { Transform } from 'class-transformer';
import { lowerCaseTransformer } from '../../utils/transformers/lower-case.transformer';
import { GenderEnum } from '../../users/enums/gender.enum';
export class AuthUpdateDto {
  @ApiPropertyOptional({ type: () => FileDto })
  @IsOptional()
  photo?: FileDto | null;
  @ApiPropertyOptional({ example: 'John' })
  @IsOptional()
  @IsNotEmpty({ message: 'mustBeNotEmpty' })
  firstName?: string;
  @ApiPropertyOptional({ example: 'Doe' })
  @IsOptional()
  @IsNotEmpty({ message: 'mustBeNotEmpty' })
  lastName?: string;
  @ApiPropertyOptional({ example: 'new.email@example.com' })
  @IsOptional()
  @IsNotEmpty()
  @IsEmail()
  @Transform(lowerCaseTransformer)
  email?: string;
  @ApiPropertyOptional()
  @IsOptional()
  @IsNotEmpty()
  @MinLength(6)
  password?: string;
  @ApiPropertyOptional()
  @IsOptional()
  @IsNotEmpty({ message: 'mustBeNotEmpty' })
  oldPassword?: string;
  @ApiPropertyOptional({ example: '1990-01-01' })
  @IsOptional()
  @IsISO8601()
  @Transform(({ value }) => (value ? new Date(value) : null))
  birthDate?: Date | null;
  @ApiPropertyOptional({ enum: GenderEnum, enumName: 'GenderEnum' })
  @IsOptional()
  @IsEnum(GenderEnum)
  gender?: GenderEnum | null;
  @ApiPropertyOptional({ example: '+1234567890' })
  @IsOptional()
  @IsString()
  phoneNumber?: string | null;
  @ApiPropertyOptional({ example: '123 Main St' })
  @IsOptional()
  @IsString()
  address?: string | null;
  @ApiPropertyOptional({ example: 'New York' })
  @IsOptional()
  @IsString()
  city?: string | null;
  @ApiPropertyOptional({ example: 'NY' })
  @IsOptional()
  @IsString()
  state?: string | null;
  @ApiPropertyOptional({ example: 'USA' })
  @IsOptional()
  @IsString()
  country?: string | null;
  @ApiPropertyOptional({ example: '10001' })
  @IsOptional()
  @IsString()
  zipCode?: string | null;
  @ApiPropertyOptional({
    example: {
      name: 'Jane Doe',
      relationship: 'Spouse',
      phoneNumber: '+1987654321',
    },
  })
  @IsOptional()
  @IsObject()
  emergencyContact?: Record<string, any>;
}

================
File: backend/src/auth/dto/login-response.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { User } from '../../users/domain/user';
export class LoginResponseDto {
  @ApiProperty()
  token: string;
  @ApiProperty()
  refreshToken: string;
  @ApiProperty()
  tokenExpires: number;
  @ApiProperty({
    type: () => User,
  })
  user: User;
}

================
File: backend/src/auth/dto/refresh-response.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
export class RefreshResponseDto {
  @ApiProperty()
  token: string;
  @ApiProperty()
  refreshToken: string;
  @ApiProperty()
  tokenExpires: number;
}

================
File: backend/src/auth/strategies/anonymous.strategy.ts
================
import { Strategy } from 'passport-anonymous';
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
@Injectable()
export class AnonymousStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super();
  }
  public validate(payload: unknown, request: unknown): unknown {
    return request;
  }
}

================
File: backend/src/auth/strategies/jwt-refresh.strategy.ts
================
import { ExtractJwt, Strategy } from 'passport-jwt';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ConfigService } from '@nestjs/config';
import { JwtRefreshPayloadType } from './types/jwt-refresh-payload.type';
import { OrNeverType } from '../../utils/types/or-never.type';
import { AllConfigType } from '../../config/config.type';
@Injectable()
export class JwtRefreshStrategy extends PassportStrategy(
  Strategy,
  'jwt-refresh',
) {
  constructor(configService: ConfigService<AllConfigType>) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: configService.getOrThrow('auth.refreshSecret', {
        infer: true,
      }),
    });
  }
  public validate(
    payload: JwtRefreshPayloadType,
  ): OrNeverType<JwtRefreshPayloadType> {
    if (
      !payload.sessionId ||
      payload.sessionId === null ||
      payload.sessionId === undefined
    ) {
      throw new UnauthorizedException('Session ID is required');
    }
    return payload;
  }
}

================
File: backend/src/auth/strategies/jwt.strategy.ts
================
import { ExtractJwt, Strategy } from 'passport-jwt';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ConfigService } from '@nestjs/config';
import { OrNeverType } from '../../utils/types/or-never.type';
import { JwtPayloadType } from './types/jwt-payload.type';
import { AllConfigType } from '../../config/config.type';
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor(configService: ConfigService<AllConfigType>) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: configService.getOrThrow('auth.secret', { infer: true }),
    });
  }
  public validate(payload: JwtPayloadType): OrNeverType<JwtPayloadType> {
    if (!payload.id) {
      throw new UnauthorizedException();
    }
    return payload;
  }
}

================
File: backend/src/auth/strategies/types/jwt-payload.type.ts
================
import { Session } from '../../../session/domain/session';
import { User } from '../../../users/domain/user';
export type JwtPayloadType = Pick<User, 'id' | 'role'> & {
  sessionId: Session['id'];
  iat: number;
  exp: number;
};

================
File: backend/src/auth/strategies/types/jwt-refresh-payload.type.ts
================
import { Session } from '../../../session/domain/session';
export type JwtRefreshPayloadType = {
  sessionId: Session['id'];
  hash: Session['hash'];
  iat: number;
  exp: number;
};

================
File: backend/src/availability/availability.controller.ts
================
import { Body, Controller, Get, Patch, UseGuards } from '@nestjs/common';
import { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { AvailabilityService } from './availability.service';
import {
  AvailabilityUpdateDto,
  BulkAvailabilityUpdateDto,
} from './dto/availability-update.dto';
import {
  CategoryAvailabilityDto,
  ModifierGroupAvailabilityDto,
} from './dto/menu-availability.dto';
@ApiTags('Availability')
@Controller({
  path: 'availability',
  version: '1',
})
@UseGuards(AuthGuard('jwt'), RolesGuard)
export class AvailabilityController {
  constructor(private readonly availabilityService: AvailabilityService) {}
  @Get('menu')
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @ApiOperation({ summary: 'Get menu availability status' })
  @ApiResponse({
    status: 200,
    description: 'Menu availability retrieved successfully',
    type: [CategoryAvailabilityDto],
  })
  async getMenuAvailability(): Promise<CategoryAvailabilityDto[]> {
    return this.availabilityService.getMenuAvailability();
  }
  @Get('modifier-groups')
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @ApiOperation({ summary: 'Get modifier groups availability status' })
  @ApiResponse({
    status: 200,
    description: 'Modifier groups availability retrieved successfully',
    type: [ModifierGroupAvailabilityDto],
  })
  async getModifierGroupsAvailability(): Promise<
    ModifierGroupAvailabilityDto[]
  > {
    return this.availabilityService.getModifierGroupsAvailability();
  }
  @Get('pizza-customizations')
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @ApiOperation({ summary: 'Get pizza customizations availability status' })
  @ApiResponse({
    status: 200,
    description: 'Pizza customizations availability retrieved successfully',
  })
  async getPizzaCustomizationsAvailability(): Promise<any[]> {
    return this.availabilityService.getPizzaCustomizationsAvailability();
  }
  @Patch('update')
  @Roles(RoleEnum.admin)
  @ApiOperation({ summary: 'Update availability for a single entity' })
  @ApiResponse({
    status: 200,
    description: 'Availability updated successfully',
  })
  async updateAvailability(@Body() dto: AvailabilityUpdateDto): Promise<void> {
    return this.availabilityService.updateAvailability(dto);
  }
  @Patch('bulk-update')
  @Roles(RoleEnum.admin)
  @ApiOperation({ summary: 'Bulk update availability for multiple entities' })
  @ApiResponse({
    status: 200,
    description: 'Availability updated successfully',
  })
  async bulkUpdateAvailability(
    @Body() dto: BulkAvailabilityUpdateDto,
  ): Promise<void> {
    return this.availabilityService.bulkUpdateAvailability(dto.updates);
  }
}

================
File: backend/src/availability/availability.module.ts
================
import { Module } from '@nestjs/common';
import { AvailabilityController } from './availability.controller';
import { AvailabilityService } from './availability.service';
import { CategoriesModule } from '../categories/categories.module';
import { SubcategoriesModule } from '../subcategories/subcategories.module';
import { ProductsModule } from '../products/products.module';
import { ModifierGroupsModule } from '../modifier-groups/modifier-groups.module';
import { ProductModifiersModule } from '../product-modifiers/product-modifiers.module';
import { PizzaCustomizationsModule } from '../pizza-customizations/pizza-customizations.module';
@Module({
  imports: [
    CategoriesModule,
    SubcategoriesModule,
    ProductsModule,
    ModifierGroupsModule,
    ProductModifiersModule,
    PizzaCustomizationsModule,
  ],
  controllers: [AvailabilityController],
  providers: [AvailabilityService],
  exports: [AvailabilityService],
})
export class AvailabilityModule {}

================
File: backend/src/availability/availability.service.ts
================
import { Injectable } from '@nestjs/common';
import { CategoriesService } from '../categories/categories.service';
import { SubcategoriesService } from '../subcategories/subcategories.service';
import { ProductsService } from '../products/products.service';
import { ModifierGroupsService } from '../modifier-groups/modifier-groups.service';
import { ProductModifiersService } from '../product-modifiers/product-modifiers.service';
import { PizzaCustomizationsService } from '../pizza-customizations/pizza-customizations.service';
import {
  AvailabilityType,
  AvailabilityUpdateDto,
} from './dto/availability-update.dto';
import {
  CategoryAvailabilityDto,
  SubcategoryAvailabilityDto,
  ModifierGroupAvailabilityDto,
} from './dto/menu-availability.dto';
@Injectable()
export class AvailabilityService {
  constructor(
    private readonly categoriesService: CategoriesService,
    private readonly subcategoriesService: SubcategoriesService,
    private readonly productsService: ProductsService,
    private readonly modifierGroupsService: ModifierGroupsService,
    private readonly productModifiersService: ProductModifiersService,
    private readonly pizzaCustomizationsService: PizzaCustomizationsService,
  ) {}
  async getMenuAvailability(): Promise<CategoryAvailabilityDto[]> {
    const categoriesResult = await this.categoriesService.findAllPaginated({
      page: 1,
      limit: 1000,
      isActive: undefined,
    });
    const menuAvailability: CategoryAvailabilityDto[] = [];
    for (const category of categoriesResult.items) {
      const subcategories = await this.subcategoriesService.findAllByCategoryId(
        category.id,
      );
      const subcategoriesWithProducts: SubcategoryAvailabilityDto[] = [];
      for (const subcategory of subcategories) {
        const products = await this.productsService.findAllBySubcategoryId(
          subcategory.id,
        );
        subcategoriesWithProducts.push({
          id: subcategory.id,
          name: subcategory.name,
          isActive: subcategory.isActive ?? true,
          categoryId: subcategory.categoryId,
          products: products.map((product) => ({
            id: product.id,
            name: product.name,
            isActive: product.isActive ?? true,
            subcategoryId: product.subcategoryId,
          })),
        });
      }
      const categoryAvailability: CategoryAvailabilityDto = {
        id: category.id,
        name: category.name,
        isActive: category.isActive ?? true,
        subcategories: subcategoriesWithProducts,
      };
      menuAvailability.push(categoryAvailability);
    }
    return menuAvailability;
  }
  async getPizzaCustomizationsAvailability(): Promise<any[]> {
    const customizationsResult = await this.pizzaCustomizationsService.findAll({
      page: 1,
      limit: 1000,
      isActive: undefined,
    });
    const groupedByType = customizationsResult.items.reduce(
      (acc, customization) => {
        const type = customization.type;
        if (!acc[type]) {
          acc[type] = [];
        }
        acc[type].push({
          id: customization.id,
          name: customization.name,
          type: customization.type,
          isActive: customization.isActive ?? true,
          sortOrder: customization.sortOrder,
        });
        return acc;
      },
      {} as Record<string, any[]>,
    );
    return Object.entries(groupedByType).map(([type, items]) => ({
      type,
      items: items.sort((a, b) => a.sortOrder - b.sortOrder),
    }));
  }
  async getModifierGroupsAvailability(): Promise<
    ModifierGroupAvailabilityDto[]
  > {
    const modifierGroupsResult = await this.modifierGroupsService.findAll({
      page: 1,
      limit: 1000,
      isActive: undefined,
    });
    const availability: ModifierGroupAvailabilityDto[] = [];
    for (const group of modifierGroupsResult.items) {
      const modifiers = await this.productModifiersService.findByGroupId(
        group.id,
      );
      availability.push({
        id: group.id,
        name: group.name,
        isActive: group.isActive ?? true,
        modifiers: modifiers.map((modifier) => ({
          id: modifier.id,
          name: modifier.name,
          isActive: modifier.isActive ?? true,
          modifierGroupId: modifier.modifierGroupId,
        })),
      });
    }
    return availability;
  }
  async updateAvailability(dto: AvailabilityUpdateDto): Promise<void> {
    const { type, id, isActive, cascade } = dto;
    switch (type) {
      case AvailabilityType.CATEGORY:
        await this.updateCategoryAvailability(id, isActive, cascade);
        break;
      case AvailabilityType.SUBCATEGORY:
        await this.updateSubcategoryAvailability(id, isActive, cascade);
        break;
      case AvailabilityType.PRODUCT:
        await this.updateProductAvailability(id, isActive);
        break;
      case AvailabilityType.MODIFIER_GROUP:
        await this.updateModifierGroupAvailability(id, isActive, cascade);
        break;
      case AvailabilityType.MODIFIER:
        await this.updateModifierAvailability(id, isActive);
        break;
      case AvailabilityType.PIZZA_CUSTOMIZATION:
        await this.updatePizzaCustomizationAvailability(id, isActive);
        break;
    }
  }
  private async updateCategoryAvailability(
    categoryId: string,
    isActive: boolean,
    cascade?: boolean,
  ): Promise<void> {
    await this.categoriesService.update(categoryId, { isActive });
    if (cascade) {
      const subcategories =
        await this.subcategoriesService.findAllByCategoryId(categoryId);
      for (const subcategory of subcategories) {
        await this.updateSubcategoryAvailability(
          subcategory.id,
          isActive,
          true,
        );
      }
    }
  }
  private async updateSubcategoryAvailability(
    subcategoryId: string,
    isActive: boolean,
    cascade?: boolean,
  ): Promise<void> {
    await this.subcategoriesService.update(subcategoryId, { isActive });
    if (cascade) {
      const products =
        await this.productsService.findAllBySubcategoryId(subcategoryId);
      for (const product of products) {
        await this.productsService.update(product.id, { isActive });
      }
    }
  }
  private async updateProductAvailability(
    productId: string,
    isActive: boolean,
  ): Promise<void> {
    await this.productsService.update(productId, { isActive });
  }
  private async updateModifierGroupAvailability(
    groupId: string,
    isActive: boolean,
    cascade?: boolean,
  ): Promise<void> {
    await this.modifierGroupsService.update(groupId, { isActive });
    if (cascade) {
      const modifiers =
        await this.productModifiersService.findByGroupId(groupId);
      for (const modifier of modifiers) {
        await this.productModifiersService.update(modifier.id, { isActive });
      }
    }
  }
  private async updateModifierAvailability(
    modifierId: string,
    isActive: boolean,
  ): Promise<void> {
    await this.productModifiersService.update(modifierId, { isActive });
  }
  private async updatePizzaCustomizationAvailability(
    customizationId: string,
    isActive: boolean,
  ): Promise<void> {
    await this.pizzaCustomizationsService.update(customizationId, { isActive });
  }
  async bulkUpdateAvailability(
    updates: AvailabilityUpdateDto[],
  ): Promise<void> {
    for (const update of updates) {
      await this.updateAvailability(update);
    }
  }
}

================
File: backend/src/availability/dto/availability-update.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsEnum, IsOptional, IsString } from 'class-validator';
export enum AvailabilityType {
  CATEGORY = 'category',
  SUBCATEGORY = 'subcategory',
  PRODUCT = 'product',
  MODIFIER_GROUP = 'modifierGroup',
  MODIFIER = 'modifier',
  PIZZA_CUSTOMIZATION = 'pizzaCustomization',
}
export class AvailabilityUpdateDto {
  @ApiProperty({
    description: 'Type of entity to update',
    enum: AvailabilityType,
  })
  @IsEnum(AvailabilityType)
  type: AvailabilityType;
  @ApiProperty({
    description: 'ID of the entity to update',
  })
  @IsString()
  id: string;
  @ApiProperty({
    description: 'New availability status',
  })
  @IsBoolean()
  isActive: boolean;
  @ApiProperty({
    description: 'Whether to cascade the update to child entities',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  cascade?: boolean;
}
export class BulkAvailabilityUpdateDto {
  @ApiProperty({
    description: 'Array of availability updates',
    type: [AvailabilityUpdateDto],
  })
  updates: AvailabilityUpdateDto[];
}

================
File: backend/src/availability/dto/menu-availability.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
export class ModifierAvailabilityDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
  @ApiProperty()
  isActive: boolean;
  @ApiProperty()
  modifierGroupId: string;
}
export class ModifierGroupAvailabilityDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
  @ApiProperty()
  isActive: boolean;
  @ApiProperty({ type: [ModifierAvailabilityDto] })
  modifiers: ModifierAvailabilityDto[];
}
export class ProductAvailabilityDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
  @ApiProperty()
  isActive: boolean;
  @ApiProperty()
  subcategoryId: string;
  @ApiProperty({ type: [ModifierGroupAvailabilityDto], required: false })
  modifierGroups?: ModifierGroupAvailabilityDto[];
}
export class SubcategoryAvailabilityDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
  @ApiProperty()
  isActive: boolean;
  @ApiProperty()
  categoryId: string;
  @ApiProperty({ type: [ProductAvailabilityDto] })
  products: ProductAvailabilityDto[];
}
export class CategoryAvailabilityDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
  @ApiProperty()
  isActive: boolean;
  @ApiProperty({ type: [SubcategoryAvailabilityDto] })
  subcategories: SubcategoryAvailabilityDto[];
}

================
File: backend/src/categories/categories.module.ts
================
import { Module } from '@nestjs/common';
import { CategoriesService } from './categories.service';
import { CategoriesController } from './categories.controller';
import { CategoriesRelationalPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [CategoriesRelationalPersistenceModule],
  controllers: [CategoriesController],
  providers: [CategoriesService],
  exports: [CategoriesService],
})
export class CategoriesModule {}

================
File: backend/src/categories/domain/category.ts
================
import { FileType } from '../../files/domain/file';
import { Subcategory } from '../../subcategories/domain/subcategory';
export class Category {
  id: string;
  name: string;
  description?: string;
  isActive: boolean;
  sortOrder: number;
  photoId: string | null;
  photo: FileType | null;
  subcategories: Subcategory[];
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/categories/dto/create-category.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  IsUUID,
  ValidateIf,
} from 'class-validator';
import { TransformDefault } from '../../utils/transformers/transform-default.decorator';
export class CreateCategoryDto {
  @ApiProperty({
    type: String,
    example: 'Bebidas',
  })
  @IsString()
  @IsNotEmpty()
  name: string;
  @ApiProperty({
    type: String,
    example: 'Bebidas sin alcohol',
    required: false,
  })
  @IsString()
  @IsOptional()
  description?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    default: true,
  })
  @TransformDefault(true)
  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((o) => o.photoId !== null)
  @IsUUID()
  photoId?: string | null;
  @ApiProperty({
    type: Number,
    example: 0,
    default: 0,
  })
  @TransformDefault(0)
  @IsNumber()
  @IsOptional()
  sortOrder?: number;
}

================
File: backend/src/categories/dto/find-all-categories.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString } from 'class-validator';
import { Transform } from 'class-transformer';
import { PaginationParams } from '../../utils/types/pagination-params';
export class FindAllCategoriesDto extends PaginationParams {
  @ApiPropertyOptional({ example: 'Bebidas' })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiPropertyOptional({
    type: Boolean,
    example: true,
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
}

================
File: backend/src/categories/dto/update-category.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNumber,
  IsOptional,
  IsString,
  IsUUID,
  ValidateIf,
} from 'class-validator';
export class UpdateCategoryDto {
  @ApiProperty({
    type: String,
    example: 'Electrónicos',
    required: false,
  })
  @IsString()
  @IsOptional()
  name?: string;
  @ApiProperty({
    type: String,
    example: 'Productos electrónicos y gadgets',
    required: false,
  })
  @IsString()
  @IsOptional()
  description?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    nullable: true,
    required: false,
  })
  @IsOptional()
  @ValidateIf((o) => o.photoId !== null)
  @IsUUID()
  photoId?: string | null;
  @ApiProperty({
    type: Number,
    example: 0,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  sortOrder?: number;
}

================
File: backend/src/categories/infrastructure/persistence/relational/entities/category.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  OneToMany,
  PrimaryColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { FileEntity } from '../../../../../files/infrastructure/persistence/relational/entities/file.entity';
import { SubcategoryEntity } from '../../../../../subcategories/infrastructure/persistence/relational/entities/subcategory.entity';
@Entity({
  name: 'category',
})
export class CategoryEntity extends EntityRelationalHelper {
  @PrimaryColumn({ type: 'varchar', length: 20 })
  id: string;
  @Column({ unique: true })
  name: string;
  @Column({ type: 'varchar', nullable: true })
  description?: string;
  @Column({ default: true })
  isActive: boolean;
  @Column({ default: 0 })
  sortOrder: number;
  @Column({ name: 'photo_id', nullable: true })
  photoId: string | null;
  @ManyToOne(() => FileEntity, { nullable: true })
  @JoinColumn({ name: 'photo_id' })
  photo: FileEntity | null;
  @OneToMany(() => SubcategoryEntity, (subcategory) => subcategory.category)
  subcategories: SubcategoryEntity[];
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/categories/infrastructure/persistence/relational/mappers/category.mapper.ts
================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { Category } from '../../../../domain/category';
import { CategoryEntity } from '../entities/category.entity';
import { FileMapper } from '../../../../../files/infrastructure/persistence/relational/mappers/file.mapper';
import { SubcategoryMapper } from '../../../../../subcategories/infrastructure/persistence/relational/mappers/subcategory.mapper';
import {
  BaseMapper,
  mapArray,
} from '../../../../../common/mappers/base.mapper';
@Injectable()
export class CategoryMapper extends BaseMapper<CategoryEntity, Category> {
  constructor(
    @Inject(forwardRef(() => SubcategoryMapper))
    private readonly subcategoryMapper: SubcategoryMapper,
    private readonly fileMapper: FileMapper,
  ) {
    super();
  }
  override toDomain(entity: CategoryEntity): Category | null {
    if (!entity) return null;
    const domain = new Category();
    domain.id = entity.id;
    domain.name = entity.name;
    domain.description = entity.description;
    domain.isActive = entity.isActive;
    domain.sortOrder = entity.sortOrder;
    domain.photoId = entity.photoId;
    domain.photo = entity.photo ? this.fileMapper.toDomain(entity.photo) : null;
    domain.subcategories = mapArray(entity.subcategories, (sub) =>
      this.subcategoryMapper.toDomain(sub),
    );
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: Category): CategoryEntity | null {
    if (!domain) return null;
    const entity = new CategoryEntity();
    if (domain.id) entity.id = domain.id;
    entity.name = domain.name;
    entity.description = domain.description;
    entity.isActive = domain.isActive;
    entity.sortOrder = domain.sortOrder;
    if (domain.photoId !== undefined) {
      entity.photoId = domain.photoId;
    }
    return entity;
  }
}

================
File: backend/src/categories/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CategoryEntity } from './entities/category.entity';
import { CategoriesRelationalRepository } from './repositories/categories.repository';
import { CategoryMapper } from './mappers/category.mapper';
import { CATEGORY_REPOSITORY } from '../../../../common/tokens';
import { RelationalSubcategoryPersistenceModule } from '../../../../subcategories/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalFilePersistenceModule } from '../../../../files/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([CategoryEntity]),
    forwardRef(() => RelationalSubcategoryPersistenceModule),
    RelationalFilePersistenceModule,
  ],
  providers: [
    {
      provide: CATEGORY_REPOSITORY,
      useClass: CategoriesRelationalRepository,
    },
    CategoryMapper,
  ],
  exports: [CATEGORY_REPOSITORY, CategoryMapper],
})
export class CategoriesRelationalPersistenceModule {}

================
File: backend/src/common/application/base-crud.service.ts
================
import { IBaseRepository } from '../domain/repositories/base.repository';
import { NullableType } from '../../utils/types/nullable.type';
import { NotFoundException } from '@nestjs/common';
export abstract class BaseCrudService<
  D extends { id: unknown },
  CreateDto,
  UpdateDto,
  FilterDto = Partial<D>,
> {
  protected constructor(
    protected readonly repo: IBaseRepository<
      D,
      FilterDto,
      CreateDto,
      UpdateDto
    >,
  ) {}
  async create(dto: CreateDto): Promise<D> {
    return this.repo.create(dto);
  }
  async findAll(filter?: FilterDto): Promise<D[]> {
    return this.repo.findAll(filter);
  }
  async findOne(id: D['id']): Promise<D> {
    const entity = await this.repo.findById(id);
    if (!entity) {
      throw new NotFoundException(
        `${this.constructor.name.replace('Service', '')} with ID ${id} not found`,
      );
    }
    return entity;
  }
  async update(id: D['id'], dto: UpdateDto): Promise<NullableType<D>> {
    return this.repo.update(id, dto);
  }
  async remove(id: D['id']): Promise<void> {
    await this.repo.remove(id);
  }
}

================
File: backend/src/common/common.module.ts
================
import { Module, Global } from '@nestjs/common';
import { UserContextService } from './services/user-context.service';
import { CustomIdService } from './services/custom-id.service';
@Global()
@Module({
  providers: [UserContextService, CustomIdService],
  exports: [UserContextService, CustomIdService],
})
export class CommonModule {}

================
File: backend/src/common/constants/error-codes.constants.ts
================
export const ERROR_CODES = {
  AUTH_INVALID_CREDENTIALS: 'AUTH_INVALID_CREDENTIALS',
  AUTH_INCORRECT_PASSWORD: 'AUTH_INCORRECT_PASSWORD',
  AUTH_DUPLICATE_EMAIL: 'AUTH_DUPLICATE_EMAIL',
  AUTH_DUPLICATE_USERNAME: 'AUTH_DUPLICATE_USERNAME',
  AUTH_EMAIL_NOT_CONFIRMED: 'AUTH_EMAIL_NOT_CONFIRMED',
  AUTH_ACCOUNT_INACTIVE: 'AUTH_ACCOUNT_INACTIVE',
  AUTH_INVALID_HASH: 'AUTH_INVALID_HASH',
  AUTH_MISSING_OLD_PASSWORD: 'AUTH_MISSING_OLD_PASSWORD',
  AUTH_INCORRECT_OLD_PASSWORD: 'AUTH_INCORRECT_OLD_PASSWORD',
  AUTH_SESSION_EXPIRED_OR_INVALID: 'AUTH_SESSION_EXPIRED_OR_INVALID',
  AUTH_UNAUTHORIZED: 'AUTH_UNAUTHORIZED',
  AUTH_FORBIDDEN: 'AUTH_FORBIDDEN',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',
  AREA_NOT_FOUND: 'AREA_NOT_FOUND',
  TABLE_NOT_FOUND: 'TABLE_NOT_FOUND',
  CATEGORY_NOT_FOUND: 'CATEGORY_NOT_FOUND',
  SUBCATEGORY_NOT_FOUND: 'SUBCATEGORY_NOT_FOUND',
  PRODUCT_NOT_FOUND: 'PRODUCT_NOT_FOUND',
  PRODUCT_VARIANT_NOT_FOUND: 'PRODUCT_VARIANT_NOT_FOUND',
  MODIFIER_GROUP_NOT_FOUND: 'MODIFIER_GROUP_NOT_FOUND',
  PRODUCT_MODIFIER_NOT_FOUND: 'PRODUCT_MODIFIER_NOT_FOUND',
  ORDER_NOT_FOUND: 'ORDER_NOT_FOUND',
  ORDER_ITEM_NOT_FOUND: 'ORDER_ITEM_NOT_FOUND',
  ORDER_ITEM_MODIFIER_NOT_FOUND: 'ORDER_ITEM_MODIFIER_NOT_FOUND',
  PAYMENT_NOT_FOUND: 'PAYMENT_NOT_FOUND',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  FILE_NOT_FOUND: 'FILE_NOT_FOUND',
  PREPARATION_SCREEN_NOT_FOUND: 'PREPARATION_SCREEN_NOT_FOUND',
  CONFLICT_ERROR: 'CONFLICT_ERROR',
  AREA_NAME_EXISTS: 'AREA_NAME_EXISTS',
  THERMAL_PRINTER_DUPLICATE_FIELD: 'THERMAL_PRINTER_DUPLICATE_FIELD',
  PRODUCT_NAME_EXISTS: 'PRODUCT_NAME_EXISTS',
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
  DATABASE_ERROR: 'DATABASE_ERROR',
  MAIL_SEND_ERROR: 'MAIL_SEND_ERROR',
  FILE_UPLOAD_ERROR: 'FILE_UPLOAD_ERROR',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR',
} as const;
export type ErrorCode = (typeof ERROR_CODES)[keyof typeof ERROR_CODES];

================
File: backend/src/common/domain/repositories/base.repository.ts
================
import { NullableType } from '../../../utils/types/nullable.type';
import { DeepPartial } from '../../../utils/types/deep-partial.type';
export interface IBaseRepository<
  TDomain extends { id: unknown },
  TFilterDto = Partial<TDomain>,
  TCreateDto = DeepPartial<TDomain>,
  TUpdateDto = DeepPartial<TDomain>,
> {
  create(data: TCreateDto): Promise<TDomain>;
  findById(id: TDomain['id']): Promise<NullableType<TDomain>>;
  findAll(filter?: TFilterDto): Promise<TDomain[]>;
  update(
    id: TDomain['id'],
    payload: TUpdateDto,
  ): Promise<NullableType<TDomain>>;
  remove(id: TDomain['id']): Promise<void>;
}

================
File: backend/src/common/dto/pagination-query.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsPositive, Max } from 'class-validator';
import { Transform } from 'class-transformer';
export class PaginationQueryDto {
  @ApiPropertyOptional({
    description: 'Page number (starting from 1)',
    example: 1,
    default: 1,
  })
  @IsOptional()
  @Transform(({ value }) => parseInt(value))
  @IsPositive()
  page?: number = 1;
  @ApiPropertyOptional({
    description: 'Number of items per page',
    example: 10,
    default: 10,
  })
  @IsOptional()
  @Transform(({ value }) => parseInt(value))
  @IsPositive()
  @Max(100)
  limit?: number = 10;
}

================
File: backend/src/common/exceptions/custom-conflict.exception.ts
================
import { ConflictException } from '@nestjs/common';
export class CustomConflictException extends ConflictException {
  constructor(message: string, code: string) {
    super({
      message,
      code,
    });
  }
}

================
File: backend/src/common/filters/http-exception.filter.ts
================
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { ERROR_CODES } from '../constants/error-codes.constants';
interface StandardErrorResponse {
  statusCode: number;
  code: string;
  message: string;
  details?: any;
  timestamp: string;
  path: string;
}
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    let status: number;
    let code: string;
    let message: string;
    let details: any | undefined;
    if (exception instanceof HttpException) {
      status = exception.getStatus();
      const exceptionResponse = exception.getResponse();
      if (typeof exceptionResponse === 'string') {
        message = exceptionResponse;
        code = this.mapHttpExceptionToCode(exception, message);
      } else if (
        typeof exceptionResponse === 'object' &&
        exceptionResponse !== null
      ) {
        if (
          status === HttpStatus.UNPROCESSABLE_ENTITY &&
          (exceptionResponse as any).errors
        ) {
          code = ERROR_CODES.VALIDATION_ERROR;
          message = (exceptionResponse as any).message || 'Error de validación';
          details = (exceptionResponse as any).errors;
        } else {
          code =
            (exceptionResponse as any).code ||
            this.mapHttpExceptionToCode(exception);
          message = (exceptionResponse as any).message || exception.message;
          details =
            (exceptionResponse as any).details ||
            (exceptionResponse as any).error;
        }
      } else {
        message = exception.message;
        code = this.mapHttpExceptionToCode(exception);
      }
    } else if (exception instanceof Error) {
      status = HttpStatus.INTERNAL_SERVER_ERROR;
      message = 'Ocurrió un error interno en el servidor.';
      code = ERROR_CODES.INTERNAL_SERVER_ERROR;
      this.logger.error(
        `Error no controlado: ${exception.message}`,
        exception.stack,
      );
    } else {
      status = HttpStatus.INTERNAL_SERVER_ERROR;
      message = 'Ocurrió un error desconocido.';
      code = ERROR_CODES.UNKNOWN_ERROR;
      this.logger.error('Excepción desconocida capturada:', exception);
    }
    const errorResponse: StandardErrorResponse = {
      statusCode: status,
      code: code || ERROR_CODES.UNKNOWN_ERROR,
      message: message,
      details: details,
      timestamp: new Date().toISOString(),
      path: request.url,
    };
    response.status(status).json(errorResponse);
  }
  private mapHttpExceptionToCode(
    exception: HttpException,
    specificMessage?: string,
  ): string {
    const status = exception.getStatus();
    switch (status) {
      case HttpStatus.BAD_REQUEST:
        return ERROR_CODES.VALIDATION_ERROR;
      case HttpStatus.UNAUTHORIZED:
        return ERROR_CODES.AUTH_UNAUTHORIZED;
      case HttpStatus.FORBIDDEN:
        return ERROR_CODES.AUTH_FORBIDDEN;
      case HttpStatus.NOT_FOUND:
        if (specificMessage?.includes('not found'))
          return ERROR_CODES.RESOURCE_NOT_FOUND;
        return ERROR_CODES.RESOURCE_NOT_FOUND;
      case HttpStatus.CONFLICT:
        if (specificMessage?.includes('already exists'))
          return ERROR_CODES.CONFLICT_ERROR;
        return ERROR_CODES.CONFLICT_ERROR;
      case HttpStatus.UNPROCESSABLE_ENTITY:
        return ERROR_CODES.VALIDATION_ERROR;
      case HttpStatus.INTERNAL_SERVER_ERROR:
        return ERROR_CODES.INTERNAL_SERVER_ERROR;
      default:
        return ERROR_CODES.UNKNOWN_ERROR;
    }
  }
}

================
File: backend/src/common/filters/unique-violation.filter.ts
================
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  Logger,
  HttpStatus,
} from '@nestjs/common';
import { QueryFailedError } from 'typeorm';
import { ERROR_CODES } from '../constants/error-codes.constants';
interface PostgresQueryFailedError extends QueryFailedError {
  code?: string;
  constraint?: string;
  detail?: string;
}
@Catch(QueryFailedError)
export class UniqueViolationFilter implements ExceptionFilter {
  private readonly logger = new Logger(UniqueViolationFilter.name);
  catch(exception: PostgresQueryFailedError, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const PG_UNIQUE_VIOLATION_CODE = '23505';
    if (exception.code === PG_UNIQUE_VIOLATION_CODE) {
      const map: Record<
        string,
        { code: string; message: (d?: string) => string }
      > = {
        uq_customer_email: {
          code: ERROR_CODES.AUTH_DUPLICATE_EMAIL,
          message: (d) =>
            `El correo electrónico ya está registrado${d ? `: ${d}` : ''}.`,
        },
        uq_customer_phone: {
          code: 'CUSTOMER_DUPLICATE_PHONE',
          message: (d) =>
            `El número de teléfono ya está registrado${d ? `: ${d}` : ''}.`,
        },
      };
      const constraint = exception.constraint;
      const meta = constraint ? map[constraint] : undefined;
      if (meta) {
        const conflictResponse = {
          statusCode: HttpStatus.CONFLICT,
          code: meta.code,
          message: meta.message(this.extractValue(exception.detail)),
        };
        response.status(HttpStatus.CONFLICT).json(conflictResponse);
        return;
      } else {
        this.logger.warn(
          `Unhandled UNIQUE constraint violation: ${constraint}`,
          exception.detail,
        );
        const genericConflictResponse = {
          statusCode: HttpStatus.CONFLICT,
          code: ERROR_CODES.CONFLICT_ERROR,
          message: 'Conflicto de datos: un valor único ya existe.',
          detail: `Constraint: ${constraint}`,
        };
        response.status(HttpStatus.CONFLICT).json(genericConflictResponse);
        return;
      }
    }
    throw exception;
  }
  private extractValue(detail?: string): string | undefined {
    if (!detail) return undefined;
    const match = detail.match(/\(([^)]+)\)=\(([^)]+)\)/);
    return match?.[2];
  }
}

================
File: backend/src/common/infrastructure/persistence/relational/base-relational.repository.ts
================
import {
  Repository,
  DeepPartial,
  FindOptionsWhere,
  ObjectLiteral,
} from 'typeorm';
import { IBaseRepository } from '../../../domain/repositories/base.repository';
import { NullableType } from '../../../../utils/types/nullable.type';
export abstract class BaseRelationalRepository<
  E extends ObjectLiteral,
  D extends { id: unknown },
  F = Partial<D>,
  C = DeepPartial<D>,
  U = DeepPartial<D>,
> implements IBaseRepository<D, F, C, U>
{
  protected constructor(
    protected readonly ormRepo: Repository<E>,
    protected readonly mapper: {
      toDomain(entity: E): D | null;
      toEntity(domain: D): E | null;
    },
  ) {}
  async create(data: C): Promise<D> {
    const entity = this.mapper.toEntity(data as unknown as D);
    const saved = await this.ormRepo.save(entity as unknown as DeepPartial<E>);
    return this.mapper.toDomain(saved as E)!;
  }
  async findById(id: D['id']): Promise<NullableType<D>> {
    const found = await this.ormRepo.findOne({
      where: { id } as unknown as FindOptionsWhere<E>,
    });
    return found ? this.mapper.toDomain(found as E) : null;
  }
  async findAll(filter?: F): Promise<D[]> {
    const where = this.buildWhere(filter);
    const entities = await this.ormRepo.find({ where });
    return entities
      .map((e) => this.mapper.toDomain(e as E))
      .filter((d): d is D => d !== null);
  }
  async update(id: D['id'], payload: U): Promise<NullableType<D>> {
    const entity = await this.ormRepo.findOne({
      where: { id } as unknown as FindOptionsWhere<E>,
    });
    if (!entity) return null;
    const domainWithId = { ...payload, id } as unknown as D;
    const mappedEntity = this.mapper.toEntity(domainWithId);
    if (!mappedEntity) return null;
    const updateData = Object.entries(mappedEntity as any).reduce(
      (acc, [key, value]) => {
        if (value !== undefined && key !== 'id') {
          acc[key] = value;
        }
        return acc;
      },
      {} as any,
    );
    await this.ormRepo.update(id as any, updateData);
    const updated = await this.ormRepo.findOne({
      where: { id } as unknown as FindOptionsWhere<E>,
    });
    return updated ? this.mapper.toDomain(updated as E) : null;
  }
  async remove(id: D['id']): Promise<void> {
    await this.ormRepo.softDelete(id as any);
  }
  protected buildWhere(_filter?: F): FindOptionsWhere<E> | undefined {
    return undefined;
  }
}

================
File: backend/src/common/interceptors/user-context.interceptor.ts
================
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { UserContextService } from '../services/user-context.service';
@Injectable()
export class UserContextInterceptor implements NestInterceptor {
  constructor(private readonly userContextService: UserContextService) {}
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    if (user) {
      return new Observable((observer) => {
        this.userContextService
          .runWithUser(
            {
              userId: user.id,
              email: user.email,
              firstName: user.firstName,
              lastName: user.lastName,
            },
            async () => {
              try {
                const result = await next.handle().toPromise();
                observer.next(result);
                observer.complete();
              } catch (error) {
                observer.error(error);
              }
            },
          )
          .catch((error) => observer.error(error));
      });
    }
    return next.handle();
  }
}

================
File: backend/src/common/mappers/base.mapper.ts
================
export interface IMapper<E, D> {
  toDomain(entity: E): D | null;
  toEntity(domain: D): E | null;
}
export abstract class BaseMapper<E, D> implements IMapper<E, D> {
  abstract toDomain(entity: E): D | null;
  abstract toEntity(domain: D): E | null;
  protected isEmpty(value: unknown): boolean {
    return value === undefined || value === null;
  }
}
export const mapArray = <F, T>(
  items: F[] | null | undefined,
  mapper: (item: F) => T | null,
): T[] => (items ?? []).map(mapper).filter((x): x is T => x !== null);

================
File: backend/src/common/presentation/crud-controller.factory.ts
================
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Post,
  Query,
  Type,
  HttpCode,
  HttpStatus,
  UseGuards,
} from '@nestjs/common';
import { ApiTags, ApiBearerAuth, ApiOperation } from '@nestjs/swagger';
import { BaseCrudService } from '../application/base-crud.service';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../../roles/roles.guard';
import { Roles } from '../../roles/roles.decorator';
import { RoleEnum } from '../../roles/roles.enum';
export interface CrudControllerOptions {
  path: string;
  swaggerTag?: string;
  createRoles?: RoleEnum[];
  updateRoles?: RoleEnum[];
  removeRoles?: RoleEnum[];
}
export interface ICrudController<D, CreateDto, UpdateDto, FilterDto> {
  create(dto: CreateDto): Promise<D>;
  findAll(q: FilterDto): Promise<D[]>;
  findOne(id: string): Promise<D>;
  update(id: string, dto: UpdateDto): Promise<D | null>;
  remove(id: string): Promise<void>;
}
export function CrudControllerFactory<
  D extends { id: unknown },
  CreateDto,
  UpdateDto,
  FilterDto,
  S extends BaseCrudService<D, CreateDto, UpdateDto, FilterDto>,
>(
  options: CrudControllerOptions,
): Type<ICrudController<D, CreateDto, UpdateDto, FilterDto>> {
  const {
    path,
    swaggerTag,
    createRoles = [RoleEnum.admin],
    updateRoles = [RoleEnum.admin],
    removeRoles = [RoleEnum.admin],
  } = options;
  @ApiTags(swaggerTag ?? path)
  @Controller({ path, version: '1' })
  class CrudController
    implements ICrudController<D, CreateDto, UpdateDto, FilterDto>
  {
    constructor(protected readonly service: S) {}
    @Post()
    @ApiOperation({ summary: `Create a new ${swaggerTag ?? path}` })
    @ApiBearerAuth()
    @UseGuards(AuthGuard('jwt'), RolesGuard)
    @Roles(...createRoles)
    @HttpCode(HttpStatus.CREATED)
    create(@Body() dto: CreateDto): Promise<D> {
      return this.service.create(dto);
    }
    @Get()
    @ApiOperation({ summary: `Find all ${swaggerTag ?? path}` })
    @HttpCode(HttpStatus.OK)
    findAll(@Query() q: FilterDto): Promise<D[]> {
      return this.service.findAll(q);
    }
    @Get(':id')
    @ApiOperation({ summary: `Find one ${swaggerTag ?? path} by ID` })
    @HttpCode(HttpStatus.OK)
    findOne(@Param('id') id: D['id']): Promise<D> {
      return this.service.findOne(id);
    }
    @Patch(':id')
    @ApiOperation({ summary: `Update a ${swaggerTag ?? path}` })
    @ApiBearerAuth()
    @UseGuards(AuthGuard('jwt'), RolesGuard)
    @Roles(...updateRoles)
    @HttpCode(HttpStatus.OK)
    update(
      @Param('id') id: D['id'],
      @Body() dto: UpdateDto,
    ): Promise<D | null> {
      return this.service.update(id, dto);
    }
    @Delete(':id')
    @ApiOperation({ summary: `Remove a ${swaggerTag ?? path}` })
    @ApiBearerAuth()
    @UseGuards(AuthGuard('jwt'), RolesGuard)
    @Roles(...removeRoles)
    @HttpCode(HttpStatus.NO_CONTENT)
    async remove(@Param('id') id: D['id']): Promise<void> {
      await this.service.remove(id);
    }
  }
  return CrudController;
}

================
File: backend/src/common/services/custom-id.service.ts
================
import { Injectable } from '@nestjs/common';
import { DataSource } from 'typeorm';
export enum EntityPrefix {
  CATEGORY = 'CAT',
  SUBCATEGORY = 'SUB',
  PRODUCT = 'PR',
  PRODUCT_VARIANT = 'PVA',
  MODIFIER_GROUP = 'MODG',
  MODIFIER = 'MOD',
  PIZZA_CUSTOMIZATION = 'PI',
}
@Injectable()
export class CustomIdService {
  constructor(private readonly dataSource: DataSource) {}
  async generateId(prefix: EntityPrefix, tableName: string): Promise<string> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    try {
      await queryRunner.startTransaction();
      const result = await queryRunner.query(
        `SELECT MAX(CAST(SUBSTRING(id FROM LENGTH($1) + 2) AS INTEGER)) as max_num
         FROM "${tableName}"
         WHERE id LIKE $1 || '-%'`,
        [prefix],
      );
      const maxNum = result[0]?.max_num || 0;
      const nextNum = maxNum + 1;
      const newId = `${prefix}-${nextNum}`;
      await queryRunner.commitTransaction();
      return newId;
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }
}

================
File: backend/src/common/services/user-context.service.ts
================
import { Injectable } from '@nestjs/common';
import { AsyncLocalStorage } from 'async_hooks';
export interface UserContext {
  userId: string;
  email: string;
  firstName?: string;
  lastName?: string;
}
@Injectable()
export class UserContextService {
  private asyncLocalStorage = new AsyncLocalStorage<UserContext>();
  async runWithUser<T>(user: UserContext, fn: () => Promise<T>): Promise<T> {
    return this.asyncLocalStorage.run(user, fn);
  }
  getCurrentUser(): UserContext | undefined {
    return this.asyncLocalStorage.getStore();
  }
  getCurrentUserId(): string | undefined {
    const user = this.getCurrentUser();
    return user?.userId;
  }
}

================
File: backend/src/common/types/paginated.type.ts
================
import { ApiProperty } from '@nestjs/swagger';
export class Paginated<T> {
  @ApiProperty({ isArray: true })
  items: T[];
  @ApiProperty({ type: Number, example: 100 })
  total: number;
  @ApiProperty({ type: Number, example: 1 })
  page: number;
  @ApiProperty({ type: Number, example: 10 })
  limit: number;
  @ApiProperty({ type: Boolean })
  hasNextPage: boolean;
  @ApiProperty({ type: Boolean })
  hasPrevPage: boolean;
  constructor(items: T[], total: number, page: number, limit: number) {
    this.items = items;
    this.total = total;
    this.page = page;
    this.limit = limit;
    this.hasNextPage = page * limit < total;
    this.hasPrevPage = page > 1;
  }
}

================
File: backend/src/config/config.type.ts
================
import { AppConfig } from './app-config.type';
import { AuthConfig } from '../auth/config/auth-config.type';
import { DatabaseConfig } from '../database/config/database-config.type';
import { FileConfig } from '../files/config/file-config.type';
import { MailConfig } from '../mail/config/mail-config.type';
export type AllConfigType = {
  app: AppConfig;
  auth: AuthConfig;
  database: DatabaseConfig;
  file: FileConfig;
  mail: MailConfig;
};

================
File: backend/src/customers/customers.module.ts
================
import { Module } from '@nestjs/common';
import { CustomersService } from './customers.service';
import { CustomersController } from './customers.controller';
import { RelationalCustomerPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { AuthModule } from '../auth/auth.module';
import { AddressesService } from './addresses.service';
import { AddressesController } from './addresses.controller';
const infrastructurePersistenceModule = RelationalCustomerPersistenceModule;
@Module({
  imports: [infrastructurePersistenceModule, AuthModule],
  controllers: [CustomersController, AddressesController],
  providers: [CustomersService, AddressesService],
  exports: [
    CustomersService,
    AddressesService,
    infrastructurePersistenceModule,
  ],
})
export class CustomersModule {}

================
File: backend/src/customers/domain/address.ts
================
import { Customer } from './customer';
export class Address {
  id: string;
  customerId: string;
  name: string;
  street: string;
  number: string;
  interiorNumber?: string;
  neighborhood?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault: boolean;
  customer: Customer;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/customers/domain/customer.ts
================
import { Address } from './address';
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
}
export class Customer {
  id: string;
  firstName: string | null;
  lastName: string | null;
  whatsappPhoneNumber: string;
  stripeCustomerId: string | null;
  email: string | null;
  birthDate: Date | null;
  fullChatHistory: ChatMessage[] | null;
  relevantChatHistory: ChatMessage[] | null;
  lastInteraction: Date | null;
  totalOrders: number;
  totalSpent: number;
  isActive: boolean;
  isBanned: boolean;
  bannedAt: Date | null;
  banReason: string | null;
  addresses: Address[];
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/customers/dto/ban-customer.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, MaxLength } from 'class-validator';
export class BanCustomerDto {
  @ApiProperty({
    description: 'Razón por la cual se está baneando al cliente',
    example: 'Comportamiento inapropiado con el personal del restaurante',
  })
  @IsNotEmpty()
  @IsString()
  @MaxLength(500)
  banReason: string;
}

================
File: backend/src/customers/dto/create-address.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNotEmpty,
  IsOptional,
  IsString,
  MaxLength,
  IsUUID,
  IsNumber,
  IsLatitude,
  IsLongitude,
} from 'class-validator';
export class CreateAddressDto {
  @ApiProperty({
    example: 'uuid-cliente',
    description:
      'ID del cliente al que pertenece la dirección (requerido si no se usa la ruta anidada)',
  })
  @IsUUID()
  @IsOptional()
  customerId?: string;
  @ApiProperty({
    type: String,
    example: 'Casa',
    description:
      'Nombre o identificador de la dirección (ej: Casa, Oficina, Casa de mamá)',
  })
  @IsNotEmpty({ message: 'El nombre de la dirección es obligatorio' })
  @IsString()
  @MaxLength(100)
  name: string;
  @ApiProperty({
    type: String,
    example: 'Calle Falsa',
    description: 'Nombre de la calle',
  })
  @IsNotEmpty({ message: 'La calle es obligatoria' })
  @IsString()
  @MaxLength(200)
  street: string;
  @ApiPropertyOptional({
    type: String,
    example: '123',
    description: 'Número exterior',
  })
  @IsNotEmpty({ message: 'El número exterior es obligatorio' })
  @IsString()
  @MaxLength(50)
  number: string;
  @ApiPropertyOptional({
    type: String,
    example: 'A',
    description: 'Número interior o departamento',
  })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  interiorNumber?: string;
  @ApiProperty({
    type: String,
    example: 'Colonia Centro',
    description: 'Colonia o barrio',
  })
  @IsNotEmpty({ message: 'La colonia es obligatoria' })
  @IsString()
  @MaxLength(150)
  neighborhood: string;
  @ApiProperty({
    type: String,
    example: 'Ciudad Ejemplo',
    description: 'Ciudad',
  })
  @IsNotEmpty({ message: 'La ciudad es obligatoria' })
  @IsString()
  @MaxLength(100)
  city: string;
  @ApiProperty({
    type: String,
    example: 'Estado Ejemplo',
    description: 'Estado o provincia',
  })
  @IsNotEmpty({ message: 'El estado es obligatorio' })
  @IsString()
  @MaxLength(100)
  state: string;
  @ApiProperty({
    type: String,
    example: '12345',
    description: 'Código postal',
  })
  @IsNotEmpty({ message: 'El código postal es obligatorio' })
  @IsString()
  @MaxLength(10)
  zipCode: string;
  @ApiProperty({
    type: String,
    example: 'México',
    description: 'País',
  })
  @IsNotEmpty({ message: 'El país es obligatorio' })
  @IsString()
  @MaxLength(100)
  country: string;
  @ApiPropertyOptional({
    type: String,
    example: 'Entre Calle A y Calle B, portón verde',
    description: 'Instrucciones adicionales para la entrega',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  deliveryInstructions?: string;
  @ApiPropertyOptional({
    type: Number,
    example: 19.4326,
    description: 'Latitud de la ubicación',
    minimum: -90,
    maximum: 90,
  })
  @IsOptional()
  @IsNumber()
  @IsLatitude()
  latitude?: number;
  @ApiPropertyOptional({
    type: Number,
    example: -99.1332,
    description: 'Longitud de la ubicación',
    minimum: -180,
    maximum: 180,
  })
  @IsOptional()
  @IsNumber()
  @IsLongitude()
  longitude?: number;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    default: false,
    description: 'Indica si es la dirección predeterminada del cliente',
  })
  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;
}

================
File: backend/src/customers/dto/find-all-addresses.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString, IsUUID } from 'class-validator';
import { Transform } from 'class-transformer';
export class FindAllAddressesDto {
  @ApiPropertyOptional({
    description:
      'Filtrar por ID del cliente (generalmente inyectado desde el parámetro de ruta)',
    example: 'a1b2c3d4-e5f6-7890-1234-567890abcdef',
  })
  @IsOptional()
  @IsUUID()
  customerId?: string;
  @ApiPropertyOptional({
    description: 'Filtrar por si es la dirección predeterminada',
    type: Boolean,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isDefault?: boolean;
  @ApiPropertyOptional({
    description: 'Filtrar por código postal',
    example: '12345',
  })
  @IsOptional()
  @IsString()
  zipCode?: string;
  @ApiPropertyOptional({
    description:
      'Filtrar por ciudad (búsqueda parcial, insensible a mayúsculas)',
    example: 'Ejemplo',
  })
  @IsOptional()
  @IsString()
  city?: string;
}

================
File: backend/src/customers/dto/update-address.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsBoolean,
  IsOptional,
  IsString,
  IsUUID,
  MaxLength,
  IsNumber,
  IsLatitude,
  IsLongitude,
} from 'class-validator';
export class UpdateAddressDto {
  @ApiPropertyOptional({
    type: String,
    example: 'a1b2c3d4-e5f6-7890-1234-567890abcdef',
    description:
      'ID de la dirección a actualizar (omitir para crear una nueva dirección dentro de una actualización de cliente)',
  })
  @IsOptional()
  @IsUUID()
  id?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'Casa',
    description:
      'Nombre o identificador de la dirección (ej: Casa, Oficina, Casa de mamá)',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  name?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'Calle Falsa',
    description: 'Nombre de la calle',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  street?: string;
  @ApiPropertyOptional({
    type: String,
    example: '123',
    description: 'Número exterior',
  })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  number?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'A',
    description: 'Número interior o departamento',
  })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  interiorNumber?: string | null;
  @ApiPropertyOptional({
    type: String,
    example: 'Colonia Centro',
    description: 'Colonia o barrio',
  })
  @IsOptional()
  @IsString()
  @MaxLength(150)
  neighborhood?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'Ciudad Ejemplo',
    description: 'Ciudad',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  city?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'Estado Ejemplo',
    description: 'Estado o provincia',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  state?: string;
  @ApiPropertyOptional({
    type: String,
    example: '12345',
    description: 'Código postal',
  })
  @IsOptional()
  @IsString()
  @MaxLength(10)
  zipCode?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'México',
    description: 'País',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  country?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'Entre Calle A y Calle B, portón verde',
    description: 'Instrucciones adicionales para la entrega',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  deliveryInstructions?: string | null;
  @ApiPropertyOptional({
    type: Number,
    example: 19.4326,
    description: 'Latitud de la ubicación',
    minimum: -90,
    maximum: 90,
  })
  @IsOptional()
  @IsNumber()
  @IsLatitude()
  latitude?: number | null;
  @ApiPropertyOptional({
    type: Number,
    example: -99.1332,
    description: 'Longitud de la ubicación',
    minimum: -180,
    maximum: 180,
  })
  @IsOptional()
  @IsNumber()
  @IsLongitude()
  longitude?: number | null;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    description: 'Indica si es la dirección predeterminada del cliente',
  })
  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;
}

================
File: backend/src/customers/infrastructure/persistence/customer.repository.ts
================
import { NullableType } from '../../../utils/types/nullable.type';
import { Customer } from '../../domain/customer';
import { FindAllCustomersDto } from '../../dto/find-all-customers.dto';
import { IBaseRepository } from '../../../common/domain/repositories/base.repository';
import { CreateCustomerDto } from '../../dto/create-customer.dto';
import { UpdateCustomerDto } from '../../dto/update-customer.dto';
export abstract class CustomerRepository
  implements
    IBaseRepository<
      Customer,
      FindAllCustomersDto,
      CreateCustomerDto,
      UpdateCustomerDto
    >
{
  abstract create(data: CreateCustomerDto): Promise<Customer>;
  abstract findById(id: Customer['id']): Promise<NullableType<Customer>>;
  abstract findAll(filter?: FindAllCustomersDto): Promise<Customer[]>;
  abstract update(
    id: Customer['id'],
    payload: UpdateCustomerDto,
  ): Promise<NullableType<Customer>>;
  abstract remove(id: Customer['id']): Promise<void>;
  abstract findByEmail(
    email: Customer['email'],
  ): Promise<NullableType<Customer>>;
  abstract findByPhone(
    phone: Customer['whatsappPhoneNumber'],
  ): Promise<NullableType<Customer>>;
  abstract findBannedCustomers(): Promise<Customer[]>;
}

================
File: backend/src/customers/infrastructure/persistence/relational/entities/address.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  Index,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
  RelationId,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { CustomerEntity } from './customer.entity';
@Entity({
  name: 'address',
})
export class AddressEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @RelationId((address: AddressEntity) => address.customer)
  customerId: string;
  @ManyToOne(() => CustomerEntity, (customer) => customer.addresses, {
    nullable: false,
    onDelete: 'CASCADE',
  })
  @JoinColumn({ name: 'customer_id' })
  customer: CustomerEntity;
  @Column({ type: 'varchar', length: 100, nullable: false })
  name: string;
  @Column({ type: 'varchar', length: 200 })
  street: string;
  @Column({ type: 'varchar', length: 50, nullable: false })
  number: string;
  @Column({ type: 'varchar', length: 50, nullable: true })
  interiorNumber: string | null;
  @Column({ type: 'varchar', length: 150, nullable: true })
  neighborhood: string | null;
  @Column({ type: 'varchar', length: 100, nullable: true })
  city: string | null;
  @Column({ type: 'varchar', length: 100, nullable: true })
  state: string | null;
  @Index()
  @Column({ type: 'varchar', length: 10, nullable: true })
  zipCode: string | null;
  @Column({ type: 'varchar', length: 100, nullable: true })
  country: string | null;
  @Column({ type: 'text', nullable: true, name: 'delivery_instructions' })
  deliveryInstructions: string | null;
  @Column({ type: 'decimal', precision: 10, scale: 8, nullable: true })
  latitude: number | null;
  @Column({ type: 'decimal', precision: 11, scale: 8, nullable: true })
  longitude: number | null;
  @Column({ type: 'boolean', default: false })
  isDefault: boolean;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/customers/infrastructure/persistence/relational/entities/customer.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  Index,
  OneToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { AddressEntity } from './address.entity';
import { OrderEntity } from '../../../../../orders/infrastructure/persistence/relational/entities/order.entity';
@Entity({
  name: 'customer',
})
export class CustomerEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Index()
  @Column({ type: 'varchar', length: 100, nullable: true })
  firstName: string | null;
  @Index()
  @Column({ type: 'varchar', length: 100, nullable: true })
  lastName: string | null;
  @Index('uq_customer_whatsapp', { unique: true })
  @Column({ type: 'varchar', length: 20 })
  whatsappPhoneNumber: string;
  @Column({ type: 'varchar', length: 255, nullable: true })
  stripeCustomerId: string | null;
  @Index('uq_customer_email', { unique: true, where: 'email IS NOT NULL' })
  @Column({ type: 'varchar', length: 255, nullable: true })
  email: string | null;
  @Column({ type: 'date', nullable: true })
  birthDate: Date | null;
  @Column({ type: 'jsonb', nullable: true })
  fullChatHistory: any[] | null;
  @Column({ type: 'jsonb', nullable: true })
  relevantChatHistory: any[] | null;
  @Column({ type: 'timestamptz', nullable: true })
  lastInteraction: Date | null;
  @Column({ type: 'int', default: 0 })
  totalOrders: number;
  @Column({ type: 'decimal', precision: 10, scale: 2, default: 0 })
  totalSpent: number;
  @Column({ type: 'boolean', default: true })
  isActive: boolean;
  @Column({ type: 'boolean', default: false })
  isBanned: boolean;
  @Column({ type: 'timestamptz', nullable: true })
  bannedAt: Date | null;
  @Column({ type: 'text', nullable: true })
  banReason: string | null;
  @OneToMany(() => AddressEntity, (address) => address.customer)
  addresses: AddressEntity[];
  @OneToMany(() => OrderEntity, (order) => order.customer)
  orders: OrderEntity[];
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/customers/infrastructure/persistence/relational/mappers/address.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { Address } from '../../../../domain/address';
import { AddressEntity } from '../entities/address.entity';
import { CustomerEntity } from '../entities/customer.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class AddressMapper extends BaseMapper<AddressEntity, Address> {
  override toDomain(entity: AddressEntity): Address | null {
    if (!entity) {
      return null;
    }
    const domain = new Address();
    domain.id = entity.id;
    domain.customerId = entity.customerId;
    domain.name = entity.name;
    domain.street = entity.street;
    domain.number = entity.number;
    domain.interiorNumber = entity.interiorNumber ?? undefined;
    domain.neighborhood = entity.neighborhood ?? undefined;
    domain.city = entity.city ?? undefined;
    domain.state = entity.state ?? undefined;
    domain.zipCode = entity.zipCode ?? undefined;
    domain.country = entity.country ?? undefined;
    domain.deliveryInstructions = entity.deliveryInstructions ?? undefined;
    domain.latitude = entity.latitude ?? undefined;
    domain.longitude = entity.longitude ?? undefined;
    domain.isDefault = entity.isDefault;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: Address): AddressEntity | null {
    if (!domain) {
      return null;
    }
    const entity = new AddressEntity();
    entity.id = domain.id;
    entity.customer = { id: domain.customerId } as CustomerEntity;
    entity.name = domain.name;
    entity.street = domain.street;
    entity.number = domain.number;
    entity.interiorNumber = domain.interiorNumber ?? null;
    entity.neighborhood = domain.neighborhood ?? null;
    entity.city = domain.city ?? null;
    entity.state = domain.state ?? null;
    entity.zipCode = domain.zipCode ?? null;
    entity.country = domain.country ?? null;
    entity.deliveryInstructions = domain.deliveryInstructions ?? null;
    entity.latitude = domain.latitude ?? null;
    entity.longitude = domain.longitude ?? null;
    entity.isDefault = domain.isDefault;
    return entity;
  }
}

================
File: backend/src/customers/infrastructure/persistence/relational/mappers/customer.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { Customer } from '../../../../domain/customer';
import { CustomerEntity } from '../entities/customer.entity';
import { AddressMapper } from './address.mapper';
import {
  BaseMapper,
  mapArray,
} from '../../../../../common/mappers/base.mapper';
@Injectable()
export class CustomerMapper extends BaseMapper<CustomerEntity, Customer> {
  constructor(private readonly addressMapper: AddressMapper) {
    super();
  }
  override toDomain(entity: CustomerEntity): Customer | null {
    if (!entity) {
      return null;
    }
    const domain = new Customer();
    domain.id = entity.id;
    domain.firstName = entity.firstName;
    domain.lastName = entity.lastName;
    domain.whatsappPhoneNumber = entity.whatsappPhoneNumber;
    domain.stripeCustomerId = entity.stripeCustomerId;
    domain.email = entity.email;
    domain.birthDate = entity.birthDate;
    domain.fullChatHistory = entity.fullChatHistory;
    domain.relevantChatHistory = entity.relevantChatHistory;
    domain.lastInteraction = entity.lastInteraction;
    domain.totalOrders = entity.totalOrders;
    domain.totalSpent = entity.totalSpent;
    domain.isActive = entity.isActive;
    domain.isBanned = entity.isBanned;
    domain.bannedAt = entity.bannedAt;
    domain.banReason = entity.banReason;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    domain.addresses = mapArray(entity.addresses, (addressEntity) =>
      this.addressMapper.toDomain(addressEntity),
    );
    return domain;
  }
  override toEntity(domain: Customer): CustomerEntity | null {
    if (!domain) {
      return null;
    }
    const entity = new CustomerEntity();
    entity.id = domain.id;
    entity.firstName = domain.firstName ?? null;
    entity.lastName = domain.lastName ?? null;
    entity.whatsappPhoneNumber = domain.whatsappPhoneNumber;
    entity.stripeCustomerId = domain.stripeCustomerId ?? null;
    entity.email = domain.email ?? null;
    entity.birthDate = domain.birthDate ?? null;
    entity.fullChatHistory = domain.fullChatHistory ?? null;
    entity.relevantChatHistory = domain.relevantChatHistory ?? null;
    entity.lastInteraction = domain.lastInteraction ?? null;
    entity.totalOrders = domain.totalOrders ?? 0;
    entity.totalSpent = domain.totalSpent ?? 0;
    entity.isActive = domain.isActive ?? true;
    entity.isBanned = domain.isBanned ?? false;
    entity.bannedAt = domain.bannedAt ?? null;
    entity.banReason = domain.banReason ?? null;
    return entity;
  }
}

================
File: backend/src/customers/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CustomerEntity } from './entities/customer.entity';
import { AddressEntity } from './entities/address.entity';
import { CustomerRelationalRepository } from './repositories/customer.repository';
import { AddressRelationalRepository } from './repositories/address.repository';
import { CustomerMapper } from './mappers/customer.mapper';
import { AddressMapper } from './mappers/address.mapper';
import { CUSTOMER_REPOSITORY } from '../../../../common/tokens';
import { ADDRESS_REPOSITORY } from '../../../../common/tokens';
@Module({
  imports: [TypeOrmModule.forFeature([CustomerEntity, AddressEntity])],
  providers: [
    {
      provide: CUSTOMER_REPOSITORY,
      useClass: CustomerRelationalRepository,
    },
    {
      provide: ADDRESS_REPOSITORY,
      useClass: AddressRelationalRepository,
    },
    CustomerMapper,
    AddressMapper,
  ],
  exports: [
    CUSTOMER_REPOSITORY,
    ADDRESS_REPOSITORY,
    CustomerMapper,
    AddressMapper,
  ],
})
export class RelationalCustomerPersistenceModule {}

================
File: backend/src/database/config/database-config.type.ts
================
export type DatabaseConfig = {
  isDocumentDatabase: boolean;
  url?: string;
  type?: string;
  host?: string;
  port?: number;
  password?: string;
  name?: string;
  username?: string;
  synchronize?: boolean;
  maxConnections: number;
  sslEnabled?: boolean;
  rejectUnauthorized?: boolean;
  ca?: string;
  key?: string;
  cert?: string;
};

================
File: backend/src/database/config/database.config.ts
================
import { registerAs } from '@nestjs/config';
import {
  IsOptional,
  IsInt,
  Min,
  Max,
  IsString,
  ValidateIf,
  IsBoolean,
} from 'class-validator';
import validateConfig from '../../utils/validate-config';
import { DatabaseConfig } from './database-config.type';
class EnvironmentVariablesValidator {
  @ValidateIf((envValues) => envValues.DATABASE_URL)
  @IsString()
  DATABASE_URL: string;
  @ValidateIf((envValues) => !envValues.DATABASE_URL)
  @IsString()
  DATABASE_TYPE: string;
  @ValidateIf((envValues) => !envValues.DATABASE_URL)
  @IsString()
  DATABASE_HOST: string;
  @ValidateIf((envValues) => !envValues.DATABASE_URL)
  @IsInt()
  @Min(0)
  @Max(65535)
  DATABASE_PORT: number;
  @ValidateIf((envValues) => !envValues.DATABASE_URL)
  @IsString()
  DATABASE_PASSWORD: string;
  @ValidateIf((envValues) => !envValues.DATABASE_URL)
  @IsString()
  DATABASE_NAME: string;
  @ValidateIf((envValues) => !envValues.DATABASE_URL)
  @IsString()
  DATABASE_USERNAME: string;
  @IsBoolean()
  @IsOptional()
  DATABASE_SYNCHRONIZE: boolean;
  @IsInt()
  @IsOptional()
  DATABASE_MAX_CONNECTIONS: number;
  @IsBoolean()
  @IsOptional()
  DATABASE_SSL_ENABLED: boolean;
  @IsBoolean()
  @IsOptional()
  DATABASE_REJECT_UNAUTHORIZED: boolean;
  @IsString()
  @IsOptional()
  DATABASE_CA: string;
  @IsString()
  @IsOptional()
  DATABASE_KEY: string;
  @IsString()
  @IsOptional()
  DATABASE_CERT: string;
}
export default registerAs<DatabaseConfig>('database', () => {
  validateConfig(process.env, EnvironmentVariablesValidator);
  return {
    isDocumentDatabase: ['mongodb'].includes(process.env.DATABASE_TYPE ?? ''),
    url: process.env.DATABASE_URL,
    type: process.env.DATABASE_TYPE,
    host: process.env.DATABASE_HOST,
    port: process.env.DATABASE_PORT
      ? parseInt(process.env.DATABASE_PORT, 10)
      : 5432,
    password: process.env.DATABASE_PASSWORD,
    name: process.env.DATABASE_NAME,
    username: process.env.DATABASE_USERNAME,
    synchronize: process.env.DATABASE_SYNCHRONIZE === 'true',
    maxConnections: process.env.DATABASE_MAX_CONNECTIONS
      ? parseInt(process.env.DATABASE_MAX_CONNECTIONS, 10)
      : 100,
    sslEnabled: process.env.DATABASE_SSL_ENABLED === 'true',
    rejectUnauthorized: process.env.DATABASE_REJECT_UNAUTHORIZED === 'true',
    ca: process.env.DATABASE_CA,
    key: process.env.DATABASE_KEY,
    cert: process.env.DATABASE_CERT,
  };
});

================
File: backend/src/database/seeds/relational/area/area-seed.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AreaSeedService } from './area-seed.service';
import { AreaEntity } from '../../../../areas/infrastructure/persistence/relational/entities/area.entity';
@Module({
  imports: [TypeOrmModule.forFeature([AreaEntity])],
  providers: [AreaSeedService],
  exports: [AreaSeedService],
})
export class AreaSeedModule {}

================
File: backend/src/database/seeds/relational/area/area-seed.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { AreaEntity } from '../../../../areas/infrastructure/persistence/relational/entities/area.entity';
@Injectable()
export class AreaSeedService {
  constructor(
    @InjectRepository(AreaEntity)
    private repository: Repository<AreaEntity>,
  ) {}
  async run() {
    const areas = [
      {
        name: 'Bar',
        description: 'Área de bar con servicio de bebidas',
        isActive: true,
      },
      {
        name: 'Arco',
        description: 'Área con vista al arco',
        isActive: true,
      },
      {
        name: 'Jardin',
        description: 'Área exterior en el jardín',
        isActive: true,
      },
      {
        name: 'Entrada',
        description: 'Área de entrada principal',
        isActive: true,
      },
      {
        name: 'Equipales',
        description: 'Área con equipales tradicionales',
        isActive: true,
      },
    ];
    for (const areaData of areas) {
      const existingArea = await this.repository.findOne({
        where: { name: areaData.name },
      });
      if (!existingArea) {
        await this.repository.save(this.repository.create(areaData));
      }
    }
  }
}

================
File: backend/src/database/seeds/relational/insert-missing-roles.ts
================
import { DataSource } from 'typeorm';
import { RoleEntity } from '../../../roles/infrastructure/persistence/relational/entities/role.entity';
import { RoleEnum } from '../../../roles/roles.enum';
import * as dotenv from 'dotenv';
dotenv.config();
async function insertMissingRoles() {
  const dataSource = new DataSource({
    type: 'postgres',
    host: process.env.DATABASE_HOST || 'localhost',
    port: parseInt(process.env.DATABASE_PORT || '5432', 10),
    username: process.env.DATABASE_USERNAME || 'postgres',
    password: process.env.DATABASE_PASSWORD || 'secret',
    database: process.env.DATABASE_NAME || 'nestjs-boilerplate',
    entities: [RoleEntity],
    synchronize: false,
  });
  try {
    await dataSource.initialize();
    const roleRepository = dataSource.getRepository(RoleEntity);
    const rolesToInsert = [
      { id: RoleEnum.admin, name: 'Admin' },
      { id: RoleEnum.manager, name: 'Manager' },
      { id: RoleEnum.cashier, name: 'Cashier' },
      { id: RoleEnum.waiter, name: 'Waiter' },
      { id: RoleEnum.kitchen, name: 'Kitchen' },
      { id: RoleEnum.delivery, name: 'Delivery' },
    ];
    for (const role of rolesToInsert) {
      try {
        const exists = await roleRepository.findOne({ where: { id: role.id } });
        if (!exists) {
          await roleRepository.save(role);
        } else {
        }
      } catch {}
    }
    await dataSource.destroy();
  } catch {
    process.exit(1);
  }
}
void insertMissingRoles();

================
File: backend/src/database/seeds/relational/preparation-screen/preparation-screen-seed.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PreparationScreenSeedService } from './preparation-screen-seed.service';
import { PreparationScreenEntity } from '../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import { UserEntity } from '../../../../users/infrastructure/persistence/relational/entities/user.entity';
@Module({
  imports: [TypeOrmModule.forFeature([PreparationScreenEntity, UserEntity])],
  providers: [PreparationScreenSeedService],
  exports: [PreparationScreenSeedService],
})
export class PreparationScreenSeedModule {}

================
File: backend/src/database/seeds/relational/preparation-screen/preparation-screen-seed.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { PreparationScreenEntity } from '../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import { UserEntity } from '../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { RoleEnum } from '../../../../roles/roles.enum';
@Injectable()
export class PreparationScreenSeedService {
  constructor(
    @InjectRepository(PreparationScreenEntity)
    private preparationScreenRepository: Repository<PreparationScreenEntity>,
    @InjectRepository(UserEntity)
    private userRepository: Repository<UserEntity>,
  ) {}
  async run() {
    const kitchenUsers = await this.userRepository.find({
      where: {
        role: {
          id: RoleEnum.kitchen,
        },
      },
      order: {
        username: 'ASC',
      },
    });
    if (kitchenUsers.length < 3) {
      return;
    }
    const preparationScreensData = [
      {
        name: 'Pizza',
        description: 'Pantalla de preparación para pizzas',
        user: kitchenUsers[0],
      },
      {
        name: 'Hamburguesas',
        description: 'Pantalla de preparación para hamburguesas',
        user: kitchenUsers[1],
      },
      {
        name: 'Bar',
        description: 'Pantalla de preparación para bebidas y bar',
        user: kitchenUsers[2],
      },
    ];
    for (const screenData of preparationScreensData) {
      const existingScreen = await this.preparationScreenRepository.findOne({
        where: { name: screenData.name },
      });
      if (!existingScreen) {
        const screen = this.preparationScreenRepository.create({
          name: screenData.name,
          description: screenData.description,
          isActive: true,
          users: [screenData.user],
        });
        await this.preparationScreenRepository.save(screen);
      }
    }
  }
}

================
File: backend/src/database/seeds/relational/product/product-seed.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CategoryEntity } from '../../../../categories/infrastructure/persistence/relational/entities/category.entity';
import { SubcategoryEntity } from '../../../../subcategories/infrastructure/persistence/relational/entities/subcategory.entity';
import { ProductEntity } from '../../../../products/infrastructure/persistence/relational/entities/product.entity';
import { ProductVariantEntity } from '../../../../product-variants/infrastructure/persistence/relational/entities/product-variant.entity';
import { ModifierGroupEntity } from '../../../../modifier-groups/infrastructure/persistence/relational/entities/modifier-group.entity';
import { ProductModifierEntity } from '../../../../product-modifiers/infrastructure/persistence/relational/entities/product-modifier.entity';
import { PizzaCustomizationEntity } from '../../../../pizza-customizations/infrastructure/persistence/relational/entities/pizza-customization.entity';
import { PizzaConfigurationEntity } from '../../../../pizza-configurations/infrastructure/persistence/relational/entities/pizza-configuration.entity';
import { PreparationScreenEntity } from '../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import { ProductSeedService } from './product-seed.service';
import { CustomIdService } from '../../../../common/services/custom-id.service';
@Module({
  imports: [
    TypeOrmModule.forFeature([
      CategoryEntity,
      SubcategoryEntity,
      ProductEntity,
      ProductVariantEntity,
      ModifierGroupEntity,
      ProductModifierEntity,
      PizzaCustomizationEntity,
      PizzaConfigurationEntity,
      PreparationScreenEntity,
    ]),
  ],
  providers: [ProductSeedService, CustomIdService],
  exports: [ProductSeedService],
})
export class ProductSeedModule {}

================
File: backend/src/database/seeds/relational/product/product-seed.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CategoryEntity } from '../../../../categories/infrastructure/persistence/relational/entities/category.entity';
import { SubcategoryEntity } from '../../../../subcategories/infrastructure/persistence/relational/entities/subcategory.entity';
import { ProductEntity } from '../../../../products/infrastructure/persistence/relational/entities/product.entity';
import { ProductVariantEntity } from '../../../../product-variants/infrastructure/persistence/relational/entities/product-variant.entity';
import { ModifierGroupEntity } from '../../../../modifier-groups/infrastructure/persistence/relational/entities/modifier-group.entity';
import { ProductModifierEntity } from '../../../../product-modifiers/infrastructure/persistence/relational/entities/product-modifier.entity';
import { PizzaCustomizationEntity } from '../../../../pizza-customizations/infrastructure/persistence/relational/entities/pizza-customization.entity';
import { PizzaConfigurationEntity } from '../../../../pizza-configurations/infrastructure/persistence/relational/entities/pizza-configuration.entity';
import { CustomizationType } from '../../../../pizza-customizations/domain/enums/customization-type.enum';
import { PreparationScreenEntity } from '../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import {
  CustomIdService,
  EntityPrefix,
} from '../../../../common/services/custom-id.service';
@Injectable()
export class ProductSeedService {
  constructor(
    @InjectRepository(CategoryEntity)
    private categoryRepository: Repository<CategoryEntity>,
    @InjectRepository(SubcategoryEntity)
    private subcategoryRepository: Repository<SubcategoryEntity>,
    @InjectRepository(ProductEntity)
    private productRepository: Repository<ProductEntity>,
    @InjectRepository(ProductVariantEntity)
    private variantRepository: Repository<ProductVariantEntity>,
    @InjectRepository(ModifierGroupEntity)
    private modifierGroupRepository: Repository<ModifierGroupEntity>,
    @InjectRepository(ProductModifierEntity)
    private modifierRepository: Repository<ProductModifierEntity>,
    @InjectRepository(PizzaCustomizationEntity)
    private pizzaCustomizationRepository: Repository<PizzaCustomizationEntity>,
    @InjectRepository(PizzaConfigurationEntity)
    private pizzaConfigurationRepository: Repository<PizzaConfigurationEntity>,
    @InjectRepository(PreparationScreenEntity)
    private preparationScreenRepository: Repository<PreparationScreenEntity>,
    private customIdService: CustomIdService,
  ) {}
  async run() {
    const countCategories = await this.categoryRepository.count();
    const countProducts = await this.productRepository.count();
    if (!countCategories) {
      await this.seedCategories();
    }
    if (!countProducts) {
      await this.seedProducts();
    }
  }
  private async seedCategories() {
    const categoriesData = [
      {
        id: 'CAT-1',
        name: 'Comida',
        description: 'Platos principales y entradas',
        sortOrder: 1,
        subcategories: [
          {
            id: 'SUB-1',
            name: 'Entradas',
            description: 'Alitas, papas y más',
            sortOrder: 1,
          },
          {
            id: 'SUB-2',
            name: 'Pizzas',
            description: 'Pizzas artesanales',
            sortOrder: 2,
          },
          {
            id: 'SUB-3',
            name: 'Hamburguesas',
            description: 'Hamburguesas gourmet',
            sortOrder: 3,
          },
          {
            id: 'SUB-4',
            name: 'Ensaladas',
            description: 'Ensaladas frescas',
            sortOrder: 4,
          },
        ],
      },
      {
        id: 'CAT-2',
        name: 'Bebida',
        description: 'Bebidas y coctelería',
        sortOrder: 2,
        subcategories: [
          {
            id: 'SUB-5',
            name: 'Frappes y Postres',
            description: 'Bebidas frías y postres',
            sortOrder: 1,
          },
          {
            id: 'SUB-6',
            name: 'Jarras',
            description: 'Bebidas para compartir',
            sortOrder: 2,
          },
          {
            id: 'SUB-7',
            name: 'Cocteleria',
            description: 'Cocteles y bebidas con alcohol',
            sortOrder: 3,
          },
          {
            id: 'SUB-8',
            name: 'Bebidas',
            description: 'Aguas frescas y bebidas naturales',
            sortOrder: 4,
          },
          {
            id: 'SUB-9',
            name: 'Cafe Caliente',
            description: 'Café y bebidas calientes',
            sortOrder: 5,
          },
          {
            id: 'SUB-10',
            name: 'Refrescos',
            description: 'Refrescos embotellados',
            sortOrder: 6,
          },
        ],
      },
    ];
    for (const categoryData of categoriesData) {
      const { subcategories, ...categoryInfo } = categoryData;
      const category = await this.categoryRepository.save(
        this.categoryRepository.create({
          ...categoryInfo,
          isActive: true,
        }),
      );
      for (const subcategoryData of subcategories) {
        await this.subcategoryRepository.save(
          this.subcategoryRepository.create({
            ...subcategoryData,
            category: category,
            isActive: true,
          }),
        );
      }
    }
  }
  private async seedProducts() {
    await this.seedPizzaCustomizations();
    await this.seedBeverageProducts();
    await this.seedFoodProducts();
  }
  private async seedPizzaCustomizations() {
    const pizzaCustomizations = [
      {
        name: 'Adelita',
        type: CustomizationType.FLAVOR,
        ingredients: 'Jamon, Piña, Arandano',
        toppingValue: 4,
        sortOrder: 1,
      },
      {
        name: 'Carnes Frias',
        type: CustomizationType.FLAVOR,
        ingredients: 'Jamon, Salami, Peperoni',
        toppingValue: 4,
        sortOrder: 2,
      },
      {
        name: 'Carranza',
        type: CustomizationType.FLAVOR,
        ingredients: 'Cebolla, Chile Morron, Pollo BBQ',
        toppingValue: 4,
        sortOrder: 3,
      },
      {
        name: 'Especial',
        type: CustomizationType.FLAVOR,
        ingredients: 'Jamon, Champiñon, Chile Morron',
        toppingValue: 4,
        sortOrder: 4,
      },
      {
        name: 'Hawaiana',
        type: CustomizationType.FLAVOR,
        ingredients: 'Jamon, Piña',
        toppingValue: 3,
        sortOrder: 5,
      },
      {
        name: 'Kahlo',
        type: CustomizationType.FLAVOR,
        ingredients: 'Calabaza, Elote, Champiñon, Jitomate',
        toppingValue: 4,
        sortOrder: 6,
      },
      {
        name: 'La Leña',
        type: CustomizationType.FLAVOR,
        ingredients: 'Tocino, Pierna, Chorizo, Molida',
        toppingValue: 6,
        sortOrder: 7,
      },
      {
        name: 'La Maria',
        type: CustomizationType.FLAVOR,
        ingredients: 'Pollo BBQ, Piña, Chile Jalapeño',
        toppingValue: 6,
        sortOrder: 8,
      },
      {
        name: 'Lupita',
        type: CustomizationType.FLAVOR,
        ingredients: 'Molida, Tocino, Cebolla, Chile Morron',
        toppingValue: 4,
        sortOrder: 9,
      },
      {
        name: 'Malinche',
        type: CustomizationType.FLAVOR,
        ingredients: 'Queso de cabra, Champiñon, Jamon, Chile Seco, Albahaca',
        toppingValue: 6,
        sortOrder: 10,
      },
      {
        name: 'Margarita',
        type: CustomizationType.FLAVOR,
        ingredients: 'Jitomate, Albahaca',
        toppingValue: 4,
        sortOrder: 11,
      },
      {
        name: 'Mexicana',
        type: CustomizationType.FLAVOR,
        ingredients: 'Chorizo, Cebolla, Chile Jalapeño, Jitomate',
        toppingValue: 4,
        sortOrder: 12,
      },
      {
        name: 'Pepperoni',
        type: CustomizationType.FLAVOR,
        ingredients: 'Pepperoni',
        toppingValue: 4,
        sortOrder: 13,
      },
      {
        name: 'Rivera',
        type: CustomizationType.FLAVOR,
        ingredients: 'Elote, Champiñon, Chile Morron',
        toppingValue: 4,
        sortOrder: 14,
      },
      {
        name: 'Villa',
        type: CustomizationType.FLAVOR,
        ingredients: 'Chorizo, Tocino, Piña, Chile Jalapeño',
        toppingValue: 4,
        sortOrder: 15,
      },
      {
        name: 'Zapata',
        type: CustomizationType.FLAVOR,
        ingredients: 'Salami, Jamon, Champiñon',
        toppingValue: 4,
        sortOrder: 16,
      },
      {
        name: '3 Quesos',
        type: CustomizationType.FLAVOR,
        ingredients: '3 Quesos',
        toppingValue: 2,
        sortOrder: 17,
      },
      {
        name: 'Albahaca',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 18,
      },
      {
        name: 'Arándano',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 19,
      },
      {
        name: 'Calabaza',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 20,
      },
      {
        name: 'Cebolla',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 21,
      },
      {
        name: 'Champiñón',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 22,
      },
      {
        name: 'Chile Jalapeño',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 23,
      },
      {
        name: 'Chile Morrón',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 24,
      },
      {
        name: 'Chile Seco',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 25,
      },
      {
        name: 'Chorizo',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 26,
      },
      {
        name: 'Elote',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 27,
      },
      {
        name: 'Jamón',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 28,
      },
      {
        name: 'Jitomate',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 29,
      },
      {
        name: 'Molida',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 30,
      },
      {
        name: 'Pierna',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 2,
        sortOrder: 31,
      },
      {
        name: 'Piña',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 32,
      },
      {
        name: 'Pollo BBQ',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 2,
        sortOrder: 33,
      },
      {
        name: 'Queso Extra',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 34,
      },
      {
        name: 'Queso de cabra',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 2,
        sortOrder: 35,
      },
      {
        name: 'Salami',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 36,
      },
      {
        name: 'Salchicha',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 37,
      },
      {
        name: 'Salsa BBQ',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 0,
        sortOrder: 38,
      },
      {
        name: 'Tocino',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 39,
      },
      {
        name: 'Pepperoni Extra',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 40,
      },
      {
        name: 'Pepperoni',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 41,
      },
      {
        name: 'Pollo',
        type: CustomizationType.INGREDIENT,
        ingredients: null,
        toppingValue: 1,
        sortOrder: 42,
      },
    ];
    for (const customization of pizzaCustomizations) {
      const id = await this.customIdService.generateId(
        EntityPrefix.PIZZA_CUSTOMIZATION,
        'pizza_customization',
      );
      await this.pizzaCustomizationRepository.save(
        this.pizzaCustomizationRepository.create({
          id,
          ...customization,
          isActive: true,
        }),
      );
    }
  }
  private async seedBeverageProducts() {
    const preparationScreens = await this.preparationScreenRepository.find({
      where: { isActive: true },
    });
    const barScreen = preparationScreens.find(
      (screen) => screen.name === 'Bar',
    );
    const defaultScreen = preparationScreens[0];
    if (!defaultScreen) {
      return;
    }
    const beverageScreen = barScreen || defaultScreen;
    const simpleBeverages = [
      {
        name: 'Agua fresca de horchata',
        description: 'Refrescante agua de horchata natural',
        price: 35,
        subcategoryId: 'SUB-8',
        sortOrder: 1,
      },
      {
        name: 'Limonada',
        description: 'Limonada natural recién preparada',
        price: 35,
        subcategoryId: 'SUB-8',
        sortOrder: 2,
      },
      {
        name: 'Limonada Mineral',
        description: 'Limonada con agua mineral',
        price: 35,
        subcategoryId: 'SUB-8',
        sortOrder: 3,
      },
      {
        name: 'Sangria Preparada',
        description: 'Sangría sin alcohol con frutas naturales',
        price: 35,
        subcategoryId: 'SUB-8',
        sortOrder: 4,
      },
      {
        name: 'Coca Cola',
        description: 'Refresco Coca Cola 355ml',
        price: 30,
        subcategoryId: 'SUB-10',
        sortOrder: 1,
      },
      {
        name: 'Sangria',
        description: 'Refresco Sangría Señorial',
        price: 30,
        subcategoryId: 'SUB-10',
        sortOrder: 2,
      },
      {
        name: 'Squirt',
        description: 'Refresco Squirt toronja',
        price: 30,
        subcategoryId: 'SUB-10',
        sortOrder: 3,
      },
      {
        name: 'Mirinda',
        description: 'Refresco Mirinda naranja',
        price: 30,
        subcategoryId: 'SUB-10',
        sortOrder: 4,
      },
      {
        name: 'Manzanita',
        description: 'Refresco Manzanita Sol',
        price: 30,
        subcategoryId: 'SUB-10',
        sortOrder: 5,
      },
      {
        name: '7up',
        description: 'Refresco 7up lima-limón',
        price: 30,
        subcategoryId: 'SUB-10',
        sortOrder: 6,
      },
      {
        name: 'Agua Mineral',
        description: 'Agua mineral Peñafiel',
        price: 30,
        subcategoryId: 'SUB-10',
        sortOrder: 7,
      },
      {
        name: 'Cafe Americano',
        description: 'Café americano recién preparado',
        price: 45,
        subcategoryId: 'SUB-9',
        sortOrder: 1,
      },
      {
        name: 'Capuchino',
        description: 'Capuchino con espuma de leche',
        price: 45,
        subcategoryId: 'SUB-9',
        sortOrder: 2,
      },
      {
        name: 'Chocolate',
        description: 'Chocolate caliente cremoso',
        price: 50,
        subcategoryId: 'SUB-9',
        sortOrder: 3,
      },
      {
        name: 'Latte Capuchino',
        description: 'Latte con toque de capuchino',
        price: 50,
        subcategoryId: 'SUB-9',
        sortOrder: 4,
      },
      {
        name: 'Latte Vainilla',
        description: 'Latte con jarabe de vainilla',
        price: 50,
        subcategoryId: 'SUB-9',
        sortOrder: 5,
      },
      {
        name: 'Mocaccino',
        description: 'Café con chocolate y crema',
        price: 50,
        subcategoryId: 'SUB-9',
        sortOrder: 6,
      },
      {
        name: 'Carajillo',
        description: 'Café con licor 43',
        price: 90,
        subcategoryId: 'SUB-7',
        sortOrder: 1,
      },
      {
        name: 'Clericot',
        description: 'Vino tinto con frutas',
        price: 80,
        subcategoryId: 'SUB-7',
        sortOrder: 2,
      },
      {
        name: 'Conga',
        description: 'Coctel refrescante con vodka',
        price: 75,
        subcategoryId: 'SUB-7',
        sortOrder: 3,
      },
      {
        name: 'Copa Vino',
        description: 'Copa de vino tinto o blanco',
        price: 90,
        subcategoryId: 'SUB-7',
        sortOrder: 4,
      },
      {
        name: 'Destornillador',
        description: 'Vodka con jugo de naranja',
        price: 75,
        subcategoryId: 'SUB-7',
        sortOrder: 5,
      },
      {
        name: 'Gin Maracuya',
        description: 'Gin con maracuyá',
        price: 90,
        subcategoryId: 'SUB-7',
        sortOrder: 6,
      },
      {
        name: 'Gin Pepino',
        description: 'Gin con pepino y tónica',
        price: 90,
        subcategoryId: 'SUB-7',
        sortOrder: 7,
      },
      {
        name: 'Margarita',
        description: 'Tequila, triple sec y limón',
        price: 85,
        subcategoryId: 'SUB-7',
        sortOrder: 8,
      },
      {
        name: 'Mojito',
        description: 'Ron, hierbabuena, limón y soda',
        price: 100,
        subcategoryId: 'SUB-7',
        sortOrder: 9,
      },
      {
        name: 'Paloma',
        description: 'Tequila con refresco de toronja',
        price: 80,
        subcategoryId: 'SUB-7',
        sortOrder: 10,
      },
      {
        name: 'Palo Santo',
        description: 'Mezcal con jugos cítricos',
        price: 80,
        subcategoryId: 'SUB-7',
        sortOrder: 11,
      },
      {
        name: 'Pina Colada',
        description: 'Ron, crema de coco y piña',
        price: 75,
        subcategoryId: 'SUB-7',
        sortOrder: 12,
      },
      {
        name: 'Pinada',
        description: 'Bebida tropical con piña',
        price: 70,
        subcategoryId: 'SUB-7',
        sortOrder: 13,
      },
      {
        name: 'Ruso Blanco',
        description: 'Vodka, licor de café y crema',
        price: 85,
        subcategoryId: 'SUB-7',
        sortOrder: 14,
      },
      {
        name: 'Sangria con Vino',
        description: 'Vino tinto con frutas y refresco',
        price: 80,
        subcategoryId: 'SUB-7',
        sortOrder: 15,
      },
      {
        name: 'Tequila',
        description: 'Caballito de tequila',
        price: 90,
        subcategoryId: 'SUB-7',
        sortOrder: 16,
      },
      {
        name: 'Tinto de Verano',
        description: 'Vino tinto con refresco de limón',
        price: 90,
        subcategoryId: 'SUB-7',
        sortOrder: 17,
      },
      {
        name: 'Vampiro',
        description: 'Tequila, sangrita y refresco',
        price: 80,
        subcategoryId: 'SUB-7',
        sortOrder: 18,
      },
    ];
    for (const beverage of simpleBeverages) {
      const subcategory = await this.subcategoryRepository.findOne({
        where: { id: beverage.subcategoryId },
      });
      if (subcategory) {
        const id = await this.customIdService.generateId(
          EntityPrefix.PRODUCT,
          'product',
        );
        await this.productRepository.save(
          this.productRepository.create({
            id,
            name: beverage.name,
            description: beverage.description,
            price: beverage.price,
            hasVariants: false,
            isActive: true,
            isPizza: false,
            sortOrder: beverage.sortOrder,
            subcategory: subcategory,
            estimatedPrepTime: 5,
            preparationScreenId: beverageScreen.id,
          }),
        );
      }
    }
    await this.seedBeveragesWithVariants(beverageScreen);
  }
  private async seedBeveragesWithVariants(
    beverageScreen: PreparationScreenEntity,
  ) {
    const micheladaSubcategory = await this.subcategoryRepository.findOne({
      where: { id: 'SUB-8' },
    });
    if (micheladaSubcategory) {
      const micheladaId = await this.customIdService.generateId(
        EntityPrefix.PRODUCT,
        'product',
      );
      const michelada = await this.productRepository.save(
        this.productRepository.create({
          id: micheladaId,
          name: 'Michelada',
          description: 'Michelada preparada con nuestra receta especial',
          hasVariants: true,
          isActive: true,
          isPizza: false,
          sortOrder: 5,
          subcategory: micheladaSubcategory,
          estimatedPrepTime: 5,
          preparationScreenId: beverageScreen.id,
        }),
      );
      const micheladaVariants = [
        { name: 'Michelada clara', price: 80, sortOrder: 1 },
        { name: 'Michelada oscura', price: 80, sortOrder: 2 },
      ];
      for (const variant of micheladaVariants) {
        const variantId = await this.customIdService.generateId(
          EntityPrefix.PRODUCT_VARIANT,
          'product_variant',
        );
        await this.variantRepository.save(
          this.variantRepository.create({
            id: variantId,
            ...variant,
            product: michelada,
            isActive: true,
          }),
        );
      }
    }
    const frappeSubcategory = await this.subcategoryRepository.findOne({
      where: { id: 'SUB-5' },
    });
    if (frappeSubcategory) {
      const frappeId = await this.customIdService.generateId(
        EntityPrefix.PRODUCT,
        'product',
      );
      const frappe = await this.productRepository.save(
        this.productRepository.create({
          id: frappeId,
          name: 'Frappe',
          description: 'Frappes preparados con ingredientes premium',
          hasVariants: true,
          isActive: true,
          isPizza: false,
          sortOrder: 1,
          subcategory: frappeSubcategory,
          estimatedPrepTime: 10,
          preparationScreenId: beverageScreen.id,
        }),
      );
      const frappeVariants = [
        { name: 'Frappe Capuchino', price: 70, sortOrder: 1 },
        { name: 'Frappe Coco', price: 70, sortOrder: 2 },
        { name: 'Frappe Caramelo', price: 70, sortOrder: 3 },
        { name: 'Frappe Cajeta', price: 70, sortOrder: 4 },
        { name: 'Frappe Mocaccino', price: 70, sortOrder: 5 },
        { name: 'Frappe Galleta', price: 70, sortOrder: 6 },
        { name: 'Frappe Bombon', price: 70, sortOrder: 7 },
        { name: 'Frappe Rompope', price: 85, sortOrder: 8 },
        { name: 'Frappe Mazapan', price: 85, sortOrder: 9 },
        { name: 'Frappe Magnum', price: 85, sortOrder: 10 },
      ];
      for (const variant of frappeVariants) {
        const variantId = await this.customIdService.generateId(
          EntityPrefix.PRODUCT_VARIANT,
          'product_variant',
        );
        await this.variantRepository.save(
          this.variantRepository.create({
            id: variantId,
            ...variant,
            product: frappe,
            isActive: true,
          }),
        );
      }
    }
  }
  private async seedFoodProducts() {
    const preparationScreens = await this.preparationScreenRepository.find({
      where: { isActive: true },
    });
    const pizzaScreen = preparationScreens.find(
      (screen) => screen.name === 'Pizza',
    );
    const hamburguesasScreen = preparationScreens.find(
      (screen) => screen.name === 'Hamburguesas',
    );
    const defaultScreen = preparationScreens[0];
    if (!defaultScreen) {
      return;
    }
    await this.seedHamburgers(hamburguesasScreen || defaultScreen);
    await this.seedAlitas(pizzaScreen || defaultScreen);
    await this.seedPapas(pizzaScreen || defaultScreen);
    await this.seedEnsaladas(hamburguesasScreen || defaultScreen);
    await this.seedOtherFoodProducts(
      pizzaScreen || defaultScreen,
      hamburguesasScreen || defaultScreen,
    );
  }
  private async seedHamburgers(preparationScreen: PreparationScreenEntity) {
    const hamburguesaSubcategory = await this.subcategoryRepository.findOne({
      where: { id: 'SUB-3' },
    });
    if (hamburguesaSubcategory) {
      const hamburguesaId = await this.customIdService.generateId(
        EntityPrefix.PRODUCT,
        'product',
      );
      const hamburguesa = await this.productRepository.save(
        this.productRepository.create({
          id: hamburguesaId,
          name: 'Hamburguesa',
          description: 'Hamburguesas artesanales con carne de res premium',
          hasVariants: true,
          isActive: true,
          isPizza: false,
          sortOrder: 1,
          subcategory: hamburguesaSubcategory,
          estimatedPrepTime: 15,
          preparationScreenId: preparationScreen.id,
        }),
      );
      const hamburguesaVariants = [
        { name: 'Hamburguesa Tradicional', price: 85, sortOrder: 1 },
        { name: 'Hamburguesa Especial', price: 95, sortOrder: 2 },
        { name: 'Hamburguesa Hawaiana', price: 95, sortOrder: 3 },
        { name: 'Hamburguesa Pollo', price: 100, sortOrder: 4 },
        { name: 'Hamburguesa BBQ', price: 100, sortOrder: 5 },
        { name: 'Hamburguesa Leñazo', price: 110, sortOrder: 6 },
        { name: 'Hamburguesa Cubana', price: 100, sortOrder: 7 },
      ];
      for (const variant of hamburguesaVariants) {
        const variantId = await this.customIdService.generateId(
          EntityPrefix.PRODUCT_VARIANT,
          'product_variant',
        );
        await this.variantRepository.save(
          this.variantRepository.create({
            id: variantId,
            ...variant,
            product: hamburguesa,
            isActive: true,
          }),
        );
      }
      await this.createHamburgerModifiers(hamburguesa);
    }
  }
  private async createHamburgerModifiers(hamburguesa: ProductEntity) {
    const papasGroupId = await this.customIdService.generateId(
      EntityPrefix.MODIFIER_GROUP,
      'modifier_group',
    );
    const papasGroup = await this.modifierGroupRepository.save(
      this.modifierGroupRepository.create({
        id: papasGroupId,
        name: 'Hamburguesa con papas',
        isRequired: false,
        allowMultipleSelections: false,
        maxSelections: 1,
        isActive: true,
        sortOrder: 1,
      }),
    );
    const papasModifiers = [
      { name: 'Con papas francesa', price: 10, sortOrder: 1 },
      { name: 'Con papas gajo', price: 15, sortOrder: 2 },
      { name: 'Con papas mixtas', price: 15, sortOrder: 3 },
      {
        name: 'Con papas francesa gratinadas',
        price: 15,
        sortOrder: 4,
      },
      {
        name: 'Con papas gajo gratinadas',
        price: 20,
        sortOrder: 5,
      },
      {
        name: 'Con papas mixtas gratinadas',
        price: 20,
        sortOrder: 6,
      },
    ];
    for (const modifier of papasModifiers) {
      const modifierId = await this.customIdService.generateId(
        EntityPrefix.MODIFIER,
        'product_modifier',
      );
      await this.modifierRepository.save(
        this.modifierRepository.create({
          id: modifierId,
          ...modifier,
          modifierGroup: papasGroup,
          isActive: true,
          isDefault: false,
        }),
      );
    }
    const extrasGroupId = await this.customIdService.generateId(
      EntityPrefix.MODIFIER_GROUP,
      'modifier_group',
    );
    const extrasGroup = await this.modifierGroupRepository.save(
      this.modifierGroupRepository.create({
        id: extrasGroupId,
        name: 'Hamburguesa extras',
        isRequired: false,
        allowMultipleSelections: true,
        maxSelections: 5,
        isActive: true,
        sortOrder: 2,
      }),
    );
    const extrasModifiers = [
      { name: 'Partida', price: 0, sortOrder: 1 },
      { name: 'Doble carne', price: 15, sortOrder: 2 },
      { name: 'Doble pollo', price: 20, sortOrder: 3 },
      { name: 'Piña', price: 5, sortOrder: 4 },
      {
        name: 'Pollo en lugar de carne de res',
        price: 15,
        sortOrder: 5,
      },
    ];
    for (const modifier of extrasModifiers) {
      const modifierId = await this.customIdService.generateId(
        EntityPrefix.MODIFIER,
        'product_modifier',
      );
      await this.modifierRepository.save(
        this.modifierRepository.create({
          id: modifierId,
          ...modifier,
          modifierGroup: extrasGroup,
          isActive: true,
          isDefault: false,
        }),
      );
    }
    const quitarGroupId = await this.customIdService.generateId(
      EntityPrefix.MODIFIER_GROUP,
      'modifier_group',
    );
    const quitarGroup = await this.modifierGroupRepository.save(
      this.modifierGroupRepository.create({
        id: quitarGroupId,
        name: 'Quitar ingredientes Hamburguesa',
        isRequired: false,
        allowMultipleSelections: true,
        maxSelections: 14,
        isActive: true,
        sortOrder: 3,
      }),
    );
    const quitarModifiers = [
      { name: 'Sin aderezo', price: 0, sortOrder: 1 },
      { name: 'Sin aderezos', price: 0, sortOrder: 2 },
      { name: 'Sin catsup', price: 0, sortOrder: 3 },
      { name: 'Sin cebolla', price: 0, sortOrder: 4 },
      { name: 'Sin chile jalapeño', price: 0, sortOrder: 5 },
      { name: 'Sin crema', price: 0, sortOrder: 6 },
      { name: 'Sin jitomate', price: 0, sortOrder: 7 },
      { name: 'Sin lechuga', price: 0, sortOrder: 8 },
      { name: 'Sin mostaza', price: 0, sortOrder: 9 },
      { name: 'Sin pierna', price: 0, sortOrder: 10 },
      { name: 'Sin queso amarillo', price: 0, sortOrder: 11 },
      { name: 'Sin queso blanco', price: 0, sortOrder: 12 },
      { name: 'Sin tocino', price: 0, sortOrder: 13 },
      { name: 'Sin verduras', price: 0, sortOrder: 14 },
    ];
    for (const modifier of quitarModifiers) {
      const modifierId = await this.customIdService.generateId(
        EntityPrefix.MODIFIER,
        'product_modifier',
      );
      await this.modifierRepository.save(
        this.modifierRepository.create({
          id: modifierId,
          ...modifier,
          modifierGroup: quitarGroup,
          isActive: true,
          isDefault: false,
        }),
      );
    }
    hamburguesa.modifierGroups = [papasGroup, extrasGroup, quitarGroup];
    await this.productRepository.save(hamburguesa);
  }
  private async seedAlitas(preparationScreen: PreparationScreenEntity) {
    const entradasSubcategory = await this.subcategoryRepository.findOne({
      where: { id: 'SUB-1' },
    });
    if (entradasSubcategory) {
      const alitasId = await this.customIdService.generateId(
        EntityPrefix.PRODUCT,
        'product',
      );
      const alitas = await this.productRepository.save(
        this.productRepository.create({
          id: alitasId,
          name: 'Alitas',
          description: 'Alitas de pollo preparadas al momento',
          hasVariants: true,
          isActive: true,
          isPizza: false,
          sortOrder: 1,
          subcategory: entradasSubcategory,
          estimatedPrepTime: 15,
          preparationScreenId: preparationScreen.id,
        }),
      );
      const alitasVariants = [
        { name: 'Orden de Alitas BBQ', price: 135, sortOrder: 1 },
        { name: 'Orden de Alitas Picosas', price: 135, sortOrder: 2 },
        { name: 'Orden de Alitas Fritas', price: 135, sortOrder: 3 },
        { name: 'Orden de Alitas Mango Habanero', price: 140, sortOrder: 4 },
        { name: 'Orden de Alitas Mixtas', price: 135, sortOrder: 5 },
        { name: 'Media Orden de Alitas BBQ', price: 70, sortOrder: 6 },
        { name: 'Media Orden de Alitas Picosas', price: 70, sortOrder: 7 },
        { name: 'Media Orden de Alitas Fritas', price: 70, sortOrder: 8 },
        {
          name: 'Media Orden de Alitas Mango Habanero',
          price: 75,
          sortOrder: 9,
        },
      ];
      for (const variant of alitasVariants) {
        const variantId = await this.customIdService.generateId(
          EntityPrefix.PRODUCT_VARIANT,
          'product_variant',
        );
        await this.variantRepository.save(
          this.variantRepository.create({
            id: variantId,
            ...variant,
            product: alitas,
            isActive: true,
          }),
        );
      }
      const alitasModifierGroupId = await this.customIdService.generateId(
        EntityPrefix.MODIFIER_GROUP,
        'modifier_group',
      );
      const alitasModifierGroup = await this.modifierGroupRepository.save(
        this.modifierGroupRepository.create({
          id: alitasModifierGroupId,
          name: 'Modificadores Alitas',
          isRequired: false,
          allowMultipleSelections: true,
          maxSelections: 4,
          isActive: true,
          sortOrder: 1,
        }),
      );
      const alitasModifiers = [
        { name: 'Extra salsa', price: 10, sortOrder: 1 },
        { name: 'Con aderezo ranch', price: 10, sortOrder: 2 },
        { name: 'Extra chile de aceite', price: 10, sortOrder: 3 },
        { name: 'Extra doradas', price: 0, sortOrder: 4 },
      ];
      for (const modifier of alitasModifiers) {
        const modifierId = await this.customIdService.generateId(
          EntityPrefix.MODIFIER,
          'product_modifier',
        );
        await this.modifierRepository.save(
          this.modifierRepository.create({
            id: modifierId,
            ...modifier,
            modifierGroup: alitasModifierGroup,
            isActive: true,
            isDefault: false,
          }),
        );
      }
      alitas.modifierGroups = [alitasModifierGroup];
      await this.productRepository.save(alitas);
    }
  }
  private async seedPapas(preparationScreen: PreparationScreenEntity) {
    const entradasSubcategory = await this.subcategoryRepository.findOne({
      where: { id: 'SUB-1' },
    });
    if (entradasSubcategory) {
      const papasId = await this.customIdService.generateId(
        EntityPrefix.PRODUCT,
        'product',
      );
      const papas = await this.productRepository.save(
        this.productRepository.create({
          id: papasId,
          name: 'Orden de Papas',
          description: 'Papas preparadas con nuestra receta especial',
          hasVariants: true,
          isActive: true,
          isPizza: false,
          sortOrder: 2,
          subcategory: entradasSubcategory,
          estimatedPrepTime: 10,
          preparationScreenId: preparationScreen.id,
        }),
      );
      const papasVariants = [
        { name: 'Orden de Papas a la Francesa', price: 90, sortOrder: 1 },
        { name: 'Orden de Papas Gajo', price: 105, sortOrder: 2 },
        {
          name: 'Orden de Papas Mixtas francesa y gajo',
          price: 105,
          sortOrder: 3,
        },
        { name: 'Media Orden de Papas a la Francesa', price: 50, sortOrder: 4 },
        { name: 'Media Orden de Papas Gajo', price: 65, sortOrder: 5 },
      ];
      for (const variant of papasVariants) {
        const variantId = await this.customIdService.generateId(
          EntityPrefix.PRODUCT_VARIANT,
          'product_variant',
        );
        await this.variantRepository.save(
          this.variantRepository.create({
            id: variantId,
            ...variant,
            product: papas,
            isActive: true,
          }),
        );
      }
      const papasQuesoGroupId = await this.customIdService.generateId(
        EntityPrefix.MODIFIER_GROUP,
        'modifier_group',
      );
      const papasQuesoGroup = await this.modifierGroupRepository.save(
        this.modifierGroupRepository.create({
          id: papasQuesoGroupId,
          name: 'Papas queso',
          isRequired: true,
          allowMultipleSelections: true,
          maxSelections: 3,
          isActive: true,
          sortOrder: 1,
        }),
      );
      const papasQuesoModifiers = [
        { name: 'Sin queso', price: 0, sortOrder: 1 },
        { name: 'Con queso', price: 0, sortOrder: 2 },
        { name: 'Extra queso', price: 10, sortOrder: 3 },
      ];
      for (const modifier of papasQuesoModifiers) {
        const modifierId = await this.customIdService.generateId(
          EntityPrefix.MODIFIER,
          'product_modifier',
        );
        await this.modifierRepository.save(
          this.modifierRepository.create({
            id: modifierId,
            ...modifier,
            modifierGroup: papasQuesoGroup,
            isActive: true,
            isDefault: modifier.name === 'Con queso',
          }),
        );
      }
      const papasObservacionesGroupId = await this.customIdService.generateId(
        EntityPrefix.MODIFIER_GROUP,
        'modifier_group',
      );
      const papasObservacionesGroup = await this.modifierGroupRepository.save(
        this.modifierGroupRepository.create({
          id: papasObservacionesGroupId,
          name: 'Papas observaciones',
          isRequired: false,
          allowMultipleSelections: true,
          maxSelections: 1,
          isActive: true,
          sortOrder: 2,
        }),
      );
      const papasObservacionesModifiers = [
        { name: 'Extra aderezo', price: 0, sortOrder: 1 },
      ];
      for (const modifier of papasObservacionesModifiers) {
        const modifierId = await this.customIdService.generateId(
          EntityPrefix.MODIFIER,
          'product_modifier',
        );
        await this.modifierRepository.save(
          this.modifierRepository.create({
            id: modifierId,
            ...modifier,
            modifierGroup: papasObservacionesGroup,
            isActive: true,
            isDefault: false,
          }),
        );
      }
      papas.modifierGroups = [papasQuesoGroup, papasObservacionesGroup];
      await this.productRepository.save(papas);
    }
  }
  private async seedEnsaladas(preparationScreen: PreparationScreenEntity) {
    const ensaladasSubcategory = await this.subcategoryRepository.findOne({
      where: { id: 'SUB-4' },
    });
    if (ensaladasSubcategory) {
      const ensaladaId = await this.customIdService.generateId(
        EntityPrefix.PRODUCT,
        'product',
      );
      const ensalada = await this.productRepository.save(
        this.productRepository.create({
          id: ensaladaId,
          name: 'Ensalada',
          description: 'Ensaladas frescas preparadas al momento',
          hasVariants: true,
          isActive: true,
          isPizza: false,
          sortOrder: 1,
          subcategory: ensaladasSubcategory,
          estimatedPrepTime: 8,
          preparationScreenId: preparationScreen.id,
        }),
      );
      const ensaladaVariants = [
        {
          name: 'Ensalada de Pollo Chica',
          price: 90,
          sortOrder: 1,
        },
        {
          name: 'Ensalada de Pollo Grande',
          price: 120,
          sortOrder: 2,
        },
        {
          name: 'Ensalada de Jamon Chica',
          price: 80,
          sortOrder: 3,
        },
        {
          name: 'Ensalada de Jamon Grande',
          price: 100,
          sortOrder: 4,
        },
        {
          name: 'Ensalada Vegetal Chica',
          price: 70,
          sortOrder: 5,
        },
        {
          name: 'Ensalada Vegetal Grande',
          price: 90,
          sortOrder: 6,
        },
      ];
      for (const variant of ensaladaVariants) {
        const variantId = await this.customIdService.generateId(
          EntityPrefix.PRODUCT_VARIANT,
          'product_variant',
        );
        await this.variantRepository.save(
          this.variantRepository.create({
            id: variantId,
            ...variant,
            product: ensalada,
            isActive: true,
          }),
        );
      }
      const extrasEnsaladasGroupId = await this.customIdService.generateId(
        EntityPrefix.MODIFIER_GROUP,
        'modifier_group',
      );
      const extrasEnsaladasGroup = await this.modifierGroupRepository.save(
        this.modifierGroupRepository.create({
          id: extrasEnsaladasGroupId,
          name: 'Extras Ensaladas',
          isRequired: false,
          allowMultipleSelections: true,
          maxSelections: 2,
          isActive: true,
          sortOrder: 1,
        }),
      );
      const extrasEnsaladasModifiers = [
        { name: 'Con vinagreta', price: 0, sortOrder: 1 },
        { name: 'Extra pollo', price: 15, sortOrder: 2 },
      ];
      for (const modifier of extrasEnsaladasModifiers) {
        const modifierId = await this.customIdService.generateId(
          EntityPrefix.MODIFIER,
          'product_modifier',
        );
        await this.modifierRepository.save(
          this.modifierRepository.create({
            id: modifierId,
            ...modifier,
            modifierGroup: extrasEnsaladasGroup,
            isActive: true,
            isDefault: false,
          }),
        );
      }
      const quitarEnsaladaGroupId = await this.customIdService.generateId(
        EntityPrefix.MODIFIER_GROUP,
        'modifier_group',
      );
      const quitarEnsaladaGroup = await this.modifierGroupRepository.save(
        this.modifierGroupRepository.create({
          id: quitarEnsaladaGroupId,
          name: 'Quitar ingredientes Ensalada',
          isRequired: false,
          allowMultipleSelections: true,
          maxSelections: 10,
          isActive: true,
          sortOrder: 2,
        }),
      );
      const quitarEnsaladaModifiers = [
        { name: 'Sin aderezo', price: 0, sortOrder: 1 },
        { name: 'Sin betabel crujiente', price: 0, sortOrder: 2 },
        { name: 'Sin chile morrón', price: 0, sortOrder: 3 },
        { name: 'Sin elote', price: 0, sortOrder: 4 },
        { name: 'Sin jamón', price: 0, sortOrder: 5 },
        { name: 'Sin jitomate', price: 0, sortOrder: 6 },
        { name: 'Sin lechuga', price: 0, sortOrder: 7 },
        { name: 'Sin pollo', price: 0, sortOrder: 8 },
        { name: 'Sin queso parmesano', price: 0, sortOrder: 9 },
        { name: 'Sin zanahoria', price: 0, sortOrder: 10 },
      ];
      for (const modifier of quitarEnsaladaModifiers) {
        const modifierId = await this.customIdService.generateId(
          EntityPrefix.MODIFIER,
          'product_modifier',
        );
        await this.modifierRepository.save(
          this.modifierRepository.create({
            id: modifierId,
            ...modifier,
            modifierGroup: quitarEnsaladaGroup,
            isActive: true,
            isDefault: false,
          }),
        );
      }
      ensalada.modifierGroups = [extrasEnsaladasGroup, quitarEnsaladaGroup];
      await this.productRepository.save(ensalada);
    }
  }
  private async seedOtherFoodProducts(
    pizzaScreen: PreparationScreenEntity,
    hamburguesasScreen: PreparationScreenEntity,
  ) {
    await this.seedPizzas(pizzaScreen);
    const hamburguesaSubcategory = await this.subcategoryRepository.findOne({
      where: { id: 'SUB-3' },
    });
    if (hamburguesaSubcategory) {
      const dedosId = await this.customIdService.generateId(
        EntityPrefix.PRODUCT,
        'product',
      );
      await this.productRepository.save(
        this.productRepository.create({
          id: dedosId,
          name: 'Dedos de queso',
          description: 'Dedos de queso mozzarella empanizados',
          price: 90,
          hasVariants: false,
          isActive: true,
          isPizza: false,
          sortOrder: 2,
          subcategory: hamburguesaSubcategory,
          estimatedPrepTime: 8,
          preparationScreenId: hamburguesasScreen.id,
        }),
      );
    }
  }
  private async seedPizzas(preparationScreen: PreparationScreenEntity) {
    const pizzaSubcategory = await this.subcategoryRepository.findOne({
      where: { id: 'SUB-2' },
    });
    if (pizzaSubcategory) {
      const pizzaId = await this.customIdService.generateId(
        EntityPrefix.PRODUCT,
        'product',
      );
      const pizza = await this.productRepository.save(
        this.productRepository.create({
          id: pizzaId,
          name: 'Pizza',
          description: 'Pizzas artesanales horneadas en horno de leña',
          hasVariants: true,
          isActive: true,
          isPizza: true,
          sortOrder: 1,
          subcategory: pizzaSubcategory,
          estimatedPrepTime: 20,
          preparationScreenId: preparationScreen.id,
        }),
      );
      const pizzaVariants = [
        { name: 'Pizza Grande', price: 240, sortOrder: 1 },
        { name: 'Pizza Mediana', price: 190, sortOrder: 2 },
        { name: 'Pizza Chica', price: 140, sortOrder: 3 },
        {
          name: 'Pizza Grande Con Orilla Rellena de Queso',
          price: 270,
          sortOrder: 4,
        },
        {
          name: 'Pizza Mediana Con Orilla Rellena de Queso',
          price: 220,
          sortOrder: 5,
        },
        {
          name: 'Pizza Chica Con Orilla Rellena de Queso',
          price: 160,
          sortOrder: 6,
        },
      ];
      for (const variant of pizzaVariants) {
        const variantId = await this.customIdService.generateId(
          EntityPrefix.PRODUCT_VARIANT,
          'product_variant',
        );
        await this.variantRepository.save(
          this.variantRepository.create({
            id: variantId,
            ...variant,
            product: pizza,
            isActive: true,
          }),
        );
      }
      await this.pizzaConfigurationRepository.save(
        this.pizzaConfigurationRepository.create({
          product: pizza,
          includedToppings: 4,
          extraToppingCost: 10,
        }),
      );
      const pizzaCustomizations =
        await this.pizzaCustomizationRepository.find();
      pizza.pizzaCustomizations = pizzaCustomizations;
      await this.productRepository.save(pizza);
      await this.createPizzaModifiers(pizza);
      const chileId = await this.customIdService.generateId(
        EntityPrefix.PRODUCT,
        'product',
      );
      await this.productRepository.save(
        this.productRepository.create({
          id: chileId,
          name: 'Chile chillon',
          description: 'Chile jalapeño relleno de queso',
          price: 35,
          hasVariants: false,
          isActive: true,
          isPizza: false,
          sortOrder: 2,
          subcategory: pizzaSubcategory,
          estimatedPrepTime: 10,
          preparationScreenId: preparationScreen.id,
        }),
      );
    }
  }
  private async createPizzaModifiers(pizza: ProductEntity) {
    const observacionesGroupId = await this.customIdService.generateId(
      EntityPrefix.MODIFIER_GROUP,
      'modifier_group',
    );
    const observacionesGroup = await this.modifierGroupRepository.save(
      this.modifierGroupRepository.create({
        id: observacionesGroupId,
        name: 'Observaciones de Pizza',
        isRequired: false,
        allowMultipleSelections: true,
        maxSelections: 6,
        isActive: true,
        sortOrder: 1,
      }),
    );
    const observacionesModifiers = [
      { name: 'Con catsup', price: 0, sortOrder: 1 },
      { name: 'Extra aderezo', price: 0, sortOrder: 2 },
      { name: 'Extra chile de aceite', price: 0, sortOrder: 3 },
      { name: 'Extra dorada', price: 0, sortOrder: 4 },
      { name: 'Menos dorada', price: 0, sortOrder: 5 },
      { name: 'Sin salsa', price: 0, sortOrder: 6 },
    ];
    for (const modifier of observacionesModifiers) {
      const modifierId = await this.customIdService.generateId(
        EntityPrefix.MODIFIER,
        'product_modifier',
      );
      await this.modifierRepository.save(
        this.modifierRepository.create({
          id: modifierId,
          ...modifier,
          modifierGroup: observacionesGroup,
          isActive: true,
          isDefault: false,
        }),
      );
    }
    pizza.modifierGroups = [observacionesGroup];
    await this.productRepository.save(pizza);
  }
}

================
File: backend/src/database/seeds/relational/restaurant-config/restaurant-config-seed.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { RestaurantConfigEntity } from '../../../../restaurant-config/infrastructure/persistence/relational/entities/restaurant-config.entity';
import { BusinessHoursEntity } from '../../../../restaurant-config/infrastructure/persistence/relational/entities/business-hours.entity';
import { RestaurantConfigSeedService } from './restaurant-config-seed.service';
@Module({
  imports: [
    TypeOrmModule.forFeature([RestaurantConfigEntity, BusinessHoursEntity]),
  ],
  providers: [RestaurantConfigSeedService],
  exports: [RestaurantConfigSeedService],
})
export class RestaurantConfigSeedModule {}

================
File: backend/src/database/seeds/relational/role/role-seed.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { RoleSeedService } from './role-seed.service';
import { RoleEntity } from '../../../../roles/infrastructure/persistence/relational/entities/role.entity';
@Module({
  imports: [TypeOrmModule.forFeature([RoleEntity])],
  providers: [RoleSeedService],
  exports: [RoleSeedService],
})
export class RoleSeedModule {}

================
File: backend/src/database/seeds/relational/role/role-seed.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { RoleEntity } from '../../../../roles/infrastructure/persistence/relational/entities/role.entity';
import { RoleEnum } from '../../../../roles/roles.enum';
@Injectable()
export class RoleSeedService {
  constructor(
    @InjectRepository(RoleEntity)
    private repository: Repository<RoleEntity>,
  ) {}
  async run() {
    const roles = [
      { id: RoleEnum.admin, name: 'Admin' },
      { id: RoleEnum.manager, name: 'Manager' },
      { id: RoleEnum.cashier, name: 'Cashier' },
      { id: RoleEnum.waiter, name: 'Waiter' },
      { id: RoleEnum.kitchen, name: 'Kitchen' },
      { id: RoleEnum.delivery, name: 'Delivery' },
    ];
    for (const role of roles) {
      const count = await this.repository.count({
        where: { id: role.id },
      });
      if (!count) {
        try {
          await this.repository.save(this.repository.create(role));
        } catch {}
      } else {
      }
    }
  }
}

================
File: backend/src/database/seeds/relational/run-seed.ts
================
import { NestFactory } from '@nestjs/core';
import { RoleSeedService } from './role/role-seed.service';
import { SeedModule } from './seed.module';
import { UserSeedService } from './user/user-seed.service';
import { RestaurantConfigSeedService } from './restaurant-config/restaurant-config-seed.service';
import { ProductSeedService } from './product/product-seed.service';
import { PreparationScreenSeedService } from './preparation-screen/preparation-screen-seed.service';
import { AreaSeedService } from './area/area-seed.service';
import { TableSeedService } from './table/table-seed.service';
const runSeed = async () => {
  const app = await NestFactory.create(SeedModule);
  await app.get(RoleSeedService).run();
  await app.get(UserSeedService).run();
  await app.get(RestaurantConfigSeedService).run();
  await app.get(PreparationScreenSeedService).run();
  await app.get(AreaSeedService).run();
  await app.get(TableSeedService).run();
  await app.get(ProductSeedService).run();
  await app.close();
};
void runSeed();

================
File: backend/src/database/seeds/relational/seed.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { DataSource, DataSourceOptions } from 'typeorm';
import { TypeOrmConfigService } from '../../typeorm-config.service';
import { RoleSeedModule } from './role/role-seed.module';
import { UserSeedModule } from './user/user-seed.module';
import { RestaurantConfigSeedModule } from './restaurant-config/restaurant-config-seed.module';
import { ProductSeedModule } from './product/product-seed.module';
import { PreparationScreenSeedModule } from './preparation-screen/preparation-screen-seed.module';
import { AreaSeedModule } from './area/area-seed.module';
import { TableSeedModule } from './table/table-seed.module';
import databaseConfig from '../../config/database.config';
import appConfig from '../../../config/app.config';
@Module({
  imports: [
    RoleSeedModule,
    UserSeedModule,
    RestaurantConfigSeedModule,
    ProductSeedModule,
    PreparationScreenSeedModule,
    AreaSeedModule,
    TableSeedModule,
    ConfigModule.forRoot({
      isGlobal: true,
      load: [databaseConfig, appConfig],
      envFilePath: ['.env'],
    }),
    TypeOrmModule.forRootAsync({
      useClass: TypeOrmConfigService,
      dataSourceFactory: async (options: DataSourceOptions) => {
        return new DataSource(options).initialize();
      },
    }),
  ],
})
export class SeedModule {}

================
File: backend/src/database/seeds/relational/table/table-seed.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TableSeedService } from './table-seed.service';
import { TableEntity } from '../../../../tables/infrastructure/persistence/relational/entities/table.entity';
import { AreaEntity } from '../../../../areas/infrastructure/persistence/relational/entities/area.entity';
@Module({
  imports: [TypeOrmModule.forFeature([TableEntity, AreaEntity])],
  providers: [TableSeedService],
  exports: [TableSeedService],
})
export class TableSeedModule {}

================
File: backend/src/database/seeds/relational/table/table-seed.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { TableEntity } from '../../../../tables/infrastructure/persistence/relational/entities/table.entity';
import { AreaEntity } from '../../../../areas/infrastructure/persistence/relational/entities/area.entity';
@Injectable()
export class TableSeedService {
  constructor(
    @InjectRepository(TableEntity)
    private tableRepository: Repository<TableEntity>,
    @InjectRepository(AreaEntity)
    private areaRepository: Repository<AreaEntity>,
  ) {}
  async run() {
    const bar = await this.areaRepository.findOne({
      where: { name: 'Bar' },
    });
    const arco = await this.areaRepository.findOne({
      where: { name: 'Arco' },
    });
    const jardin = await this.areaRepository.findOne({
      where: { name: 'Jardin' },
    });
    const entrada = await this.areaRepository.findOne({
      where: { name: 'Entrada' },
    });
    const equipales = await this.areaRepository.findOne({
      where: { name: 'Equipales' },
    });
    if (!bar || !arco || !jardin || !entrada || !equipales) {
      return;
    }
    const tables: any[] = [];
    for (let i = 1; i <= 12; i++) {
      tables.push({
        name: i.toString(),
        area: bar,
        capacity: 4,
        isActive: true,
        isAvailable: true,
      });
    }
    for (let i = 1; i <= 5; i++) {
      tables.push({
        name: i.toString(),
        area: entrada,
        capacity: 4,
        isActive: true,
        isAvailable: true,
      });
    }
    for (let i = 1; i <= 2; i++) {
      tables.push({
        name: i.toString(),
        area: equipales,
        capacity: 6,
        isActive: true,
        isAvailable: true,
      });
    }
    for (let i = 1; i <= 2; i++) {
      tables.push({
        name: i.toString(),
        area: arco,
        capacity: 4,
        isActive: true,
        isAvailable: true,
      });
    }
    for (let i = 1; i <= 4; i++) {
      tables.push({
        name: i.toString(),
        area: jardin,
        capacity: 4,
        isActive: true,
        isAvailable: true,
      });
    }
    for (const tableData of tables) {
      const existingTable = await this.tableRepository.findOne({
        where: {
          name: tableData.name,
          area: { id: tableData.area.id },
        },
      });
      if (!existingTable) {
        await this.tableRepository.save(
          this.tableRepository.create({
            ...tableData,
            isTemporary: false,
            temporaryIdentifier: null,
          }),
        );
      }
    }
  }
}

================
File: backend/src/database/seeds/relational/user/user-seed.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserSeedService } from './user-seed.service';
import { UserEntity } from '../../../../users/infrastructure/persistence/relational/entities/user.entity';
@Module({
  imports: [TypeOrmModule.forFeature([UserEntity])],
  providers: [UserSeedService],
  exports: [UserSeedService],
})
export class UserSeedModule {}

================
File: backend/src/database/seeds/relational/user/user-seed.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import bcrypt from 'bcryptjs';
import { RoleEnum } from '../../../../roles/roles.enum';
import { UserEntity } from '../../../../users/infrastructure/persistence/relational/entities/user.entity';
@Injectable()
export class UserSeedService {
  constructor(
    @InjectRepository(UserEntity)
    private repository: Repository<UserEntity>,
  ) {}
  async run() {
    const salt = await bcrypt.genSalt();
    const defaultPassword = await bcrypt.hash('secret', salt);
    const countAdmin = await this.repository.count({
      where: {
        role: {
          id: RoleEnum.admin,
        },
      },
    });
    if (!countAdmin) {
      await this.repository.save(
        this.repository.create({
          firstName: 'Carlos',
          lastName: 'Administrador',
          email: 'admin@example.com',
          username: 'admin',
          password: defaultPassword,
          role: {
            id: RoleEnum.admin,
            name: 'Admin',
          },
          isActive: true,
        }),
      );
    }
    const countManager = await this.repository.count({
      where: {
        role: {
          id: RoleEnum.manager,
        },
      },
    });
    if (!countManager) {
      await this.repository.save(
        this.repository.create({
          firstName: 'María',
          lastName: 'Gerente',
          email: 'manager@example.com',
          username: 'manager',
          password: defaultPassword,
          role: {
            id: RoleEnum.manager,
            name: 'Manager',
          },
          isActive: true,
        }),
      );
    }
    const countCashier = await this.repository.count({
      where: {
        role: {
          id: RoleEnum.cashier,
        },
      },
    });
    if (!countCashier) {
      await this.repository.save(
        this.repository.create({
          firstName: 'Ana',
          lastName: 'Cajera',
          email: 'cashier@example.com',
          username: 'cashier',
          password: defaultPassword,
          role: {
            id: RoleEnum.cashier,
            name: 'Cashier',
          },
          isActive: true,
        }),
      );
    }
    const countWaiter = await this.repository.count({
      where: {
        role: {
          id: RoleEnum.waiter,
        },
      },
    });
    if (!countWaiter) {
      await this.repository.save(
        this.repository.create({
          firstName: 'Luis',
          lastName: 'Mesero',
          email: 'waiter@example.com',
          username: 'waiter',
          password: defaultPassword,
          role: {
            id: RoleEnum.waiter,
            name: 'Waiter',
          },
          isActive: true,
        }),
      );
    }
    const countKitchen = await this.repository.count({
      where: {
        role: {
          id: RoleEnum.kitchen,
        },
      },
    });
    if (!countKitchen) {
      await this.repository.save(
        this.repository.create({
          firstName: 'Pedro',
          lastName: 'Cocinero',
          email: 'kitchen1@example.com',
          username: 'kitchen1',
          password: defaultPassword,
          role: {
            id: RoleEnum.kitchen,
            name: 'Kitchen',
          },
          isActive: true,
        }),
      );
      await this.repository.save(
        this.repository.create({
          firstName: 'Rosa',
          lastName: 'Chef',
          email: 'kitchen2@example.com',
          username: 'kitchen2',
          password: defaultPassword,
          role: {
            id: RoleEnum.kitchen,
            name: 'Kitchen',
          },
          isActive: true,
        }),
      );
      await this.repository.save(
        this.repository.create({
          firstName: 'Miguel',
          lastName: 'Parrillero',
          email: 'kitchen3@example.com',
          username: 'kitchen3',
          password: defaultPassword,
          role: {
            id: RoleEnum.kitchen,
            name: 'Kitchen',
          },
          isActive: true,
        }),
      );
    }
    const countDelivery = await this.repository.count({
      where: {
        role: {
          id: RoleEnum.delivery,
        },
      },
    });
    if (!countDelivery) {
      await this.repository.save(
        this.repository.create({
          firstName: 'Juan',
          lastName: 'Repartidor',
          email: 'delivery@example.com',
          username: 'delivery',
          password: defaultPassword,
          role: {
            id: RoleEnum.delivery,
            name: 'Delivery',
          },
          isActive: true,
        }),
      );
    }
  }
}

================
File: backend/src/discovery/discovery.module.ts
================
import { Module } from '@nestjs/common';
import { DiscoveryController } from './discovery.controller';
@Module({
  controllers: [DiscoveryController],
})
export class DiscoveryModule {}

================
File: backend/src/files/config/file-config.type.ts
================
export enum FileDriver {
  LOCAL = 'local',
  S3 = 's3',
  S3_PRESIGNED = 's3-presigned',
}
export type FileConfig = {
  driver: FileDriver;
  accessKeyId?: string;
  secretAccessKey?: string;
  awsDefaultS3Bucket?: string;
  awsS3Region?: string;
  maxFileSize: number;
};

================
File: backend/src/files/config/file.config.ts
================
import { registerAs } from '@nestjs/config';
import { IsEnum, IsString, ValidateIf } from 'class-validator';
import validateConfig from '../../utils/validate-config';
import { FileDriver, FileConfig } from './file-config.type';
class EnvironmentVariablesValidator {
  @IsEnum(FileDriver)
  FILE_DRIVER: FileDriver;
  @ValidateIf((envValues) =>
    [FileDriver.S3, FileDriver.S3_PRESIGNED].includes(envValues.FILE_DRIVER),
  )
  @IsString()
  ACCESS_KEY_ID: string;
  @ValidateIf((envValues) =>
    [FileDriver.S3, FileDriver.S3_PRESIGNED].includes(envValues.FILE_DRIVER),
  )
  @IsString()
  SECRET_ACCESS_KEY: string;
  @ValidateIf((envValues) =>
    [FileDriver.S3, FileDriver.S3_PRESIGNED].includes(envValues.FILE_DRIVER),
  )
  @IsString()
  AWS_DEFAULT_S3_BUCKET: string;
  @ValidateIf((envValues) =>
    [FileDriver.S3, FileDriver.S3_PRESIGNED].includes(envValues.FILE_DRIVER),
  )
  @IsString()
  AWS_S3_REGION: string;
}
export default registerAs<FileConfig>('file', () => {
  validateConfig(process.env, EnvironmentVariablesValidator);
  return {
    driver:
      (process.env.FILE_DRIVER as FileDriver | undefined) ?? FileDriver.LOCAL,
    accessKeyId: process.env.ACCESS_KEY_ID,
    secretAccessKey: process.env.SECRET_ACCESS_KEY,
    awsDefaultS3Bucket: process.env.AWS_DEFAULT_S3_BUCKET,
    awsS3Region: process.env.AWS_S3_REGION,
    maxFileSize: 10485760,
  };
});

================
File: backend/src/files/domain/file.ts
================
import { Allow } from 'class-validator';
import { Transform } from 'class-transformer';
import fileConfig from '../config/file.config';
import { FileConfig, FileDriver } from '../config/file-config.type';
import { GetObjectCommand, S3Client } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { AppConfig } from '../../config/app-config.type';
import appConfig from '../../config/app.config';
export class FileType {
  @Allow()
  id: string;
  @Transform(
    ({ value }) => {
      if (!value) {
        return null;
      }
      if ((fileConfig() as FileConfig).driver === FileDriver.LOCAL) {
        return (appConfig() as AppConfig).backendDomain + value;
      } else if (
        [FileDriver.S3_PRESIGNED, FileDriver.S3].includes(
          (fileConfig() as FileConfig).driver,
        )
      ) {
        const s3 = new S3Client({
          region: (fileConfig() as FileConfig).awsS3Region ?? '',
          credentials: {
            accessKeyId: (fileConfig() as FileConfig).accessKeyId ?? '',
            secretAccessKey: (fileConfig() as FileConfig).secretAccessKey ?? '',
          },
        });
        const command = new GetObjectCommand({
          Bucket: (fileConfig() as FileConfig).awsDefaultS3Bucket ?? '',
          Key: value,
        });
        return getSignedUrl(s3, command, { expiresIn: 3600 });
      }
      return value;
    },
    {
      toPlainOnly: true,
    },
  )
  path: string;
}

================
File: backend/src/files/dto/file.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';
export class FileDto {
  @ApiProperty()
  @IsString()
  @IsNotEmpty()
  id: string;
  path: string;
}

================
File: backend/src/files/files.module.ts
================
import { Module } from '@nestjs/common';
import { RelationalFilePersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { FilesService } from './files.service';
import fileConfig from './config/file.config';
import { FileConfig, FileDriver } from './config/file-config.type';
import { FilesLocalModule } from './infrastructure/uploader/local/files.module';
import { FilesS3Module } from './infrastructure/uploader/s3/files.module';
import { FilesS3PresignedModule } from './infrastructure/uploader/s3-presigned/files.module';
const infrastructurePersistenceModule = RelationalFilePersistenceModule;
const infrastructureUploaderModule =
  (fileConfig() as FileConfig).driver === FileDriver.LOCAL
    ? FilesLocalModule
    : (fileConfig() as FileConfig).driver === FileDriver.S3
      ? FilesS3Module
      : FilesS3PresignedModule;
@Module({
  imports: [infrastructurePersistenceModule, infrastructureUploaderModule],
  providers: [FilesService],
  exports: [FilesService, infrastructurePersistenceModule],
})
export class FilesModule {}

================
File: backend/src/files/files.service.ts
================
import { Inject, Injectable } from '@nestjs/common';
import { FileRepository } from './infrastructure/persistence/file.repository';
import { FileType } from './domain/file';
import { NullableType } from '../utils/types/nullable.type';
import { FILE_REPOSITORY } from '../common/tokens';
@Injectable()
export class FilesService {
  constructor(
    @Inject(FILE_REPOSITORY)
    private readonly fileRepository: FileRepository,
  ) {}
  findById(id: FileType['id']): Promise<NullableType<FileType>> {
    return this.fileRepository.findById(id);
  }
  findByIds(ids: FileType['id'][]): Promise<FileType[]> {
    return this.fileRepository.findByIds(ids);
  }
}

================
File: backend/src/files/infrastructure/persistence/file.repository.ts
================
import { NullableType } from '../../../utils/types/nullable.type';
import { FileType } from '../../domain/file';
export abstract class FileRepository {
  abstract create(data: Omit<FileType, 'id'>): Promise<FileType>;
  abstract findById(id: FileType['id']): Promise<NullableType<FileType>>;
  abstract findByIds(ids: FileType['id'][]): Promise<FileType[]>;
}

================
File: backend/src/files/infrastructure/persistence/relational/entities/file.entity.ts
================
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
@Entity({ name: 'file' })
export class FileEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column()
  path: string;
}

================
File: backend/src/files/infrastructure/persistence/relational/mappers/file.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { FileType } from '../../../../domain/file';
import { FileEntity } from '../entities/file.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class FileMapper extends BaseMapper<FileEntity, FileType> {
  override toDomain(entity: FileEntity): FileType | null {
    if (!entity) return null;
    const domain = new FileType();
    domain.id = entity.id;
    domain.path = entity.path;
    return domain;
  }
  override toEntity(domain: FileType): FileEntity | null {
    if (!domain) return null;
    const entity = new FileEntity();
    entity.id = domain.id;
    entity.path = domain.path;
    return entity;
  }
}

================
File: backend/src/files/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { FileEntity } from './entities/file.entity';
import { FileRelationalRepository } from './repositories/file.repository';
import { FileMapper } from './mappers/file.mapper';
import { FILE_REPOSITORY } from '../../../../common/tokens';
@Module({
  imports: [TypeOrmModule.forFeature([FileEntity])],
  providers: [
    {
      provide: FILE_REPOSITORY,
      useClass: FileRelationalRepository,
    },
    FileMapper,
  ],
  exports: [FILE_REPOSITORY, FileMapper],
})
export class RelationalFilePersistenceModule {}

================
File: backend/src/files/infrastructure/persistence/relational/repositories/file.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FileEntity } from '../entities/file.entity';
import { In, Repository } from 'typeorm';
import { FileRepository } from '../../file.repository';
import { FileMapper } from '../mappers/file.mapper';
import { FileType } from '../../../../domain/file';
import { NullableType } from '../../../../../utils/types/nullable.type';
@Injectable()
export class FileRelationalRepository implements FileRepository {
  constructor(
    @InjectRepository(FileEntity)
    private readonly fileRepository: Repository<FileEntity>,
    private readonly fileMapper: FileMapper,
  ) {}
  async create(data: Omit<FileType, 'id'>): Promise<FileType> {
    const entity = this.fileRepository.create({ path: data.path });
    const saved = await this.fileRepository.save(entity);
    return this.fileMapper.toDomain(saved)!;
  }
  async findById(id: FileType['id']): Promise<NullableType<FileType>> {
    const entity = await this.fileRepository.findOne({
      where: {
        id: id,
      },
    });
    return entity ? this.fileMapper.toDomain(entity) : null;
  }
  async findByIds(ids: FileType['id'][]): Promise<FileType[]> {
    const entities = await this.fileRepository.find({
      where: {
        id: In(ids),
      },
    });
    return entities.map((entity) => this.fileMapper.toDomain(entity)!);
  }
}

================
File: backend/src/files/infrastructure/uploader/local/dto/file-response.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { FileType } from '../../../../domain/file';
export class FileResponseDto {
  @ApiProperty({
    type: () => FileType,
  })
  file: FileType;
}

================
File: backend/src/files/infrastructure/uploader/local/files.controller.ts
================
import {
  Controller,
  Get,
  Param,
  Post,
  Response,
  UploadedFile,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import {
  ApiBearerAuth,
  ApiBody,
  ApiConsumes,
  ApiCreatedResponse,
  ApiExcludeEndpoint,
  ApiTags,
} from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { FilesLocalService } from './files.service';
import { FileResponseDto } from './dto/file-response.dto';
@ApiTags('Files')
@Controller({
  path: 'files',
  version: '1',
})
export class FilesLocalController {
  constructor(private readonly filesService: FilesLocalService) {}
  @ApiCreatedResponse({
    type: FileResponseDto,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  @Post('upload')
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  @UseInterceptors(FileInterceptor('file'))
  async uploadFile(
    @UploadedFile() file: Express.Multer.File,
  ): Promise<FileResponseDto> {
    if (!file) {
      throw new Error('No file uploaded');
    }
    try {
      const result = await this.filesService.create(file);
      return result;
    } catch (error) {
      throw error;
    }
  }
  @Get(':path')
  @ApiExcludeEndpoint()
  download(@Param('path') path, @Response() response) {
    return response.sendFile(path, { root: './files' });
  }
}

================
File: backend/src/files/infrastructure/uploader/local/files.module.ts
================
import {
  HttpStatus,
  Module,
  UnprocessableEntityException,
  MiddlewareConsumer,
  NestModule,
} from '@nestjs/common';
import { FilesLocalController } from './files.controller';
import { MulterModule } from '@nestjs/platform-express';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { diskStorage } from 'multer';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { FilesLocalService } from './files.service';
import { RelationalFilePersistenceModule } from '../../persistence/relational/relational-persistence.module';
import { AllConfigType } from '../../../../config/config.type';
import { UploadTimeoutMiddleware } from '../upload.middleware';
const infrastructurePersistenceModule = RelationalFilePersistenceModule;
@Module({
  imports: [
    infrastructurePersistenceModule,
    MulterModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService<AllConfigType>) => {
        return {
          fileFilter: (request, file, callback) => {
            if (!file.originalname.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
              return callback(
                new UnprocessableEntityException({
                  status: HttpStatus.UNPROCESSABLE_ENTITY,
                  errors: {
                    file: `cantUploadFileType`,
                  },
                }),
                false,
              );
            }
            callback(null, true);
          },
          storage: diskStorage({
            destination: './files',
            filename: (request, file, callback) => {
              callback(
                null,
                `${randomStringGenerator()}.${file.originalname
                  .split('.')
                  .pop()
                  ?.toLowerCase()}`,
              );
            },
          }),
          limits: {
            fileSize: configService.get('file.maxFileSize', { infer: true }),
          },
        };
      },
    }),
  ],
  controllers: [FilesLocalController],
  providers: [
    ConfigModule,
    ConfigService,
    FilesLocalService,
    UploadTimeoutMiddleware,
  ],
  exports: [FilesLocalService],
})
export class FilesLocalModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(UploadTimeoutMiddleware).forRoutes('files/upload');
  }
}

================
File: backend/src/files/infrastructure/uploader/local/files.service.ts
================
import {
  HttpStatus,
  Inject,
  Injectable,
  UnprocessableEntityException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { FileRepository } from '../../persistence/file.repository';
import { AllConfigType } from '../../../../config/config.type';
import { FileType } from '../../../domain/file';
import { FILE_REPOSITORY } from '../../../../common/tokens';
@Injectable()
export class FilesLocalService {
  constructor(
    private readonly configService: ConfigService<AllConfigType>,
    @Inject(FILE_REPOSITORY)
    private readonly fileRepository: FileRepository,
  ) {}
  async create(file: Express.Multer.File): Promise<{ file: FileType }> {
    if (!file) {
      throw new UnprocessableEntityException({
        status: HttpStatus.UNPROCESSABLE_ENTITY,
        errors: {
          file: 'selectFile',
        },
      });
    }
    return {
      file: await this.fileRepository.create({
        path: `/${this.configService.get('app.apiPrefix', {
          infer: true,
        })}/v1/${file.path}`,
      }),
    };
  }
}

================
File: backend/src/files/infrastructure/uploader/s3-presigned/dto/file-response.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { FileType } from '../../../../domain/file';
export class FileResponseDto {
  @ApiProperty({
    type: () => FileType,
  })
  file: FileType;
  @ApiProperty({
    type: String,
  })
  uploadSignedUrl: string;
}

================
File: backend/src/files/infrastructure/uploader/s3-presigned/dto/file.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNumber, IsString } from 'class-validator';
export class FileUploadDto {
  @ApiProperty({ example: 'image.jpg' })
  @IsString()
  fileName: string;
  @ApiProperty({ example: 138723 })
  @IsNumber()
  fileSize: number;
}

================
File: backend/src/files/infrastructure/uploader/s3-presigned/files.controller.ts
================
import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiCreatedResponse, ApiTags } from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { FilesS3PresignedService } from './files.service';
import { FileUploadDto } from './dto/file.dto';
import { FileResponseDto } from './dto/file-response.dto';
@ApiTags('Files')
@Controller({
  path: 'files',
  version: '1',
})
export class FilesS3PresignedController {
  constructor(private readonly filesService: FilesS3PresignedService) {}
  @ApiCreatedResponse({
    type: FileResponseDto,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  @Post('upload')
  async uploadFile(@Body() file: FileUploadDto) {
    return this.filesService.create(file);
  }
}

================
File: backend/src/files/infrastructure/uploader/s3-presigned/files.module.ts
================
import {
  HttpStatus,
  Module,
  UnprocessableEntityException,
} from '@nestjs/common';
import { FilesS3PresignedController } from './files.controller';
import { MulterModule } from '@nestjs/platform-express';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { S3Client } from '@aws-sdk/client-s3';
import multerS3 from 'multer-s3';
import { FilesS3PresignedService } from './files.service';
import { RelationalFilePersistenceModule } from '../../persistence/relational/relational-persistence.module';
import { AllConfigType } from '../../../../config/config.type';
const infrastructurePersistenceModule = RelationalFilePersistenceModule;
@Module({
  imports: [
    infrastructurePersistenceModule,
    MulterModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService<AllConfigType>) => {
        const s3 = new S3Client({
          region: configService.get('file.awsS3Region', { infer: true }),
          credentials: {
            accessKeyId: configService.getOrThrow('file.accessKeyId', {
              infer: true,
            }),
            secretAccessKey: configService.getOrThrow('file.secretAccessKey', {
              infer: true,
            }),
          },
        });
        return {
          fileFilter: (request, file, callback) => {
            if (!file.originalname.match(/\.(jpg|jpeg|png|gif)$/i)) {
              return callback(
                new UnprocessableEntityException({
                  status: HttpStatus.UNPROCESSABLE_ENTITY,
                  errors: {
                    file: `cantUploadFileType`,
                  },
                }),
                false,
              );
            }
            callback(null, true);
          },
          storage: multerS3({
            s3: s3 as any,
            bucket: '',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            key: (request, file, callback) => {
              callback(
                null,
                `${randomStringGenerator()}.${file.originalname
                  .split('.')
                  .pop()
                  ?.toLowerCase()}`,
              );
            },
          }),
          limits: {
            fileSize: configService.get('file.maxFileSize', { infer: true }),
          },
        };
      },
    }),
  ],
  controllers: [FilesS3PresignedController],
  providers: [ConfigModule, ConfigService, FilesS3PresignedService],
  exports: [FilesS3PresignedService],
})
export class FilesS3PresignedModule {}

================
File: backend/src/files/infrastructure/uploader/s3-presigned/files.service.ts
================
import {
  HttpStatus,
  Injectable,
  PayloadTooLargeException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { FileRepository } from '../../persistence/file.repository';
import { FileUploadDto } from './dto/file.dto';
import { PutObjectCommand, S3Client } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { ConfigService } from '@nestjs/config';
import { FileType } from '../../../domain/file';
@Injectable()
export class FilesS3PresignedService {
  private s3: S3Client;
  constructor(
    private readonly fileRepository: FileRepository,
    private readonly configService: ConfigService,
  ) {
    this.s3 = new S3Client({
      region: configService.get('file.awsS3Region', { infer: true }),
      credentials: {
        accessKeyId: configService.getOrThrow('file.accessKeyId', {
          infer: true,
        }),
        secretAccessKey: configService.getOrThrow('file.secretAccessKey', {
          infer: true,
        }),
      },
    });
  }
  async create(
    file: FileUploadDto,
  ): Promise<{ file: FileType; uploadSignedUrl: string }> {
    if (!file) {
      throw new UnprocessableEntityException({
        status: HttpStatus.UNPROCESSABLE_ENTITY,
        errors: {
          file: 'selectFile',
        },
      });
    }
    if (!file.fileName.match(/\.(jpg|jpeg|png|gif)$/i)) {
      throw new UnprocessableEntityException({
        status: HttpStatus.UNPROCESSABLE_ENTITY,
        errors: {
          file: `cantUploadFileType`,
        },
      });
    }
    if (
      file.fileSize >
      (this.configService.get('file.maxFileSize', {
        infer: true,
      }) || 0)
    ) {
      throw new PayloadTooLargeException({
        statusCode: HttpStatus.PAYLOAD_TOO_LARGE,
        error: 'Payload Too Large',
        message: 'File too large',
      });
    }
    const key = `${randomStringGenerator()}.${file.fileName
      .split('.')
      .pop()
      ?.toLowerCase()}`;
    const command = new PutObjectCommand({
      Bucket: this.configService.getOrThrow('file.awsDefaultS3Bucket', {
        infer: true,
      }),
      Key: key,
      ContentLength: file.fileSize,
    });
    const signedUrl = await getSignedUrl(this.s3, command, { expiresIn: 3600 });
    const data = await this.fileRepository.create({
      path: key,
    });
    return {
      file: data,
      uploadSignedUrl: signedUrl,
    };
  }
}

================
File: backend/src/files/infrastructure/uploader/s3/dto/file-response.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { FileType } from '../../../../domain/file';
export class FileResponseDto {
  @ApiProperty({
    type: () => FileType,
  })
  file: FileType;
}

================
File: backend/src/files/infrastructure/uploader/s3/files.controller.ts
================
import {
  Controller,
  Post,
  UploadedFile,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import {
  ApiBearerAuth,
  ApiBody,
  ApiConsumes,
  ApiCreatedResponse,
  ApiTags,
} from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { FilesS3Service } from './files.service';
import { FileResponseDto } from './dto/file-response.dto';
@ApiTags('Files')
@Controller({
  path: 'files',
  version: '1',
})
export class FilesS3Controller {
  constructor(private readonly filesService: FilesS3Service) {}
  @ApiCreatedResponse({
    type: FileResponseDto,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  @Post('upload')
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  @UseInterceptors(FileInterceptor('file'))
  async uploadFile(
    @UploadedFile() file: Express.MulterS3.File,
  ): Promise<FileResponseDto> {
    return this.filesService.create(file);
  }
}

================
File: backend/src/files/infrastructure/uploader/s3/files.module.ts
================
import {
  HttpStatus,
  Module,
  UnprocessableEntityException,
} from '@nestjs/common';
import { FilesS3Controller } from './files.controller';
import { MulterModule } from '@nestjs/platform-express';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { S3Client } from '@aws-sdk/client-s3';
import multerS3 from 'multer-s3';
import { FilesS3Service } from './files.service';
import { RelationalFilePersistenceModule } from '../../persistence/relational/relational-persistence.module';
import { AllConfigType } from '../../../../config/config.type';
const infrastructurePersistenceModule = RelationalFilePersistenceModule;
@Module({
  imports: [
    infrastructurePersistenceModule,
    MulterModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService<AllConfigType>) => {
        const s3 = new S3Client({
          region: configService.get('file.awsS3Region', { infer: true }),
          credentials: {
            accessKeyId: configService.getOrThrow('file.accessKeyId', {
              infer: true,
            }),
            secretAccessKey: configService.getOrThrow('file.secretAccessKey', {
              infer: true,
            }),
          },
        });
        return {
          fileFilter: (request, file, callback) => {
            if (!file.originalname.match(/\.(jpg|jpeg|png|gif)$/i)) {
              return callback(
                new UnprocessableEntityException({
                  status: HttpStatus.UNPROCESSABLE_ENTITY,
                  errors: {
                    file: `cantUploadFileType`,
                  },
                }),
                false,
              );
            }
            callback(null, true);
          },
          storage: multerS3({
            s3: s3 as any,
            bucket: configService.getOrThrow('file.awsDefaultS3Bucket', {
              infer: true,
            }),
            contentType: multerS3.AUTO_CONTENT_TYPE,
            key: (request, file, callback) => {
              callback(
                null,
                `${randomStringGenerator()}.${file.originalname
                  .split('.')
                  .pop()
                  ?.toLowerCase()}`,
              );
            },
          }),
          limits: {
            fileSize: configService.get('file.maxFileSize', { infer: true }),
          },
        };
      },
    }),
  ],
  controllers: [FilesS3Controller],
  providers: [FilesS3Service],
  exports: [FilesS3Service],
})
export class FilesS3Module {}

================
File: backend/src/files/infrastructure/uploader/s3/files.service.ts
================
import {
  HttpStatus,
  Injectable,
  UnprocessableEntityException,
} from '@nestjs/common';
import { FileRepository } from '../../persistence/file.repository';
import { FileType } from '../../../domain/file';
@Injectable()
export class FilesS3Service {
  constructor(private readonly fileRepository: FileRepository) {}
  async create(file: Express.MulterS3.File): Promise<{ file: FileType }> {
    if (!file) {
      throw new UnprocessableEntityException({
        status: HttpStatus.UNPROCESSABLE_ENTITY,
        errors: {
          file: 'selectFile',
        },
      });
    }
    return {
      file: await this.fileRepository.create({
        path: file.key,
      }),
    };
  }
}

================
File: backend/src/files/infrastructure/uploader/upload.middleware.ts
================
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
@Injectable()
export class UploadTimeoutMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    if (req.path.includes('/upload')) {
      req.setTimeout(300000);
      res.setTimeout(300000);
    }
    next();
  }
}

================
File: backend/src/health/health.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
@ApiTags('Health')
@Controller({
  path: 'health',
  version: '1',
})
export class HealthController {
  private readonly startTime = Date.now();
  @Get()
  @ApiOperation({ summary: 'Check API health status' })
  @ApiResponse({
    status: 200,
    description: 'API is healthy',
    schema: {
      type: 'object',
      properties: {
        status: { type: 'string', example: 'ok' },
        timestamp: { type: 'number', example: 1234567890123 },
        uptime: { type: 'number', example: 3600000 },
        version: { type: 'string', example: '1.0.0' },
      },
    },
  })
  getHealth() {
    return {
      status: 'ok',
      timestamp: Date.now(),
      uptime: Date.now() - this.startTime,
      version: process.env.npm_package_version || '1.0.0',
    };
  }
}

================
File: backend/src/health/health.module.ts
================
import { Module } from '@nestjs/common';
import { HealthController } from './health.controller';
@Module({
  controllers: [HealthController],
})
export class HealthModule {}

================
File: backend/src/home/home.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { HomeService } from './home.service';
@ApiTags('Home')
@Controller({
  path: '/',
  version: '1',
})
export class HomeController {
  constructor(private service: HomeService) {}
  @Get()
  appInfo() {
    return this.service.appInfo();
  }
}

================
File: backend/src/home/home.module.ts
================
import { Module } from '@nestjs/common';
import { HomeService } from './home.service';
import { HomeController } from './home.controller';
import { ConfigModule } from '@nestjs/config';
@Module({
  imports: [ConfigModule],
  controllers: [HomeController],
  providers: [HomeService],
})
export class HomeModule {}

================
File: backend/src/home/home.service.ts
================
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { AllConfigType } from '../config/config.type';
@Injectable()
export class HomeService {
  constructor(private configService: ConfigService<AllConfigType>) {}
  appInfo() {
    return { name: this.configService.get('app.name', { infer: true }) };
  }
}

================
File: backend/src/kitchen/dto/kitchen-order-filter.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsEnum, IsOptional, IsUUID } from 'class-validator';
import { Transform } from 'class-transformer';
import { OrderType } from '../../orders/domain/enums/order-type.enum';
export class KitchenOrderFilterDto {
  @ApiProperty({
    enum: OrderType,
    description: 'Filtrar por tipo de orden',
    required: false,
  })
  @IsOptional()
  @IsEnum(OrderType)
  orderType?: OrderType;
  @ApiProperty({
    type: Boolean,
    description: 'Mostrar órdenes con productos preparados',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => value === 'true' || value === true)
  showPrepared?: boolean;
  @ApiProperty({
    type: Boolean,
    description: 'Mostrar todos los productos (no solo de mi pantalla)',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => value === 'true' || value === true)
  showAllProducts?: boolean;
  @ApiProperty({
    type: Boolean,
    description: 'Desagrupar productos idénticos',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => value === 'true' || value === true)
  ungroupProducts?: boolean;
  @ApiProperty({
    type: String,
    description:
      'ID de la pantalla de preparación (opcional, se obtiene del usuario)',
    required: false,
  })
  @IsOptional()
  @IsUUID()
  screenId?: string;
}

================
File: backend/src/kitchen/dto/mark-item-prepared.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsOptional } from 'class-validator';
export class MarkItemPreparedDto {
  @ApiProperty({
    type: Boolean,
    description: 'Si el item está preparado o no',
    default: true,
  })
  @IsOptional()
  @IsBoolean()
  isPrepared?: boolean;
}

================
File: backend/src/kitchen/kitchen.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { KitchenController } from './controllers/kitchen.controller';
import { KitchenService } from './services/kitchen.service';
import { OrderEntity } from '../orders/infrastructure/persistence/relational/entities/order.entity';
import { OrderItemEntity } from '../orders/infrastructure/persistence/relational/entities/order-item.entity';
import { UserEntity } from '../users/infrastructure/persistence/relational/entities/user.entity';
import { PreparationScreenEntity } from '../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import { RelationalOrderPersistenceModule } from '../orders/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([
      OrderEntity,
      OrderItemEntity,
      UserEntity,
      PreparationScreenEntity,
    ]),
    forwardRef(() => RelationalOrderPersistenceModule),
  ],
  controllers: [KitchenController],
  providers: [KitchenService],
  exports: [KitchenService],
})
export class KitchenModule {}

================
File: backend/src/mail/config/mail-config.type.ts
================
export type MailConfig = {
  port: number;
  host?: string;
  user?: string;
  password?: string;
  defaultEmail?: string;
  defaultName?: string;
  ignoreTLS: boolean;
  secure: boolean;
  requireTLS: boolean;
};

================
File: backend/src/mail/config/mail.config.ts
================
import { registerAs } from '@nestjs/config';
import {
  IsString,
  IsInt,
  Min,
  Max,
  IsOptional,
  IsBoolean,
  IsEmail,
} from 'class-validator';
import validateConfig from '../../utils/validate-config';
import { MailConfig } from './mail-config.type';
class EnvironmentVariablesValidator {
  @IsInt()
  @Min(0)
  @Max(65535)
  @IsOptional()
  MAIL_PORT: number;
  @IsString()
  MAIL_HOST: string;
  @IsString()
  @IsOptional()
  MAIL_USER: string;
  @IsString()
  @IsOptional()
  MAIL_PASSWORD: string;
  @IsEmail()
  MAIL_DEFAULT_EMAIL: string;
  @IsString()
  MAIL_DEFAULT_NAME: string;
  @IsBoolean()
  MAIL_IGNORE_TLS: boolean;
  @IsBoolean()
  MAIL_SECURE: boolean;
  @IsBoolean()
  MAIL_REQUIRE_TLS: boolean;
}
export default registerAs<MailConfig>('mail', () => {
  validateConfig(process.env, EnvironmentVariablesValidator);
  return {
    port: process.env.MAIL_PORT ? parseInt(process.env.MAIL_PORT, 10) : 587,
    host: process.env.MAIL_HOST,
    user: process.env.MAIL_USER,
    password: process.env.MAIL_PASSWORD,
    defaultEmail: process.env.MAIL_DEFAULT_EMAIL,
    defaultName: process.env.MAIL_DEFAULT_NAME,
    ignoreTLS: process.env.MAIL_IGNORE_TLS === 'true',
    secure: process.env.MAIL_SECURE === 'true',
    requireTLS: process.env.MAIL_REQUIRE_TLS === 'true',
  };
});

================
File: backend/src/mail/interfaces/mail-data.interface.ts
================
export interface MailData<T = never> {
  to: string;
  data: T;
}

================
File: backend/src/mail/mail-templates/activation.hbs
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=">
    <title>{{title}}</title>
</head>

<body style="margin:0;font-family:arial">
    <table style="border:0;width:100%">
        <tr style="background:#eeeeee">
            <td style="padding:20px;color:#808080;text-align:center;font-size:40px;font-weight:600">
                {{app_name}}
            </td>
        </tr>
        <tr>
            <td style="padding:20px;color:#808080;font-size:16px;font-weight:100">
                {{text1}}<br>
                {{text2}} {{app_name}}.<br>
                {{text3}}
            </td>
        </tr>
        <tr>
            <td style="text-align:center">
                <a href="{{url}}"
                    style="display:inline-block;padding:20px;background:#00838f;text-decoration:none;color:#ffffff">{{actionTitle}}</a>
            </td>
        </tr>
    </table>
</body>

</html>

================
File: backend/src/mail/mail-templates/confirm-new-email.hbs
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=">
    <title>{{title}}</title>
</head>

<body style="margin:0;font-family:arial">
    <table style="border:0;width:100%">
        <tr style="background:#eeeeee">
            <td style="padding:20px;color:#808080;text-align:center;font-size:40px;font-weight:600">
                {{app_name}}
            </td>
        </tr>
        <tr>
            <td style="padding:20px;color:#808080;font-size:16px;font-weight:100">
                {{text1}}<br>
                {{text2}}<br>
                {{text3}}
            </td>
        </tr>
        <tr>
            <td style="text-align:center">
                <a href="{{url}}"
                    style="display:inline-block;padding:20px;background:#00838f;text-decoration:none;color:#ffffff">{{actionTitle}}</a>
            </td>
        </tr>
    </table>
</body>

</html>

================
File: backend/src/mail/mail-templates/reset-password.hbs
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=">
    <title>{{title}}</title>
</head>

<body style="margin:0;font-family:arial">
    <table style="border:0;width:100%">
        <tr style="background:#eeeeee">
            <td style="padding:20px;color:#808080;text-align:center;font-size:40px;font-weight:600">
                {{app_name}}
            </td>
        </tr>
        <tr>
            <td style="padding:20px;color:#808080;font-size:16px;font-weight:100">
                {{text1}}<br>
                {{text2}}<br>
                {{text3}}
            </td>
        </tr>
        <tr>
            <td style="text-align:center">
                <a href="{{url}}"
                    style="display:inline-block;padding:20px;background:#00838f;text-decoration:none;color:#ffffff">{{actionTitle}}</a>
            </td>
        </tr>
        <tr>
            <td style="padding:20px;color:#808080;font-size:16px;font-weight:100">
                {{text4}}
            </td>
        </tr>
    </table>
</body>

</html>

================
File: backend/src/mail/mail.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { MailService } from './mail.service';
import { MailerModule } from '../mailer/mailer.module';
@Module({
  imports: [ConfigModule, MailerModule],
  providers: [MailService],
  exports: [MailService],
})
export class MailModule {}

================
File: backend/src/mail/mail.service.ts
================
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { MailData } from './interfaces/mail-data.interface';
import { MaybeType } from '../utils/types/maybe.type';
import { MailerService } from '../mailer/mailer.service';
import path from 'path';
import { AllConfigType } from '../config/config.type';
@Injectable()
export class MailService {
  constructor(
    private readonly mailerService: MailerService,
    private readonly configService: ConfigService<AllConfigType>,
  ) {}
  async userSignUp(mailData: MailData<{ hash: string }>): Promise<void> {
    const emailConfirmTitle: MaybeType<string> = 'Confirm Email';
    const text1: MaybeType<string> = '';
    const text2: MaybeType<string> = '';
    const text3: MaybeType<string> = '';
    const url = new URL(
      this.configService.getOrThrow('app.frontendDomain', {
        infer: true,
      }) + '/confirm-email',
    );
    url.searchParams.set('hash', mailData.data.hash);
    await this.mailerService.sendMail({
      to: mailData.to,
      subject: emailConfirmTitle,
      text: `${url.toString()} ${emailConfirmTitle}`,
      templatePath: path.join(
        this.configService.getOrThrow('app.workingDirectory', {
          infer: true,
        }),
        'src',
        'mail',
        'mail-templates',
        'activation.hbs',
      ),
      context: {
        title: emailConfirmTitle,
        url: url.toString(),
        actionTitle: emailConfirmTitle,
        app_name: this.configService.get('app.name', { infer: true }),
        text1,
        text2,
        text3,
      },
    });
  }
  async forgotPassword(
    mailData: MailData<{ hash: string; tokenExpires: number }>,
  ): Promise<void> {
    const resetPasswordTitle: MaybeType<string> = 'Reset Password';
    const text1: MaybeType<string> = '';
    const text2: MaybeType<string> = '';
    const text3: MaybeType<string> = '';
    const text4: MaybeType<string> = '';
    const url = new URL(
      this.configService.getOrThrow('app.frontendDomain', {
        infer: true,
      }) + '/password-change',
    );
    url.searchParams.set('hash', mailData.data.hash);
    url.searchParams.set('expires', mailData.data.tokenExpires.toString());
    await this.mailerService.sendMail({
      to: mailData.to,
      subject: resetPasswordTitle,
      text: `${url.toString()} ${resetPasswordTitle}`,
      templatePath: path.join(
        this.configService.getOrThrow('app.workingDirectory', {
          infer: true,
        }),
        'src',
        'mail',
        'mail-templates',
        'reset-password.hbs',
      ),
      context: {
        title: resetPasswordTitle,
        url: url.toString(),
        actionTitle: resetPasswordTitle,
        app_name: this.configService.get('app.name', {
          infer: true,
        }),
        text1,
        text2,
        text3,
        text4,
      },
    });
  }
  async confirmNewEmail(mailData: MailData<{ hash: string }>): Promise<void> {
    const emailConfirmTitle: MaybeType<string> = 'Confirm New Email';
    const text1: MaybeType<string> = '';
    const text2: MaybeType<string> = '';
    const text3: MaybeType<string> = '';
    const url = new URL(
      this.configService.getOrThrow('app.frontendDomain', {
        infer: true,
      }) + '/confirm-new-email',
    );
    url.searchParams.set('hash', mailData.data.hash);
    await this.mailerService.sendMail({
      to: mailData.to,
      subject: emailConfirmTitle,
      text: `${url.toString()} ${emailConfirmTitle}`,
      templatePath: path.join(
        this.configService.getOrThrow('app.workingDirectory', {
          infer: true,
        }),
        'src',
        'mail',
        'mail-templates',
        'confirm-new-email.hbs',
      ),
      context: {
        title: emailConfirmTitle,
        url: url.toString(),
        actionTitle: emailConfirmTitle,
        app_name: this.configService.get('app.name', { infer: true }),
        text1,
        text2,
        text3,
      },
    });
  }
}

================
File: backend/src/mailer/mailer.module.ts
================
import { Module } from '@nestjs/common';
import { MailerService } from './mailer.service';
@Module({
  providers: [MailerService],
  exports: [MailerService],
})
export class MailerModule {}

================
File: backend/src/mailer/mailer.service.ts
================
import { Injectable } from '@nestjs/common';
import fs from 'node:fs/promises';
import { ConfigService } from '@nestjs/config';
import nodemailer from 'nodemailer';
import Handlebars from 'handlebars';
import { AllConfigType } from '../config/config.type';
@Injectable()
export class MailerService {
  private readonly transporter: nodemailer.Transporter;
  constructor(private readonly configService: ConfigService<AllConfigType>) {
    this.transporter = nodemailer.createTransport({
      host: configService.get('mail.host', { infer: true }),
      port: configService.get('mail.port', { infer: true }),
      ignoreTLS: configService.get('mail.ignoreTLS', { infer: true }),
      secure: configService.get('mail.secure', { infer: true }),
      requireTLS: configService.get('mail.requireTLS', { infer: true }),
      auth: {
        user: configService.get('mail.user', { infer: true }),
        pass: configService.get('mail.password', { infer: true }),
      },
    });
  }
  async sendMail({
    templatePath,
    context,
    ...mailOptions
  }: nodemailer.SendMailOptions & {
    templatePath: string;
    context: Record<string, unknown>;
  }): Promise<void> {
    let html: string | undefined;
    if (templatePath) {
      const template = await fs.readFile(templatePath, 'utf-8');
      html = Handlebars.compile(template, {
        strict: true,
      })(context);
    }
    await this.transporter.sendMail({
      ...mailOptions,
      from: mailOptions.from
        ? mailOptions.from
        : `"${this.configService.get('mail.defaultName', {
            infer: true,
          })}" <${this.configService.get('mail.defaultEmail', {
            infer: true,
          })}>`,
      html: mailOptions.html ? mailOptions.html : html,
    });
  }
}

================
File: backend/src/modifier-groups/domain/modifier-group.ts
================
import { ProductModifier } from '../../product-modifiers/domain/product-modifier';
import { Product } from '../../products/domain/product';
export class ModifierGroup {
  id: string;
  name: string;
  description: string | null;
  minSelections: number;
  maxSelections: number;
  isRequired: boolean;
  allowMultipleSelections: boolean;
  isActive: boolean;
  sortOrder: number;
  productModifiers: ProductModifier[];
  products: Product[];
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/modifier-groups/dto/create-modifier-group.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsInt,
  IsNotEmpty,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
export class CreateModifierGroupDto {
  @ApiProperty({
    type: String,
    example: 'Tamaños',
    description: 'Nombre del grupo de modificadores',
  })
  @IsNotEmpty()
  @IsString()
  name: string;
  @ApiProperty({
    type: String,
    example: 'Selecciona el tamaño de tu bebida',
    description: 'Descripción del grupo de modificadores',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  description?: string | null;
  @ApiProperty({
    type: Number,
    example: 0,
    description: 'Número mínimo de selecciones',
    default: 0,
  })
  @IsInt()
  @Min(0)
  @IsOptional()
  minSelections?: number;
  @ApiProperty({
    type: Number,
    example: 1,
    description: 'Número máximo de selecciones',
  })
  @IsInt()
  @Min(1)
  @IsNotEmpty()
  maxSelections: number;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si el grupo de modificadores es requerido',
    default: false,
  })
  @IsBoolean()
  @IsOptional()
  isRequired?: boolean;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si se permiten múltiples selecciones',
    default: false,
  })
  @IsBoolean()
  @IsOptional()
  allowMultipleSelections?: boolean;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si el grupo de modificadores está activo',
    default: true,
  })
  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
  @ApiProperty({
    type: Number,
    example: 0,
    default: 0,
    description: 'Orden de visualización del grupo de modificadores',
    required: false,
  })
  @IsInt()
  @Min(0)
  @IsOptional()
  sortOrder?: number;
}

================
File: backend/src/modifier-groups/dto/find-all-modifier-groups.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsNumber, IsOptional, IsString } from 'class-validator';
import { Transform } from 'class-transformer';
export class FindAllModifierGroupsDto {
  @ApiPropertyOptional()
  @Transform(({ value }) => (value ? Number(value) : 1))
  @IsNumber()
  @IsOptional()
  page?: number = 1;
  @ApiPropertyOptional()
  @Transform(({ value }) => (value ? Number(value) : 10))
  @IsNumber()
  @IsOptional()
  limit?: number = 10;
  @ApiProperty({
    type: String,
    description: 'Filtrar por nombre',
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: Boolean,
    description: 'Filtrar por requerido',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isRequired?: boolean;
  @ApiProperty({
    type: Boolean,
    description: 'Filtrar por permitir múltiples selecciones',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  allowMultipleSelections?: boolean;
  @ApiProperty({
    type: Boolean,
    description: 'Filtrar por activo',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
}

================
File: backend/src/modifier-groups/dto/update-modifier-group.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsInt, IsOptional, IsString, Min } from 'class-validator';
export class UpdateModifierGroupDto {
  @ApiProperty({
    type: String,
    example: 'Tamaños',
    description: 'Nombre del grupo de modificadores',
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: String,
    example: 'Selecciona el tamaño de tu bebida',
    description: 'Descripción del grupo de modificadores',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  description?: string | null;
  @ApiProperty({
    type: Number,
    example: 0,
    description: 'Número mínimo de selecciones',
    required: false,
  })
  @IsOptional()
  @IsInt()
  @Min(0)
  minSelections?: number;
  @ApiProperty({
    type: Number,
    example: 1,
    description: 'Número máximo de selecciones',
    required: false,
  })
  @IsOptional()
  @IsInt()
  @Min(1)
  maxSelections?: number;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si el grupo de modificadores es requerido',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isRequired?: boolean;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si se permiten múltiples selecciones',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  allowMultipleSelections?: boolean;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si el grupo de modificadores está activo',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: Number,
    example: 0,
    description: 'Orden de visualización del grupo de modificadores',
    required: false,
  })
  @IsOptional()
  @IsInt()
  @Min(0)
  sortOrder?: number;
}

================
File: backend/src/modifier-groups/infrastructure/persistence/modifier-group.repository.ts
================
import { DeepPartial } from '../../../utils/types/deep-partial.type';
import { NullableType } from '../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../utils/types/pagination-options';
import { ModifierGroup } from '../../domain/modifier-group';
import { FindAllModifierGroupsDto } from '../../dto/find-all-modifier-groups.dto';
import { Paginated } from '../../../common/types/paginated.type';
export abstract class ModifierGroupRepository {
  abstract create(
    data: Omit<ModifierGroup, 'id' | 'createdAt' | 'deletedAt' | 'updatedAt'>,
  ): Promise<ModifierGroup>;
  abstract findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: FindAllModifierGroupsDto | null;
    paginationOptions: IPaginationOptions;
  }): Promise<Paginated<ModifierGroup>>;
  abstract findById(
    id: ModifierGroup['id'],
  ): Promise<NullableType<ModifierGroup>>;
  abstract findByName(
    name: ModifierGroup['name'],
  ): Promise<NullableType<ModifierGroup>>;
  abstract update(
    id: ModifierGroup['id'],
    payload: DeepPartial<ModifierGroup>,
  ): Promise<ModifierGroup | null>;
  abstract remove(id: ModifierGroup['id']): Promise<void>;
}

================
File: backend/src/modifier-groups/infrastructure/persistence/relational/entities/modifier-group.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  ManyToMany,
  OneToMany,
  PrimaryColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { ProductModifierEntity } from '../../../../../product-modifiers/infrastructure/persistence/relational/entities/product-modifier.entity';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
@Entity({
  name: 'modifier_group',
})
export class ModifierGroupEntity extends EntityRelationalHelper {
  @PrimaryColumn({ type: 'varchar', length: 20 })
  id: string;
  @Column()
  name: string;
  @Column({ type: 'varchar', nullable: true })
  description: string | null;
  @Column({ type: 'int', default: 0 })
  minSelections: number;
  @Column({ type: 'int' })
  maxSelections: number;
  @Column({ default: false })
  isRequired: boolean;
  @Column({ default: false })
  allowMultipleSelections: boolean;
  @Column({ default: true })
  isActive: boolean;
  @Column({ default: 0 })
  sortOrder: number;
  @OneToMany(
    () => ProductModifierEntity,
    (productModifier) => productModifier.modifierGroup,
  )
  productModifiers: ProductModifierEntity[];
  @ManyToMany(() => ProductEntity, (product) => product.modifierGroups)
  products: ProductEntity[];
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/modifier-groups/infrastructure/persistence/relational/mappers/modifier-group.mapper.ts
================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { ModifierGroup } from '../../../../domain/modifier-group';
import { ModifierGroupEntity } from '../entities/modifier-group.entity';
import { ProductModifierMapper } from '../../../../../product-modifiers/infrastructure/persistence/relational/mappers/product-modifier.mapper';
import {
  BaseMapper,
  mapArray,
} from '../../../../../common/mappers/base.mapper';
import { ProductMapper } from '../../../../../products/infrastructure/persistence/relational/mappers/product.mapper';
@Injectable()
export class ModifierGroupMapper extends BaseMapper<
  ModifierGroupEntity,
  ModifierGroup
> {
  constructor(
    private readonly productModifierMapper: ProductModifierMapper,
    @Inject(forwardRef(() => ProductMapper))
    private readonly productMapper: ProductMapper,
  ) {
    super();
  }
  override toDomain(entity: ModifierGroupEntity): ModifierGroup | null {
    if (!entity) return null;
    const domain = new ModifierGroup();
    domain.id = entity.id;
    domain.name = entity.name;
    domain.description = entity.description;
    domain.minSelections = entity.minSelections;
    domain.maxSelections = entity.maxSelections;
    domain.isRequired = entity.isRequired;
    domain.allowMultipleSelections = entity.allowMultipleSelections;
    domain.isActive = entity.isActive;
    domain.sortOrder = entity.sortOrder;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    domain.productModifiers = mapArray(entity.productModifiers, (modifier) =>
      this.productModifierMapper.toDomain(modifier),
    );
    domain.products = [];
    return domain;
  }
  override toEntity(domain: ModifierGroup): ModifierGroupEntity | null {
    if (!domain) return null;
    const entity = new ModifierGroupEntity();
    if (domain.id) entity.id = domain.id;
    entity.name = domain.name;
    entity.description = domain.description;
    entity.minSelections = domain.minSelections;
    entity.maxSelections = domain.maxSelections;
    entity.isRequired = domain.isRequired;
    entity.allowMultipleSelections = domain.allowMultipleSelections;
    entity.isActive = domain.isActive;
    entity.sortOrder = domain.sortOrder;
    return entity;
  }
}

================
File: backend/src/modifier-groups/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ModifierGroupEntity } from './entities/modifier-group.entity';
import { ModifierGroupsRelationalRepository } from './repositories/modifier-group.repository';
import { ModifierGroupMapper } from './mappers/modifier-group.mapper';
import { MODIFIER_GROUP_REPOSITORY } from '../../../../common/tokens';
import { RelationalProductModifierPersistenceModule } from '../../../../product-modifiers/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalProductPersistenceModule } from '../../../../products/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([ModifierGroupEntity]),
    RelationalProductModifierPersistenceModule,
    forwardRef(() => RelationalProductPersistenceModule),
  ],
  providers: [
    {
      provide: MODIFIER_GROUP_REPOSITORY,
      useClass: ModifierGroupsRelationalRepository,
    },
    ModifierGroupMapper,
  ],
  exports: [MODIFIER_GROUP_REPOSITORY, ModifierGroupMapper],
})
export class RelationalModifierGroupPersistenceModule {}

================
File: backend/src/modifier-groups/infrastructure/persistence/relational/repositories/modifier-group.repository.ts
================
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ModifierGroupEntity } from '../entities/modifier-group.entity';
import { ModifierGroupRepository } from '../../modifier-group.repository';
import { ModifierGroup } from '../../../../domain/modifier-group';
import { FindAllModifierGroupsDto } from '../../../../dto/find-all-modifier-groups.dto';
import { IPaginationOptions } from '../../../../../utils/types/pagination-options';
import { NullableType } from '../../../../../utils/types/nullable.type';
import { DeepPartial } from '../../../../../utils/types/deep-partial.type';
import { ModifierGroupMapper } from '../mappers/modifier-group.mapper';
import { Paginated } from '../../../../../common/types/paginated.type';
@Injectable()
export class ModifierGroupsRelationalRepository
  implements ModifierGroupRepository
{
  constructor(
    @InjectRepository(ModifierGroupEntity)
    private readonly modifierGroupRepository: Repository<ModifierGroupEntity>,
    private readonly modifierGroupMapper: ModifierGroupMapper,
  ) {}
  async create(
    data: Omit<ModifierGroup, 'id' | 'createdAt' | 'deletedAt' | 'updatedAt'>,
  ): Promise<ModifierGroup> {
    const entity = this.modifierGroupMapper.toEntity(data as ModifierGroup);
    if (!entity) {
      throw new InternalServerErrorException(
        'Error creating modifier group entity',
      );
    }
    const savedEntity = await this.modifierGroupRepository.save(entity);
    const domainResult = this.modifierGroupMapper.toDomain(savedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping saved modifier group entity to domain',
      );
    }
    return domainResult;
  }
  async findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: FindAllModifierGroupsDto | null;
    paginationOptions: IPaginationOptions;
  }): Promise<Paginated<ModifierGroup>> {
    const page = paginationOptions.page;
    const limit = paginationOptions.limit;
    const skip = (page - 1) * limit;
    const queryBuilder =
      this.modifierGroupRepository.createQueryBuilder('modifierGroup');
    if (filterOptions?.name) {
      queryBuilder.andWhere('modifierGroup.name ILIKE :name', {
        name: `%${filterOptions.name}%`,
      });
    }
    if (filterOptions?.isRequired !== undefined) {
      queryBuilder.andWhere('modifierGroup.isRequired = :isRequired', {
        isRequired: filterOptions.isRequired,
      });
    }
    if (filterOptions?.allowMultipleSelections !== undefined) {
      queryBuilder.andWhere(
        'modifierGroup.allowMultipleSelections = :allowMultipleSelections',
        {
          allowMultipleSelections: filterOptions.allowMultipleSelections,
        },
      );
    }
    if (filterOptions?.isActive !== undefined) {
      queryBuilder.andWhere('modifierGroup.isActive = :isActive', {
        isActive: filterOptions.isActive,
      });
    }
    queryBuilder.leftJoinAndSelect(
      'modifierGroup.productModifiers',
      'productModifiers',
    );
    queryBuilder.orderBy('modifierGroup.sortOrder', 'ASC');
    queryBuilder.addOrderBy('modifierGroup.name', 'ASC');
    queryBuilder.addOrderBy('productModifiers.sortOrder', 'ASC');
    queryBuilder.skip(skip).take(limit);
    const [entities, count] = await queryBuilder.getManyAndCount();
    const domainResults = entities
      .map((entity) => this.modifierGroupMapper.toDomain(entity))
      .filter((item): item is ModifierGroup => item !== null);
    return new Paginated(domainResults, count, page, limit);
  }
  async findById(
    id: ModifierGroup['id'],
  ): Promise<NullableType<ModifierGroup>> {
    const entity = await this.modifierGroupRepository.findOne({
      where: { id },
      relations: ['productModifiers'],
    });
    return entity ? this.modifierGroupMapper.toDomain(entity) : null;
  }
  async findByName(
    name: ModifierGroup['name'],
  ): Promise<NullableType<ModifierGroup>> {
    const entity = await this.modifierGroupRepository.findOne({
      where: { name },
      relations: ['productModifiers'],
    });
    return entity ? this.modifierGroupMapper.toDomain(entity) : null;
  }
  async update(
    id: ModifierGroup['id'],
    payload: DeepPartial<ModifierGroup>,
  ): Promise<ModifierGroup | null> {
    const entityToUpdate = this.modifierGroupMapper.toEntity(
      payload as ModifierGroup,
    );
    if (!entityToUpdate) {
      throw new InternalServerErrorException(
        'Error creating modifier group entity for update',
      );
    }
    await this.modifierGroupRepository.update(id, entityToUpdate);
    const updatedEntity = await this.modifierGroupRepository.findOne({
      where: { id },
      relations: ['productModifiers'],
    });
    if (!updatedEntity) {
      throw new NotFoundException(`ModifierGroup con ID ${id} no encontrado`);
    }
    const domainResult = this.modifierGroupMapper.toDomain(updatedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping updated modifier group entity to domain',
      );
    }
    return domainResult;
  }
  async remove(id: ModifierGroup['id']): Promise<void> {
    const result = await this.modifierGroupRepository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(`ModifierGroup con ID ${id} no encontrado`);
    }
  }
}

================
File: backend/src/modifier-groups/modifier-groups.controller.ts
================
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { ModifierGroupsService } from './modifier-groups.service';
import { CreateModifierGroupDto } from './dto/create-modifier-group.dto';
import { UpdateModifierGroupDto } from './dto/update-modifier-group.dto';
import { FindAllModifierGroupsDto } from './dto/find-all-modifier-groups.dto';
import { ModifierGroup } from './domain/modifier-group';
import { Paginated } from '../common/types/paginated.type';
@ApiTags('Grupos de Modificadores')
@Controller({
  path: 'modifier-groups',
  version: '1',
})
export class ModifierGroupsController {
  constructor(private readonly modifierGroupsService: ModifierGroupsService) {}
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @Post()
  @HttpCode(HttpStatus.CREATED)
  create(
    @Body() createModifierGroupDto: CreateModifierGroupDto,
  ): Promise<ModifierGroup> {
    return this.modifierGroupsService.create(createModifierGroupDto);
  }
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @Get()
  @HttpCode(HttpStatus.OK)
  findAll(
    @Query() findAllModifierGroupsDto: FindAllModifierGroupsDto,
  ): Promise<Paginated<ModifierGroup>> {
    return this.modifierGroupsService.findAll(findAllModifierGroupsDto);
  }
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @Get(':id')
  @HttpCode(HttpStatus.OK)
  findOne(@Param('id') id: string): Promise<ModifierGroup> {
    return this.modifierGroupsService.findOne(id);
  }
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @Patch(':id')
  @HttpCode(HttpStatus.OK)
  update(
    @Param('id') id: string,
    @Body() updateModifierGroupDto: UpdateModifierGroupDto,
  ): Promise<ModifierGroup> {
    return this.modifierGroupsService.update(id, updateModifierGroupDto);
  }
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id') id: string): Promise<void> {
    return this.modifierGroupsService.remove(id);
  }
}

================
File: backend/src/modifier-groups/modifier-groups.module.ts
================
import { Module } from '@nestjs/common';
import { ModifierGroupsController } from './modifier-groups.controller';
import { ModifierGroupsService } from './modifier-groups.service';
import { RelationalModifierGroupPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { AuthModule } from '../auth/auth.module';
import { CommonModule } from '../common/common.module';
const infrastructurePersistenceModule =
  RelationalModifierGroupPersistenceModule;
@Module({
  imports: [infrastructurePersistenceModule, AuthModule, CommonModule],
  controllers: [ModifierGroupsController],
  providers: [ModifierGroupsService],
  exports: [ModifierGroupsService, infrastructurePersistenceModule],
})
export class ModifierGroupsModule {}

================
File: backend/src/modifier-groups/modifier-groups.service.ts
================
import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { ModifierGroupRepository } from './infrastructure/persistence/modifier-group.repository';
import { CreateModifierGroupDto } from './dto/create-modifier-group.dto';
import { UpdateModifierGroupDto } from './dto/update-modifier-group.dto';
import { ModifierGroup } from './domain/modifier-group';
import { FindAllModifierGroupsDto } from './dto/find-all-modifier-groups.dto';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { Paginated } from '../common/types/paginated.type';
import { MODIFIER_GROUP_REPOSITORY } from '../common/tokens';
import {
  CustomIdService,
  EntityPrefix,
} from '../common/services/custom-id.service';
@Injectable()
export class ModifierGroupsService {
  constructor(
    @Inject(MODIFIER_GROUP_REPOSITORY)
    private readonly modifierGroupRepository: ModifierGroupRepository,
    private readonly customIdService: CustomIdService,
  ) {}
  async create(
    createModifierGroupDto: CreateModifierGroupDto,
  ): Promise<ModifierGroup> {
    const data = new ModifierGroup();
    data.id = await this.customIdService.generateId(
      EntityPrefix.MODIFIER_GROUP,
      'modifier_group',
    );
    data.name = createModifierGroupDto.name;
    data.description = createModifierGroupDto.description ?? null;
    data.minSelections = createModifierGroupDto.minSelections ?? 0;
    data.maxSelections = createModifierGroupDto.maxSelections;
    data.isRequired = createModifierGroupDto.isRequired ?? false;
    data.allowMultipleSelections =
      createModifierGroupDto.allowMultipleSelections ?? false;
    data.isActive = createModifierGroupDto.isActive ?? true;
    data.productModifiers = [];
    data.products = [];
    return this.modifierGroupRepository.create(data);
  }
  async findAll(
    findAllModifierGroupsDto: FindAllModifierGroupsDto,
  ): Promise<Paginated<ModifierGroup>> {
    const paginationOptions: IPaginationOptions = {
      page: findAllModifierGroupsDto.page ?? 1,
      limit: findAllModifierGroupsDto.limit ?? 10,
    };
    return this.modifierGroupRepository.findManyWithPagination({
      filterOptions: findAllModifierGroupsDto,
      paginationOptions,
    });
  }
  async findOne(id: string): Promise<ModifierGroup> {
    const modifierGroup = await this.modifierGroupRepository.findById(id);
    if (!modifierGroup) {
      throw new NotFoundException('Grupo de modificadores no encontrado');
    }
    return modifierGroup;
  }
  async update(
    id: string,
    updateModifierGroupDto: UpdateModifierGroupDto,
  ): Promise<ModifierGroup> {
    const existingModifierGroup =
      await this.modifierGroupRepository.findById(id);
    if (!existingModifierGroup) {
      throw new NotFoundException(`ModifierGroup con ID ${id} no encontrado`);
    }
    const modifierGroup = new ModifierGroup();
    modifierGroup.id = id;
    modifierGroup.name =
      updateModifierGroupDto.name ?? existingModifierGroup.name;
    modifierGroup.description =
      updateModifierGroupDto.description ?? existingModifierGroup.description;
    modifierGroup.minSelections =
      updateModifierGroupDto.minSelections ??
      existingModifierGroup.minSelections;
    modifierGroup.maxSelections =
      updateModifierGroupDto.maxSelections ??
      existingModifierGroup.maxSelections;
    modifierGroup.isRequired =
      updateModifierGroupDto.isRequired ?? existingModifierGroup.isRequired;
    modifierGroup.allowMultipleSelections =
      updateModifierGroupDto.allowMultipleSelections ??
      existingModifierGroup.allowMultipleSelections;
    modifierGroup.isActive =
      updateModifierGroupDto.isActive ?? existingModifierGroup.isActive;
    const updatedModifierGroup = await this.modifierGroupRepository.update(
      id,
      modifierGroup,
    );
    if (!updatedModifierGroup) {
      throw new NotFoundException(
        'Grupo de modificadores no encontrado después de intentar actualizar',
      );
    }
    return updatedModifierGroup;
  }
  async remove(id: string): Promise<void> {
    await this.modifierGroupRepository.remove(id);
  }
}

================
File: backend/src/orders/domain/delivery-info.ts
================
export class DeliveryInfo {
  id: string;
  orderId: string;
  fullAddress?: string;
  street?: string;
  number?: string;
  interiorNumber?: string;
  neighborhood?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
  recipientName?: string;
  recipientPhone?: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  createdAt: Date;
  updatedAt: Date;
}

================
File: backend/src/orders/domain/enums/order-status.enum.ts
================
export enum OrderStatus {
  PENDING = 'PENDING',
  IN_PROGRESS = 'IN_PROGRESS',
  IN_PREPARATION = 'IN_PREPARATION',
  READY = 'READY',
  IN_DELIVERY = 'IN_DELIVERY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED',
}

================
File: backend/src/orders/domain/enums/order-type.enum.ts
================
export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKE_AWAY = 'TAKE_AWAY',
  DELIVERY = 'DELIVERY',
}

================
File: backend/src/orders/domain/enums/ticket-type.enum.ts
================
export enum TicketType {
  KITCHEN = 'KITCHEN',
  BAR = 'BAR',
  BILLING = 'BILLING',
  CUSTOMER_COPY = 'CUSTOMER_COPY',
  GENERAL = 'GENERAL',
}

================
File: backend/src/orders/domain/order-item.ts
================
import { Order } from './order';
import { Product } from '../../products/domain/product';
import { ProductVariant } from '../../product-variants/domain/product-variant';
import { ProductModifier } from '../../product-modifiers/domain/product-modifier';
import { Adjustment } from '../../adjustments/domain/adjustment';
import { SelectedPizzaCustomization } from '../../selected-pizza-customizations/domain/selected-pizza-customization';
import { User } from '../../users/domain/user';
export enum PreparationStatus {
  PENDING = 'PENDING',
  IN_PROGRESS = 'IN_PROGRESS',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  CANCELLED = 'CANCELLED',
}
export class OrderItem {
  id: string;
  orderId: string;
  productId: string;
  productVariantId: string | null;
  basePrice: number;
  finalPrice: number;
  preparationStatus: PreparationStatus;
  statusChangedAt: Date;
  preparationNotes: string | null;
  preparedAt?: Date | null;
  preparedById?: string | null;
  preparedBy?: User | null;
  order?: Order;
  product?: Product;
  productVariant?: ProductVariant | null;
  productModifiers?: ProductModifier[];
  adjustments?: Adjustment[];
  selectedPizzaCustomizations?: SelectedPizzaCustomization[];
  createdAt?: Date;
  updatedAt?: Date;
  deletedAt?: Date | null;
}

================
File: backend/src/orders/domain/order-preparation-screen-status.ts
================
import { User } from '../../users/domain/user';
import { PreparationScreen } from '../../preparation-screens/domain/preparation-screen';
export enum PreparationScreenStatus {
  PENDING = 'PENDING',
  IN_PREPARATION = 'IN_PREPARATION',
  READY = 'READY',
}
export class OrderPreparationScreenStatus {
  id: string;
  orderId: string;
  preparationScreenId: string;
  status: PreparationScreenStatus;
  startedAt?: Date | null;
  completedAt?: Date | null;
  startedById?: string | null;
  completedById?: string | null;
  startedBy?: User | null;
  completedBy?: User | null;
  preparationScreen?: PreparationScreen;
  createdAt?: Date;
  updatedAt?: Date;
}

================
File: backend/src/orders/dto/create-order-item.dto.ts
================
import {
  IsArray,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  Min,
  ValidateNested,
} from 'class-validator';
import { Type } from 'class-transformer';
import { CreateSelectedPizzaCustomizationDto } from '../../selected-pizza-customizations/dto/create-selected-pizza-customization.dto';
import { ProductModifierDto } from './product-modifier.dto';
import { ApiProperty } from '@nestjs/swagger';
export class CreateOrderItemDto {
  @IsNotEmpty()
  @IsString()
  orderId: string;
  @IsNotEmpty()
  @IsString()
  productId: string;
  @IsOptional()
  @IsString()
  productVariantId?: string;
  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  basePrice: number;
  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  finalPrice: number;
  @IsOptional()
  @IsString()
  preparationNotes?: string;
  @ApiProperty({
    type: [ProductModifierDto],
    description: 'Lista de modificadores del producto',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => ProductModifierDto)
  productModifiers?: ProductModifierDto[];
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateSelectedPizzaCustomizationDto)
  selectedPizzaCustomizations?: CreateSelectedPizzaCustomizationDto[];
}

================
File: backend/src/orders/dto/create-order.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsDateString,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsPositive,
  IsUUID,
  ValidateNested,
  ValidateIf,
  IsString,
} from 'class-validator';
import { OrderType } from '../domain/enums/order-type.enum';
import { Type } from 'class-transformer';
import { OrderItemInputDto } from './order-item-input.dto';
import { DeliveryInfoDto } from './delivery-info.dto';
export class CreateOrderDto {
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description:
      'ID del usuario que realiza la orden (opcional para órdenes de WhatsApp)',
    required: false,
  })
  @IsOptional()
  @ValidateIf((o) => !o.isFromWhatsApp)
  @IsNotEmpty({
    message: 'El ID del usuario es requerido cuando la orden no es de WhatsApp',
  })
  @IsUUID()
  userId?: string;
  @ApiProperty({
    type: String,
    example: 'TABLE-1',
    description: 'ID de la mesa (opcional para órdenes que no son en el local)',
    required: false,
  })
  @IsOptional()
  @IsString()
  tableId?: string;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si se debe crear una mesa temporal',
    required: false,
    default: false,
  })
  @IsOptional()
  isTemporaryTable?: boolean;
  @ApiProperty({
    type: String,
    example: 'Mesa Exterior 1',
    description:
      'Nombre de la mesa temporal a crear (requerido si isTemporaryTable es true)',
    required: false,
  })
  @IsOptional()
  @ValidateIf((o) => o.isTemporaryTable === true)
  @IsNotEmpty({
    message:
      'El nombre de la mesa temporal es requerido cuando isTemporaryTable es true',
  })
  @IsString()
  temporaryTableName?: string;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description:
      'ID del área donde se creará la mesa temporal (requerido si isTemporaryTable es true)',
    required: false,
  })
  @IsOptional()
  @ValidateIf((o) => o.isTemporaryTable === true)
  @IsNotEmpty({
    message: 'El ID del área es requerido cuando isTemporaryTable es true',
  })
  @IsUUID()
  temporaryTableAreaId?: string;
  @ApiProperty({
    type: Date,
    example: '2023-01-01T14:30:00.000Z',
    description: 'Fecha y hora programada para la orden (opcional)',
    required: false,
  })
  @IsOptional()
  @IsDateString()
  scheduledAt?: Date;
  @ApiProperty({
    enum: OrderType,
    example: OrderType.DINE_IN,
    description: 'Tipo de orden (obligatorio)',
    required: true,
  })
  @IsNotEmpty()
  @IsEnum(OrderType)
  orderType: OrderType;
  @ApiProperty({
    type: Number,
    example: 150.5,
    description: 'Subtotal de la orden',
    required: true,
  })
  @IsNotEmpty()
  @IsNumber()
  @IsPositive()
  subtotal: number;
  @ApiProperty({
    type: Number,
    example: 177.59,
    description: 'Total de la orden',
    required: true,
  })
  @IsNotEmpty()
  @IsNumber()
  @IsPositive()
  total: number;
  @ApiProperty({
    type: String,
    example: 'Extra cheese, no onions.',
    description: 'Optional notes for the order',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  notes?: string;
  @ApiProperty({
    type: [OrderItemInputDto],
    description: 'Items de la orden',
    required: true,
  })
  @IsNotEmpty()
  @ValidateNested({ each: true })
  @Type(() => OrderItemInputDto)
  items: OrderItemInputDto[];
  @ApiProperty({
    type: DeliveryInfoDto,
    description:
      'Información de entrega (requerida para todas las órdenes, pero todos los campos son opcionales)',
    required: true,
  })
  @IsNotEmpty({ message: 'La información de entrega es requerida' })
  @ValidateNested()
  @Type(() => DeliveryInfoDto)
  deliveryInfo: DeliveryInfoDto;
  @ApiProperty({
    type: String,
    example: 'CUST-1',
    description: 'ID del cliente (opcional)',
    required: false,
  })
  @IsOptional()
  @IsString()
  customerId?: string;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si la orden fue creada a través de WhatsApp',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsNotEmpty()
  isFromWhatsApp?: boolean;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description: 'ID del pre-pago a asociar con la orden (opcional)',
    required: false,
  })
  @IsOptional()
  @IsUUID()
  prepaymentId?: string;
}

================
File: backend/src/orders/dto/delivery-info.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsOptional,
  IsString,
  IsNumber,
  MaxLength,
  MinLength,
  Matches,
} from 'class-validator';
export class DeliveryInfoDto {
  @ApiProperty({
    type: String,
    example: 'Av. Revolución 123, Col. Centro, entre calles X y Y',
    description:
      'Dirección completa en una línea (útil para pedidos telefónicos)',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  fullAddress?: string;
  @ApiProperty({
    type: String,
    example: 'Av. Revolución',
    description: 'Calle de entrega',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  street?: string;
  @ApiProperty({
    type: String,
    example: '123',
    description: 'Número exterior',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(20)
  number?: string;
  @ApiProperty({
    type: String,
    example: 'A',
    description: 'Número interior',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(20)
  interiorNumber?: string;
  @ApiProperty({
    type: String,
    example: 'Centro',
    description: 'Colonia o barrio',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  neighborhood?: string;
  @ApiProperty({
    type: String,
    example: 'Guadalajara',
    description: 'Ciudad',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  city?: string;
  @ApiProperty({
    type: String,
    example: 'Jalisco',
    description: 'Estado o provincia',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  state?: string;
  @ApiProperty({
    type: String,
    example: '44100',
    description: 'Código postal',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(20)
  zipCode?: string;
  @ApiProperty({
    type: String,
    example: 'México',
    description: 'País',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  country?: string;
  @ApiProperty({
    type: String,
    example: 'Juan Pérez',
    description: 'Nombre de quien recibe',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  recipientName?: string;
  @ApiProperty({
    type: String,
    example: '+523331234567',
    description: 'Teléfono de contacto para la entrega',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MinLength(10, {
    message: 'El número de teléfono debe tener al menos 10 dígitos',
  })
  @MaxLength(15, {
    message: 'El número de teléfono no puede tener más de 15 dígitos',
  })
  @Matches(/^\+?[0-9]+$/, {
    message:
      'El número de teléfono solo debe contener dígitos y puede empezar con +',
  })
  recipientPhone?: string;
  @ApiProperty({
    type: String,
    example: 'Casa blanca con portón negro, tocar el timbre 2 veces',
    description: 'Instrucciones adicionales para la entrega',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  deliveryInstructions?: string;
  @ApiProperty({
    type: Number,
    example: 20.6597,
    description: 'Latitud de la dirección',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  latitude?: number;
  @ApiProperty({
    type: Number,
    example: -103.3496,
    description: 'Longitud de la dirección',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  longitude?: number;
}

================
File: backend/src/orders/dto/finalize-orders.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsEnum, IsOptional, IsString, IsUUID } from 'class-validator';
export enum PaymentMethod {
  CASH = 'cash',
  CARD = 'card',
  TRANSFER = 'transfer',
}
export class FinalizeOrdersDto {
  @ApiProperty({
    description: 'Lista de IDs de órdenes a finalizar',
    type: [String],
    example: ['uuid1', 'uuid2', 'uuid3'],
  })
  @IsArray()
  @IsUUID(4, { each: true })
  orderIds: string[];
  @ApiProperty({
    description: 'Método de pago utilizado',
    enum: PaymentMethod,
    example: PaymentMethod.CASH,
  })
  @IsEnum(PaymentMethod)
  paymentMethod: PaymentMethod;
  @ApiProperty({
    description: 'Notas adicionales para la finalización',
    required: false,
    example: 'Entregado por conductor John',
  })
  @IsOptional()
  @IsString()
  notes?: string;
}

================
File: backend/src/orders/dto/order-item-input.dto.ts
================
import {
  IsArray,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  Min,
  ValidateNested,
} from 'class-validator';
import { Type } from 'class-transformer';
import { ApiProperty } from '@nestjs/swagger';
import { CreateSelectedPizzaCustomizationDto } from '../../selected-pizza-customizations/dto/create-selected-pizza-customization.dto';
import { ProductModifierDto } from './product-modifier.dto';
export class OrderItemInputDto {
  @ApiProperty({
    type: String,
    example: 'ORDERITEM-1',
    description: 'ID del order item (opcional, para actualizaciones)',
    required: false,
  })
  @IsOptional()
  @IsString()
  id?: string;
  @ApiProperty({
    type: String,
    example: 'PROD-1',
    description: 'ID del producto',
  })
  @IsNotEmpty()
  @IsString()
  productId: string;
  @ApiProperty({
    type: String,
    example: 'PRODVAR-1',
    description: 'ID de la variante del producto (opcional)',
    required: false,
  })
  @IsOptional()
  @IsString()
  productVariantId?: string;
  @ApiProperty({
    type: Number,
    example: 10.99,
    description: 'Precio base del producto',
    minimum: 0,
  })
  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  basePrice: number;
  @ApiProperty({
    type: Number,
    example: 12.99,
    description: 'Precio final del producto (incluyendo modificadores)',
    minimum: 0,
  })
  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  finalPrice: number;
  @ApiProperty({
    type: String,
    example: 'Sin cebolla, extra queso',
    description: 'Notas de preparación (opcional)',
    required: false,
  })
  @IsOptional()
  @IsString()
  preparationNotes?: string;
  @ApiProperty({
    type: [ProductModifierDto],
    description: 'Lista de modificadores del producto (opcional)',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => ProductModifierDto)
  productModifiers?: ProductModifierDto[];
  @ApiProperty({
    type: [CreateSelectedPizzaCustomizationDto],
    description: 'Personalizaciones de pizza (opcional)',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateSelectedPizzaCustomizationDto)
  selectedPizzaCustomizations?: CreateSelectedPizzaCustomizationDto[];
}

================
File: backend/src/orders/dto/product-modifier.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, Length } from 'class-validator';
export class ProductModifierDto {
  @ApiProperty({
    type: String,
    example: 'MOD001',
    description: 'ID del modificador seleccionado',
    minLength: 1,
    maxLength: 20,
  })
  @IsNotEmpty()
  @IsString()
  @Length(1, 20)
  modifierId: string;
}

================
File: backend/src/orders/dto/recover-order.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsOptional, IsString, IsUUID } from 'class-validator';
export class RecoverOrderDto {
  @ApiProperty({
    description: 'Lista de IDs de órdenes a recuperar o finalizar',
    type: [String],
    example: ['uuid1', 'uuid2', 'uuid3'],
  })
  @IsArray()
  @IsUUID(4, { each: true })
  orderIds: string[];
  @ApiProperty({
    description: 'Notas adicionales para la operación',
    required: false,
    example: 'Recuperado por solicitud del cliente',
  })
  @IsOptional()
  @IsString()
  notes?: string;
}

================
File: backend/src/orders/dto/update-order-item.dto.ts
================
import {
  IsArray,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
  ValidateNested,
} from 'class-validator';
import { Type } from 'class-transformer';
import { PreparationStatus } from '../domain/order-item';
import { ProductModifierDto } from './product-modifier.dto';
import { CreateSelectedPizzaCustomizationDto } from '../../selected-pizza-customizations/dto/create-selected-pizza-customization.dto';
import { ApiProperty } from '@nestjs/swagger';
export class UpdateOrderItemDto {
  @IsOptional()
  @IsString()
  productId?: string;
  @IsOptional()
  @IsString()
  productVariantId?: string;
  @IsOptional()
  @IsNumber()
  @Min(0)
  basePrice?: number;
  @IsOptional()
  @IsNumber()
  @Min(0)
  finalPrice?: number;
  @IsOptional()
  @IsEnum(PreparationStatus)
  preparationStatus?: PreparationStatus;
  @IsOptional()
  @IsString()
  preparationNotes?: string;
  @ApiProperty({
    type: [ProductModifierDto],
    description: 'Lista de modificadores del producto',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => ProductModifierDto)
  productModifiers?: ProductModifierDto[];
  @ApiProperty({
    type: [CreateSelectedPizzaCustomizationDto],
    description: 'Lista de personalizaciones de pizza seleccionadas',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateSelectedPizzaCustomizationDto)
  selectedPizzaCustomizations?: CreateSelectedPizzaCustomizationDto[];
}

================
File: backend/src/orders/infrastructure/persistence/order-history.repository.ts
================
import { OrderHistoryEntity } from './relational/entities/order-history.entity';
import { IPaginationOptions } from '../../../utils/types/pagination-options';
export abstract class OrderHistoryRepository {
  abstract findByOrderId(
    orderId: string,
    paginationOptions: IPaginationOptions,
  ): Promise<[OrderHistoryEntity[], number]>;
}

================
File: backend/src/orders/infrastructure/persistence/order-item.repository.ts
================
import { OrderItem } from '../../domain/order-item';
export interface OrderItemRepository {
  findById(id: string): Promise<OrderItem | null>;
  findByOrderId(orderId: string): Promise<OrderItem[]>;
  save(orderItem: OrderItem): Promise<OrderItem>;
  update(orderItem: OrderItem): Promise<OrderItem>;
  delete(id: string): Promise<void>;
}

================
File: backend/src/orders/infrastructure/persistence/order-preparation-screen-status.repository.ts
================
import { OrderPreparationScreenStatus } from '../../domain/order-preparation-screen-status';
export abstract class OrderPreparationScreenStatusRepository {
  abstract create(
    data: Omit<OrderPreparationScreenStatus, 'id' | 'createdAt' | 'updatedAt'>,
  ): Promise<OrderPreparationScreenStatus>;
  abstract findByOrderId(
    orderId: string,
  ): Promise<OrderPreparationScreenStatus[]>;
  abstract findByOrderAndScreen(
    orderId: string,
    screenId: string,
  ): Promise<OrderPreparationScreenStatus | null>;
  abstract update(
    id: string,
    data: Partial<OrderPreparationScreenStatus>,
  ): Promise<OrderPreparationScreenStatus>;
  abstract createOrUpdate(
    orderId: string,
    screenId: string,
    data: Partial<OrderPreparationScreenStatus>,
  ): Promise<OrderPreparationScreenStatus>;
  abstract deleteByOrderId(orderId: string): Promise<void>;
}

================
File: backend/src/orders/infrastructure/persistence/relational/entities/delivery-info.entity.ts
================
import {
  Column,
  CreateDateColumn,
  Entity,
  JoinColumn,
  OneToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { OrderEntity } from './order.entity';
@Entity({
  name: 'delivery_info',
})
export class DeliveryInfoEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ name: 'order_id', type: 'uuid', unique: true })
  orderId: string;
  @OneToOne(() => OrderEntity, (order) => order.deliveryInfo, {
    onDelete: 'CASCADE',
  })
  @JoinColumn({ name: 'order_id' })
  order: OrderEntity;
  @Column({ name: 'full_address', type: 'text', nullable: true })
  fullAddress?: string;
  @Column({ type: 'varchar', nullable: true })
  street?: string;
  @Column({ type: 'varchar', nullable: true })
  number?: string;
  @Column({ name: 'interior_number', type: 'varchar', nullable: true })
  interiorNumber?: string;
  @Column({ type: 'varchar', nullable: true })
  neighborhood?: string;
  @Column({ type: 'varchar', nullable: true })
  city?: string;
  @Column({ type: 'varchar', nullable: true })
  state?: string;
  @Column({ name: 'zip_code', type: 'varchar', nullable: true })
  zipCode?: string;
  @Column({ type: 'varchar', nullable: true })
  country?: string;
  @Column({ name: 'recipient_name', type: 'varchar', nullable: true })
  recipientName?: string;
  @Column({ name: 'recipient_phone', type: 'varchar', nullable: true })
  recipientPhone?: string;
  @Column({ name: 'delivery_instructions', type: 'text', nullable: true })
  deliveryInstructions?: string;
  @Column({ type: 'decimal', precision: 10, scale: 8, nullable: true })
  latitude?: number;
  @Column({ type: 'decimal', precision: 11, scale: 8, nullable: true })
  longitude?: number;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
}

================
File: backend/src/orders/infrastructure/persistence/relational/entities/order-history.entity.ts
================
import {
  Column,
  CreateDateColumn,
  Entity,
  Index,
  PrimaryGeneratedColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
@Entity({ name: 'order_history' })
@Index(['orderId', 'changedAt'])
export class OrderHistoryEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn()
  id: number;
  @Column('uuid', { name: 'order_id' })
  orderId: string;
  @Column({ length: 10 })
  operation: string;
  @Column('uuid', { name: 'changed_by' })
  changedBy: string;
  @CreateDateColumn({ name: 'changed_at', type: 'timestamptz' })
  changedAt: Date;
  @Column({ type: 'jsonb', nullable: true })
  diff: Record<string, any> | null;
  @Column({ type: 'jsonb' })
  snapshot: Record<string, any>;
}

================
File: backend/src/orders/infrastructure/persistence/relational/entities/order-item.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  JoinTable,
  ManyToMany,
  ManyToOne,
  OneToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { OrderEntity } from './order.entity';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
import { ProductVariantEntity } from '../../../../../product-variants/infrastructure/persistence/relational/entities/product-variant.entity';
import { PreparationStatus } from '../../../../domain/order-item';
import { AdjustmentEntity } from '../../../../../adjustments/infrastructure/persistence/relational/entities/adjustment.entity';
import { SelectedPizzaCustomizationEntity } from '../../../../../selected-pizza-customizations/infrastructure/persistence/relational/entities/selected-pizza-customization.entity';
import { ProductModifierEntity } from '../../../../../product-modifiers/infrastructure/persistence/relational/entities/product-modifier.entity';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
@Entity({
  name: 'order_item',
})
export class OrderItemEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ name: 'order_id', type: 'uuid' })
  orderId: string;
  @Column({ name: 'product_id', type: 'uuid' })
  productId: string;
  @Column({ name: 'product_variant_id', type: 'uuid', nullable: true })
  productVariantId: string | null;
  @Column({ type: 'decimal', precision: 10, scale: 2, nullable: false })
  basePrice: number;
  @Column({ type: 'decimal', precision: 10, scale: 2, nullable: false })
  finalPrice: number;
  @Column({
    type: 'enum',
    enum: PreparationStatus,
    default: PreparationStatus.PENDING,
  })
  preparationStatus: PreparationStatus;
  @Column({ type: 'timestamptz', default: () => 'CURRENT_TIMESTAMP' })
  statusChangedAt: Date;
  @Column({ type: 'varchar', nullable: true })
  preparationNotes: string | null;
  @Column({ type: 'timestamptz', nullable: true })
  preparedAt: Date | null;
  @Column({ name: 'prepared_by_id', type: 'uuid', nullable: true })
  preparedById: string | null;
  @ManyToOne(() => UserEntity, { nullable: true })
  @JoinColumn({ name: 'prepared_by_id' })
  preparedBy: UserEntity | null;
  @ManyToOne(() => OrderEntity, (order) => order.orderItems, {
    eager: true,
    nullable: false,
  })
  @JoinColumn({ name: 'order_id' })
  order: OrderEntity;
  @ManyToOne(() => ProductEntity, (product) => product.orderItems, {
    eager: true,
    nullable: false,
  })
  @JoinColumn({ name: 'product_id' })
  product: ProductEntity;
  @ManyToOne(
    () => ProductVariantEntity,
    (productVariant) => productVariant.orderItems,
    {
      eager: true,
      nullable: true,
    },
  )
  @JoinColumn({ name: 'product_variant_id' })
  productVariant: ProductVariantEntity | null;
  @ManyToMany(() => ProductModifierEntity)
  @JoinTable({
    name: 'order_item_product_modifiers',
    joinColumn: {
      name: 'order_item_id',
      referencedColumnName: 'id',
    },
    inverseJoinColumn: {
      name: 'product_modifier_id',
      referencedColumnName: 'id',
    },
  })
  productModifiers: ProductModifierEntity[];
  @OneToMany(() => AdjustmentEntity, (adjustment) => adjustment.orderItem)
  adjustments: AdjustmentEntity[];
  @OneToMany(
    () => SelectedPizzaCustomizationEntity,
    (selectedCustomization) => selectedCustomization.orderItem,
    { cascade: true },
  )
  selectedPizzaCustomizations: SelectedPizzaCustomizationEntity[];
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/orders/infrastructure/persistence/relational/entities/order-preparation-screen-status.entity.ts
================
import {
  Column,
  CreateDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
  Index,
  Unique,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { OrderEntity } from './order.entity';
import { PreparationScreenEntity } from '../../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { PreparationScreenStatus } from '../../../../domain/order-preparation-screen-status';
@Entity({
  name: 'order_preparation_screen_status',
})
@Unique(['orderId', 'preparationScreenId'])
@Index(['orderId', 'status'])
export class OrderPreparationScreenStatusEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ name: 'order_id', type: 'uuid' })
  orderId: string;
  @Column({ name: 'preparation_screen_id', type: 'uuid' })
  preparationScreenId: string;
  @Column({
    type: 'enum',
    enum: PreparationScreenStatus,
    default: PreparationScreenStatus.PENDING,
  })
  status: PreparationScreenStatus;
  @Column({ type: 'timestamptz', nullable: true })
  startedAt: Date | null;
  @Column({ type: 'timestamptz', nullable: true })
  completedAt: Date | null;
  @Column({ name: 'started_by_id', type: 'uuid', nullable: true })
  startedById: string | null;
  @Column({ name: 'completed_by_id', type: 'uuid', nullable: true })
  completedById: string | null;
  @ManyToOne(() => OrderEntity, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'order_id' })
  order: OrderEntity;
  @ManyToOne(() => PreparationScreenEntity)
  @JoinColumn({ name: 'preparation_screen_id' })
  preparationScreen: PreparationScreenEntity;
  @ManyToOne(() => UserEntity, { nullable: true })
  @JoinColumn({ name: 'started_by_id' })
  startedBy: UserEntity | null;
  @ManyToOne(() => UserEntity, { nullable: true })
  @JoinColumn({ name: 'completed_by_id' })
  completedBy: UserEntity | null;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
}

================
File: backend/src/orders/infrastructure/persistence/relational/mappers/delivery-info.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { DeliveryInfo } from '../../../../domain/delivery-info';
import { DeliveryInfoEntity } from '../entities/delivery-info.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class DeliveryInfoMapper extends BaseMapper<
  DeliveryInfoEntity,
  DeliveryInfo
> {
  override toDomain(entity: DeliveryInfoEntity): DeliveryInfo | null {
    if (!entity) return null;
    const domain = new DeliveryInfo();
    domain.id = entity.id;
    domain.orderId = entity.orderId;
    domain.fullAddress = entity.fullAddress;
    domain.street = entity.street;
    domain.number = entity.number;
    domain.interiorNumber = entity.interiorNumber;
    domain.neighborhood = entity.neighborhood;
    domain.city = entity.city;
    domain.state = entity.state;
    domain.zipCode = entity.zipCode;
    domain.country = entity.country;
    domain.recipientName = entity.recipientName;
    domain.recipientPhone = entity.recipientPhone;
    domain.deliveryInstructions = entity.deliveryInstructions;
    domain.latitude = entity.latitude;
    domain.longitude = entity.longitude;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    return domain;
  }
  override toEntity(domain: DeliveryInfo): DeliveryInfoEntity | null {
    if (!domain) return null;
    const entity = new DeliveryInfoEntity();
    if (domain.id) entity.id = domain.id;
    entity.orderId = domain.orderId;
    entity.fullAddress = domain.fullAddress;
    entity.street = domain.street;
    entity.number = domain.number;
    entity.interiorNumber = domain.interiorNumber;
    entity.neighborhood = domain.neighborhood;
    entity.city = domain.city;
    entity.state = domain.state;
    entity.zipCode = domain.zipCode;
    entity.country = domain.country;
    entity.recipientName = domain.recipientName;
    entity.recipientPhone = domain.recipientPhone;
    entity.deliveryInstructions = domain.deliveryInstructions;
    entity.latitude = domain.latitude;
    entity.longitude = domain.longitude;
    return entity;
  }
}

================
File: backend/src/orders/infrastructure/persistence/relational/mappers/order-item.mapper.ts
================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { OrderItem } from '../../../../domain/order-item';
import { OrderItemEntity } from '../entities/order-item.entity';
import { OrderEntity } from '../entities/order.entity';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
import { ProductVariantEntity } from '../../../../../product-variants/infrastructure/persistence/relational/entities/product-variant.entity';
import { OrderMapper } from './order.mapper';
import { ProductMapper } from '../../../../../products/infrastructure/persistence/relational/mappers/product.mapper';
import { ProductVariantMapper } from '../../../../../product-variants/infrastructure/persistence/relational/mappers/product-variant.mapper';
import { ProductModifierMapper } from '../../../../../product-modifiers/infrastructure/persistence/relational/mappers/product-modifier.mapper';
import { UserMapper } from '../../../../../users/infrastructure/persistence/relational/mappers/user.mapper';
import {
  BaseMapper,
  mapArray,
} from '../../../../../common/mappers/base.mapper';
import { SelectedPizzaCustomizationEntity } from '../../../../../selected-pizza-customizations/infrastructure/persistence/relational/entities/selected-pizza-customization.entity';
import { SelectedPizzaCustomization } from '../../../../../selected-pizza-customizations/domain/selected-pizza-customization';
@Injectable()
export class OrderItemMapper extends BaseMapper<OrderItemEntity, OrderItem> {
  constructor(
    @Inject(forwardRef(() => OrderMapper))
    private readonly orderMapper: OrderMapper,
    private readonly productMapper: ProductMapper,
    private readonly productVariantMapper: ProductVariantMapper,
    private readonly productModifierMapper: ProductModifierMapper,
    private readonly userMapper: UserMapper,
  ) {
    super();
  }
  override toDomain(entity: OrderItemEntity): OrderItem | null {
    if (!entity) return null;
    const domain = new OrderItem();
    domain.id = entity.id;
    domain.orderId = entity.orderId;
    domain.order = this.orderMapper.toDomain(entity.order!)!;
    domain.productId = entity.productId;
    domain.product = this.productMapper.toDomain(entity.product!)!;
    domain.productVariantId = entity.productVariantId;
    domain.productVariant = this.productVariantMapper.toDomain(
      entity.productVariant!,
    )!;
    domain.basePrice = entity.basePrice;
    domain.finalPrice = entity.finalPrice;
    domain.preparationStatus = entity.preparationStatus;
    domain.statusChangedAt = entity.statusChangedAt;
    domain.preparationNotes = entity.preparationNotes;
    domain.preparedAt = entity.preparedAt;
    domain.preparedById = entity.preparedById;
    domain.preparedBy = entity.preparedBy
      ? this.userMapper.toDomain(entity.preparedBy)
      : null;
    domain.productModifiers = mapArray(entity.productModifiers, (mod) =>
      this.productModifierMapper.toDomain(mod),
    );
    if (entity.selectedPizzaCustomizations) {
      domain.selectedPizzaCustomizations =
        entity.selectedPizzaCustomizations.map((customization) => {
          const domainCustomization = new SelectedPizzaCustomization();
          domainCustomization.id = customization.id;
          domainCustomization.orderItemId = customization.orderItemId;
          domainCustomization.pizzaCustomizationId =
            customization.pizzaCustomizationId;
          domainCustomization.half = customization.half;
          domainCustomization.action = customization.action;
          domainCustomization.createdAt = customization.createdAt;
          domainCustomization.updatedAt = customization.updatedAt;
          domainCustomization.deletedAt = customization.deletedAt;
          if (customization.pizzaCustomization) {
            domainCustomization.pizzaCustomization = {
              id: customization.pizzaCustomization.id,
              name: customization.pizzaCustomization.name,
              type: customization.pizzaCustomization.type,
              ingredients: customization.pizzaCustomization.ingredients,
              toppingValue: customization.pizzaCustomization.toppingValue,
              isActive: customization.pizzaCustomization.isActive,
              sortOrder: customization.pizzaCustomization.sortOrder,
            } as any;
          }
          return domainCustomization;
        });
    }
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: OrderItem): OrderItemEntity | null {
    if (!domain) return null;
    const entity = new OrderItemEntity();
    if (domain.id) entity.id = domain.id;
    if (domain.orderId) {
      entity.order = { id: domain.orderId } as OrderEntity;
    }
    if (domain.productId) {
      entity.product = { id: domain.productId } as ProductEntity;
    }
    if (domain.productVariantId) {
      entity.productVariant = {
        id: domain.productVariantId,
      } as ProductVariantEntity;
    }
    entity.basePrice = domain.basePrice;
    entity.finalPrice = domain.finalPrice;
    entity.preparationStatus = domain.preparationStatus;
    entity.statusChangedAt = domain.statusChangedAt;
    entity.preparationNotes = domain.preparationNotes;
    entity.preparedAt = domain.preparedAt || null;
    entity.preparedById = domain.preparedById || null;
    if (domain.productModifiers) {
      entity.productModifiers = domain.productModifiers.map((modifier) => {
        if (typeof modifier === 'object' && 'id' in modifier) {
          return { id: modifier.id } as any;
        }
        if (typeof modifier === 'string') {
          return { id: modifier } as any;
        }
        return modifier;
      });
    }
    if (domain.selectedPizzaCustomizations) {
      entity.selectedPizzaCustomizations =
        domain.selectedPizzaCustomizations.map((customization) => {
          const entityCustomization = new SelectedPizzaCustomizationEntity();
          if (customization.id) entityCustomization.id = customization.id;
          entityCustomization.orderItemId = customization.orderItemId;
          entityCustomization.pizzaCustomizationId =
            customization.pizzaCustomizationId;
          entityCustomization.half = customization.half;
          entityCustomization.action = customization.action;
          return entityCustomization;
        });
    }
    return entity;
  }
}

================
File: backend/src/orders/infrastructure/persistence/relational/mappers/order-preparation-screen-status.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { OrderPreparationScreenStatus } from '../../../../domain/order-preparation-screen-status';
import { OrderPreparationScreenStatusEntity } from '../entities/order-preparation-screen-status.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
import { UserMapper } from '../../../../../users/infrastructure/persistence/relational/mappers/user.mapper';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { PreparationScreenEntity } from '../../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import { PreparationScreen } from '../../../../../preparation-screens/domain/preparation-screen';
@Injectable()
export class OrderPreparationScreenStatusMapper extends BaseMapper<
  OrderPreparationScreenStatusEntity,
  OrderPreparationScreenStatus
> {
  constructor(private readonly userMapper: UserMapper) {
    super();
  }
  override toDomain(
    entity: OrderPreparationScreenStatusEntity,
  ): OrderPreparationScreenStatus | null {
    if (!entity) return null;
    const domain = new OrderPreparationScreenStatus();
    domain.id = entity.id;
    domain.orderId = entity.orderId;
    domain.preparationScreenId = entity.preparationScreenId;
    domain.status = entity.status;
    domain.startedAt = entity.startedAt;
    domain.completedAt = entity.completedAt;
    domain.startedById = entity.startedById;
    domain.completedById = entity.completedById;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    if (entity.startedBy) {
      domain.startedBy = this.userMapper.toDomain(entity.startedBy);
    }
    if (entity.completedBy) {
      domain.completedBy = this.userMapper.toDomain(entity.completedBy);
    }
    if (entity.preparationScreen) {
      const screen = new PreparationScreen();
      screen.id = entity.preparationScreen.id;
      screen.name = entity.preparationScreen.name;
      screen.description = entity.preparationScreen.description;
      screen.isActive = entity.preparationScreen.isActive;
      domain.preparationScreen = screen;
    }
    return domain;
  }
  override toEntity(
    domain: OrderPreparationScreenStatus,
  ): OrderPreparationScreenStatusEntity | null {
    if (!domain) return null;
    const entity = new OrderPreparationScreenStatusEntity();
    if (domain.id) entity.id = domain.id;
    entity.orderId = domain.orderId;
    entity.preparationScreenId = domain.preparationScreenId;
    entity.status = domain.status;
    entity.startedAt = domain.startedAt || null;
    entity.completedAt = domain.completedAt || null;
    entity.startedById = domain.startedById || null;
    entity.completedById = domain.completedById || null;
    if (domain.startedById) {
      entity.startedBy = { id: domain.startedById } as UserEntity;
    }
    if (domain.completedById) {
      entity.completedBy = { id: domain.completedById } as UserEntity;
    }
    if (domain.preparationScreenId) {
      entity.preparationScreen = {
        id: domain.preparationScreenId,
      } as PreparationScreenEntity;
    }
    return entity;
  }
}

================
File: backend/src/orders/infrastructure/persistence/relational/repositories/order-history.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { OrderHistoryEntity } from '../entities/order-history.entity';
import { OrderHistoryRepository } from '../../order-history.repository';
import { IPaginationOptions } from '../../../../../utils/types/pagination-options';
@Injectable()
export class OrderHistoryRelationalRepository
  implements OrderHistoryRepository
{
  constructor(
    @InjectRepository(OrderHistoryEntity)
    private readonly historyRepository: Repository<OrderHistoryEntity>,
  ) {}
  async findByOrderId(
    orderId: string,
    paginationOptions: IPaginationOptions,
  ): Promise<[OrderHistoryEntity[], number]> {
    const { page, limit } = paginationOptions;
    const skip = (page - 1) * limit;
    return this.historyRepository.findAndCount({
      where: { orderId },
      order: { changedAt: 'DESC' },
      skip: skip,
      take: limit,
    });
  }
}

================
File: backend/src/orders/infrastructure/persistence/relational/repositories/order-item.repository.ts
================
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { OrderEntity } from '../entities/order.entity';
import { OrderItem } from '../../../../domain/order-item';
import { OrderItemRepository } from '../../order-item.repository';
import { OrderItemEntity } from '../entities/order-item.entity';
import { OrderItemMapper } from '../mappers/order-item.mapper';
@Injectable()
export class OrderItemRelationalRepository implements OrderItemRepository {
  constructor(
    @InjectRepository(OrderItemEntity)
    private readonly orderItemRepository: Repository<OrderItemEntity>,
    @InjectRepository(OrderEntity)
    private readonly orderRepository: Repository<OrderEntity>,
    private readonly orderItemMapper: OrderItemMapper,
  ) {}
  async findById(id: string): Promise<OrderItem | null> {
    const orderItemEntity = await this.orderItemRepository.findOne({
      where: { id },
      relations: ['order', 'productModifiers', 'selectedPizzaCustomizations'],
    });
    if (!orderItemEntity) {
      return null;
    }
    return this.orderItemMapper.toDomain(orderItemEntity);
  }
  async findByOrderId(orderId: string): Promise<OrderItem[]> {
    const orderItemEntities = await this.orderItemRepository.find({
      where: { orderId },
      relations: ['order', 'productModifiers', 'selectedPizzaCustomizations'],
    });
    return orderItemEntities
      .map((entity) => this.orderItemMapper.toDomain(entity))
      .filter((item): item is OrderItem => item !== null);
  }
  async save(orderItem: OrderItem): Promise<OrderItem> {
    const orderEntity = await this.orderRepository.findOneBy({
      id: orderItem.orderId,
    });
    if (!orderEntity) {
      throw new NotFoundException(
        `Order with ID ${orderItem.orderId} not found when saving OrderItem`,
      );
    }
    const orderItemEntity = this.orderItemMapper.toEntity(orderItem);
    if (!orderItemEntity) {
      throw new InternalServerErrorException(
        'Error mapping OrderItem domain to entity for save',
      );
    }
    const savedEntity = await this.orderItemRepository.save(orderItemEntity);
    const reloadedEntity = await this.orderItemRepository.findOne({
      where: { id: savedEntity.id },
      relations: [
        'order',
        'productModifiers',
        'product',
        'productVariant',
        'selectedPizzaCustomizations',
      ],
    });
    if (!reloadedEntity) {
      throw new InternalServerErrorException(
        `OrderItem with ID ${savedEntity.id} not found after saving.`,
      );
    }
    const domainResult = this.orderItemMapper.toDomain(reloadedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping reloaded OrderItem entity to domain',
      );
    }
    return domainResult;
  }
  async update(orderItem: OrderItem): Promise<OrderItem> {
    const entityToUpdate = this.orderItemMapper.toEntity(orderItem);
    if (!entityToUpdate || !entityToUpdate.id) {
      throw new InternalServerErrorException(
        'Error mapping OrderItem domain to entity for update or ID missing',
      );
    }
    const exists = await this.orderItemRepository.existsBy({
      id: entityToUpdate.id,
    });
    if (!exists) {
      throw new NotFoundException(
        `OrderItem with ID ${entityToUpdate.id} not found for update.`,
      );
    }
    const updatedEntity = await this.orderItemRepository.save(entityToUpdate);
    const reloadedEntity = await this.orderItemRepository.findOne({
      where: { id: updatedEntity.id },
      relations: [
        'order',
        'productModifiers',
        'product',
        'productVariant',
        'selectedPizzaCustomizations',
      ],
    });
    if (!reloadedEntity) {
      throw new InternalServerErrorException(
        `OrderItem with ID ${updatedEntity.id} not found after updating.`,
      );
    }
    const domainResult = this.orderItemMapper.toDomain(reloadedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping reloaded OrderItem entity to domain after update',
      );
    }
    return domainResult;
  }
  async delete(id: string): Promise<void> {
    await this.orderItemRepository.softDelete(id);
  }
}

================
File: backend/src/orders/infrastructure/persistence/relational/repositories/order-preparation-screen-status.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { OrderPreparationScreenStatus } from '../../../../domain/order-preparation-screen-status';
import { OrderPreparationScreenStatusRepository } from '../../order-preparation-screen-status.repository';
import { OrderPreparationScreenStatusEntity } from '../entities/order-preparation-screen-status.entity';
import { OrderPreparationScreenStatusMapper } from '../mappers/order-preparation-screen-status.mapper';
@Injectable()
export class OrderPreparationScreenStatusRelationalRepository
  implements OrderPreparationScreenStatusRepository
{
  constructor(
    @InjectRepository(OrderPreparationScreenStatusEntity)
    private readonly repository: Repository<OrderPreparationScreenStatusEntity>,
    private readonly mapper: OrderPreparationScreenStatusMapper,
  ) {}
  async create(
    data: Omit<OrderPreparationScreenStatus, 'id' | 'createdAt' | 'updatedAt'>,
  ): Promise<OrderPreparationScreenStatus> {
    const entity = this.mapper.toEntity(data as OrderPreparationScreenStatus);
    if (!entity) {
      throw new Error('Failed to map domain to entity');
    }
    const newEntity = await this.repository.save(
      this.repository.create(entity),
    );
    const result = this.mapper.toDomain(newEntity);
    if (!result) {
      throw new Error('Failed to map entity to domain');
    }
    return result;
  }
  async findByOrderId(
    orderId: string,
  ): Promise<OrderPreparationScreenStatus[]> {
    const entities = await this.repository.find({
      where: { orderId },
      relations: ['preparationScreen', 'startedBy', 'completedBy'],
    });
    return entities
      .map((entity) => this.mapper.toDomain(entity))
      .filter(
        (domain): domain is OrderPreparationScreenStatus => domain !== null,
      );
  }
  async findByOrderAndScreen(
    orderId: string,
    screenId: string,
  ): Promise<OrderPreparationScreenStatus | null> {
    const entity = await this.repository.findOne({
      where: {
        orderId,
        preparationScreenId: screenId,
      },
      relations: ['preparationScreen', 'startedBy', 'completedBy'],
    });
    return entity ? this.mapper.toDomain(entity) : null;
  }
  async update(
    id: string,
    data: Partial<OrderPreparationScreenStatus>,
  ): Promise<OrderPreparationScreenStatus> {
    const entity = await this.repository.findOne({
      where: { id },
      relations: ['preparationScreen', 'startedBy', 'completedBy'],
    });
    if (!entity) {
      throw new Error('OrderPreparationScreenStatus not found');
    }
    Object.assign(entity, data);
    const updatedEntity = await this.repository.save(entity);
    const result = this.mapper.toDomain(updatedEntity);
    if (!result) {
      throw new Error('Failed to map entity to domain');
    }
    return result;
  }
  async createOrUpdate(
    orderId: string,
    screenId: string,
    data: Partial<OrderPreparationScreenStatus>,
  ): Promise<OrderPreparationScreenStatus> {
    let entity = await this.repository.findOne({
      where: {
        orderId,
        preparationScreenId: screenId,
      },
    });
    if (entity) {
      Object.assign(entity, data);
      entity = await this.repository.save(entity);
    } else {
      const newData = {
        ...data,
        orderId,
        preparationScreenId: screenId,
      } as OrderPreparationScreenStatus;
      const newEntity = this.mapper.toEntity(newData);
      if (!newEntity) {
        throw new Error('Failed to map domain to entity');
      }
      entity = await this.repository.save(this.repository.create(newEntity));
    }
    const completeEntity = await this.repository.findOne({
      where: { id: entity!.id },
      relations: ['preparationScreen', 'startedBy', 'completedBy'],
    });
    if (!completeEntity) {
      throw new Error('Failed to load complete entity');
    }
    const result = this.mapper.toDomain(completeEntity);
    if (!result) {
      throw new Error('Failed to map entity to domain');
    }
    return result;
  }
  async deleteByOrderId(orderId: string): Promise<void> {
    await this.repository.delete({ orderId });
  }
}

================
File: backend/src/orders/infrastructure/persistence/relational/subscribers/order.subscriber.ts
================
import {
  DataSource,
  EntitySubscriberInterface,
  EventSubscriber,
  RemoveEvent,
  UpdateEvent,
} from 'typeorm';
import { InjectDataSource } from '@nestjs/typeorm';
import { OrderEntity } from '../entities/order.entity';
import { UserContextService } from '../../../../../common/services/user-context.service';
import { Inject } from '@nestjs/common';
import { OrderChangeTrackerV2Service } from '../../../../services/order-change-tracker-v2.service';
@EventSubscriber()
export class OrderSubscriber implements EntitySubscriberInterface<OrderEntity> {
  private changeTracker: OrderChangeTrackerV2Service;
  private beforeUpdateCache = new Map<string, OrderEntity>();
  constructor(
    @InjectDataSource() readonly dataSource: DataSource,
    @Inject(UserContextService)
    private readonly userContextService: UserContextService,
  ) {
    dataSource.subscribers.push(this);
    this.changeTracker = new OrderChangeTrackerV2Service();
  }
  listenTo() {
    return OrderEntity;
  }
  async beforeUpdate(event: UpdateEvent<OrderEntity>) {
    if (!event.entity || !event.databaseEntity) return;
    const queryRunner = this.dataSource.createQueryRunner();
    try {
      await queryRunner.connect();
      const fullOrder = await queryRunner.manager.findOne(OrderEntity, {
        where: { id: event.databaseEntity.id },
        relations: [
          'orderItems',
          'orderItems.product',
          'orderItems.productVariant',
          'orderItems.productModifiers',
          'orderItems.selectedPizzaCustomizations',
          'orderItems.selectedPizzaCustomizations.pizzaCustomization',
          'table',
          'customer',
          'customer.addresses',
          'deliveryInfo',
        ],
      });
      if (fullOrder) {
        this.beforeUpdateCache.set(fullOrder.id, fullOrder);
      }
    } finally {
      await queryRunner.release();
    }
  }
  afterInsert(): void {
    return;
  }
  afterUpdate(event: UpdateEvent<OrderEntity>): void {
    if (!event.entity) return;
    const orderId = event.entity.id;
    const previousState = this.beforeUpdateCache.get(orderId);
    if (!previousState) {
      return;
    }
    this.beforeUpdateCache.delete(orderId);
    setTimeout(async () => {
      const queryRunner = this.dataSource.createQueryRunner();
      try {
        await queryRunner.connect();
        const currentOrder = await queryRunner.manager.findOne(OrderEntity, {
          where: { id: orderId },
          relations: [
            'orderItems',
            'orderItems.product',
            'orderItems.productVariant',
            'orderItems.productModifiers',
            'orderItems.selectedPizzaCustomizations',
            'orderItems.selectedPizzaCustomizations.pizzaCustomization',
            'table',
            'customer',
            'customer.addresses',
            'deliveryInfo',
          ],
        });
        if (!currentOrder) {
          return;
        }
        const currentUser = this.userContextService.getCurrentUser();
        const changedBy =
          currentUser?.userId || currentOrder.userId || 'system';
        await this.changeTracker.trackOrderWithItems(
          'UPDATE',
          currentOrder,
          previousState,
          changedBy,
          queryRunner.manager,
        );
      } finally {
        await queryRunner.release();
      }
    }, 100);
  }
  async afterRemove(event: RemoveEvent<OrderEntity>) {
    if (!event.databaseEntity) return;
    const currentUser = this.userContextService.getCurrentUser();
    const changedBy =
      currentUser?.userId || event.databaseEntity.userId || 'system';
    await this.changeTracker.trackOrderWithItems(
      'DELETE',
      event.databaseEntity,
      null,
      changedBy,
      event.manager,
    );
  }
}

================
File: backend/src/orders/infrastructure/persistence/ticket-impression.repository.ts
================
import { NullableType } from '../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../utils/types/pagination-options';
import { TicketImpression } from '../../domain/ticket-impression';
export abstract class TicketImpressionRepository {
  abstract create(
    data: Omit<
      TicketImpression,
      'id' | 'createdAt' | 'deletedAt' | 'updatedAt' | 'order' | 'user'
    >,
  ): Promise<TicketImpression>;
  abstract findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: {
      orderId?: string;
      userId?: string;
      ticketType?: string;
    } | null;
    paginationOptions: IPaginationOptions;
  }): Promise<TicketImpression[]>;
  abstract findById(
    id: TicketImpression['id'],
  ): Promise<NullableType<TicketImpression>>;
  abstract findByOrderId(
    orderId: TicketImpression['orderId'],
  ): Promise<TicketImpression[]>;
}

================
File: backend/src/orders/order-change-log.service.ts
================
import { Injectable, Inject } from '@nestjs/common';
import { OrderHistoryRepository } from './infrastructure/persistence/order-history.repository';
import { UsersService } from '../users/users.service';
import { ORDER_HISTORY_REPOSITORY } from '../common/tokens';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { OrderHistoryEntity } from './infrastructure/persistence/relational/entities/order-history.entity';
import { User } from '../users/domain/user';
export class EnrichedOrderHistoryDto extends OrderHistoryEntity {
  changedByUser?: Pick<
    User,
    'id' | 'firstName' | 'lastName' | 'username'
  > | null;
  formattedChanges?: Record<string, any>;
}
@Injectable()
export class OrderChangeLogService {
  constructor(
    @Inject(ORDER_HISTORY_REPOSITORY)
    private readonly historyRepository: OrderHistoryRepository,
    private readonly usersService: UsersService,
  ) {}
  async findByOrderId(
    orderId: string,
    paginationOptions: IPaginationOptions,
  ): Promise<[EnrichedOrderHistoryDto[], number]> {
    const [logs, totalCount] = await this.historyRepository.findByOrderId(
      orderId,
      paginationOptions,
    );
    if (logs.length === 0) {
      return [[], totalCount];
    }
    const userIds = [...new Set(logs.map((log) => log.changedBy))].filter(
      (id): id is string => !!id,
    );
    let userMap = new Map<
      string,
      Pick<User, 'id' | 'firstName' | 'lastName' | 'username'>
    >();
    if (userIds.length > 0) {
      try {
        const users = await this.usersService.findByIds(userIds);
        userMap = new Map(
          users.map((u) => [
            u.id,
            {
              id: u.id,
              firstName: u.firstName,
              lastName: u.lastName,
              username: u.username,
            },
          ]),
        );
      } catch {
      }
    }
    const enrichedLogs = logs.map((log) => {
      const user = log.changedBy ? userMap.get(log.changedBy) : null;
      const enrichedLog = new EnrichedOrderHistoryDto();
      Object.assign(enrichedLog, log);
      enrichedLog.changedByUser = user || null;
      if (log.diff) {
        if (log.diff.order || log.diff.items || log.diff.summary) {
          enrichedLog.diff = log.diff;
          enrichedLog.formattedChanges = this.formatChanges(log.diff);
        } else if (log.operation === 'UPDATE') {
          enrichedLog.formattedChanges = this.formatChanges(log.diff);
        }
      }
      return enrichedLog;
    });
    return [enrichedLogs, totalCount];
  }
  private formatChanges(diff: any): Record<string, any> {
    const formatted: Record<string, any> = {};
    if (diff && (diff.order || diff.items || diff.summary)) {
      if (diff.summary) {
        formatted['Resumen'] = diff.summary;
      }
      if (diff.order) {
        if (diff.order.fields) {
          formatted['Cambios en la orden'] = this.formatOrderFields(
            diff.order.fields,
          );
        }
        if (diff.order.deliveryInfo) {
          formatted['Información de entrega'] = this.formatDeliveryInfo(
            diff.order.deliveryInfo,
          );
        }
      }
      if (diff.items) {
        formatted['Cambios en productos'] = this.formatConsolidatedItemChanges(
          diff.items,
        );
      }
      return formatted;
    }
    return this.formatOrderChanges(diff);
  }
  private formatOrderChanges(diff: any): Record<string, any> {
    const formatted: Record<string, any> = {};
    const fieldLabels: Record<string, string> = {
      orderStatus: 'Estado de la orden',
      orderType: 'Tipo de orden',
      total: 'Total',
      subtotal: 'Subtotal',
      notes: 'Notas',
      tableId: 'Mesa',
      customerId: 'Cliente',
      deliveryInfo: 'Información de entrega',
      scheduledAt: 'Hora programada',
      estimatedDeliveryTime: 'Tiempo estimado de entrega',
      isFromWhatsApp: 'Origen WhatsApp',
    };
    const valueFormatters: Record<string, (value: any) => string> = {
      orderStatus: (value) => {
        const statusMap: Record<string, string> = {
          PENDING: 'Pendiente',
          IN_PROGRESS: 'En Progreso',
          READY: 'Lista',
          DELIVERED: 'Entregada',
          COMPLETED: 'Completada',
          CANCELLED: 'Cancelada',
        };
        return statusMap[value] || value;
      },
      orderType: (value) => {
        const typeMap: Record<string, string> = {
          DINE_IN: 'Para Comer Aquí',
          TAKE_AWAY: 'Para Llevar',
          DELIVERY: 'Domicilio',
        };
        return typeMap[value] || value;
      },
      total: (value) => `$${value}`,
      subtotal: (value) => `$${value}`,
      scheduledAt: (value) =>
        value ? new Date(value).toLocaleString('es-MX') : 'No programada',
      estimatedDeliveryTime: (value) =>
        value ? new Date(value).toLocaleString('es-MX') : 'No especificado',
      isFromWhatsApp: (value) => (value ? 'Sí' : 'No'),
      deliveryInfo: (value) => {
        if (!value || typeof value !== 'object') return value;
        const parts: string[] = [];
        if (value.recipientName) parts.push(`Cliente: ${value.recipientName}`);
        if (value.recipientPhone) parts.push(`Tel: ${value.recipientPhone}`);
        if (value.fullAddress) parts.push(`Dirección: ${value.fullAddress}`);
        return parts.join(', ');
      },
    };
    for (const [field, change] of Object.entries(diff)) {
      if (change && typeof change === 'object') {
        const label = fieldLabels[field] || field;
        const formatter = valueFormatters[field];
        if (Array.isArray(change) && change.length >= 2) {
          const [oldValue, newValue] = change;
          formatted[label] = {
            anterior: formatter ? formatter(oldValue) : oldValue,
            nuevo: formatter ? formatter(newValue) : newValue,
          };
        }
      }
    }
    return formatted;
  }
  private formatConsolidatedItemChanges(items: any): any {
    const formatted: any = {};
    if (items.added && items.added.length > 0) {
      formatted['Productos agregados'] = items.added.map(
        (item: any) =>
          item.productName + (item.variantName ? ` - ${item.variantName}` : ''),
      );
    }
    // Items modificados - Simplificado mostrando antes y después
    if (items.modified && items.modified.length > 0) {
      formatted['Productos modificados'] = items.modified.map(
        (change: any) => ({
          antes:
            change.before.productName +
            (change.before.variantName
              ? ` - ${change.before.variantName}`
              : ''),
          después:
            change.after.productName +
            (change.after.variantName ? ` - ${change.after.variantName}` : ''),
        }),
      );
    }
    // Items eliminados - Simplificado para la app
    if (items.removed && items.removed.length > 0) {
      formatted['Productos eliminados'] = items.removed.map(
        (item: any) =>
          item.productName + (item.variantName ? ` - ${item.variantName}` : ''),
      );
    }
    return formatted;
  }
  private formatOrderFields(fields: any): any {
    const formatted: any = {};
    for (const [field, change] of Object.entries(fields)) {
      if (Array.isArray(change) && change.length === 2) {
        const [before, after] = change;
        const label = this.getFieldLabel(field);
        const formatter = this.getFieldFormatter(field);
        formatted[label] = {
          anterior: formatter(before),
          nuevo: formatter(after),
        };
      }
    }
    return formatted;
  }
  private formatDeliveryInfo(deliveryDiff: any): any {
    const formatted: any = {};
    // Manejar cambios en campos individuales de deliveryInfo
    for (const [field, change] of Object.entries(deliveryDiff)) {
      if (Array.isArray(change) && change.length === 2) {
        const [before, after] = change;
        const label = this.getDeliveryFieldLabel(field);
        formatted[label] = {
          anterior: before || 'No especificado',
          nuevo: after || 'No especificado',
        };
      }
    }
    return formatted;
  }
  private getFieldLabel(field: string): string {
    const labels: Record<string, string> = {
      orderStatus: 'Estado de la orden',
      orderType: 'Tipo de orden',
      notes: 'Notas',
      tableId: 'Mesa',
      customerId: 'Cliente',
      scheduledAt: 'Hora programada',
      estimatedDeliveryTime: 'Tiempo estimado de entrega',
      isFromWhatsApp: 'Origen WhatsApp',
    };
    return labels[field] || field;
  }
  private getDeliveryFieldLabel(field: string): string {
    const labels: Record<string, string> = {
      recipientName: 'Nombre del destinatario',
      recipientPhone: 'Teléfono del destinatario',
      fullAddress: 'Dirección completa',
      references: 'Referencias',
      coordinates: 'Coordenadas',
    };
    return labels[field] || field;
  }
  private getFieldFormatter(field: string): (value: any) => string {
    const formatters: Record<string, (value: any) => string> = {
      orderStatus: (value) => this.formatOrderStatus(value),
      orderType: (value) => this.formatOrderType(value),
      scheduledAt: (value) =>
        value ? new Date(value).toLocaleString('es-MX') : 'No programada',
      estimatedDeliveryTime: (value) =>
        value ? new Date(value).toLocaleString('es-MX') : 'No especificado',
      isFromWhatsApp: (value) => (value ? 'Sí' : 'No'),
    };
    return (
      formatters[field] || ((value) => value?.toString() || 'No especificado')
    );
  }
  private formatOrderStatus(status: string): string {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Progreso',
      READY: 'Lista',
      DELIVERED: 'Entregada',
      COMPLETED: 'Completada',
      CANCELLED: 'Cancelada',
    };
    return statusMap[status] || status;
  }
  private formatOrderType(type: string): string {
    const typeMap: Record<string, string> = {
      DINE_IN: 'Para Comer Aquí',
      TAKE_AWAY: 'Para Llevar',
      DELIVERY: 'Domicilio',
    };
    return typeMap[type] || type;
  }
}

================
File: backend/src/orders/services/pizza-price-calculator.service.ts
================
import { Injectable } from '@nestjs/common';
import { Product } from '../../products/domain/product';
import { ProductVariant } from '../../product-variants/domain/product-variant';
import { ProductModifier } from '../../product-modifiers/domain/product-modifier';
import { SelectedPizzaCustomization } from '../../selected-pizza-customizations/domain/selected-pizza-customization';
import { PizzaConfiguration } from '../../pizza-configurations/domain/pizza-configuration';
import { PizzaCustomization } from '../../pizza-customizations/domain/pizza-customization';
import { CustomizationAction } from '../../selected-pizza-customizations/domain/enums/customization-action.enum';
import { PizzaHalf } from '../../selected-pizza-customizations/domain/enums/pizza-half.enum';
@Injectable()
export class PizzaPriceCalculatorService {
  calculateOrderItemPrice(params: {
    product: Product;
    productVariant?: ProductVariant | null;
    productModifiers: ProductModifier[];
    selectedPizzaCustomizations?: SelectedPizzaCustomization[];
  }): { basePrice: number; finalPrice: number } {
    const {
      product,
      productVariant,
      productModifiers,
      selectedPizzaCustomizations,
    } = params;
    let basePrice = 0;
    if (productVariant) {
      basePrice = Number(productVariant.price);
    } else if (product.hasVariants) {
      throw new Error('Producto con variantes requiere selección de variante');
    } else {
      basePrice = Number(product.price) || 0;
    }
    const modifiersPrice = productModifiers.reduce(
      (sum, modifier) => sum + (Number(modifier.price) || 0),
      0,
    );
    let finalPrice = basePrice + modifiersPrice;
    if (
      product.isPizza &&
      product.pizzaConfiguration &&
      selectedPizzaCustomizations
    ) {
      const pizzaExtraCost = this.calculatePizzaExtraCost(
        product.pizzaConfiguration,
        selectedPizzaCustomizations,
        product.pizzaCustomizations || [],
      );
      finalPrice += pizzaExtraCost;
    }
    return { basePrice, finalPrice };
  }
  private calculatePizzaExtraCost(
    config: PizzaConfiguration,
    selectedCustomizations: SelectedPizzaCustomization[],
    availableCustomizations: PizzaCustomization[],
  ): number {
    let totalToppingValue = 0;
    const addedCustomizations = selectedCustomizations.filter(
      (c) => c.action === CustomizationAction.ADD,
    );
    for (const selected of addedCustomizations) {
      const customization = availableCustomizations.find(
        (c) => c.id === selected.pizzaCustomizationId,
      );
      if (!customization) {
        continue;
      }
      if (selected.half === PizzaHalf.FULL) {
        totalToppingValue += customization.toppingValue;
      } else {
        totalToppingValue += customization.toppingValue / 2;
      }
    }
    if (totalToppingValue > config.includedToppings) {
      const extraToppings = totalToppingValue - config.includedToppings;
      return extraToppings * Number(config.extraToppingCost);
    }
    return 0;
  }
}

================
File: backend/src/orders/ticket-impressions.controller.ts
================
import {
  Controller,
  Get,
  Param,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
  UseGuards,
} from '@nestjs/common';
import {
  ApiOperation,
  ApiResponse,
  ApiTags,
  ApiParam,
  ApiBearerAuth,
} from '@nestjs/swagger';
import { OrdersService } from './orders.service';
import { TicketImpression } from './domain/ticket-impression';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
@ApiTags('Order Ticket Impressions')
@Controller({
  path: 'orders/:orderId/ticket-impressions',
  version: '1',
})
export class TicketImpressionsController {
  constructor(private readonly ordersService: OrdersService) {}
  @Get()
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(
    RoleEnum.admin,
    RoleEnum.manager,
    RoleEnum.cashier,
    RoleEnum.waiter,
    RoleEnum.kitchen,
  )
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary:
      'Obtener todas las impresiones de tickets para una orden específica',
  })
  @ApiParam({ name: 'orderId', description: 'ID de la orden', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Lista de impresiones de tickets para la orden.',
    type: [TicketImpression],
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Orden no encontrada.',
  })
  findAllByOrderId(
    @Param('orderId', ParseUUIDPipe) orderId: string,
  ): Promise<TicketImpression[]> {
    return this.ordersService.findImpressionsByOrderId(orderId);
  }
}

================
File: backend/src/payments/domain/enums/payment-method.enum.ts
================
export enum PaymentMethod {
  CASH = 'CASH',
  CREDIT_CARD = 'CREDIT_CARD',
  DEBIT_CARD = 'DEBIT_CARD',
  TRANSFER = 'TRANSFER',
  OTHER = 'OTHER',
}

================
File: backend/src/payments/domain/enums/payment-status.enum.ts
================
export enum PaymentStatus {
  PENDING = 'PENDING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED',
  CANCELLED = 'CANCELLED',
}

================
File: backend/src/payments/dto/create-payment.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsPositive,
  IsUUID,
} from 'class-validator';
import { PaymentMethod } from '../domain/enums/payment-method.enum';
export class CreatePaymentDto {
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description: 'ID de la orden asociada al pago',
  })
  @IsNotEmpty()
  @IsUUID()
  orderId: string;
  @ApiProperty({
    enum: PaymentMethod,
    example: PaymentMethod.CASH,
    description: 'Método de pago',
  })
  @IsNotEmpty()
  @IsEnum(PaymentMethod)
  paymentMethod: PaymentMethod;
  @ApiProperty({
    type: Number,
    example: 177.59,
    description: 'Monto del pago',
  })
  @IsNotEmpty()
  @IsNumber()
  @IsPositive()
  amount: number;
}

================
File: backend/src/payments/dto/create-prepayment.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEnum, IsNotEmpty, IsNumber, IsPositive } from 'class-validator';
import { PaymentMethod } from '../domain/enums/payment-method.enum';
export class CreatePrepaymentDto {
  @ApiProperty({
    enum: PaymentMethod,
    example: PaymentMethod.CASH,
    description: 'Método de pago',
  })
  @IsNotEmpty()
  @IsEnum(PaymentMethod)
  paymentMethod: PaymentMethod;
  @ApiProperty({
    type: Number,
    example: 177.59,
    description: 'Monto del pago',
  })
  @IsNotEmpty()
  @IsNumber()
  @IsPositive()
  amount: number;
}

================
File: backend/src/payments/dto/find-all-payments.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEnum, IsOptional, IsUUID } from 'class-validator';
import { PaymentMethod } from '../domain/enums/payment-method.enum';
import { PaymentStatus } from '../domain/enums/payment-status.enum';
export class FindAllPaymentsDto {
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description: 'ID de la orden asociada al pago',
    required: false,
  })
  @IsOptional()
  @IsUUID()
  orderId?: string;
  @ApiProperty({
    enum: PaymentMethod,
    example: PaymentMethod.CASH,
    description: 'Método de pago',
    required: false,
  })
  @IsOptional()
  @IsEnum(PaymentMethod)
  paymentMethod?: PaymentMethod;
  @ApiProperty({
    enum: PaymentStatus,
    example: PaymentStatus.PENDING,
    description: 'Estado del pago',
    required: false,
  })
  @IsOptional()
  @IsEnum(PaymentStatus)
  paymentStatus?: PaymentStatus;
}

================
File: backend/src/payments/dto/update-payment.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEnum, IsNumber, IsOptional, IsPositive } from 'class-validator';
import { PaymentMethod } from '../domain/enums/payment-method.enum';
import { PaymentStatus } from '../domain/enums/payment-status.enum';
export class UpdatePaymentDto {
  @ApiProperty({
    enum: PaymentMethod,
    example: PaymentMethod.CASH,
    description: 'Método de pago',
    required: false,
  })
  @IsOptional()
  @IsEnum(PaymentMethod)
  paymentMethod?: PaymentMethod;
  @ApiProperty({
    type: Number,
    example: 177.59,
    description: 'Monto del pago',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  @IsPositive()
  amount?: number;
  @ApiProperty({
    enum: PaymentStatus,
    example: PaymentStatus.COMPLETED,
    description: 'Estado del pago',
    required: false,
  })
  @IsOptional()
  @IsEnum(PaymentStatus)
  paymentStatus?: PaymentStatus;
}

================
File: backend/src/payments/infrastructure/persistence/relational/entities/payment.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
  RelationId,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { OrderEntity } from '../../../../../orders/infrastructure/persistence/relational/entities/order.entity';
import { PaymentMethod } from '../../../../domain/enums/payment-method.enum';
import { PaymentStatus } from '../../../../domain/enums/payment-status.enum';
@Entity({
  name: 'payment',
})
export class PaymentEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @RelationId((payment: PaymentEntity) => payment.order)
  orderId: string | null;
  @Column({
    type: 'enum',
    enum: PaymentMethod,
    default: PaymentMethod.CASH,
  })
  paymentMethod: PaymentMethod;
  @Column({
    type: 'decimal',
    precision: 10,
    scale: 2,
    transformer: {
      to: (value: number) => value,
      from: (value: string) => parseFloat(value),
    },
  })
  amount: number;
  @Column({
    type: 'enum',
    enum: PaymentStatus,
    default: PaymentStatus.PENDING,
  })
  paymentStatus: PaymentStatus;
  @ManyToOne(() => OrderEntity, (order) => order.payments, {
    eager: true,
    nullable: true,
  })
  @JoinColumn({ name: 'order_id' })
  order: OrderEntity | null;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/payments/infrastructure/persistence/relational/mappers/payment.mapper.ts
================
import { forwardRef, Inject, Injectable } from '@nestjs/common';
import { Payment } from '../../../../domain/payment';
import { PaymentEntity } from '../entities/payment.entity';
import { OrderEntity } from '../../../../../orders/infrastructure/persistence/relational/entities/order.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
import { OrderMapper } from '../../../../../orders/infrastructure/persistence/relational/mappers/order.mapper';
@Injectable()
export class PaymentMapper extends BaseMapper<PaymentEntity, Payment> {
  constructor(
    @Inject(forwardRef(() => OrderMapper))
    private readonly orderMapper: OrderMapper,
  ) {
    super();
  }
  override toDomain(entity: PaymentEntity): Payment | null {
    if (!entity) return null;
    const domain = new Payment();
    domain.id = entity.id;
    domain.orderId = entity.orderId || entity.order?.id || null;
    domain.paymentMethod = entity.paymentMethod;
    domain.amount = entity.amount;
    domain.paymentStatus = entity.paymentStatus;
    if (entity.order) {
      const mappedOrder = this.orderMapper.toDomain(entity.order);
      if (mappedOrder) {
        domain.order = mappedOrder;
      }
    }
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: Payment): PaymentEntity | null {
    if (!domain) return null;
    const entity = new PaymentEntity();
    if (domain.id) entity.id = domain.id;
    entity.orderId = domain.orderId;
    if (domain.orderId) {
      entity.order = { id: domain.orderId } as OrderEntity;
    }
    entity.paymentMethod = domain.paymentMethod;
    entity.amount = domain.amount;
    entity.paymentStatus = domain.paymentStatus;
    return entity;
  }
}

================
File: backend/src/payments/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PaymentEntity } from './entities/payment.entity';
import { PaymentMapper } from './mappers/payment.mapper';
import { RelationalPaymentRepository } from './repositories/payment.repository';
import { PAYMENT_REPOSITORY } from '../../../../common/tokens';
import { RelationalOrderPersistenceModule } from '../../../../orders/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([PaymentEntity]),
    forwardRef(() => RelationalOrderPersistenceModule),
  ],
  providers: [
    {
      provide: PAYMENT_REPOSITORY,
      useClass: RelationalPaymentRepository,
    },
    PaymentMapper,
  ],
  exports: [PAYMENT_REPOSITORY, PaymentMapper],
})
export class RelationalPaymentPersistenceModule {}

================
File: backend/src/payments/payments.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common';
import { PaymentsService } from './payments.service';
import { CreatePaymentDto } from './dto/create-payment.dto';
import { CreatePrepaymentDto } from './dto/create-prepayment.dto';
import { UpdatePaymentDto } from './dto/update-payment.dto';
import { FindAllPaymentsDto } from './dto/find-all-payments.dto';
import { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';
import { Payment } from './domain/payment';
@ApiTags('payments')
@Controller({ path: 'payments', version: '1' })
export class PaymentsController {
  constructor(private readonly paymentsService: PaymentsService) {}
  @Post()
  @ApiOperation({ summary: 'Crear un nuevo pago' })
  @ApiResponse({
    status: 201,
    description: 'El pago ha sido creado exitosamente',
    type: Payment,
  })
  create(@Body() createPaymentDto: CreatePaymentDto) {
    return this.paymentsService.create(createPaymentDto);
  }
  @Get()
  @ApiOperation({ summary: 'Obtener todos los pagos con filtros opcionales' })
  @ApiResponse({
    status: 200,
    description: 'Lista de pagos',
    type: [Payment],
  })
  findAll(@Query() findAllPaymentsDto: FindAllPaymentsDto) {
    return this.paymentsService.findAll(findAllPaymentsDto);
  }
  @Get(':id')
  @ApiOperation({ summary: 'Obtener un pago por su ID' })
  @ApiResponse({
    status: 200,
    description: 'Pago encontrado',
    type: Payment,
  })
  @ApiResponse({
    status: 404,
    description: 'Pago no encontrado',
  })
  findOne(@Param('id', ParseUUIDPipe) id: string) {
    return this.paymentsService.findOne(id);
  }
  @Get('order/:orderId')
  @ApiOperation({ summary: 'Obtener pagos por ID de orden' })
  @ApiResponse({
    status: 200,
    description: 'Lista de pagos para la orden especificada',
    type: [Payment],
  })
  findByOrderId(@Param('orderId', ParseUUIDPipe) orderId: string) {
    return this.paymentsService.findByOrderId(orderId);
  }
  @Patch(':id')
  @ApiOperation({ summary: 'Actualizar un pago' })
  @ApiResponse({
    status: 200,
    description: 'Pago actualizado exitosamente',
    type: Payment,
  })
  @ApiResponse({
    status: 404,
    description: 'Pago no encontrado',
  })
  update(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updatePaymentDto: UpdatePaymentDto,
  ) {
    return this.paymentsService.update(id, updatePaymentDto);
  }
  @Delete(':id')
  @ApiOperation({ summary: 'Eliminar un pago' })
  @ApiResponse({
    status: 200,
    description: 'Pago eliminado exitosamente',
  })
  @ApiResponse({
    status: 404,
    description: 'Pago no encontrado',
  })
  remove(@Param('id', ParseUUIDPipe) id: string) {
    return this.paymentsService.remove(id);
  }
  @Post('prepayment')
  @ApiOperation({ summary: 'Crear un pre-pago (sin orden asociada)' })
  @ApiResponse({
    status: 201,
    description: 'El pre-pago ha sido creado exitosamente',
    type: Payment,
  })
  createPrepayment(@Body() createPrepaymentDto: CreatePrepaymentDto) {
    return this.paymentsService.createPrepayment(createPrepaymentDto);
  }
  @Patch(':paymentId/associate/:orderId')
  @ApiOperation({ summary: 'Asociar un pre-pago a una orden' })
  @ApiResponse({
    status: 200,
    description: 'El pago ha sido asociado a la orden exitosamente',
    type: Payment,
  })
  associateToOrder(
    @Param('paymentId', ParseUUIDPipe) paymentId: string,
    @Param('orderId', ParseUUIDPipe) orderId: string,
  ) {
    return this.paymentsService.associatePaymentToOrder(paymentId, orderId);
  }
}

================
File: backend/src/payments/payments.module.ts
================
import { Module } from '@nestjs/common';
import { PaymentsService } from './payments.service';
import { PaymentsController } from './payments.controller';
import { RelationalPaymentPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [RelationalPaymentPersistenceModule],
  controllers: [PaymentsController],
  providers: [PaymentsService],
  exports: [PaymentsService],
})
export class PaymentsModule {}

================
File: backend/src/payments/payments.service.ts
================
import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { PaymentRepository } from './infrastructure/persistence/payment.repository';
import { Payment } from './domain/payment';
import { CreatePaymentDto } from './dto/create-payment.dto';
import { CreatePrepaymentDto } from './dto/create-prepayment.dto';
import { UpdatePaymentDto } from './dto/update-payment.dto';
import { FindAllPaymentsDto } from './dto/find-all-payments.dto';
import { v4 as uuidv4 } from 'uuid';
import { PaymentStatus } from './domain/enums/payment-status.enum';
import { PaymentMethod } from './domain/enums/payment-method.enum';
import { PAYMENT_REPOSITORY } from '../common/tokens';
@Injectable()
export class PaymentsService {
  constructor(
    @Inject(PAYMENT_REPOSITORY)
    private readonly paymentRepository: PaymentRepository,
  ) {}
  async create(createPaymentDto: CreatePaymentDto): Promise<Payment> {
    const payment = new Payment();
    payment.id = uuidv4();
    payment.orderId = createPaymentDto.orderId;
    payment.paymentMethod = createPaymentDto.paymentMethod;
    payment.amount = createPaymentDto.amount;
    payment.paymentStatus =
      createPaymentDto.paymentMethod === PaymentMethod.CASH
        ? PaymentStatus.COMPLETED
        : PaymentStatus.PENDING;
    return this.paymentRepository.create(payment);
  }
  async findAll(findAllPaymentsDto: FindAllPaymentsDto): Promise<Payment[]> {
    const payments = await this.paymentRepository.findAll();
    let filteredPayments = payments;
    if (findAllPaymentsDto.orderId) {
      filteredPayments = filteredPayments.filter(
        (payment) => payment.orderId === findAllPaymentsDto.orderId,
      );
    }
    if (findAllPaymentsDto.paymentMethod) {
      filteredPayments = filteredPayments.filter(
        (payment) => payment.paymentMethod === findAllPaymentsDto.paymentMethod,
      );
    }
    if (findAllPaymentsDto.paymentStatus) {
      filteredPayments = filteredPayments.filter(
        (payment) => payment.paymentStatus === findAllPaymentsDto.paymentStatus,
      );
    }
    return filteredPayments;
  }
  async findOne(id: string): Promise<Payment> {
    const payment = await this.paymentRepository.findById(id);
    if (!payment) {
      throw new NotFoundException(`Payment with ID ${id} not found`);
    }
    return payment;
  }
  async findByOrderId(orderId: string): Promise<Payment[]> {
    return this.paymentRepository.findByOrderId(orderId);
  }
  async update(
    id: string,
    updatePaymentDto: UpdatePaymentDto,
  ): Promise<Payment> {
    const existingPayment = await this.findOne(id);
    const updatedPayment = new Payment();
    updatedPayment.id = id;
    updatedPayment.orderId = existingPayment.orderId;
    updatedPayment.paymentMethod =
      updatePaymentDto.paymentMethod ?? existingPayment.paymentMethod;
    updatedPayment.amount = updatePaymentDto.amount ?? existingPayment.amount;
    updatedPayment.paymentStatus =
      updatePaymentDto.paymentStatus ?? existingPayment.paymentStatus;
    updatedPayment.createdAt = existingPayment.createdAt;
    updatedPayment.order = existingPayment.order;
    return this.paymentRepository.update(id, updatedPayment);
  }
  async remove(id: string): Promise<void> {
    await this.findOne(id);
    await this.paymentRepository.delete(id);
  }
  async createPrepayment(
    createPrepaymentDto: CreatePrepaymentDto,
  ): Promise<Payment> {
    const payment = new Payment();
    payment.id = uuidv4();
    payment.orderId = null;
    payment.paymentMethod = createPrepaymentDto.paymentMethod;
    payment.amount = createPrepaymentDto.amount;
    payment.paymentStatus =
      createPrepaymentDto.paymentMethod === PaymentMethod.CASH
        ? PaymentStatus.COMPLETED
        : PaymentStatus.PENDING;
    return this.paymentRepository.create(payment);
  }
  async associatePaymentToOrder(
    paymentId: string,
    orderId: string,
  ): Promise<Payment> {
    const payment = await this.findOne(paymentId);
    if (payment.orderId) {
      throw new Error('Este pago ya está asociado a una orden');
    }
    const updatedPayment = new Payment();
    updatedPayment.id = payment.id;
    updatedPayment.orderId = orderId;
    updatedPayment.paymentMethod = payment.paymentMethod;
    updatedPayment.amount = payment.amount;
    updatedPayment.paymentStatus = payment.paymentStatus;
    updatedPayment.createdAt = payment.createdAt;
    return this.paymentRepository.update(paymentId, updatedPayment);
  }
}

================
File: backend/src/pizza-configurations/domain/pizza-configuration.ts
================
export class PizzaConfiguration {
  id: string;
  productId: string;
  includedToppings: number;
  extraToppingCost: number;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
}

================
File: backend/src/pizza-configurations/dto/create-pizza-configuration.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNumber, IsPositive, IsString, Min } from 'class-validator';
export class CreatePizzaConfigurationDto {
  @ApiProperty({ example: 'PROD-1' })
  @IsString()
  productId: string;
  @ApiProperty({
    example: 4,
    description: 'Number of toppings included in base price',
    default: 4,
  })
  @IsNumber()
  @Min(0)
  includedToppings: number;
  @ApiProperty({
    example: 20,
    description: 'Cost per extra topping',
    default: 20,
  })
  @IsNumber()
  @IsPositive()
  extraToppingCost: number;
}

================
File: backend/src/pizza-configurations/dto/update-pizza-configuration.dto.ts
================
import { PartialType } from '@nestjs/swagger';
import { CreatePizzaConfigurationDto } from './create-pizza-configuration.dto';
export class UpdatePizzaConfigurationDto extends PartialType(
  CreatePizzaConfigurationDto,
) {}

================
File: backend/src/pizza-configurations/infrastructure/persistence/pizza-configuration.repository.ts
================
import { PizzaConfiguration } from '../../domain/pizza-configuration';
export abstract class PizzaConfigurationRepository {
  abstract create(
    pizzaConfiguration: PizzaConfiguration,
  ): Promise<PizzaConfiguration>;
  abstract findById(id: string): Promise<PizzaConfiguration | null>;
  abstract findByProductId(
    productId: string,
  ): Promise<PizzaConfiguration | null>;
  abstract update(
    id: string,
    pizzaConfiguration: Partial<PizzaConfiguration>,
  ): Promise<PizzaConfiguration>;
  abstract updateByProductId(
    productId: string,
    pizzaConfiguration: Partial<PizzaConfiguration>,
  ): Promise<PizzaConfiguration | null>;
  abstract delete(id: string): Promise<void>;
  abstract deleteByProductId(productId: string): Promise<void>;
}

================
File: backend/src/pizza-configurations/infrastructure/persistence/relational/entities/pizza-configuration.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  OneToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
@Entity({
  name: 'pizza_configuration',
})
export class PizzaConfigurationEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ name: 'product_id', type: 'uuid', unique: true })
  productId: string;
  @OneToOne(() => ProductEntity, (product) => product.pizzaConfiguration)
  @JoinColumn({ name: 'product_id' })
  product: ProductEntity;
  @Column({ name: 'included_toppings', type: 'int', default: 0 })
  includedToppings: number;
  @Column({
    name: 'extra_topping_cost',
    type: 'decimal',
    precision: 10,
    scale: 2,
    default: 20,
  })
  extraToppingCost: number;
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/pizza-configurations/infrastructure/persistence/relational/mappers/pizza-configuration.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { PizzaConfiguration } from '../../../../domain/pizza-configuration';
import { PizzaConfigurationEntity } from '../entities/pizza-configuration.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class PizzaConfigurationMapper extends BaseMapper<
  PizzaConfigurationEntity,
  PizzaConfiguration
> {
  override toDomain(
    entity: PizzaConfigurationEntity,
  ): PizzaConfiguration | null {
    if (!entity) return null;
    const domain = new PizzaConfiguration();
    domain.id = entity.id;
    domain.productId = entity.productId;
    domain.includedToppings = entity.includedToppings;
    domain.extraToppingCost = entity.extraToppingCost;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(
    domain: PizzaConfiguration,
  ): PizzaConfigurationEntity | null {
    if (!domain) return null;
    const entity = new PizzaConfigurationEntity();
    if (domain.id) entity.id = domain.id;
    entity.productId = domain.productId;
    entity.includedToppings = domain.includedToppings;
    entity.extraToppingCost = domain.extraToppingCost;
    return entity;
  }
}

================
File: backend/src/pizza-configurations/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PizzaConfigurationEntity } from './entities/pizza-configuration.entity';
import { PizzaConfigurationRepository } from '../pizza-configuration.repository';
import { PizzaConfigurationRelationalRepository } from './repositories/pizza-configuration.repository';
import { PizzaConfigurationMapper } from './mappers/pizza-configuration.mapper';
@Module({
  imports: [TypeOrmModule.forFeature([PizzaConfigurationEntity])],
  providers: [
    {
      provide: PizzaConfigurationRepository,
      useClass: PizzaConfigurationRelationalRepository,
    },
    PizzaConfigurationMapper,
  ],
  exports: [PizzaConfigurationRepository, PizzaConfigurationMapper],
})
export class RelationalPizzaConfigurationPersistenceModule {}

================
File: backend/src/pizza-configurations/infrastructure/persistence/relational/repositories/pizza-configuration.repository.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { PizzaConfigurationEntity } from '../entities/pizza-configuration.entity';
import { PizzaConfigurationMapper } from '../mappers/pizza-configuration.mapper';
import { PizzaConfiguration } from '../../../../domain/pizza-configuration';
import { PizzaConfigurationRepository } from '../../pizza-configuration.repository';
@Injectable()
export class PizzaConfigurationRelationalRepository
  implements PizzaConfigurationRepository
{
  constructor(
    @InjectRepository(PizzaConfigurationEntity)
    private readonly pizzaConfigurationRepository: Repository<PizzaConfigurationEntity>,
    private readonly pizzaConfigurationMapper: PizzaConfigurationMapper,
  ) {}
  async create(
    pizzaConfiguration: PizzaConfiguration,
  ): Promise<PizzaConfiguration> {
    const persistenceModel =
      this.pizzaConfigurationMapper.toEntity(pizzaConfiguration);
    if (!persistenceModel) {
      throw new Error('Failed to map pizza configuration to entity');
    }
    const newEntity = await this.pizzaConfigurationRepository.save(
      this.pizzaConfigurationRepository.create(persistenceModel),
    );
    const domainResult = this.pizzaConfigurationMapper.toDomain(newEntity);
    if (!domainResult) {
      throw new Error('Failed to map entity to domain');
    }
    return domainResult;
  }
  async findById(id: string): Promise<PizzaConfiguration | null> {
    const entity = await this.pizzaConfigurationRepository.findOne({
      where: { id },
    });
    if (!entity) {
      return null;
    }
    return this.pizzaConfigurationMapper.toDomain(entity);
  }
  async findByProductId(productId: string): Promise<PizzaConfiguration | null> {
    const entity = await this.pizzaConfigurationRepository.findOne({
      where: { productId },
    });
    if (!entity) {
      return null;
    }
    return this.pizzaConfigurationMapper.toDomain(entity);
  }
  async update(
    id: string,
    pizzaConfiguration: Partial<PizzaConfiguration>,
  ): Promise<PizzaConfiguration> {
    const result = await this.pizzaConfigurationRepository.update(
      { id },
      pizzaConfiguration,
    );
    if (result.affected === 0) {
      throw new NotFoundException(
        `Pizza configuration with id ${id} not found`,
      );
    }
    const updated = await this.findById(id);
    if (!updated) {
      throw new NotFoundException(
        `Pizza configuration with id ${id} not found`,
      );
    }
    return updated;
  }
  async updateByProductId(
    productId: string,
    pizzaConfiguration: Partial<PizzaConfiguration>,
  ): Promise<PizzaConfiguration | null> {
    const result = await this.pizzaConfigurationRepository.update(
      { productId },
      pizzaConfiguration,
    );
    if (result.affected === 0) {
      return null;
    }
    return this.findByProductId(productId);
  }
  async delete(id: string): Promise<void> {
    const result = await this.pizzaConfigurationRepository.delete({ id });
    if (result.affected === 0) {
      throw new NotFoundException(
        `Pizza configuration with id ${id} not found`,
      );
    }
  }
  async deleteByProductId(productId: string): Promise<void> {
    const result = await this.pizzaConfigurationRepository.delete({
      productId,
    });
    if (result.affected === 0) {
      throw new NotFoundException(
        `Pizza configuration for product ${productId} not found`,
      );
    }
  }
}

================
File: backend/src/pizza-configurations/pizza-configurations.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { PizzaConfigurationsService } from './pizza-configurations.service';
import { CreatePizzaConfigurationDto } from './dto/create-pizza-configuration.dto';
import { UpdatePizzaConfigurationDto } from './dto/update-pizza-configuration.dto';
import { PizzaConfiguration } from './domain/pizza-configuration';
@ApiTags('Pizza Configurations')
@Controller({
  path: 'pizza-configurations',
  version: '1',
})
export class PizzaConfigurationsController {
  constructor(
    private readonly pizzaConfigurationsService: PizzaConfigurationsService,
  ) {}
  @Post()
  @ApiOperation({ summary: 'Create a new pizza configuration' })
  @ApiResponse({
    status: 201,
    description: 'Pizza configuration created successfully',
    type: PizzaConfiguration,
  })
  create(
    @Body() createPizzaConfigurationDto: CreatePizzaConfigurationDto,
  ): Promise<PizzaConfiguration> {
    return this.pizzaConfigurationsService.create(createPizzaConfigurationDto);
  }
  @Get('product/:productId')
  @ApiOperation({ summary: 'Get pizza configuration by product ID' })
  @ApiResponse({
    status: 200,
    description: 'Pizza configuration found',
    type: PizzaConfiguration,
  })
  @ApiResponse({
    status: 404,
    description: 'Pizza configuration not found',
  })
  findByProductId(
    @Param('productId') productId: string,
  ): Promise<PizzaConfiguration | null> {
    return this.pizzaConfigurationsService.findByProductId(productId);
  }
  @Patch(':id')
  @ApiOperation({ summary: 'Update a pizza configuration' })
  @ApiResponse({
    status: 200,
    description: 'Pizza configuration updated successfully',
    type: PizzaConfiguration,
  })
  update(
    @Param('id') id: string,
    @Body() updatePizzaConfigurationDto: UpdatePizzaConfigurationDto,
  ): Promise<PizzaConfiguration> {
    return this.pizzaConfigurationsService.update(
      id,
      updatePizzaConfigurationDto,
    );
  }
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete a pizza configuration' })
  @ApiResponse({
    status: 204,
    description: 'Pizza configuration deleted successfully',
  })
  remove(@Param('id') id: string): Promise<void> {
    return this.pizzaConfigurationsService.remove(id);
  }
}

================
File: backend/src/pizza-configurations/pizza-configurations.module.ts
================
import { Module } from '@nestjs/common';
import { PizzaConfigurationsService } from './pizza-configurations.service';
import { PizzaConfigurationsController } from './pizza-configurations.controller';
import { RelationalPizzaConfigurationPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [RelationalPizzaConfigurationPersistenceModule],
  controllers: [PizzaConfigurationsController],
  providers: [PizzaConfigurationsService],
  exports: [
    PizzaConfigurationsService,
    RelationalPizzaConfigurationPersistenceModule,
  ],
})
export class PizzaConfigurationsModule {}

================
File: backend/src/pizza-configurations/pizza-configurations.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { PizzaConfiguration } from './domain/pizza-configuration';
import { PizzaConfigurationRepository } from './infrastructure/persistence/pizza-configuration.repository';
import { CreatePizzaConfigurationDto } from './dto/create-pizza-configuration.dto';
import { UpdatePizzaConfigurationDto } from './dto/update-pizza-configuration.dto';
@Injectable()
export class PizzaConfigurationsService {
  constructor(
    private readonly pizzaConfigurationRepository: PizzaConfigurationRepository,
  ) {}
  async create(
    createPizzaConfigurationDto: CreatePizzaConfigurationDto,
  ): Promise<PizzaConfiguration> {
    const existing = await this.pizzaConfigurationRepository.findByProductId(
      createPizzaConfigurationDto.productId,
    );
    if (existing) {
      throw new Error(
        `Pizza configuration already exists for product ${createPizzaConfigurationDto.productId}`,
      );
    }
    const pizzaConfiguration = new PizzaConfiguration();
    pizzaConfiguration.productId = createPizzaConfigurationDto.productId;
    pizzaConfiguration.includedToppings =
      createPizzaConfigurationDto.includedToppings;
    pizzaConfiguration.extraToppingCost =
      createPizzaConfigurationDto.extraToppingCost;
    return this.pizzaConfigurationRepository.create(pizzaConfiguration);
  }
  async findByProductId(productId: string): Promise<PizzaConfiguration | null> {
    const pizzaConfiguration =
      await this.pizzaConfigurationRepository.findByProductId(productId);
    return pizzaConfiguration;
  }
  async update(
    id: string,
    updatePizzaConfigurationDto: UpdatePizzaConfigurationDto,
  ): Promise<PizzaConfiguration> {
    const configuration = await this.pizzaConfigurationRepository.findById(id);
    if (!configuration) {
      throw new NotFoundException(
        `Pizza configuration with id ${id} not found`,
      );
    }
    Object.assign(configuration, updatePizzaConfigurationDto);
    return this.pizzaConfigurationRepository.update(id, configuration);
  }
  async remove(id: string): Promise<void> {
    const configuration = await this.pizzaConfigurationRepository.findById(id);
    if (!configuration) {
      throw new NotFoundException(
        `Pizza configuration with id ${id} not found`,
      );
    }
    await this.pizzaConfigurationRepository.delete(id);
  }
}

================
File: backend/src/pizza-customizations/domain/enums/customization-type.enum.ts
================
export enum CustomizationType {
  FLAVOR = 'FLAVOR',
  INGREDIENT = 'INGREDIENT',
}

================
File: backend/src/pizza-customizations/domain/pizza-customization.ts
================
import { CustomizationType } from './enums/customization-type.enum';
export class PizzaCustomization {
  id: string;
  name: string;
  type: CustomizationType;
  ingredients?: string | null;
  toppingValue: number;
  isActive: boolean;
  sortOrder: number;
  productIds?: string[];
  products?: { id: string; name: string }[];
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
}

================
File: backend/src/pizza-customizations/dto/create-pizza-customization.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { CustomizationType } from '../domain/enums/customization-type.enum';
export class CreatePizzaCustomizationDto {
  @ApiProperty({ example: 'PI-1', required: false })
  @IsOptional()
  @IsString()
  id?: string;
  @ApiProperty({ example: 'Pepperoni' })
  @IsNotEmpty()
  @IsString()
  name: string;
  @ApiProperty({
    enum: CustomizationType,
    example: CustomizationType.INGREDIENT,
    description: 'Type of customization: FLAVOR or INGREDIENT',
  })
  @IsEnum(CustomizationType)
  type: CustomizationType;
  @ApiProperty({
    example: 'Jamón, piña, queso mozzarella',
    description: 'Description of ingredients for FLAVOR type',
    required: false,
  })
  @IsOptional()
  @IsString()
  ingredients?: string;
  @ApiProperty({
    example: 1,
    description: 'How much this counts towards the topping limit',
    default: 1,
  })
  @IsOptional()
  @IsNumber()
  @Min(0)
  toppingValue?: number;
  @ApiProperty({
    example: 0,
    description: 'Sort order for display',
    default: 0,
  })
  @IsOptional()
  @IsNumber()
  sortOrder?: number;
}

================
File: backend/src/pizza-customizations/dto/find-all-pizza-customizations.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { PaginationQueryDto } from '../../common/dto/pagination-query.dto';
import { IsBoolean, IsEnum, IsOptional } from 'class-validator';
import { Transform } from 'class-transformer';
import { CustomizationType } from '../domain/enums/customization-type.enum';
export class FindAllPizzaCustomizationsDto extends PaginationQueryDto {
  @ApiPropertyOptional({
    example: true,
    description: 'Filter by active status',
  })
  @IsOptional()
  @Transform(({ value }) => value === 'true')
  @IsBoolean()
  isActive?: boolean;
  @ApiPropertyOptional({
    enum: CustomizationType,
    example: CustomizationType.INGREDIENT,
    description: 'Filter by customization type',
  })
  @IsOptional()
  @IsEnum(CustomizationType)
  type?: CustomizationType;
}

================
File: backend/src/pizza-customizations/dto/update-pizza-customization.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { PartialType } from '@nestjs/swagger';
import { CreatePizzaCustomizationDto } from './create-pizza-customization.dto';
import { IsBoolean, IsOptional } from 'class-validator';
export class UpdatePizzaCustomizationDto extends PartialType(
  CreatePizzaCustomizationDto,
) {
  @ApiPropertyOptional({ example: true })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

================
File: backend/src/pizza-customizations/infrastructure/persistence/pizza-customization.repository.ts
================
import { PizzaCustomization } from '../../domain/pizza-customization';
import { Paginated } from '../../../common/types/paginated.type';
export abstract class PizzaCustomizationRepository {
  abstract create(
    pizzaCustomization: PizzaCustomization,
  ): Promise<PizzaCustomization>;
  abstract findAll(options: {
    page: number;
    limit: number;
    isActive?: boolean;
    type?: string;
  }): Promise<Paginated<PizzaCustomization>>;
  abstract findById(id: string): Promise<PizzaCustomization | null>;
  abstract findByIds(ids: string[]): Promise<PizzaCustomization[]>;
  abstract update(
    id: string,
    pizzaCustomization: Partial<PizzaCustomization>,
  ): Promise<PizzaCustomization | null>;
  abstract softDelete(id: string): Promise<void>;
}

================
File: backend/src/pizza-customizations/infrastructure/persistence/relational/entities/pizza-customization.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  ManyToMany,
  OneToMany,
  PrimaryColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
import { CustomizationType } from '../../../../domain/enums/customization-type.enum';
import { SelectedPizzaCustomizationEntity } from '../../../../../selected-pizza-customizations/infrastructure/persistence/relational/entities/selected-pizza-customization.entity';
@Entity({
  name: 'pizza_customization',
})
export class PizzaCustomizationEntity extends EntityRelationalHelper {
  @PrimaryColumn({ type: 'varchar', length: 50 })
  id: string;
  @Column()
  name: string;
  @Column({
    type: 'enum',
    enum: CustomizationType,
    default: CustomizationType.INGREDIENT,
  })
  type: CustomizationType;
  @Column({ type: 'text', nullable: true })
  ingredients: string | null;
  @Column({ name: 'topping_value', type: 'int', default: 1 })
  toppingValue: number;
  @Column({ name: 'is_active', default: true })
  isActive: boolean;
  @Column({ name: 'sort_order', type: 'int', default: 0 })
  sortOrder: number;
  @ManyToMany(() => ProductEntity, (product) => product.pizzaCustomizations)
  products: ProductEntity[];
  @OneToMany(
    () => SelectedPizzaCustomizationEntity,
    (selected) => selected.pizzaCustomization,
  )
  selectedPizzaCustomizations: SelectedPizzaCustomizationEntity[];
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/pizza-customizations/infrastructure/persistence/relational/mappers/pizza-customization.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { PizzaCustomization } from '../../../../domain/pizza-customization';
import { PizzaCustomizationEntity } from '../entities/pizza-customization.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class PizzaCustomizationMapper extends BaseMapper<
  PizzaCustomizationEntity,
  PizzaCustomization
> {
  override toDomain(
    entity: PizzaCustomizationEntity,
  ): PizzaCustomization | null {
    if (!entity) return null;
    const domain = new PizzaCustomization();
    domain.id = entity.id;
    domain.name = entity.name;
    domain.type = entity.type;
    domain.ingredients = entity.ingredients;
    domain.toppingValue = entity.toppingValue;
    domain.isActive = entity.isActive;
    domain.sortOrder = entity.sortOrder;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    if (entity.products) {
      domain.productIds = entity.products.map((product) => product.id);
      domain.products = entity.products.map((product) => ({
        id: product.id,
        name: product.name,
      }));
    }
    return domain;
  }
  override toEntity(
    domain: PizzaCustomization,
  ): PizzaCustomizationEntity | null {
    if (!domain) return null;
    const entity = new PizzaCustomizationEntity();
    if (domain.id) entity.id = domain.id;
    entity.name = domain.name;
    entity.type = domain.type;
    entity.ingredients = domain.ingredients || null;
    entity.toppingValue = domain.toppingValue;
    entity.isActive = domain.isActive;
    entity.sortOrder = domain.sortOrder;
    return entity;
  }
}

================
File: backend/src/pizza-customizations/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PizzaCustomizationEntity } from './entities/pizza-customization.entity';
import { PizzaCustomizationRepository } from '../pizza-customization.repository';
import { PizzaCustomizationRelationalRepository } from './repositories/pizza-customization.repository';
import { PizzaCustomizationMapper } from './mappers/pizza-customization.mapper';
@Module({
  imports: [TypeOrmModule.forFeature([PizzaCustomizationEntity])],
  providers: [
    {
      provide: PizzaCustomizationRepository,
      useClass: PizzaCustomizationRelationalRepository,
    },
    PizzaCustomizationMapper,
  ],
  exports: [PizzaCustomizationRepository, PizzaCustomizationMapper],
})
export class RelationalPizzaCustomizationPersistenceModule {}

================
File: backend/src/pizza-customizations/infrastructure/persistence/relational/repositories/pizza-customization.repository.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';
import { PizzaCustomizationEntity } from '../entities/pizza-customization.entity';
import { PizzaCustomizationMapper } from '../mappers/pizza-customization.mapper';
import { PizzaCustomization } from '../../../../domain/pizza-customization';
import { PizzaCustomizationRepository } from '../../pizza-customization.repository';
import { Paginated } from '../../../../../common/types/paginated.type';
@Injectable()
export class PizzaCustomizationRelationalRepository
  implements PizzaCustomizationRepository
{
  constructor(
    @InjectRepository(PizzaCustomizationEntity)
    private readonly pizzaCustomizationRepository: Repository<PizzaCustomizationEntity>,
    private readonly pizzaCustomizationMapper: PizzaCustomizationMapper,
  ) {}
  async create(
    pizzaCustomization: PizzaCustomization,
  ): Promise<PizzaCustomization> {
    const persistenceModel =
      this.pizzaCustomizationMapper.toEntity(pizzaCustomization);
    if (!persistenceModel) {
      throw new Error('Failed to map pizza customization to entity');
    }
    const newEntity = await this.pizzaCustomizationRepository.save(
      this.pizzaCustomizationRepository.create(persistenceModel),
    );
    const domainResult = this.pizzaCustomizationMapper.toDomain(newEntity);
    if (!domainResult) {
      throw new Error('Failed to map entity to domain');
    }
    return domainResult;
  }
  async findAll(options: {
    page: number;
    limit: number;
    isActive?: boolean;
    type?: string;
  }): Promise<Paginated<PizzaCustomization>> {
    const { page, limit, isActive, type } = options;
    const where: any = {};
    if (isActive !== undefined) {
      where.isActive = isActive;
    }
    if (type) {
      where.type = type;
    }
    const [entities, total] =
      await this.pizzaCustomizationRepository.findAndCount({
        where,
        relations: ['products'],
        order: {
          sortOrder: 'ASC',
          name: 'ASC',
        },
        skip: (page - 1) * limit,
        take: limit,
      });
    const items = entities
      .map((entity) => this.pizzaCustomizationMapper.toDomain(entity))
      .filter((item): item is PizzaCustomization => item !== null);
    return new Paginated(items, total, page, limit);
  }
  async findById(id: string): Promise<PizzaCustomization | null> {
    const entity = await this.pizzaCustomizationRepository.findOne({
      where: { id },
      relations: ['products'],
    });
    if (!entity) {
      return null;
    }
    return this.pizzaCustomizationMapper.toDomain(entity);
  }
  async findByIds(ids: string[]): Promise<PizzaCustomization[]> {
    const entities = await this.pizzaCustomizationRepository.find({
      where: { id: In(ids) },
      relations: ['products'],
    });
    return entities
      .map((entity) => this.pizzaCustomizationMapper.toDomain(entity))
      .filter((item): item is PizzaCustomization => item !== null);
  }
  async update(
    id: string,
    pizzaCustomization: Partial<PizzaCustomization>,
  ): Promise<PizzaCustomization | null> {
    const result = await this.pizzaCustomizationRepository.update(
      id,
      pizzaCustomization,
    );
    if (result.affected === 0) {
      return null;
    }
    return this.findById(id);
  }
  async softDelete(id: string): Promise<void> {
    const result = await this.pizzaCustomizationRepository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(
        `Pizza customization with ID ${id} not found`,
      );
    }
  }
}

================
File: backend/src/pizza-customizations/pizza-customizations.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { PizzaCustomizationsService } from './pizza-customizations.service';
import { CreatePizzaCustomizationDto } from './dto/create-pizza-customization.dto';
import { UpdatePizzaCustomizationDto } from './dto/update-pizza-customization.dto';
import { FindAllPizzaCustomizationsDto } from './dto/find-all-pizza-customizations.dto';
import { PizzaCustomization } from './domain/pizza-customization';
import { Paginated } from '../common/types/paginated.type';
@ApiTags('pizza-customizations')
@Controller({
  path: 'pizza-customizations',
  version: '1',
})
export class PizzaCustomizationsController {
  constructor(
    private readonly pizzaCustomizationsService: PizzaCustomizationsService,
  ) {}
  @Post()
  @ApiOperation({ summary: 'Create a new pizza customization' })
  @ApiResponse({
    status: 201,
    description: 'The pizza customization has been successfully created.',
  })
  create(
    @Body() createPizzaCustomizationDto: CreatePizzaCustomizationDto,
  ): Promise<PizzaCustomization> {
    return this.pizzaCustomizationsService.create(createPizzaCustomizationDto);
  }
  @Get()
  @ApiOperation({ summary: 'Get all pizza customizations' })
  @ApiResponse({
    status: 200,
    description: 'Return all pizza customizations.',
  })
  findAll(
    @Query() query: FindAllPizzaCustomizationsDto,
  ): Promise<Paginated<PizzaCustomization>> {
    return this.pizzaCustomizationsService.findAll(query);
  }
  @Get('active')
  @ApiOperation({ summary: 'Get all active pizza customizations' })
  @ApiResponse({
    status: 200,
    description: 'Return all active pizza customizations.',
  })
  findAllActive(): Promise<PizzaCustomization[]> {
    return this.pizzaCustomizationsService.findAllActive();
  }
  @Get(':id')
  @ApiOperation({ summary: 'Get a pizza customization by id' })
  @ApiResponse({
    status: 200,
    description: 'Return the pizza customization.',
  })
  @ApiResponse({
    status: 404,
    description: 'Pizza customization not found.',
  })
  findOne(@Param('id') id: string): Promise<PizzaCustomization> {
    return this.pizzaCustomizationsService.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({ summary: 'Update a pizza customization' })
  @ApiResponse({
    status: 200,
    description: 'The pizza customization has been successfully updated.',
  })
  @ApiResponse({
    status: 404,
    description: 'Pizza customization not found.',
  })
  update(
    @Param('id') id: string,
    @Body() updatePizzaCustomizationDto: UpdatePizzaCustomizationDto,
  ): Promise<PizzaCustomization> {
    return this.pizzaCustomizationsService.update(
      id,
      updatePizzaCustomizationDto,
    );
  }
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete a pizza customization' })
  @ApiResponse({
    status: 204,
    description: 'The pizza customization has been successfully deleted.',
  })
  remove(@Param('id') id: string): Promise<void> {
    return this.pizzaCustomizationsService.remove(id);
  }
}

================
File: backend/src/pizza-customizations/pizza-customizations.module.ts
================
import { Module } from '@nestjs/common';
import { PizzaCustomizationsService } from './pizza-customizations.service';
import { PizzaCustomizationsController } from './pizza-customizations.controller';
import { RelationalPizzaCustomizationPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { CustomIdService } from '../common/services/custom-id.service';
@Module({
  imports: [RelationalPizzaCustomizationPersistenceModule],
  controllers: [PizzaCustomizationsController],
  providers: [PizzaCustomizationsService, CustomIdService],
  exports: [
    PizzaCustomizationsService,
    RelationalPizzaCustomizationPersistenceModule,
  ],
})
export class PizzaCustomizationsModule {}

================
File: backend/src/pizza-customizations/pizza-customizations.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { PizzaCustomization } from './domain/pizza-customization';
import { PizzaCustomizationRepository } from './infrastructure/persistence/pizza-customization.repository';
import { CreatePizzaCustomizationDto } from './dto/create-pizza-customization.dto';
import { UpdatePizzaCustomizationDto } from './dto/update-pizza-customization.dto';
import { FindAllPizzaCustomizationsDto } from './dto/find-all-pizza-customizations.dto';
import { Paginated } from '../common/types/paginated.type';
import {
  CustomIdService,
  EntityPrefix,
} from '../common/services/custom-id.service';
@Injectable()
export class PizzaCustomizationsService {
  constructor(
    private readonly pizzaCustomizationRepository: PizzaCustomizationRepository,
    private readonly customIdService: CustomIdService,
  ) {}
  async create(
    createPizzaCustomizationDto: CreatePizzaCustomizationDto,
  ): Promise<PizzaCustomization> {
    const pizzaCustomization = new PizzaCustomization();
    if (createPizzaCustomizationDto.id) {
      pizzaCustomization.id = createPizzaCustomizationDto.id;
    } else {
      pizzaCustomization.id = await this.customIdService.generateId(
        EntityPrefix.PIZZA_CUSTOMIZATION,
        'pizza_customization',
      );
    }
    pizzaCustomization.name = createPizzaCustomizationDto.name;
    pizzaCustomization.type = createPizzaCustomizationDto.type;
    pizzaCustomization.ingredients =
      createPizzaCustomizationDto.ingredients || null;
    pizzaCustomization.toppingValue =
      createPizzaCustomizationDto.toppingValue ?? 1;
    pizzaCustomization.sortOrder = createPizzaCustomizationDto.sortOrder ?? 0;
    pizzaCustomization.isActive = true;
    return this.pizzaCustomizationRepository.create(pizzaCustomization);
  }
  async findAll(
    query: FindAllPizzaCustomizationsDto,
  ): Promise<Paginated<PizzaCustomization>> {
    const { page = 1, limit = 10, ...filters } = query;
    return this.pizzaCustomizationRepository.findAll({
      page,
      limit,
      ...filters,
    });
  }
  async findOne(id: string): Promise<PizzaCustomization> {
    const pizzaCustomization =
      await this.pizzaCustomizationRepository.findById(id);
    if (!pizzaCustomization) {
      throw new NotFoundException(
        `Pizza customization with ID ${id} not found`,
      );
    }
    return pizzaCustomization;
  }
  async update(
    id: string,
    updatePizzaCustomizationDto: UpdatePizzaCustomizationDto,
  ): Promise<PizzaCustomization> {
    const updated = await this.pizzaCustomizationRepository.update(
      id,
      updatePizzaCustomizationDto,
    );
    if (!updated) {
      throw new NotFoundException(
        `Pizza customization with ID ${id} not found`,
      );
    }
    return updated;
  }
  async remove(id: string): Promise<void> {
    await this.pizzaCustomizationRepository.softDelete(id);
  }
  async findByIds(ids: string[]): Promise<PizzaCustomization[]> {
    return this.pizzaCustomizationRepository.findByIds(ids);
  }
  async findAllActive(): Promise<PizzaCustomization[]> {
    const result = await this.pizzaCustomizationRepository.findAll({
      page: 1,
      limit: 1000,
      isActive: true,
    });
    return result.items;
  }
}

================
File: backend/src/preparation-screens/domain/preparation-screen.ts
================
import { Expose } from 'class-transformer';
import { Product } from '../../products/domain/product';
import { User } from '../../users/domain/user';
export class PreparationScreen {
  @Expose()
  id: string;
  @Expose()
  name: string;
  @Expose()
  description: string | null;
  @Expose()
  isActive: boolean;
  @Expose()
  products: Product[] | null;
  @Expose()
  users: User[] | null;
  @Expose()
  createdAt: Date;
  @Expose()
  updatedAt: Date;
  @Expose()
  deletedAt: Date | null;
}

================
File: backend/src/preparation-screens/dto/assign-users.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsBoolean, IsOptional, IsUUID } from 'class-validator';
export class UserAssignmentDto {
  @ApiProperty({
    type: String,
    example: 'USR-123',
    description: 'ID del usuario',
  })
  @IsUUID()
  userId: string;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Si esta pantalla es la predeterminada para el usuario',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;
}
export class AssignUsersDto {
  @ApiProperty({
    type: [UserAssignmentDto],
    description: 'Lista de usuarios a asignar con sus configuraciones',
  })
  @IsArray()
  users: UserAssignmentDto[];
}

================
File: backend/src/preparation-screens/dto/associate-products.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsString } from 'class-validator';
import { Type } from 'class-transformer';
export class AssociateProductsDto {
  @ApiProperty({
    description:
      'IDs de los productos a asociar con la pantalla de preparación',
    example: ['PROD-1'],
    type: [String],
  })
  @IsArray()
  @IsString({ each: true })
  @Type(() => String)
  productIds: string[];
}

================
File: backend/src/preparation-screens/dto/create-preparation-screen.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsArray,
  IsBoolean,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsUUID,
  MaxLength,
} from 'class-validator';
export class CreatePreparationScreenDto {
  @ApiProperty({
    type: String,
    example: 'Cocina Principal',
    description: 'Nombre de la pantalla de preparación',
  })
  @IsNotEmpty()
  @IsString()
  @MaxLength(100)
  name: string;
  @ApiProperty({
    type: String,
    example: 'Pantalla para preparación de platos principales',
    description: 'Descripción de la pantalla de preparación (opcional)',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  description?: string | null;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si la pantalla está activa',
    required: false,
    default: true,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: [String],
    example: ['PROD-1', 'PROD-2'],
    description: 'IDs de los productos asociados a esta pantalla',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  productIds?: string[];
  @ApiProperty({
    type: String,
    example: 'b88a9f9a-8e8e-4b7d-8c5e-5d5f1f2a3b4c',
    description: 'ID del usuario con rol de cocina asignado a esta pantalla',
    required: true,
  })
  @IsNotEmpty({ message: 'El usuario es requerido' })
  @IsUUID('4', { message: 'El ID del usuario debe ser un UUID válido' })
  userId: string;
}

================
File: backend/src/preparation-screens/dto/find-all-preparation-screens.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsNumber } from 'class-validator';
import { Transform } from 'class-transformer';
export class FindAllPreparationScreensDto {
  @ApiProperty({
    type: Number,
    example: 1,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  page?: number = 1;
  @ApiProperty({
    type: Number,
    example: 10,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  limit?: number = 10;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
}

================
File: backend/src/preparation-screens/dto/update-preparation-screen.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsArray,
  IsBoolean,
  IsOptional,
  IsString,
  IsUUID,
  MaxLength,
} from 'class-validator';
export class UpdatePreparationScreenDto {
  @ApiProperty({
    type: String,
    example: 'Cocina Principal',
    description: 'Nombre de la pantalla de preparación',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  name?: string;
  @ApiProperty({
    type: String,
    example: 'Pantalla para preparación de platos principales',
    description: 'Descripción de la pantalla de preparación (opcional)',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  description?: string | null;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si la pantalla está activa',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: [String],
    example: ['PROD-1', 'PROD-2'],
    description:
      'IDs de los productos asociados a esta pantalla. Reemplaza la lista existente.',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  productIds?: string[];
  @ApiProperty({
    type: String,
    example: 'b88a9f9a-8e8e-4b7d-8c5e-5d5f1f2a3b4c',
    description: 'ID del usuario con rol de cocina asignado a esta pantalla',
    required: false,
  })
  @IsOptional()
  @IsUUID('4', { message: 'El ID del usuario debe ser un UUID válido' })
  userId?: string;
}

================
File: backend/src/preparation-screens/infrastructure/persistence/preparation-screen.repository.ts
================
import { PreparationScreen } from '../../domain/preparation-screen';
import { Paginated } from '../../../common/types/paginated.type';
import { UserAssignmentDto } from '../../dto/assign-users.dto';
export interface PreparationScreenRepository {
  create(data: PreparationScreen): Promise<PreparationScreen>;
  findOne(id: string): Promise<PreparationScreen>;
  findAll(options?: {
    page?: number;
    limit?: number;
    isActive?: boolean;
  }): Promise<Paginated<PreparationScreen>>;
  update(id: string, data: PreparationScreen): Promise<PreparationScreen>;
  softDelete(id: string): Promise<void>;
  findByIds(ids: string[]): Promise<PreparationScreen[]>;
  getUsersByScreenId(screenId: string): Promise<any[]>;
  getUsers(screenId: string): Promise<any[]>;
  assignUsers(
    screenId: string,
    userAssignments: UserAssignmentDto[],
  ): Promise<void>;
  removeUsers(screenId: string, userIds: string[]): Promise<void>;
}

================
File: backend/src/preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  OneToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
@Entity({ name: 'preparation_screens' })
export class PreparationScreenEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ type: 'varchar', length: 100 })
  name: string;
  @Column({ type: 'varchar', length: 255, nullable: true })
  description: string | null;
  @Column({ type: 'boolean', default: true })
  isActive: boolean;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
  @OneToMany(() => ProductEntity, (product) => product.preparationScreen)
  products: ProductEntity[];
  @OneToMany(() => UserEntity, (user) => user.preparationScreen)
  users?: UserEntity[];
}

================
File: backend/src/preparation-screens/infrastructure/persistence/relational/mappers/preparation-screen.mapper.ts
================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { PreparationScreen } from '../../../../domain/preparation-screen';
import { PreparationScreenEntity } from '../entities/preparation-screen.entity';
import { ProductMapper } from '../../../../../products/infrastructure/persistence/relational/mappers/product.mapper';
import { UserMapper } from '../../../../../users/infrastructure/persistence/relational/mappers/user.mapper';
import {
  BaseMapper,
  mapArray,
} from '../../../../../common/mappers/base.mapper';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
@Injectable()
export class PreparationScreenMapper extends BaseMapper<
  PreparationScreenEntity,
  PreparationScreen
> {
  constructor(
    @Inject(forwardRef(() => ProductMapper))
    private readonly productMapper: ProductMapper,
    @Inject(forwardRef(() => UserMapper))
    private readonly userMapper: UserMapper,
  ) {
    super();
  }
  override toDomain(entity: PreparationScreenEntity): PreparationScreen | null {
    if (!entity) return null;
    const domain = new PreparationScreen();
    domain.id = entity.id;
    domain.name = entity.name;
    domain.description = entity.description;
    domain.isActive = entity.isActive;
    domain.products = mapArray(entity.products, (p) =>
      this.productMapper.toDomain(p),
    );
    domain.users = mapArray(entity.users, (u) => this.userMapper.toDomain(u));
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: PreparationScreen): PreparationScreenEntity | null {
    if (!domain) return null;
    const entity = new PreparationScreenEntity();
    if (domain.id) entity.id = domain.id;
    entity.name = domain.name;
    entity.description = domain.description;
    entity.isActive = domain.isActive;
    if (domain.products) {
      entity.products = mapArray(
        domain.products,
        (p) => this.productMapper.toEntity(p) as ProductEntity,
      );
    }
    return entity;
  }
}

================
File: backend/src/preparation-screens/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PreparationScreenEntity } from './entities/preparation-screen.entity';
import { PreparationScreensRelationalRepository } from './repositories/preparation-screen.repository';
import { PREPARATION_SCREEN_REPOSITORY } from '../../../../common/tokens';
import { PreparationScreenMapper } from './mappers/preparation-screen.mapper';
import { RelationalProductPersistenceModule } from '../../../../products/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalUserPersistenceModule } from '../../../../users/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([PreparationScreenEntity]),
    forwardRef(() => RelationalProductPersistenceModule),
    forwardRef(() => RelationalUserPersistenceModule),
  ],
  providers: [
    {
      provide: PREPARATION_SCREEN_REPOSITORY,
      useClass: PreparationScreensRelationalRepository,
    },
    PreparationScreenMapper,
  ],
  exports: [PREPARATION_SCREEN_REPOSITORY, PreparationScreenMapper],
})
export class RelationalPreparationScreenPersistenceModule {}

================
File: backend/src/preparation-screens/infrastructure/persistence/relational/repositories/preparation-screen.repository.ts
================
import {
  Injectable,
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';
import { PreparationScreenEntity } from '../entities/preparation-screen.entity';
import { PreparationScreenRepository } from '../../preparation-screen.repository';
import { PreparationScreen } from '../../../../domain/preparation-screen';
import { PreparationScreenMapper } from '../mappers/preparation-screen.mapper';
import { Paginated } from '../../../../../common/types/paginated.type';
import { UserAssignmentDto } from '../../../../dto/assign-users.dto';
@Injectable()
export class PreparationScreensRelationalRepository
  implements PreparationScreenRepository
{
  constructor(
    @InjectRepository(PreparationScreenEntity)
    private readonly preparationScreenRepository: Repository<PreparationScreenEntity>,
    private readonly preparationScreenMapper: PreparationScreenMapper,
  ) {}
  async create(data: PreparationScreen): Promise<PreparationScreen> {
    const entity = this.preparationScreenMapper.toEntity(data);
    if (!entity) {
      throw new InternalServerErrorException(
        'Error creating preparation screen entity',
      );
    }
    const savedEntity = await this.preparationScreenRepository.save(entity);
    const domainResult = this.preparationScreenMapper.toDomain(savedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping saved preparation screen entity to domain',
      );
    }
    return domainResult;
  }
  async findOne(id: string): Promise<PreparationScreen> {
    const entity = await this.preparationScreenRepository.findOne({
      where: { id },
      relations: ['products', 'users', 'users.role'],
    });
    if (!entity) {
      throw new NotFoundException(`Preparation screen with ID ${id} not found`);
    }
    const domainResult = this.preparationScreenMapper.toDomain(entity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping preparation screen entity to domain',
      );
    }
    return domainResult;
  }
  async findAll(options?: {
    page?: number;
    limit?: number;
    isActive?: boolean;
  }): Promise<Paginated<PreparationScreen>> {
    const page = options?.page || 1;
    const limit = options?.limit || 10;
    const skip = (page - 1) * limit;
    const queryBuilder = this.preparationScreenRepository
      .createQueryBuilder('preparationScreen')
      .leftJoinAndSelect('preparationScreen.products', 'products')
      .leftJoinAndSelect('preparationScreen.users', 'users')
      .leftJoinAndSelect('users.role', 'role')
      .skip(skip)
      .take(limit)
      .orderBy('preparationScreen.name', 'ASC');
    if (options?.isActive !== undefined) {
      queryBuilder.andWhere('preparationScreen.isActive = :isActive', {
        isActive: options.isActive,
      });
    }
    const [entities, count] = await queryBuilder.getManyAndCount();
    const domainResults = entities
      .map((entity) => this.preparationScreenMapper.toDomain(entity))
      .filter((item): item is PreparationScreen => item !== null);
    return new Paginated(domainResults, count, page, limit);
  }
  async update(
    id: string,
    data: PreparationScreen,
  ): Promise<PreparationScreen> {
    const entity = this.preparationScreenMapper.toEntity(data);
    if (!entity) {
      throw new InternalServerErrorException(
        'Error creating preparation screen entity for update',
      );
    }
    await this.preparationScreenRepository.update(id, entity);
    const updatedEntity = await this.preparationScreenRepository.findOne({
      where: { id },
      relations: ['products'],
    });
    if (!updatedEntity) {
      throw new NotFoundException(`Preparation screen with ID ${id} not found`);
    }
    const domainResult = this.preparationScreenMapper.toDomain(updatedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping updated preparation screen entity to domain',
      );
    }
    return domainResult;
  }
  async softDelete(id: string): Promise<void> {
    const result = await this.preparationScreenRepository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(`Preparation screen with ID ${id} not found`);
    }
  }
  async findByIds(ids: string[]): Promise<PreparationScreen[]> {
    if (!ids || ids.length === 0) {
      return [];
    }
    const entities = await this.preparationScreenRepository.find({
      where: { id: In(ids) },
      relations: ['products'],
    });
    const domainResults = entities
      .map((entity) => this.preparationScreenMapper.toDomain(entity))
      .filter((item): item is PreparationScreen => item !== null);
    return domainResults;
  }
  async getUsersByScreenId(screenId: string): Promise<any[]> {
    const screen = await this.preparationScreenRepository.findOne({
      where: { id: screenId },
      relations: ['users', 'users.role'],
    });
    if (!screen) return [];
    return (
      screen.users?.map((user) => ({
        userId: user.id,
        username: user.username,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        role: user.role,
      })) || []
    );
  }
  async assignUsers(
    screenId: string,
    userAssignments: UserAssignmentDto[],
  ): Promise<void> {
    throw new Error('Use UserRepository.updatePreparationScreen instead');
  }
  async getUsers(screenId: string): Promise<any[]> {
    return this.getUsersByScreenId(screenId);
  }
  async removeUsers(screenId: string, userIds: string[]): Promise<void> {
    throw new Error('Use UserRepository.updatePreparationScreen instead');
  }
}

================
File: backend/src/preparation-screens/preparation-screens.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Query,
  HttpStatus,
  HttpCode,
} from '@nestjs/common';
import { PreparationScreensService } from './preparation-screens.service';
import { CreatePreparationScreenDto } from './dto/create-preparation-screen.dto';
import { UpdatePreparationScreenDto } from './dto/update-preparation-screen.dto';
import { FindAllPreparationScreensDto } from './dto/find-all-preparation-screens.dto';
import { AssociateProductsDto } from './dto/associate-products.dto';
import { AssignUsersDto } from './dto/assign-users.dto';
import { ApiBearerAuth, ApiOperation, ApiTags } from '@nestjs/swagger';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
@ApiTags('Pantallas de Preparación')
@Controller({
  path: 'preparation-screens',
  version: '1',
})
export class PreparationScreensController {
  constructor(
    private readonly preparationScreensService: PreparationScreensService,
  ) {}
  @Post()
  @ApiOperation({
    summary: 'Crear una nueva pantalla de preparación',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createPreparationScreenDto: CreatePreparationScreenDto) {
    return this.preparationScreensService.create(createPreparationScreenDto);
  }
  @Get()
  @ApiOperation({
    summary: 'Obtener todas las pantallas de preparación',
  })
  @HttpCode(HttpStatus.OK)
  findAll(@Query() findAllPreparationScreensDto: FindAllPreparationScreensDto) {
    return this.preparationScreensService.findAll(findAllPreparationScreensDto);
  }
  @Get(':id')
  @ApiOperation({
    summary: 'Obtener una pantalla de preparación por ID',
  })
  @HttpCode(HttpStatus.OK)
  findOne(@Param('id') id: string) {
    return this.preparationScreensService.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({
    summary: 'Actualizar una pantalla de preparación',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  update(
    @Param('id') id: string,
    @Body() updatePreparationScreenDto: UpdatePreparationScreenDto,
  ) {
    return this.preparationScreensService.update(
      id,
      updatePreparationScreenDto,
    );
  }
  @Delete(':id')
  @ApiOperation({
    summary: 'Eliminar una pantalla de preparación',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id') id: string) {
    return this.preparationScreensService.remove(id);
  }
  @Get(':id/products')
  @ApiOperation({
    summary: 'Obtener productos asociados a una pantalla de preparación',
  })
  @HttpCode(HttpStatus.OK)
  async getProducts(@Param('id') id: string) {
    return this.preparationScreensService.getProducts(id);
  }
  @Get(':id/menu-with-associations')
  @ApiOperation({
    summary:
      'Obtener menú completo con información de asociaciones para una pantalla específica',
  })
  @HttpCode(HttpStatus.OK)
  async getMenuWithAssociations(@Param('id') id: string) {
    return this.preparationScreensService.getMenuWithAssociations(id);
  }
  @Post(':id/products')
  @ApiOperation({
    summary: 'Asociar productos a una pantalla de preparación',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  async associateProducts(
    @Param('id') id: string,
    @Body() associateProductsDto: AssociateProductsDto,
  ) {
    return this.preparationScreensService.associateProducts(
      id,
      associateProductsDto.productIds,
    );
  }
  @Get(':id/users')
  @ApiOperation({
    summary: 'Obtener usuarios asignados a una pantalla de preparación',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  async getUsers(@Param('id') id: string) {
    return this.preparationScreensService.getUsers(id);
  }
  @Post(':id/users')
  @ApiOperation({
    summary: 'Asignar usuarios a una pantalla de preparación',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  async assignUsers(
    @Param('id') id: string,
    @Body() assignUsersDto: AssignUsersDto,
  ) {
    return this.preparationScreensService.assignUsers(id, assignUsersDto.users);
  }
}

================
File: backend/src/preparation-screens/preparation-screens.module.ts
================
import { Module } from '@nestjs/common';
import { PreparationScreensController } from './preparation-screens.controller';
import { PreparationScreensService } from './preparation-screens.service';
import { RelationalPreparationScreenPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { RelationalProductPersistenceModule } from '../products/infrastructure/persistence/relational/relational-persistence.module';
import { CategoriesRelationalPersistenceModule } from '../categories/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalSubcategoryPersistenceModule } from '../subcategories/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalUserPersistenceModule } from '../users/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    RelationalPreparationScreenPersistenceModule,
    RelationalProductPersistenceModule,
    CategoriesRelationalPersistenceModule,
    RelationalSubcategoryPersistenceModule,
    RelationalUserPersistenceModule,
  ],
  controllers: [PreparationScreensController],
  providers: [PreparationScreensService],
  exports: [
    PreparationScreensService,
    RelationalPreparationScreenPersistenceModule,
  ],
})
export class PreparationScreensModule {}

================
File: backend/src/preparation-screens/preparation-screens.service.ts
================
import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { PreparationScreen } from './domain/preparation-screen';
import { CreatePreparationScreenDto } from './dto/create-preparation-screen.dto';
import { FindAllPreparationScreensDto } from './dto/find-all-preparation-screens.dto';
import { UpdatePreparationScreenDto } from './dto/update-preparation-screen.dto';
import { PreparationScreenRepository } from './infrastructure/persistence/preparation-screen.repository';
import {
  PREPARATION_SCREEN_REPOSITORY,
  PRODUCT_REPOSITORY,
  CATEGORY_REPOSITORY,
  SUBCATEGORY_REPOSITORY,
  USER_REPOSITORY,
} from '../common/tokens';
import { Paginated } from '../common/types/paginated.type';
import { ProductRepository } from '../products/infrastructure/persistence/product.repository';
import { CategoryRepository } from '../categories/infrastructure/persistence/category.repository';
import { SubcategoryRepository } from '../subcategories/infrastructure/persistence/subcategory.repository';
import { UserRepository } from '../users/infrastructure/persistence/user.repository';
import { UserAssignmentDto } from './dto/assign-users.dto';
@Injectable()
export class PreparationScreensService {
  constructor(
    @Inject(PREPARATION_SCREEN_REPOSITORY)
    private readonly preparationScreenRepository: PreparationScreenRepository,
    @Inject(PRODUCT_REPOSITORY)
    private readonly productRepository: ProductRepository,
    @Inject(CATEGORY_REPOSITORY)
    private readonly categoryRepository: CategoryRepository,
    @Inject(SUBCATEGORY_REPOSITORY)
    private readonly subcategoryRepository: SubcategoryRepository,
    @Inject(USER_REPOSITORY)
    private readonly userRepository: UserRepository,
  ) {}
  async create(
    createDto: CreatePreparationScreenDto,
  ): Promise<PreparationScreen> {
    const user = await this.userRepository.findById(createDto.userId);
    if (!user) {
      throw new NotFoundException(`User with ID ${createDto.userId} not found`);
    }
    if (!user.role || user.role.id !== 5) {
      throw new NotFoundException('User must have kitchen role');
    }
    if (user.preparationScreen) {
      throw new NotFoundException(
        `User is already assigned to preparation screen: ${user.preparationScreen.name}`,
      );
    }
    const preparationScreen = new PreparationScreen();
    preparationScreen.name = createDto.name;
    preparationScreen.description = createDto.description || null;
    preparationScreen.isActive = createDto.isActive ?? true;
    const createdScreen =
      await this.preparationScreenRepository.create(preparationScreen);
    await this.userRepository.updatePreparationScreen(
      createDto.userId,
      createdScreen.id,
    );
    return this.preparationScreenRepository.findOne(createdScreen.id);
  }
  async findAll(
    findAllPreparationScreensDto: FindAllPreparationScreensDto,
  ): Promise<Paginated<PreparationScreen>> {
    return this.preparationScreenRepository.findAll({
      page: findAllPreparationScreensDto.page,
      limit: findAllPreparationScreensDto.limit,
      isActive: findAllPreparationScreensDto.isActive,
    });
  }
  async findOne(id: string): Promise<PreparationScreen> {
    const preparationScreen =
      await this.preparationScreenRepository.findOne(id);
    if (!preparationScreen) {
      throw new NotFoundException(`Preparation screen with ID ${id} not found`);
    }
    return preparationScreen;
  }
  async update(
    id: string,
    updateDto: UpdatePreparationScreenDto,
  ): Promise<PreparationScreen> {
    const existingScreen = await this.preparationScreenRepository.findOne(id);
    if (!existingScreen) {
      throw new NotFoundException(`Preparation screen with ID ${id} not found`);
    }
    if (updateDto.userId !== undefined) {
      if (updateDto.userId) {
        const user = await this.userRepository.findById(updateDto.userId);
        if (!user) {
          throw new NotFoundException(
            `User with ID ${updateDto.userId} not found`,
          );
        }
        if (!user.role || user.role.id !== 5) {
          throw new NotFoundException('User must have kitchen role');
        }
      }
    }
    const preparationScreen = new PreparationScreen();
    preparationScreen.id = id;
    preparationScreen.name = updateDto.name ?? existingScreen.name;
    preparationScreen.description =
      updateDto.description ?? existingScreen.description;
    preparationScreen.isActive = updateDto.isActive ?? existingScreen.isActive;
    await this.preparationScreenRepository.update(id, preparationScreen);
    if (updateDto.userId !== undefined) {
      const screenWithUsers =
        await this.preparationScreenRepository.findOne(id);
      if (screenWithUsers.users && screenWithUsers.users.length > 0) {
        for (const user of screenWithUsers.users) {
          await this.userRepository.updatePreparationScreen(user.id, null);
        }
      }
      if (updateDto.userId) {
        const user = await this.userRepository.findById(updateDto.userId);
        if (user && user.preparationScreen) {
          throw new NotFoundException(
            `User is already assigned to preparation screen: ${user.preparationScreen.name}`,
          );
        }
        await this.userRepository.updatePreparationScreen(updateDto.userId, id);
      }
    }
    if (updateDto.productIds !== undefined) {
      const currentProducts = existingScreen.products || [];
      for (const product of currentProducts) {
        await this.productRepository.updatePreparationScreen(product.id, null);
      }
      if (updateDto.productIds.length > 0) {
        for (const productId of updateDto.productIds) {
          await this.productRepository.updatePreparationScreen(productId, id);
        }
      }
      return this.preparationScreenRepository.findOne(id);
    }
    return this.preparationScreenRepository.findOne(id);
  }
  async remove(id: string): Promise<void> {
    return this.preparationScreenRepository.softDelete(id);
  }
  async getProducts(id: string): Promise<any> {
    const screen = await this.preparationScreenRepository.findOne(id);
    if (!screen) {
      throw new NotFoundException(`Preparation screen with ID ${id} not found`);
    }
    return screen.products || [];
  }
  async associateProducts(
    id: string,
    productIds: string[],
  ): Promise<PreparationScreen> {
    const screen = await this.preparationScreenRepository.findOne(id);
    if (!screen) {
      throw new NotFoundException(`Preparation screen with ID ${id} not found`);
    }
    const currentProducts = screen.products || [];
    for (const product of currentProducts) {
      await this.productRepository.updatePreparationScreen(product.id, null);
    }
    for (const productId of productIds) {
      await this.productRepository.updatePreparationScreen(productId, id);
    }
    return this.preparationScreenRepository.findOne(id);
  }
  async getMenuWithAssociations(screenId: string): Promise<any> {
    const screen = await this.preparationScreenRepository.findOne(screenId);
    if (!screen) {
      throw new NotFoundException(
        `Preparation screen with ID ${screenId} not found`,
      );
    }
    const categories = await this.categoryRepository.findAll({
      page: 1,
      limit: 1000,
      isActive: true,
    });
    const menuWithAssociations: any[] = [];
    for (const category of categories) {
      const categoryData: any = {
        id: category.id,
        name: category.name,
        photo: category.photo,
        subcategories: [],
      };
      const subcategories = await this.subcategoryRepository.findAll({
        page: 1,
        limit: 1000,
        categoryId: category.id,
        isActive: true,
      });
      for (const subcategory of subcategories.items) {
        const subcategoryData: any = {
          id: subcategory.id,
          name: subcategory.name,
          photo: subcategory.photo,
          products: [],
        };
        const products = await this.productRepository.findAll({
          page: 1,
          limit: 1000,
          subcategoryId: subcategory.id,
          isActive: true,
        });
        for (const product of products.items) {
          subcategoryData.products.push({
            id: product.id,
            name: product.name,
            photo: product.photo,
            price: product.price,
            isAssociated: product.preparationScreenId === screenId,
            currentPreparationScreenId: product.preparationScreenId,
          });
        }
        categoryData.subcategories.push(subcategoryData);
      }
      menuWithAssociations.push(categoryData);
    }
    return {
      screenId,
      screenName: screen.name,
      menu: menuWithAssociations,
    };
  }
  async getUsers(screenId: string): Promise<any> {
    const screen = await this.preparationScreenRepository.findOne(screenId);
    if (!screen) {
      throw new NotFoundException(
        `Preparation screen with ID ${screenId} not found`,
      );
    }
    const users =
      await this.preparationScreenRepository.getUsersByScreenId(screenId);
    return users;
  }
  async assignUsers(
    screenId: string,
    userAssignments: UserAssignmentDto[],
  ): Promise<PreparationScreen> {
    const screen = await this.preparationScreenRepository.findOne(screenId);
    if (!screen) {
      throw new NotFoundException(
        `Preparation screen with ID ${screenId} not found`,
      );
    }
    await this.preparationScreenRepository.assignUsers(
      screenId,
      userAssignments,
    );
    return this.preparationScreenRepository.findOne(screenId);
  }
}

================
File: backend/src/product-modifiers/domain/product-modifier.ts
================
export class ProductModifier {
  id: string;
  modifierGroupId: string;
  name: string;
  description: string | null;
  price: number | null;
  sortOrder: number;
  isDefault: boolean;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/product-modifiers/dto/create-product-modifier.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  MaxLength,
} from 'class-validator';
export class CreateProductModifierDto {
  @ApiProperty({
    type: String,
    example: 'MODG-1',
    description: 'ID del grupo de modificadores al que pertenece',
  })
  @IsNotEmpty()
  @IsString()
  modifierGroupId: string;
  @ApiProperty({
    type: String,
    example: 'Grande',
    description: 'Nombre del modificador',
  })
  @IsNotEmpty()
  @IsString()
  @MaxLength(100)
  name: string;
  @ApiProperty({
    type: String,
    example: 'Tamaño grande de 500ml',
    description: 'Descripción del modificador',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  description?: string | null;
  @ApiProperty({
    type: Number,
    example: 10.5,
    description: 'Precio adicional del modificador',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsNumber()
  price?: number | null;
  @ApiProperty({
    type: Number,
    example: 0,
    description: 'Orden de visualización',
    required: false,
    default: 0,
  })
  @IsOptional()
  @IsNumber()
  sortOrder?: number;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si este modificador es seleccionado por defecto',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si el modificador está activo',
    required: false,
    default: true,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

================
File: backend/src/product-modifiers/dto/find-all-product-modifiers.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString, IsUUID } from 'class-validator';
export class FindAllProductModifiersDto {
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description: 'Filtrar por ID del grupo de modificadores',
    required: false,
  })
  @IsOptional()
  @IsUUID()
  groupId?: string;
  @ApiProperty({
    type: String,
    example: 'Grande',
    description: 'Filtrar por nombre (búsqueda parcial)',
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Filtrar por estado activo/inactivo',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Filtrar por modificadores por defecto',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;
}

================
File: backend/src/product-modifiers/dto/update-product-modifier.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNumber,
  IsOptional,
  IsString,
  MaxLength,
} from 'class-validator';
export class UpdateProductModifierDto {
  @ApiProperty({
    type: String,
    example: 'MODG-1',
    description: 'ID del grupo de modificadores al que pertenece',
    required: false,
  })
  @IsOptional()
  @IsString()
  modifierGroupId?: string;
  @ApiProperty({
    type: String,
    example: 'Grande',
    description: 'Nombre del modificador',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  name?: string;
  @ApiProperty({
    type: String,
    example: 'Tamaño grande de 500ml',
    description: 'Descripción del modificador',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  description?: string | null;
  @ApiProperty({
    type: Number,
    example: 10.5,
    description: 'Precio adicional del modificador',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsNumber()
  price?: number | null;
  @ApiProperty({
    type: Number,
    example: 0,
    description: 'Orden de visualización',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  sortOrder?: number;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si este modificador es seleccionado por defecto',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si el modificador está activo',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

================
File: backend/src/product-modifiers/infrastructure/persistence/product-modifier.repository.ts
================
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ProductModifier } from '../../domain/product-modifier';
import { ProductModifierEntity } from './relational/entities/product-modifier.entity';
import { ProductModifierMapper } from './relational/mappers/product-modifier.mapper';
import { FindAllProductModifiersDto } from '../../dto/find-all-product-modifiers.dto';
import { IPaginationOptions } from '../../../utils/types/pagination-options';
import { Paginated } from '../../../common/types/paginated.type';
export interface IProductModifierRepository {
  create(data: ProductModifier): Promise<ProductModifier>;
  findById(id: string): Promise<ProductModifier | null>;
  findByGroupId(
    modifierGroupId: string,
    filters?: { isActive?: boolean; search?: string },
  ): Promise<ProductModifier[]>;
  findManyWithPagination(options: {
    filterOptions: FindAllProductModifiersDto;
    paginationOptions: IPaginationOptions;
  }): Promise<Paginated<ProductModifier>>;
  findAll(filters: {
    modifierGroupId?: string;
  }): Promise<Paginated<ProductModifier>>;
  update(
    id: string,
    data: Partial<ProductModifier>,
  ): Promise<ProductModifier | null>;
  remove(id: string): Promise<void>;
}
@Injectable()
export class ProductModifierRepository implements IProductModifierRepository {
  constructor(
    @InjectRepository(ProductModifierEntity)
    private readonly productModifierEntityRepository: Repository<ProductModifierEntity>,
    private readonly productModifierMapper: ProductModifierMapper,
  ) {}
  async create(data: ProductModifier): Promise<ProductModifier> {
    const persistenceModel = this.productModifierMapper.toEntity(data);
    if (!persistenceModel) {
      throw new InternalServerErrorException(
        'Error creating product modifier entity',
      );
    }
    const newEntity =
      await this.productModifierEntityRepository.save(persistenceModel);
    const domainResult = this.productModifierMapper.toDomain(newEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping saved product modifier entity to domain',
      );
    }
    return domainResult;
  }
  async findById(id: string): Promise<ProductModifier | null> {
    const entity = await this.productModifierEntityRepository.findOne({
      where: { id },
    });
    const domainResult = entity
      ? this.productModifierMapper.toDomain(entity)
      : null;
    if (!domainResult && entity) {
      throw new InternalServerErrorException(
        'Error mapping found product modifier entity to domain',
      );
    }
    return domainResult;
  }
  async findByGroupId(
    modifierGroupId: string,
    filters?: { isActive?: boolean; search?: string },
  ): Promise<ProductModifier[]> {
    const queryBuilder =
      this.productModifierEntityRepository.createQueryBuilder(
        'product_modifier',
      );
    queryBuilder.where(
      'product_modifier.modifier_group_id = :modifierGroupId',
      { modifierGroupId },
    );
    if (filters?.isActive !== undefined) {
      queryBuilder.andWhere('product_modifier.is_active = :isActive', {
        isActive: filters.isActive,
      });
    }
    if (filters?.search) {
      queryBuilder.andWhere(
        '(product_modifier.name ILIKE :search OR product_modifier.description ILIKE :search)',
        { search: `%${filters.search}%` },
      );
    }
    queryBuilder.orderBy('product_modifier.sort_order', 'ASC');
    const entities = await queryBuilder.getMany();
    const domainResults = entities
      .map((entity) => this.productModifierMapper.toDomain(entity))
      .filter((item): item is ProductModifier => item !== null);
    return domainResults;
  }
  async findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions: FindAllProductModifiersDto;
    paginationOptions: IPaginationOptions;
  }): Promise<Paginated<ProductModifier>> {
    const page = paginationOptions.page || 1;
    const limit = paginationOptions.limit || 10;
    const skip = (page - 1) * limit;
    const queryBuilder =
      this.productModifierEntityRepository.createQueryBuilder(
        'product_modifier',
      );
    if (filterOptions.groupId) {
      queryBuilder.andWhere(
        'product_modifier.modifier_group_id = :modifierGroupId',
        {
          modifierGroupId: filterOptions.groupId,
        },
      );
    }
    if (filterOptions.name) {
      queryBuilder.andWhere('product_modifier.name ILIKE :name', {
        name: `%${filterOptions.name}%`,
      });
    }
    if (filterOptions.isActive !== undefined) {
      queryBuilder.andWhere('product_modifier.is_active = :isActive', {
        isActive: filterOptions.isActive,
      });
    }
    if (filterOptions.isDefault !== undefined) {
      queryBuilder.andWhere('product_modifier.is_default = :isDefault', {
        isDefault: filterOptions.isDefault,
      });
    }
    queryBuilder
      .orderBy('product_modifier.sort_order', 'ASC')
      .addOrderBy('product_modifier.name', 'ASC')
      .skip(skip)
      .take(limit);
    const [entities, count] = await queryBuilder.getManyAndCount();
    const domainResults = entities
      .map((entity) => this.productModifierMapper.toDomain(entity))
      .filter((item): item is ProductModifier => item !== null);
    return new Paginated(domainResults, count, page, limit);
  }
  async update(
    id: string,
    data: Partial<ProductModifier>,
  ): Promise<ProductModifier | null> {
    const entityToUpdate = this.productModifierMapper.toEntity({
      ...data,
      id,
    } as ProductModifier);
    if (!entityToUpdate) {
      throw new InternalServerErrorException(
        'Error creating product modifier entity for update',
      );
    }
    await this.productModifierEntityRepository.update(id, entityToUpdate);
    const updatedEntity = await this.productModifierEntityRepository.findOne({
      where: { id },
    });
    if (!updatedEntity) {
      throw new NotFoundException(
        `Product modifier with ID ${id} not found after update`,
      );
    }
    const domainResult = this.productModifierMapper.toDomain(updatedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping updated product modifier entity to domain',
      );
    }
    return domainResult;
  }
  async remove(id: string): Promise<void> {
    const result = await this.productModifierEntityRepository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(`Product modifier with ID ${id} not found`);
    }
  }
  async findAll(filters: {
    modifierGroupId?: string;
  }): Promise<Paginated<ProductModifier>> {
    const queryBuilder =
      this.productModifierEntityRepository.createQueryBuilder(
        'product_modifier',
      );
    if (filters.modifierGroupId) {
      queryBuilder.where(
        'product_modifier.modifier_group_id = :modifierGroupId',
        {
          modifierGroupId: filters.modifierGroupId,
        },
      );
    }
    queryBuilder.orderBy('product_modifier.sort_order', 'ASC');
    const [entities, count] = await queryBuilder.getManyAndCount();
    const domainResults = entities
      .map((entity) => this.productModifierMapper.toDomain(entity))
      .filter((item): item is ProductModifier => item !== null);
    return new Paginated(domainResults, count, 1, count);
  }
}

================
File: backend/src/product-modifiers/infrastructure/persistence/relational/entities/product-modifier.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { ModifierGroupEntity } from '../../../../../modifier-groups/infrastructure/persistence/relational/entities/modifier-group.entity';
@Entity({
  name: 'product_modifier',
})
export class ProductModifierEntity extends EntityRelationalHelper {
  @PrimaryColumn({ type: 'varchar', length: 20 })
  id: string;
  @Column({ name: 'modifier_group_id', type: 'varchar', length: 20 })
  modifierGroupId: string;
  @Column()
  name: string;
  @Column({ type: 'varchar', nullable: true })
  description: string | null;
  @Column({ type: 'decimal', precision: 10, scale: 2, nullable: true })
  price: number | null;
  @Column({ name: 'sort_order', type: 'int', default: 0 })
  sortOrder: number;
  @Column({ name: 'is_default', default: false })
  isDefault: boolean;
  @Column({ name: 'is_active', default: true })
  isActive: boolean;
  @ManyToOne(() => ModifierGroupEntity, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'modifier_group_id' })
  modifierGroup: ModifierGroupEntity;
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/product-modifiers/infrastructure/persistence/relational/mappers/product-modifier.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { ProductModifier } from '../../../../domain/product-modifier';
import { ProductModifierEntity } from '../entities/product-modifier.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
import { ModifierGroupEntity } from '../../../../../modifier-groups/infrastructure/persistence/relational/entities/modifier-group.entity';
@Injectable()
export class ProductModifierMapper extends BaseMapper<
  ProductModifierEntity,
  ProductModifier
> {
  override toDomain(entity: ProductModifierEntity): ProductModifier | null {
    if (!entity) return null;
    const domain = new ProductModifier();
    domain.id = entity.id;
    domain.modifierGroupId = entity.modifierGroupId;
    domain.name = entity.name;
    domain.description = entity.description;
    domain.price = entity.price;
    domain.sortOrder = entity.sortOrder;
    domain.isDefault = entity.isDefault;
    domain.isActive = entity.isActive;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: ProductModifier): ProductModifierEntity | null {
    if (!domain) return null;
    const entity = new ProductModifierEntity();
    if (domain.id) entity.id = domain.id;
    entity.modifierGroupId = domain.modifierGroupId;
    entity.name = domain.name;
    entity.description = domain.description;
    entity.price = domain.price;
    entity.sortOrder = domain.sortOrder;
    entity.isDefault = domain.isDefault;
    entity.isActive = domain.isActive;
    if (domain.modifierGroupId) {
      entity.modifierGroup = {
        id: domain.modifierGroupId,
      } as ModifierGroupEntity;
    }
    return entity;
  }
}

================
File: backend/src/product-modifiers/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ProductModifierEntity } from './entities/product-modifier.entity';
import { ProductModifierMapper } from './mappers/product-modifier.mapper';
import { ProductModifierRepository } from '../product-modifier.repository';
import { PRODUCT_MODIFIER_REPOSITORY } from '../../../../common/tokens';
@Module({
  imports: [TypeOrmModule.forFeature([ProductModifierEntity])],
  providers: [
    {
      provide: PRODUCT_MODIFIER_REPOSITORY,
      useClass: ProductModifierRepository,
    },
    ProductModifierMapper,
  ],
  exports: [PRODUCT_MODIFIER_REPOSITORY, ProductModifierMapper],
})
export class RelationalProductModifierPersistenceModule {}

================
File: backend/src/product-modifiers/product-modifiers.module.ts
================
import { Module } from '@nestjs/common';
import { ProductModifiersService } from './product-modifiers.service';
import { ProductModifiersController } from './product-modifiers.controller';
import { RelationalProductModifierPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { CommonModule } from '../common/common.module';
@Module({
  imports: [RelationalProductModifierPersistenceModule, CommonModule],
  controllers: [ProductModifiersController],
  providers: [ProductModifiersService],
  exports: [ProductModifiersService],
})
export class ProductModifiersModule {}

================
File: backend/src/product-modifiers/product-modifiers.service.ts
================
import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { ProductModifier } from './domain/product-modifier';
import { CreateProductModifierDto } from './dto/create-product-modifier.dto';
import { FindAllProductModifiersDto } from './dto/find-all-product-modifiers.dto';
import { UpdateProductModifierDto } from './dto/update-product-modifier.dto';
import { IProductModifierRepository } from './infrastructure/persistence/product-modifier.repository';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { PRODUCT_MODIFIER_REPOSITORY } from '../common/tokens';
import { Paginated } from '../common/types/paginated.type';
import {
  CustomIdService,
  EntityPrefix,
} from '../common/services/custom-id.service';
@Injectable()
export class ProductModifiersService {
  constructor(
    @Inject(PRODUCT_MODIFIER_REPOSITORY)
    private readonly productModifierRepository: IProductModifierRepository,
    private readonly customIdService: CustomIdService,
  ) {}
  async create(
    createProductModifierDto: CreateProductModifierDto,
  ): Promise<ProductModifier> {
    const productModifier = new ProductModifier();
    productModifier.id = await this.customIdService.generateId(
      EntityPrefix.MODIFIER,
      'product_modifier',
    );
    productModifier.modifierGroupId = createProductModifierDto.modifierGroupId;
    productModifier.name = createProductModifierDto.name;
    productModifier.description =
      createProductModifierDto.description !== undefined
        ? createProductModifierDto.description
        : null;
    productModifier.price =
      createProductModifierDto.price !== undefined
        ? createProductModifierDto.price
        : null;
    productModifier.sortOrder =
      createProductModifierDto.sortOrder !== undefined
        ? createProductModifierDto.sortOrder
        : 0;
    productModifier.isDefault =
      createProductModifierDto.isDefault !== undefined
        ? createProductModifierDto.isDefault
        : false;
    productModifier.isActive =
      createProductModifierDto.isActive !== undefined
        ? createProductModifierDto.isActive
        : true;
    return this.productModifierRepository.create(productModifier);
  }
  async findAll(
    filterOptions: FindAllProductModifiersDto,
    paginationOptions: IPaginationOptions,
  ): Promise<Paginated<ProductModifier>> {
    return this.productModifierRepository.findManyWithPagination({
      filterOptions,
      paginationOptions,
    });
  }
  async findOne(id: string): Promise<ProductModifier> {
    const productModifier = await this.productModifierRepository.findById(id);
    if (!productModifier) {
      throw new NotFoundException(`Product modifier with ID ${id} not found`);
    }
    return productModifier;
  }
  async findByGroupId(
    modifierGroupId: string,
    filters?: { isActive?: boolean; search?: string },
  ): Promise<ProductModifier[]> {
    return this.productModifierRepository.findByGroupId(
      modifierGroupId,
      filters,
    );
  }
  async update(
    id: string,
    updateProductModifierDto: UpdateProductModifierDto,
  ): Promise<ProductModifier> {
    const updatedProductModifier = await this.productModifierRepository.update(
      id,
      updateProductModifierDto,
    );
    if (!updatedProductModifier) {
      throw new NotFoundException(`Product modifier with ID ${id} not found`);
    }
    return updatedProductModifier;
  }
  async remove(id: string): Promise<void> {
    await this.productModifierRepository.remove(id);
  }
}

================
File: backend/src/product-variants/domain/product-variant.ts
================
import { Product } from '../../products/domain/product';
export class ProductVariant {
  id: string;
  productId: string;
  name: string;
  price: number;
  isActive: boolean;
  sortOrder: number;
  product?: Product;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/product-variants/dto/create-product-variant.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
export class CreateProductVariantDto {
  @ApiProperty({
    type: String,
    example: 'PROD-1',
    description: 'ID del producto al que pertenece esta variante',
  })
  @IsString()
  @IsNotEmpty()
  productId: string;
  @ApiProperty({
    type: String,
    example: 'Grande',
    description: 'Nombre de la variante',
  })
  @IsString()
  @IsNotEmpty()
  name: string;
  @ApiProperty({
    type: Number,
    example: 12.99,
    description: 'Precio de la variante',
  })
  @IsNumber()
  @IsPositive()
  price: number;
  @ApiProperty({
    type: Boolean,
    example: true,
    default: true,
    description: 'Indica si la variante está activa',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}

================
File: backend/src/product-variants/dto/find-all-product-variants.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsNumber, IsOptional, IsString } from 'class-validator';
import { Transform } from 'class-transformer';
export class FindAllProductVariantsDto {
  @ApiProperty({
    type: Number,
    example: 1,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  page?: number = 1;
  @ApiProperty({
    type: Number,
    example: 10,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  limit?: number = 10;
  @ApiProperty({
    type: String,
    example: 'PROD-1',
    description: 'Filtrar por ID de producto',
    required: false,
  })
  @IsOptional()
  @IsString()
  productId?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Filtrar por estado activo/inactivo',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
}

================
File: backend/src/product-variants/dto/update-product-variant.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
export class UpdateProductVariantDto {
  @ApiProperty({
    type: String,
    example: 'PROD-1',
    description: 'ID del producto al que pertenece esta variante',
    required: false,
  })
  @IsOptional()
  @IsString()
  productId?: string;
  @ApiProperty({
    type: String,
    example: 'Grande',
    description: 'Nombre de la variante',
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: Number,
    example: 12.99,
    description: 'Precio de la variante',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  @IsPositive()
  price?: number;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si la variante está activa',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: Number,
    example: 0,
    description: 'Orden de visualización de la variante',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  sortOrder?: number;
}

================
File: backend/src/product-variants/infrastructure/persistence/product-variant.repository.ts
================
import { ProductVariant } from '../../domain/product-variant';
export interface ProductVariantRepository {
  create(productVariant: ProductVariant): Promise<ProductVariant>;
  findAll(options: {
    page: number;
    limit: number;
    productId?: string;
    isActive?: boolean;
  }): Promise<[ProductVariant[], number]>;
  findOne(id: string): Promise<ProductVariant>;
  update(
    id: string,
    productVariant: Partial<ProductVariant>,
  ): Promise<ProductVariant>;
  save(productVariant: ProductVariant): Promise<ProductVariant>;
  findAllByProductId(productId: string): Promise<ProductVariant[]>;
  softDelete(id: string): Promise<void>;
}

================
File: backend/src/product-variants/infrastructure/persistence/relational/entities/product-variant.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  OneToMany,
  PrimaryColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
import { OrderItemEntity } from '../../../../../orders/infrastructure/persistence/relational/entities/order-item.entity';
@Entity({
  name: 'product_variant',
})
export class ProductVariantEntity extends EntityRelationalHelper {
  @PrimaryColumn({ type: 'varchar', length: 20 })
  id: string;
  @Column({ name: 'product_id', type: 'varchar', length: 20 })
  productId: string;
  @Column()
  name: string;
  @Column({ type: 'decimal', precision: 10, scale: 2 })
  price: number;
  @Column({ default: true })
  isActive: boolean;
  @Column({ default: 0 })
  sortOrder: number;
  @ManyToOne(() => ProductEntity, (product) => product.variants, {
    nullable: false,
  })
  @JoinColumn({ name: 'product_id' })
  product: ProductEntity;
  @OneToMany(() => OrderItemEntity, (orderItem) => orderItem.productVariant)
  orderItems: OrderItemEntity[];
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/product-variants/infrastructure/persistence/relational/mappers/product-variant.mapper.ts
================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { ProductVariant } from '../../../../domain/product-variant';
import { ProductVariantEntity } from '../entities/product-variant.entity';
import { ProductMapper } from '../../../../../products/infrastructure/persistence/relational/mappers/product.mapper';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class ProductVariantMapper extends BaseMapper<
  ProductVariantEntity,
  ProductVariant
> {
  constructor(
    @Inject(forwardRef(() => ProductMapper))
    private readonly productMapper: ProductMapper,
  ) {
    super();
  }
  override toDomain(entity: ProductVariantEntity): ProductVariant | null {
    if (!entity) return null;
    const domain = new ProductVariant();
    domain.id = entity.id;
    domain.productId = entity.product?.id || entity.productId;
    domain.name = entity.name;
    domain.price = entity.price;
    domain.isActive = entity.isActive;
    domain.sortOrder = entity.sortOrder;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    if (entity.product) {
      const mappedProduct = this.productMapper.toDomain(entity.product);
      if (mappedProduct) {
        domain.product = mappedProduct;
      }
    }
    return domain;
  }
  override toEntity(domain: ProductVariant): ProductVariantEntity | null {
    if (!domain) return null;
    const entity = new ProductVariantEntity();
    entity.id = domain.id;
    entity.product = { id: domain.productId } as ProductEntity;
    entity.name = domain.name;
    entity.price = domain.price;
    entity.isActive = domain.isActive;
    entity.sortOrder = domain.sortOrder;
    return entity;
  }
}

================
File: backend/src/product-variants/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ProductVariantEntity } from './entities/product-variant.entity';
import { ProductVariantRelationalRepository } from './repositories/product-variant.repository';
import { ProductVariantMapper } from './mappers/product-variant.mapper';
import { RelationalProductPersistenceModule } from '../../../../products/infrastructure/persistence/relational/relational-persistence.module';
import { PRODUCT_VARIANT_REPOSITORY } from '../../../../common/tokens';
@Module({
  imports: [
    TypeOrmModule.forFeature([ProductVariantEntity]),
    forwardRef(() => RelationalProductPersistenceModule),
  ],
  providers: [
    {
      provide: PRODUCT_VARIANT_REPOSITORY,
      useClass: ProductVariantRelationalRepository,
    },
    ProductVariantMapper,
  ],
  exports: [PRODUCT_VARIANT_REPOSITORY, ProductVariantMapper],
})
export class RelationalProductVariantPersistenceModule {}

================
File: backend/src/product-variants/infrastructure/persistence/relational/repositories/product-variant.repository.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ProductVariantEntity } from '../entities/product-variant.entity';
import { ProductVariantRepository } from '../../product-variant.repository';
import { ProductVariant } from '../../../../domain/product-variant';
import { ProductVariantMapper } from '../mappers/product-variant.mapper';
@Injectable()
export class ProductVariantRelationalRepository
  implements ProductVariantRepository
{
  constructor(
    @InjectRepository(ProductVariantEntity)
    private readonly productVariantRepository: Repository<ProductVariantEntity>,
    private readonly productVariantMapper: ProductVariantMapper,
  ) {}
  async create(productVariant: ProductVariant): Promise<ProductVariant> {
    const entity = this.productVariantMapper.toEntity(productVariant);
    if (!entity) {
      throw new Error(
        'Error mapping ProductVariant domain to entity for create',
      );
    }
    const newEntity = this.productVariantRepository.create(entity);
    const savedEntity = await this.productVariantRepository.save(newEntity);
    const domainResult = this.productVariantMapper.toDomain(savedEntity);
    if (!domainResult) {
      throw new Error(
        'Error mapping saved ProductVariant entity back to domain',
      );
    }
    return domainResult;
  }
  async findAll(options: {
    page: number;
    limit: number;
    productId?: string;
    isActive?: boolean;
  }): Promise<[ProductVariant[], number]> {
    const where: any = {};
    if (options.productId) {
      where.product = { id: options.productId };
    }
    if (options.isActive !== undefined) {
      where.isActive = options.isActive;
    }
    const [entities, count] = await this.productVariantRepository.findAndCount({
      where,
      skip: (options.page - 1) * options.limit,
      take: options.limit,
      relations: ['product'],
      order: {
        sortOrder: 'ASC',
        name: 'ASC',
      },
    });
    const productVariants = entities
      .map((entity) => this.productVariantMapper.toDomain(entity))
      .filter((variant): variant is ProductVariant => variant !== null);
    return [productVariants, count];
  }
  async findOne(id: string): Promise<ProductVariant> {
    const entity = await this.productVariantRepository.findOne({
      where: { id },
      relations: ['product'],
    });
    if (!entity) {
      throw new NotFoundException(
        `Variante de producto con ID ${id} no encontrada`,
      );
    }
    const domainResult = this.productVariantMapper.toDomain(entity);
    if (!domainResult) {
      throw new NotFoundException(
        `Error mapping ProductVariant entity with ID ${id} to domain`,
      );
    }
    return domainResult;
  }
  async update(
    id: string,
    productVariant: ProductVariant,
  ): Promise<ProductVariant> {
    const partialEntity = this.productVariantMapper.toEntity(productVariant);
    if (!partialEntity) {
      throw new Error(
        'Error mapping ProductVariant domain to partial entity for update',
      );
    }
    const { id: _entityId, ...updatePayload } = partialEntity;
    const updateResult = await this.productVariantRepository.update(
      id,
      updatePayload,
    );
    if (updateResult.affected === 0) {
      throw new NotFoundException(
        `Variante de producto con ID ${id} no encontrada para actualizar`,
      );
    }
    const updatedEntity = await this.productVariantRepository.findOne({
      where: { id },
      relations: ['product'],
    });
    if (!updatedEntity) {
      throw new NotFoundException(
        `Variante de producto con ID ${id} no encontrada`,
      );
    }
    const domainResult = this.productVariantMapper.toDomain(updatedEntity);
    if (!domainResult) {
      throw new NotFoundException(
        `Error mapping updated ProductVariant entity with ID ${id} to domain`,
      );
    }
    return domainResult;
  }
  async save(productVariant: ProductVariant): Promise<ProductVariant> {
    const entity = this.productVariantMapper.toEntity(productVariant);
    if (!entity) {
      throw new Error('Error mapping ProductVariant domain to entity for save');
    }
    const savedEntity = await this.productVariantRepository.save(entity);
    if (
      !savedEntity ||
      typeof savedEntity !== 'object' ||
      !('id' in savedEntity)
    ) {
      throw new Error(
        'Error saving ProductVariant: unexpected result from repository save',
      );
    }
    const reloadedEntity = await this.productVariantRepository.findOne({
      where: { id: savedEntity.id },
      relations: ['product'],
    });
    if (!reloadedEntity) {
      throw new NotFoundException(
        `Variante con ID ${savedEntity.id} no encontrada después de guardar`,
      );
    }
    const domainResult = this.productVariantMapper.toDomain(reloadedEntity);
    if (!domainResult) {
      throw new NotFoundException(
        `Error mapping reloaded ProductVariant entity with ID ${reloadedEntity.id} to domain`,
      );
    }
    return domainResult;
  }
  async findAllByProductId(productId: string): Promise<ProductVariant[]> {
    const entities = await this.productVariantRepository.find({
      where: { product: { id: productId } },
      relations: ['product'],
    });
    return entities
      .map((entity) => this.productVariantMapper.toDomain(entity))
      .filter((variant): variant is ProductVariant => variant !== null);
  }
  async softDelete(id: string): Promise<void> {
    const result = await this.productVariantRepository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(
        `Variante de producto con ID ${id} no encontrada`,
      );
    }
  }
}

================
File: backend/src/product-variants/product-variants.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Query,
  HttpStatus,
  HttpCode,
} from '@nestjs/common';
import { ProductVariantsService } from './product-variants.service';
import { CreateProductVariantDto } from './dto/create-product-variant.dto';
import { UpdateProductVariantDto } from './dto/update-product-variant.dto';
import { ApiBearerAuth, ApiOperation, ApiTags } from '@nestjs/swagger';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { FindAllProductVariantsDto } from './dto/find-all-product-variants.dto';
@ApiTags('Variantes de Productos')
@Controller({
  path: 'product-variants',
  version: '1',
})
export class ProductVariantsController {
  constructor(
    private readonly productVariantsService: ProductVariantsService,
  ) {}
  @Post()
  @ApiOperation({
    summary: 'Crear una nueva variante de producto',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createProductVariantDto: CreateProductVariantDto) {
    return this.productVariantsService.create(createProductVariantDto);
  }
  @Get()
  @ApiOperation({
    summary: 'Obtener todas las variantes de productos',
  })
  @HttpCode(HttpStatus.OK)
  findAll(@Query() findAllProductVariantsDto: FindAllProductVariantsDto) {
    return this.productVariantsService.findAll(findAllProductVariantsDto);
  }
  @Get(':id')
  @ApiOperation({
    summary: 'Obtener una variante de producto por ID',
  })
  @HttpCode(HttpStatus.OK)
  findOne(@Param('id') id: string) {
    return this.productVariantsService.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({
    summary: 'Actualizar una variante de producto',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  update(
    @Param('id') id: string,
    @Body() updateProductVariantDto: UpdateProductVariantDto,
  ) {
    return this.productVariantsService.update(id, updateProductVariantDto);
  }
  @Delete(':id')
  @ApiOperation({
    summary: 'Eliminar una variante de producto',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id') id: string) {
    return this.productVariantsService.remove(id);
  }
}

================
File: backend/src/product-variants/product-variants.module.ts
================
import { Module } from '@nestjs/common';
import { ProductVariantsService } from './product-variants.service';
import { ProductVariantsController } from './product-variants.controller';
import { RelationalProductVariantPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { CommonModule } from '../common/common.module';
@Module({
  imports: [RelationalProductVariantPersistenceModule, CommonModule],
  controllers: [ProductVariantsController],
  providers: [ProductVariantsService],
  exports: [ProductVariantsService, RelationalProductVariantPersistenceModule],
})
export class ProductVariantsModule {}

================
File: backend/src/product-variants/product-variants.service.ts
================
import { Inject, Injectable } from '@nestjs/common';
import { ProductVariantRepository } from './infrastructure/persistence/product-variant.repository';
import { CreateProductVariantDto } from './dto/create-product-variant.dto';
import { UpdateProductVariantDto } from './dto/update-product-variant.dto';
import { ProductVariant } from './domain/product-variant';
import { FindAllProductVariantsDto } from './dto/find-all-product-variants.dto';
import { PRODUCT_VARIANT_REPOSITORY } from '../common/tokens';
import {
  CustomIdService,
  EntityPrefix,
} from '../common/services/custom-id.service';
@Injectable()
export class ProductVariantsService {
  constructor(
    @Inject(PRODUCT_VARIANT_REPOSITORY)
    private readonly productVariantRepository: ProductVariantRepository,
    private readonly customIdService: CustomIdService,
  ) {}
  async create(
    createProductVariantDto: CreateProductVariantDto,
  ): Promise<ProductVariant> {
    const productVariant = new ProductVariant();
    productVariant.id = await this.customIdService.generateId(
      EntityPrefix.PRODUCT_VARIANT,
      'product_variant',
    );
    productVariant.productId = createProductVariantDto.productId;
    productVariant.name = createProductVariantDto.name;
    productVariant.price = createProductVariantDto.price;
    productVariant.isActive = createProductVariantDto.isActive ?? true;
    return this.productVariantRepository.create(productVariant);
  }
  async findAll(
    findAllProductVariantsDto: FindAllProductVariantsDto,
  ): Promise<[ProductVariant[], number]> {
    return this.productVariantRepository.findAll({
      page: findAllProductVariantsDto.page || 1,
      limit: findAllProductVariantsDto.limit || 10,
      productId: findAllProductVariantsDto.productId,
      isActive: findAllProductVariantsDto.isActive,
    });
  }
  async findOne(id: string): Promise<ProductVariant> {
    return this.productVariantRepository.findOne(id);
  }
  async findAllByProductId(productId: string): Promise<ProductVariant[]> {
    return this.productVariantRepository.findAllByProductId(productId);
  }
  async update(
    id: string,
    updateProductVariantDto: UpdateProductVariantDto,
  ): Promise<ProductVariant> {
    const existingProductVariant =
      await this.productVariantRepository.findOne(id);
    const productVariant = new ProductVariant();
    productVariant.id = id;
    productVariant.productId =
      updateProductVariantDto.productId ?? existingProductVariant.productId;
    productVariant.name =
      updateProductVariantDto.name ?? existingProductVariant.name;
    productVariant.price =
      updateProductVariantDto.price ?? existingProductVariant.price;
    productVariant.isActive =
      updateProductVariantDto.isActive ?? existingProductVariant.isActive;
    return this.productVariantRepository.update(id, productVariant);
  }
  async remove(id: string): Promise<void> {
    return this.productVariantRepository.softDelete(id);
  }
}

================
File: backend/src/products/domain/product.ts
================
import { Subcategory } from '../../subcategories/domain/subcategory';
import { FileType } from '../../files/domain/file';
import { ProductVariant } from '../../product-variants/domain/product-variant';
import { ModifierGroup } from '../../modifier-groups/domain/modifier-group';
import { PreparationScreen } from '../../preparation-screens/domain/preparation-screen';
import { PizzaCustomization } from '../../pizza-customizations/domain/pizza-customization';
import { PizzaConfiguration } from '../../pizza-configurations/domain/pizza-configuration';
export class Product {
  id: string;
  name: string;
  description: string | null;
  price: number | null;
  hasVariants: boolean;
  isActive: boolean;
  isPizza: boolean;
  sortOrder: number;
  subcategoryId: string;
  preparationScreenId: string | null;
  photoId: string | null;
  estimatedPrepTime: number;
  photo: FileType | null;
  subcategory: Subcategory | null;
  variants: ProductVariant[];
  modifierGroups: ModifierGroup[];
  preparationScreen: PreparationScreen | null;
  pizzaCustomizations?: PizzaCustomization[];
  pizzaConfiguration?: PizzaConfiguration;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/products/dto/assign-modifier-groups.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsNotEmpty, IsString } from 'class-validator';
export class AssignModifierGroupsDto {
  @ApiProperty({
    type: [String],
    example: ['MODGRP-1', 'MODGRP-2'],
    description: 'IDs de los grupos de modificadores a asignar al producto',
  })
  @IsNotEmpty()
  @IsArray()
  @IsString({ each: true })
  modifierGroupIds: string[];
}

================
File: backend/src/products/dto/create-product.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
  Min,
  ValidateIf,
  ValidateNested,
  IsArray,
} from 'class-validator';
import { Type } from 'class-transformer';
export class CreateProductVariantDto {
  @ApiProperty({
    type: String,
    example: 'Grande',
    description: 'Nombre de la variante',
  })
  @IsString()
  @IsNotEmpty()
  name: string;
  @ApiProperty({
    type: Number,
    example: 12.99,
    description: 'Precio de la variante',
  })
  @IsNumber()
  @IsPositive()
  price: number;
  @ApiProperty({
    type: Boolean,
    example: true,
    default: true,
    description: 'Indica si la variante está activa',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: Number,
    example: 0,
    default: 0,
    description: 'Orden de visualización de la variante',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  sortOrder?: number;
}
export class CreateProductDto {
  @ApiProperty({
    type: String,
    example: 'Hamburguesa Clásica',
    description: 'Nombre del producto',
  })
  @IsString()
  @IsNotEmpty()
  name: string;
  @ApiProperty({
    type: String,
    example:
      'Deliciosa hamburguesa con carne 100% res, lechuga, tomate y nuestra salsa especial',
    description: 'Descripción del producto',
    nullable: true,
    required: false,
  })
  @IsOptional()
  @IsString()
  description?: string;
  @ApiProperty({
    type: Number,
    example: 10.99,
    description: 'Precio del producto (puede ser nulo si tiene variantes)',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((o) => o.hasVariants === false)
  @IsNumber()
  @IsPositive()
  price?: number;
  @ApiProperty({
    type: Boolean,
    example: false,
    default: false,
    description: 'Indica si el producto tiene variantes',
  })
  @IsOptional()
  @IsBoolean()
  hasVariants?: boolean;
  @ApiProperty({
    type: Boolean,
    example: true,
    default: true,
    description: 'Indica si el producto está activo',
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: Boolean,
    example: false,
    default: false,
    description: 'Indica si el producto es una pizza',
  })
  @IsOptional()
  @IsBoolean()
  isPizza?: boolean;
  @ApiProperty({
    type: String,
    example: 'SUBCAT-1',
    description: 'ID de la subcategoría a la que pertenece el producto',
  })
  @IsString()
  @IsNotEmpty()
  subcategoryId: string;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description: 'ID de la foto del producto',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((o) => o.photoId !== null)
  @IsString()
  photoId?: string | null;
  @ApiProperty({
    type: Number,
    example: 15,
    description: 'Tiempo estimado de preparación en minutos',
  })
  @IsNumber()
  @Min(1)
  estimatedPrepTime: number;
  @ApiProperty({
    type: String,
    example: 'PREPSCR-1',
    description: 'ID de la pantalla de preparación',
    required: false,
  })
  @IsOptional()
  @IsString()
  preparationScreenId?: string;
  @ApiProperty({
    type: [CreateProductVariantDto],
    description: 'Variantes del producto',
    required: false,
  })
  @IsOptional()
  @ValidateIf((o) => o.hasVariants === true)
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateProductVariantDto)
  variants?: CreateProductVariantDto[];
  @ApiProperty({
    type: [String],
    example: ['MODGRP-1', 'MODGRP-2'],
    description: 'IDs de los grupos de modificadores a asociar con el producto',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  modifierGroupIds?: string[];
  @ApiProperty({
    type: Number,
    example: 0,
    default: 0,
    description: 'Orden de visualización del producto',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  sortOrder?: number;
}

================
File: backend/src/products/dto/find-all-products.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsNumber, IsOptional, IsString } from 'class-validator';
import { Transform } from 'class-transformer';
export class FindAllProductsDto {
  @ApiProperty({
    type: Number,
    example: 1,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  page?: number = 1;
  @ApiProperty({
    type: Number,
    example: 10,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  limit?: number = 10;
  @ApiProperty({
    type: String,
    example: 'SUBCAT-1',
    description: 'Filtrar por ID de subcategoría',
    required: false,
  })
  @IsOptional()
  @IsString()
  subcategoryId?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Filtrar por productos con variantes',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  hasVariants?: boolean;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Filtrar por productos activos',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
  @ApiProperty({
    type: String,
    example: 'Hamburguesa',
    description: 'Buscar por nombre del producto',
    required: false,
  })
  @IsOptional()
  @IsString()
  search?: string;
}

================
File: backend/src/products/dto/update-product.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
  Min,
  ValidateIf,
  ValidateNested,
  IsArray,
} from 'class-validator';
import { Type } from 'class-transformer';
export class UpdateProductVariantDto {
  @ApiProperty({
    type: String,
    example: 'Grande',
    description: 'Nombre de la variante',
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: Number,
    example: 12.99,
    description: 'Precio de la variante',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  @IsPositive()
  price?: number;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si la variante está activa',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description:
      'ID de la variante (solo para actualizar variantes existentes)',
    required: false,
  })
  @IsOptional()
  @IsString()
  id?: string;
  @ApiProperty({
    type: Number,
    example: 0,
    description: 'Orden de visualización de la variante',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  sortOrder?: number;
}
export class UpdateProductDto {
  @ApiProperty({
    type: String,
    example: 'Hamburguesa Clásica',
    description: 'Nombre del producto',
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: String,
    example:
      'Deliciosa hamburguesa con carne 100% res, lechuga, tomate y nuestra salsa especial',
    description: 'Descripción del producto',
    nullable: true,
    required: false,
  })
  @IsOptional()
  @IsString()
  description?: string | null;
  @ApiProperty({
    type: Number,
    example: 10.99,
    description: 'Precio del producto (puede ser nulo si tiene variantes)',
    nullable: true,
    required: false,
  })
  @IsOptional()
  @ValidateIf((o) => o.hasVariants === false)
  @IsNumber()
  @IsPositive()
  price?: number | null;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si el producto tiene variantes',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  hasVariants?: boolean;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si el producto está activo',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si el producto es una pizza',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isPizza?: boolean;
  @ApiProperty({
    type: String,
    example: 'SUBCAT-1',
    description: 'ID de la subcategoría a la que pertenece el producto',
    required: false,
  })
  @IsOptional()
  @IsString()
  subcategoryId?: string;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description: 'ID de la foto del producto',
    nullable: true,
    required: false,
  })
  @IsOptional()
  @ValidateIf((o) => o.photoId !== null)
  @IsString()
  photoId?: string | null;
  @ApiProperty({
    type: Number,
    example: 15,
    description: 'Tiempo estimado de preparación en minutos',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  @Min(1)
  estimatedPrepTime?: number;
  @ApiProperty({
    type: String,
    example: 'PREPSCR-1',
    description: 'ID de la pantalla de preparación',
    required: false,
  })
  @IsOptional()
  @IsString()
  preparationScreenId?: string;
  @ApiProperty({
    type: [UpdateProductVariantDto],
    description:
      'Lista completa de variantes deseadas para el producto. Las variantes existentes no incluidas aquí serán eliminadas. Incluir "id" para actualizar una existente, omitirlo para crear una nueva.',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => UpdateProductVariantDto)
  variants?: UpdateProductVariantDto[];
  @ApiProperty({
    type: [String],
    example: ['MODGRP-1', 'MODGRP-2'],
    description:
      'Lista completa de IDs de los grupos de modificadores a asociar. Las asociaciones existentes no incluidas aquí serán eliminadas.',
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  modifierGroupIds?: string[];
  @ApiProperty({
    type: Number,
    example: 0,
    description: 'Orden de visualización del producto',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  sortOrder?: number;
}

================
File: backend/src/products/infrastructure/persistence/product.repository.ts
================
import { Product } from '../../domain/product';
import { Paginated } from '../../../common/types/paginated.type';
export interface ProductRepository {
  create(product: Product): Promise<Product>;
  findAll(options: {
    page: number;
    limit: number;
    subcategoryId?: string;
    hasVariants?: boolean;
    isActive?: boolean;
    search?: string;
  }): Promise<Paginated<Product>>;
  findOne(id: string): Promise<Product | null>;
  findByIds(ids: string[]): Promise<Product[]>;
  update(id: string, product: Partial<Product>): Promise<Product | null>;
  save(product: Product): Promise<Product>;
  softDelete(id: string): Promise<void>;
  updatePreparationScreen(
    productId: string,
    preparationScreenId: string | null,
  ): Promise<void>;
  findOneWithPizzaCustomizations(id: string): Promise<Product | null>;
  updatePizzaCustomizations(
    productId: string,
    pizzaCustomizationIds: string[],
  ): Promise<void>;
  findAllPizzas(): Promise<Product[]>;
}

================
File: backend/src/products/infrastructure/persistence/relational/entities/product.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  JoinTable,
  ManyToMany,
  ManyToOne,
  OneToMany,
  OneToOne,
  PrimaryColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { SubcategoryEntity } from '../../../../../subcategories/infrastructure/persistence/relational/entities/subcategory.entity';
import { FileEntity } from '../../../../../files/infrastructure/persistence/relational/entities/file.entity';
import { ProductVariantEntity } from '../../../../../product-variants/infrastructure/persistence/relational/entities/product-variant.entity';
import { ModifierGroupEntity } from '../../../../../modifier-groups/infrastructure/persistence/relational/entities/modifier-group.entity';
import { OrderItemEntity } from '../../../../../orders/infrastructure/persistence/relational/entities/order-item.entity';
import { PreparationScreenEntity } from '../../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import { PizzaCustomizationEntity } from '../../../../../pizza-customizations/infrastructure/persistence/relational/entities/pizza-customization.entity';
import { PizzaConfigurationEntity } from '../../../../../pizza-configurations/infrastructure/persistence/relational/entities/pizza-configuration.entity';
@Entity({
  name: 'product',
})
export class ProductEntity extends EntityRelationalHelper {
  @PrimaryColumn({ type: 'varchar', length: 20 })
  id: string;
  @Column()
  name: string;
  @Column({ type: 'text', nullable: true })
  description: string | null;
  @Column({ type: 'decimal', precision: 10, scale: 2, nullable: true })
  price: number | null;
  @Column({ default: false })
  hasVariants: boolean;
  @Column({ default: true })
  isActive: boolean;
  @Column({ name: 'is_pizza', default: false })
  isPizza: boolean;
  @Column({ default: 0 })
  sortOrder: number;
  @Column({ name: 'subcategory_id', type: 'varchar', length: 20 })
  subcategoryId: string;
  @Column({ name: 'photo_id', nullable: true })
  photoId: string | null;
  @Column()
  estimatedPrepTime: number;
  @ManyToOne(() => FileEntity, { nullable: true })
  @JoinColumn({ name: 'photo_id' })
  photo: FileEntity | null;
  @ManyToOne(() => SubcategoryEntity, {
    nullable: false,
  })
  @JoinColumn({ name: 'subcategory_id' })
  subcategory: SubcategoryEntity;
  @OneToMany(() => ProductVariantEntity, (variant) => variant.product)
  variants: ProductVariantEntity[];
  @OneToMany(() => OrderItemEntity, (orderItem) => orderItem.product)
  orderItems: OrderItemEntity[];
  @ManyToMany(() => ModifierGroupEntity)
  @JoinTable({
    name: 'product_modifier_group',
    joinColumn: {
      name: 'product_id',
      referencedColumnName: 'id',
    },
    inverseJoinColumn: {
      name: 'modifier_group_id',
      referencedColumnName: 'id',
    },
  })
  modifierGroups: ModifierGroupEntity[];
  @Column({ name: 'preparation_screen_id', nullable: true, type: 'uuid' })
  preparationScreenId: string | null;
  @ManyToOne(
    () => PreparationScreenEntity,
    (preparationScreen) => preparationScreen.products,
    {
      nullable: true,
    },
  )
  @JoinColumn({ name: 'preparation_screen_id' })
  preparationScreen: PreparationScreenEntity | null;
  @ManyToMany(
    () => PizzaCustomizationEntity,
    (customization) => customization.products,
  )
  @JoinTable({
    name: 'product_pizza_customization',
    joinColumn: {
      name: 'product_id',
      referencedColumnName: 'id',
    },
    inverseJoinColumn: {
      name: 'pizza_customization_id',
      referencedColumnName: 'id',
    },
  })
  pizzaCustomizations: PizzaCustomizationEntity[];
  @OneToOne(() => PizzaConfigurationEntity, (config) => config.product)
  pizzaConfiguration: PizzaConfigurationEntity;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/products/infrastructure/persistence/relational/mappers/product.mapper.ts
================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { Product } from '../../../../domain/product';
import { ProductEntity } from '../entities/product.entity';
import { SubcategoryMapper } from '../../../../../subcategories/infrastructure/persistence/relational/mappers/subcategory.mapper';
import { FileMapper } from '../../../../../files/infrastructure/persistence/relational/mappers/file.mapper';
import { ProductVariantMapper } from '../../../../../product-variants/infrastructure/persistence/relational/mappers/product-variant.mapper';
import { ModifierGroupMapper } from '../../../../../modifier-groups/infrastructure/persistence/relational/mappers/modifier-group.mapper';
import { PreparationScreenMapper } from '../../../../../preparation-screens/infrastructure/persistence/relational/mappers/preparation-screen.mapper';
import { PizzaCustomizationMapper } from '../../../../../pizza-customizations/infrastructure/persistence/relational/mappers/pizza-customization.mapper';
import { PizzaConfigurationMapper } from '../../../../../pizza-configurations/infrastructure/persistence/relational/mappers/pizza-configuration.mapper';
import { SubcategoryEntity } from '../../../../../subcategories/infrastructure/persistence/relational/entities/subcategory.entity';
import { FileEntity } from '../../../../../files/infrastructure/persistence/relational/entities/file.entity';
import {
  BaseMapper,
  mapArray,
} from '../../../../../common/mappers/base.mapper';
import { ModifierGroupEntity } from '../../../../../modifier-groups/infrastructure/persistence/relational/entities/modifier-group.entity';
import { PreparationScreenEntity } from '../../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import { ProductVariantEntity } from '../../../../../product-variants/infrastructure/persistence/relational/entities/product-variant.entity';
import { PizzaCustomization } from '../../../../../pizza-customizations/domain/pizza-customization';
@Injectable()
export class ProductMapper extends BaseMapper<ProductEntity, Product> {
  constructor(
    @Inject(forwardRef(() => SubcategoryMapper))
    private readonly subcategoryMapper: SubcategoryMapper,
    private readonly fileMapper: FileMapper,
    @Inject(forwardRef(() => ProductVariantMapper))
    private readonly productVariantMapper: ProductVariantMapper,
    @Inject(forwardRef(() => ModifierGroupMapper))
    private readonly modifierGroupMapper: ModifierGroupMapper,
    @Inject(forwardRef(() => PreparationScreenMapper))
    private readonly preparationScreenMapper: PreparationScreenMapper,
    @Inject(forwardRef(() => PizzaCustomizationMapper))
    private readonly pizzaCustomizationMapper: PizzaCustomizationMapper,
    @Inject(forwardRef(() => PizzaConfigurationMapper))
    private readonly pizzaConfigurationMapper: PizzaConfigurationMapper,
  ) {
    super();
  }
  override toDomain(entity: ProductEntity): Product | null {
    if (!entity) return null;
    const domain = new Product();
    domain.id = entity.id;
    domain.name = entity.name;
    domain.description = entity.description;
    domain.price = entity.price;
    domain.hasVariants = entity.hasVariants;
    domain.isActive = entity.isActive;
    domain.isPizza = entity.isPizza;
    domain.sortOrder = entity.sortOrder;
    domain.subcategoryId = entity.subcategoryId;
    domain.photoId = entity.photoId;
    domain.estimatedPrepTime = entity.estimatedPrepTime;
    domain.preparationScreenId = entity.preparationScreenId;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    domain.photo = entity.photo ? this.fileMapper.toDomain(entity.photo) : null;
    domain.subcategory = entity.subcategory
      ? this.subcategoryMapper.toDomain(entity.subcategory)
      : null;
    domain.variants = mapArray(entity.variants, (variant) =>
      this.productVariantMapper.toDomain(variant),
    );
    domain.modifierGroups = mapArray(entity.modifierGroups, (group) =>
      this.modifierGroupMapper.toDomain(group),
    );
    if (entity.preparationScreen) {
      const screen = this.preparationScreenMapper.toDomain(
        entity.preparationScreen,
      );
      if (screen) {
        domain.preparationScreen = screen;
      }
    }
    if (entity.pizzaCustomizations) {
      domain.pizzaCustomizations = entity.pizzaCustomizations
        .map((customization) =>
          this.pizzaCustomizationMapper.toDomain(customization),
        )
        .filter((item): item is PizzaCustomization => item !== null);
    }
    if (entity.pizzaConfiguration) {
      const configuration = this.pizzaConfigurationMapper.toDomain(
        entity.pizzaConfiguration,
      );
      if (configuration) {
        domain.pizzaConfiguration = configuration;
      }
    }
    return domain;
  }
  override toEntity(domain: Product): ProductEntity | null {
    if (!domain) return null;
    const entity = new ProductEntity();
    if (domain.id) entity.id = domain.id;
    entity.name = domain.name;
    entity.description = domain.description;
    entity.price = domain.price;
    entity.hasVariants = domain.hasVariants;
    entity.isActive = domain.isActive;
    entity.isPizza = domain.isPizza;
    entity.sortOrder = domain.sortOrder;
    entity.subcategoryId = domain.subcategoryId;
    entity.subcategory = { id: domain.subcategoryId } as SubcategoryEntity;
    entity.photoId = domain.photoId || null;
    entity.photo = domain.photoId
      ? ({ id: domain.photoId } as FileEntity)
      : null;
    entity.estimatedPrepTime = domain.estimatedPrepTime;
    if (domain.preparationScreenId) {
      entity.preparationScreenId = domain.preparationScreenId;
      entity.preparationScreen = {
        id: domain.preparationScreenId,
      } as PreparationScreenEntity;
    } else if (domain.preparationScreen?.id) {
      entity.preparationScreenId = domain.preparationScreen.id;
      entity.preparationScreen = {
        id: domain.preparationScreen.id,
      } as PreparationScreenEntity;
    }
    if (domain.modifierGroups !== undefined) {
      entity.modifierGroups = domain.modifierGroups.map(
        (group) => ({ id: group.id }) as ModifierGroupEntity,
      );
    }
    if (domain.variants !== undefined) {
      entity.variants = domain.variants
        .map((variant) => this.productVariantMapper.toEntity(variant))
        .filter((entity): entity is ProductVariantEntity => entity !== null);
    }
    return entity;
  }
}

================
File: backend/src/products/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { forwardRef, Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ProductEntity } from './entities/product.entity';
import { ProductRelationalRepository } from './repositories/product.repository';
import { ModifierGroupEntity } from '../../../../modifier-groups/infrastructure/persistence/relational/entities/modifier-group.entity';
import { ProductMapper } from './mappers/product.mapper';
import { PRODUCT_REPOSITORY } from '../../../../common/tokens';
import { RelationalSubcategoryPersistenceModule } from '../../../../subcategories/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalFilePersistenceModule } from '../../../../files/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalProductVariantPersistenceModule } from '../../../../product-variants/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalModifierGroupPersistenceModule } from '../../../../modifier-groups/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalPreparationScreenPersistenceModule } from '../../../../preparation-screens/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalPizzaCustomizationPersistenceModule } from '../../../../pizza-customizations/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalPizzaConfigurationPersistenceModule } from '../../../../pizza-configurations/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([ProductEntity, ModifierGroupEntity]),
    forwardRef(() => RelationalSubcategoryPersistenceModule),
    RelationalFilePersistenceModule,
    forwardRef(() => RelationalProductVariantPersistenceModule),
    forwardRef(() => RelationalModifierGroupPersistenceModule),
    forwardRef(() => RelationalPreparationScreenPersistenceModule),
    forwardRef(() => RelationalPizzaCustomizationPersistenceModule),
    forwardRef(() => RelationalPizzaConfigurationPersistenceModule),
  ],
  providers: [
    {
      provide: PRODUCT_REPOSITORY,
      useClass: ProductRelationalRepository,
    },
    ProductMapper,
  ],
  exports: [PRODUCT_REPOSITORY, ProductMapper],
})
export class RelationalProductPersistenceModule {}

================
File: backend/src/products/products.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Put,
  UseGuards,
  Query,
  HttpStatus,
  HttpCode,
} from '@nestjs/common';
import { ProductsService } from './products.service';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { ApiBearerAuth, ApiOperation, ApiTags } from '@nestjs/swagger';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { FindAllProductsDto } from './dto/find-all-products.dto';
@ApiTags('Productos')
@Controller({
  path: 'products',
  version: '1',
})
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}
  @Post()
  @ApiOperation({
    summary: 'Crear un nuevo producto',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createProductDto: CreateProductDto) {
    return this.productsService.create(createProductDto);
  }
  @Get()
  @ApiOperation({
    summary: 'Obtener todos los productos',
  })
  @HttpCode(HttpStatus.OK)
  findAll(@Query() findAllProductsDto: FindAllProductsDto) {
    return this.productsService.findAll(findAllProductsDto);
  }
  @Get('pizzas/all')
  @ApiOperation({
    summary: 'Obtener todos los productos tipo pizza',
  })
  @HttpCode(HttpStatus.OK)
  findAllPizzas() {
    return this.productsService.findAllPizzas();
  }
  @Get(':id')
  @ApiOperation({
    summary: 'Obtener un producto por ID',
  })
  @HttpCode(HttpStatus.OK)
  findOne(@Param('id') id: string) {
    return this.productsService.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({
    summary: 'Actualizar un producto',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  update(@Param('id') id: string, @Body() updateProductDto: UpdateProductDto) {
    return this.productsService.update(id, updateProductDto);
  }
  @Delete(':id')
  @ApiOperation({
    summary: 'Eliminar un producto',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id') id: string) {
    return this.productsService.remove(id);
  }
  @Get(':id/pizza-customizations')
  @ApiOperation({
    summary: 'Obtener las personalizaciones de pizza de un producto',
  })
  @HttpCode(HttpStatus.OK)
  async getPizzaCustomizations(@Param('id') id: string) {
    return this.productsService.getPizzaCustomizations(id);
  }
  @Put(':id/pizza-customizations')
  @ApiOperation({
    summary: 'Actualizar las personalizaciones de pizza de un producto',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  async updatePizzaCustomizations(
    @Param('id') id: string,
    @Body() customizationIds: string[],
  ) {
    return this.productsService.updatePizzaCustomizations(id, customizationIds);
  }
}

================
File: backend/src/products/products.module.ts
================
import { Module } from '@nestjs/common';
import { ProductsService } from './products.service';
import { ProductsController } from './products.controller';
import { RelationalProductPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { ProductVariantsModule } from '../product-variants/product-variants.module';
import { ModifierGroupsModule } from '../modifier-groups/modifier-groups.module';
import { RelationalPreparationScreenPersistenceModule } from '../preparation-screens/infrastructure/persistence/relational/relational-persistence.module';
import { PizzaCustomizationsModule } from '../pizza-customizations/pizza-customizations.module';
import { PizzaConfigurationsModule } from '../pizza-configurations/pizza-configurations.module';
import { CommonModule } from '../common/common.module';
@Module({
  imports: [
    RelationalProductPersistenceModule,
    ProductVariantsModule,
    ModifierGroupsModule,
    RelationalPreparationScreenPersistenceModule,
    PizzaCustomizationsModule,
    PizzaConfigurationsModule,
    CommonModule,
  ],
  controllers: [ProductsController],
  providers: [ProductsService],
  exports: [ProductsService],
})
export class ProductsModule {}

================
File: backend/src/products/products.service.ts
================
import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { ERROR_CODES } from '../common/constants/error-codes.constants';
import { CustomConflictException } from '../common/exceptions/custom-conflict.exception';
import { ProductRepository } from './infrastructure/persistence/product.repository';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { Product } from './domain/product';
import { FindAllProductsDto } from './dto/find-all-products.dto';
import { ProductVariantRepository } from '../product-variants/infrastructure/persistence/product-variant.repository';
import { ProductVariant } from '../product-variants/domain/product-variant';
import { ModifierGroupRepository } from '../modifier-groups/infrastructure/persistence/modifier-group.repository';
import { ModifierGroup } from '../modifier-groups/domain/modifier-group';
import { PreparationScreenRepository } from '../preparation-screens/infrastructure/persistence/preparation-screen.repository';
import {
  PRODUCT_REPOSITORY,
  PRODUCT_VARIANT_REPOSITORY,
  MODIFIER_GROUP_REPOSITORY,
  PREPARATION_SCREEN_REPOSITORY,
} from '../common/tokens';
import { Paginated } from '../common/types/paginated.type';
import {
  CustomIdService,
  EntityPrefix,
} from '../common/services/custom-id.service';
@Injectable()
export class ProductsService {
  constructor(
    @Inject(PRODUCT_REPOSITORY)
    private readonly productRepository: ProductRepository,
    @Inject(PRODUCT_VARIANT_REPOSITORY)
    private readonly productVariantRepository: ProductVariantRepository,
    @Inject(MODIFIER_GROUP_REPOSITORY)
    private readonly modifierGroupRepository: ModifierGroupRepository,
    @Inject(PREPARATION_SCREEN_REPOSITORY)
    private readonly preparationScreenRepository: PreparationScreenRepository,
    private readonly customIdService: CustomIdService,
  ) {}
  async create(createProductDto: CreateProductDto): Promise<Product> {
    const existingProducts = await this.productRepository.findAll({
      page: 1,
      limit: 1,
      search: createProductDto.name,
    });
    if (
      existingProducts.items.length > 0 &&
      existingProducts.items[0].name === createProductDto.name
    ) {
      throw new CustomConflictException(
        `Ya existe un producto con el nombre "${createProductDto.name}"`,
        ERROR_CODES.PRODUCT_NAME_EXISTS,
      );
    }
    const product = new Product();
    product.id = await this.customIdService.generateId(
      EntityPrefix.PRODUCT,
      'product',
    );
    product.name = createProductDto.name;
    product.description = createProductDto.description ?? null;
    product.price = createProductDto.price ?? null;
    product.hasVariants = createProductDto.hasVariants ?? false;
    product.isActive = createProductDto.isActive ?? true;
    product.isPizza = createProductDto.isPizza ?? false;
    product.subcategoryId = createProductDto.subcategoryId;
    product.estimatedPrepTime = createProductDto.estimatedPrepTime;
    product.photoId = createProductDto.photoId ?? null;
    if (createProductDto.photoId) {
      product.photo = {
        id: createProductDto.photoId,
        path: '',
      };
    }
    if (
      createProductDto.modifierGroupIds &&
      createProductDto.modifierGroupIds.length > 0
    ) {
      const modifierGroups: ModifierGroup[] = [];
      for (const groupId of createProductDto.modifierGroupIds) {
        try {
          const group = await this.modifierGroupRepository.findById(groupId);
          if (!group) {
            throw new NotFoundException(
              `ModifierGroup with ID ${groupId} not found during creation`,
            );
          }
          modifierGroups.push(group);
        } catch (error) {
          if (error instanceof NotFoundException) {
            throw error;
          }
          throw error;
        }
      }
      product.modifierGroups = modifierGroups;
    } else {
      product.modifierGroups = [];
    }
    // preparationScreenId es opcional
    if (createProductDto.preparationScreenId) {
      try {
        const screen = await this.preparationScreenRepository.findOne(
          createProductDto.preparationScreenId,
        );
        product.preparationScreen = screen;
        product.preparationScreenId = createProductDto.preparationScreenId;
      } catch (error) {
        if (error instanceof NotFoundException) {
          throw new NotFoundException(
            `PreparationScreen with ID ${createProductDto.preparationScreenId} not found during product creation`,
          );
        }
        throw error;
      }
    } else {
      product.preparationScreen = null;
      product.preparationScreenId = null;
    }
    const createdProduct = await this.productRepository.create(product);
    if (
      createProductDto.hasVariants &&
      createProductDto.variants &&
      createProductDto.variants.length > 0
    ) {
      const variants: ProductVariant[] = [];
      for (const variantDto of createProductDto.variants) {
        const variantToCreate = new ProductVariant();
        variantToCreate.id = await this.customIdService.generateId(
          EntityPrefix.PRODUCT_VARIANT,
          'product_variant',
        );
        variantToCreate.productId = createdProduct.id;
        variantToCreate.name = variantDto.name;
        variantToCreate.price = variantDto.price;
        variantToCreate.isActive = variantDto.isActive ?? true;
        const variant =
          await this.productVariantRepository.create(variantToCreate);
        variants.push(variant);
      }
      createdProduct.variants = variants;
    }
    return this.productRepository.findOne(
      createdProduct.id,
    ) as Promise<Product>;
  }
  async findAll(
    findAllProductsDto: FindAllProductsDto,
  ): Promise<Paginated<Product>> {
    return this.productRepository.findAll({
      page: findAllProductsDto.page || 1,
      limit: findAllProductsDto.limit || 10,
      subcategoryId: findAllProductsDto.subcategoryId,
      hasVariants: findAllProductsDto.hasVariants,
      isActive: findAllProductsDto.isActive,
      search: findAllProductsDto.search,
    });
  }
  async findOne(id: string): Promise<Product> {
    const product = await this.productRepository.findOne(id);
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
    return product;
  }
  async update(
    id: string,
    updateProductDto: UpdateProductDto,
  ): Promise<Product> {
    const product = await this.productRepository.findOne(id);
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
    if (updateProductDto.name && updateProductDto.name !== product.name) {
      const existingProducts = await this.productRepository.findAll({
        page: 1,
        limit: 1,
        search: updateProductDto.name,
      });
      if (
        existingProducts.items.length > 0 &&
        existingProducts.items[0].name === updateProductDto.name &&
        existingProducts.items[0].id !== id
      ) {
        throw new CustomConflictException(
          `Ya existe un producto con el nombre "${updateProductDto.name}"`,
          ERROR_CODES.PRODUCT_NAME_EXISTS,
        );
      }
    }
    product.name = updateProductDto.name ?? product.name;
    product.description =
      updateProductDto.description === null
        ? null
        : (updateProductDto.description ?? product.description);
    product.price =
      updateProductDto.price === null
        ? null
        : (updateProductDto.price ?? product.price);
    product.hasVariants = updateProductDto.hasVariants ?? product.hasVariants;
    product.isActive = updateProductDto.isActive ?? product.isActive;
    product.isPizza = updateProductDto.isPizza ?? product.isPizza;
    product.subcategoryId =
      updateProductDto.subcategoryId ?? product.subcategoryId;
    product.estimatedPrepTime =
      updateProductDto.estimatedPrepTime ?? product.estimatedPrepTime;
    if (updateProductDto.photoId !== undefined) {
      product.photo = updateProductDto.photoId
        ? {
            id: updateProductDto.photoId,
            path: '', // Path se resolverá en el dominio si es necesario
          }
        : null;
      product.photoId = updateProductDto.photoId; // Asegurar que photoId también se actualice
    }
    // Actualizar grupos de modificadores
    if (updateProductDto.modifierGroupIds !== undefined) {
      if (updateProductDto.modifierGroupIds.length > 0) {
        const modifierGroups: ModifierGroup[] = [];
        for (const groupId of updateProductDto.modifierGroupIds) {
          try {
            // Usar repositorio en lugar de servicio
            const group = await this.modifierGroupRepository.findById(groupId);
            if (!group) {
              // Manejar caso donde findById devuelve null
              throw new NotFoundException(
                `ModifierGroup with ID ${groupId} not found during update`,
              );
            }
            modifierGroups.push(group);
          } catch (error) {
            // Mantener el manejo de NotFoundException por si findById lanza otro error
            if (error instanceof NotFoundException) {
              throw error; // Re-lanzar
            }
            throw error; // Lanzar otros errores
          }
        }
        product.modifierGroups = modifierGroups;
      } else {
        product.modifierGroups = []; // Vaciar si el array está vacío
      }
    }
    // Actualizar pantalla de preparación
    if (updateProductDto.preparationScreenId !== undefined) {
      if (updateProductDto.preparationScreenId === null) {
        // Si se envía null, remover la pantalla de preparación
        product.preparationScreen = null;
        product.preparationScreenId = null;
      } else {
        // Si se envía un ID, buscar y asignar la pantalla
        try {
          const screen = await this.preparationScreenRepository.findOne(
            updateProductDto.preparationScreenId,
          );
          product.preparationScreen = screen;
          product.preparationScreenId = screen.id;
        } catch (error) {
          if (error instanceof NotFoundException) {
            throw new NotFoundException(
              `PreparationScreen with ID ${updateProductDto.preparationScreenId} not found during product update`,
            );
          }
          throw error;
        }
      }
    }
    // Guardar el producto actualizado (incluyendo relaciones actualizadas)
    // Usar 'save' para que TypeORM maneje las relaciones ManyToMany correctamente
    const savedProduct = await this.productRepository.save(product);
    if (updateProductDto.variants !== undefined) {
      const currentVariants =
        await this.productVariantRepository.findAllByProductId(id);
      const currentVariantIds = currentVariants.map((v) => v.id);
      const incomingVariantsData = updateProductDto.variants || [];
      const incomingVariantIds = new Set(
        incomingVariantsData.filter((v) => v.id).map((v) => v.id as string),
      );
      const processedVariantIds: string[] = [];
      for (const variantDto of incomingVariantsData) {
        if (variantDto.id) {
          if (currentVariantIds.includes(variantDto.id)) {
            const currentVariant = currentVariants.find(
              (v) => v.id === variantDto.id,
            );
            if (currentVariant) {
              const variantToUpdate = new ProductVariant();
              variantToUpdate.id = variantDto.id;
              variantToUpdate.productId = id;
              variantToUpdate.name = variantDto.name ?? currentVariant.name;
              variantToUpdate.price = variantDto.price ?? currentVariant.price;
              variantToUpdate.isActive =
                variantDto.isActive ?? currentVariant.isActive;
              await this.productVariantRepository.update(
                variantDto.id,
                variantToUpdate,
              );
              processedVariantIds.push(variantDto.id);
            }
          } else {
          }
        } else {
          const variantToCreate = new ProductVariant();
          variantToCreate.id = await this.customIdService.generateId(
            EntityPrefix.PRODUCT_VARIANT,
            'product_variant',
          );
          variantToCreate.productId = id;
          variantToCreate.name = variantDto.name || '';
          variantToCreate.price = variantDto.price || 0;
          variantToCreate.isActive = variantDto.isActive ?? true;
          const newVariant =
            await this.productVariantRepository.create(variantToCreate);
          processedVariantIds.push(newVariant.id);
        }
      }
      const variantsToDelete = currentVariants.filter(
        (v) => !incomingVariantIds.has(v.id),
      );
      for (const variantToDelete of variantsToDelete) {
        await this.productVariantRepository.softDelete(variantToDelete.id);
      }
    }
    return this.productRepository.findOne(savedProduct.id) as Promise<Product>;
  }
  async remove(id: string): Promise<void> {
    await this.productRepository.softDelete(id);
  }
  async findAllPizzas(): Promise<Product[]> {
    return this.productRepository.findAllPizzas();
  }
  async findAllBySubcategoryId(subcategoryId: string): Promise<Product[]> {
    const result = await this.productRepository.findAll({
      page: 1,
      limit: 1000,
      subcategoryId,
    });
    return result.items;
  }
  async getPizzaCustomizations(id: string): Promise<any[]> {
    const product =
      await this.productRepository.findOneWithPizzaCustomizations(id);
    if (!product) {
      throw new NotFoundException(
        `Producto con ID ${id} no encontrado`,
        ERROR_CODES.PRODUCT_NOT_FOUND,
      );
    }
    return product.pizzaCustomizations || [];
  }
  async updatePizzaCustomizations(
    id: string,
    customizationIds: string[],
  ): Promise<Product> {
    const product = await this.productRepository.findOne(id);
    if (!product) {
      throw new NotFoundException(
        `Producto con ID ${id} no encontrado`,
        ERROR_CODES.PRODUCT_NOT_FOUND,
      );
    }
    await this.productRepository.updatePizzaCustomizations(
      id,
      customizationIds,
    );
    const updatedProduct =
      await this.productRepository.findOneWithPizzaCustomizations(id);
    if (!updatedProduct) {
      throw new NotFoundException(
        `Producto con ID ${id} no encontrado después de actualizar`,
        ERROR_CODES.PRODUCT_NOT_FOUND,
      );
    }
    return updatedProduct;
  }
}

================
File: backend/src/restaurant-config/domain/business-hours.ts
================
import { RestaurantConfig } from './restaurant-config';
export class BusinessHours {
  id: string;
  dayOfWeek: number;
  openingTime: string | null;
  closingTime: string | null;
  isClosed: boolean;
  restaurantConfigId: string;
  restaurantConfig?: RestaurantConfig;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/restaurant-config/dto/business-hours.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
export class BusinessHoursDto {
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  id: string;
  @ApiProperty({
    type: Number,
    example: 1,
    description: 'Día de la semana (0 = Domingo, 1 = Lunes, ... 6 = Sábado)',
  })
  dayOfWeek: number;
  @ApiPropertyOptional({
    type: String,
    example: '09:00',
    description: 'Hora de apertura en formato HH:mm (null si está cerrado)',
    nullable: true,
  })
  openingTime: string | null;
  @ApiPropertyOptional({
    type: String,
    example: '22:00',
    description: 'Hora de cierre en formato HH:mm (null si está cerrado)',
    nullable: true,
  })
  closingTime: string | null;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si el restaurante está cerrado ese día',
  })
  isClosed: boolean;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description: 'ID de la configuración del restaurante',
  })
  restaurantConfigId: string;
  @ApiProperty()
  createdAt: Date;
  @ApiProperty()
  updatedAt: Date;
}

================
File: backend/src/restaurant-config/dto/create-business-hours.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsInt,
  IsOptional,
  IsString,
  IsUUID,
  Max,
  Min,
  Matches,
} from 'class-validator';
export class CreateBusinessHoursDto {
  @ApiProperty({
    type: Number,
    example: 1,
    description: 'Día de la semana (0 = Domingo, 1 = Lunes, ... 6 = Sábado)',
    minimum: 0,
    maximum: 6,
  })
  @IsInt()
  @Min(0)
  @Max(6)
  dayOfWeek: number;
  @ApiProperty({
    type: String,
    example: '09:00',
    description: 'Hora de apertura en formato HH:mm (null si está cerrado)',
    nullable: true,
  })
  @IsOptional()
  @IsString()
  @Matches(/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/, {
    message: 'openingTime debe estar en formato HH:mm',
  })
  openingTime?: string | null;
  @ApiProperty({
    type: String,
    example: '22:00',
    description: 'Hora de cierre en formato HH:mm (null si está cerrado)',
    nullable: true,
  })
  @IsOptional()
  @IsString()
  @Matches(/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/, {
    message: 'closingTime debe estar en formato HH:mm',
  })
  closingTime?: string | null;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si el restaurante está cerrado ese día',
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isClosed?: boolean;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description: 'ID de la configuración del restaurante',
  })
  @IsUUID()
  restaurantConfigId: string;
}

================
File: backend/src/restaurant-config/dto/update-business-hours.dto.ts
================
import { PartialType } from '@nestjs/swagger';
import { CreateBusinessHoursDto } from './create-business-hours.dto';
export class UpdateBusinessHoursDto extends PartialType(
  CreateBusinessHoursDto,
) {}

================
File: backend/src/restaurant-config/infrastructure/persistence/relational/entities/business-hours.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  Unique,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { RestaurantConfigEntity } from './restaurant-config.entity';
@Entity({
  name: 'business_hours',
})
@Unique(['restaurantConfigId', 'dayOfWeek'])
export class BusinessHoursEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ type: 'int' })
  dayOfWeek: number;
  @Column({ type: 'time', nullable: true })
  openingTime: string | null;
  @Column({ type: 'time', nullable: true })
  closingTime: string | null;
  @Column({ type: 'boolean', default: false })
  isClosed: boolean;
  @Column({ name: 'restaurant_config_id', type: 'uuid' })
  restaurantConfigId: string;
  @ManyToOne(() => RestaurantConfigEntity, (config) => config.businessHours)
  @JoinColumn({ name: 'restaurant_config_id' })
  restaurantConfig: RestaurantConfigEntity;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/restaurant-config/infrastructure/persistence/relational/mappers/business-hours.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { BusinessHours } from '../../../../domain/business-hours';
import { BusinessHoursEntity } from '../entities/business-hours.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
import { RestaurantConfigEntity } from '../entities/restaurant-config.entity';
@Injectable()
export class BusinessHoursMapper extends BaseMapper<
  BusinessHoursEntity,
  BusinessHours
> {
  override toDomain(entity: BusinessHoursEntity): BusinessHours | null {
    if (!entity) {
      return null;
    }
    const domain = new BusinessHours();
    domain.id = entity.id;
    domain.dayOfWeek = entity.dayOfWeek;
    domain.openingTime = entity.openingTime;
    domain.closingTime = entity.closingTime;
    domain.isClosed = entity.isClosed;
    domain.restaurantConfigId = entity.restaurantConfigId;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: BusinessHours): BusinessHoursEntity | null {
    if (!domain) {
      return null;
    }
    const entity = new BusinessHoursEntity();
    if (domain.id) entity.id = domain.id;
    entity.dayOfWeek = domain.dayOfWeek;
    entity.openingTime = domain.openingTime;
    entity.closingTime = domain.closingTime;
    entity.isClosed = domain.isClosed;
    entity.restaurantConfig = {
      id: domain.restaurantConfigId,
    } as RestaurantConfigEntity;
    return entity;
  }
}

================
File: backend/src/restaurant-config/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { RestaurantConfigEntity } from './entities/restaurant-config.entity';
import { BusinessHoursEntity } from './entities/business-hours.entity';
import { RestaurantConfigRepository } from '../restaurant-config.repository';
import { RestaurantConfigRelationalRepository } from './repositories/restaurant-config.repository';
import { RestaurantConfigMapper } from './mappers/restaurant-config.mapper';
import { BusinessHoursMapper } from './mappers/business-hours.mapper';
@Module({
  imports: [
    TypeOrmModule.forFeature([RestaurantConfigEntity, BusinessHoursEntity]),
  ],
  providers: [
    {
      provide: RestaurantConfigRepository,
      useClass: RestaurantConfigRelationalRepository,
    },
    RestaurantConfigMapper,
    BusinessHoursMapper,
  ],
  exports: [RestaurantConfigRepository],
})
export class RelationalRestaurantConfigPersistenceModule {}

================
File: backend/src/restaurant-config/infrastructure/persistence/relational/repositories/restaurant-config.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { RestaurantConfigEntity } from '../entities/restaurant-config.entity';
import { BusinessHoursEntity } from '../entities/business-hours.entity';
import { RestaurantConfigRepository } from '../../restaurant-config.repository';
import { RestaurantConfig } from '../../../../domain/restaurant-config';
import { RestaurantConfigMapper } from '../mappers/restaurant-config.mapper';
@Injectable()
export class RestaurantConfigRelationalRepository
  implements RestaurantConfigRepository
{
  constructor(
    @InjectRepository(RestaurantConfigEntity)
    private readonly restaurantConfigRepository: Repository<RestaurantConfigEntity>,
    @InjectRepository(BusinessHoursEntity)
    private readonly businessHoursRepository: Repository<BusinessHoursEntity>,
    private readonly restaurantConfigMapper: RestaurantConfigMapper,
  ) {}
  async findFirst(): Promise<RestaurantConfig | null> {
    const entity = await this.restaurantConfigRepository.findOne({
      where: {},
      order: { createdAt: 'ASC' },
      relations: ['businessHours'],
    });
    return entity ? this.restaurantConfigMapper.toDomain(entity) : null;
  }
  async create(data: RestaurantConfig): Promise<RestaurantConfig> {
    const persistenceModel = this.restaurantConfigMapper.toPersistence(data);
    const newEntity = await this.restaurantConfigRepository.save(
      this.restaurantConfigRepository.create(persistenceModel),
    );
    const entityWithRelations = await this.restaurantConfigRepository.findOne({
      where: { id: newEntity.id },
      relations: ['businessHours'],
    });
    return this.restaurantConfigMapper.toDomain(entityWithRelations!);
  }
  async update(
    id: string,
    data: Partial<RestaurantConfig>,
  ): Promise<RestaurantConfig | null> {
    const { businessHours, ...updateData } = data;
    if (Object.keys(updateData).length > 0) {
      await this.restaurantConfigRepository.update(id, updateData);
    }
    if (businessHours && businessHours.length > 0) {
      await this.businessHoursRepository.delete({ restaurantConfigId: id });
      const newBusinessHours = businessHours.map((hour) =>
        this.businessHoursRepository.create({
          ...hour,
          restaurantConfigId: id,
        }),
      );
      await this.businessHoursRepository.save(newBusinessHours);
    }
    const entity = await this.restaurantConfigRepository.findOne({
      where: { id },
      relations: ['businessHours'],
    });
    return entity ? this.restaurantConfigMapper.toDomain(entity) : null;
  }
}

================
File: backend/src/restaurant-config/infrastructure/persistence/restaurant-config.repository.ts
================
import { RestaurantConfig } from '../../domain/restaurant-config';
export abstract class RestaurantConfigRepository {
  abstract findFirst(): Promise<RestaurantConfig | null>;
  abstract create(data: RestaurantConfig): Promise<RestaurantConfig>;
  abstract update(
    id: string,
    data: Partial<RestaurantConfig>,
  ): Promise<RestaurantConfig | null>;
}

================
File: backend/src/restaurant-config/restaurant-config.controller.ts
================
import {
  Controller,
  Get,
  Body,
  Put,
  UseGuards,
  HttpStatus,
  HttpCode,
  SerializeOptions,
} from '@nestjs/common';
import { RestaurantConfigService } from './restaurant-config.service';
import { UpdateRestaurantConfigDto } from './dto/update-restaurant-config.dto';
import { ApiBearerAuth, ApiOkResponse, ApiTags } from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { RestaurantConfigDto } from './dto/restaurant-config.dto';
@ApiTags('Restaurant Config')
@Controller({
  path: 'restaurant-config',
  version: '1',
})
@UseGuards(AuthGuard('jwt'), RolesGuard)
export class RestaurantConfigController {
  constructor(
    private readonly restaurantConfigService: RestaurantConfigService,
  ) {}
  @Get()
  @ApiBearerAuth()
  @Roles(
    RoleEnum.admin,
    RoleEnum.manager,
    RoleEnum.cashier,
    RoleEnum.waiter,
    RoleEnum.kitchen,
    RoleEnum.delivery,
  )
  @ApiOkResponse({
    type: RestaurantConfigDto,
  })
  @HttpCode(HttpStatus.OK)
  async getConfig(): Promise<RestaurantConfigDto> {
    return this.restaurantConfigService.getConfig();
  }
  @Put()
  @ApiBearerAuth()
  @Roles(RoleEnum.admin)
  @ApiOkResponse({
    type: RestaurantConfigDto,
  })
  @HttpCode(HttpStatus.OK)
  @SerializeOptions({
    groups: ['admin'],
  })
  async updateConfig(
    @Body() updateRestaurantConfigDto: UpdateRestaurantConfigDto,
  ): Promise<RestaurantConfigDto> {
    return this.restaurantConfigService.updateConfig(updateRestaurantConfigDto);
  }
}

================
File: backend/src/roles/domain/role.ts
================
import { Allow } from 'class-validator';
export class Role {
  @Allow()
  id: number | string;
  @Allow()
  name: string | null;
}

================
File: backend/src/roles/dto/role.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNumber } from 'class-validator';
export class RoleDto {
  @ApiProperty()
  @IsNumber()
  id: number | string;
}

================
File: backend/src/roles/infrastructure/persistence/relational/entities/role.entity.ts
================
import { Column, Entity, PrimaryColumn } from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
@Entity({
  name: 'role',
})
export class RoleEntity extends EntityRelationalHelper {
  @PrimaryColumn()
  id: number;
  @Column()
  name?: string;
}

================
File: backend/src/roles/roles.decorator.ts
================
import { SetMetadata } from '@nestjs/common';
export const Roles = (...roles: number[]) => SetMetadata('roles', roles);

================
File: backend/src/roles/roles.enum.ts
================
export enum RoleEnum {
  'admin' = 1,
  'manager' = 2,
  'cashier' = 3,
  'waiter' = 4,
  'kitchen' = 5,
  'delivery' = 6,
}

================
File: backend/src/roles/roles.guard.ts
================
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}
  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.getAllAndOverride<(number | string)[]>(
      'roles',
      [context.getClass(), context.getHandler()],
    );
    if (!roles.length) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    return roles.map(String).includes(String(request.user?.role?.id));
  }
}

================
File: backend/src/selected-pizza-customizations/domain/enums/customization-action.enum.ts
================
export enum CustomizationAction {
  ADD = 'ADD',
  REMOVE = 'REMOVE',
}

================
File: backend/src/selected-pizza-customizations/domain/enums/pizza-half.enum.ts
================
export enum PizzaHalf {
  FULL = 'FULL',
  HALF_1 = 'HALF_1',
  HALF_2 = 'HALF_2',
}

================
File: backend/src/selected-pizza-customizations/domain/selected-pizza-customization.ts
================
import { CustomizationAction } from './enums/customization-action.enum';
import { PizzaHalf } from './enums/pizza-half.enum';
import { PizzaCustomization } from '../../pizza-customizations/domain/pizza-customization';
export class SelectedPizzaCustomization {
  id: string;
  orderItemId: string;
  pizzaCustomizationId: string;
  pizzaCustomization?: PizzaCustomization;
  half: PizzaHalf;
  action: CustomizationAction;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
}

================
File: backend/src/selected-pizza-customizations/dto/create-selected-pizza-customization.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { CustomizationAction } from '../domain/enums/customization-action.enum';
import { PizzaHalf } from '../domain/enums/pizza-half.enum';
export class CreateSelectedPizzaCustomizationDto {
  @ApiProperty({ example: 'PEPPERONI' })
  @IsNotEmpty()
  @IsString()
  pizzaCustomizationId: string;
  @ApiProperty({
    enum: PizzaHalf,
    example: PizzaHalf.FULL,
    description: 'Which half of the pizza',
  })
  @IsEnum(PizzaHalf)
  half: PizzaHalf;
  @ApiProperty({
    enum: CustomizationAction,
    example: CustomizationAction.ADD,
    description: 'Add or remove customization',
  })
  @IsEnum(CustomizationAction)
  action: CustomizationAction;
}

================
File: backend/src/selected-pizza-customizations/infrastructure/persistence/relational/entities/selected-pizza-customization.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  Unique,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { OrderItemEntity } from '../../../../../orders/infrastructure/persistence/relational/entities/order-item.entity';
import { PizzaCustomizationEntity } from '../../../../../pizza-customizations/infrastructure/persistence/relational/entities/pizza-customization.entity';
import { CustomizationAction } from '../../../../domain/enums/customization-action.enum';
import { PizzaHalf } from '../../../../domain/enums/pizza-half.enum';
@Entity({
  name: 'selected_pizza_customization',
})
@Unique(['orderItemId', 'pizzaCustomizationId', 'half', 'action'])
export class SelectedPizzaCustomizationEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ name: 'order_item_id', type: 'uuid' })
  orderItemId: string;
  @Column({ name: 'pizza_customization_id', type: 'varchar', length: 50 })
  pizzaCustomizationId: string;
  @Column({
    type: 'enum',
    enum: PizzaHalf,
    default: PizzaHalf.FULL,
  })
  half: PizzaHalf;
  @Column({
    type: 'enum',
    enum: CustomizationAction,
    default: CustomizationAction.ADD,
  })
  action: CustomizationAction;
  @ManyToOne(
    () => OrderItemEntity,
    (orderItem) => orderItem.selectedPizzaCustomizations,
  )
  @JoinColumn({ name: 'order_item_id' })
  orderItem: OrderItemEntity;
  @ManyToOne(
    () => PizzaCustomizationEntity,
    (pizzaCustomization) => pizzaCustomization.selectedPizzaCustomizations,
  )
  @JoinColumn({ name: 'pizza_customization_id' })
  pizzaCustomization: PizzaCustomizationEntity;
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/session/domain/session.ts
================
import { User } from '../../users/domain/user';
export class Session {
  id: number | string;
  user: User;
  hash: string;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date;
}

================
File: backend/src/session/infrastructure/persistence/relational/entities/session.entity.ts
================
import {
  CreateDateColumn,
  Entity,
  Index,
  ManyToOne,
  PrimaryGeneratedColumn,
  DeleteDateColumn,
  Column,
  UpdateDateColumn,
} from 'typeorm';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
@Entity({
  name: 'session',
})
export class SessionEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn()
  id: number;
  @ManyToOne(() => UserEntity, {
    eager: true,
  })
  @Index()
  user: UserEntity;
  @Column()
  hash: string;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date;
}

================
File: backend/src/session/infrastructure/persistence/relational/mappers/session.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { UserMapper } from '../../../../../users/infrastructure/persistence/relational/mappers/user.mapper';
import { Session } from '../../../../domain/session';
import { SessionEntity } from '../entities/session.entity';
@Injectable()
export class SessionMapper extends BaseMapper<SessionEntity, Session> {
  constructor(private readonly userMapper: UserMapper) {
    super();
  }
  override toDomain(raw: SessionEntity): Session {
    const domain = new Session();
    domain.id = raw.id;
    if (!raw.user) {
      throw new Error('Session must have a user');
    }
    const user = this.userMapper.toDomain(raw.user);
    if (!user) {
      throw new Error('Failed to map user');
    }
    domain.user = user;
    domain.hash = raw.hash;
    domain.createdAt = raw.createdAt;
    domain.updatedAt = raw.updatedAt;
    domain.deletedAt = raw.deletedAt;
    return domain;
  }
  override toEntity(domain: Session): SessionEntity {
    const user = new UserEntity();
    user.id = domain.user.id;
    const entity = new SessionEntity();
    if (domain.id !== null && domain.id !== undefined) {
      const numericId = Number(domain.id);
      if (!isNaN(numericId)) {
        entity.id = numericId;
      }
    }
    entity.hash = domain.hash;
    entity.user = user;
    return entity;
  }
}

================
File: backend/src/session/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { SessionRelationalRepository } from './repositories/session.repository';
import { TypeOrmModule } from '@nestjs/typeorm';
import { SessionEntity } from './entities/session.entity';
import { SESSION_REPOSITORY } from '../../../../common/tokens';
import { SessionMapper } from './mappers/session.mapper';
import { RelationalUserPersistenceModule } from '../../../../users/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([SessionEntity]),
    RelationalUserPersistenceModule,
  ],
  providers: [
    {
      provide: SESSION_REPOSITORY,
      useClass: SessionRelationalRepository,
    },
    SessionMapper,
  ],
  exports: [SESSION_REPOSITORY],
})
export class RelationalSessionPersistenceModule {}

================
File: backend/src/session/infrastructure/persistence/relational/repositories/session.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Not, Repository } from 'typeorm';
import { SessionEntity } from '../entities/session.entity';
import { NullableType } from '../../../../../utils/types/nullable.type';
import { SessionRepository } from '../../session.repository';
import { Session } from '../../../../domain/session';
import { SessionMapper } from '../mappers/session.mapper';
import { User } from '../../../../../users/domain/user';
@Injectable()
export class SessionRelationalRepository implements SessionRepository {
  constructor(
    @InjectRepository(SessionEntity)
    private readonly sessionRepository: Repository<SessionEntity>,
    private readonly sessionMapper: SessionMapper,
  ) {}
  async findById(id: Session['id']): Promise<NullableType<Session>> {
    if (!id || id === null || id === undefined) {
      return null;
    }
    const numericId = Number(id);
    if (isNaN(numericId)) {
      return null;
    }
    const entity = await this.sessionRepository.findOne({
      where: {
        id: numericId,
      },
    });
    return entity ? this.sessionMapper.toDomain(entity) : null;
  }
  async create(data: Session): Promise<Session> {
    const persistenceModel = this.sessionMapper.toEntity(data);
    const createdEntity = await this.sessionRepository.save(
      this.sessionRepository.create(persistenceModel),
    );
    const entityWithRelations = await this.sessionRepository.findOne({
      where: { id: createdEntity.id },
      relations: ['user', 'user.role'],
    });
    if (!entityWithRelations) {
      throw new Error('Failed to create session');
    }
    return this.sessionMapper.toDomain(entityWithRelations);
  }
  async update(
    id: Session['id'],
    payload: Partial<
      Omit<Session, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>
    >,
  ): Promise<Session | null> {
    if (!id || id === null || id === undefined) {
      throw new Error('Session ID is required');
    }
    const numericId = Number(id);
    if (isNaN(numericId)) {
      throw new Error('Invalid session ID');
    }
    const entity = await this.sessionRepository.findOne({
      where: { id: numericId },
    });
    if (!entity) {
      throw new Error('Session not found');
    }
    const updatedEntity = await this.sessionRepository.save(
      this.sessionRepository.create(
        this.sessionMapper.toEntity({
          ...this.sessionMapper.toDomain(entity),
          ...payload,
        }),
      ),
    );
    return this.sessionMapper.toDomain(updatedEntity);
  }
  async deleteById(id: Session['id']): Promise<void> {
    if (!id || id === null || id === undefined) {
      return;
    }
    const numericId = Number(id);
    if (isNaN(numericId)) {
      return;
    }
    await this.sessionRepository.softDelete({
      id: numericId,
    });
  }
  async deleteByUserId(conditions: { userId: User['id'] }): Promise<void> {
    await this.sessionRepository.softDelete({
      user: {
        id: conditions.userId,
      },
    });
  }
  async deleteByUserIdWithExclude(conditions: {
    userId: User['id'];
    excludeSessionId: Session['id'];
  }): Promise<void> {
    if (
      !conditions.excludeSessionId ||
      conditions.excludeSessionId === null ||
      conditions.excludeSessionId === undefined
    ) {
      return this.deleteByUserId({ userId: conditions.userId });
    }
    const numericExcludeId = Number(conditions.excludeSessionId);
    if (isNaN(numericExcludeId)) {
      return this.deleteByUserId({ userId: conditions.userId });
    }
    await this.sessionRepository.softDelete({
      user: {
        id: conditions.userId,
      },
      id: Not(numericExcludeId),
    });
  }
}

================
File: backend/src/session/infrastructure/persistence/session.repository.ts
================
import { User } from '../../../users/domain/user';
import { NullableType } from '../../../utils/types/nullable.type';
import { Session } from '../../domain/session';
export abstract class SessionRepository {
  abstract findById(id: Session['id']): Promise<NullableType<Session>>;
  abstract create(
    data: Omit<Session, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>,
  ): Promise<Session>;
  abstract update(
    id: Session['id'],
    payload: Partial<
      Omit<Session, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>
    >,
  ): Promise<Session | null>;
  abstract deleteById(id: Session['id']): Promise<void>;
  abstract deleteByUserId(conditions: { userId: User['id'] }): Promise<void>;
  abstract deleteByUserIdWithExclude(conditions: {
    userId: User['id'];
    excludeSessionId: Session['id'];
  }): Promise<void>;
}

================
File: backend/src/session/session.module.ts
================
import { Module } from '@nestjs/common';
import { RelationalSessionPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { SessionService } from './session.service';
const infrastructurePersistenceModule = RelationalSessionPersistenceModule;
@Module({
  imports: [infrastructurePersistenceModule],
  providers: [SessionService],
  exports: [SessionService, infrastructurePersistenceModule],
})
export class SessionModule {}

================
File: backend/src/session/session.service.ts
================
import { Injectable } from '@nestjs/common';
import { SessionRepository } from './infrastructure/persistence/session.repository';
import { Session } from './domain/session';
import { User } from '../users/domain/user';
import { NullableType } from '../utils/types/nullable.type';
import { SESSION_REPOSITORY } from '../common/tokens';
import { Inject } from '@nestjs/common';
@Injectable()
export class SessionService {
  constructor(
    @Inject(SESSION_REPOSITORY)
    private readonly sessionRepository: SessionRepository,
  ) {}
  findById(id: Session['id']): Promise<NullableType<Session>> {
    return this.sessionRepository.findById(id);
  }
  create(
    data: Omit<Session, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>,
  ): Promise<Session> {
    return this.sessionRepository.create(data);
  }
  update(
    id: Session['id'],
    payload: Partial<
      Omit<Session, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>
    >,
  ): Promise<Session | null> {
    return this.sessionRepository.update(id, payload);
  }
  deleteById(id: Session['id']): Promise<void> {
    return this.sessionRepository.deleteById(id);
  }
  deleteByUserId(conditions: { userId: User['id'] }): Promise<void> {
    return this.sessionRepository.deleteByUserId(conditions);
  }
  deleteByUserIdWithExclude(conditions: {
    userId: User['id'];
    excludeSessionId: Session['id'];
  }): Promise<void> {
    return this.sessionRepository.deleteByUserIdWithExclude(conditions);
  }
}

================
File: backend/src/subcategories/domain/subcategory.ts
================
import { Category } from '../../categories/domain/category';
import { FileType } from '../../files/domain/file';
import { Product } from '../../products/domain/product';
export class Subcategory {
  id: string;
  categoryId: string;
  name: string;
  description: string | null;
  isActive: boolean;
  sortOrder: number;
  photoId: string | null;
  category: Category | null;
  photo: FileType | null;
  products: Product[] | null;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/subcategories/dto/create-subcategory.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  ValidateIf,
} from 'class-validator';
import { TransformDefault } from '../../utils/transformers/transform-default.decorator';
export class CreateSubcategoryDto {
  @ApiProperty({
    type: String,
    example: 'Smartphones',
  })
  @IsString()
  @IsNotEmpty()
  name: string;
  @ApiProperty({
    type: String,
    example: 'Teléfonos inteligentes y accesorios',
    nullable: true,
  })
  @IsString()
  @IsOptional()
  description?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    default: true,
  })
  @TransformDefault(true)
  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
  @ApiProperty({
    type: String,
    example: 'CAT-1',
  })
  @IsString()
  @IsNotEmpty()
  categoryId: string;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((o) => o.photoId !== null)
  @IsString()
  photoId?: string | null;
  @ApiProperty({
    type: Number,
    example: 0,
    default: 0,
  })
  @TransformDefault(0)
  @IsNumber()
  @IsOptional()
  sortOrder?: number;
}

================
File: backend/src/subcategories/dto/find-all-subcategories.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsNumber, IsOptional, IsString } from 'class-validator';
import { Transform } from 'class-transformer';
export class FindAllSubcategoriesDto {
  @ApiProperty({
    type: Number,
    example: 1,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  page?: number = 1;
  @ApiProperty({
    type: Number,
    example: 10,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  limit?: number = 10;
  @ApiProperty({
    type: String,
    example: 'CAT-1',
    required: false,
  })
  @IsString()
  @IsOptional()
  categoryId?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
}

================
File: backend/src/subcategories/dto/update-subcategory.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNumber,
  IsOptional,
  IsString,
  ValidateIf,
} from 'class-validator';
export class UpdateSubcategoryDto {
  @ApiProperty({
    type: String,
    example: 'Smartphones',
    required: false,
  })
  @IsString()
  @IsOptional()
  name?: string;
  @ApiProperty({
    type: String,
    example: 'Teléfonos inteligentes y accesorios',
    nullable: true,
    required: false,
  })
  @IsString()
  @IsOptional()
  description?: string;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
  @ApiProperty({
    type: String,
    example: 'CAT-1',
    required: false,
  })
  @IsString()
  @IsOptional()
  categoryId?: string;
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    nullable: true,
    required: false,
  })
  @IsOptional()
  @ValidateIf((o) => o.photoId !== null)
  @IsString()
  photoId?: string | null;
  @ApiProperty({
    type: Number,
    example: 0,
    required: false,
  })
  @IsNumber()
  @IsOptional()
  sortOrder?: number;
}

================
File: backend/src/subcategories/infrastructure/persistence/relational/entities/subcategory.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryColumn,
  UpdateDateColumn,
  OneToMany,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { CategoryEntity } from '../../../../../categories/infrastructure/persistence/relational/entities/category.entity';
import { FileEntity } from '../../../../../files/infrastructure/persistence/relational/entities/file.entity';
import { ProductEntity } from '../../../../../products/infrastructure/persistence/relational/entities/product.entity';
@Entity({
  name: 'subcategory',
})
export class SubcategoryEntity extends EntityRelationalHelper {
  @PrimaryColumn({ type: 'varchar', length: 20 })
  id: string;
  @Column()
  name: string;
  @Column({ nullable: true, type: 'varchar' })
  description: string | null;
  @Column({ default: true })
  isActive: boolean;
  @Column({ default: 0 })
  sortOrder: number;
  @Column({ name: 'category_id', type: 'varchar', length: 20 })
  categoryId: string;
  @Column({ name: 'photo_id', nullable: true })
  photoId: string | null;
  @ManyToOne(() => FileEntity, { nullable: true })
  @JoinColumn({ name: 'photo_id' })
  photo: FileEntity | null;
  @ManyToOne(() => CategoryEntity, (category) => category.subcategories, {
    nullable: false,
  })
  @JoinColumn({ name: 'category_id' })
  category: CategoryEntity;
  @OneToMany(() => ProductEntity, (product) => product.subcategory)
  products: ProductEntity[];
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/subcategories/infrastructure/persistence/relational/mappers/subcategory.mapper.ts
================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { Subcategory } from '../../../../domain/subcategory';
import { SubcategoryEntity } from '../entities/subcategory.entity';
import { FileMapper } from '../../../../../files/infrastructure/persistence/relational/mappers/file.mapper';
import { CategoryMapper } from '../../../../../categories/infrastructure/persistence/relational/mappers/category.mapper';
import { ProductMapper } from '../../../../../products/infrastructure/persistence/relational/mappers/product.mapper';
import { CategoryEntity } from '../../../../../categories/infrastructure/persistence/relational/entities/category.entity';
import { FileEntity } from '../../../../../files/infrastructure/persistence/relational/entities/file.entity';
import {
  BaseMapper,
  mapArray,
} from '../../../../../common/mappers/base.mapper';
@Injectable()
export class SubcategoryMapper extends BaseMapper<
  SubcategoryEntity,
  Subcategory
> {
  constructor(
    @Inject(forwardRef(() => CategoryMapper))
    private readonly categoryMapper: CategoryMapper,
    private readonly fileMapper: FileMapper,
    @Inject(forwardRef(() => ProductMapper))
    private readonly productMapper: ProductMapper,
  ) {
    super();
  }
  override toDomain(entity: SubcategoryEntity): Subcategory | null {
    if (!entity) return null;
    const domain = new Subcategory();
    domain.id = entity.id;
    domain.name = entity.name;
    domain.description = entity.description;
    domain.isActive = entity.isActive;
    domain.sortOrder = entity.sortOrder;
    domain.categoryId = entity.categoryId;
    domain.photoId = entity.photoId;
    domain.category = entity.category
      ? this.categoryMapper.toDomain(entity.category)
      : null;
    domain.photo = entity.photo ? this.fileMapper.toDomain(entity.photo) : null;
    domain.products = mapArray(entity.products, (p) =>
      this.productMapper.toDomain(p),
    );
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: Subcategory): SubcategoryEntity | null {
    if (!domain) return null;
    const entity = new SubcategoryEntity();
    if (domain.id) entity.id = domain.id;
    entity.name = domain.name;
    entity.description = domain.description;
    entity.isActive = domain.isActive;
    entity.sortOrder = domain.sortOrder;
    entity.category = { id: domain.categoryId } as CategoryEntity;
    entity.photoId = domain.photoId || null;
    entity.photo = domain.photoId
      ? ({ id: domain.photoId } as FileEntity)
      : null;
    return entity;
  }
}

================
File: backend/src/subcategories/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { SubcategoryEntity } from './entities/subcategory.entity';
import { SubcategoriesRelationalRepository } from './repositories/subcategories.repository';
import { SubcategoryMapper } from './mappers/subcategory.mapper';
import { SUBCATEGORY_REPOSITORY } from '../../../../common/tokens';
import { CategoriesRelationalPersistenceModule } from '../../../../categories/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalFilePersistenceModule } from '../../../../files/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalProductPersistenceModule } from '../../../../products/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([SubcategoryEntity]),
    forwardRef(() => CategoriesRelationalPersistenceModule),
    forwardRef(() => RelationalFilePersistenceModule),
    forwardRef(() => RelationalProductPersistenceModule),
  ],
  providers: [
    SubcategoryMapper,
    {
      provide: SUBCATEGORY_REPOSITORY,
      useClass: SubcategoriesRelationalRepository,
    },
  ],
  exports: [SUBCATEGORY_REPOSITORY, SubcategoryMapper],
})
export class RelationalSubcategoryPersistenceModule {}

================
File: backend/src/subcategories/infrastructure/persistence/relational/repositories/subcategories.repository.ts
================
import {
  Injectable,
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SubcategoryEntity } from '../entities/subcategory.entity';
import { SubcategoryRepository } from '../../subcategory.repository';
import { Subcategory } from '../../../../domain/subcategory';
import { SubcategoryMapper } from '../mappers/subcategory.mapper';
import { Paginated } from '../../../../../common/types/paginated.type';
@Injectable()
export class SubcategoriesRelationalRepository
  implements SubcategoryRepository
{
  constructor(
    @InjectRepository(SubcategoryEntity)
    private readonly subcategoryRepository: Repository<SubcategoryEntity>,
    private readonly subcategoryMapper: SubcategoryMapper,
  ) {}
  async create(data: Subcategory): Promise<Subcategory> {
    const entity = this.subcategoryMapper.toEntity(data);
    if (!entity) {
      throw new InternalServerErrorException(
        'Error creating subcategory entity',
      );
    }
    const savedEntity = await this.subcategoryRepository.save(entity);
    const domainResult = this.subcategoryMapper.toDomain(savedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping saved subcategory entity to domain',
      );
    }
    return domainResult;
  }
  async findOne(id: string): Promise<Subcategory> {
    const entity = await this.subcategoryRepository.findOne({
      where: { id },
      relations: ['photo', 'category'],
    });
    const domainResult = entity
      ? this.subcategoryMapper.toDomain(entity)
      : null;
    if (!domainResult) {
      throw new NotFoundException(`Subcategoría con ID ${id} no encontrada`);
    }
    return domainResult;
  }
  async findAll(options?: {
    page?: number;
    limit?: number;
    categoryId?: string;
    isActive?: boolean;
  }): Promise<Paginated<Subcategory>> {
    const page = options?.page || 1;
    const limit = options?.limit || 10;
    const skip = (page - 1) * limit;
    const queryBuilder = this.subcategoryRepository
      .createQueryBuilder('subcategory')
      .leftJoinAndSelect('subcategory.photo', 'photo')
      .leftJoinAndSelect('subcategory.category', 'category')
      .orderBy('subcategory.sortOrder', 'ASC')
      .addOrderBy('subcategory.name', 'ASC')
      .skip(skip)
      .take(limit);
    if (options?.categoryId) {
      queryBuilder.andWhere('category.id = :categoryId', {
        categoryId: options.categoryId,
      });
    }
    if (options?.isActive !== undefined) {
      queryBuilder.andWhere('subcategory.isActive = :isActive', {
        isActive: options.isActive,
      });
    }
    const [entities, count] = await queryBuilder.getManyAndCount();
    const domainResults = entities
      .map((entity) => this.subcategoryMapper.toDomain(entity))
      .filter((item): item is Subcategory => item !== null);
    return new Paginated(domainResults, count, page, limit);
  }
  async update(id: string, data: Subcategory): Promise<Subcategory> {
    const entity = this.subcategoryMapper.toEntity(data);
    if (!entity) {
      throw new InternalServerErrorException(
        'Error creating subcategory entity for update',
      );
    }
    await this.subcategoryRepository.update(id, entity);
    const updatedEntity = await this.subcategoryRepository.findOne({
      where: { id },
      relations: ['photo', 'category'],
    });
    if (!updatedEntity) {
      throw new NotFoundException(`Subcategoría con ID ${id} no encontrada`);
    }
    const domainResult = this.subcategoryMapper.toDomain(updatedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping updated subcategory entity to domain',
      );
    }
    return domainResult;
  }
  async softDelete(id: string): Promise<void> {
    const result = await this.subcategoryRepository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(`Subcategoría con ID ${id} no encontrada`);
    }
  }
}

================
File: backend/src/subcategories/infrastructure/persistence/subcategory.repository.ts
================
import { Paginated } from '../../../common/types/paginated.type';
import { Subcategory } from '../../domain/subcategory';
export interface SubcategoryRepository {
  create(data: Subcategory): Promise<Subcategory>;
  findOne(id: string): Promise<Subcategory>;
  findAll(options?: {
    page?: number;
    limit?: number;
    categoryId?: string;
    isActive?: boolean;
  }): Promise<Paginated<Subcategory>>;
  update(id: string, data: Subcategory): Promise<Subcategory>;
  softDelete(id: string): Promise<void>;
}

================
File: backend/src/subcategories/subcategories.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Query,
  HttpStatus,
  HttpCode,
} from '@nestjs/common';
import { SubcategoriesService } from './subcategories.service';
import { CreateSubcategoryDto } from './dto/create-subcategory.dto';
import { UpdateSubcategoryDto } from './dto/update-subcategory.dto';
import { ApiBearerAuth, ApiOperation, ApiTags } from '@nestjs/swagger';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { FindAllSubcategoriesDto } from './dto/find-all-subcategories.dto';
@ApiTags('Subcategorías')
@Controller({
  path: 'subcategories',
  version: '1',
})
export class SubcategoriesController {
  constructor(private readonly subcategoriesService: SubcategoriesService) {}
  @Post()
  @ApiOperation({
    summary: 'Crear una nueva subcategoría',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createSubcategoryDto: CreateSubcategoryDto) {
    return this.subcategoriesService.create(createSubcategoryDto);
  }
  @Get()
  @ApiOperation({
    summary: 'Obtener todas las subcategorías',
  })
  @HttpCode(HttpStatus.OK)
  findAll(@Query() findAllSubcategoriesDto: FindAllSubcategoriesDto) {
    return this.subcategoriesService.findAll(findAllSubcategoriesDto);
  }
  @Get(':id')
  @ApiOperation({
    summary: 'Obtener una subcategoría por ID',
  })
  @HttpCode(HttpStatus.OK)
  findOne(@Param('id') id: string) {
    return this.subcategoriesService.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({
    summary: 'Actualizar una subcategoría',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  update(
    @Param('id') id: string,
    @Body() updateSubcategoryDto: UpdateSubcategoryDto,
  ) {
    return this.subcategoriesService.update(id, updateSubcategoryDto);
  }
  @Delete(':id')
  @ApiOperation({
    summary: 'Eliminar una subcategoría',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id') id: string) {
    return this.subcategoriesService.remove(id);
  }
}

================
File: backend/src/subcategories/subcategories.module.ts
================
import { Module } from '@nestjs/common';
import { SubcategoriesService } from './subcategories.service';
import { SubcategoriesController } from './subcategories.controller';
import { RelationalSubcategoryPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { CommonModule } from '../common/common.module';
@Module({
  imports: [RelationalSubcategoryPersistenceModule, CommonModule],
  controllers: [SubcategoriesController],
  providers: [SubcategoriesService],
  exports: [SubcategoriesService],
})
export class SubcategoriesModule {}

================
File: backend/src/subcategories/subcategories.service.ts
================
import { Inject, Injectable } from '@nestjs/common';
import { SubcategoryRepository } from './infrastructure/persistence/subcategory.repository';
import { SUBCATEGORY_REPOSITORY } from '../common/tokens';
import { CreateSubcategoryDto } from './dto/create-subcategory.dto';
import { UpdateSubcategoryDto } from './dto/update-subcategory.dto';
import { Subcategory } from './domain/subcategory';
import { FindAllSubcategoriesDto } from './dto/find-all-subcategories.dto';
import { Paginated } from '../common/types/paginated.type';
import {
  CustomIdService,
  EntityPrefix,
} from '../common/services/custom-id.service';
@Injectable()
export class SubcategoriesService {
  constructor(
    @Inject(SUBCATEGORY_REPOSITORY)
    private readonly subcategoryRepository: SubcategoryRepository,
    private readonly customIdService: CustomIdService,
  ) {}
  async create(
    createSubcategoryDto: CreateSubcategoryDto,
  ): Promise<Subcategory> {
    const subcategory = new Subcategory();
    subcategory.id = await this.customIdService.generateId(
      EntityPrefix.SUBCATEGORY,
      'subcategory',
    );
    subcategory.name = createSubcategoryDto.name;
    subcategory.description = createSubcategoryDto.description || null;
    subcategory.isActive = createSubcategoryDto.isActive ?? true;
    subcategory.categoryId = createSubcategoryDto.categoryId;
    subcategory.sortOrder = createSubcategoryDto.sortOrder ?? 0;
    if (createSubcategoryDto.photoId) {
      subcategory.photoId = createSubcategoryDto.photoId;
      subcategory.photo = {
        id: createSubcategoryDto.photoId,
        path: '',
      };
    }
    return this.subcategoryRepository.create(subcategory);
  }
  async findAll(
    findAllSubcategoriesDto: FindAllSubcategoriesDto,
  ): Promise<Paginated<Subcategory>> {
    return this.subcategoryRepository.findAll({
      page: findAllSubcategoriesDto.page,
      limit: findAllSubcategoriesDto.limit,
      categoryId: findAllSubcategoriesDto.categoryId,
      isActive: findAllSubcategoriesDto.isActive,
    });
  }
  async findOne(id: string): Promise<Subcategory> {
    return this.subcategoryRepository.findOne(id);
  }
  async update(
    id: string,
    updateSubcategoryDto: UpdateSubcategoryDto,
  ): Promise<Subcategory> {
    const existingSubcategory = await this.subcategoryRepository.findOne(id);
    const subcategory = new Subcategory();
    subcategory.id = id;
    subcategory.name = updateSubcategoryDto.name ?? existingSubcategory.name;
    subcategory.description =
      updateSubcategoryDto.description ?? existingSubcategory.description;
    subcategory.isActive =
      updateSubcategoryDto.isActive ?? existingSubcategory.isActive;
    subcategory.categoryId =
      updateSubcategoryDto.categoryId ?? existingSubcategory.categoryId;
    subcategory.sortOrder =
      updateSubcategoryDto.sortOrder ?? existingSubcategory.sortOrder;
    if (updateSubcategoryDto.photoId !== undefined) {
      subcategory.photoId = updateSubcategoryDto.photoId;
      subcategory.photo = updateSubcategoryDto.photoId
        ? {
            id: updateSubcategoryDto.photoId,
            path: '',
          }
        : null;
    } else if (existingSubcategory.photo) {
      subcategory.photoId = existingSubcategory.photoId;
      subcategory.photo = {
        id: existingSubcategory.photo.id,
        path: '',
      };
    }
    return this.subcategoryRepository.update(id, subcategory);
  }
  async remove(id: string): Promise<void> {
    return this.subcategoryRepository.softDelete(id);
  }
  async findAllByCategoryId(categoryId: string): Promise<Subcategory[]> {
    const result = await this.subcategoryRepository.findAll({
      page: 1,
      limit: 1000,
      categoryId,
    });
    return result.items;
  }
  async findAllByCategoryIdWithProducts(
    categoryId: string,
  ): Promise<Subcategory[]> {
    return this.findAllByCategoryId(categoryId);
  }
}

================
File: backend/src/sync/config/sync-config.type.ts
================
export type SyncConfig = {
  enabled: boolean;
  cloudApiUrl: string;
  cloudApiKey: string;
  intervalMinutes: number;
  webSocketEnabled: boolean;
};

================
File: backend/src/sync/config/sync.config.ts
================
import { registerAs } from '@nestjs/config';
import { SyncConfig } from './sync-config.type';
import {
  IsBoolean,
  IsNotEmpty,
  IsNumber,
  IsString,
  Min,
} from 'class-validator';
import validateConfig from '../../utils/validate-config';
class EnvironmentVariablesValidator {
  @IsBoolean()
  SYNC_ENABLED: boolean;
  @IsString()
  @IsNotEmpty()
  CLOUD_API_URL: string;
  @IsString()
  @IsNotEmpty()
  CLOUD_API_KEY: string;
  @IsNumber()
  @Min(1)
  SYNC_INTERVAL_MINUTES: number;
  @IsBoolean()
  SYNC_WEBSOCKET_ENABLED: boolean;
}
export default registerAs<SyncConfig>('sync', () => {
  validateConfig(process.env, EnvironmentVariablesValidator);
  return {
    enabled: process.env.SYNC_ENABLED === 'true',
    cloudApiUrl: process.env.CLOUD_API_URL || '',
    cloudApiKey: process.env.CLOUD_API_KEY || '',
    intervalMinutes: parseInt(process.env.SYNC_INTERVAL_MINUTES || '5', 10),
    webSocketEnabled: process.env.SYNC_WEBSOCKET_ENABLED === 'true',
  };
});

================
File: backend/src/tables/domain/table.ts
================
import { Area } from '../../areas/domain/area';
export class Table {
  id: string;
  name: string;
  areaId: string;
  capacity: number | null;
  isActive: boolean;
  isAvailable: boolean;
  isTemporary: boolean;
  temporaryIdentifier: string | null;
  area: Area;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/tables/dto/create-table.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsNumber,
  IsInt,
} from 'class-validator';
export class CreateTableDto {
  @ApiProperty({
    type: String,
    example: 'Mesa 1',
  })
  @IsNotEmpty()
  @IsString()
  name: string;
  @ApiProperty({
    type: String,
    example: 'AREA-1',
    description: 'ID del área a la que pertenece la mesa (obligatorio)',
  })
  @IsNotEmpty()
  @IsString()
  areaId: string;
  @ApiProperty({
    type: Number,
    example: 4,
    required: false,
    description: 'Capacidad de la mesa (opcional)',
  })
  @IsOptional()
  @IsNumber()
  @IsInt()
  capacity?: number;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
    default: true,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
    default: true,
  })
  @IsOptional()
  @IsBoolean()
  isAvailable?: boolean;
  @ApiProperty({
    type: Boolean,
    example: false,
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isTemporary?: boolean;
  @ApiProperty({
    type: String,
    example: 'T-123',
    required: false,
  })
  @IsOptional()
  @IsString()
  temporaryIdentifier?: string;
}

================
File: backend/src/tables/dto/find-all-tables.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsOptional,
  IsString,
  IsNumber,
  IsInt,
} from 'class-validator';
import { Transform } from 'class-transformer';
export class FindAllTablesDto {
  @ApiProperty({
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  areaId?: string;
  @ApiProperty({
    type: Number,
    required: false,
    description: 'Capacidad de la mesa (opcional)',
  })
  @IsOptional()
  @IsNumber()
  @IsInt()
  @Transform(({ value }) => {
    if (value === undefined || value === null) return undefined;
    return Number(value);
  })
  capacity?: number;
  @ApiProperty({
    type: Boolean,
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
  @ApiProperty({
    type: Boolean,
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isAvailable?: boolean;
  @ApiProperty({
    type: Boolean,
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isTemporary?: boolean;
}

================
File: backend/src/tables/dto/update-table.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsBoolean,
  IsOptional,
  IsString,
  IsNumber,
  IsInt,
} from 'class-validator';
export class UpdateTableDto {
  @ApiProperty({
    type: String,
    example: 'Mesa 1',
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiProperty({
    type: String,
    example: 'AREA-1',
    required: false,
  })
  @IsOptional()
  @IsString()
  areaId?: string;
  @ApiProperty({
    type: Number,
    example: 4,
    required: false,
    description: 'Capacidad de la mesa (opcional)',
  })
  @IsOptional()
  @IsNumber()
  @IsInt()
  capacity?: number;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiProperty({
    type: Boolean,
    example: true,
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isAvailable?: boolean;
  @ApiProperty({
    type: Boolean,
    example: false,
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isTemporary?: boolean;
  @ApiProperty({
    type: String,
    example: 'T-123',
    required: false,
  })
  @IsOptional()
  @IsString()
  temporaryIdentifier?: string;
}

================
File: backend/src/tables/infrastructure/persistence/relational/entities/table.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
  RelationId,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { AreaEntity } from '../../../../../areas/infrastructure/persistence/relational/entities/area.entity';
@Entity({
  name: 'table',
})
export class TableEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column()
  name: string;
  @RelationId((table: TableEntity) => table.area)
  areaId: string;
  @Column({ type: 'int', nullable: true })
  capacity: number | null;
  @Column({ default: true })
  isActive: boolean;
  @Column({ default: true })
  isAvailable: boolean;
  @Column({ default: false })
  isTemporary: boolean;
  @Column({ type: 'varchar', nullable: true })
  temporaryIdentifier: string | null;
  @ManyToOne(() => AreaEntity, (area) => area.tables, {
    eager: true,
    nullable: false,
  })
  @JoinColumn({ name: 'area_id' })
  area: AreaEntity;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/tables/infrastructure/persistence/relational/mappers/table.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { AreaMapper } from '../../../../../areas/infrastructure/persistence/relational/mappers/area.mapper';
import { Table } from '../../../../domain/table';
import { TableEntity } from '../entities/table.entity';
import { AreaEntity } from '../../../../../areas/infrastructure/persistence/relational/entities/area.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class TableMapper extends BaseMapper<TableEntity, Table> {
  constructor(private readonly areaMapper: AreaMapper) {
    super();
  }
  override toDomain(entity: TableEntity): Table | null {
    if (!entity) return null;
    if (entity.id && !entity.area) {
      throw new Error(
        `La tabla ${entity.id} (${entity.name}) no tiene un área asociada. ` +
          `Asegúrese de cargar la relación 'table.area' en la consulta.`,
      );
    }
    const domain = new Table();
    domain.id = entity.id;
    domain.name = entity.name;
    domain.areaId = entity.area!.id;
    domain.capacity = entity.capacity;
    domain.isActive = entity.isActive;
    domain.isAvailable = entity.isAvailable;
    domain.isTemporary = entity.isTemporary;
    domain.temporaryIdentifier = entity.temporaryIdentifier;
    domain.area = this.areaMapper.toDomain(entity.area!)!;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  override toEntity(domain: Table): TableEntity | null {
    if (!domain) return null;
    const entity = new TableEntity();
    if (domain.id) {
      entity.id = domain.id;
    }
    entity.name = domain.name;
    entity.area = { id: domain.areaId } as AreaEntity;
    entity.capacity = domain.capacity;
    entity.isActive = domain.isActive;
    entity.isAvailable = domain.isAvailable;
    entity.isTemporary = domain.isTemporary;
    entity.temporaryIdentifier = domain.temporaryIdentifier;
    return entity;
  }
}

================
File: backend/src/tables/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TableEntity } from './entities/table.entity';
import { TablesRelationalRepository } from './repositories/table.repository';
import { TableMapper } from './mappers/table.mapper';
import { RelationalAreaPersistenceModule } from '../../../../areas/infrastructure/persistence/relational/relational-persistence.module';
import { TABLE_REPOSITORY } from '../../../../common/tokens';
@Module({
  imports: [
    TypeOrmModule.forFeature([TableEntity]),
    RelationalAreaPersistenceModule,
  ],
  providers: [
    {
      provide: TABLE_REPOSITORY,
      useClass: TablesRelationalRepository,
    },
    TableMapper,
  ],
  exports: [TABLE_REPOSITORY, TableMapper],
})
export class RelationalTablePersistenceModule {}

================
File: backend/src/tables/infrastructure/persistence/relational/repositories/table.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FindOptionsWhere, Repository, ILike } from 'typeorm';
import { NullableType } from '../../../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../../../utils/types/pagination-options';
import { Table } from '../../../../domain/table';
import { FindAllTablesDto } from '../../../../dto/find-all-tables.dto';
import { TableRepository } from '../../table.repository';
import { TableEntity } from '../entities/table.entity';
import { TableMapper } from '../mappers/table.mapper';
@Injectable()
export class TablesRelationalRepository implements TableRepository {
  constructor(
    @InjectRepository(TableEntity)
    private readonly tablesRepository: Repository<TableEntity>,
    private readonly tableMapper: TableMapper,
  ) {}
  async create(data: Table): Promise<Table> {
    const persistenceModel = this.tableMapper.toEntity(data);
    if (!persistenceModel) {
      throw new Error('Error creating table entity');
    }
    const newEntity = await this.tablesRepository.save(
      this.tablesRepository.create(persistenceModel),
    );
    const completeEntity = await this.tablesRepository.findOne({
      where: { id: newEntity.id },
      relations: ['area'],
    });
    if (!completeEntity) {
      throw new Error(
        `No se pudo cargar la tabla creada con ID ${newEntity.id}`,
      );
    }
    const domainResult = this.tableMapper.toDomain(completeEntity);
    if (!domainResult) {
      throw new Error('Error mapping created table entity to domain');
    }
    return domainResult;
  }
  async findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: FindAllTablesDto | null;
    paginationOptions: IPaginationOptions;
  }): Promise<Table[]> {
    const where: FindOptionsWhere<TableEntity> = {};
    if (filterOptions?.name) {
      where.name = ILike(`%${filterOptions.name}%`);
    }
    if (filterOptions?.areaId) {
      where.area = { id: filterOptions.areaId };
    }
    if (filterOptions?.capacity !== undefined) {
      where.capacity = filterOptions.capacity;
    }
    if (filterOptions?.isActive !== undefined) {
      where.isActive = filterOptions.isActive;
    }
    if (filterOptions?.isAvailable !== undefined) {
      where.isAvailable = filterOptions.isAvailable;
    }
    if (filterOptions?.isTemporary !== undefined) {
      where.isTemporary = filterOptions.isTemporary;
    } else {
      where.isTemporary = false;
    }
    const entities = await this.tablesRepository.find({
      skip: (paginationOptions.page - 1) * paginationOptions.limit,
      take: paginationOptions.limit,
      where: where,
      relations: ['area'],
    });
    return entities
      .map((table) => this.tableMapper.toDomain(table))
      .filter((item): item is Table => item !== null);
  }
  async findById(id: Table['id']): Promise<NullableType<Table>> {
    const entity = await this.tablesRepository.findOne({
      where: { id },
      relations: ['area'],
    });
    return entity ? this.tableMapper.toDomain(entity) : null;
  }
  async findByName(name: Table['name']): Promise<NullableType<Table>> {
    const entity = await this.tablesRepository.findOne({
      where: { name },
      relations: ['area'],
    });
    return entity ? this.tableMapper.toDomain(entity) : null;
  }
  async findByAreaId(areaId: Table['areaId']): Promise<Table[]> {
    const entities = await this.tablesRepository.find({
      where: {
        area: { id: areaId },
        isTemporary: false,
      },
      relations: ['area'],
    });
    return entities
      .map((table) => this.tableMapper.toDomain(table))
      .filter((item): item is Table => item !== null);
  }
  async update(id: Table['id'], payload: Partial<Table>): Promise<Table> {
    const entity = await this.tablesRepository.findOne({
      where: { id },
      relations: ['area'],
    });
    if (!entity) {
      throw new Error('Table not found');
    }
    const domainEntity = this.tableMapper.toDomain(entity);
    if (!domainEntity) {
      throw new Error('Error mapping existing table entity to domain');
    }
    const updatedDomain = { ...domainEntity, ...payload };
    const persistenceModel = this.tableMapper.toEntity(updatedDomain);
    if (!persistenceModel) {
      throw new Error('Error creating table entity for update');
    }
    const updatedEntity = await this.tablesRepository.save(
      this.tablesRepository.create(persistenceModel),
    );
    const completeEntity = await this.tablesRepository.findOne({
      where: { id: updatedEntity.id },
      relations: ['area'],
    });
    if (!completeEntity) {
      throw new Error(
        `No se pudo cargar la tabla actualizada con ID ${updatedEntity.id}`,
      );
    }
    const domainResult = this.tableMapper.toDomain(completeEntity);
    if (!domainResult) {
      throw new Error('Error mapping updated table entity to domain');
    }
    return domainResult;
  }
  async remove(id: Table['id']): Promise<void> {
    await this.tablesRepository.softDelete(id);
  }
}

================
File: backend/src/tables/infrastructure/persistence/table.repository.ts
================
import { DeepPartial } from '../../../utils/types/deep-partial.type';
import { NullableType } from '../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../utils/types/pagination-options';
import { Table } from '../../domain/table';
import { FindAllTablesDto } from '../../dto/find-all-tables.dto';
export abstract class TableRepository {
  abstract create(
    data: Omit<Table, 'id' | 'createdAt' | 'deletedAt' | 'updatedAt'>,
  ): Promise<Table>;
  abstract findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: FindAllTablesDto | null;
    paginationOptions: IPaginationOptions;
  }): Promise<Table[]>;
  abstract findById(id: Table['id']): Promise<NullableType<Table>>;
  abstract findByName(name: Table['name']): Promise<NullableType<Table>>;
  abstract findByAreaId(areaId: Table['areaId']): Promise<Table[]>;
  abstract update(
    id: Table['id'],
    payload: DeepPartial<Table>,
  ): Promise<Table | null>;
  abstract remove(id: Table['id']): Promise<void>;
}

================
File: backend/src/tables/tables.controller.ts
================
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import {
  ApiOperation,
  ApiParam,
  ApiResponse,
  ApiTags,
  ApiBearerAuth,
} from '@nestjs/swagger';
import { TablesService } from './tables.service';
import { Table } from './domain/table';
import { CreateTableDto } from './dto/create-table.dto';
import { FindAllTablesDto } from './dto/find-all-tables.dto';
import { UpdateTableDto } from './dto/update-table.dto';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { AuthGuard } from '@nestjs/passport';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { RolesGuard } from '../roles/roles.guard';
import { Paginated } from '../common/types/paginated.type';
@ApiTags('Tables')
@Controller({
  path: 'tables',
  version: '1',
})
export class TablesController {
  constructor(private readonly tablesService: TablesService) {}
  @Post()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'Create a new table' })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'The table has been successfully created.',
    type: Table,
  })
  @ApiBearerAuth()
  @Roles(RoleEnum.admin)
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  create(@Body() createTableDto: CreateTableDto): Promise<Table> {
    return this.tablesService.create(createTableDto);
  }
  @Get()
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Get all tables' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'List of tables',
    type: Paginated,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  findAll(
    @Query() filterOptions: FindAllTablesDto,
    @Query('page') page = 1,
    @Query('limit') limit = 10,
  ): Promise<Paginated<Table>> {
    return this.tablesService.findAllPaginated(filterOptions, {
      page,
      limit,
    } as IPaginationOptions);
  }
  @Get('area/:areaId')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Get tables by area id' })
  @ApiParam({
    name: 'areaId',
    description: 'The id of the area',
    type: String,
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'List of tables by area id',
    type: Paginated,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  findByAreaId(@Param('areaId') areaId: string): Promise<Paginated<Table>> {
    return this.tablesService.findByAreaIdPaginated(areaId);
  }
  @Get(':id')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Get table by id' })
  @ApiParam({
    name: 'id',
    description: 'The id of the table',
    type: String,
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'The table has been successfully retrieved.',
    type: Table,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Table not found',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  findOne(@Param('id') id: string): Promise<Table> {
    return this.tablesService.findOne(id);
  }
  @Patch(':id')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Update table by id' })
  @ApiParam({
    name: 'id',
    description: 'The id of the table',
    type: String,
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'The table has been successfully updated.',
    type: Table,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Table not found',
  })
  @ApiBearerAuth()
  @Roles(RoleEnum.admin)
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  update(
    @Param('id') id: string,
    @Body() updateTableDto: UpdateTableDto,
  ): Promise<Table> {
    return this.tablesService.update(id, updateTableDto);
  }
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete table by id' })
  @ApiParam({
    name: 'id',
    description: 'The id of the table',
    type: String,
  })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'The table has been successfully deleted.',
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Table not found',
  })
  @ApiBearerAuth()
  @Roles(RoleEnum.admin)
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  remove(@Param('id') id: string): Promise<void> {
    return this.tablesService.remove(id);
  }
}

================
File: backend/src/tables/tables.module.ts
================
import { Module } from '@nestjs/common';
import { TablesController } from './tables.controller';
import { TablesService } from './tables.service';
import { RelationalTablePersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { AreasModule } from '../areas/areas.module';
import { AuthModule } from '../auth/auth.module';
const infrastructurePersistenceModule = RelationalTablePersistenceModule;
@Module({
  imports: [infrastructurePersistenceModule, AreasModule, AuthModule],
  controllers: [TablesController],
  providers: [TablesService],
  exports: [TablesService, infrastructurePersistenceModule],
})
export class TablesModule {}

================
File: backend/src/tables/tables.service.ts
================
import { Injectable } from '@nestjs/common';
import { Table } from './domain/table';
import { CreateTableDto } from './dto/create-table.dto';
import { FindAllTablesDto } from './dto/find-all-tables.dto';
import { UpdateTableDto } from './dto/update-table.dto';
import { TableRepository } from './infrastructure/persistence/table.repository';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { TABLE_REPOSITORY } from '../common/tokens';
import { Inject } from '@nestjs/common';
import { Paginated } from '../common/types/paginated.type';
@Injectable()
export class TablesService {
  constructor(
    @Inject(TABLE_REPOSITORY)
    private readonly tableRepository: TableRepository,
  ) {}
  async create(createTableDto: CreateTableDto): Promise<Table> {
    const table = new Table();
    table.name = createTableDto.name;
    table.areaId = createTableDto.areaId;
    table.capacity =
      createTableDto.capacity !== undefined ? createTableDto.capacity : null;
    table.isActive =
      createTableDto.isActive !== undefined ? createTableDto.isActive : true;
    table.isAvailable =
      createTableDto.isAvailable !== undefined
        ? createTableDto.isAvailable
        : true;
    table.isTemporary =
      createTableDto.isTemporary !== undefined
        ? createTableDto.isTemporary
        : false;
    table.temporaryIdentifier = createTableDto.temporaryIdentifier || null;
    return this.tableRepository.create(table);
  }
  async findAll(
    filterOptions: FindAllTablesDto,
    paginationOptions: IPaginationOptions,
  ): Promise<Table[]> {
    return this.tableRepository.findManyWithPagination({
      filterOptions,
      paginationOptions,
    });
  }
  async findOne(id: string): Promise<Table> {
    const table = await this.tableRepository.findById(id);
    if (!table) {
      throw new Error('Table not found');
    }
    return table;
  }
  async findByAreaId(areaId: string): Promise<Table[]> {
    return this.tableRepository.findByAreaId(areaId);
  }
  async update(id: string, updateTableDto: UpdateTableDto): Promise<Table> {
    const updatedTable = await this.tableRepository.update(id, updateTableDto);
    if (!updatedTable) {
      throw new Error('Table not found');
    }
    return updatedTable;
  }
  async remove(id: string): Promise<void> {
    return this.tableRepository.remove(id);
  }
  async findAllPaginated(
    filterOptions: FindAllTablesDto,
    paginationOptions: IPaginationOptions,
  ): Promise<Paginated<Table>> {
    const items = await this.findAll(filterOptions, paginationOptions);
    const total = items.length;
    return new Paginated(
      items,
      total,
      paginationOptions.page || 1,
      paginationOptions.limit || 10,
    );
  }
  async findByAreaIdPaginated(areaId: string): Promise<Paginated<Table>> {
    const items = await this.findByAreaId(areaId);
    return new Paginated(
      items,
      items.length,
      1,
      100,
    );
  }
}

================
File: backend/src/thermal-printers/dto/discovered-printer.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
export class DiscoveredPrinterDto {
  @ApiProperty({
    description: 'Dirección IP de la impresora',
    example: '192.168.1.101',
  })
  ip: string;
  @ApiProperty({
    description: 'Primer puerto TCP abierto encontrado en la impresora',
    example: 9100,
  })
  port: number;
  @ApiProperty({
    description: 'Tipo de descubrimiento (siempre tcp:raw)',
    example: 'tcp:raw',
  })
  type: string;
  @ApiPropertyOptional({
    description: 'Nombre genérico asignado',
    example: 'Printer @ 192.168.1.101',
  })
  name?: string;
  @ApiPropertyOptional({
    description: 'Dirección MAC física obtenida de la tabla ARP del sistema',
    example: '00:1A:2B:3C:4D:5E',
  })
  mac?: string;
}

================
File: backend/src/thermal-printers/dto/find-all-thermal-printers.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsBoolean,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';
import { Transform } from 'class-transformer';
import { PrinterConnectionType } from '../domain/thermal-printer';
export class FindAllThermalPrintersDto {
  @ApiPropertyOptional({
    type: Number,
    example: 1,
    description: 'Número de página',
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  page?: number = 1;
  @ApiPropertyOptional({
    type: Number,
    example: 10,
    description: 'Número de elementos por página',
  })
  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  limit?: number = 10;
  @ApiPropertyOptional({
    type: String,
    example: 'Cocina',
    description: 'Filtrar por nombre (búsqueda parcial)',
  })
  @IsOptional()
  @IsString()
  name?: string;
  @ApiPropertyOptional({
    enum: PrinterConnectionType,
    example: PrinterConnectionType.NETWORK,
    description: 'Filtrar por tipo de conexión',
  })
  @IsOptional()
  @IsEnum(PrinterConnectionType)
  connectionType?: PrinterConnectionType;
  @ApiPropertyOptional({
    type: Boolean,
    example: true,
    description: 'Filtrar por estado activo/inactivo',
  })
  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
}

================
File: backend/src/thermal-printers/dto/print-order.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsNotEmpty, IsOptional, IsUUID } from 'class-validator';
export class PrintOrderDto {
  @ApiProperty({
    description: 'ID de la orden a imprimir',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsNotEmpty()
  @IsUUID()
  orderId: string;
  @ApiPropertyOptional({
    description: 'ID de la impresora térmica a utilizar (opcional)',
    example: 'a1b2c3d4-e5f6-7890-1234-567890abcdef',
  })
  @IsOptional()
  @IsUUID()
  printerId?: string;
}

================
File: backend/src/thermal-printers/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ThermalPrinterEntity } from './entities/thermal-printer.entity';
import { ThermalPrintersRelationalRepository } from './repositories/thermal-printer.repository';
import { THERMAL_PRINTER_REPOSITORY } from '../../../../common/tokens';
import { ThermalPrinterMapper } from './mappers/thermal-printer.mapper';
@Module({
  imports: [TypeOrmModule.forFeature([ThermalPrinterEntity])],
  providers: [
    {
      provide: THERMAL_PRINTER_REPOSITORY,
      useClass: ThermalPrintersRelationalRepository,
    },
    ThermalPrinterMapper,
  ],
  exports: [THERMAL_PRINTER_REPOSITORY, ThermalPrinterMapper],
})
export class RelationalThermalPrinterPersistenceModule {}

================
File: backend/src/thermal-printers/infrastructure/persistence/relational/repositories/thermal-printer.repository.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FindOptionsWhere, ILike, Repository } from 'typeorm';
import { NullableType } from '../../../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../../../utils/types/pagination-options';
import { ThermalPrinter } from '../../../../domain/thermal-printer';
import { FindAllThermalPrintersDto } from '../../../../dto/find-all-thermal-printers.dto';
import { ThermalPrinterRepository } from '../../thermal-printer.repository';
import { ThermalPrinterEntity } from '../entities/thermal-printer.entity';
import { ThermalPrinterMapper } from '../mappers/thermal-printer.mapper';
import { DeepPartial } from '../../../../../utils/types/deep-partial.type';
@Injectable()
export class ThermalPrintersRelationalRepository
  implements ThermalPrinterRepository
{
  constructor(
    @InjectRepository(ThermalPrinterEntity)
    private readonly printersRepository: Repository<ThermalPrinterEntity>,
  ) {}
  async create(
    data: Omit<ThermalPrinter, 'id' | 'createdAt' | 'deletedAt' | 'updatedAt'>,
  ): Promise<ThermalPrinter> {
    const persistenceModel = ThermalPrinterMapper.toEntity(
      data as ThermalPrinter,
    );
    const newEntity = await this.printersRepository.save(
      this.printersRepository.create(persistenceModel),
    );
    const completeEntity = await this.printersRepository.findOne({
      where: { id: newEntity.id },
    });
    if (!completeEntity) {
      throw new Error(
        `Failed to load created thermal printer with ID ${newEntity.id}`,
      );
    }
    return ThermalPrinterMapper.toDomain(completeEntity);
  }
  async findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: FindAllThermalPrintersDto | null;
    paginationOptions: IPaginationOptions;
  }): Promise<[ThermalPrinter[], number]> {
    const where: FindOptionsWhere<ThermalPrinterEntity> = {};
    if (filterOptions?.name) {
      where.name = ILike(`%${filterOptions.name}%`);
    }
    if (filterOptions?.connectionType) {
      where.connectionType = filterOptions.connectionType;
    }
    if (filterOptions?.isActive !== undefined) {
      where.isActive = filterOptions.isActive;
    }
    const [entities, count] = await this.printersRepository.findAndCount({
      skip: (paginationOptions.page - 1) * paginationOptions.limit,
      take: paginationOptions.limit,
      where: where,
      order: { name: 'ASC' },
    });
    const printers = entities.map((printer) =>
      ThermalPrinterMapper.toDomain(printer),
    );
    return [printers, count];
  }
  async findById(
    id: ThermalPrinter['id'],
  ): Promise<NullableType<ThermalPrinter>> {
    const entity = await this.printersRepository.findOne({
      where: { id },
    });
    return entity ? ThermalPrinterMapper.toDomain(entity) : null;
  }
  async findByName(
    name: ThermalPrinter['name'],
  ): Promise<NullableType<ThermalPrinter>> {
    const entity = await this.printersRepository.findOne({
      where: { name },
    });
    return entity ? ThermalPrinterMapper.toDomain(entity) : null;
  }
  async findByIpAddress(
    ipAddress: ThermalPrinter['ipAddress'],
  ): Promise<NullableType<ThermalPrinter>> {
    if (!ipAddress) {
      return null;
    }
    const entity = await this.printersRepository.findOne({
      where: { ipAddress },
    });
    return entity ? ThermalPrinterMapper.toDomain(entity) : null;
  }
  async update(
    id: ThermalPrinter['id'],
    payload: DeepPartial<ThermalPrinter>,
  ): Promise<ThermalPrinter | null> {
    const entity = await this.printersRepository.findOne({ where: { id } });
    if (!entity) {
      return null;
    }
    const updatedEntityData = this.printersRepository.merge(entity, payload);
    const savedEntity = await this.printersRepository.save(updatedEntityData);
    const reloadedEntity = await this.printersRepository.findOne({
      where: { id: savedEntity.id },
    });
    if (!reloadedEntity) {
      throw new Error(`Failed to reload printer with ID ${id} after update.`);
    }
    return ThermalPrinterMapper.toDomain(reloadedEntity);
  }
  async remove(id: ThermalPrinter['id']): Promise<void> {
    const result = await this.printersRepository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(`Thermal printer with ID ${id} not found.`);
    }
  }
}

================
File: backend/src/thermal-printers/infrastructure/persistence/thermal-printer.repository.ts
================
import { DeepPartial } from '../../../utils/types/deep-partial.type';
import { NullableType } from '../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../utils/types/pagination-options';
import { ThermalPrinter } from '../../domain/thermal-printer';
import { FindAllThermalPrintersDto } from '../../dto/find-all-thermal-printers.dto';
export abstract class ThermalPrinterRepository {
  abstract create(
    data: Omit<ThermalPrinter, 'id' | 'createdAt' | 'deletedAt' | 'updatedAt'>,
  ): Promise<ThermalPrinter>;
  abstract findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: FindAllThermalPrintersDto | null;
    paginationOptions: IPaginationOptions;
  }): Promise<[ThermalPrinter[], number]>;
  abstract findById(
    id: ThermalPrinter['id'],
  ): Promise<NullableType<ThermalPrinter>>;
  abstract findByName(
    name: ThermalPrinter['name'],
  ): Promise<NullableType<ThermalPrinter>>;
  abstract findByIpAddress(
    ipAddress: ThermalPrinter['ipAddress'],
  ): Promise<NullableType<ThermalPrinter>>;
  abstract update(
    id: ThermalPrinter['id'],
    payload: DeepPartial<ThermalPrinter>,
  ): Promise<ThermalPrinter | null>;
  abstract remove(id: ThermalPrinter['id']): Promise<void>;
}

================
File: backend/src/thermal-printers/printing.controller.ts
================
import { Controller, Post, Body, HttpCode, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { PrintingService } from './printing.service';
import { PrintOrderDto } from './dto/print-order.dto';
@ApiTags('Printing')
@Controller({
  path: 'print',
  version: '1',
})
export class PrintingController {
  constructor(private readonly printingService: PrintingService) {}
  @Post('order')
  @HttpCode(HttpStatus.ACCEPTED)
  @ApiOperation({
    summary: 'Enviar una orden a imprimir en una impresora térmica',
  })
  @ApiResponse({
    status: HttpStatus.ACCEPTED,
    description: 'La solicitud de impresión ha sido aceptada.',
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Orden o impresora no encontrada.',
  })
  @ApiResponse({
    status: HttpStatus.INTERNAL_SERVER_ERROR,
    description: 'Error interno del servidor durante la impresión.',
  })
  async printKitchenTicket(
    @Body() printOrderDto: PrintOrderDto,
  ): Promise<{ message: string }> {
    await this.printingService.printKitchenTicket(printOrderDto);
    return { message: 'Solicitud de impresión de cocina aceptada.' };
  }
}

================
File: backend/src/thermal-printers/thermal-printers.controller.ts
================
import {
  Body,
  Controller,
  DefaultValuePipe,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  ParseArrayPipe,
  ParseIntPipe,
  ParseUUIDPipe,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import {
  ApiBearerAuth,
  ApiOperation,
  ApiQuery,
  ApiResponse,
  ApiTags,
} from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { RolesGuard } from '../roles/roles.guard';
import { ThermalPrintersService } from './thermal-printers.service';
import { CreateThermalPrinterDto } from './dto/create-thermal-printer.dto';
import { UpdateThermalPrinterDto } from './dto/update-thermal-printer.dto';
import { FindAllThermalPrintersDto } from './dto/find-all-thermal-printers.dto';
import { DiscoveryService } from './discovery.service';
import { DiscoveredPrinterDto } from './dto/discovered-printer.dto';
import { ThermalPrinter } from './domain/thermal-printer';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { Paginated } from '../common/types/paginated.type';
@ApiTags('Thermal Printers')
@Controller({
  path: 'thermal-printers',
  version: '1',
})
export class ThermalPrintersController {
  constructor(
    private readonly thermalPrintersService: ThermalPrintersService,
    private readonly discoveryService: DiscoveryService,
  ) {}
  @Post()
  @ApiBearerAuth()
  @Roles(RoleEnum.admin)
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'Crear una nueva impresora térmica' })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'Impresora creada exitosamente.',
    type: ThermalPrinter,
  })
  create(
    @Body() createThermalPrinterDto: CreateThermalPrinterDto,
  ): Promise<ThermalPrinter> {
    return this.thermalPrintersService.create(createThermalPrinterDto);
  }
  @Get()
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Obtener lista paginada de impresoras térmicas' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Lista de impresoras obtenida.',
    type: Paginated,
  })
  async findAll(
    @Query() query: FindAllThermalPrintersDto,
  ): Promise<Paginated<ThermalPrinter>> {
    const page = query?.page ?? 1;
    let limit = query?.limit ?? 10;
    if (limit > 50) {
      limit = 50;
    }
    const paginationOptions: IPaginationOptions = {
      page,
      limit,
    };
    const [data, total] = await this.thermalPrintersService.findAll(
      query,
      paginationOptions,
    );
    return new Paginated(data, total, page, limit);
  }
  @Get('/discover')
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Descubrir impresoras térmicas en la red (TCP Scan + ARP)',
  })
  @ApiQuery({
    name: 'scanTimeout',
    required: false,
    description: 'Timeout por puerto TCP (ms)',
    type: Number,
    example: 500,
  })
  @ApiQuery({
    name: 'maxConcurrency',
    required: false,
    description: 'Concurrencia TCP',
    type: Number,
    example: 100,
  })
  @ApiQuery({
    name: 'ports',
    required: false,
    description: 'Puertos TCP a escanear (separados por coma)',
    type: String,
    example: '9100,631,515',
  })
  @ApiQuery({
    name: 'subnet',
    required: false,
    description: 'Subred a escanear (ej: 192.168.1.0/24, auto si se omite)',
    type: String,
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Lista de impresoras descubiertas.',
    type: [DiscoveredPrinterDto],
  })
  async discoverPrinters(
    @Query('scanTimeout', new DefaultValuePipe(500), ParseIntPipe)
    scanTimeout?: number,
    @Query('maxConcurrency', new DefaultValuePipe(100), ParseIntPipe)
    maxConcurrency?: number,
    @Query(
      'ports',
      new DefaultValuePipe('9100,631,515'),
      new ParseArrayPipe({ items: Number, separator: ',', optional: true }),
    )
    ports?: number[],
    @Query('subnet') subnet?: string,
  ): Promise<DiscoveredPrinterDto[]> {
    const options = {
      scanTimeout,
      maxConcurrency,
      ports,
      subnet: subnet || null,
    };
    return this.discoveryService.discoverPrinters(options);
  }
  @Get(':id')
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Obtener detalles de una impresora térmica por ID' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Detalles de la impresora.',
    type: ThermalPrinter,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Impresora no encontrada.',
  })
  findOne(@Param('id', ParseUUIDPipe) id: string): Promise<ThermalPrinter> {
    return this.thermalPrintersService.findOne(id);
  }
  @Get(':id/ping')
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Verificar conexión con una impresora térmica (ping)',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Resultado de la prueba de conexión.',
    schema: { example: { status: 'online' } },
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Impresora no encontrada.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'La prueba de ping no aplica para este tipo de conexión.',
  })
  @ApiResponse({
    status: HttpStatus.SERVICE_UNAVAILABLE,
    description: 'No se pudo conectar a la impresora.',
  })
  async pingPrinter(
    @Param('id', ParseUUIDPipe) id: string,
  ): Promise<{ status: string }> {
    return this.thermalPrintersService.pingPrinter(id);
  }
  @Post('test-print')
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'))
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Imprimir ticket de prueba en una impresora descubierta',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Ticket de prueba impreso exitosamente.',
    schema: {
      example: {
        success: true,
        message: 'Ticket de prueba impreso correctamente',
      },
    },
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Datos de impresora inválidos.',
  })
  @ApiResponse({
    status: HttpStatus.SERVICE_UNAVAILABLE,
    description: 'No se pudo conectar a la impresora.',
  })
  async testPrint(
    @Body() printerInfo: { ip: string; port: number; connectionType: string },
  ): Promise<{ success: boolean; message?: string }> {
    return this.thermalPrintersService.testPrint(printerInfo);
  }
  @Patch(':id')
  @ApiBearerAuth()
  @Roles(RoleEnum.admin)
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Actualizar una impresora térmica por ID' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Impresora actualizada.',
    type: ThermalPrinter,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Impresora no encontrada.',
  })
  update(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updateThermalPrinterDto: UpdateThermalPrinterDto,
  ): Promise<ThermalPrinter> {
    return this.thermalPrintersService.update(id, updateThermalPrinterDto);
  }
  @Delete(':id')
  @ApiBearerAuth()
  @Roles(RoleEnum.admin)
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Eliminar una impresora térmica por ID' })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'Impresora eliminada.',
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Impresora no encontrada.',
  })
  async remove(@Param('id', ParseUUIDPipe) id: string): Promise<void> {
    await this.thermalPrintersService.remove(id);
  }
}

================
File: backend/src/users/domain/user.ts
================
import { Exclude, Expose } from 'class-transformer';
import { Role } from '../../roles/domain/role';
import { GenderEnum } from '../enums/gender.enum';
import { PreparationScreen } from '../../preparation-screens/domain/preparation-screen';
export class User {
  @Expose()
  id: string;
  @Expose({ groups: ['me', 'admin'] })
  email: string | null;
  @Expose()
  username: string;
  @Exclude({ toPlainOnly: true })
  password?: string;
  @Expose()
  firstName: string | null;
  @Expose()
  lastName: string | null;
  @Expose({ groups: ['me', 'admin'] })
  birthDate: Date | null;
  @Expose({ groups: ['me', 'admin'] })
  gender: GenderEnum | null;
  @Expose({ groups: ['me', 'admin'] })
  phoneNumber: string | null;
  @Expose({ groups: ['me', 'admin'] })
  address: string | null;
  @Expose({ groups: ['me', 'admin'] })
  city: string | null;
  @Expose({ groups: ['me', 'admin'] })
  state: string | null;
  @Expose({ groups: ['me', 'admin'] })
  country: string | null;
  @Expose({ groups: ['me', 'admin'] })
  zipCode: string | null;
  @Expose({ groups: ['me', 'admin'] })
  emergencyContact: Record<string, any> | null;
  @Expose({ groups: ['me', 'admin'] })
  role: Role;
  @Expose({ groups: ['me', 'admin'] })
  isActive: boolean;
  @Expose({ groups: ['me', 'admin'] })
  preparationScreen?: PreparationScreen | null;
  @Expose({ groups: ['me', 'admin'] })
  createdAt: Date;
  @Expose({ groups: ['me', 'admin'] })
  updatedAt: Date;
  @Expose({ groups: ['me', 'admin'] })
  deletedAt: Date;
}

================
File: backend/src/users/dto/create-user.dto.ts
================
import { Transform, Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  MinLength,
  IsEnum,
  IsISO8601,
  IsString,
  IsObject,
  IsBoolean,
} from 'class-validator';
import { RoleDto } from '../../roles/dto/role.dto';
import { lowerCaseTransformer } from '../../utils/transformers/lower-case.transformer';
import { GenderEnum } from '../enums/gender.enum';
export class CreateUserDto {
  @ApiProperty({ example: 'test1@example.com', type: String })
  @Transform(lowerCaseTransformer)
  @IsOptional()
  @IsEmail()
  email?: string | null;
  @ApiProperty({ example: 'johndoe', type: String })
  @IsNotEmpty()
  username: string;
  @ApiProperty()
  @MinLength(6)
  password?: string;
  @ApiProperty({ example: 'John', type: String })
  @IsNotEmpty()
  firstName: string | null;
  @ApiProperty({ example: 'Doe', type: String })
  @IsNotEmpty()
  lastName: string | null;
  @ApiPropertyOptional({ example: '1990-01-01' })
  @IsOptional()
  @IsISO8601()
  birthDate?: string;
  @ApiPropertyOptional({ enum: GenderEnum, enumName: 'GenderEnum' })
  @IsOptional()
  @IsEnum(GenderEnum)
  gender?: GenderEnum;
  @ApiPropertyOptional({ example: '+1234567890' })
  @IsOptional()
  @IsString()
  phoneNumber?: string;
  @ApiPropertyOptional({ example: '123 Main St' })
  @IsOptional()
  @IsString()
  address?: string;
  @ApiPropertyOptional({ example: 'New York' })
  @IsOptional()
  @IsString()
  city?: string;
  @ApiPropertyOptional({ example: 'NY' })
  @IsOptional()
  @IsString()
  state?: string;
  @ApiPropertyOptional({ example: 'USA' })
  @IsOptional()
  @IsString()
  country?: string;
  @ApiPropertyOptional({ example: '10001' })
  @IsOptional()
  @IsString()
  zipCode?: string;
  @ApiPropertyOptional({
    example: {
      name: 'Jane Doe',
      relationship: 'Spouse',
      phoneNumber: '1987654321',
    },
  })
  @IsOptional()
  @IsObject()
  emergencyContact?: Record<string, any>;
  @ApiProperty({ type: RoleDto })
  @IsNotEmpty({ message: 'El rol es obligatorio' })
  @Type(() => RoleDto)
  role: RoleDto;
  @ApiPropertyOptional({ example: true })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

================
File: backend/src/users/dto/query-user.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsBoolean,
  IsNumber,
  IsOptional,
  IsString,
  ValidateNested,
} from 'class-validator';
import { Transform, Type, plainToInstance } from 'class-transformer';
import { User } from '../domain/user';
import { RoleDto } from '../../roles/dto/role.dto';
export class FilterUserDto {
  @ApiPropertyOptional({ type: RoleDto })
  @IsOptional()
  @ValidateNested({ each: true })
  @Type(() => RoleDto)
  roles?: RoleDto[] | null;
  @ApiPropertyOptional({ type: Boolean })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}
export class SortUserDto {
  @ApiProperty()
  @Type(() => String)
  @IsString()
  orderBy: keyof User;
  @ApiProperty()
  @IsString()
  order: string;
}
export class QueryUserDto {
  @ApiPropertyOptional()
  @Transform(({ value }) => (value ? Number(value) : 1))
  @IsNumber()
  @IsOptional()
  page?: number;
  @ApiPropertyOptional()
  @Transform(({ value }) => (value ? Number(value) : 10))
  @IsNumber()
  @IsOptional()
  limit?: number;
  @ApiPropertyOptional({ type: String })
  @IsOptional()
  @Transform(({ value }) =>
    value ? plainToInstance(FilterUserDto, JSON.parse(value)) : undefined,
  )
  @ValidateNested()
  @Type(() => FilterUserDto)
  filters?: FilterUserDto | null;
  @ApiPropertyOptional({ type: String })
  @IsOptional()
  @Transform(({ value }) => {
    return value ? plainToInstance(SortUserDto, JSON.parse(value)) : undefined;
  })
  @ValidateNested({ each: true })
  @Type(() => SortUserDto)
  sort?: SortUserDto[] | null;
}

================
File: backend/src/users/dto/update-user-preparation-screens.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsUUID } from 'class-validator';
export class UpdateUserPreparationScreensDto {
  @ApiProperty({
    type: [String],
    example: ['123e4567-e89b-12d3-a456-426614174000'],
  })
  @IsArray()
  @IsUUID('all', { each: true })
  preparationScreenIds: string[];
}

================
File: backend/src/users/dto/update-user.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { Transform, Type } from 'class-transformer';
import {
  IsEmail,
  IsOptional,
  MinLength,
  IsEnum,
  IsISO8601,
  IsString,
  IsObject,
  IsBoolean,
} from 'class-validator';
import { RoleDto } from '../../roles/dto/role.dto';
import { lowerCaseTransformer } from '../../utils/transformers/lower-case.transformer';
import { GenderEnum } from '../enums/gender.enum';
export class UpdateUserDto {
  @ApiPropertyOptional({ example: 'test1@example.com', type: String })
  @Transform(lowerCaseTransformer)
  @IsOptional()
  @IsEmail()
  email?: string | null;
  @ApiPropertyOptional({ example: 'johndoe', type: String })
  @IsOptional()
  @IsEmail()
  username?: string;
  @ApiPropertyOptional()
  @IsOptional()
  @MinLength(6)
  password?: string;
  @ApiPropertyOptional({ example: 'John', type: String })
  @IsOptional()
  firstName?: string | null;
  @ApiPropertyOptional({ example: 'Doe', type: String })
  @IsOptional()
  lastName?: string | null;
  @ApiPropertyOptional({ example: '1990-01-01' })
  @IsOptional()
  @IsISO8601()
  @Transform(({ value }) => (value ? new Date(value) : null))
  birthDate?: Date | null;
  @ApiPropertyOptional({ enum: GenderEnum, enumName: 'GenderEnum' })
  @IsOptional()
  @IsEnum(GenderEnum)
  gender?: GenderEnum | null;
  @ApiPropertyOptional({ example: '+1234567890' })
  @IsOptional()
  @IsString()
  phoneNumber?: string | null;
  @ApiPropertyOptional({ example: '123 Main St' })
  @IsOptional()
  @IsString()
  address?: string | null;
  @ApiPropertyOptional({ example: 'New York' })
  @IsOptional()
  @IsString()
  city?: string | null;
  @ApiPropertyOptional({ example: 'NY' })
  @IsOptional()
  @IsString()
  state?: string | null;
  @ApiPropertyOptional({ example: 'USA' })
  @IsOptional()
  @IsString()
  country?: string | null;
  @ApiPropertyOptional({ example: '10001' })
  @IsOptional()
  @IsString()
  zipCode?: string | null;
  @ApiPropertyOptional({
    example: {
      name: 'Jane Doe',
      relationship: 'Spouse',
      phoneNumber: '+1987654321',
    },
  })
  @IsOptional()
  @IsObject()
  emergencyContact?: Record<string, any> | null;
  @ApiPropertyOptional({ type: () => RoleDto })
  @IsOptional()
  @Type(() => RoleDto)
  role?: RoleDto | null;
  @ApiPropertyOptional({ example: true, type: Boolean })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

================
File: backend/src/users/dto/user.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsUUID } from 'class-validator';
export class UserDto {
  @ApiProperty({
    type: String,
    example: 'a1b2c3d4-e5f6-7890-1234-567890abcdef',
  })
  @IsNotEmpty()
  @IsUUID()
  id: string;
}

================
File: backend/src/users/enums/gender.enum.ts
================
export enum GenderEnum {
  MALE = 'male',
  FEMALE = 'female',
  OTHER = 'other',
  PREFER_NOT_TO_SAY = 'prefer_not_to_say',
}

================
File: backend/src/users/infrastructure/persistence/relational/entities/user.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  Index,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { RoleEntity } from '../../../../../roles/infrastructure/persistence/relational/entities/role.entity';
import { GenderEnum } from '../../../../enums/gender.enum';
import { PreparationScreenEntity } from '../../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
@Entity({
  name: 'user',
})
export class UserEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ type: String, unique: true, nullable: true })
  email: string | null;
  @Column({ type: String, unique: true, nullable: false })
  username: string;
  @Column({ nullable: true })
  password?: string;
  @Index()
  @Column({ type: String, nullable: true })
  firstName: string | null;
  @Index()
  @Column({ type: String, nullable: true })
  lastName: string | null;
  @Column({ type: 'date', nullable: true })
  birthDate: Date | null;
  @Column({ type: 'enum', enum: GenderEnum, nullable: true })
  gender: GenderEnum | null;
  @Column({ type: String, nullable: true })
  phoneNumber: string | null;
  @Column({ type: String, nullable: true })
  address: string | null;
  @Column({ type: String, nullable: true })
  city: string | null;
  @Column({ type: String, nullable: true })
  state: string | null;
  @Column({ type: String, nullable: true })
  country: string | null;
  @Column({ type: String, nullable: true })
  zipCode: string | null;
  @Column({ type: 'jsonb', nullable: true })
  emergencyContact: Record<string, any> | null;
  @ManyToOne(() => RoleEntity, {
    eager: true,
    nullable: false,
  })
  role: RoleEntity;
  @Column({ type: 'boolean', default: true })
  isActive: boolean;
  @ManyToOne(
    () => PreparationScreenEntity,
    (preparationScreen) => preparationScreen.users,
    { eager: false, nullable: true },
  )
  preparationScreen?: PreparationScreenEntity | null;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date;
}

================
File: backend/src/users/infrastructure/persistence/relational/mappers/user.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { RoleEntity } from '../../../../../roles/infrastructure/persistence/relational/entities/role.entity';
import { User } from '../../../../domain/user';
import { UserEntity } from '../entities/user.entity';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
import { PreparationScreen } from '../../../../../preparation-screens/domain/preparation-screen';
@Injectable()
export class UserMapper extends BaseMapper<UserEntity, User> {
  override toDomain(entity: UserEntity): User | null {
    if (!entity) return null;
    const domain = new User();
    domain.id = entity.id;
    domain.email = entity.email;
    domain.username = entity.username;
    domain.password = entity.password;
    domain.firstName = entity.firstName;
    domain.lastName = entity.lastName;
    domain.isActive = entity.isActive;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    domain.birthDate = entity.birthDate;
    domain.gender = entity.gender;
    domain.phoneNumber = entity.phoneNumber;
    domain.address = entity.address;
    domain.city = entity.city;
    domain.state = entity.state;
    domain.country = entity.country;
    domain.zipCode = entity.zipCode;
    domain.emergencyContact = entity.emergencyContact;
    if (entity.role) {
      domain.role = {
        id: entity.role.id,
        name: entity.role.name ?? null,
      };
    }
    if (entity.preparationScreen) {
      const screen = new PreparationScreen();
      screen.id = entity.preparationScreen.id;
      screen.name = entity.preparationScreen.name;
      screen.description = entity.preparationScreen.description;
      screen.isActive = entity.preparationScreen.isActive;
      screen.createdAt = entity.preparationScreen.createdAt;
      screen.updatedAt = entity.preparationScreen.updatedAt;
      screen.deletedAt = entity.preparationScreen.deletedAt;
      screen.products = null;
      screen.users = null;
      domain.preparationScreen = screen;
    } else {
      domain.preparationScreen = null;
    }
    return domain;
  }
  override toEntity(domain: User): UserEntity | null {
    if (!domain) return null;
    if (!domain.role) {
      throw new Error(
        'User domain entity must have a role to be mapped to persistence.',
      );
    }
    const role = new RoleEntity();
    role.id = Number(domain.role.id);
    const entity = new UserEntity();
    if (domain.id) {
      entity.id = domain.id;
    }
    entity.email = domain.email;
    entity.username = domain.username;
    entity.password = domain.password;
    entity.firstName = domain.firstName;
    entity.lastName = domain.lastName;
    entity.role = role;
    entity.isActive = domain.isActive;
    entity.birthDate = domain.birthDate;
    entity.gender = domain.gender;
    entity.phoneNumber = domain.phoneNumber;
    entity.address = domain.address;
    entity.city = domain.city;
    entity.state = domain.state;
    entity.country = domain.country;
    entity.zipCode = domain.zipCode;
    entity.emergencyContact = domain.emergencyContact;
    return entity;
  }
}

================
File: backend/src/users/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { UsersRelationalRepository } from './repositories/user.repository';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserEntity } from './entities/user.entity';
import { UserMapper } from './mappers/user.mapper';
import { USER_REPOSITORY } from '../../../../common/tokens';
import { PreparationScreenEntity } from '../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
@Module({
  imports: [TypeOrmModule.forFeature([UserEntity, PreparationScreenEntity])],
  providers: [
    {
      provide: USER_REPOSITORY,
      useClass: UsersRelationalRepository,
    },
    UserMapper,
  ],
  exports: [USER_REPOSITORY, UserMapper],
})
export class RelationalUserPersistenceModule {}

================
File: backend/src/users/infrastructure/persistence/relational/repositories/user.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FindOptionsWhere, Repository, In } from 'typeorm';
import { UserEntity } from '../entities/user.entity';
import { NullableType } from '../../../../../utils/types/nullable.type';
import { FilterUserDto, SortUserDto } from '../../../../dto/query-user.dto';
import { User } from '../../../../domain/user';
import { UserRepository } from '../../user.repository';
import { UserMapper } from '../mappers/user.mapper';
import { IPaginationOptions } from '../../../../../utils/types/pagination-options';
import { PreparationScreenEntity } from '../../../../../preparation-screens/infrastructure/persistence/relational/entities/preparation-screen.entity';
@Injectable()
export class UsersRelationalRepository implements UserRepository {
  constructor(
    @InjectRepository(UserEntity)
    private readonly usersRepository: Repository<UserEntity>,
    @InjectRepository(PreparationScreenEntity)
    private readonly preparationScreensRepository: Repository<PreparationScreenEntity>,
    private readonly userMapper: UserMapper,
  ) {}
  async create(data: User): Promise<User> {
    const persistenceModel = this.userMapper.toEntity(data);
    if (!persistenceModel) {
      throw new Error('Failed to map user domain to entity');
    }
    const newEntity = await this.usersRepository.save(
      this.usersRepository.create(persistenceModel),
    );
    const domainResult = this.userMapper.toDomain(newEntity);
    if (!domainResult) {
      throw new Error('Failed to map new user entity to domain');
    }
    return domainResult;
  }
  async findManyWithPagination({
    filterOptions,
    sortOptions,
    paginationOptions,
  }: {
    filterOptions?: FilterUserDto | null;
    sortOptions?: SortUserDto[] | null;
    paginationOptions: IPaginationOptions;
  }): Promise<User[]> {
    const where: FindOptionsWhere<UserEntity> = {};
    if (filterOptions?.roles?.length) {
      where.role = filterOptions.roles.map((role) => ({
        id: Number(role.id),
      }));
    }
    const entities = await this.usersRepository.find({
      skip: (paginationOptions.page - 1) * paginationOptions.limit,
      take: paginationOptions.limit,
      where: where,
      order: sortOptions?.reduce(
        (accumulator, sort) => ({
          ...accumulator,
          [sort.orderBy]: sort.order,
        }),
        {},
      ),
      relations: ['preparationScreen'],
    });
    return entities
      .map((user) => this.userMapper.toDomain(user))
      .filter((user): user is User => user !== null);
  }
  async findById(id: User['id']): Promise<NullableType<User>> {
    const entity = await this.usersRepository.findOne({
      where: { id: id },
      relations: ['preparationScreen'],
    });
    return entity ? this.userMapper.toDomain(entity) : null;
  }
  async findByIds(ids: User['id'][]): Promise<User[]> {
    const entities = await this.usersRepository.find({
      where: { id: In(ids) },
      relations: ['preparationScreen'],
    });
    return entities
      .map((user) => this.userMapper.toDomain(user))
      .filter((user): user is User => user !== null);
  }
  async findByEmail(email: User['email']): Promise<NullableType<User>> {
    if (!email) return null;
    const entity = await this.usersRepository.findOne({
      where: { email },
      relations: ['preparationScreen'],
    });
    return entity ? this.userMapper.toDomain(entity) : null;
  }
  async findByUsername(
    username: User['username'],
  ): Promise<NullableType<User>> {
    if (!username) return null;
    const entity = await this.usersRepository.findOne({
      where: { username },
      relations: ['preparationScreen'],
    });
    return entity ? this.userMapper.toDomain(entity) : null;
  }
  async update(id: User['id'], payload: Partial<User>): Promise<User> {
    const entity = await this.usersRepository.findOne({
      where: { id: id },
      relations: ['preparationScreen'],
    });
    if (!entity) {
      throw new Error('User not found');
    }
    const existingDomain = this.userMapper.toDomain(entity);
    if (!existingDomain) {
      throw new Error('Failed to map existing user entity to domain');
    }
    const persistenceModel = this.userMapper.toEntity({
      ...existingDomain,
      ...payload,
    });
    if (!persistenceModel) {
      throw new Error('Failed to map updated user domain to entity');
    }
    const updatedEntity = await this.usersRepository.save(
      this.usersRepository.create(persistenceModel),
    );
    const domainResult = this.userMapper.toDomain(updatedEntity);
    if (!domainResult) {
      throw new Error('Failed to map updated user entity to domain');
    }
    return domainResult;
  }
  async remove(id: User['id']): Promise<void> {
    await this.usersRepository.softDelete(id);
  }
  async updatePreparationScreen(
    id: User['id'],
    preparationScreenId: string | null,
  ): Promise<User | null> {
    const entity = await this.usersRepository.findOne({
      where: { id: id },
    });
    if (!entity) {
      throw new Error('User not found');
    }
    let preparationScreen: PreparationScreenEntity | null = null;
    if (preparationScreenId) {
      preparationScreen = await this.preparationScreensRepository.findOne({
        where: { id: preparationScreenId },
      });
      if (!preparationScreen) {
        throw new Error('Preparation screen not found');
      }
    }
    entity.preparationScreen = preparationScreen;
    await this.usersRepository.save(entity);
    const refreshedEntity = await this.usersRepository.findOne({
      where: { id: id },
      relations: ['preparationScreen'],
    });
    if (!refreshedEntity) {
      throw new Error('Failed to load updated user');
    }
    const domainResult = this.userMapper.toDomain(refreshedEntity);
    if (!domainResult) {
      throw new Error('Failed to map updated user entity to domain');
    }
    return domainResult;
  }
}

================
File: backend/src/users/infrastructure/persistence/user.repository.ts
================
import { DeepPartial } from '../../../utils/types/deep-partial.type';
import { NullableType } from '../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../utils/types/pagination-options';
import { User } from '../../domain/user';
import { FilterUserDto, SortUserDto } from '../../dto/query-user.dto';
export abstract class UserRepository {
  abstract create(
    data: Omit<User, 'id' | 'createdAt' | 'deletedAt' | 'updatedAt'>,
  ): Promise<User>;
  abstract findManyWithPagination({
    filterOptions,
    sortOptions,
    paginationOptions,
  }: {
    filterOptions?: FilterUserDto | null;
    sortOptions?: SortUserDto[] | null;
    paginationOptions: IPaginationOptions;
  }): Promise<User[]>;
  abstract findById(id: User['id']): Promise<NullableType<User>>;
  abstract findByIds(ids: User['id'][]): Promise<User[]>;
  abstract findByEmail(email: User['email']): Promise<NullableType<User>>;
  abstract findByUsername(
    username: User['username'],
  ): Promise<NullableType<User>>;
  abstract update(
    id: User['id'],
    payload: DeepPartial<User>,
  ): Promise<User | null>;
  abstract remove(id: User['id']): Promise<void>;
  abstract updatePreparationScreen(
    id: User['id'],
    preparationScreenId: string | null,
  ): Promise<User | null>;
}

================
File: backend/src/users/users.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Query,
  HttpStatus,
  HttpCode,
  SerializeOptions,
} from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { UpdateUserPreparationScreensDto } from './dto/update-user-preparation-screens.dto';
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
  ApiParam,
  ApiTags,
} from '@nestjs/swagger';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { AuthGuard } from '@nestjs/passport';
import {
  InfinityPaginationResponse,
  InfinityPaginationResponseDto,
} from '../utils/dto/infinity-pagination-response.dto';
import { NullableType } from '../utils/types/nullable.type';
import { QueryUserDto } from './dto/query-user.dto';
import { User } from './domain/user';
import { UsersService } from './users.service';
import { RolesGuard } from '../roles/roles.guard';
import { infinityPagination } from '../utils/infinity-pagination';
@ApiBearerAuth()
@Roles(RoleEnum.admin)
@UseGuards(AuthGuard('jwt'), RolesGuard)
@ApiTags('Users')
@Controller({
  path: 'users',
  version: '1',
})
export class UsersController {
  constructor(private readonly usersService: UsersService) {}
  @ApiCreatedResponse({
    type: User,
  })
  @SerializeOptions({
    groups: ['admin'],
  })
  @Post()
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createProfileDto: CreateUserDto): Promise<User> {
    return this.usersService.create(createProfileDto);
  }
  @ApiOkResponse({
    type: InfinityPaginationResponse(User),
  })
  @SerializeOptions({
    groups: ['admin'],
  })
  @Get()
  @HttpCode(HttpStatus.OK)
  async findAll(
    @Query() query: QueryUserDto,
  ): Promise<InfinityPaginationResponseDto<User>> {
    const page = query?.page ?? 1;
    let limit = query?.limit ?? 10;
    if (limit > 50) {
      limit = 50;
    }
    return infinityPagination(
      await this.usersService.findManyWithPagination({
        filterOptions: query?.filters,
        sortOptions: query?.sort,
        paginationOptions: {
          page,
          limit,
        },
      }),
      { page, limit },
    );
  }
  @ApiOkResponse({
    type: User,
  })
  @SerializeOptions({
    groups: ['admin'],
  })
  @Get(':id')
  @HttpCode(HttpStatus.OK)
  @ApiParam({
    name: 'id',
    type: String,
    required: true,
  })
  findOne(@Param('id') id: User['id']): Promise<NullableType<User>> {
    return this.usersService.findById(id);
  }
  @ApiOkResponse({
    type: User,
  })
  @SerializeOptions({
    groups: ['admin'],
  })
  @Patch(':id')
  @HttpCode(HttpStatus.OK)
  @ApiParam({
    name: 'id',
    type: String,
    required: true,
  })
  update(
    @Param('id') id: User['id'],
    @Body() updateProfileDto: UpdateUserDto,
  ): Promise<User | null> {
    return this.usersService.update(id, updateProfileDto);
  }
  @Delete(':id')
  @ApiParam({
    name: 'id',
    type: String,
    required: true,
  })
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id') id: User['id']): Promise<void> {
    return this.usersService.remove(id);
  }
  @ApiOkResponse({
    type: User,
  })
  @SerializeOptions({
    groups: ['admin'],
  })
  @Patch(':id/preparation-screens')
  @HttpCode(HttpStatus.OK)
  @ApiParam({
    name: 'id',
    type: String,
    required: true,
  })
  updatePreparationScreens(
    @Param('id') id: User['id'],
    @Body() updateUserPreparationScreensDto: UpdateUserPreparationScreensDto,
  ): Promise<User | null> {
    return this.usersService.updatePreparationScreens(
      id,
      updateUserPreparationScreensDto.preparationScreenIds,
    );
  }
  @Get(':id/debug-screen')
  @ApiParam({
    name: 'id',
    type: String,
    required: true,
  })
  @HttpCode(HttpStatus.OK)
  async debugUserScreen(@Param('id') id: string) {
    const user = await this.usersService.findById(id);
    return {
      userId: user?.id,
      username: user?.username,
      roleId: user?.role?.id,
      hasPreparationScreen: !!user?.preparationScreen,
      preparationScreenId: user?.preparationScreen?.id,
      preparationScreenName: user?.preparationScreen?.name,
    };
  }
}

================
File: backend/src/users/users.module.ts
================
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { RelationalUserPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { UserMapper } from './infrastructure/persistence/relational/mappers/user.mapper';
import { PreparationScreensModule } from '../preparation-screens/preparation-screens.module';
const infrastructurePersistenceModule = RelationalUserPersistenceModule;
@Module({
  imports: [infrastructurePersistenceModule, PreparationScreensModule],
  controllers: [UsersController],
  providers: [UsersService, UserMapper],
  exports: [UsersService, infrastructurePersistenceModule],
})
export class UsersModule {}

================
File: backend/src/users/users.service.ts
================
import {
  HttpStatus,
  Inject,
  Injectable,
  UnprocessableEntityException,
} from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { NullableType } from '../utils/types/nullable.type';
import { FilterUserDto, SortUserDto } from './dto/query-user.dto';
import { UserRepository } from './infrastructure/persistence/user.repository';
import { User } from './domain/user';
import bcrypt from 'bcryptjs';
import { RoleEnum } from '../roles/roles.enum';
import { USER_REPOSITORY } from '../common/tokens';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { Role } from '../roles/domain/role';
import { UpdateUserDto } from './dto/update-user.dto';
import { ERROR_CODES } from '../common/constants/error-codes.constants';
import { PreparationScreenRepository } from '../preparation-screens/infrastructure/persistence/preparation-screen.repository';
import { PREPARATION_SCREEN_REPOSITORY } from '../common/tokens';
@Injectable()
export class UsersService {
  constructor(
    @Inject(USER_REPOSITORY) private readonly usersRepository: UserRepository,
    @Inject(PREPARATION_SCREEN_REPOSITORY)
    private readonly preparationScreensRepository: PreparationScreenRepository,
  ) {}
  async create(createUserDto: CreateUserDto): Promise<User> {
    let password: string | undefined = undefined;
    if (createUserDto.password) {
      const salt = await bcrypt.genSalt();
      password = await bcrypt.hash(createUserDto.password, salt);
    }
    let email: string | null = null;
    if (createUserDto.email) {
      const userObject = await this.usersRepository.findByEmail(
        createUserDto.email,
      );
      if (userObject) {
        throw new UnprocessableEntityException({
          code: ERROR_CODES.AUTH_DUPLICATE_EMAIL,
          message: 'El correo electrónico ya está registrado.',
          details: { field: 'email' },
        });
      }
      email = createUserDto.email;
    }
    const userByUsername = await this.usersRepository.findByUsername(
      createUserDto.username,
    );
    if (userByUsername) {
      throw new UnprocessableEntityException({
        code: ERROR_CODES.AUTH_DUPLICATE_USERNAME,
        message: 'El nombre de usuario ya está en uso.',
        details: { field: 'username' },
      });
    }
    const roleExists = Object.values(RoleEnum)
      .map(String)
      .includes(String(createUserDto.role.id));
    if (!roleExists) {
      throw new UnprocessableEntityException({
        status: HttpStatus.UNPROCESSABLE_ENTITY,
        errors: {
          role: 'roleNotExists',
        },
      });
    }
    const role: Role = {
      id: createUserDto.role.id,
      name: null,
    };
    let birthDate: Date | null = null;
    if (createUserDto.birthDate) {
      birthDate = new Date(createUserDto.birthDate);
    }
    return this.usersRepository.create({
      firstName: createUserDto.firstName,
      lastName: createUserDto.lastName,
      email: email,
      username: createUserDto.username,
      password: password,
      role: role,
      birthDate: birthDate,
      gender: createUserDto.gender || null,
      phoneNumber: createUserDto.phoneNumber || null,
      address: createUserDto.address || null,
      city: createUserDto.city || null,
      state: createUserDto.state || null,
      country: createUserDto.country || null,
      zipCode: createUserDto.zipCode || null,
      emergencyContact: createUserDto.emergencyContact || null,
      isActive: true,
    });
  }
  findManyWithPagination({
    filterOptions,
    sortOptions,
    paginationOptions,
  }: {
    filterOptions?: FilterUserDto | null;
    sortOptions?: SortUserDto[] | null;
    paginationOptions: IPaginationOptions;
  }): Promise<User[]> {
    return this.usersRepository.findManyWithPagination({
      filterOptions,
      sortOptions,
      paginationOptions,
    });
  }
  findById(id: User['id']): Promise<NullableType<User>> {
    return this.usersRepository.findById(id);
  }
  findByIds(ids: User['id'][]): Promise<User[]> {
    return this.usersRepository.findByIds(ids);
  }
  findByEmail(email: User['email']): Promise<NullableType<User>> {
    return this.usersRepository.findByEmail(email);
  }
  findByUsername(username: User['username']): Promise<NullableType<User>> {
    return this.usersRepository.findByUsername(username);
  }
  async update(
    id: User['id'],
    updateUserDto: UpdateUserDto,
  ): Promise<User | null> {
    let password: string | undefined = undefined;
    if (updateUserDto.password) {
      const userObject = await this.usersRepository.findById(id);
      if (userObject && userObject?.password !== updateUserDto.password) {
        const salt = await bcrypt.genSalt();
        password = await bcrypt.hash(updateUserDto.password, salt);
      }
    }
    let email: string | null | undefined = undefined;
    if (updateUserDto.email) {
      const userObject = await this.usersRepository.findByEmail(
        updateUserDto.email,
      );
      if (userObject && userObject.id !== id) {
        throw new UnprocessableEntityException({
          code: ERROR_CODES.AUTH_DUPLICATE_EMAIL,
          message: 'El correo electrónico ya está registrado por otro usuario.',
          details: { field: 'email' },
        });
      }
      email = updateUserDto.email;
    } else if (updateUserDto.email === null) {
      email = null;
    }
    let username: string | undefined = undefined;
    if (updateUserDto.username) {
      const userObject = await this.usersRepository.findByUsername(
        updateUserDto.username,
      );
      if (userObject && userObject.id !== id) {
        throw new UnprocessableEntityException({
          code: ERROR_CODES.AUTH_DUPLICATE_USERNAME,
          message: 'El nombre de usuario ya está en uso por otro usuario.',
          details: { field: 'username' },
        });
      }
      username = updateUserDto.username;
    }
    let role: Role | undefined = undefined;
    if (updateUserDto.role?.id) {
      const roleObject = Object.values(RoleEnum)
        .map(String)
        .includes(String(updateUserDto.role.id));
      if (!roleObject) {
        throw new UnprocessableEntityException({
          status: HttpStatus.UNPROCESSABLE_ENTITY,
          errors: {
            role: 'roleNotExists',
          },
        });
      }
      role = {
        id: updateUserDto.role.id,
        name: null,
      };
    }
    let birthDate: Date | null | undefined = undefined;
    if (updateUserDto.birthDate) {
      birthDate = updateUserDto.birthDate;
    } else if (updateUserDto.birthDate === null) {
      birthDate = null;
    }
    const updatePayload: Partial<User> = {
      firstName: updateUserDto.firstName,
      lastName: updateUserDto.lastName,
      email: email,
      username: username,
      password: password,
      role: role,
      birthDate: birthDate,
      gender: updateUserDto.gender,
      phoneNumber: updateUserDto.phoneNumber,
      address: updateUserDto.address,
      city: updateUserDto.city,
      state: updateUserDto.state,
      country: updateUserDto.country,
      zipCode: updateUserDto.zipCode,
      emergencyContact: updateUserDto.emergencyContact,
      ...(updateUserDto.isActive !== undefined && {
        isActive: updateUserDto.isActive,
      }),
    };
    const filteredPayload: Partial<User> = {};
    for (const key in updatePayload) {
      if (Object.prototype.hasOwnProperty.call(updatePayload, key)) {
        const value = updatePayload[key as keyof Partial<User>];
        if (value !== undefined) {
          filteredPayload[key as keyof Partial<User>] = value as any;
        }
      }
    }
    const updatedUser = await this.usersRepository.update(id, filteredPayload);
    return updatedUser;
  }
  async remove(id: User['id']): Promise<void> {
    await this.usersRepository.remove(id);
  }
  async updatePreparationScreens(
    id: User['id'],
    preparationScreenIds: string[],
  ): Promise<User | null> {
    const user = await this.usersRepository.findById(id);
    if (!user) {
      throw new UnprocessableEntityException({
        status: HttpStatus.UNPROCESSABLE_ENTITY,
        errors: {
          id: 'userNotExists',
        },
      });
    }
    if (user.role.id !== RoleEnum.kitchen) {
      throw new UnprocessableEntityException({
        status: HttpStatus.UNPROCESSABLE_ENTITY,
        errors: {
          role: 'onlyKitchenUsersCanHavePreparationScreens',
        },
      });
    }
    if (preparationScreenIds.length > 0) {
      const screens =
        await this.preparationScreensRepository.findByIds(preparationScreenIds);
      if (screens.length !== preparationScreenIds.length) {
        throw new UnprocessableEntityException({
          status: HttpStatus.UNPROCESSABLE_ENTITY,
          errors: {
            preparationScreens: 'somePreparationScreensNotExist',
          },
        });
      }
    }
    const screenId =
      preparationScreenIds.length > 0 ? preparationScreenIds[0] : null;
    return this.usersRepository.updatePreparationScreen(id, screenId);
  }
}

================
File: backend/src/utils/deep-resolver.ts
================
async function deepResolvePromises(input) {
  if (input instanceof Promise) {
    return await input;
  }
  if (Array.isArray(input)) {
    const resolvedArray = await Promise.all(input.map(deepResolvePromises));
    return resolvedArray;
  }
  if (input instanceof Date) {
    return input;
  }
  if (typeof input === 'object' && input !== null) {
    const keys = Object.keys(input);
    const resolvedObject = {};
    for (const key of keys) {
      const resolvedValue = await deepResolvePromises(input[key]);
      resolvedObject[key] = resolvedValue;
    }
    return resolvedObject;
  }
  return input;
}
export default deepResolvePromises;

================
File: backend/src/utils/dto/infinity-pagination-response.dto.ts
================
import { Type } from '@nestjs/common';
import { ApiProperty } from '@nestjs/swagger';
export class InfinityPaginationResponseDto<T> {
  data: T[];
  hasNextPage: boolean;
}
export function InfinityPaginationResponse<T>(classReference: Type<T>) {
  abstract class Pagination {
    @ApiProperty({ type: [classReference] })
    data!: T[];
    @ApiProperty({
      type: Boolean,
      example: true,
    })
    hasNextPage: boolean;
  }
  Object.defineProperty(Pagination, 'name', {
    writable: false,
    value: `InfinityPagination${classReference.name}ResponseDto`,
  });
  return Pagination;
}

================
File: backend/src/utils/infinity-pagination.ts
================
import { IPaginationOptions } from './types/pagination-options';
import { InfinityPaginationResponseDto } from './dto/infinity-pagination-response.dto';
export const infinityPagination = <T>(
  data: T[],
  options: IPaginationOptions,
): InfinityPaginationResponseDto<T> => {
  return {
    data,
    hasNextPage: data.length === options.limit,
  };
};

================
File: backend/src/utils/relational-entity-helper.ts
================
import { instanceToPlain } from 'class-transformer';
import { AfterLoad, BaseEntity } from 'typeorm';
export class EntityRelationalHelper extends BaseEntity {
  __entity?: string;
  @AfterLoad()
  setEntityName() {
    this.__entity = this.constructor.name;
  }
  toJSON() {
    return instanceToPlain(this);
  }
}

================
File: backend/src/utils/serializer.interceptor.ts
================
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import deepResolvePromises from './deep-resolver';
@Injectable()
export class ResolvePromisesInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<unknown> {
    return next.handle().pipe(map((data) => deepResolvePromises(data)));
  }
}

================
File: backend/src/utils/transformers/lower-case.transformer.ts
================
import { TransformFnParams } from 'class-transformer/types/interfaces';
import { MaybeType } from '../types/maybe.type';
export const lowerCaseTransformer = (
  params: TransformFnParams,
): MaybeType<string> => params.value?.toLowerCase().trim();

================
File: backend/src/utils/transformers/transform-default.decorator.ts
================
import { Transform, TransformFnParams } from 'class-transformer';
export function TransformDefault(defaultValue: any): PropertyDecorator {
  return Transform(({ value }: TransformFnParams) => {
    if (value !== undefined) {
      return value;
    }
    return defaultValue;
  });
}

================
File: backend/src/utils/types/deep-partial.type.ts
================
export type DeepPartial<T> = {
  [P in keyof T]?: DeepPartial<T[P]>;
};

================
File: backend/src/utils/types/maybe.type.ts
================
export type MaybeType<T> = T | undefined;

================
File: backend/src/utils/types/nullable.type.ts
================
export type NullableType<T> = T | null;

================
File: backend/src/utils/types/or-never.type.ts
================
export type OrNeverType<T> = T | never;

================
File: backend/src/utils/types/pagination-options.ts
================
export interface IPaginationOptions {
  page: number;
  limit: number;
}

================
File: backend/src/utils/types/pagination-params.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsInt, IsOptional, Min } from 'class-validator';
export class PaginationParams {
  @ApiProperty({
    description: 'Page number (starts from 1)',
    required: false,
    default: 1,
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number;
  @ApiProperty({
    description: 'Number of items per page',
    required: false,
    default: 10,
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  limit?: number;
}

================
File: backend/src/utils/validate-config.ts
================
import { plainToClass } from 'class-transformer';
import { validateSync } from 'class-validator';
import { ClassConstructor } from 'class-transformer/types/interfaces';
function validateConfig<T extends object>(
  config: Record<string, unknown>,
  envVariablesClass: ClassConstructor<T>,
) {
  const validatedConfig = plainToClass(envVariablesClass, config, {
    enableImplicitConversion: true,
  });
  const errors = validateSync(validatedConfig, {
    skipMissingProperties: false,
  });
  if (errors.length > 0) {
    throw new Error(errors.toString());
  }
  return validatedConfig;
}
export default validateConfig;

================
File: backend/src/utils/validation-options.ts
================
import {
  HttpStatus,
  UnprocessableEntityException,
  ValidationError,
  ValidationPipeOptions,
} from '@nestjs/common';
function generateErrors(errors: ValidationError[]) {
  return errors.reduce(
    (accumulator, currentValue) => ({
      ...accumulator,
      [currentValue.property]:
        (currentValue.children?.length ?? 0) > 0
          ? generateErrors(currentValue.children ?? [])
          : Object.values(currentValue.constraints ?? {}).join(', '),
    }),
    {},
  );
}
const validationOptions: ValidationPipeOptions = {
  transform: true,
  whitelist: true,
  errorHttpStatusCode: HttpStatus.UNPROCESSABLE_ENTITY,
  exceptionFactory: (errors: ValidationError[]) => {
    return new UnprocessableEntityException({
      status: HttpStatus.UNPROCESSABLE_ENTITY,
      errors: generateErrors(errors),
    });
  },
};
export default validationOptions;

================
File: backend/test/admin/auth.e2e-spec.ts
================
import request from 'supertest';
import { ADMIN_EMAIL, ADMIN_PASSWORD, APP_URL } from '../utils/constants';
describe('Auth', () => {
  const app = APP_URL;
  describe('Admin', () => {
    it('should successfully login via /api/v1/auth/email/login (POST)', () => {
      return request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: ADMIN_EMAIL, password: ADMIN_PASSWORD })
        .expect(200)
        .expect(({ body }) => {
          expect(body.token).toBeDefined();
          expect(body.user.email).toBeDefined();
          expect(body.user.role).toBeDefined();
        });
    });
  });
});

================
File: backend/test/admin/users.e2e-spec.ts
================
import { APP_URL, ADMIN_EMAIL, ADMIN_PASSWORD } from '../utils/constants';
import request from 'supertest';
import { RoleEnum } from '../../src/roles/roles.enum';
describe('Users Module', () => {
  const app = APP_URL;
  let apiToken;
  beforeAll(async () => {
    await request(app)
      .post('/api/v1/auth/email/login')
      .send({ email: ADMIN_EMAIL, password: ADMIN_PASSWORD })
      .then(({ body }) => {
        apiToken = body.token;
      });
  });
  describe('Update', () => {
    let newUser;
    const newUserEmail = `user-first.${Date.now()}@example.com`;
    const newUserChangedEmail = `user-first-changed.${Date.now()}@example.com`;
    const newUserPassword = `secret`;
    const newUserChangedPassword = `new-secret`;
    beforeAll(async () => {
      await request(app)
        .post('/api/v1/auth/email/register')
        .send({
          email: newUserEmail,
          password: newUserPassword,
          firstName: `First${Date.now()}`,
          lastName: 'E2E',
        });
      await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserPassword })
        .then(({ body }) => {
          newUser = body.user;
        });
    });
    describe('User with "Admin" role', () => {
      it('should change password for existing user: /api/v1/users/:id (PATCH)', () => {
        return request(app)
          .patch(`/api/v1/users/${newUser.id}`)
          .auth(apiToken, {
            type: 'bearer',
          })
          .send({
            email: newUserChangedEmail,
            password: newUserChangedPassword,
          })
          .expect(200);
      });
      describe('Guest', () => {
        it('should login with changed password: /api/v1/auth/email/login (POST)', () => {
          return request(app)
            .post('/api/v1/auth/email/login')
            .send({
              email: newUserChangedEmail,
              password: newUserChangedPassword,
            })
            .expect(200)
            .expect(({ body }) => {
              expect(body.token).toBeDefined();
            });
        });
      });
    });
  });
  describe('Create', () => {
    const newUserByAdminEmail = `user-created-by-admin.${Date.now()}@example.com`;
    const newUserByAdminPassword = `secret`;
    describe('User with "Admin" role', () => {
      it('should fail to create new user with invalid email: /api/v1/users (POST)', () => {
        return request(app)
          .post(`/api/v1/users`)
          .auth(apiToken, {
            type: 'bearer',
          })
          .send({ email: 'fail-data' })
          .expect(422);
      });
      it('should successfully create new user: /api/v1/users (POST)', () => {
        return request(app)
          .post(`/api/v1/users`)
          .auth(apiToken, {
            type: 'bearer',
          })
          .send({
            email: newUserByAdminEmail,
            password: newUserByAdminPassword,
            firstName: `UserByAdmin${Date.now()}`,
            lastName: 'E2E',
            role: {
              id: RoleEnum.user,
            },
            status: {
              id: 'active',
            },
          })
          .expect(201);
      });
      describe('Guest', () => {
        it('should successfully login via created by admin user: /api/v1/auth/email/login (GET)', () => {
          return request(app)
            .post('/api/v1/auth/email/login')
            .send({
              email: newUserByAdminEmail,
              password: newUserByAdminPassword,
            })
            .expect(200)
            .expect(({ body }) => {
              expect(body.token).toBeDefined();
            });
        });
      });
    });
  });
  describe('Get many', () => {
    describe('User with "Admin" role', () => {
      it('should get list of users: /api/v1/users (GET)', () => {
        return request(app)
          .get(`/api/v1/users`)
          .auth(apiToken, {
            type: 'bearer',
          })
          .expect(200)
          .send()
          .expect(({ body }) => {
            expect(body.data[0].provider).toBeDefined();
            expect(body.data[0].email).toBeDefined();
            expect(body.data[0].hash).not.toBeDefined();
            expect(body.data[0].password).not.toBeDefined();
          });
      });
    });
  });
});

================
File: backend/test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: backend/test/user/auth.e2e-spec.ts
================
import request from 'supertest';
import {
  APP_URL,
  TESTER_EMAIL,
  TESTER_PASSWORD,
  MAIL_HOST,
  MAIL_PORT,
} from '../utils/constants';
describe('Auth Module', () => {
  const app = APP_URL;
  const mail = `http://${MAIL_HOST}:${MAIL_PORT}`;
  const newUserFirstName = `Tester${Date.now()}`;
  const newUserLastName = `E2E`;
  const newUserEmail = `User.${Date.now()}@example.com`;
  const newUserPassword = `secret`;
  describe('Registration', () => {
    it('should fail with exists email: /api/v1/auth/email/register (POST)', () => {
      return request(app)
        .post('/api/v1/auth/email/register')
        .send({
          email: TESTER_EMAIL,
          password: TESTER_PASSWORD,
          firstName: 'Tester',
          lastName: 'E2E',
        })
        .expect(422)
        .expect(({ body }) => {
          expect(body.errors.email).toBeDefined();
        });
    });
    it('should successfully: /api/v1/auth/email/register (POST)', async () => {
      return request(app)
        .post('/api/v1/auth/email/register')
        .send({
          email: newUserEmail,
          password: newUserPassword,
          firstName: newUserFirstName,
          lastName: newUserLastName,
        })
        .expect(204);
    });
    describe('Login', () => {
      it('should successfully with unconfirmed email: /api/v1/auth/email/login (POST)', () => {
        return request(app)
          .post('/api/v1/auth/email/login')
          .send({ email: newUserEmail, password: newUserPassword })
          .expect(200)
          .expect(({ body }) => {
            expect(body.token).toBeDefined();
          });
      });
    });
    describe('Confirm email', () => {
      it('should successfully: /api/v1/auth/email/confirm (POST)', async () => {
        const hash = await request(mail)
          .get('/email')
          .then(({ body }) =>
            body
              .find(
                (letter) =>
                  letter.to[0].address.toLowerCase() ===
                    newUserEmail.toLowerCase() &&
                  /.*confirm\-email\?hash\=(\S+).*/g.test(letter.text),
              )
              ?.text.replace(/.*confirm\-email\?hash\=(\S+).*/g, '$1'),
          );
        return request(app)
          .post('/api/v1/auth/email/confirm')
          .send({
            hash,
          })
          .expect(204);
      });
      it('should fail for already confirmed email: /api/v1/auth/email/confirm (POST)', async () => {
        const hash = await request(mail)
          .get('/email')
          .then(({ body }) =>
            body
              .find(
                (letter) =>
                  letter.to[0].address.toLowerCase() ===
                    newUserEmail.toLowerCase() &&
                  /.*confirm\-email\?hash\=(\S+).*/g.test(letter.text),
              )
              ?.text.replace(/.*confirm\-email\?hash\=(\S+).*/g, '$1'),
          );
        return request(app)
          .post('/api/v1/auth/email/confirm')
          .send({
            hash,
          })
          .expect(404);
      });
    });
  });
  describe('Login', () => {
    it('should successfully for user with confirmed email: /api/v1/auth/email/login (POST)', () => {
      return request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserPassword })
        .expect(200)
        .expect(({ body }) => {
          expect(body.token).toBeDefined();
          expect(body.refreshToken).toBeDefined();
          expect(body.tokenExpires).toBeDefined();
          expect(body.user.email).toBeDefined();
          expect(body.user.hash).not.toBeDefined();
          expect(body.user.password).not.toBeDefined();
        });
    });
  });
  describe('Logged in user', () => {
    let newUserApiToken;
    beforeAll(async () => {
      await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserPassword })
        .then(({ body }) => {
          newUserApiToken = body.token;
        });
    });
    it('should retrieve your own profile: /api/v1/auth/me (GET)', async () => {
      await request(app)
        .get('/api/v1/auth/me')
        .auth(newUserApiToken, {
          type: 'bearer',
        })
        .send()
        .expect(({ body }) => {
          expect(body.provider).toBeDefined();
          expect(body.email).toBeDefined();
          expect(body.hash).not.toBeDefined();
          expect(body.password).not.toBeDefined();
        });
    });
    it('should get new refresh token: /api/v1/auth/refresh (POST)', async () => {
      let newUserRefreshToken = await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserPassword })
        .then(({ body }) => body.refreshToken);
      newUserRefreshToken = await request(app)
        .post('/api/v1/auth/refresh')
        .auth(newUserRefreshToken, {
          type: 'bearer',
        })
        .send()
        .then(({ body }) => body.refreshToken);
      await request(app)
        .post('/api/v1/auth/refresh')
        .auth(newUserRefreshToken, {
          type: 'bearer',
        })
        .send()
        .expect(({ body }) => {
          expect(body.token).toBeDefined();
          expect(body.refreshToken).toBeDefined();
          expect(body.tokenExpires).toBeDefined();
        });
    });
    it('should fail on the second attempt to refresh token with the same token: /api/v1/auth/refresh (POST)', async () => {
      const newUserRefreshToken = await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserPassword })
        .then(({ body }) => body.refreshToken);
      await request(app)
        .post('/api/v1/auth/refresh')
        .auth(newUserRefreshToken, {
          type: 'bearer',
        })
        .send();
      await request(app)
        .post('/api/v1/auth/refresh')
        .auth(newUserRefreshToken, {
          type: 'bearer',
        })
        .send()
        .expect(401);
    });
    it('should update profile successfully: /api/v1/auth/me (PATCH)', async () => {
      const newUserNewName = Date.now();
      const newUserNewPassword = 'new-secret';
      const newUserApiToken = await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserPassword })
        .then(({ body }) => body.token);
      await request(app)
        .patch('/api/v1/auth/me')
        .auth(newUserApiToken, {
          type: 'bearer',
        })
        .send({
          firstName: newUserNewName,
          password: newUserNewPassword,
        })
        .expect(422);
      await request(app)
        .patch('/api/v1/auth/me')
        .auth(newUserApiToken, {
          type: 'bearer',
        })
        .send({
          firstName: newUserNewName,
          password: newUserNewPassword,
          oldPassword: newUserPassword,
        })
        .expect(200);
      await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserNewPassword })
        .expect(200)
        .expect(({ body }) => {
          expect(body.token).toBeDefined();
        });
      await request(app)
        .patch('/api/v1/auth/me')
        .auth(newUserApiToken, {
          type: 'bearer',
        })
        .send({ password: newUserPassword, oldPassword: newUserNewPassword })
        .expect(200);
    });
    it('should update profile email successfully: /api/v1/auth/me (PATCH)', async () => {
      const newUserFirstName = `Tester${Date.now()}`;
      const newUserLastName = `E2E`;
      const newUserEmail = `user.${Date.now()}@example.com`;
      const newUserPassword = `secret`;
      const newUserNewEmail = `new.${newUserEmail}`;
      await request(app)
        .post('/api/v1/auth/email/register')
        .send({
          email: newUserEmail,
          password: newUserPassword,
          firstName: newUserFirstName,
          lastName: newUserLastName,
        })
        .expect(204);
      const newUserApiToken = await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserPassword })
        .then(({ body }) => body.token);
      await request(app)
        .patch('/api/v1/auth/me')
        .auth(newUserApiToken, {
          type: 'bearer',
        })
        .send({
          email: newUserNewEmail,
        })
        .expect(200);
      const hash = await request(mail)
        .get('/email')
        .then(({ body }) =>
          body
            .find((letter) => {
              return (
                letter.to[0].address.toLowerCase() ===
                  newUserNewEmail.toLowerCase() &&
                /.*confirm\-new\-email\?hash\=(\S+).*/g.test(letter.text)
              );
            })
            ?.text.replace(/.*confirm\-new\-email\?hash\=(\S+).*/g, '$1'),
        );
      await request(app)
        .get('/api/v1/auth/me')
        .auth(newUserApiToken, {
          type: 'bearer',
        })
        .expect(200)
        .expect(({ body }) => {
          expect(body.email).not.toBe(newUserNewEmail);
        });
      await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserNewEmail, password: newUserPassword })
        .expect(422);
      await request(app)
        .post('/api/v1/auth/email/confirm/new')
        .send({
          hash,
        })
        .expect(204);
      await request(app)
        .get('/api/v1/auth/me')
        .auth(newUserApiToken, {
          type: 'bearer',
        })
        .expect(200)
        .expect(({ body }) => {
          expect(body.email).toBe(newUserNewEmail);
        });
      await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserNewEmail, password: newUserPassword })
        .expect(200);
    });
    it('should delete profile successfully: /api/v1/auth/me (DELETE)', async () => {
      const newUserApiToken = await request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserPassword })
        .then(({ body }) => body.token);
      await request(app).delete('/api/v1/auth/me').auth(newUserApiToken, {
        type: 'bearer',
      });
      return request(app)
        .post('/api/v1/auth/email/login')
        .send({ email: newUserEmail, password: newUserPassword })
        .expect(422);
    });
  });
});

================
File: backend/test/utils/constants.ts
================
export const APP_URL = `http://localhost:${process.env.APP_PORT}`;
export const TESTER_EMAIL = 'john.doe@example.com';
export const TESTER_PASSWORD = 'secret';
export const ADMIN_EMAIL = 'admin@example.com';
export const ADMIN_PASSWORD = 'secret';
export const MAIL_HOST = process.env.MAIL_HOST;
export const MAIL_PORT = process.env.MAIL_CLIENT_PORT;

================
File: backend/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: backend/tsconfig.cli.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2021",
    "allowJs": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*", "scripts/**/*"],
  "exclude": ["node_modules", "dist", "test"]
}

================
File: backend/tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false,
    "esModuleInterop": true,
    "strictPropertyInitialization": false
  }
}

================
File: CLAUDE.md
================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Instrucciones Importantes

**IMPORTANTE**: Siempre responder en español en todas las interacciones.

## Project Overview

This is a restaurant management system with two main components:
- **Backend**: NestJS API for restaurant operations (orders, products, thermal printing, etc.)
- **App**: React Native mobile app built with Expo

## Backend Commands

### Development
```bash
cd backend
npm install
npm run start:dev     # Start in watch mode (puerto 3737)
npm run start:debug   # Start with debugger (puerto 3737)
npm run start:prod    # Start production build (puerto 3737)
```

**IMPORTANTE**: El backend ahora usa el puerto 3737 para permitir auto-descubrimiento desde la app.

### Database & Migrations
```bash
npm run migration:generate -- src/database/migrations/MigrationName
npm run migration:run
npm run migration:revert
npm run seed:run:relational  # Run database seeds

# Reset de la base de datos
npm run db:reset           # Elimina TODA la base de datos y la recrea vacía
npm run db:clear-migrations # Solo elimina la tabla de migraciones
npm run db:fresh           # Reset completo + migraciones + seeds
```

### Testing & Quality
```bash
npm run test              # Unit tests
npm run test:e2e          # E2E tests
npm run test:cov          # Coverage report
npm run lint              # ESLint
npm run format            # Prettier format
```

### Code Generation
```bash
npm run generate:resource:relational  # Generate new CRUD resource
npm run add:property:to-relational    # Add property to existing entity
```

## App Commands

### Development
```bash
cd app
npm install

# Comandos directos
npm run start           # Start Expo dev server
npm run ios             # Run on iOS simulator
npm run android         # Run on Android emulator  
npm run web             # Run in web browser
```

### Desarrollo con Dispositivo Físico

**Configuración inicial (una sola vez):**
1. Instala el APK en tu dispositivo:
   ```bash
   adb install build-*.apk
   ```

**Desarrollo diario:**
```bash
cd app
npm start    # Inicia el servidor de desarrollo
```

**Nota:** Si tienes problemas de conexión de red, puedes usar `npx expo start --tunnel` para un modo más confiable aunque ligeramente más lento.

### Building (Local con EAS)

#### Setup Inicial (solo la primera vez)
```bash
# 1. Instalar herramientas necesarias
cd app
./scripts/install-java.sh        # Instala Java
./scripts/install-android-sdk.sh # Instala Android SDK (si existe)
source ~/.bashrc                 # Cargar variables de entorno

# 2. Login en EAS
npx eas login
```

#### Crear Builds Locales
```bash
npm run build:ios:sim      # Build para iOS simulator
npm run build:android:sim  # Build para Android emulator
npm run build:ios:dev      # Build para iOS device  
npm run build:android:dev  # Build para Android device (APK)
npm run build:android:prod # Build de producción
```

#### Instalar y Ejecutar
```bash
# Instalar APK en dispositivo Android
adb install build-*.apk

# Ejecutar servidor de desarrollo
npm start
```

**Nota**: Los archivos de build se generan en la raíz del proyecto como `build-*.apk`

### Testing & Quality
```bash
npm run test            # Jest tests
npm run test:watch      # Jest in watch mode
npm run lint            # ESLint with auto-fix
npm run compile         # TypeScript check
npm run compile:check   # TypeScript check (ignorando errores conocidos de React)
```

### Problemas Conocidos

#### Incompatibilidad de Tipos de React
Actualmente hay un problema conocido de incompatibilidad entre las versiones de React, React Native y sus tipos. Los siguientes errores pueden ignorarse temporalmente:
- "cannot be used as a JSX component"
- "is not a valid JSX element"
- "Type 'undefined' is not assignable to type 'Element | null'"
- "Property 'children' is missing in type 'ReactElement'"
- "Property 'refs' is missing in type"

Estos errores son causados por conflictos de versiones en el ecosistema y no afectan el funcionamiento de la aplicación. Para verificar solo errores reales, usa: `npm run compile:check`

## Architecture Overview

### Backend Architecture

**Core Business Modules:**
- `orders/` - Order management with history tracking via TypeORM subscribers
- `products/` - Products with variants and modifiers
- `thermal-printers/` - Network printer discovery and printing
- `payments/` - Payment processing
- `customers/` - Customer and address management
- `areas/` & `tables/` - Restaurant layout management
- `restaurant-config/` - Restaurant configuration (hours, acceptance status)
- `audio-order-processing/` - Voice order processing with remote AI service integration

**Infrastructure Patterns:**
- Repository pattern with TypeORM entities
- Domain models separate from entities
- DTOs for request/response validation
- Mappers for entity-domain conversion
- Module-based organization following NestJS conventions
- Subscriber pattern for order history tracking

**Key Features:**
- JWT authentication with refresh tokens
- Email-based auth (no social logins implemented)
- File uploads supporting local/S3 storage (configurable via FILE_DRIVER)
- Swagger API documentation on all endpoints
- Order change tracking with jsondiffpatch
- Thermal printer integration via node-thermal-printer
- Voice order processing with speech recognition and AI parsing

### App Architecture

**Navigation:**
- React Navigation with drawer and stack navigators
- Authentication flow separate from main app flow
- Module-based navigation structure
- Each module has its own navigation stack

**State Management:**
- Zustand stores for global state (auth, theme, snackbar)
- React Query for API state and caching
- AsyncStorage for persistence
- React Hook Form for form state management

**Key Screens:**
- Order creation with product customization and voice input
- Open orders management
- Product catalog with categories and variants
- Table and area configuration
- Thermal printer setup and testing
- Restaurant configuration management

**API Integration:**
- Custom API client with interceptors
- Automatic token refresh
- Error mapping and handling
- Image caching system
- Axios with retry mechanism

**Module Structure:**
```
app/src/modules/
├── auth/           # Authentication screens and logic
├── orders/         # Order management and creation
├── products/       # Product catalog and management
├── tables/         # Table and area management
├── printers/       # Thermal printer configuration
├── payments/       # Payment processing
├── customers/      # Customer management
└── restaurantConfig/ # Restaurant settings
```

## Important Configuration

### Backend Environment
Create `.env` from `env-example-relational`:
- `APP_PORT` - Puerto del servidor (debe ser 3737)
- `DATABASE_*` - PostgreSQL connection
- `FILE_DRIVER` - 'local', 's3', or 's3-presigned'
- `AUTH_JWT_SECRET` - Must be changed in production
- `MAIL_*` - Email service configuration
- `CLOUD_API_URL` - URL for remote services (sync, audio processing)
- `CLOUD_API_KEY` - API key for remote services authentication

### App Configuration
- **Auto-descubrimiento**: La app encuentra automáticamente el backend en la red local (puerto 3737)
- **Cero configuración**: No requiere archivos `.env` ni configuración manual
- Module-specific services in each module's `services/` directory
- Global configuration in `app/constants/`
- Theme configuration in `app/styles/`
- Path aliases: `@/` resolves to `src/`

### Sistema de Auto-Descubrimiento
La app implementa un sistema robusto de auto-descubrimiento del backend:
1. Escanea la red local buscando el servidor en el puerto 3737
2. Cachea la URL encontrada para uso posterior
3. Incluye fallback para última URL conocida
4. Soporta re-descubrimiento manual si cambia la IP del servidor

## Development Notes

### Backend
1. Uses PostgreSQL with TypeORM
2. Order changes automatically tracked via subscribers
3. Thermal printer discovery uses network scanning
4. Hygen generators for scaffolding new resources
5. TypeORM migrations must be generated after entity changes
6. Seeds can be run with `npm run seed:run:relational`

### App
1. Supports both light and dark themes
2. Material Design 3 with React Native Paper
3. Custom theme system with consistent spacing
4. React Hook Form with Zod validation
5. FlashList for performant lists
6. Image caching with expo-image

### Common Patterns
1. All API responses follow consistent format with data/message/errors
2. Error handling uses custom error types
3. Form validation uses Zod schemas
4. Lists use FlashList for performance
5. Navigation types are strictly typed
6. Services layer abstracts API calls from components

================
File: Dockerfile
================
FROM node:18-alpine

# Install build dependencies including SQLite
RUN apk add --no-cache python3 make g++ sqlite sqlite-dev

WORKDIR /app

# Copy all files
COPY . .

# Install all dependencies with verbose output
RUN npm install --verbose

# Build cloud-service
WORKDIR /app/cloud-service
RUN echo "=== Current directory before build ===" && pwd && ls -la
RUN npm run build || (echo "Build failed. Package.json content:" && cat package.json && exit 1)

# Verify build output
RUN echo "=== After build, current directory ===" && pwd && ls -la
RUN if [ -d "dist" ]; then \
      echo "=== dist found, searching for JS files ===" && \
      find dist -type f -name "*.js" | head -20; \
    else \
      echo "=== dist not found! ===" && \
      exit 1; \
    fi

EXPOSE 5000

# Make scripts executable
RUN chmod +x start.sh
RUN chmod +x health-check.js || true

# Add a simple test to verify the app can at least load
RUN node -e "console.log('Node.js is working')"

CMD ["./start.sh"]

================
File: package.json
================
{
  "name": "bite-monorepo",
  "private": true,
  "workspaces": [
    "backend",
    "app",
    "shared"
  ],
  "scripts": {
    "backend:dev": "npm run start:dev --workspace=backend",
    "app:start": "npm run start --workspace=app",
    "install:all": "npm install",
    "lint": "npm run lint --workspaces --if-present",
    "format": "npm run format --workspaces --if-present"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  },
  "version": "1.0.0"
}

================
File: railway.json
================
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "DOCKERFILE",
    "dockerfilePath": "./Dockerfile"
  },
  "deploy": {
    "numReplicas": 1,
    "healthcheckPath": "/api/sync/health",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 3
  }
}

================
File: shared/package.json
================
{
  "name": "@bite/shared",
  "version": "1.0.0",
  "description": "Shared types and constants for bite monorepo",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "watch": "tsc --watch"
  },
  "devDependencies": {
    "typescript": "^5.1.3"
  }
}

================
File: shared/src/index.ts
================
export * from './types';

================
File: shared/src/types/customer.types.ts
================
export interface CustomerDeliveryInfo {
  id?: string;
  customerId: string;
  streetAddress: string;
  neighborhood?: string;
  postalCode?: string;
  city: string;
  state?: string;
  country?: string;
  latitude?: number;
  longitude?: number;
  pickupName?: string;
  additionalDetails?: string;
  createdAt?: Date;
  updatedAt?: Date;
}
export interface CloudCustomer {
  id?: string;
  phoneNumber: string;
  deliveryInfo?: CustomerDeliveryInfo;
  lastInteraction?: Date;
  createdAt?: Date;
  updatedAt?: Date;
}

================
File: shared/src/types/index.ts
================
export * from './order.types';
export * from './customer.types';
export * from './webhook.types';

================
File: shared/src/types/webhook.types.ts
================
export interface WhatsAppMessage {
  from: string;
  type: 'text' | 'interactive' | 'audio' | 'image' | 'document';
  id: string;
  timestamp: string;
  text?: { body: string };
  interactive?: {
    type: string;
    button_reply?: { id: string; title: string };
    list_reply?: { id: string; title: string };
  };
  audio?: { id: string };
  context?: { id: string };
}
export interface WebhookEntry {
  changes: Array<{
    value: {
      messages?: WhatsAppMessage[];
      metadata?: {
        display_phone_number: string;
        phone_number_id: string;
      };
    };
  }>;
}
export interface WebhookBody {
  object: string;
  entry: WebhookEntry[];
}

================
File: shared/tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

================
File: app/.eslintrc.js
================
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2021,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true,
    },
    project: './tsconfig.json',
  },
  plugins: [
    '@typescript-eslint',
    'react',
    'react-hooks',
    'react-native',
    'prettier',
  ],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:react-native/all',
    'prettier',
  ],
  env: {
    'react-native/react-native': true,
    node: true,
    es2021: true,
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
  rules: {
    '@typescript-eslint/no-unused-vars': ['error', {
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^_',
      ignoreRestSiblings: true
    }],
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-namespace': 'off',
    'react/react-in-jsx-scope': 'off',
    'react/prop-types': 'off',
    'react/display-name': 'off',
    'react-native/no-inline-styles': 'error',
    'react-native/no-color-literals': 'off',
    'react-native/no-raw-text': 'off',
    'react-native/sort-styles': 'off',
    'react-native/no-unused-styles': 'off',
    'react-hooks/exhaustive-deps': 'warn',
    'react-hooks/rules-of-hooks': 'error',
    'no-console': ['warn', { allow: ['warn', 'error', 'info'] }],
    'prettier/prettier': 'error',
    'no-empty': ['error', { allowEmptyCatch: true }],
    'no-prototype-builtins': 'off',
  },
  ignorePatterns: [
    'node_modules/',
    'android/',
    'ios/',
    '.expo/',
    'babel.config.js',
    'metro.config.js',
    '*.config.js',
    '.eslintrc.js',
  ],
};

================
File: app/eas.json
================
{
  "cli": {
    "version": ">= 16.3.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      }
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      },
      "env": {
        "NODE_ENV": "production"
      }
    },
    "production": {
      "autoIncrement": true,
      "android": {
        "buildType": "app-bundle"
      },
      "env": {
        "NODE_ENV": "production"
      }
    },
    "release": {
      "android": {
        "buildType": "apk"
      }
    },
    "production-apk": {
      "autoIncrement": true,
      "android": {
        "buildType": "apk"
      },
      "env": {
        "NODE_ENV": "production"
      }
    }
  },
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "./google-play-service-account.json",
        "track": "internal",
        "releaseStatus": "draft",
        "changesNotSentForReview": false
      }
    }
  }
}

================
File: app/index.ts
================
import { registerRootComponent } from 'expo';
import App from './App';
registerRootComponent(App);

================
File: app/scripts/check-new-arch-compatibility.js
================
const fs = require('fs');
const path = require('path');
const checkCompatibility = (packageName) => {
  const packagePath = path.join(__dirname, '../node_modules', packageName);
  if (!fs.existsSync(packagePath)) {
    return { status: 'not-found', packageName };
  }
  const indicators = {
    turboModules: false,
    fabric: false,
    codegen: false,
    reactNativeConfig: false
  };
  const packageJsonPath = path.join(packagePath, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    if (packageJson.codegenConfig) {
      indicators.codegen = true;
    }
  }
  const rnConfigPath = path.join(packagePath, 'react-native.config.js');
  if (fs.existsSync(rnConfigPath)) {
    indicators.reactNativeConfig = true;
  }
  const searchFiles = (dir, depth = 0) => {
    if (!fs.existsSync(dir) || depth > 3) return;
    try {
      const files = fs.readdirSync(dir);
      for (const file of files) {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        if (stat.isDirectory() && !file.includes('node_modules') && !file.startsWith('.')) {
          searchFiles(filePath, depth + 1);
        } else if ((file.endsWith('.js') || file.endsWith('.ts') || file.endsWith('.tsx')) && stat.size < 100000) {
          try {
            const content = fs.readFileSync(filePath, 'utf8');
            if (content.includes('TurboModule')) indicators.turboModules = true;
            if (content.includes('codegenNativeComponent')) indicators.fabric = true;
          } catch (e) {
          }
        }
      }
    } catch (e) {
    }
  };
  searchFiles(packagePath);
  const isCompatible = indicators.turboModules || indicators.fabric || indicators.codegen;
  return {
    packageName,
    status: isCompatible ? 'compatible' : 'unknown',
    indicators
  };
};
const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8'));
const allDependencies = {
  ...packageJson.dependencies,
  ...packageJson.devDependencies
};
const nativeDependencies = Object.keys(allDependencies).filter(dep =>
  dep.startsWith('react-native') ||
  dep.startsWith('expo') ||
  dep.startsWith('@react-native') ||
  dep.includes('react-native') ||
  dep === '@shopify/flash-list'
);
console.log('🔍 Verificando compatibilidad con Nueva Arquitectura...\n');
console.log(`📦 Total de dependencias nativas encontradas: ${nativeDependencies.length}\n`);
const results = {
  compatible: [],
  unknown: [],
  notFound: []
};
nativeDependencies.forEach(dep => {
  const result = checkCompatibility(dep);
  const emoji = result.status === 'compatible' ? '✅' : '⚠️';
  if (result.status === 'compatible') {
    results.compatible.push(dep);
    console.log(`${emoji} ${result.packageName}: Compatible`);
    const indicators = Object.entries(result.indicators)
      .filter(([_, value]) => value)
      .map(([key]) => key);
    if (indicators.length > 0) {
      console.log(`   Indicadores encontrados: ${indicators.join(', ')}`);
    }
  } else if (result.status === 'unknown') {
    results.unknown.push(dep);
    console.log(`${emoji} ${result.packageName}: Compatibilidad desconocida`);
  } else {
    results.notFound.push(dep);
    console.log(`❌ ${result.packageName}: No encontrado`);
  }
});
console.log('\n📊 Resumen:');
console.log(`✅ Compatibles: ${results.compatible.length}`);
console.log(`⚠️  Desconocidas: ${results.unknown.length}`);
console.log(`❌ No encontradas: ${results.notFound.length}`);
console.log('\n💡 Recomendaciones:');
if (results.unknown.length > 0) {
  console.log('- Las bibliotecas con compatibilidad desconocida pueden funcionar con el Interop Layer');
  console.log('- Verifica la documentación oficial de cada biblioteca');
  console.log('- Considera buscar alternativas para bibliotecas críticas sin soporte');
}
console.log('\n📚 Para más información, consulta NEW_ARCHITECTURE_COMPATIBILITY.md');

================
File: app/src/app/components/responsive/ResponsiveGrid.tsx
================
import React, { ReactNode, useMemo, Children } from 'react';
import { View, ViewStyle, StyleProp, DimensionValue } from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';
interface ResponsiveGridProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;
  columns?: number;
  columnsTablet?: number;
  columnsLandscape?: number;
  minItemWidth?: number;
  rows?: number;
  minItemHeight?: number;
  gap?: number;
  gapTablet?: number;
  rowGap?: number;
  columnGap?: number;
  padding?: number;
  alignItems?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justifyContent?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';
  fillLastRow?: boolean;
  equalHeight?: boolean;
  itemStyle?: StyleProp<ViewStyle>;
  itemPadding?: number;
}
interface GridItemProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;
  span?: number;
  spanTablet?: number;
}
export const GridItem: React.FC<GridItemProps> = ({
  children,
  style,
  span = 1,
  spanTablet,
}) => {
  const responsive = useResponsive();
  const actualSpan = responsive.isTablet && spanTablet ? spanTablet : span;
  return <View style={[{ flex: actualSpan }, style]}>{children}</View>;
};
export const ResponsiveGrid: React.FC<ResponsiveGridProps> = ({
  children,
  style,
  columns = 1,
  columnsTablet,
  columnsLandscape,
  minItemWidth,
  rows,
  minItemHeight,
  gap = 16,
  gapTablet,
  rowGap,
  columnGap,
  padding = 0,
  alignItems = 'stretch',
  justifyContent = 'flex-start',
  fillLastRow = false,
  equalHeight = false,
  itemStyle,
  itemPadding = 0,
}) => {
  const responsive = useResponsive();
  const calculateColumns = useMemo(() => {
    if (minItemWidth) {
      return responsive.getGridColumns(minItemWidth, gap, padding);
    }
    if (responsive.isLandscape && columnsLandscape) {
      return columnsLandscape;
    }
    if (responsive.isTablet && columnsTablet) {
      return columnsTablet;
    }
    return columns;
  }, [
    columns,
    columnsTablet,
    columnsLandscape,
    minItemWidth,
    gap,
    padding,
    responsive,
  ]);
  const actualGap =
    responsive.isTablet && gapTablet !== undefined ? gapTablet : gap;
  const scaledGap = responsive.scaleWidth(actualGap);
  const actualRowGap =
    rowGap !== undefined ? responsive.scaleHeight(rowGap) : scaledGap;
  const actualColumnGap =
    columnGap !== undefined ? responsive.scaleWidth(columnGap) : scaledGap;
  const processedChildren = useMemo(() => {
    const childArray = Children.toArray(children);
    const gridRows: ReactNode[][] = [];
    for (let i = 0; i < childArray.length; i += calculateColumns) {
      const row = childArray.slice(i, i + calculateColumns);
      if (
        fillLastRow &&
        row.length < calculateColumns &&
        i + calculateColumns >= childArray.length
      ) {
        while (row.length < calculateColumns) {
          row.push(
            <View key={`empty-${i}-${row.length}`} style={{ flex: 1 }} />,
          );
        }
      }
      gridRows.push(row);
    }
    return gridRows;
  }, [children, calculateColumns, fillLastRow]);
  const containerStyle = useMemo(() => {
    const baseStyle: ViewStyle = {
      padding: responsive.scaleWidth(padding),
    };
    if (rows && minItemHeight) {
      baseStyle.height =
        rows * (minItemHeight + actualRowGap) - actualRowGap + padding * 2;
    }
    return [baseStyle, style];
  }, [padding, rows, minItemHeight, actualRowGap, responsive, style]);
  const rowStyle = useMemo(() => {
    const style: ViewStyle = {
      flexDirection: 'row',
      justifyContent,
      alignItems,
    };
    if (equalHeight) {
      style.alignItems = 'stretch';
    }
    return style;
  }, [justifyContent, alignItems, equalHeight]);
  const gridItemStyle = useMemo(() => {
    const style: ViewStyle = {
      flex: 1,
      padding: responsive.scaleWidth(itemPadding),
    };
    if (minItemHeight) {
      style.minHeight = responsive.scaleHeight(minItemHeight);
    }
    return [style, itemStyle];
  }, [itemPadding, minItemHeight, responsive, itemStyle]);
  return (
    <View style={containerStyle}>
      {processedChildren.map((row, rowIndex) => (
        <View
          key={`row-${rowIndex}`}
          style={[
            rowStyle,
            rowIndex < processedChildren.length - 1 && {
              marginBottom: actualRowGap,
            },
          ]}
        >
          {row.map((child, colIndex) => (
            <View
              key={`item-${rowIndex}-${colIndex}`}
              style={[
                gridItemStyle,
                colIndex < row.length - 1 && { marginRight: actualColumnGap },
              ]}
            >
              {child}
            </View>
          ))}
        </View>
      ))}
    </View>
  );
};
export const ResponsiveFlexGrid: React.FC<ResponsiveGridProps> = ({
  children,
  style,
  columns = 2,
  columnsTablet,
  minItemWidth,
  gap = 16,
  gapTablet,
  padding = 0,
  alignItems = 'stretch',
  justifyContent = 'flex-start',
  itemStyle,
}) => {
  const responsive = useResponsive();
  const calculateColumns = minItemWidth
    ? responsive.getGridColumns(minItemWidth, gap, padding)
    : responsive.isTablet && columnsTablet
      ? columnsTablet
      : columns;
  const itemWidth = `${100 / calculateColumns - (gap * (calculateColumns - 1)) / calculateColumns}%`;
  const actualGap =
    responsive.isTablet && gapTablet !== undefined ? gapTablet : gap;
  const containerStyle: ViewStyle = {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent,
    alignItems,
    padding: responsive.scaleWidth(padding),
    gap: responsive.scaleWidth(actualGap),
  };
  const flexItemStyle: ViewStyle = {
    width: itemWidth as DimensionValue,
    minWidth: minItemWidth || 0,
  };
  return (
    <View style={[containerStyle, style]}>
      {Children.map(children, (child, index) => (
        <View key={index} style={[flexItemStyle, itemStyle]}>
          {child}
        </View>
      ))}
    </View>
  );
};

================
File: app/src/app/constants/apiErrorCodes.ts
================
export const ERROR_CODES = {
  AUTH_INVALID_CREDENTIALS: 'AUTH_INVALID_CREDENTIALS',
  AUTH_INCORRECT_PASSWORD: 'AUTH_INCORRECT_PASSWORD',
  AUTH_DUPLICATE_EMAIL: 'AUTH_DUPLICATE_EMAIL',
  AUTH_DUPLICATE_USERNAME: 'AUTH_DUPLICATE_USERNAME',
  AUTH_UNAUTHORIZED: 'AUTH_UNAUTHORIZED',
  AUTH_FORBIDDEN: 'AUTH_FORBIDDEN',
  REFRESH_FAILED: 'REFRESH_FAILED',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',
  CONFLICT_ERROR: 'CONFLICT_ERROR',
  PRODUCT_NAME_EXISTS: 'PRODUCT_NAME_EXISTS',
  NETWORK_ERROR: 'NETWORK_ERROR',
  API_CLIENT_ERROR: 'API_CLIENT_ERROR',
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
  UNKNOWN_API_ERROR: 'UNKNOWN_API_ERROR',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR',
  UPLOAD_FAILED: 'UPLOAD_FAILED',
  FILE_TOO_LARGE: 'FILE_TOO_LARGE',
} as const;
export type ApiErrorCode = (typeof ERROR_CODES)[keyof typeof ERROR_CODES];

================
File: app/src/app/lib/imageUploadService.ts
================
import {
  uploadFile,
  FileUploadResponse,
} from '../../modules/menu/services/fileService';
import { ApiError } from './errors';
import { getImageUrl } from './imageUtils';
export interface ImageUploadResult {
  success: boolean;
  photoId?: string;
  error?: string;
}
export interface FileObject {
  uri: string;
  name: string;
  type: string;
}
export interface EntityWithOptionalPhoto {
  photo?: {
    id: string;
    path: string;
  } | null;
}
export class ImageUploadService {
  static async uploadImage(imageFile: FileObject): Promise<ImageUploadResult> {
    if (!imageFile || !imageFile.uri) {
      return {
        success: false,
        error: 'No se proporcionó ninguna imagen válida',
      };
    }
    try {
      const uploadResult: FileUploadResponse = await uploadFile(imageFile);
      if (!uploadResult || !uploadResult.file || !uploadResult.file.id) {
        return {
          success: false,
          error: 'Respuesta inválida del servidor al subir imagen.',
        };
      }
      return {
        success: true,
        photoId: uploadResult.file.id,
      };
    } catch (error) {
      let errorMessage = 'Error desconocido al subir la imagen.';
      if (error instanceof ApiError) {
        errorMessage = `Error al subir: ${error.originalMessage || error.code}`;
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      return {
        success: false,
        error: errorMessage,
      };
    }
  }
  static async determinePhotoId(
    formImageUri: string | null | undefined,
    existingEntity?: EntityWithOptionalPhoto,
  ): Promise<undefined | null> {
    const existingPhotoPath = existingEntity?.photo?.path;
    const existingPhotoFullUrl = existingPhotoPath
      ? await getImageUrl(existingPhotoPath)
      : null;
    if (formImageUri && formImageUri.startsWith('file://')) {
      return undefined;
    } else if (
      (formImageUri === null || formImageUri === undefined) &&
      existingEntity?.photo
    ) {
      return null;
    } else if (
      formImageUri &&
      !formImageUri.startsWith('file://') &&
      formImageUri === existingPhotoFullUrl
    ) {
      return undefined;
    } else if (
      formImageUri &&
      !formImageUri.startsWith('file://') &&
      formImageUri !== existingPhotoFullUrl
    ) {
      return undefined;
    } else if (
      (formImageUri === null || formImageUri === undefined) &&
      !existingEntity?.photo
    ) {
      return undefined;
    }
    return undefined;
  }
}

================
File: app/src/app/navigation/AuthStack.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '../styles/theme';
import LoginScreen from '../../modules/auth/screens/LoginScreen';
import type { AuthStackParamList } from './types';
const Stack = createNativeStackNavigator<AuthStackParamList>();
export function AuthStack() {
  const theme = useAppTheme();
  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.primary,
        },
        headerTintColor: theme.colors.onPrimary,
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
        },
      }}
    >
      <Stack.Screen
        name="Login"
        component={LoginScreen}
        options={{
          title: 'Iniciar Sesión',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/app/navigation/ConditionalAppNavigator.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { View, ActivityIndicator } from 'react-native';
import { Portal, Dialog, Button, Text } from 'react-native-paper';
import { useAuthStore } from '../store/authStore';
import { AppDrawerNavigator } from './AppDrawerNavigator';
import { KitchenOnlyNavigator } from './KitchenOnlyNavigator';
import { useAppTheme } from '../styles/theme';
export function ConditionalAppNavigator() {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const logout = useAuthStore((state) => state.logout);
  const [loading, setLoading] = useState(true);
  const [showNoScreenAlert, setShowNoScreenAlert] = useState(false);
  const [isKitchenUser, setIsKitchenUser] = useState(false);
  const checkUserAccess = useCallback(async () => {
    if (!user) {
      setLoading(false);
      return;
    }
    try {
      const roleId = typeof user.role === 'object' ? user.role?.id : null;
      if (roleId === 5) {
        setIsKitchenUser(true);
        const hasScreen = !!user.preparationScreen;
        if (!hasScreen) {
          setShowNoScreenAlert(true);
        }
      } else {
        setIsKitchenUser(false);
      }
    } catch (error) {
      setIsKitchenUser(false);
    } finally {
      setLoading(false);
    }
  }, [user]);
  useEffect(() => {
    checkUserAccess();
  }, [checkUserAccess]);
  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: theme.colors.background,
        }}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }
  return (
    <>
      {isKitchenUser ? <KitchenOnlyNavigator /> : <AppDrawerNavigator />}
      <Portal>
        <Dialog
          visible={showNoScreenAlert}
          onDismiss={() => setShowNoScreenAlert(false)}
          style={{ backgroundColor: theme.colors.surface }}
        >
          <Dialog.Icon
            icon="alert-circle"
            size={64}
            color={theme.colors.error}
          />
          <Dialog.Title style={{ textAlign: 'center' }}>
            Sin Pantalla Asignada
          </Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyLarge" style={{ textAlign: 'center' }}>
              Tu usuario de cocina no tiene una pantalla de preparación
              asignada.
            </Text>
            <Text
              variant="bodyMedium"
              style={{ textAlign: 'center', marginTop: 8 }}
            >
              Por favor, contacta a tu administrador para que te asigne una
              pantalla de preparación.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowNoScreenAlert(false)}>
              Entendido
            </Button>
            <Button
              mode="contained"
              onPress={async () => {
                setShowNoScreenAlert(false);
                await logout();
              }}
            >
              Cerrar Sesión
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </>
  );
}

================
File: app/src/app/navigation/helpers/navigationHelpers.ts
================
import { CommonActions } from '@react-navigation/native';
import { DrawerSection, hasPermission } from '@/app/constants/rolePermissions';
export const ALL_DRAWER_ROUTES: DrawerSection[] = [
  'OrdersStack',
  'ReceiptsStack',
  'OrderFinalizationStack',
  'MenuStack',
  'AvailabilityStack',
  'ModifiersStack',
  'PizzaCustomizationsStack',
  'PreparationScreensStack',
  'AreasTablesStack',
  'PrintersStack',
  'RestaurantConfigStack',
  'CustomersStack',
  'SyncStack',
  'UsersStack',
  'ShiftAuditStack',
  'KitchenStack',
];
export const ROUTE_INITIAL_SCREENS: Record<DrawerSection, string> = {
  OrdersStack: 'Orders',
  ReceiptsStack: 'ReceiptsList',
  OrderFinalizationStack: 'OrderFinalizationScreen',
  MenuStack: 'CategoriesScreen',
  AvailabilityStack: 'AvailabilityScreen',
  ModifiersStack: 'ModifierGroupsScreen',
  PizzaCustomizationsStack: 'PizzaCustomizationsList',
  PreparationScreensStack: 'PreparationScreensList',
  AreasTablesStack: 'AreasList',
  PrintersStack: 'PrintersList',
  RestaurantConfigStack: 'RestaurantConfig',
  CustomersStack: 'Customers',
  SyncStack: 'SyncStatus',
  UsersStack: 'UsersList',
  ShiftAuditStack: 'ShiftsList',
  KitchenStack: 'KitchenOrders',
};
export const generateNavigationAction = (
  targetRoute: DrawerSection,
  userRoleId: number | undefined,
) => {
  const allowedRoutes = ALL_DRAWER_ROUTES.filter((route) =>
    hasPermission(userRoleId, route),
  );
  const targetIndex = allowedRoutes.indexOf(targetRoute);
  if (targetIndex === -1) {
    return null;
  }
  const routes = allowedRoutes.map((route, index) => {
    const baseRoute = { name: route };
    if (index === targetIndex) {
      return {
        ...baseRoute,
        state: {
          routes: [{ name: ROUTE_INITIAL_SCREENS[route] }],
        },
      };
    }
    return baseRoute;
  });
  return CommonActions.reset({
    index: targetIndex,
    routes,
  });
};

================
File: app/src/app/navigation/options.ts
================
import { NativeStackNavigationOptions } from '@react-navigation/native-stack';
import { DrawerNavigationOptions } from '@react-navigation/drawer';
import { AppTheme } from '../styles/theme';
import { ResponsiveInfo } from '../hooks/useResponsive';
export const getDrawerHeaderOptions = (
  theme: AppTheme,
  responsive?: ResponsiveInfo,
): DrawerNavigationOptions => ({
  headerStyle: {
    backgroundColor: theme.colors.primary,
    height: responsive?.dimensions.headerHeight,
  },
  headerTintColor: theme.colors.onPrimary,
  headerTitleStyle: {
    ...theme.fonts.titleLarge,
    color: theme.colors.onPrimary,
    fontWeight: 'bold',
    fontSize: responsive?.fontSize.xl,
  },
  headerShadowVisible: false,
});
export const getStackHeaderOptions = (
  theme: AppTheme,
  responsive?: ResponsiveInfo,
): NativeStackNavigationOptions => ({
  headerStyle: {
    backgroundColor: theme.colors.elevation.level2,
    height: responsive?.dimensions.headerHeight,
  },
  headerTintColor: theme.colors.onSurface,
  headerTitleStyle: {
    ...theme.fonts.titleMedium,
    color: theme.colors.onSurface,
    fontWeight: 'bold',
    fontSize: responsive?.fontSize.l,
  },
  headerTitleAlign: 'center',
  headerShadowVisible: false,
});

================
File: app/src/app/schemas/domain/preparation-screen.schema.ts
================
import { z } from 'zod';
export const preparationScreenSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
});
export type PreparationScreen = z.infer<typeof preparationScreenSchema>;

================
File: app/src/app/types/theme.types.ts
================
import { z } from 'zod';
import { MD3Theme } from 'react-native-paper';
export const themePreferenceSchema = z.enum(['light', 'dark', 'system']);
export type ThemePreference = z.infer<typeof themePreferenceSchema>;
export const THEME_PREFERENCE_STORAGE_KEY = 'app_theme_preference';
export const THEME_MODE = {
  LIGHT: 'light',
  DARK: 'dark',
  SYSTEM: 'system',
} as const;
export interface AppTheme extends MD3Theme {}
export interface ThemeState {
  preference: ThemePreference;
  setPreference: (preference: ThemePreference) => void;
}

================
File: app/src/app/utils/__tests__/dateTimeHelpers.test.ts
================
import {
  safeTimeStringToDate,
  safeDateToTimeString,
  createScheduledDateTime as _createScheduledDateTime,
  roundMinutesToFive,
  parseDateFromBackend,
  getNextAvailableTime,
} from '../dateTimeHelpers';
describe('dateTimeHelpers', () => {
  describe('safeTimeStringToDate', () => {
    it('debe convertir string de hora a Date correctamente', () => {
      const result = safeTimeStringToDate('14:30');
      expect(result.getHours()).toBe(14);
      expect(result.getMinutes()).toBe(30);
      expect(result.getSeconds()).toBe(0);
      expect(result.getMilliseconds()).toBe(0);
    });
    it('debe lanzar error con formato inválido', () => {
      expect(() => safeTimeStringToDate('14:30:00')).toThrow();
      expect(() => safeTimeStringToDate('25:00')).toThrow();
      expect(() => safeTimeStringToDate('14:60')).toThrow();
    });
    it('debe usar fecha base si se proporciona', () => {
      const baseDate = new Date('2024-01-15');
      const result = safeTimeStringToDate('10:00', baseDate);
      expect(result.getFullYear()).toBe(2024);
      expect(result.getMonth()).toBe(0);
      expect(result.getDate()).toBe(15);
    });
  });
  describe('safeDateToTimeString', () => {
    it('debe convertir Date a string HH:mm', () => {
      const date = new Date();
      date.setHours(9, 5);
      expect(safeDateToTimeString(date)).toBe('09:05');
      date.setHours(23, 59);
      expect(safeDateToTimeString(date)).toBe('23:59');
    });
    it('debe lanzar error con fecha inválida', () => {
      expect(() => safeDateToTimeString(new Date('invalid'))).toThrow();
    });
  });
  describe('roundMinutesToFive', () => {
    it('debe redondear minutos correctamente', () => {
      expect(roundMinutesToFive(0)).toBe(0);
      expect(roundMinutesToFive(2)).toBe(0);
      expect(roundMinutesToFive(3)).toBe(5);
      expect(roundMinutesToFive(7)).toBe(5);
      expect(roundMinutesToFive(8)).toBe(10);
      expect(roundMinutesToFive(12)).toBe(10);
      expect(roundMinutesToFive(13)).toBe(15);
      expect(roundMinutesToFive(57)).toBe(55);
      expect(roundMinutesToFive(58)).toBe(60);
    });
  });
  describe('parseDateFromBackend', () => {
    it('debe parsear fechas ISO correctamente', () => {
      const isoString = '2024-01-15T14:30:00.000Z';
      const result = parseDateFromBackend(isoString);
      expect(result).toBeInstanceOf(Date);
      expect(result?.toISOString()).toBe(isoString);
    });
    it('debe retornar null para valores inválidos', () => {
      expect(parseDateFromBackend(null)).toBeNull();
      expect(parseDateFromBackend(undefined)).toBeNull();
      expect(parseDateFromBackend('')).toBeNull();
      expect(parseDateFromBackend('invalid-date')).toBeNull();
    });
  });
  describe('getNextAvailableTime', () => {
    it('debe obtener siguiente hora disponible redondeada', () => {
      const mockNow = new Date('2024-01-15T14:22:00');
      jest.spyOn(global, 'Date').mockImplementation(() => mockNow);
      const result = getNextAvailableTime(30);
      expect(result.getTime()).toBeGreaterThan(mockNow.getTime());
      expect(result.getMinutes() % 5).toBe(0);
      expect(result.getSeconds()).toBe(0);
      expect(result.getMilliseconds()).toBe(0);
      (global.Date as any).mockRestore();
    });
  });
});

================
File: app/src/hooks/useResponsiveFontScale.ts
================
import { useWindowDimensions, PixelRatio } from 'react-native';
interface ResponsiveFontConfig {
  baseSize?: number;
  minScale?: number;
  maxScale?: number;
}
export const useResponsiveFontScale = (config: ResponsiveFontConfig = {}) => {
  const { width, height } = useWindowDimensions();
  const { minScale = 0.8, maxScale = 1.2 } = config;
  const pixelRatio = PixelRatio.get();
  const fontScale = PixelRatio.getFontScale();
  const screenSize = Math.min(width, height);
  const baseScreenSize = 360;
  let scale = screenSize / baseScreenSize;
  scale = Math.max(minScale, Math.min(maxScale, scale));
  scale = scale * fontScale;
  const isTablet = screenSize > 600;
  if (isTablet) {
    scale = scale * 0.85;
  }
  return {
    scale,
    fontSize: (size: number) => Math.round(size * scale),
    isTablet,
    screenSize,
    pixelRatio,
    fontScale,
  };
};
export const getResponsiveFontSize = (
  baseSize: number,
  screenWidth?: number,
): number => {
  const fontScale = PixelRatio.getFontScale();
  const width = screenWidth || 360;
  const baseScreenWidth = 360;
  const scale = Math.min(1.2, Math.max(0.8, width / baseScreenWidth));
  return Math.round(baseSize * scale * fontScale);
};

================
File: app/src/modules/areasTables/hooks/useAreasQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as areaService from '../services/areaService';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  FindAllAreasDto,
} from '../schema/area.schema';
import { BaseListQuery } from '../../../app/types/query.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
const areasQueryKeys = {
  all: ['areas'] as const,
  lists: () => [...areasQueryKeys.all, 'list'] as const,
  list: (filters: FindAllAreasDto & BaseListQuery) =>
    [...areasQueryKeys.lists(), filters] as const,
  details: () => [...areasQueryKeys.all, 'detail'] as const,
  detail: (id: string) => [...areasQueryKeys.details(), id] as const,
};
export const useGetAreas = (
  filters: FindAllAreasDto = {},
  pagination: BaseListQuery = { page: 1, limit: 10 },
) => {
  const queryKey = areasQueryKeys.list({ ...filters, ...pagination });
  return useQuery<Area[], Error>({
    queryKey,
    queryFn: () => areaService.getAreas(filters, pagination),
  });
};
export const useGetAreaById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = areasQueryKeys.detail(id!);
  return useQuery<Area, Error>({
    queryKey,
    queryFn: () => areaService.getAreaById(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};
export const useCreateArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<Area, Error, CreateAreaDto>({
    mutationFn: areaService.createArea,
    onSuccess: (_newArea) => {
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      showSnackbar({ message: 'Área creada con éxito', type: 'success' });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};
export const useUpdateArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  type UpdateAreaContext = { previousAreas?: Area[]; previousDetail?: Area };
  return useMutation<
    Area,
    Error,
    { id: string; data: UpdateAreaDto },
    UpdateAreaContext
  >({
    mutationFn: ({ id, data }) => areaService.updateArea(id, data),
    onMutate: async (variables) => {
      const { id, data } = variables;
      const listQueryKey = areasQueryKeys.lists();
      const detailQueryKey = areasQueryKeys.detail(id);
      await queryClient.cancelQueries({ queryKey: listQueryKey });
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousAreas = queryClient.getQueryData<Area[]>(listQueryKey);
      const previousDetail = queryClient.getQueryData<Area>(detailQueryKey);
      if (previousAreas) {
        queryClient.setQueryData<Area[]>(
          listQueryKey,
          (old) =>
            old?.map((area) =>
              area.id === id ? { ...area, ...data } : area,
            ) ?? [],
        );
      }
      if (previousDetail) {
        queryClient.setQueryData<Area>(
          detailQueryKey,
          (
            old: Area | undefined,
          ) => (old ? { ...old, ...data } : undefined),
        );
      }
      return { previousAreas, previousDetail };
    },
    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      if (context?.previousAreas) {
        queryClient.setQueryData(areasQueryKeys.lists(), context.previousAreas);
      }
      if (context?.previousDetail) {
        queryClient.setQueryData(
          areasQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },
    onSettled: (data, error, variables, _context) => {
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: areasQueryKeys.detail(variables.id),
      });
      if (!error && data) {
        showSnackbar({
          message: 'Área actualizada con éxito',
          type: 'success',
        });
      }
    },
  });
};
export const useDeleteArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  type DeleteAreaContext = { previousDetail?: Area };
  return useMutation<void, Error, string, DeleteAreaContext>({
    mutationFn: areaService.deleteArea,
    onMutate: async (deletedId) => {
      const detailQueryKey = areasQueryKeys.detail(deletedId);
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousDetail = queryClient.getQueryData<Area>(detailQueryKey);
      queryClient.removeQueries({ queryKey: detailQueryKey });
      return { previousDetail };
    },
    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      if (context?.previousDetail) {
        queryClient.setQueryData(
          areasQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },
    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      if (!error) {
        queryClient.removeQueries({
          queryKey: areasQueryKeys.detail(deletedId),
        });
        showSnackbar({ message: 'Área eliminada con éxito', type: 'success' });
      }
    },
  });
};

================
File: app/src/modules/areasTables/hooks/useTablesQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as tableService from '../services/tableService';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  FindAllTablesDto,
} from '../schema/table.schema';
import { BaseListQuery } from '../../../app/types/query.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
const tablesQueryKeys = {
  all: ['tables'] as const,
  lists: () => [...tablesQueryKeys.all, 'list'] as const,
  list: (filters: FindAllTablesDto & BaseListQuery) =>
    [...tablesQueryKeys.lists(), filters] as const,
  listsByArea: (areaId: string) =>
    [...tablesQueryKeys.lists(), { areaId }] as const,
  details: () => [...tablesQueryKeys.all, 'detail'] as const,
  detail: (id: string) => [...tablesQueryKeys.details(), id] as const,
};
export const useGetTables = (
  filters: FindAllTablesDto = {},
  pagination: BaseListQuery = { page: 1, limit: 10 },
) => {
  const queryKey = tablesQueryKeys.list({ ...filters, ...pagination });
  return useQuery<Table[], Error>({
    queryKey,
    queryFn: () => tableService.getTables(filters, pagination),
  });
};
export const useGetTablesByAreaId = (
  areaId: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = tablesQueryKeys.listsByArea(areaId!);
  return useQuery<Table[], Error>({
    queryKey,
    queryFn: () => tableService.getTablesByAreaId(areaId!),
    enabled: !!areaId && (options?.enabled ?? true),
  });
};
export const useGetTableById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = tablesQueryKeys.detail(id!);
  return useQuery<Table, Error>({
    queryKey,
    queryFn: () => tableService.getTableById(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};
export const useCreateTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<Table, Error, CreateTableDto>({
    mutationFn: tableService.createTable,
    onSuccess: (_newTable) => {
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      showSnackbar({ message: 'Mesa creada con éxito', type: 'success' });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};
export const useUpdateTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  type UpdateTableContext = { previousDetail?: Table };
  return useMutation<
    Table,
    Error,
    { id: string; data: UpdateTableDto },
    UpdateTableContext
  >({
    mutationFn: ({ id, data }) => tableService.updateTable(id, data),
    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = tablesQueryKeys.detail(id);
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousDetail = queryClient.getQueryData<Table>(detailQueryKey);
      if (previousDetail) {
        queryClient.setQueryData<Table>(
          detailQueryKey,
          (
            old: Table | undefined,
          ) => (old ? { ...old, ...data } : undefined),
        );
      }
      return { previousDetail };
    },
    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      if (context?.previousDetail) {
        queryClient.setQueryData(
          tablesQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },
    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: tablesQueryKeys.detail(variables.id),
      });
      if (!error && data) {
        showSnackbar({
          message: 'Mesa actualizada con éxito',
          type: 'success',
        });
      }
    },
  });
};
export const useDeleteTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  type DeleteTableContext = { previousDetail?: Table };
  return useMutation<void, Error, string, DeleteTableContext>({
    mutationFn: tableService.deleteTable,
    onMutate: async (deletedId) => {
      const detailQueryKey = tablesQueryKeys.detail(deletedId);
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousDetail = queryClient.getQueryData<Table>(detailQueryKey);
      queryClient.removeQueries({ queryKey: detailQueryKey });
      return { previousDetail };
    },
    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      if (context?.previousDetail) {
        queryClient.setQueryData(
          tablesQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },
    onSettled: (_data, error, deletedId, context) => {
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      if (context?.previousDetail?.areaId) {
        queryClient.invalidateQueries({
          queryKey: tablesQueryKeys.listsByArea(context.previousDetail.areaId),
        });
      }
      if (!error) {
        queryClient.removeQueries({
          queryKey: tablesQueryKeys.detail(deletedId),
        });
        showSnackbar({ message: 'Mesa eliminada con éxito', type: 'success' });
      }
    },
  });
};

================
File: app/src/modules/availability/components/AvailabilityListItem.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Surface, Text, IconButton, Switch } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
interface AvailabilityListItemProps {
  title: string;
  subtitle: string;
  icon: string;
  isActive: boolean;
  onToggle: (value: boolean) => void;
  isExpanded?: boolean;
  onToggleExpand?: () => void;
  children?: React.ReactNode;
}
export const AvailabilityListItem: React.FC<AvailabilityListItemProps> = ({
  title,
  subtitle,
  icon,
  isActive,
  onToggle,
  isExpanded = false,
  onToggleExpand,
  children,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  return (
    <Surface
      style={[styles.container, { backgroundColor: theme.colors.surface }]}
      elevation={1}
    >
      {}
      <TouchableOpacity
        style={[
          styles.header,
          {
            backgroundColor: theme.colors.elevation.level2,
            opacity: isActive ? 1 : 0.7,
          },
        ]}
        onPress={onToggleExpand}
        activeOpacity={0.7}
        disabled={!onToggleExpand}
      >
        <View style={styles.left}>
          <View
            style={[
              styles.iconContainer,
              {
                backgroundColor: isActive
                  ? theme.colors.primaryContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
          >
            <IconButton
              icon={icon}
              size={20}
              iconColor={isActive ? theme.colors.primary : theme.colors.outline}
              style={{ margin: 0 }}
            />
          </View>
          <View style={styles.info}>
            <Text
              style={[styles.title, { color: theme.colors.onSurface }]}
              numberOfLines={1}
            >
              {title}
            </Text>
            <Text
              style={[
                styles.subtitle,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              {subtitle}
            </Text>
          </View>
        </View>
        <View style={styles.right}>
          <Switch
            value={isActive}
            onValueChange={onToggle}
            color={theme.colors.primary}
            style={styles.switch}
          />
          {onToggleExpand && (
            <IconButton
              icon={isExpanded ? 'chevron-up' : 'chevron-down'}
              size={20}
              iconColor={theme.colors.onSurfaceVariant}
              style={{ margin: 0 }}
            />
          )}
        </View>
      </TouchableOpacity>
      {}
      {isExpanded && children && (
        <View
          style={[
            styles.expandedContent,
            { backgroundColor: theme.colors.elevation.level1 },
          ]}
        >
          {children}
        </View>
      )}
    </Surface>
  );
};
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      borderRadius: 16,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m),
    },
    left: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    iconContainer: {
      width: responsive.isTablet ? 32 : 40,
      height: responsive.isTablet ? 32 : 40,
      borderRadius: responsive.isTablet ? 16 : 20,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: responsive.spacing(theme.spacing.m),
    },
    info: {
      flex: 1,
    },
    title: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
      marginBottom: 2,
    },
    subtitle: {
      fontSize: responsive.fontSize(12),
      opacity: 0.8,
    },
    right: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    switch: {
      marginHorizontal: responsive.spacing(theme.spacing.s),
    },
    expandedContent: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
  });

================
File: app/src/modules/availability/hooks/useOptimisticAvailability.ts
================
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { availabilityService } from '../services/availabilityService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import {
  CategoryAvailability,
  SubcategoryAvailability as _SubcategoryAvailability,
  ProductAvailability as _ProductAvailability,
  ModifierGroupAvailability,
  ModifierAvailability as _ModifierAvailability,
  PizzaCustomizationGroupAvailability,
  AvailabilityUpdatePayload,
} from '../types/availability.types';
export const useOptimisticAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const updateOptimistically = (
    type: string,
    id: string,
    isActive: boolean,
    cascade?: boolean,
  ) => {
    const menuQueryKey = ['availability', 'menu'];
    const modifierQueryKey = ['availability', 'modifierGroups'];
    const pizzaQueryKey = ['availability', 'pizzaCustomizations'];
    const updateMenuOptimistically = (oldData: CategoryAvailability[]) => {
      if (!oldData) return oldData;
      return oldData.map((category) => {
        if (type === 'category' && category.id === id) {
          const updated = { ...category, isActive };
          if (cascade) {
            return {
              ...updated,
              subcategories: updated.subcategories.map((sub) => ({
                ...sub,
                isActive,
                products: sub.products.map((prod) => ({ ...prod, isActive })),
              })),
            };
          }
          return updated;
        }
        if (type === 'subcategory') {
          const updatedSubcategories = category.subcategories.map((sub) => {
            if (sub.id === id) {
              const updated = { ...sub, isActive };
              if (cascade) {
                return {
                  ...updated,
                  products: updated.products.map((prod) => ({
                    ...prod,
                    isActive,
                  })),
                };
              }
              return updated;
            }
            return sub;
          });
          return { ...category, subcategories: updatedSubcategories };
        }
        if (type === 'product') {
          const updatedSubcategories = category.subcategories.map((sub) => ({
            ...sub,
            products: sub.products.map((prod) =>
              prod.id === id ? { ...prod, isActive } : prod,
            ),
          }));
          return { ...category, subcategories: updatedSubcategories };
        }
        return category;
      });
    };
    const updateModifierGroupsOptimistically = (
      oldData: ModifierGroupAvailability[],
    ) => {
      if (!oldData) return oldData;
      return oldData.map((group) => {
        if (type === 'modifierGroup' && group.id === id) {
          const updated = { ...group, isActive };
          if (cascade) {
            return {
              ...updated,
              modifiers: updated.modifiers.map((mod) => ({ ...mod, isActive })),
            };
          }
          return updated;
        }
        if (type === 'modifier') {
          const updatedModifiers = group.modifiers.map((mod) =>
            mod.id === id ? { ...mod, isActive } : mod,
          );
          return { ...group, modifiers: updatedModifiers };
        }
        return group;
      });
    };
    const updatePizzaCustomizationsOptimistically = (
      oldData: PizzaCustomizationGroupAvailability[],
    ) => {
      if (!oldData) return oldData;
      return oldData.map((group) => ({
        ...group,
        items: group.items.map((item) =>
          item.id === id ? { ...item, isActive } : item,
        ),
      }));
    };
    if (type === 'category' || type === 'subcategory' || type === 'product') {
      queryClient.setQueryData(menuQueryKey, updateMenuOptimistically);
    } else if (type === 'modifierGroup' || type === 'modifier') {
      queryClient.setQueryData(
        modifierQueryKey,
        updateModifierGroupsOptimistically,
      );
    } else if (type === 'pizzaCustomization') {
      queryClient.setQueryData(
        pizzaQueryKey,
        updatePizzaCustomizationsOptimistically,
      );
    }
  };
  const mutation = useMutation({
    mutationFn: availabilityService.updateAvailability,
    onMutate: async (variables: AvailabilityUpdatePayload) => {
      await queryClient.cancelQueries({ queryKey: ['availability'] });
      const previousMenuData = queryClient.getQueryData([
        'availability',
        'menu',
      ]);
      const previousModifierData = queryClient.getQueryData([
        'availability',
        'modifierGroups',
      ]);
      const previousPizzaData = queryClient.getQueryData([
        'availability',
        'pizzaCustomizations',
      ]);
      updateOptimistically(
        variables.type,
        variables.id,
        variables.isActive,
        variables.cascade,
      );
      return {
        previousMenuData,
        previousModifierData,
        previousPizzaData,
        variables,
      };
    },
    onSuccess: () => {
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: (error, variables, context) => {
      if (context?.previousMenuData) {
        queryClient.setQueryData(
          ['availability', 'menu'],
          context.previousMenuData,
        );
      }
      if (context?.previousModifierData) {
        queryClient.setQueryData(
          ['availability', 'modifierGroups'],
          context.previousModifierData,
        );
      }
      if (context?.previousPizzaData) {
        queryClient.setQueryData(
          ['availability', 'pizzaCustomizations'],
          context.previousPizzaData,
        );
      }
      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
    },
  });
  return mutation;
};

================
File: app/src/modules/customers/components/LocationPicker.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Alert } from 'react-native';
import { Text, Button, TextInput, Chip, HelperText } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';
interface LocationPickerProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: (location: {
    latitude: number;
    longitude: number;
    geocodedAddress?: string;
  }) => void;
  initialLocation?: {
    latitude: number;
    longitude: number;
  };
  address?: string;
}
export default function LocationPicker({
  visible,
  onDismiss,
  onConfirm,
  initialLocation,
  address,
}: LocationPickerProps) {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  const [latitude, setLatitude] = useState(
    initialLocation?.latitude?.toString() || '',
  );
  const [longitude, setLongitude] = useState(
    initialLocation?.longitude?.toString() || '',
  );
  const [geocodedAddress, setGeocodedAddress] = useState(address || '');
  const [latitudeError, setLatitudeError] = useState('');
  const [longitudeError, setLongitudeError] = useState('');
  const validateCoordinates = () => {
    let isValid = true;
    setLatitudeError('');
    setLongitudeError('');
    const lat = parseFloat(latitude);
    const lng = parseFloat(longitude);
    if (!latitude || isNaN(lat)) {
      setLatitudeError('Latitud inválida');
      isValid = false;
    } else if (lat < -90 || lat > 90) {
      setLatitudeError('La latitud debe estar entre -90 y 90');
      isValid = false;
    }
    if (!longitude || isNaN(lng)) {
      setLongitudeError('Longitud inválida');
      isValid = false;
    } else if (lng < -180 || lng > 180) {
      setLongitudeError('La longitud debe estar entre -180 y 180');
      isValid = false;
    }
    return isValid;
  };
  const handleConfirm = () => {
    if (validateCoordinates()) {
      onConfirm({
        latitude: parseFloat(latitude),
        longitude: parseFloat(longitude),
        geocodedAddress: geocodedAddress || undefined,
      });
    }
  };
  const handleUseCurrentLocation = () => {
    Alert.alert(
      'Función no disponible',
      'La función de mapas está temporalmente deshabilitada. Por favor, ingrese las coordenadas manualmente.',
      [{ text: 'OK' }],
    );
  };
  const footerActions = (
    <View style={styles.actions}>
      <Button mode="text" onPress={onDismiss} style={styles.button}>
        Cancelar
      </Button>
      <Button
        mode="contained"
        onPress={handleConfirm}
        disabled={!latitude || !longitude}
        style={styles.button}
      >
        Confirmar
      </Button>
    </View>
  );
  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title="Ubicación"
      maxWidthTablet={400}
      scrollable={false}
      footer={footerActions}
    >
      <View style={styles.content}>
        <Text variant="bodyMedium" style={styles.helperText}>
          Ingrese las coordenadas de la ubicación o use el botón para obtener su
          ubicación actual.
        </Text>
        <View style={styles.coordinatesRow}>
          <View style={styles.coordinateInput}>
            <TextInput
              mode="outlined"
              label="Latitud"
              value={latitude}
              onChangeText={setLatitude}
              keyboardType="numeric"
              placeholder="19.4326"
              error={!!latitudeError}
            />
            {latitudeError ? (
              <HelperText type="error" visible={!!latitudeError}>
                {latitudeError}
              </HelperText>
            ) : null}
          </View>
          <View style={styles.coordinateInput}>
            <TextInput
              mode="outlined"
              label="Longitud"
              value={longitude}
              onChangeText={setLongitude}
              keyboardType="numeric"
              placeholder="-99.1332"
              error={!!longitudeError}
            />
            {longitudeError ? (
              <HelperText type="error" visible={!!longitudeError}>
                {longitudeError}
              </HelperText>
            ) : null}
          </View>
        </View>
        <Button
          mode="outlined"
          onPress={handleUseCurrentLocation}
          icon="crosshairs-gps"
          style={styles.locationButton}
        >
          Usar mi ubicación actual
        </Button>
        <TextInput
          mode="outlined"
          label="Dirección (opcional)"
          value={geocodedAddress}
          onChangeText={setGeocodedAddress}
          multiline
          numberOfLines={2}
          placeholder="Calle, número, colonia, ciudad..."
          style={styles.addressInput}
        />
        {latitude && longitude && !latitudeError && !longitudeError && (
          <View style={styles.previewContainer}>
            <Text variant="labelMedium" style={styles.previewLabel}>
              Vista previa de coordenadas:
            </Text>
            <View style={styles.chipsContainer}>
              <Chip icon="map-marker" compact mode="flat">
                {parseFloat(latitude).toFixed(6)},{' '}
                {parseFloat(longitude).toFixed(6)}
              </Chip>
            </View>
          </View>
        )}
      </View>
    </ResponsiveModal>
  );
}
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    content: {
    },
    helperText: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.m,
    },
    coordinatesRow: {
      flexDirection: 'row',
      gap: theme.spacing.m,
      marginBottom: theme.spacing.m,
    },
    coordinateInput: {
      flex: 1,
    },
    locationButton: {
      marginBottom: theme.spacing.m,
    },
    addressInput: {
      marginBottom: theme.spacing.m,
    },
    previewContainer: {
      marginTop: theme.spacing.s,
    },
    previewLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.s,
    },
    chipsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.s,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      gap: theme.spacing.s,
    },
    button: {
      minWidth: 100,
    },
  });

================
File: app/src/modules/customers/schema/customer.schema.ts
================
import { z } from 'zod';
export const addressSchema = z.object({
  name: z.string().min(1, 'El nombre de la dirección es requerido').max(100),
  street: z.string().min(1, 'La calle es requerida'),
  number: z.string().min(1, 'El número es requerido'),
  interiorNumber: z.string().optional(),
  neighborhood: z.string().min(1, 'La colonia es requerida'),
  city: z.string().min(1, 'La ciudad es requerida'),
  state: z.string().min(1, 'El estado es requerido'),
  zipCode: z.string().regex(/^\d{5}$/, 'El código postal debe tener 5 dígitos'),
  country: z.string().min(1, 'El país es requerido').default('México'),
  deliveryInstructions: z.string().optional(),
  latitude: z.number().min(-90).max(90).optional(),
  longitude: z.number().min(-180).max(180).optional(),
  isDefault: z.boolean().optional(),
});
export const createCustomerSchema = z.object({
  firstName: z.string().min(1, 'El nombre es requerido').max(100),
  lastName: z.string().min(1, 'El apellido es requerido').max(100),
  whatsappPhoneNumber: z.string().min(1, 'El número de WhatsApp es requerido'),
  email: z
    .string()
    .email('El correo electrónico no es válido')
    .optional()
    .or(z.literal('')),
  birthDate: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'La fecha debe tener el formato YYYY-MM-DD')
    .optional()
    .or(z.literal('')),
  isActive: z.boolean().optional(),
  isBanned: z.boolean().optional(),
  addresses: z.array(addressSchema).optional(),
});
// Schema para actualizar cliente
export const updateCustomerSchema = createCustomerSchema.partial();
// Schema para formularios
export const customerFormSchema = z.object({
  firstName: z.string().min(1, 'El nombre es requerido').max(100),
  lastName: z.string().min(1, 'El apellido es requerido').max(100),
  whatsappPhoneNumber: z.string().min(1, 'El número de WhatsApp es requerido'),
  email: z
    .string()
    .email('El correo electrónico no es válido')
    .optional()
    .or(z.literal('')),
  birthDate: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'La fecha debe tener el formato YYYY-MM-DD')
    .optional()
    .or(z.literal('')),
  isActive: z.boolean(),
  isBanned: z.boolean(),
  banReason: z.string().optional().or(z.literal('')),
});
export type AddressFormInputs = z.infer<typeof addressSchema>;
export type CustomerFormInputs = z.infer<typeof customerFormSchema>;
export type CreateCustomerInput = z.infer<typeof createCustomerSchema>;
export type UpdateCustomerInput = z.infer<typeof updateCustomerSchema>;

================
File: app/src/modules/customers/services/addressesService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Address,
  CreateAddressDto,
  UpdateAddressDto,
} from '../types/customer.types';
async function create(
  customerId: string,
  data: CreateAddressDto,
): Promise<Address> {
  const response = await apiClient.post<Address>(
    API_PATHS.ADDRESSES_BY_CUSTOMER.replace(':customerId', customerId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}
async function update(
  addressId: string,
  data: UpdateAddressDto,
): Promise<Address> {
  const response = await apiClient.patch<Address>(
    API_PATHS.ADDRESSES_BY_ID.replace(':id', addressId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}
async function remove(addressId: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.ADDRESSES_BY_ID.replace(':id', addressId),
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}
export const addressesService = {
  create,
  update,
  remove,
};

================
File: app/src/modules/customers/types/customer.types.ts
================
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
}
export interface Address {
  id: string;
  name: string;
  street: string;
  number: string;
  interiorNumber?: string;
  neighborhood: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault: boolean;
  customerId: string;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
}
export interface Customer {
  id: string;
  firstName: string;
  lastName: string;
  whatsappPhoneNumber: string;
  stripeCustomerId?: string | null;
  email?: string | null;
  birthDate?: Date | null;
  fullChatHistory?: ChatMessage[] | null;
  relevantChatHistory?: ChatMessage[] | null;
  lastInteraction?: Date | null;
  totalOrders: number;
  totalSpent: number;
  isActive: boolean;
  isBanned: boolean;
  bannedAt?: Date | null;
  banReason?: string | null;
  whatsappMessageCount: number;
  lastWhatsappMessageTime?: Date | null;
  addresses: Address[];
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
}
export interface CreateCustomerDto {
  firstName: string;
  lastName: string;
  whatsappPhoneNumber: string;
  email?: string;
  birthDate?: string;
  isActive?: boolean;
  isBanned?: boolean;
  whatsappMessageCount?: number;
  lastWhatsappMessageTime?: string;
  addresses?: CreateAddressDto[];
}
export interface UpdateCustomerDto {
  firstName?: string;
  lastName?: string;
  whatsappPhoneNumber?: string;
  email?: string | null;
  birthDate?: string | null;
  isActive?: boolean;
  isBanned?: boolean;
  bannedAt?: string;
  banReason?: string | null;
  whatsappMessageCount?: number;
  lastWhatsappMessageTime?: string;
  fullChatHistory?: ChatMessage[];
  relevantChatHistory?: ChatMessage[];
  lastInteraction?: string;
}
export interface CreateAddressDto {
  name: string;
  street: string;
  number: string;
  interiorNumber?: string;
  neighborhood: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault?: boolean;
}
export interface UpdateAddressDto {
  name?: string;
  street?: string;
  number?: string;
  interiorNumber?: string;
  neighborhood?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault?: boolean;
}
export interface FindAllCustomersQuery {
  firstName?: string;
  lastName?: string;
  email?: string;
  whatsappPhoneNumber?: string;
  isActive?: boolean;
  isBanned?: boolean;
  lastInteractionAfter?: Date;
  page?: number;
  limit?: number;
}

================
File: app/src/modules/menu/hooks/useProductsQueries.ts
================
import {
  useQuery,
  useMutation,
  useQueryClient,
  UseQueryResult,
  UseMutationResult,
} from '@tanstack/react-query';
import { productsService } from '../services/productsService';
import {
  Product,
  ProductFormInputs,
  FindAllProductsQuery,
  AssignModifierGroupsInput,
} from '../schema/products.schema';
import { PaginatedResponse } from '@/app/types/api.types';
import { ApiError } from '@/app/lib/errors';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
const productKeys = {
  all: ['products'] as const,
  lists: (filters: FindAllProductsQuery) =>
    [...productKeys.all, 'list', filters] as const,
  details: (id: string) => [...productKeys.all, 'detail', id] as const,
  detailModifierGroups: (id: string) =>
    [...productKeys.details(id), 'modifier-groups'] as const,
};
export function useProductsQuery(
  filters: FindAllProductsQuery,
  options?: { enabled?: boolean },
): UseQueryResult<PaginatedResponse<Product>, ApiError> {
  return useQuery<PaginatedResponse<Product>, ApiError>({
    queryKey: productKeys.lists(filters),
    queryFn: () => productsService.findAll(filters),
    enabled: options?.enabled ?? true,
  });
}
export function useProductQuery(
  productId: string,
  options?: { enabled?: boolean },
): UseQueryResult<Product, ApiError> {
  return useQuery<Product, ApiError>({
    queryKey: productKeys.details(productId),
    queryFn: () => productsService.findOne(productId),
    enabled: !!productId && (options?.enabled ?? true),
  });
}
export function useCreateProductMutation(): UseMutationResult<
  Product,
  ApiError,
  ProductFormInputs
> {
  const queryClient = useQueryClient();
  return useMutation<Product, ApiError, ProductFormInputs>({
    mutationFn: (newProduct) => {
      return productsService.create(newProduct);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });
    },
    onError: () => {},
  });
}
export function useUpdateProductMutation(): UseMutationResult<
  Product,
  ApiError,
  { id: string; data: Partial<ProductFormInputs> },
  { previousProducts?: PaginatedResponse<Product>; previousDetail?: Product }
> {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  type UpdateProductContext = { previousDetail?: Product };
  return useMutation<
    Product,
    ApiError,
    { id: string; data: Partial<ProductFormInputs> },
    UpdateProductContext
  >({
    mutationFn: ({ id, data }) => productsService.update(id, data),
    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = productKeys.details(id);
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousDetail = queryClient.getQueryData<Product>(detailQueryKey);
      if (previousDetail) {
        queryClient.setQueryData<Product>(
          detailQueryKey,
          (old: Product | undefined) => {
            if (!old) return undefined;
            const { variants, modifierGroupIds, ...restOfData } = data;
            return { ...old, ...restOfData };
          },
        );
      }
      return { previousDetail };
    },
    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      if (context?.previousDetail) {
        queryClient.setQueryData(
          productKeys.details(variables.id),
          context.previousDetail,
        );
      }
    },
    onSettled: (data, error, _variables) => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });
      if (!error && data) {
        showSnackbar({
          message: 'Producto actualizado con éxito',
          type: 'success',
        });
      }
    },
  });
}
export function useDeleteProductMutation(): UseMutationResult<
  void,
  ApiError,
  string,
  { previousDetail?: Product }
> {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  type DeleteProductContext = { previousDetail?: Product };
  return useMutation<void, ApiError, string, DeleteProductContext>({
    mutationFn: (productId) => productsService.remove(productId),
    onMutate: async (deletedId) => {
      const detailQueryKey = productKeys.details(deletedId);
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousDetail = queryClient.getQueryData<Product>(detailQueryKey);
      queryClient.removeQueries({ queryKey: detailQueryKey });
      return { previousDetail };
    },
    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      if (context?.previousDetail) {
        queryClient.setQueryData(
          productKeys.details(deletedId),
          context.previousDetail,
        );
      }
    },
    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });
      if (!error) {
        queryClient.removeQueries({ queryKey: productKeys.details(deletedId) });
        showSnackbar({
          message: 'Producto eliminado con éxito',
          type: 'success',
        });
      }
    },
  });
}
export function useAssignModifierGroupsMutation(): UseMutationResult<
  Product,
  ApiError,
  { productId: string; data: AssignModifierGroupsInput }
> {
  const queryClient = useQueryClient();
  return useMutation<
    Product,
    ApiError,
    { productId: string; data: AssignModifierGroupsInput }
  >({
    mutationFn: ({ productId, data }) =>
      productsService.assignModifierGroups(productId, data),
    onSuccess: (updatedProduct) => {
      queryClient.invalidateQueries({
        queryKey: productKeys.details(updatedProduct.id),
      });
      queryClient.invalidateQueries({
        queryKey: productKeys.detailModifierGroups(updatedProduct.id),
      });
    },
  });
}
export function useProductModifierGroupsQuery(
  productId: string,
  options?: { enabled?: boolean },
): UseQueryResult<Product, ApiError> {
  return useQuery<Product, ApiError>({
    queryKey: productKeys.detailModifierGroups(productId),
    queryFn: () => productsService.getModifierGroups(productId),
    enabled: !!productId && (options?.enabled ?? true),
  });
}
export function useRemoveModifierGroupsMutation(): UseMutationResult<
  Product,
  ApiError,
  { productId: string; data: AssignModifierGroupsInput }
> {
  const queryClient = useQueryClient();
  return useMutation<
    Product,
    ApiError,
    { productId: string; data: AssignModifierGroupsInput }
  >({
    mutationFn: ({ productId, data }) =>
      productsService.removeModifierGroups(productId, data),
    onSuccess: (updatedProduct) => {
      queryClient.invalidateQueries({
        queryKey: productKeys.details(updatedProduct.id),
      });
      queryClient.invalidateQueries({
        queryKey: productKeys.detailModifierGroups(updatedProduct.id),
      });
    },
  });
}

================
File: app/src/modules/menu/hooks/useSubcategoriesQueries.ts
================
import {
  useQuery,
  useMutation,
  useQueryClient,
  type UseQueryResult,
  type UseMutationResult,
} from '@tanstack/react-query';
import * as subcategoriesService from '../services/subcategoriesService';
import {
  SubCategory,
  CreateSubCategoryDto,
  UpdateSubCategoryDto,
  findAllSubcategoriesDtoSchema,
} from '../schema/subcategories.schema';
import { z } from 'zod';
import { PaginatedResponse } from '../../../app/types/api.types';
import { ApiError } from '../../../app/lib/errors';
import {
  useSnackbarStore,
  type SnackbarState,
} from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
type FindAllSubcategoriesDto = z.infer<typeof findAllSubcategoriesDtoSchema>;
const subcategoryKeys = {
  all: ['subcategories'] as const,
  lists: () => [...subcategoryKeys.all, 'list'] as const,
  list: (filters: FindAllSubcategoriesDto) =>
    [...subcategoryKeys.lists(), filters] as const,
  details: () => [...subcategoryKeys.all, 'detail'] as const,
  detail: (id: string) => [...subcategoryKeys.details(), id] as const,
};
export const useFindAllSubcategories = (
  params: FindAllSubcategoriesDto = { page: 1, limit: 10 },
  enabled: boolean = true,
): UseQueryResult<PaginatedResponse<SubCategory>, ApiError> => {
  const queryKey = subcategoryKeys.list(params);
  return useQuery<PaginatedResponse<SubCategory>, ApiError>({
    queryKey: queryKey,
    queryFn: () => subcategoriesService.findAllSubcategories(params),
    enabled: enabled,
  });
};
export const useFindOneSubcategory = (
  id: string | undefined,
  enabled: boolean = true,
): UseQueryResult<SubCategory, ApiError> => {
  const queryKey = subcategoryKeys.detail(id!);
  return useQuery<SubCategory, ApiError>({
    queryKey: queryKey,
    queryFn: () => subcategoriesService.findOneSubcategory(id!),
    enabled: enabled && !!id,
  });
};
type UpdateSubcategoryContext = {
  previousDetail?: SubCategory;
};
export const useCreateSubcategory = (): UseMutationResult<
  SubCategory,
  ApiError,
  CreateSubCategoryDto
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );
  return useMutation<SubCategory, ApiError, CreateSubCategoryDto>({
    mutationFn: subcategoriesService.createSubcategory,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });
      showSnackbar({
        message: 'Subcategoría creada con éxito',
        type: 'success',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
    },
  });
};
export const useUpdateSubcategory = (): UseMutationResult<
  SubCategory,
  ApiError,
  { id: string; data: UpdateSubCategoryDto },
  UpdateSubcategoryContext
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );
  return useMutation<
    SubCategory,
    ApiError,
    { id: string; data: UpdateSubCategoryDto },
    UpdateSubcategoryContext
  >({
    mutationFn: ({ id, data }) =>
      subcategoriesService.updateSubcategory(id, data),
    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = subcategoryKeys.detail(id);
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousDetail =
        queryClient.getQueryData<SubCategory>(detailQueryKey);
      if (previousDetail) {
        queryClient.setQueryData<SubCategory>(
          detailQueryKey,
          (
            old: SubCategory | undefined,
          ) => (old ? { ...old, ...data } : undefined),
        );
      }
      return { previousDetail };
    },
    onError: (error, variables, context) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      if (context?.previousDetail) {
        queryClient.setQueryData(
          subcategoryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },
    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: subcategoryKeys.detail(variables.id),
      });
      if (!error && data) {
        showSnackbar({
          message: 'Subcategoría actualizada con éxito',
          type: 'success',
        });
      }
    },
  });
};
export const useRemoveSubcategory = (): UseMutationResult<
  void,
  ApiError,
  string,
  { previousDetail?: SubCategory }
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );
  type DeleteSubcategoryContext = { previousDetail?: SubCategory };
  return useMutation<void, ApiError, string, DeleteSubcategoryContext>({
    mutationFn: subcategoriesService.removeSubcategory,
    onMutate: async (deletedId) => {
      const detailQueryKey = subcategoryKeys.detail(deletedId);
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousDetail =
        queryClient.getQueryData<SubCategory>(detailQueryKey);
      queryClient.removeQueries({ queryKey: detailQueryKey });
      return { previousDetail };
    },
    onError: (error, deletedId, context) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      if (context?.previousDetail) {
        queryClient.setQueryData(
          subcategoryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },
    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });
      if (!error) {
        queryClient.removeQueries({
          queryKey: subcategoryKeys.detail(deletedId),
        });
        showSnackbar({
          message: 'Subcategoría eliminada con éxito',
          type: 'success',
        });
      }
    },
  });
};

================
File: app/src/modules/menu/services/subcategoriesService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  SubCategory,
  CreateSubCategoryDto,
  UpdateSubCategoryDto,
  findAllSubcategoriesDtoSchema,
} from '../schema/subcategories.schema';
import { z } from 'zod';
import { PaginatedResponse } from '../../../app/types/api.types';
type FindAllSubcategoriesDto = z.infer<typeof findAllSubcategoriesDtoSchema>;
export const createSubcategory = async (
  data: CreateSubCategoryDto,
): Promise<SubCategory> => {
  const response = await apiClient.post<SubCategory>(
    API_PATHS.SUBCATEGORIES,
    data,
  );
  return response.data;
};
export const findAllSubcategories = async (
  params: FindAllSubcategoriesDto,
): Promise<PaginatedResponse<SubCategory>> => {
  const queryParams = Object.entries(params).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    },
    {} as Record<string, any>,
  );
  const response = await apiClient.get<{
    items: SubCategory[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.SUBCATEGORIES, { params: queryParams });
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};
export const findOneSubcategory = async (id: string): Promise<SubCategory> => {
  const response = await apiClient.get<SubCategory>(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
  );
  return response.data;
};
export const updateSubcategory = async (
  id: string,
  data: UpdateSubCategoryDto,
): Promise<SubCategory> => {
  const response = await apiClient.patch<SubCategory>(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};
export const removeSubcategory = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id));
};

================
File: app/src/modules/modifiers/components/ModifierFormModal.tsx
================
import React, { useMemo, useCallback } from 'react';
import { z } from 'zod';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import GenericFormModal, {
  FormFieldConfig,
} from '@/app/components/crud/GenericFormModal';
import { modifierService } from '../services/modifierService';
import { ModifierFormInputs } from '../types/modifier.types';
import {
  Modifier,
  modifierFormValidationSchema,
  CreateModifierInput,
  UpdateModifierInput,
} from '../schema/modifier.schema';
interface Props {
  visible: boolean;
  onDismiss: () => void;
  onSaveSuccess: () => void;
  initialData?: Modifier | null;
  groupId: string;
}
const formFields: FormFieldConfig<ModifierFormInputs>[] = [
  { name: 'name', label: 'Nombre *', type: 'text', required: true },
  {
    name: 'description',
    label: 'Descripción (Opcional)',
    type: 'textarea',
    numberOfLines: 3,
  },
  {
    name: 'price',
    label: 'Precio Adicional (Opcional)',
    type: 'number',
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'sortOrder',
    label: 'Orden de Visualización',
    type: 'number',
    defaultValue: 0,
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'isDefault',
    label: 'Seleccionado por Defecto',
    type: 'switch',
    defaultValue: false,
  },
  { name: 'isActive', label: 'Activo', type: 'switch', defaultValue: true },
];
const formSchema = modifierFormValidationSchema;
const ModifierFormModal: React.FC<Props> = ({
  visible,
  onDismiss,
  onSaveSuccess,
  initialData,
  groupId,
}) => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const isEditing = !!initialData;
  const QUERY_KEY_TO_INVALIDATE = ['modifiers', groupId];
  const mutation = useMutation<
    Modifier,
    Error,
    CreateModifierInput | UpdateModifierInput
  >({
    mutationFn: (data) => {
      if (isEditing && initialData) {
        return modifierService.update(
          initialData.id,
          data as UpdateModifierInput,
        );
      } else {
        return modifierService.create(data as CreateModifierInput);
      }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEY_TO_INVALIDATE });
      showSnackbar({
        message: `Modificador "${data.name}" ${isEditing ? 'actualizado' : 'creado'} correctamente`,
        type: 'success',
      });
      onSaveSuccess();
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
    },
  });
  const handleFormSubmit = useCallback(
    async (formData: ModifierFormInputs) => {
      const dataToSend: CreateModifierInput | UpdateModifierInput = {
        ...formData,
        price:
          formData.price === undefined || isNaN(Number(formData.price))
            ? null
            : Number(formData.price),
        description:
          formData.description === undefined ? null : formData.description,
        sortOrder: formData.sortOrder ?? 0,
        isDefault: formData.isDefault ?? false,
        isActive: formData.isActive ?? true,
        modifierGroupId: groupId,
      };
      try {
        await mutation.mutateAsync(dataToSend);
      } catch (error) {
      }
    },
    [
      mutation,
      groupId,
      isEditing,
      initialData?.id,
      onSaveSuccess,
      queryClient,
      showSnackbar,
    ],
  );
  return (
    <GenericFormModal<ModifierFormInputs, Modifier>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={handleFormSubmit}
      formSchema={formSchema as z.ZodSchema<ModifierFormInputs>}
      formFields={formFields}
      editingItem={initialData ?? null}
      isSubmitting={mutation.isPending}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Modificador' : 'Crear Nuevo Modificador'
      }
      initialValues={useMemo(
        () =>
          initialData
            ? {
                name: initialData.name,
                description: initialData.description,
                price: initialData.price,
                sortOrder: initialData.sortOrder,
                isDefault: initialData.isDefault,
                isActive: initialData.isActive,
              }
            : {
                name: '',
                description: null,
                price: null,
                sortOrder: 0,
                isDefault: false,
                isActive: true,
              },
        [initialData],
      )}
    />
  );
};
export default ModifierFormModal;

================
File: app/src/modules/orders/hooks/useMenuQueries.ts
================
import { useQuery } from '@tanstack/react-query';
import { useEffect } from 'react';
import { getOrderMenu } from '@/modules/menu/services/categoryService';
import type { FullMenuCategory } from '@/modules/orders/types/orders.types';
import { ApiError } from '@/app/lib/errors';
import { prefetchMenuImages } from '@/app/lib/imageCache';
const orderMenuQueryKey = ['orderMenu'];
export function useGetOrderMenu() {
  const query = useQuery<FullMenuCategory[], ApiError>({
    queryKey: orderMenuQueryKey,
    queryFn: getOrderMenu,
    refetchInterval: 10000,
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000,
    keepPreviousData: true,
    notifyOnChangeProps: ['data', 'error'],
  });
  useEffect(() => {
    if (query.data && query.data.length > 0) {
      prefetchMenuImages(query.data, {
        maxConcurrent: 3,
      }).catch(() => {
      });
    }
  }, [query.data]);
  return query;
}

================
File: app/src/modules/orders/services/adjustmentService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Adjustment } from '@/app/schemas/domain/adjustment.schema';
import type { OrderAdjustmentDto } from '../types/update-order.types';
export const adjustmentService = {
  createBulkAdjustments: async (
    adjustments: OrderAdjustmentDto[],
  ): Promise<Adjustment[]> => {
    const response = await apiClient.post<Adjustment[]>(
      API_PATHS.ADJUSTMENTS + '/bulk',
      adjustments,
    );
    return response.data;
  },
  getOrderAdjustments: async (orderId: string): Promise<Adjustment[]> => {
    const response = await apiClient.get<Adjustment[]>(
      API_PATHS.ADJUSTMENTS + '/order/' + orderId,
    );
    return response.data;
  },
  deleteAdjustment: async (adjustmentId: string): Promise<void> => {
    await apiClient.delete<void>(
      API_PATHS.ADJUSTMENTS_BY_ID.replace(':id', adjustmentId),
    );
  },
  getOrderAdjustmentsTotal: async (
    orderId: string,
  ): Promise<{ total: number }> => {
    const response = await apiClient.get<{ total: number }>(
      API_PATHS.ADJUSTMENTS + '/order/' + orderId + '/total',
    );
    return response.data;
  },
};

================
File: app/src/modules/orders/stores/useCartStore.ts
================
import { create } from 'zustand';
import type { Product } from '../types/orders.types';
import type { SelectedPizzaCustomization } from '../../../app/schemas/domain/order.schema';
import { useOrderFormStore } from './useOrderFormStore';
const generateId = () => {
  const timestamp = Date.now().toString();
  const random1 = Math.floor(Math.random() * 1000000).toString();
  const random2 = Math.floor(Math.random() * 1000000).toString();
  return `${timestamp}-${random1}-${random2}`;
};
export interface CartItemModifier {
  id: string;
  modifierGroupId: string;
  name: string;
  price: number;
}
export interface CartItem {
  id: string;
  productId: string;
  productName: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  modifiers: CartItemModifier[];
  variantId?: string;
  variantName?: string;
  preparationNotes?: string;
  notes?: string;
  preparationStatus?:
    | 'NEW'
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'CANCELLED';
  selectedPizzaCustomizations?: SelectedPizzaCustomization[];
  pizzaExtraCost?: number;
}
interface CartStore {
  items: CartItem[];
  isCartVisible: boolean;
  addItem: (
    product: Product,
    quantity?: number,
    variantId?: string,
    modifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  removeItem: (itemId: string) => void;
  updateItemQuantity: (itemId: string, quantity: number) => void;
  updateItem: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  clearCart: () => void;
  setItems: (items: CartItem[]) => void;
  showCart: () => void;
  hideCart: () => void;
}
export const useCartSubtotal = () =>
  useCartStore((state) =>
    state.items.reduce((sum, item) => sum + item.totalPrice, 0),
  );
export const useCartTotal = () => useCartSubtotal();
export const useCartItemsCount = () =>
  useCartStore((state) =>
    state.items.reduce((sum, item) => sum + item.quantity, 0),
  );
export const useIsCartEmpty = () =>
  useCartStore((state) => state.items.length === 0);
export const useClearAll = () => {
  const clearCart = useCartStore((state) => state.clearCart);
  const clearForm = useOrderFormStore((state) => state.clearForm);
  return () => {
    clearCart();
    clearForm();
  };
};
export const useCartStore = create<CartStore>((set, get) => ({
  items: [],
  isCartVisible: false,
  addItem: (
    product: Product,
    quantity: number = 1,
    variantId?: string,
    modifiers: CartItemModifier[] = [],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost: number = 0,
  ) => {
    const { items } = get();
    const variantToAdd = variantId
      ? product.variants?.find((v) => v.id === variantId)
      : undefined;
    const safeParsePrice = (price: any): number => {
      const parsed = Number(price);
      if (isNaN(parsed) || !isFinite(parsed) || parsed < 0) {
        return 0;
      }
      return Math.min(Math.round(parsed * 100) / 100, 999999.99);
    };
    const unitPrice = variantToAdd
      ? safeParsePrice(variantToAdd.price)
      : safeParsePrice(product.price);
    const modifiersPrice = modifiers.reduce(
      (sum, mod) => sum + safeParsePrice(mod.price || 0),
      0,
    );
    const existingItemIndex = items.findIndex((item) => {
      if (item.productId !== product.id) return false;
      if (item.variantId !== variantId) return false;
      if (item.preparationNotes !== preparationNotes) return false;
      if (item.modifiers.length !== modifiers.length) return false;
      const sortedExistingModifiers = [...item.modifiers].sort((a, b) =>
        a.id.localeCompare(b.id),
      );
      const sortedNewModifiers = [...modifiers].sort((a, b) =>
        a.id.localeCompare(b.id),
      );
      for (let i = 0; i < sortedExistingModifiers.length; i++) {
        if (
          sortedExistingModifiers[i].id !== sortedNewModifiers[i].id ||
          sortedExistingModifiers[i].name !== sortedNewModifiers[i].name ||
          sortedExistingModifiers[i].price !== sortedNewModifiers[i].price
        ) {
          return false;
        }
      }
      const existingCustomizations = item.selectedPizzaCustomizations || [];
      const newCustomizations = selectedPizzaCustomizations || [];
      if (existingCustomizations.length !== newCustomizations.length)
        return false;
      const sortedExistingCustomizations = [...existingCustomizations].sort(
        (a, b) =>
          `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
            `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
          ),
      );
      const sortedNewCustomizations = [...newCustomizations].sort((a, b) =>
        `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
          `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
        ),
      );
      for (let i = 0; i < sortedExistingCustomizations.length; i++) {
        if (
          sortedExistingCustomizations[i].pizzaCustomizationId !==
            sortedNewCustomizations[i].pizzaCustomizationId ||
          sortedExistingCustomizations[i].half !==
            sortedNewCustomizations[i].half ||
          sortedExistingCustomizations[i].action !==
            sortedNewCustomizations[i].action
        ) {
          return false;
        }
      }
      return true;
    });
    if (existingItemIndex !== -1) {
      const updatedItems = [...items];
      const existingItem = updatedItems[existingItemIndex];
      const newQuantity = existingItem.quantity + quantity;
      const newTotalPrice =
        (existingItem.unitPrice + modifiersPrice + pizzaExtraCost) *
        newQuantity;
      updatedItems[existingItemIndex] = {
        ...existingItem,
        quantity: newQuantity,
        totalPrice: newTotalPrice,
        pizzaExtraCost,
      };
      set({ items: updatedItems });
    } else {
      const newItem: CartItem = {
        id: generateId(),
        productId: product.id,
        productName: product.name,
        quantity,
        unitPrice: unitPrice as number,
        totalPrice:
          ((unitPrice as number) + modifiersPrice + pizzaExtraCost) * quantity,
        modifiers,
        variantId,
        variantName: variantToAdd?.name,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      };
      set({ items: [...items, newItem] });
    }
  },
  removeItem: (itemId: string) => {
    const { items } = get();
    set({ items: items.filter((item) => item.id !== itemId) });
  },
  updateItemQuantity: (itemId: string, quantity: number) => {
    const { items, removeItem } = get();
    const safeQuantity = Math.round(quantity);
    if (safeQuantity <= 0 || isNaN(safeQuantity)) {
      removeItem(itemId);
      return;
    }
    const MAX_QUANTITY = 9999;
    const finalQuantity = Math.min(safeQuantity, MAX_QUANTITY);
    const updatedItems = items.map((item) => {
      if (item.id === itemId) {
        const modifiersPrice = item.modifiers.reduce(
          (sum, mod) => sum + Number(mod.price || 0),
          0,
        );
        const pizzaExtraCost = item.pizzaExtraCost || 0;
        const newTotalPrice =
          (item.unitPrice + modifiersPrice + pizzaExtraCost) * finalQuantity;
        return {
          ...item,
          quantity: finalQuantity,
          totalPrice: newTotalPrice,
        };
      }
      return item;
    });
    set({ items: updatedItems });
  },
  updateItem: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost: number = 0,
  ) => {
    const { items } = get();
    const updatedItems = items.map((item) => {
      if (item.id === itemId) {
        const modifiersPrice = modifiers.reduce(
          (sum, mod) => sum + Number(mod.price || 0),
          0,
        );
        const finalUnitPrice =
          unitPrice !== undefined ? unitPrice : item.unitPrice;
        const newTotalPrice =
          (finalUnitPrice + modifiersPrice + pizzaExtraCost) * quantity;
        return {
          ...item,
          quantity,
          modifiers,
          preparationNotes:
            preparationNotes !== undefined
              ? preparationNotes
              : item.preparationNotes,
          variantId: variantId !== undefined ? variantId : item.variantId,
          variantName:
            variantName !== undefined ? variantName : item.variantName,
          unitPrice: finalUnitPrice,
          totalPrice: newTotalPrice,
          selectedPizzaCustomizations:
            selectedPizzaCustomizations !== undefined
              ? selectedPizzaCustomizations
              : item.selectedPizzaCustomizations,
          pizzaExtraCost,
        };
      }
      return item;
    });
    set({ items: updatedItems });
  },
  clearCart: () => {
    set({ items: [] });
  },
  setItems: (items: CartItem[]) => {
    set({ items });
  },
  showCart: () => {
    set({ isCartVisible: true });
  },
  hideCart: () => {
    set({ isCartVisible: false });
  },
}));

================
File: app/src/modules/orders/stores/useOrderFormStore.ts
================
import { create } from 'zustand';
import { OrderTypeEnum, type OrderType } from '../types/orders.types';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';
interface OrderFormStore {
  orderType: OrderType;
  selectedAreaId: string | null;
  selectedTableId: string | null;
  isTemporaryTable: boolean;
  temporaryTableName: string;
  scheduledTime: Date | null;
  deliveryInfo: DeliveryInfo;
  orderNotes: string;
  prepaymentId: string | null;
  prepaymentAmount: string;
  prepaymentMethod: 'CASH' | 'CARD' | 'TRANSFER' | null;
  setOrderType: (type: OrderType) => void;
  setSelectedAreaId: (id: string | null) => void;
  setSelectedTableId: (id: string | null) => void;
  setIsTemporaryTable: (isTemp: boolean) => void;
  setTemporaryTableName: (name: string) => void;
  setScheduledTime: (time: Date | null) => void;
  setDeliveryInfo: (info: DeliveryInfo) => void;
  setOrderNotes: (notes: string) => void;
  setPrepaymentId: (id: string | null) => void;
  setPrepaymentAmount: (amount: string) => void;
  setPrepaymentMethod: (method: 'CASH' | 'CARD' | 'TRANSFER' | null) => void;
  clearForm: () => void;
}
export const useOrderFormStore = create<OrderFormStore>((set) => ({
  orderType: OrderTypeEnum.DINE_IN,
  selectedAreaId: null,
  selectedTableId: null,
  isTemporaryTable: false,
  temporaryTableName: '',
  scheduledTime: null,
  deliveryInfo: {},
  orderNotes: '',
  // Estado inicial del prepago
  prepaymentId: null,
  prepaymentAmount: '',
  prepaymentMethod: null,
  // Actions
  setOrderType: (type: OrderType) => {
    set({ orderType: type });
  },
  setSelectedAreaId: (id: string | null) => {
    set({ selectedAreaId: id });
  },
  setSelectedTableId: (id: string | null) => {
    set({ selectedTableId: id });
  },
  setIsTemporaryTable: (isTemp: boolean) => {
    set({ isTemporaryTable: isTemp });
  },
  setTemporaryTableName: (name: string) => {
    set({ temporaryTableName: name });
  },
  setScheduledTime: (time: Date | null) => {
    set({ scheduledTime: time });
  },
  setDeliveryInfo: (info: DeliveryInfo) => {
    set({ deliveryInfo: info });
  },
  setOrderNotes: (notes: string) => {
    set({ orderNotes: notes });
  },
  setPrepaymentId: (id: string | null) => {
    set({ prepaymentId: id });
  },
  setPrepaymentAmount: (amount: string) => {
    set({ prepaymentAmount: amount });
  },
  setPrepaymentMethod: (method: 'CASH' | 'CARD' | 'TRANSFER' | null) => {
    set({ prepaymentMethod: method });
  },
  clearForm: () => {
    set({
      orderType: OrderTypeEnum.DINE_IN,
      selectedAreaId: null,
      selectedTableId: null,
      isTemporaryTable: false,
      temporaryTableName: '',
      scheduledTime: null,
      deliveryInfo: {},
      orderNotes: '',
      prepaymentId: null,
      prepaymentAmount: '',
      prepaymentMethod: null,
    });
  },
}));

================
File: app/src/modules/orders/types/payment.types.ts
================
export enum PaymentMethodEnum {
  CASH = 'CASH',
  CARD = 'CARD',
  TRANSFER = 'TRANSFER',
}
export enum PaymentStatusEnum {
  PENDING = 'PENDING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED',
  CANCELLED = 'CANCELLED',
}
export type PaymentMethod = keyof typeof PaymentMethodEnum;
export type PaymentStatus = keyof typeof PaymentStatusEnum;
export interface Payment {
  id: string;
  orderId: string;
  paymentMethod: PaymentMethod;
  amount: number;
  paymentStatus: PaymentStatus;
  createdAt: string;
  updatedAt: string;
  order?: {
    id: string;
    shiftOrderNumber: number;
    total: number;
  };
}
export interface CreatePaymentDto {
  orderId: string;
  paymentMethod: PaymentMethod;
  amount: number;
}
export interface UpdatePaymentDto {
  paymentMethod?: PaymentMethod;
  amount?: number;
  paymentStatus?: PaymentStatus;
}

================
File: app/src/modules/pizzaCustomizations/components/AssociatePizzaToppingsModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  Checkbox,
  Button,
  IconButton,
  Chip,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { productsService } from '@/modules/menu/services/productsService';
import { pizzaCustomizationsService } from '../services/pizzaCustomizationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { CustomizationType } from '../types/pizzaCustomization.types';
import type { Product } from '@/modules/menu/schema/products.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
interface AssociatePizzaToppingsModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product | null;
}
export function AssociatePizzaToppingsModal({
  visible,
  onDismiss,
  product,
}: AssociatePizzaToppingsModalProps) {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [selectedToppings, setSelectedToppings] = useState<Set<string>>(
    new Set(),
  );
  const [hasChanges, setHasChanges] = useState(false);
  const [filterType, setFilterType] = useState<
    'all' | 'flavors' | 'ingredients'
  >('all');
  const [showConfirmation, setShowConfirmation] = useState(false);
  const { data: allToppings, isLoading: isLoadingToppings } = useQuery({
    queryKey: ['pizza-toppings-modal'],
    queryFn: async () => {
      const response = await pizzaCustomizationsService.findAll({
        page: 1,
        limit: 100,
        isActive: true,
      });
      return response.data || [];
    },
    enabled: visible,
  });
  const { data: associatedToppings, isLoading: isLoadingAssociated } = useQuery(
    {
      queryKey: ['product-pizza-toppings', product?.id],
      queryFn: async () => {
        if (!product?.id) return [];
        const result = await productsService.getPizzaCustomizations(product.id);
        return result || [];
      },
      enabled: !!product?.id && visible,
    },
  );
  useEffect(() => {
    if (associatedToppings && visible && product) {
      const associatedIds = new Set(associatedToppings.map((t) => t.id));
      setSelectedToppings(associatedIds);
      setHasChanges(false);
    }
  }, [associatedToppings, visible, product]);
  const updateMutation = useMutation({
    mutationFn: async () => {
      if (!product) throw new Error('No hay producto seleccionado');
      await productsService.updatePizzaCustomizations(
        product.id,
        Array.from(selectedToppings),
      );
    },
    onSuccess: () => {
      showSnackbar({
        message: 'Sabores e ingredientes actualizados exitosamente',
        type: 'success',
      });
      queryClient.invalidateQueries({
        queryKey: ['product-pizza-toppings', product?.id],
      });
      queryClient.invalidateQueries({ queryKey: ['pizza-products'] });
      queryClient.invalidateQueries({ queryKey: ['pizza-configurations'] });
      setHasChanges(false);
      onDismiss();
    },
    onError: (error) => {
      showSnackbar({
        message: error instanceof Error ? error.message : 'Error al actualizar',
        type: 'error',
      });
    },
  });
  const toggleTopping = (toppingId: string) => {
    setSelectedToppings((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(toppingId)) {
        newSet.delete(toppingId);
      } else {
        newSet.add(toppingId);
      }
      return newSet;
    });
    setHasChanges(true);
  };
  const toggleAll = () => {
    if (!allToppings) return;
    if (selectedToppings.size === allToppings.length) {
      setSelectedToppings(new Set());
    } else {
      setSelectedToppings(new Set(allToppings.map((t) => t.id)));
    }
    setHasChanges(true);
  };
  const filteredToppings = useMemo(() => {
    if (!allToppings || !Array.isArray(allToppings)) {
      return {
        flavors: [],
        ingredients: [],
        displayFlavors: [],
        displayIngredients: [],
      };
    }
    const flavors = allToppings.filter(
      (t) => t.type === CustomizationType.FLAVOR,
    );
    const ingredients = allToppings.filter(
      (t) => t.type === CustomizationType.INGREDIENT,
    );
    return {
      flavors,
      ingredients,
      displayFlavors: filterType === 'ingredients' ? [] : flavors,
      displayIngredients: filterType === 'flavors' ? [] : ingredients,
    };
  }, [allToppings, filterType]);
  const isLoading = isLoadingToppings || isLoadingAssociated;
  const styles = StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: theme.spacing.m,
      marginTop: theme.spacing.xl * 2,
      borderRadius: theme.roundness * 2,
      height: '90%',
      maxHeight: '90%',
    },
    header: {
      backgroundColor: theme.colors.elevation.level1,
      borderTopLeftRadius: theme.roundness * 2,
      borderTopRightRadius: theme.roundness * 2,
      paddingHorizontal: theme.spacing.m,
      paddingTop: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    titleIcon: {
      margin: 0,
      marginRight: theme.spacing.xs,
    },
    title: {
      fontSize: 20,
      fontWeight: '700',
      color: theme.colors.onSurface,
    },
    subtitle: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      marginLeft: theme.spacing.xl + theme.spacing.m,
    },
    closeButton: {
      margin: 0,
    },
    filterContainer: {
      backgroundColor: theme.colors.background,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.m,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    filterButtons: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      justifyContent: 'space-between',
    },
    filterChip: {
      flex: 1,
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.outlineVariant,
      height: 32,
    },
    filterChipActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    filterChipText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    filterChipTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    content: {
      flex: 1,
      minHeight: 200,
    },
    scrollContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2,
    },
    selectAllContainer: {
      marginBottom: theme.spacing.l,
      paddingTop: theme.spacing.s,
    },
    selectAllButton: {
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    selectAllContent: {
      paddingVertical: theme.spacing.xs,
    },
    selectionCount: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      textAlign: 'center',
      marginTop: theme.spacing.xs,
    },
    section: {
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      fontSize: 14,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.m,
      textTransform: 'uppercase',
      letterSpacing: 1,
    },
    toppingItem: {
      marginBottom: theme.spacing.xs,
    },
    checkbox: {
      paddingVertical: theme.spacing.s,
      paddingHorizontal: 0,
      marginHorizontal: 0,
    },
    checkboxLabel: {
      textAlign: 'left',
      marginLeft: theme.spacing.xs,
    },
    ingredientsText: {
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginLeft: theme.spacing.xl * 2,
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
      fontSize: 12,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: 200,
    },
    emptyState: {
      padding: theme.spacing.xl,
      alignItems: 'center',
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.m,
      gap: theme.spacing.m,
    },
    actionButton: {
      flex: 1,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    cancelButton: {
      borderColor: theme.colors.outlineVariant,
    },
    saveButton: {
      borderWidth: 0,
    },
  });
  if (!product) return null;
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (hasChanges) {
            setShowConfirmation(true);
          } else {
            onDismiss();
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={true}
      >
        <View style={styles.header}>
          <View style={styles.headerContent}>
            <View style={styles.titleContainer}>
              <IconButton
                icon="food-variant"
                size={20}
                iconColor={theme.colors.primary}
                style={styles.titleIcon}
              />
              <Text style={styles.title}>Personalizar Producto</Text>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={() => {
                if (hasChanges) {
                  setShowConfirmation(true);
                } else {
                  onDismiss();
                }
              }}
              style={styles.closeButton}
            />
          </View>
          <Text style={styles.subtitle}>{product.name}</Text>
        </View>
        <View style={styles.filterContainer}>
          <View style={styles.filterButtons}>
            <Chip
              mode={filterType === 'all' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('all')}
              style={[
                styles.filterChip,
                filterType === 'all' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'all' && styles.filterChipTextActive,
              ]}
              icon="format-list-bulleted"
              compact
            >
              Todos
            </Chip>
            <Chip
              mode={filterType === 'flavors' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('flavors')}
              style={[
                styles.filterChip,
                filterType === 'flavors' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'flavors' && styles.filterChipTextActive,
              ]}
              icon="pizza"
              compact
            >
              Sabores
            </Chip>
            <Chip
              mode={filterType === 'ingredients' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('ingredients')}
              style={[
                styles.filterChip,
                filterType === 'ingredients' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'ingredients' && styles.filterChipTextActive,
              ]}
              icon="food-variant"
              compact
            >
              Ingredientes
            </Chip>
          </View>
        </View>
        <View style={styles.content}>
          {isLoading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
            </View>
          ) : (
            <ScrollView
              contentContainerStyle={styles.scrollContent}
              showsVerticalScrollIndicator={true}
            >
              <View style={styles.selectAllContainer}>
                <Button
                  mode="contained-tonal"
                  onPress={toggleAll}
                  style={styles.selectAllButton}
                  icon={
                    selectedToppings.size === allToppings?.length
                      ? 'checkbox-marked'
                      : 'checkbox-blank-outline'
                  }
                  contentStyle={styles.selectAllContent}
                >
                  {selectedToppings.size === allToppings?.length
                    ? 'Quitar selección'
                    : 'Seleccionar todo'}
                </Button>
                <Text style={styles.selectionCount}>
                  {selectedToppings.size} de {allToppings?.length || 0}{' '}
                  seleccionados
                </Text>
              </View>
              {filteredToppings.displayFlavors.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>
                    Sabores ({filteredToppings.displayFlavors.length})
                  </Text>
                  {filteredToppings.displayFlavors.map((flavor) => (
                    <View key={flavor.id} style={styles.toppingItem}>
                      <Checkbox.Item
                        label={flavor.name}
                        status={
                          selectedToppings.has(flavor.id)
                            ? 'checked'
                            : 'unchecked'
                        }
                        onPress={() => toggleTopping(flavor.id)}
                        labelStyle={styles.checkboxLabel}
                        style={styles.checkbox}
                        position="leading"
                      />
                      {flavor.ingredients && (
                        <Text style={styles.ingredientsText}>
                          {flavor.ingredients}
                        </Text>
                      )}
                    </View>
                  ))}
                </View>
              )}
              {filteredToppings.displayIngredients.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>
                    Ingredientes ({filteredToppings.displayIngredients.length})
                  </Text>
                  {filteredToppings.displayIngredients.map((ingredient) => (
                    <View key={ingredient.id} style={styles.toppingItem}>
                      <Checkbox.Item
                        label={ingredient.name}
                        status={
                          selectedToppings.has(ingredient.id)
                            ? 'checked'
                            : 'unchecked'
                        }
                        onPress={() => toggleTopping(ingredient.id)}
                        labelStyle={styles.checkboxLabel}
                        style={styles.checkbox}
                        position="leading"
                      />
                    </View>
                  ))}
                </View>
              )}
              {filteredToppings.displayFlavors.length === 0 &&
                filteredToppings.displayIngredients.length === 0 && (
                  <View style={styles.emptyState}>
                    <Text style={styles.emptyText}>
                      No hay sabores ni ingredientes disponibles
                    </Text>
                  </View>
                )}
            </ScrollView>
          )}
        </View>
        <Divider />
        <View>
          <View style={styles.actions}>
            <Button
              mode="outlined"
              onPress={() => {
                if (hasChanges) {
                  setShowConfirmation(true);
                } else {
                  onDismiss();
                }
              }}
              style={[styles.actionButton, styles.cancelButton]}
              contentStyle={{ paddingVertical: 6 }}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={() => updateMutation.mutate()}
              loading={updateMutation.isPending}
              disabled={!hasChanges}
              style={[styles.actionButton, styles.saveButton]}
              contentStyle={{ paddingVertical: 6 }}
            >
              Guardar
            </Button>
          </View>
        </View>
      </Modal>
      <ConfirmationModal
        visible={showConfirmation}
        title="¿Salir sin guardar?"
        message="Los cambios se perderán"
        confirmText="Salir"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={() => {
          setShowConfirmation(false);
          setHasChanges(false);
          onDismiss();
        }}
        onCancel={() => setShowConfirmation(false)}
        onDismiss={() => setShowConfirmation(false)}
      />
    </Portal>
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationCard.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Card, Text, Chip } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import {
  CustomizationType,
  type PizzaCustomization,
} from '../types/pizzaCustomization.types';
interface PizzaCustomizationCardProps {
  customization: PizzaCustomization;
  onPress: () => void;
}
export function PizzaCustomizationCard({
  customization,
  onPress,
}: PizzaCustomizationCardProps) {
  const theme = useAppTheme();
  const styles = StyleSheet.create({
    card: {
      marginBottom: theme.spacing.s,
    },
    content: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: -4,
    },
    info: {
      flex: 1,
    },
    name: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      marginBottom: 2,
    },
    ingredients: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      lineHeight: 16,
    },
    chip: {
      marginRight: theme.spacing.xs,
      height: 24,
    },
    rightSection: {
      alignItems: 'flex-end',
      marginLeft: theme.spacing.s,
    },
    toppingValue: {
      ...theme.fonts.titleLarge,
      color: theme.colors.primary,
      fontWeight: 'bold',
    },
    toppingLabel: {
      ...theme.fonts.labelSmall,
      color: theme.colors.onSurfaceVariant,
      marginTop: -2,
    },
  });
  const getTypeLabel = (type: CustomizationType) => {
    return type === CustomizationType.FLAVOR ? 'Sabor' : 'Ingrediente';
  };
  const getTypeIcon = (type: CustomizationType) => {
    return type === CustomizationType.FLAVOR ? 'pizza' : 'food-variant';
  };
  return (
    <Card style={styles.card} onPress={onPress} mode="contained">
      <Card.Content style={{ paddingVertical: 12, paddingHorizontal: 16 }}>
        <View style={styles.content}>
          <View style={styles.info}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginBottom: 4,
              }}
            >
              <Text style={styles.name}>{customization.name}</Text>
              <Chip
                icon={getTypeIcon(customization.type)}
                style={[styles.chip, { marginLeft: theme.spacing.s }]}
                compact
                textStyle={{ fontSize: 11 }}
              >
                {getTypeLabel(customization.type)}
              </Chip>
              {!customization.isActive && (
                <Chip
                  icon="eye-off"
                  style={[styles.chip, { marginLeft: theme.spacing.xs }]}
                  compact
                  mode="outlined"
                  textStyle={{ fontSize: 11 }}
                >
                  Inactivo
                </Chip>
              )}
            </View>
            {customization.ingredients && (
              <Text style={styles.ingredients} numberOfLines={1}>
                {customization.ingredients}
              </Text>
            )}
          </View>
          <View style={styles.rightSection}>
            <Text style={styles.toppingValue}>
              {customization.toppingValue}
            </Text>
            <Text style={styles.toppingLabel}>
              topping{customization.toppingValue !== 1 ? 's' : ''}
            </Text>
          </View>
        </View>
      </Card.Content>
    </Card>
  );
}

================
File: app/src/modules/pizzaCustomizations/screens/PizzaManagementScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { FAB, Text, Icon } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useAppTheme } from '@/app/styles/theme';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import {
  PizzaProductsTab,
  PizzaCustomizationsTab,
  PizzaCustomizationFormModal,
} from '../components';
export function PizzaManagementScreen() {
  const theme = useAppTheme();
  const [selectedTab, setSelectedTab] = useState('products');
  const [formModalVisible, setFormModalVisible] = useState(false);
  useRefreshModuleOnFocus('pizza-products');
  useRefreshModuleOnFocus('pizza-customizations');
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    tabsContainer: {
      flexDirection: 'row',
      height: 48,
    },
    tab: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: theme.spacing.m,
      gap: theme.spacing.xs,
    },
    tabActive: {
      borderBottomWidth: 2,
      borderBottomColor: theme.colors.primary,
    },
    tabText: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    tabTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    tabIcon: {
      marginRight: 4,
    },
    content: {
      flex: 1,
    },
    fab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 0,
      backgroundColor: theme.colors.primary,
    },
  });
  const renderContent = () => {
    switch (selectedTab) {
      case 'products':
        return <PizzaProductsTab />;
      case 'customizations':
        return <PizzaCustomizationsTab />;
      default:
        return null;
    }
  };
  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.header}>
        <View style={styles.tabsContainer}>
          <Pressable
            style={[styles.tab, selectedTab === 'products' && styles.tabActive]}
            onPress={() => setSelectedTab('products')}
          >
            <Icon
              source="pizza"
              size={20}
              color={
                selectedTab === 'products'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                selectedTab === 'products' && styles.tabTextActive,
              ]}
            >
              Productos
            </Text>
          </Pressable>
          <Pressable
            style={[
              styles.tab,
              selectedTab === 'customizations' && styles.tabActive,
            ]}
            onPress={() => setSelectedTab('customizations')}
          >
            <Icon
              source="cheese"
              size={20}
              color={
                selectedTab === 'customizations'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                selectedTab === 'customizations' && styles.tabTextActive,
              ]}
            >
              Ingredientes
            </Text>
          </Pressable>
        </View>
      </View>
      <View style={styles.content}>{renderContent()}</View>
      {selectedTab === 'customizations' && (
        <FAB
          icon="plus"
          style={styles.fab}
          onPress={() => setFormModalVisible(true)}
          color={theme.colors.onPrimary}
        />
      )}
      <PizzaCustomizationFormModal
        visible={formModalVisible}
        onDismiss={() => setFormModalVisible(false)}
        onSuccess={() => {
        }}
      />
    </SafeAreaView>
  );
}

================
File: app/src/modules/pizzaCustomizations/services/pizzaConfigurationsService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { PizzaConfiguration } from '../types/pizzaConfiguration.types';
import type {
  PizzaConfigurationFormInputs,
  UpdatePizzaConfigurationInputs,
} from '../schema/pizzaConfiguration.schema';
async function findByProductId(
  productId: string,
): Promise<PizzaConfiguration | null> {
  const response = await apiClient.get<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS + '/product/' + productId,
  );
  if (response.status === 404) {
    return null;
  }
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}
async function create(
  data: PizzaConfigurationFormInputs,
): Promise<PizzaConfiguration> {
  const response = await apiClient.post<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS,
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}
async function update(
  id: string,
  data: UpdatePizzaConfigurationInputs,
): Promise<PizzaConfiguration> {
  const response = await apiClient.patch<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS_BY_ID.replace(':id', id),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}
async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.PIZZA_CONFIGURATIONS_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}
export const pizzaConfigurationsService = {
  findByProductId,
  create,
  update,
  remove,
};

================
File: app/src/modules/pizzaCustomizations/services/pizzaCustomizationsService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { PaginatedResponse } from '@/app/types/api.types';
import type { PizzaCustomization } from '../types/pizzaCustomization.types';
import type {
  PizzaCustomizationFormInputs,
  FindAllPizzaCustomizationsQuery,
} from '../schema/pizzaCustomization.schema';
async function findAll(
  params?: FindAllPizzaCustomizationsQuery,
): Promise<PaginatedResponse<PizzaCustomization>> {
  const response = await apiClient.get<{
    items: PizzaCustomization[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.PIZZA_CUSTOMIZATIONS, params);
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
}
async function findOne(id: string): Promise<PizzaCustomization> {
  const response = await apiClient.get<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}
async function create(
  data: PizzaCustomizationFormInputs,
): Promise<PizzaCustomization> {
  const response = await apiClient.post<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS,
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}
async function update(
  id: string,
  data: Partial<PizzaCustomizationFormInputs>,
): Promise<PizzaCustomization> {
  const response = await apiClient.patch<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}
async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}
async function updateSortOrder(
  updates: { id: string; sortOrder: number }[],
): Promise<void> {
  const response = await apiClient.patch(
    API_PATHS.PIZZA_CUSTOMIZATIONS_SORT_ORDER,
    { updates },
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}
export const pizzaCustomizationsService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  updateSortOrder,
};

================
File: app/src/modules/preparationScreens/components/PreparationScreenDetailModalSimple.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Text,
  Button,
  Chip,
  ActivityIndicator,
  IconButton,
  Divider,
} from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PreparationScreen } from '../schema/preparationScreen.schema';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';
interface PreparationScreenDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  item: PreparationScreen | null;
  onEdit?: (item: PreparationScreen) => void;
  onDelete?: (id: string) => void;
  onManageProducts?: (item: PreparationScreen) => void;
  isDeleting?: boolean;
}
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    descriptionContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      paddingBottom: theme.spacing.m,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    iconContainer: {
      width: 48,
      height: 48,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: theme.spacing.m,
    },
    description: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
      marginLeft: theme.spacing.m,
    },
    statusChip: {
      marginLeft: theme.spacing.s,
    },
    section: {
      padding: theme.spacing.m,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
      color: theme.colors.onSurface,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    infoIcon: {
      marginRight: theme.spacing.m,
    },
    infoText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    userChip: {
      marginRight: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    userChipsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      marginTop: theme.spacing.s,
    },
    productCard: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.s,
    },
    productInfo: {
      flex: 1,
    },
    productCount: {
      fontSize: 24,
      fontWeight: 'bold',
      color: theme.colors.primary,
    },
    productLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    emptyState: {
      alignItems: 'center',
      paddingVertical: theme.spacing.l,
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 14,
      marginTop: theme.spacing.s,
    },
    actionContainer: {
    },
    actionButtons: {
      flexDirection: 'row',
      gap: theme.spacing.m,
    },
    actionButton: {
      flex: 1,
      borderRadius: theme.roundness,
    },
    loadingContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl * 2,
    },
  });
const PreparationScreenDetailModal: React.FC<
  PreparationScreenDetailModalProps
> = ({
  visible,
  onDismiss,
  item,
  onEdit,
  onDelete,
  onManageProducts,
  isDeleting = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const handleEdit = () => {
    if (onEdit && item) {
      onEdit(item);
    }
  };
  const handleDelete = () => {
    if (onDelete && item) {
      onDelete(item.id);
    }
  };
  const getColor = () => {
    if (!item) return theme.colors.primary;
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return '#FF6B6B';
    if (name.includes('hamburguesa')) return '#4ECDC4';
    if (name.includes('bar')) return '#667EEA';
    return theme.colors.primary;
  };
  const getIcon = () => {
    if (!item) return 'monitor-dashboard';
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return 'pizza';
    if (name.includes('hamburguesa')) return 'hamburger';
    if (name.includes('bar')) return 'glass-cocktail';
    return 'monitor-dashboard';
  };
  const renderContent = () => {
    if (!item) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator
            animating={true}
            size="large"
            color={theme.colors.primary}
          />
        </View>
      );
    }
    const userCount = item.users?.length || 0;
    const productCount = item.products?.length || 0;
    const color = getColor();
    return (
      <>
        {}
        {item.description && (
          <View style={styles.descriptionContainer}>
            <View
              style={[styles.iconContainer, { backgroundColor: `${color}20` }]}
            >
              <Icon name={getIcon()} size={24} color={color} />
            </View>
            <Text style={styles.description} numberOfLines={2}>
              {item.description}
            </Text>
          </View>
        )}
        {}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            <Icon name="account-group" size={16} /> Usuarios Asignados (
            {userCount})
          </Text>
          {userCount > 0 ? (
            <View style={styles.userChipsContainer}>
              {item.users?.map((user: any) => (
                <Chip
                  key={user.id}
                  style={styles.userChip}
                  icon="account"
                  compact
                  mode="outlined"
                >
                  {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username}
                </Chip>
              ))}
            </View>
          ) : (
            <View style={styles.emptyState}>
              <Icon
                name="account-off-outline"
                size={32}
                color={theme.colors.onSurfaceVariant}
              />
              <Text style={styles.emptyText}>Sin usuarios asignados</Text>
            </View>
          )}
        </View>
        <Divider />
        {}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            <Icon name="food" size={16} /> Productos Asociados
          </Text>
          <View style={styles.productCard}>
            <View style={styles.productInfo}>
              <Text style={styles.productCount}>{productCount}</Text>
              <Text style={styles.productLabel}>
                {productCount === 1 ? 'Producto' : 'Productos'}
              </Text>
            </View>
            {onManageProducts && (
              <Button
                mode="contained-tonal"
                onPress={() => onManageProducts(item)}
                icon="link-variant"
                compact
              >
                Gestionar
              </Button>
            )}
          </View>
        </View>
      </>
    );
  };
  const headerActions = item && (
    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
      <Chip
        mode="flat"
        compact
        style={styles.statusChip}
        textStyle={{ fontSize: 12 }}
        selected={item.isActive}
      >
        {item.isActive ? 'Activa' : 'Inactiva'}
      </Chip>
    </View>
  );
  const footerActions = item && (
    <View style={styles.actionContainer}>
      <View style={styles.actionButtons}>
        {onEdit && (
          <Button
            icon="pencil"
            mode="contained"
            onPress={() => onEdit(item)}
            disabled={isDeleting}
            style={styles.actionButton}
            buttonColor={theme.colors.primary}
          >
            Editar
          </Button>
        )}
        {onDelete && (
          <Button
            icon="delete"
            mode="contained-tonal"
            onPress={() => onDelete(item.id)}
            loading={isDeleting}
            disabled={isDeleting}
            style={styles.actionButton}
            buttonColor={theme.colors.errorContainer}
            textColor={theme.colors.error}
          >
            Eliminar
          </Button>
        )}
      </View>
    </View>
  );
  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title={item?.name}
      headerActions={headerActions}
      hideCloseButton={isDeleting}
      dismissable={!isDeleting}
      maxHeightTablet="90%"
      scrollable={true}
      footer={footerActions}
    >
      {renderContent()}
    </ResponsiveModal>
  );
};
export default PreparationScreenDetailModal;

================
File: app/src/modules/preparationScreens/components/PreparationScreenListItem.tsx
================
import React from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Chip, IconButton, Surface } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PreparationScreen } from '../schema/preparationScreen.schema';
interface PreparationScreenListItemProps {
  item: PreparationScreen;
  onPress: (item: PreparationScreen) => void;
  onManageProducts?: (item: PreparationScreen) => void;
}
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      elevation: 2,
      backgroundColor: theme.colors.surface,
    },
    pressable: {
      borderRadius: theme.roundness * 2,
    },
    colorBar: {
      position: 'absolute',
      left: 0,
      right: 0,
      top: 0,
      height: 6,
    },
    content: {
      padding: theme.spacing.m,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.s,
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    iconContainer: {
      width: 48,
      height: 48,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: theme.spacing.m,
    },
    title: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    statusChip: {
      paddingHorizontal: theme.spacing.s,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.m,
      lineHeight: 20,
    },
    footer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingTop: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    statsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.l,
    },
    stat: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    statIcon: {
      opacity: 0.7,
    },
    statText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    actionButton: {
      margin: -8,
    },
  });
const PreparationScreenListItem: React.FC<PreparationScreenListItemProps> = ({
  item,
  onPress,
  onManageProducts,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);
  const userCount = item.users?.length || 0;
  const productCount = item.products?.length || 0;
  const isActive = item.isActive ?? true;
  const getGradientColors = () => {
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) {
      return ['#FF6B6B', '#FF8E53'];
    } else if (name.includes('hamburguesa')) {
      return ['#4ECDC4', '#44A08D'];
    } else if (name.includes('bar')) {
      return ['#667EEA', '#764BA2'];
    }
    return [theme.colors.primary, theme.colors.secondary];
  };
  const getIcon = () => {
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return 'pizza';
    if (name.includes('hamburguesa')) return 'hamburger';
    if (name.includes('bar')) return 'glass-cocktail';
    return 'monitor-dashboard';
  };
  const gradientColors = getGradientColors();
  return (
    <Surface style={styles.container}>
      <Pressable
        style={styles.pressable}
        onPress={() => onPress(item)}
        android_ripple={{ borderless: false }}
      >
        <View
          style={[styles.colorBar, { backgroundColor: gradientColors[0] }]}
        />
        <View style={styles.content}>
          <View style={styles.header}>
            <View style={styles.titleContainer}>
              <View
                style={[
                  styles.iconContainer,
                  { backgroundColor: `${gradientColors[0]}20` },
                ]}
              >
                <Icon name={getIcon()} size={24} color={gradientColors[0]} />
              </View>
              <Text style={styles.title} numberOfLines={1}>
                {item.name}
              </Text>
            </View>
            <Chip
              mode="flat"
              compact
              style={[
                styles.statusChip,
                {
                  backgroundColor: isActive
                    ? theme.colors.successContainer
                    : theme.colors.surfaceVariant,
                },
              ]}
              textStyle={{
                color: isActive
                  ? theme.colors.onSuccessContainer
                  : theme.colors.onSurfaceVariant,
                fontSize: 12,
              }}
            >
              {isActive ? 'Activa' : 'Inactiva'}
            </Chip>
          </View>
          {item.description && (
            <Text style={styles.description} numberOfLines={2}>
              {item.description}
            </Text>
          )}
          <View style={styles.footer}>
            <View style={styles.statsContainer}>
              <View style={styles.stat}>
                <Icon
                  name="account-group"
                  size={16}
                  color={theme.colors.onSurfaceVariant}
                  style={styles.statIcon}
                />
                <Text style={styles.statText}>
                  {userCount} {userCount === 1 ? 'usuario' : 'usuarios'}
                </Text>
              </View>
              <View style={styles.stat}>
                <Icon
                  name="food"
                  size={16}
                  color={theme.colors.onSurfaceVariant}
                  style={styles.statIcon}
                />
                <Text style={styles.statText}>
                  {productCount} {productCount === 1 ? 'producto' : 'productos'}
                </Text>
              </View>
            </View>
            {onManageProducts && (
              <IconButton
                icon="link-variant"
                size={20}
                onPress={() => onManageProducts(item)}
                style={styles.actionButton}
              />
            )}
          </View>
        </View>
      </Pressable>
    </Surface>
  );
};
export default PreparationScreenListItem;

================
File: app/src/modules/printers/components/PrinterDiscoveryModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet } from 'react-native';
import { FlashList, ListRenderItemInfo } from '@shopify/flash-list';
import {
  Modal,
  Portal,
  Text,
  ActivityIndicator,
  List,
  Icon,
  Divider,
  IconButton,
  Appbar,
} from 'react-native-paper';
import {
  useDiscoverPrinters,
  useTestPrintDiscoveredPrinter,
} from '../hooks/usePrintersQueries';
import { DiscoveredPrinter } from '../types/printer.types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
interface PrinterDiscoveryModalProps {
  visible: boolean;
  onDismiss: () => void;
  onPrinterSelect: (printer: DiscoveredPrinter) => void;
}
const PrinterDiscoveryModal: React.FC<PrinterDiscoveryModalProps> = ({
  visible,
  onDismiss,
  onPrinterSelect,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const discoverMutation = useDiscoverPrinters();
  const testPrintMutation = useTestPrintDiscoveredPrinter();
  useEffect(() => {
    if (visible) {
      discoverMutation.mutate(undefined, {
        onError: (error) => {
          showSnackbar({
            message: `Error descubriendo impresoras: ${getApiErrorMessage(error)}`,
            type: 'error',
          });
        },
      });
    }
  }, [visible, discoverMutation, showSnackbar]);
  const handleRescan = () => {
    discoverMutation.mutate(undefined);
  };
  const handleTestPrint = (printer: DiscoveredPrinter) => {
    testPrintMutation.mutate(printer);
  };
  const renderPrinterItem = (
    { item }: ListRenderItemInfo<DiscoveredPrinter>,
  ) => (
    <List.Item
      title={item.name || item.ip}
      description={`IP: ${item.ip}:${item.port}${item.mac ? ` | MAC: ${item.mac}` : ''}${item.model ? ` (${item.model})` : ''}`}
      left={(props) => <List.Icon {...props} icon="printer" />}
      right={(props) => (
        <View style={styles.itemActions}>
          <IconButton
            {...props}
            icon="printer-check"
            size={24}
            onPress={() => handleTestPrint(item)}
            disabled={testPrintMutation.isPending}
            loading={
              testPrintMutation.isPending &&
              testPrintMutation.variables?.ip === item.ip
            }
            tooltip="Imprimir prueba"
          />
          <IconButton
            {...props}
            icon="plus"
            size={24}
            onPress={() => onPrinterSelect(item)}
            disabled={testPrintMutation.isPending}
            tooltip="Agregar impresora"
          />
        </View>
      )}
      style={styles.listItem}
      titleStyle={styles.itemTitle}
      descriptionStyle={styles.itemDescription}
    />
  );
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
        dismissable={
          !discoverMutation.isPending && !testPrintMutation.isPending
        }
      >
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction
            onPress={onDismiss}
            disabled={discoverMutation.isPending || testPrintMutation.isPending}
          />
          <Appbar.Content
            title="Descubrir Impresoras"
            titleStyle={styles.appBarTitle}
          />
          {}
          <Appbar.Action
            icon="refresh"
            size={32}
            onPress={handleRescan}
            disabled={discoverMutation.isPending || testPrintMutation.isPending}
            color={theme.colors.primary}
          />
        </Appbar.Header>
        <View style={styles.contentContainer}>
          {discoverMutation.isPending && (
            <View style={styles.centeredView}>
              <ActivityIndicator animating={true} size="large" />
              <Text style={styles.statusText}>
                Buscando impresoras en la red...
              </Text>
              <Text style={styles.statusSubText}>
                (Esto puede tardar unos segundos)
              </Text>
            </View>
          )}
          {discoverMutation.isError && !discoverMutation.isPending && (
            <View style={styles.centeredView}>
              <Icon
                source="alert-circle-outline"
                color={theme.colors.error}
                size={48}
              />
              <Text style={styles.errorText}>
                Error al buscar impresoras:{' '}
                {getApiErrorMessage(discoverMutation.error)}
              </Text>
              {}
            </View>
          )}
          {discoverMutation.isSuccess && !discoverMutation.isPending && (
            <>
              {discoverMutation.data.length === 0 ? (
                <View style={styles.centeredView}>
                  <Icon
                    source="printer-off"
                    color={theme.colors.onSurfaceVariant}
                    size={48}
                  />
                  <Text style={styles.statusText}>
                    No se encontraron impresoras.
                  </Text>
                  <Text style={styles.statusSubText}>
                    Asegúrate de que estén encendidas y en la misma red.
                  </Text>
                  {}
                </View>
              ) : (
                <>
                  {}
                  <Text style={styles.foundText}>Impresoras encontradas:</Text>
                  <FlashList
                    data={discoverMutation.data}
                    renderItem={renderPrinterItem}
                    keyExtractor={(item: DiscoveredPrinter) =>
                      `${item.ip}:${item.port}`
                    }
                    estimatedItemSize={70}
                    ItemSeparatorComponent={() => (
                      <Divider style={styles.divider} />
                    )}
                  />
                  {}
                </>
              )}
            </>
          )}
        </View>
        {}
      </Modal>
    </Portal>
  );
};
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '100%',
      height: '100%',
      margin: 0,
      justifyContent: 'flex-start',
    },
    appBar: {
      backgroundColor: theme.colors.elevation.level2,
    },
    appBarTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
    },
    contentContainer: {
      flex: 1,
      padding: theme.spacing.m,
    },
    centeredView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    statusText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      textAlign: 'center',
      color: theme.colors.onSurface,
    },
    statusSubText: {
      marginTop: theme.spacing.xs,
      fontSize: 14,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      marginTop: theme.spacing.m,
      color: theme.colors.error,
      textAlign: 'center',
      marginBottom: theme.spacing.m,
    },
    foundText: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.m,
      color: theme.colors.primary,
    },
    list: {
      flex: 1,
      marginBottom: theme.spacing.m,
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    itemTitle: {
      fontWeight: '500',
    },
    itemDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    itemActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    divider: {
      height: 0,
    },
    button: {
      marginTop: theme.spacing.m,
      minWidth: 150,
    },
  });
export default PrinterDiscoveryModal;

================
File: app/src/modules/printers/components/PrinterListItem.tsx
================
import React from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Surface, Icon, Chip } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { ThermalPrinter } from '../types/printer.types';
interface PrinterListItemProps {
  printer: ThermalPrinter;
  onPress: () => void;
  renderActions?: React.ReactNode;
}
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      elevation: 2,
    },
    pressable: {
      padding: theme.spacing.m,
    },
    content: {
      gap: theme.spacing.s,
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    titleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      flex: 1,
      marginRight: 60,
    },
    printerIcon: {
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: theme.roundness,
      padding: theme.spacing.xs,
    },
    titleContainer: {
      flex: 1,
    },
    title: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    connectionInfo: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    statusBadge: {
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
    },
    activeBadge: {
      borderColor: theme.colors.primary,
    },
    inactiveBadge: {
      borderColor: theme.colors.error,
    },
    detailsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.xs,
      marginTop: theme.spacing.xs,
      marginRight: 60,
    },
    detailChip: {
      height: 24,
      backgroundColor: theme.colors.surfaceVariant,
    },
    detailChipLabel: {
      fontSize: 11,
      marginHorizontal: 8,
      marginVertical: 0,
    },
    featuresRow: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      marginTop: theme.spacing.xs,
      marginRight: 60,
    },
    featureChip: {
      height: 28,
      backgroundColor: theme.colors.secondaryContainer,
    },
    featureChipLabel: {
      fontSize: 12,
      marginHorizontal: 10,
      marginVertical: 0,
      color: theme.colors.onSecondaryContainer,
    },
    actionsContainer: {
      position: 'absolute',
      right: theme.spacing.m,
      top: theme.spacing.m,
    },
  });
const PrinterListItem: React.FC<PrinterListItemProps> = ({
  printer,
  onPress,
  renderActions,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);
  const getConnectionDisplay = () => {
    if (printer.connectionType === 'NETWORK' && printer.ipAddress) {
      return `${printer.ipAddress}:${printer.port || 9100}`;
    }
    return printer.connectionType;
  };
  const hasAutoPrintFeatures =
    printer.autoDeliveryPrint || printer.autoPickupPrint;
  return (
    <Surface style={styles.container}>
      <Pressable
        style={styles.pressable}
        onPress={onPress}
        android_ripple={{ color: theme.colors.primary + '20' }}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <View style={styles.titleRow}>
              <View style={styles.printerIcon}>
                <Icon
                  source="printer"
                  size={20}
                  color={theme.colors.onPrimaryContainer}
                />
              </View>
              <View style={styles.titleContainer}>
                <Text style={styles.title}>{printer.name}</Text>
                <Text style={styles.connectionInfo}>
                  {getConnectionDisplay()}
                </Text>
              </View>
            </View>
            {renderActions && (
              <View style={styles.actionsContainer}>{renderActions}</View>
            )}
          </View>
          <View style={styles.detailsContainer}>
            <Chip
              mode="flat"
              style={[
                styles.statusBadge,
                printer.isActive ? styles.activeBadge : styles.inactiveBadge,
              ]}
              textStyle={[
                styles.detailChipLabel,
                {
                  color: printer.isActive
                    ? theme.colors.primary
                    : theme.colors.error,
                },
              ]}
            >
              {printer.isActive ? 'Activa' : 'Inactiva'}
            </Chip>
            {printer.isDefaultPrinter && (
              <Chip
                mode="flat"
                style={styles.detailChip}
                textStyle={styles.detailChipLabel}
                icon="star"
              >
                Predeterminada
              </Chip>
            )}
            <Chip
              mode="flat"
              style={styles.detailChip}
              textStyle={styles.detailChipLabel}
              icon="file-document-outline"
            >
              {printer.paperWidth}mm
            </Chip>
          </View>
          {hasAutoPrintFeatures && (
            <View style={styles.featuresRow}>
              {printer.autoDeliveryPrint && (
                <Chip
                  mode="flat"
                  style={styles.featureChip}
                  textStyle={styles.featureChipLabel}
                  icon="home-export-outline"
                >
                  Auto Domicilio
                </Chip>
              )}
              {printer.autoPickupPrint && (
                <Chip
                  mode="flat"
                  style={styles.featureChip}
                  textStyle={styles.featureChipLabel}
                  icon="bag-checked"
                >
                  Auto Para Llevar
                </Chip>
              )}
            </View>
          )}
        </View>
      </Pressable>
    </Surface>
  );
};
export default PrinterListItem;

================
File: app/src/modules/shared/components/OrderHistoryModal.tsx
================
import React, { useCallback, useMemo, useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  Platform,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Divider,
  Chip,
  Button,
  Avatar,
  Surface,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
interface HistoryItem {
  id: string | number;
  orderId: string;
  orderItemId?: string;
  operation: 'INSERT' | 'UPDATE' | 'DELETE' | 'BATCH';
  changedBy: string;
  changedAt: string;
  diff?: Record<string, any> | null;
  snapshot?: Record<string, any>;
  productId?: string;
  preparationStatus?: string;
  changedByUser?: {
    id?: string;
    firstName: string;
    lastName: string;
  };
  user?: {
    firstName: string;
    lastName: string;
  };
  itemDescription?: string;
  formattedChanges?: Record<string, any>;
  batchOperations?: any[];
  type: 'order' | 'item';
}
interface OrderHistoryModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId: string | null;
  orderNumber?: number;
}
const getOperationIcon = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    return 'receipt';
  }
  switch (operation) {
    case 'INSERT':
      return 'plus-circle';
    case 'UPDATE':
      return 'pencil';
    case 'DELETE':
      return 'delete';
    case 'BATCH':
      return 'folder-multiple';
    default:
      return 'information';
  }
};
const getOperationLabel = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    const orderOperationMap: Record<string, string> = {
      INSERT: 'Orden creada',
      UPDATE: 'Orden modificada',
      DELETE: 'Orden eliminada',
    };
    return orderOperationMap[operation] || operation;
  }
  const operationMap: Record<string, string> = {
    INSERT: 'Item agregado',
    UPDATE: 'Item modificado',
    DELETE: 'Item eliminado',
    BATCH: 'Cambios múltiples',
  };
  return operationMap[operation] || operation;
};
const getStatusColor = (status: string, theme: any) => {
  switch (status) {
    case 'PENDING':
      return theme.colors.error;
    case 'IN_PROGRESS':
    case 'IN_PREPARATION':
      return theme.colors.warning;
    case 'READY':
    case 'DELIVERED':
    case 'COMPLETED':
      return theme.colors.success;
    case 'CANCELLED':
      return theme.colors.onSurfaceVariant;
    default:
      return theme.colors.onSurface;
  }
};
const formatFieldName = (field: string): string => {
  const fieldMap: Record<string, string> = {
    orderStatus: 'Estado de la orden',
    orderType: 'Tipo de orden',
    tableId: 'Mesa',
    table: 'Mesa',
    notes: 'Notas',
    deliveryInfo: 'Información de entrega',
    scheduledAt: 'Programado para',
    customerId: 'Cliente',
    isFromWhatsApp: 'Orden de WhatsApp',
    recipientName: 'Destinatario',
    recipientPhone: 'Teléfono',
    fullAddress: 'Dirección completa',
    deliveryInstructions: 'Instrucciones de entrega',
    street: 'Calle',
    number: 'Número',
    neighborhood: 'Colonia',
    city: 'Ciudad',
    state: 'Estado',
    zipCode: 'Código postal',
  };
  return fieldMap[field] || field;
};
const formatValue = (field: string, value: any): string => {
  if (value === null || value === undefined) return 'Sin valor';
  if (field === 'orderStatus' || field === 'preparationStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Progreso',
      IN_PREPARATION: 'En Preparación',
      READY: 'Lista',
      DELIVERED: 'Entregada',
      COMPLETED: 'Completada',
      CANCELLED: 'Cancelada',
    };
    return statusMap[value] || value;
  }
  if (field === 'orderType') {
    const typeMap: Record<string, string> = {
      DINE_IN: 'Para Comer Aquí',
      TAKE_AWAY: 'Para Llevar',
      DELIVERY: 'Domicilio',
    };
    return typeMap[value] || value;
  }
  if (field === 'table' || field === 'tableId') {
    if (typeof value === 'object' && value !== null) {
      return value.name || 'Sin mesa';
    }
    return value || 'Sin mesa';
  }
  if (field === 'recipientName') {
    return value || 'Sin nombre';
  }
  if (field === 'recipientPhone') {
    return value || 'Sin teléfono';
  }
  if (field === 'fullAddress') {
    return value || 'Sin dirección';
  }
  if (field === 'isFromWhatsApp') {
    return value ? 'Sí' : 'No';
  }
  if (field === 'customerId') {
    return value || 'Sin cliente registrado';
  }
  if (field === 'scheduledAt') {
    return value
      ? format(new Date(value), 'dd/MM/yyyy HH:mm', { locale: es })
      : 'No programado';
  }
  return String(value);
};
const HistoryItemComponent: React.FC<{
  item: HistoryItem;
  theme: ReturnType<typeof useAppTheme>;
}> = ({ item, theme }) => {
  const [expanded, setExpanded] = useState(false);
  const styles = useMemo(() => createStyles(theme), [theme]);
  const renderChangeDetail = (change: any, fieldName?: string) => {
    if (
      change &&
      typeof change === 'object' &&
      change.anterior !== undefined &&
      change.nuevo !== undefined
    ) {
      if (
        (fieldName === 'Descripción del Item' || fieldName === 'Descripción') &&
        (String(change.anterior).length > 30 ||
          String(change.nuevo).length > 30)
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {String(change.anterior)}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Después:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {String(change.nuevo)}
              </Text>
            </View>
          </View>
        );
      }
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {String(change.anterior)}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {String(change.nuevo)}
            </Text>
          </View>
        </View>
      );
    } else if (Array.isArray(change) && change.length === 2) {
      const oldVal = formatValue(fieldName || '', change[0]);
      const newVal = formatValue(fieldName || '', change[1]);
      // Para campos largos o especiales, usar formato vertical
      if (
        fieldName &&
        ['notes', 'deliveryInfo', 'customerName', 'deliveryAddress'].includes(
          fieldName,
        )
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {oldVal}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Después:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {newVal}
              </Text>
            </View>
          </View>
        );
      }
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {oldVal}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {newVal}
            </Text>
          </View>
        </View>
      );
    }
    return null;
  };
  return (
    <Surface
      style={[
        styles.historyItem,
        { backgroundColor: theme.colors.surfaceVariant },
      ]}
      elevation={1}
    >
      <TouchableOpacity
        onPress={() => setExpanded(!expanded)}
        activeOpacity={0.7}
      >
        <View style={styles.historyHeader}>
          <View style={{ flex: 1, marginRight: 12 }}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginBottom: 4,
              }}
            >
              <Avatar.Icon
                size={24}
                icon={getOperationIcon(item.operation, item.type)}
                style={{
                  backgroundColor:
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary,
                  marginRight: 6,
                }}
              />
              <Text
                variant="bodySmall"
                style={{ fontWeight: '600', flex: 1 }}
                numberOfLines={1}
              >
                {item.changedByUser
                  ? `${item.changedByUser.firstName} ${item.changedByUser.lastName}`
                  : item.user
                    ? `${item.user.firstName} ${item.user.lastName}`
                    : 'Sistema'}
              </Text>
              <View
                style={{
                  width: 32,
                  height: 32,
                  borderRadius: 16,
                  backgroundColor: theme.colors.surfaceVariant,
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Icon
                  name={expanded ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                flexWrap: 'wrap',
                gap: 4,
              }}
            >
              <View
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor:
                    (item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary) + '15',
                  paddingHorizontal: 5,
                  paddingVertical: 1,
                  borderRadius: 10,
                }}
              >
                <Icon
                  name={getOperationIcon(item.operation, item.type)}
                  size={10}
                  color={
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary
                  }
                  style={{ marginRight: 3 }}
                />
                <Text
                  style={{
                    color:
                      item.type === 'order'
                        ? theme.colors.primary
                        : theme.colors.secondary,
                    fontSize: 9,
                    fontWeight: '600',
                  }}
                >
                  {getOperationLabel(item.operation, item.type)}
                </Text>
              </View>
              {item.preparationStatus && (
                <Chip
                  mode="flat"
                  textStyle={{ fontSize: 9 }}
                  style={{
                    backgroundColor:
                      getStatusColor(item.preparationStatus, theme) + '20',
                    transform: [{ scale: 0.8 }],
                    height: 20,
                  }}
                  compact
                >
                  {formatValue('preparationStatus', item.preparationStatus)}
                </Chip>
              )}
              <Text variant="labelSmall" style={{ opacity: 0.6, fontSize: 10 }}>
                {format(new Date(item.changedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          </View>
        </View>
      </TouchableOpacity>
      {expanded && (
        <View style={styles.expandedContent}>
          <Divider style={{ marginBottom: 8 }} />
          {}
          {item.type === 'order' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <>
                  {}
                  {item.diff && (item.diff.order || item.diff.items) ? (
                    <>
                      {item.diff.summary && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.primary,
                            fontWeight: '600',
                            marginBottom: 8,
                            fontStyle: 'italic',
                          }}
                        >
                          {item.diff.summary}
                        </Text>
                      )}
                      {}
                      {item.diff.order && (
                        <View
                          style={{
                            backgroundColor: theme.colors.surface,
                            padding: 8,
                            borderRadius: 6,
                            marginBottom: 8,
                          }}
                        >
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.primary,
                              fontWeight: '600',
                              marginBottom: 6,
                            }}
                          >
                            Detalles de la orden:
                          </Text>
                          {item.diff.order.fields?.orderType && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.diff.order.fields.orderType[1],
                              )}
                            </Text>
                          )}
                          {item.diff.order.fields?.tableId && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Mesa:</Text>{' '}
                              {item.snapshot?.table?.name ||
                                `Mesa ${item.diff.order.fields.tableId[1]}`}
                            </Text>
                          )}
                          {item.diff.order.fields?.notes && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Notas:</Text>{' '}
                              {item.diff.order.fields.notes[1]}
                            </Text>
                          )}
                          {}
                          {item.diff.order.deliveryInfo && (
                            <>
                              {item.diff.order.deliveryInfo.recipientName && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Cliente:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientName[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.recipientPhone && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Teléfono:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientPhone[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.fullAddress && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Dirección:
                                  </Text>{' '}
                                  {item.diff.order.deliveryInfo.fullAddress[1]}
                                </Text>
                              )}
                            </>
                          )}
                        </View>
                      )}
                      {}
                      {item.diff.items?.added &&
                        item.diff.items.added.length > 0 && (
                          <>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                marginTop: 8,
                              }}
                            >
                              Productos incluidos en la orden:
                            </Text>
                            {item.diff.items.added.map(
                              (addedItem: any, idx: number) => (
                                <View
                                  key={`added-${idx}`}
                                  style={{
                                    marginBottom: 8,
                                    paddingLeft: 8,
                                    borderLeftWidth: 2,
                                    borderLeftColor:
                                      theme.colors.primary + '50',
                                    backgroundColor: theme.colors.surface,
                                    padding: 8,
                                    marginLeft: 4,
                                    borderRadius: 4,
                                  }}
                                >
                                  <Text
                                    variant="bodySmall"
                                    style={{ fontWeight: '600' }}
                                  >
                                    {addedItem.productName}
                                    {addedItem.variantName
                                      ? ` - ${addedItem.variantName}`
                                      : ''}
                                  </Text>
                                  {addedItem.modifiers?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Modificadores:{' '}
                                      {addedItem.modifiers.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.customizations?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Personalizaciones:{' '}
                                      {addedItem.customizations.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.notes && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        fontStyle: 'italic',
                                      }}
                                    >
                                      Notas: {addedItem.notes}
                                    </Text>
                                  )}
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      marginTop: 2,
                                      fontWeight: '600',
                                      color: theme.colors.primary,
                                    }}
                                  >
                                    Precio: ${addedItem.price}
                                  </Text>
                                </View>
                              ),
                            )}
                          </>
                        )}
                    </>
                  ) : (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Nueva orden creada
                      </Text>
                      {item.snapshot && (
                        <View
                          style={{
                            backgroundColor: theme.colors.surface,
                            padding: 8,
                            borderRadius: 6,
                          }}
                        >
                          {item.snapshot.orderType && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.snapshot.orderType,
                              )}
                            </Text>
                          )}
                          {item.snapshot.tableId && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Mesa:</Text>{' '}
                              {item.snapshot.table?.name ||
                                'Mesa ' + item.snapshot.tableId}
                            </Text>
                          )}
                          {item.snapshot.notes && (
                            <Text variant="bodySmall">
                              <Text style={{ fontWeight: '600' }}>Notas:</Text>{' '}
                              {item.snapshot.notes}
                            </Text>
                          )}
                        </View>
                      )}
                    </>
                  )}
                </>
              )}
              {item.operation === 'UPDATE' &&
                item.diff &&
                (() => {
                  const relevantChanges = Object.entries(item.diff)
                    .filter(([field]) => {
                      const allowedFields = [
                        'orderStatus',
                        'orderType',
                        'notes',
                        'tableId',
                        'customerId',
                        'scheduledAt',
                        'deliveryInfo',
                        'isFromWhatsApp',
                      ];
                      return allowedFields.includes(field);
                    })
                    .flatMap(([field, change]) => {
                      if (
                        field === 'deliveryInfo' &&
                        change &&
                        typeof change === 'object' &&
                        !Array.isArray(change)
                      ) {
                        return Object.entries(change).map(
                          ([subField, subChange]) => ({
                            field: subField,
                            change: subChange,
                          }),
                        );
                      }
                      return [{ field, change }];
                    });
                  if (relevantChanges.length === 0) {
                    return (
                      <Text
                        variant="bodySmall"
                        style={{ color: theme.colors.onSurfaceVariant }}
                      >
                        Actualización de productos de la orden
                      </Text>
                    );
                  }
                  return (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en la orden:
                      </Text>
                      {relevantChanges.map(({ field, change }) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ))}
                    </>
                  );
                })()}
              {item.operation === 'DELETE' && (
                <Text variant="bodySmall" style={{ color: theme.colors.error }}>
                  La orden fue eliminada
                </Text>
              )}
            </View>
          )}
          {}
          {item.diff &&
            (item.diff.order || item.diff.items || item.diff.summary) && (
              <View style={styles.changesContainer}>
                {}
                {item.diff.summary && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                      fontStyle: 'italic',
                    }}
                  >
                    {item.diff.summary}
                  </Text>
                )}
                {}
                {item.diff.order?.fields && (
                  <>
                    <Text
                      variant="bodySmall"
                      style={{
                        color: theme.colors.primary,
                        fontWeight: '600',
                        marginBottom: 8,
                      }}
                    >
                      Cambios en la orden:
                    </Text>
                    {Object.entries(item.diff.order.fields).map(
                      ([field, change]) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ),
                    )}
                  </>
                )}
                {}
                {item.diff.order?.deliveryInfo && (
                  <>
                    <Text
                      variant="bodySmall"
                      style={{
                        color: theme.colors.primary,
                        fontWeight: '600',
                        marginBottom: 8,
                      }}
                    >
                      Cambios en información de entrega:
                    </Text>
                    {Object.entries(item.diff.order.deliveryInfo).map(
                      ([field, change]) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ),
                    )}
                  </>
                )}
                {}
                {item.formattedChanges &&
                  item.formattedChanges['Cambios en productos'] && (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en productos:
                      </Text>
                      {}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos modificados'
                      ] && (
                        <View style={{ marginTop: 8 }}>
                          {item.formattedChanges['Cambios en productos'][
                            'Productos modificados'
                          ].map((modItem: any, idx: number) => (
                            <View
                              key={`mod-${idx}`}
                              style={{
                                marginBottom: 12,
                                backgroundColor: theme.colors.surfaceVariant,
                                borderRadius: theme.roundness * 2,
                                overflow: 'hidden',
                              }}
                            >
                              {}
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  backgroundColor: theme.colors.warning + '20',
                                  paddingHorizontal: 12,
                                  paddingVertical: 8,
                                  borderBottomWidth: 1,
                                  borderBottomColor:
                                    theme.colors.warning + '30',
                                }}
                              >
                                <Icon
                                  name="pencil"
                                  size={16}
                                  color={theme.colors.warning}
                                  style={{ marginRight: 8 }}
                                />
                                <Text
                                  variant="labelMedium"
                                  style={{
                                    color: theme.colors.warning,
                                    fontWeight: '600',
                                    flex: 1,
                                  }}
                                >
                                  Producto modificado
                                </Text>
                              </View>
                              {}
                              <View style={{ padding: 12 }}>
                                <View
                                  style={{
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    backgroundColor: theme.colors.surface,
                                    borderRadius: theme.roundness,
                                    padding: 10,
                                  }}
                                >
                                  {}
                                  <View
                                    style={{
                                      flex: 1,
                                      paddingRight: 8,
                                    }}
                                  >
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        color: theme.colors.error,
                                        marginBottom: 4,
                                        opacity: 0.8,
                                      }}
                                    >
                                      Antes
                                    </Text>
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.onSurfaceVariant,
                                        textDecorationLine: 'line-through',
                                        opacity: 0.7,
                                      }}
                                    >
                                      {modItem.antes}
                                    </Text>
                                  </View>
                                  {}
                                  <View
                                    style={{
                                      paddingHorizontal: 8,
                                    }}
                                  >
                                    <Icon
                                      name="arrow-right-thick"
                                      size={24}
                                      color={theme.colors.primary}
                                    />
                                  </View>
                                  {}
                                  <View
                                    style={{
                                      flex: 1,
                                      paddingLeft: 8,
                                    }}
                                  >
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        color: theme.colors.primary,
                                        marginBottom: 4,
                                      }}
                                    >
                                      Después
                                    </Text>
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.primary,
                                        fontWeight: '600',
                                      }}
                                    >
                                      {modItem.después}
                                    </Text>
                                  </View>
                                </View>
                              </View>
                            </View>
                          ))}
                        </View>
                      )}
                      {}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos agregados'
                      ] && (
                        <>
                          {item.formattedChanges['Cambios en productos'][
                            'Productos agregados'
                          ].map((product: string, idx: number) => (
                            <View
                              key={`added-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.success + '50',
                              }}
                            >
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'flex-start',
                                }}
                              >
                                <Icon
                                  name="plus-circle"
                                  size={14}
                                  color={theme.colors.success}
                                  style={{ marginRight: 6, marginTop: 2 }}
                                />
                                <View style={{ flex: 1 }}>
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.success,
                                      fontWeight: '600',
                                    }}
                                  >
                                    Producto agregado
                                  </Text>
                                  <Text
                                    variant="bodySmall"
                                    style={{ marginTop: 2 }}
                                  >
                                    {product}
                                  </Text>
                                </View>
                              </View>
                            </View>
                          ))}
                        </>
                      )}
                      {}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos eliminados'
                      ] && (
                        <>
                          {item.formattedChanges['Cambios en productos'][
                            'Productos eliminados'
                          ].map((product: string, idx: number) => (
                            <View
                              key={`removed-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.error + '50',
                              }}
                            >
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'flex-start',
                                }}
                              >
                                <Icon
                                  name="delete"
                                  size={14}
                                  color={theme.colors.error}
                                  style={{ marginRight: 6, marginTop: 2 }}
                                />
                                <View style={{ flex: 1 }}>
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.error,
                                      fontWeight: '600',
                                    }}
                                  >
                                    Producto eliminado
                                  </Text>
                                  <Text
                                    variant="bodySmall"
                                    style={{ marginTop: 2 }}
                                  >
                                    {product}
                                  </Text>
                                </View>
                              </View>
                            </View>
                          ))}
                        </>
                      )}
                    </>
                  )}
                {}
                {item.diff.items &&
                  !item.formattedChanges?.['Cambios en productos'] && (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en productos:
                      </Text>
                      {}
                      {item.diff.items.added?.map(
                        (addedItem: any, idx: number) => (
                          <View
                            key={`added-${idx}`}
                            style={{
                              marginBottom: 8,
                              paddingLeft: 8,
                              borderLeftWidth: 2,
                              borderLeftColor: theme.colors.success + '50',
                            }}
                          >
                            <View
                              style={{
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                              }}
                            >
                              <Icon
                                name="plus-circle"
                                size={14}
                                color={theme.colors.success}
                                style={{ marginRight: 6, marginTop: 2 }}
                              />
                              <View style={{ flex: 1 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.success,
                                    fontWeight: '600',
                                  }}
                                >
                                  Producto agregado
                                </Text>
                                <Text
                                  variant="bodySmall"
                                  style={{ marginTop: 2 }}
                                >
                                  {addedItem.productName}
                                  {addedItem.variantName
                                    ? ` - ${addedItem.variantName}`
                                    : ''}
                                </Text>
                                {addedItem.modifiers?.length > 0 && (
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      marginTop: 2,
                                      color: theme.colors.onSurfaceVariant,
                                    }}
                                  >
                                    Modificadores:{' '}
                                    {addedItem.modifiers.join(', ')}
                                  </Text>
                                )}
                                {addedItem.price && (
                                  <Text
                                    variant="labelSmall"
                                    style={{ marginTop: 2, fontWeight: '600' }}
                                  >
                                    Precio: ${addedItem.price}
                                  </Text>
                                )}
                              </View>
                            </View>
                          </View>
                        ),
                      )}
                      {}
                      {item.diff.items.modified?.map(
                        (modItem: any, idx: number) => (
                          <View
                            key={`mod-${idx}`}
                            style={{
                              marginBottom: 8,
                              paddingLeft: 8,
                              borderLeftWidth: 2,
                              borderLeftColor: theme.colors.warning + '50',
                            }}
                          >
                            <View
                              style={{
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                              }}
                            >
                              <Icon
                                name="pencil"
                                size={14}
                                color={theme.colors.warning}
                                style={{ marginRight: 6, marginTop: 2 }}
                              />
                              <View style={{ flex: 1 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.warning,
                                    fontWeight: '600',
                                  }}
                                >
                                  Producto modificado
                                </Text>
                                <View
                                  style={{
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    flexWrap: 'wrap',
                                    marginTop: 4,
                                  }}
                                >
                                  <View
                                    style={{
                                      backgroundColor:
                                        theme.colors.errorContainer,
                                      paddingHorizontal: 8,
                                      paddingVertical: 4,
                                      borderRadius: 4,
                                      marginRight: 6,
                                      marginTop: 4,
                                    }}
                                  >
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.onErrorContainer,
                                      }}
                                    >
                                      {modItem.before.productName}
                                      {modItem.before.variantName
                                        ? ` - ${modItem.before.variantName}`
                                        : ''}
                                    </Text>
                                  </View>
                                  <Icon
                                    name="arrow-right"
                                    size={16}
                                    color={theme.colors.onSurfaceVariant}
                                    style={{
                                      marginHorizontal: 4,
                                      marginTop: 4,
                                    }}
                                  />
                                  <View
                                    style={{
                                      backgroundColor:
                                        theme.colors.primaryContainer,
                                      paddingHorizontal: 8,
                                      paddingVertical: 4,
                                      borderRadius: 4,
                                      marginTop: 4,
                                    }}
                                  >
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.onPrimaryContainer,
                                      }}
                                    >
                                      {modItem.after.productName}
                                      {modItem.after.variantName
                                        ? ` - ${modItem.after.variantName}`
                                        : ''}
                                    </Text>
                                  </View>
                                </View>
                              </View>
                            </View>
                          </View>
                        ),
                      )}
                      {/* Items eliminados */}
                      {item.diff.items.removed?.map(
                        (removedItem: any, idx: number) => (
                          <View
                            key={`removed-${idx}`}
                            style={{
                              marginBottom: 8,
                              paddingLeft: 8,
                              borderLeftWidth: 2,
                              borderLeftColor: theme.colors.error + '50',
                            }}
                          >
                            <View
                              style={{
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                              }}
                            >
                              <Icon
                                name="delete"
                                size={14}
                                color={theme.colors.error}
                                style={{ marginRight: 6, marginTop: 2 }}
                              />
                              <View style={{ flex: 1 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.error,
                                    fontWeight: '600',
                                  }}
                                >
                                  Producto eliminado
                                </Text>
                                <Text
                                  variant="bodySmall"
                                  style={{ marginTop: 2 }}
                                >
                                  {removedItem.productName}
                                  {removedItem.variantName
                                    ? ` - ${removedItem.variantName}`
                                    : ''}
                                </Text>
                                {removedItem.price && (
                                  <Text
                                    variant="labelSmall"
                                    style={{ marginTop: 2, fontWeight: '600' }}
                                  >
                                    Precio: ${removedItem.price}
                                  </Text>
                                )}
                              </View>
                            </View>
                          </View>
                        ),
                      )}
                    </>
                  )}
              </View>
            )}
          {}
          {item.type === 'item' && item.operation !== 'BATCH' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <Text
                  variant="bodySmall"
                  style={{
                    color: theme.colors.primary,
                    fontWeight: '600',
                    marginBottom: 8,
                  }}
                >
                  Nuevo item agregado:
                </Text>
              )}
              {item.operation === 'UPDATE' && item.formattedChanges && (
                <>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                    }}
                  >
                    Item modificado:
                  </Text>
                  {Object.entries(item.formattedChanges)
                    .filter(([fieldName]) => {
                      const allowedFields = [
                        'Descripción del Item',
                        'Estado',
                        'Notas de preparación',
                        'Producto',
                        'Variante',
                        'Modificadores',
                      ];
                      return allowedFields.includes(fieldName);
                    })
                    .map(([fieldName, change]) => (
                      <View key={fieldName} style={{ marginBottom: 8 }}>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.onSurfaceVariant,
                            fontWeight: '600',
                            marginBottom: 4,
                          }}
                        >
                          {fieldName}:
                        </Text>
                        {renderChangeDetail(change, fieldName)}
                      </View>
                    ))}
                </>
              )}
              {item.operation === 'DELETE' && (
                <Text
                  variant="bodySmall"
                  style={{ color: theme.colors.error, marginBottom: 8 }}
                >
                  Item eliminado:
                </Text>
              )}
              {}
              {(item.operation === 'INSERT' || item.operation === 'DELETE') &&
                item.itemDescription && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.onSurface,
                      backgroundColor: theme.colors.surface,
                      padding: 8,
                      borderRadius: 6,
                    }}
                  >
                    {item.itemDescription}
                  </Text>
                )}
            </View>
          )}
          {}
          {item.operation === 'BATCH' && item.batchOperations && (
            <View style={styles.changesContainer}>
              <Text
                variant="bodySmall"
                style={{
                  color: theme.colors.primary,
                  fontWeight: '600',
                  marginBottom: 8,
                }}
              >
                Cambios realizados en una sola edición:
              </Text>
              {item.batchOperations.map((op: any, idx: number) => (
                <View
                  key={idx}
                  style={{
                    marginBottom:
                      idx < item.batchOperations!.length - 1 ? 12 : 0,
                    paddingLeft: 8,
                    borderLeftWidth: 2,
                    borderLeftColor: theme.colors.primary + '30',
                    marginLeft: 4,
                  }}
                >
                  <View
                    style={{
                      flexDirection: 'row',
                      alignItems: 'flex-start',
                      marginBottom: 4,
                    }}
                  >
                    <Icon
                      name={getOperationIcon(op.operation)}
                      size={14}
                      color={theme.colors.primary}
                      style={{ marginRight: 6, marginTop: 2 }}
                    />
                    <View style={{ flex: 1 }}>
                      <Text
                        variant="labelSmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '500',
                          marginBottom: 4,
                        }}
                      >
                        {getOperationLabel(op.operation)}
                      </Text>
                      {}
                      {(op.itemDescription || op.snapshot?.itemDescription) && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.onSurface,
                            backgroundColor: theme.colors.surface,
                            padding: 6,
                            borderRadius: 4,
                          }}
                        >
                          {op.itemDescription || op.snapshot?.itemDescription}
                        </Text>
                      )}
                      {}
                      {op.operation === 'UPDATE' && op.formattedChanges && (
                        <View style={{ marginTop: 4 }}>
                          {Object.entries(op.formattedChanges)
                            .filter(([fieldName]) => {
                              const allowedFields = [
                                'Descripción del Item',
                                'Descripción',
                                'Estado',
                                'Notas de preparación',
                                'Producto',
                                'Variante',
                                'Modificadores',
                                'Estado de preparación',
                              ];
                              return allowedFields.includes(fieldName);
                            })
                            .map(([fieldName, change]) => (
                              <View key={fieldName} style={{ marginBottom: 4 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.onSurfaceVariant,
                                    fontWeight: '500',
                                    fontSize: 11,
                                  }}
                                >
                                  {fieldName}:
                                </Text>
                                {renderChangeDetail(change, fieldName)}
                              </View>
                            ))}
                        </View>
                      )}
                    </View>
                  </View>
                </View>
              ))}
            </View>
          )}
        </View>
      )}
    </Surface>
  );
};
export const OrderHistoryModal: React.FC<OrderHistoryModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderNumber,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const {
    data: historyData,
    isError,
    refetch,
    isLoading,
  } = useQuery({
    queryKey: ['combinedHistory', orderId],
    queryFn: async () => {
      if (!orderId) throw new Error('No order ID');
      const orderHistoryResponse = await apiClient.get(
        API_PATHS.ORDERS_HISTORY.replace(':orderId', orderId),
        {
          page: 1,
          limit: 100,
        },
      );
      const orderHistory =
        orderHistoryResponse.ok && orderHistoryResponse.data?.data
          ? orderHistoryResponse.data.data.map((item: any) => ({
              ...item,
              type: 'order' as const,
            }))
          : [];
      return orderHistory;
    },
    enabled: visible && !!orderId,
    staleTime: 30000,
  });
  useEffect(() => {
    if (visible && orderId) {
      refetch();
    }
  }, [visible, orderId, refetch]);
  const renderHistoryItem = useCallback(
    ({ item }: { item: HistoryItem }) => {
      return <HistoryItemComponent item={item} theme={theme} />;
    },
    [theme],
  );
  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Icon
        name="history"
        size={48}
        color={theme.colors.onSurfaceVariant}
        style={{ opacity: 0.5 }}
      />
      <Text
        variant="bodyLarge"
        style={{
          color: theme.colors.onSurfaceVariant,
          marginTop: theme.spacing.m,
        }}
      >
        No hay historial disponible
      </Text>
    </View>
  );
  return (
    <Modal
      visible={visible}
      onDismiss={onDismiss}
      contentContainerStyle={styles.modalContainer}
      dismissable={true}
      dismissableBackButton={false}
    >
      <View style={styles.header}>
        <View style={{ flex: 1 }}>
          <Text
            variant="titleMedium"
            style={{
              color: theme.colors.onSurface,
              fontSize: 18,
              fontWeight: '600',
            }}
            numberOfLines={1}
          >
            Historial de Orden #{orderNumber || ''}
          </Text>
          <Text
            variant="bodySmall"
            style={{
              color: theme.colors.onSurfaceVariant,
              marginTop: 2,
            }}
          >
            {historyData?.length || 0} cambios registrados
          </Text>
        </View>
        <TouchableOpacity
          onPress={onDismiss}
          style={{
            width: 44,
            height: 44,
            borderRadius: 22,
            backgroundColor: theme.colors.errorContainer,
            alignItems: 'center',
            justifyContent: 'center',
            elevation: 2,
            shadowColor: '#000',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 0.1,
            shadowRadius: 4,
          }}
          activeOpacity={0.8}
        >
          <Icon name="close" size={24} color={theme.colors.onErrorContainer} />
        </TouchableOpacity>
      </View>
      <Divider />
      <View style={{ flex: 1 }}>
        {isError ? (
          <View style={styles.emptyContainer}>
            <Icon
              name="alert-circle"
              size={48}
              color={theme.colors.error}
              style={{ opacity: 0.7 }}
            />
            <Text
              variant="bodyLarge"
              style={{
                color: theme.colors.error,
                marginTop: theme.spacing.m,
                textAlign: 'center',
              }}
            >
              Error al cargar el historial
            </Text>
            <Button
              onPress={() => refetch()}
              mode="text"
              style={{ marginTop: 16 }}
            >
              Reintentar
            </Button>
          </View>
        ) : isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando historial...</Text>
          </View>
        ) : (
          <FlatList
            data={historyData || []}
            renderItem={renderHistoryItem}
            keyExtractor={(item) => item.id.toString()}
            contentContainerStyle={styles.listContent}
            ListEmptyComponent={renderEmpty}
            showsVerticalScrollIndicator={false}
          />
        )}
      </View>
    </Modal>
  );
};
const createStyles = (theme: ReturnType<typeof useAppTheme>) => {
  return StyleSheet.create({
    modalContainer: {
      backgroundColor: theme.colors.surface,
      margin: 20,
      marginVertical: Platform.OS === 'ios' ? 60 : 40,
      borderRadius: theme.roundness * 3,
      height: '80%',
      maxHeight: 600,
      width: '90%',
      maxWidth: 500,
      alignSelf: 'center',
      elevation: 24,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 12 },
      shadowOpacity: 0.58,
      shadowRadius: 16.0,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.l,
      paddingVertical: theme.spacing.m,
      backgroundColor: theme.colors.elevation.level2,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      minHeight: 64,
    },
    scrollView: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2,
    },
    loadingContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    historyItem: {
      padding: theme.spacing.s,
      marginBottom: theme.spacing.s,
      marginHorizontal: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 2,
    },
    historyHeader: {
    },
    userInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
      minWidth: 0,
    },
    userDetails: {
      marginLeft: theme.spacing.s,
      flex: 1,
      minWidth: 0,
    },
    expandedContent: {
      marginTop: theme.spacing.m,
      backgroundColor: theme.colors.background,
      marginHorizontal: -theme.spacing.s,
      padding: theme.spacing.m,
      borderBottomLeftRadius: theme.roundness,
      borderBottomRightRadius: theme.roundness,
    },
    changesContainer: {
      paddingTop: theme.spacing.xs,
    },
    changeDetail: {
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
      marginBottom: 4,
    },
    emptyContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
  });
};
export default OrderHistoryModal;

================
File: app/src/modules/shared/components/OrderSummaryCard.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Chip, Card, Icon } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { getPaymentStatus } from '@/app/utils/orderFormatters';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { OrderTypeEnum } from '@/modules/orders/types/orders.types';
import { formatOrderTypeShort } from '@/app/utils/orderFormatters';
interface OrderSummaryCardProps {
  item: any;
  onPress: () => void;
  renderActions?: (item: any) => React.ReactNode;
  getStatusColor?: (status: string) => string;
  getStatusLabel?: (status: string) => string;
}
const OrderSummaryCard: React.FC<OrderSummaryCardProps> = ({
  item,
  onPress,
  renderActions,
  getStatusColor,
  getStatusLabel,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  let orderTitle = `#${item.shiftOrderNumber || item.orderNumber} • ${formatOrderTypeShort(item.orderType)}`;
  if (item.orderType === OrderTypeEnum.DINE_IN && item.table) {
    const tableDisplay = item.table.isTemporary
      ? item.table.name
      : `Mesa ${item.table.name || item.table.number || 'N/A'}`;
    orderTitle += ` • ${item.table.area?.name || item.area?.name || 'Sin área'} • ${tableDisplay}`;
  } else if (item.orderType === OrderTypeEnum.TAKE_AWAY) {
    if (item.deliveryInfo?.recipientName || item.deliveryInfo?.customerName) {
      orderTitle += ` • ${item.deliveryInfo.recipientName || item.deliveryInfo.customerName}`;
    }
    if (item.deliveryInfo?.recipientPhone || item.deliveryInfo?.customerPhone) {
      orderTitle += ` • ${item.deliveryInfo.recipientPhone || item.deliveryInfo.customerPhone}`;
    }
  } else if (item.orderType === OrderTypeEnum.DELIVERY) {
    if (item.deliveryInfo?.fullAddress || item.deliveryInfo?.address) {
      orderTitle += ` • ${item.deliveryInfo.fullAddress || item.deliveryInfo.address}`;
    }
    if (item.deliveryInfo?.recipientPhone || item.deliveryInfo?.customerPhone) {
      orderTitle += ` • ${item.deliveryInfo.recipientPhone || item.deliveryInfo.customerPhone}`;
    }
  }
  const totalAmount =
    typeof item.total === 'string' ? parseFloat(item.total) : item.total;
  const totalPaid =
    item.paymentsSummary?.totalPaid ||
    item.payments?.reduce((sum: number, p: any) => sum + (p.amount || 0), 0) ||
    0;
  const pendingAmount = totalAmount - totalPaid;
  const paymentStatus = getPaymentStatus(item as any);
  const paymentColor =
    paymentStatus === 'paid'
      ? '#10B981'
      : paymentStatus === 'partial'
        ? '#F59E0B'
        : '#EF4444';
  const paymentIcon =
    paymentStatus === 'paid' ? '✓' : paymentStatus === 'partial' ? '½' : '•';
  const defaultGetStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return '#4CAF50';
      case 'CANCELLED':
        return '#F44336';
      case 'IN_PROGRESS':
        return '#FF9800';
      default:
        return theme.colors.surfaceVariant;
    }
  };
  const defaultGetStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      case 'IN_PROGRESS':
        return 'En proceso';
      default:
        return status;
    }
  };
  const statusColor = getStatusColor
    ? getStatusColor(item.orderStatus)
    : defaultGetStatusColor(item.orderStatus);
  const statusLabel = getStatusLabel
    ? getStatusLabel(item.orderStatus)
    : defaultGetStatusLabel(item.orderStatus);
  return (
    <TouchableOpacity activeOpacity={0.95} onPress={onPress}>
      <Card
        style={[
          styles.orderCard,
          {
            backgroundColor: theme.colors.surface,
          },
        ]}
        mode="elevated"
      >
        <Card.Content style={styles.cardContent}>
          <View style={styles.mainContainer}>
            <View style={styles.leftContainer}>
              <Text
                style={[styles.orderNumber, { color: theme.colors.onSurface }]}
              >
                {orderTitle}
                <Text
                  style={[
                    styles.orderPrice,
                    {
                      color: pendingAmount > 0 ? theme.colors.error : '#10B981',
                    },
                  ]}
                >
                  {' • '}
                  {pendingAmount > 0
                    ? `Por pagar: $${pendingAmount.toFixed(2)}`
                    : `Pagado: $${totalAmount.toFixed(2)}`}
                </Text>
                {item.notes && (
                  <Text
                    style={[
                      styles.notesInline,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                    numberOfLines={1}
                  >
                    {' • '}
                    {item.notes}
                  </Text>
                )}
              </Text>
              <View style={styles.timeAndPaymentRow}>
                <Text
                  style={[styles.orderTime, { color: theme.colors.primary }]}
                >
                  {format(new Date(item.createdAt), 'p', { locale: es })}
                </Text>
                {}
                <View
                  style={[
                    styles.miniPaymentBadge,
                    { backgroundColor: paymentColor },
                  ]}
                >
                  <Text style={styles.miniPaymentText}>{paymentIcon}</Text>
                </View>
                {}
                {item.isFromWhatsApp && (
                  <View
                    style={[
                      styles.inlinePreparationBadge,
                      {
                        backgroundColor: '#25D366',
                        borderColor: '#25D366',
                      },
                    ]}
                  >
                    <Icon source="whatsapp" size={12} color="#FFFFFF" />
                  </View>
                )}
                {}
                {item.preparationScreenStatuses &&
                  item.preparationScreenStatuses.length > 0 && (
                    <>
                      {item.preparationScreenStatuses.map(
                        (screen: any, index: number) => {
                          const backgroundColor =
                            screen.status === 'READY'
                              ? '#4CAF50'
                              : screen.status === 'IN_PROGRESS'
                                ? '#FFA000'
                                : theme.colors.surfaceVariant;
                          const textColor =
                            screen.status === 'READY' ||
                            screen.status === 'IN_PROGRESS'
                              ? '#FFFFFF'
                              : theme.colors.onSurfaceVariant;
                          return (
                            <View
                              key={`${item.id}-screen-${index}`}
                              style={[
                                styles.inlinePreparationBadge,
                                {
                                  backgroundColor,
                                  borderColor:
                                    backgroundColor ===
                                    theme.colors.surfaceVariant
                                      ? theme.colors.outline
                                      : backgroundColor,
                                },
                              ]}
                            >
                              <Text
                                style={[
                                  styles.inlinePreparationText,
                                  { color: textColor },
                                ]}
                              >
                                {screen.status === 'READY'
                                  ? '✓ '
                                  : screen.status === 'IN_PROGRESS'
                                    ? '⏳'
                                    : ''}
                                🍳 {screen.name}
                              </Text>
                            </View>
                          );
                        },
                      )}
                    </>
                  )}
              </View>
            </View>
            <View style={styles.rightContainer}>
              {item.createdBy && (
                <Text style={styles.createdByText} numberOfLines={1}>
                  {item.createdBy.firstName && item.createdBy.lastName
                    ? `${item.createdBy.firstName} ${item.createdBy.lastName}`
                    : item.createdBy.username}
                </Text>
              )}
              <Chip
                mode="flat"
                compact
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: statusColor,
                  },
                ]}
                textStyle={styles.statusChipText}
              >
                {statusLabel}
              </Chip>
              {/* Contenedor de acciones personalizables */}
              {renderActions && (
                <View style={styles.actionsContainer}>
                  {renderActions(item)}
                </View>
              )}
            </View>
          </View>
        </Card.Content>
      </Card>
    </TouchableOpacity>
  );
};
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      marginRight: 12,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minHeight: 60,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: '600',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 14,
      fontWeight: '500',
    },
    notesInline: {
      fontSize: 13,
      fontStyle: 'italic',
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
      flexWrap: 'wrap',
    },
    orderTime: {
      fontSize: 13,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: 16,
      height: 16,
      borderRadius: 8,
      justifyContent: 'center',
      alignItems: 'center',
    },
    miniPaymentText: {
      color: '#FFFFFF',
      fontSize: 10,
      fontWeight: 'bold',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 1,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    createdByText: {
      fontSize: 12,
      color: '#666',
      marginBottom: 4,
      maxWidth: 120,
    },
    statusChip: {
      marginBottom: 8,
    },
    statusChipText: {
      fontSize: 11,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    actionsContainer: {
      alignItems: 'center',
    },
  });
export default OrderSummaryCard;

================
File: app/src/modules/sync/navigation/SyncStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { SyncStatusScreen } from '../screens/SyncStatusScreen';
export type SyncStackParamList = {
  SyncStatus: undefined;
};
const Stack = createNativeStackNavigator<SyncStackParamList>();
export const SyncStackNavigator: React.FC = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="SyncStatus"
        component={SyncStatusScreen}
        options={{ title: 'Estado de Sincronización' }}
      />
    </Stack.Navigator>
  );
};

================
File: backend/.cloudflared/config.yml
================
tunnel: d4a06053-91ba-414e-a0fd-310377381098
credentials-file: C:\Users\Leonel\.cloudflared\d4a06053-91ba-414e-a0fd-310377381098.json
ingress:
  - hostname: api.pizzatototlan.store
    service: http://localhost:3737
    originRequest:
      noTLSVerify: true
  - service: http_status:404

================
File: backend/.env.example
================
NODE_ENV=development
APP_PORT=3737
APP_NAME="NestJS API"
API_PREFIX=api
APP_FALLBACK_LANGUAGE=en
APP_HEADER_LANGUAGE=x-custom-lang
FRONTEND_DOMAIN=http://localhost:3737
BACKEND_DOMAIN=http://localhost:3737

# Database
DATABASE_TYPE=postgres
DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_USERNAME=root
DATABASE_PASSWORD=secret
DATABASE_NAME=api
DATABASE_SYNCHRONIZE=false
DATABASE_MAX_CONNECTIONS=100
DATABASE_SSL_ENABLED=false
DATABASE_REJECT_UNAUTHORIZED=false
DATABASE_CA=
DATABASE_KEY=
DATABASE_CERT=
DATABASE_URL=


# File storage - Support "local", "s3", "s3-presigned"
FILE_DRIVER=local
ACCESS_KEY_ID=
SECRET_ACCESS_KEY=
AWS_S3_REGION=
AWS_DEFAULT_S3_BUCKET=

# Mail
MAIL_HOST=localhost
MAIL_PORT=1025
MAIL_USER=
MAIL_PASSWORD=
MAIL_IGNORE_TLS=true
MAIL_SECURE=false
MAIL_REQUIRE_TLS=false
MAIL_DEFAULT_EMAIL=noreply@example.com
MAIL_DEFAULT_NAME=Api
MAIL_CLIENT_PORT=1080

# Auth secrets - IMPORTANT: Change these in production!
AUTH_JWT_SECRET=CHANGE_THIS_SECRET_IN_PRODUCTION
AUTH_JWT_TOKEN_EXPIRES_IN=15m
AUTH_REFRESH_SECRET=CHANGE_THIS_REFRESH_SECRET_IN_PRODUCTION
AUTH_REFRESH_TOKEN_EXPIRES_IN=3650d
AUTH_FORGOT_SECRET=CHANGE_THIS_FORGOT_SECRET_IN_PRODUCTION
AUTH_FORGOT_TOKEN_EXPIRES_IN=30m
AUTH_CONFIRM_EMAIL_SECRET=CHANGE_THIS_CONFIRM_SECRET_IN_PRODUCTION
AUTH_CONFIRM_EMAIL_TOKEN_EXPIRES_IN=1d

# Worker (if using Redis)
WORKER_HOST=redis://localhost:6379/1

# Sync Configuration
SYNC_ENABLED=false
REMOTE_API_URL=
CLOUD_API_KEY=
SYNC_INTERVAL_MINUTES=5
SYNC_WEBSOCKET_ENABLED=false

GOOGLE_MAPS_API_KEY=AI............

================
File: backend/docs/CLOUDFLARE_TUNNEL_SETUP.md
================
# Configuración de Cloudflare Tunnel para CloudBite

Esta guía te ayudará a configurar Cloudflare Tunnel para acceder a tu restaurante desde cualquier lugar con internet.

## ¿Qué es Cloudflare Tunnel?

Cloudflare Tunnel crea una conexión segura entre tu servidor local y la red de Cloudflare, permitiendo:
- ✅ Acceso remoto sin abrir puertos en tu router
- ✅ HTTPS automático con certificados SSL
- ✅ Protección contra ataques DDoS
- ✅ Sin necesidad de IP estática
- ✅ **GRATIS** para hasta 50 usuarios

## Requisitos Previos

1. **Cuenta de Cloudflare** (gratis en [cloudflare.com](https://cloudflare.com))
2. **Un dominio** agregado a Cloudflare (puede ser uno gratuito de Freenom)
3. **Backend de CloudBite funcionando** en el puerto 3737

## Instalación Rápida

### Opción 1: Script Automático (Recomendado)

```bash
cd backend
npm run setup:cloudflare-tunnel
```

Este script:
- Verifica la instalación de cloudflared
- Te guía paso a paso por la configuración
- Crea los archivos necesarios automáticamente
- Configura el dominio en Cloudflare

### Opción 2: Instalación Manual

#### Paso 1: Instalar cloudflared

**Windows:**
```bash
winget install Cloudflare.cloudflared
# o descarga desde: https://github.com/cloudflare/cloudflared/releases
```

**macOS:**
```bash
brew install cloudflared
```

**Linux:**
```bash
# Debian/Ubuntu
curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb -o cloudflared.deb
sudo dpkg -i cloudflared.deb

# Otros Linux
curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o /usr/local/bin/cloudflared
chmod +x /usr/local/bin/cloudflared
```

#### Paso 2: Autenticarse con Cloudflare

```bash
cloudflared tunnel login
```

Esto abrirá tu navegador para iniciar sesión en Cloudflare.

#### Paso 3: Crear el Túnel

```bash
cloudflared tunnel create cloudbite-restaurante
```

#### Paso 4: Configurar el Túnel

Crea el archivo `backend/.cloudflared/config.yml`:

```yaml
tunnel: [TU-TUNNEL-ID]
credentials-file: ~/.cloudflared/[TU-TUNNEL-ID].json

ingress:
  - hostname: api.tu-restaurante.com
    service: http://localhost:3737
    originRequest:
      noTLSVerify: true
  - service: http_status:404
```

#### Paso 5: Configurar DNS

```bash
cloudflared tunnel route dns cloudbite-restaurante api.tu-restaurante.com
```

#### Paso 6: Actualizar Variables de Entorno

Agrega a tu archivo `.env`:

```env
# Cloudflare Tunnel Configuration
REMOTE_URL=https://api.tu-restaurante.com
TUNNEL_NAME=cloudbite-restaurante
```

## Uso Diario

### Iniciar el Servidor con Túnel

**Windows:**
```bash
cd backend
.\scripts\start-with-tunnel.bat
```

**Linux/macOS:**
```bash
cd backend
./scripts/start-with-tunnel.sh
```

### Verificar Funcionamiento

1. **Local**: http://localhost:3737/api/v1/discovery
2. **Remoto**: https://api.tu-restaurante.com/api/v1/discovery

Deberías ver:
```json
{
  "type": "cloudbite-api",
  "name": "CloudBite Restaurant API",
  "remoteUrl": "https://api.tu-restaurante.com",
  "tunnelEnabled": true
}
```

## Configuración en la App

La app detectará automáticamente la URL remota cuando:

1. **Red Local**: Usará auto-descubrimiento (sin cambios)
2. **Fuera de la Red**: 
   - Detectará que el servidor local no está disponible
   - Mostrará la opción de usar el servidor remoto
   - Se conectará automáticamente a la URL de Cloudflare

### Configuración Manual (si es necesario)

1. Abre el menú lateral (hamburguesa)
2. Ve a "Configuración del Servidor"
3. Selecciona "Remoto (Internet)"
4. La app usará automáticamente la URL configurada

## Solución de Problemas

### El túnel no se conecta

```bash
# Verificar logs
cloudflared tunnel run cloudbite-restaurante --loglevel debug

# Verificar configuración
cloudflared tunnel list
cloudflared tunnel info cloudbite-restaurante
```

### La app no encuentra el servidor remoto

1. Verifica que el backend tenga `REMOTE_URL` en `.env`
2. Reinicia el backend después de cambiar `.env`
3. Verifica que el endpoint discovery responda con `remoteUrl`

### Error de certificado SSL

Si ves errores de certificado:
1. Asegúrate de usar `https://` en la URL
2. Verifica que el dominio esté activo en Cloudflare
3. Espera 5-10 minutos para propagación DNS

## Seguridad

### Proteger el Acceso (Opcional)

Para agregar autenticación adicional:

1. Ve a [Cloudflare Zero Trust](https://one.dash.cloudflare.com/)
2. Access > Applications > Add application
3. Configura reglas de acceso (email, IP, etc.)

### Mejores Prácticas

- ✅ Usa siempre HTTPS para conexiones remotas
- ✅ Mantén actualizado cloudflared
- ✅ Monitorea los logs de acceso
- ✅ Considera usar Cloudflare Access para autenticación extra
- ❌ No expongas puertos directamente en tu router
- ❌ No compartas las credenciales del túnel

## Comandos Útiles

```bash
# Ver estado del túnel
cloudflared tunnel info cloudbite-restaurante

# Ver métricas
cloudflared tunnel metrics cloudbite-restaurante

# Detener túnel
cloudflared tunnel cleanup cloudbite-restaurante

# Eliminar túnel
cloudflared tunnel delete cloudbite-restaurante
```

## Automatización con Systemd (Linux)

Para ejecutar automáticamente al iniciar el sistema:

```bash
sudo cloudflared service install
sudo systemctl start cloudflared
sudo systemctl enable cloudflared
```

## Costos

- **Gratis**: Hasta 50 usuarios simultáneos
- **Pago**: $7/usuario/mes para más de 50 usuarios
- **Sin límites** de ancho de banda o solicitudes

## Soporte

- [Documentación Cloudflare Tunnel](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/)
- [CloudBite Issues](https://github.com/tu-usuario/cloudbite/issues)
- [Cloudflare Community](https://community.cloudflare.com/)

================
File: backend/scripts/drop-all-tables.ts
================
import { AppDataSource } from '../src/database/data-source';
async function dropAllTables() {
  try {
    console.log('🔄 Iniciando eliminación completa de todas las tablas...');
    await AppDataSource.initialize();
    console.log('✅ Conexión establecida');
    await AppDataSource.query('SET session_replication_role = replica;');
    const tables = await AppDataSource.query(`
      SELECT tablename
      FROM pg_tables
      WHERE schemaname = 'public'
    `);
    console.log(`📊 Se encontraron ${tables.length} tablas`);
    for (const table of tables) {
      console.log(`🗑️  Eliminando tabla: ${table.tablename}`);
      await AppDataSource.query(`DROP TABLE IF EXISTS "${table.tablename}" CASCADE`);
    }
    const enums = await AppDataSource.query(`
      SELECT n.nspname, t.typname
      FROM pg_type t
      JOIN pg_namespace n ON n.oid = t.typnamespace
      WHERE t.typtype = 'e' AND n.nspname = 'public'
    `);
    console.log(`📊 Se encontraron ${enums.length} tipos ENUM`);
    for (const enumType of enums) {
      console.log(`🗑️  Eliminando tipo: ${enumType.typname}`);
      await AppDataSource.query(`DROP TYPE IF EXISTS "${enumType.typname}" CASCADE`);
    }
    await AppDataSource.query('SET session_replication_role = DEFAULT;');
    await AppDataSource.destroy();
    console.log('✅ Conexión cerrada');
    console.log('🎉 Todas las tablas y tipos han sido eliminados!');
    console.log('📝 La base de datos está completamente vacía.');
    console.log('📝 Ahora puedes ejecutar: npm run migration:run');
  } catch (error) {
    console.error('❌ Error durante la eliminación:', error);
    process.exit(1);
  }
}
if (require.main === module) {
  dropAllTables();
}

================
File: backend/scripts/run-migrations.ts
================
import { AppDataSource } from '../src/database/data-source';
async function runMigrations() {
  try {
    console.log('🔄 Ejecutando migraciones...');
    await AppDataSource.initialize();
    console.log('✅ Conexión establecida');
    const migrations = await AppDataSource.runMigrations();
    if (migrations.length === 0) {
      console.log('✅ No hay migraciones pendientes');
    } else {
      console.log(`✅ Se ejecutaron ${migrations.length} migraciones:`);
      migrations.forEach(migration => {
        console.log(`   - ${migration.name}`);
      });
    }
    await AppDataSource.destroy();
    console.log('✅ Conexión cerrada');
    console.log('🎉 Migraciones completadas exitosamente!');
  } catch (error) {
    console.error('❌ Error durante las migraciones:', error);
    process.exit(1);
  }
}
if (require.main === module) {
  runMigrations();
}

================
File: backend/scripts/setup-cloudflare-tunnel.js
================
#!/usr/bin/env node
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
const question = (query) => new Promise(resolve => rl.question(query, resolve));
async function setupCloudfareTunnel() {
  console.log('🚀 Configuración de Cloudflare Tunnel para CloudBite\n');
  try {
    try {
      execSync('cloudflared --version', { stdio: 'ignore' });
      console.log('✅ cloudflared está instalado');
    } catch {
      console.log('❌ cloudflared no está instalado');
      console.log('\nPara instalar cloudflared:');
      console.log('- Windows: winget install Cloudflare.cloudflared');
      console.log('- macOS: brew install cloudflared');
      console.log('- Linux: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/\n');
      process.exit(1);
    }
    const tunnelConfigPath = path.join(__dirname, '..', '.cloudflared', 'config.yml');
    if (fs.existsSync(tunnelConfigPath)) {
      const overwrite = await question('Ya existe una configuración de túnel. ¿Deseas sobrescribirla? (s/n): ');
      if (overwrite.toLowerCase() !== 's') {
        console.log('Configuración cancelada.');
        process.exit(0);
      }
    }
    console.log('\n📝 Autenticándose con Cloudflare...');
    console.log('Se abrirá tu navegador para iniciar sesión.');
    execSync('cloudflared tunnel login', { stdio: 'inherit' });
    const tunnelName = await question('\nNombre del túnel (ej: cloudbite-prod): ') || 'cloudbite';
    console.log(`\n🔧 Creando túnel "${tunnelName}"...`);
    try {
      execSync(`cloudflared tunnel create ${tunnelName}`, { stdio: 'inherit' });
    } catch (error) {
      if (error.message.includes('already exists')) {
        console.log('El túnel ya existe, continuando con la configuración...');
      } else {
        throw error;
      }
    }
    const tunnelList = execSync('cloudflared tunnel list --output json').toString();
    const tunnels = JSON.parse(tunnelList);
    const tunnel = tunnels.find(t => t.name === tunnelName);
    if (!tunnel) {
      throw new Error('No se pudo encontrar el túnel creado');
    }
    const domain = await question('\nDominio de Cloudflare (ej: ejemplo.com): ');
    const subdomain = await question('Subdominio (ej: api, dejar vacío para usar dominio raíz): ');
    const fullDomain = subdomain ? `${subdomain}.${domain}` : domain;
    const config = {
      tunnel: tunnel.id,
      credentials_file: path.join('~', '.cloudflared', `${tunnel.id}.json`),
      ingress: [
        {
          hostname: fullDomain,
          service: 'http://localhost:3737',
          originRequest: {
            noTLSVerify: true
          }
        },
        {
          service: 'http_status:404'
        }
      ]
    };
    const configDir = path.join(__dirname, '..', '.cloudflared');
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    fs.writeFileSync(
      tunnelConfigPath,
      `# Configuración generada automáticamente para CloudBite\n` +
      `tunnel: ${config.tunnel}\n` +
      `credentials-file: ${config.credentials_file}\n\n` +
      `ingress:\n` +
      `  - hostname: ${fullDomain}\n` +
      `    service: http://localhost:3737\n` +
      `    originRequest:\n` +
      `      noTLSVerify: true\n` +
      `  - service: http_status:404\n`
    );
    console.log(`\n🌐 Configurando DNS para ${fullDomain}...`);
    execSync(`cloudflared tunnel route dns ${tunnelName} ${fullDomain}`, { stdio: 'inherit' });
    const startScript = `#!/bin/bash
# Script para iniciar CloudBite con Cloudflare Tunnel
echo "🚀 Iniciando CloudBite Backend..."
npm run start:prod &
BACKEND_PID=$!
echo "🔧 Esperando a que el backend esté listo..."
sleep 5
echo "🌐 Iniciando Cloudflare Tunnel..."
cloudflared tunnel run ${tunnelName}
# Cleanup
kill $BACKEND_PID
`;
    fs.writeFileSync(
      path.join(__dirname, 'start-with-tunnel.sh'),
      startScript,
      { mode: 0o755 }
    );
    const startScriptWin = `@echo off
echo 🚀 Iniciando CloudBite Backend...
start /b npm run start:prod
echo 🔧 Esperando a que el backend esté listo...
timeout /t 5 /nobreak > nul
echo 🌐 Iniciando Cloudflare Tunnel...
cloudflared tunnel run ${tunnelName}
`;
    fs.writeFileSync(
      path.join(__dirname, 'start-with-tunnel.bat'),
      startScriptWin
    );
    const envPath = path.join(__dirname, '..', '.env');
    let envContent = '';
    if (fs.existsSync(envPath)) {
      envContent = fs.readFileSync(envPath, 'utf8');
    }
    if (!envContent.includes('REMOTE_URL')) {
      envContent += `\n# Cloudflare Tunnel Configuration\n`;
      envContent += `REMOTE_URL=https://${fullDomain}\n`;
      envContent += `TUNNEL_NAME=${tunnelName}\n`;
      fs.writeFileSync(envPath, envContent);
    }
    console.log('\n✅ Configuración completada exitosamente!\n');
    console.log('📋 Resumen:');
    console.log(`- Túnel: ${tunnelName}`);
    console.log(`- URL Local: http://localhost:3737`);
    console.log(`- URL Remota: https://${fullDomain}`);
    console.log(`- Configuración: ${tunnelConfigPath}`);
    console.log('\n🚀 Para iniciar el servidor con el túnel:');
    console.log(`- Linux/Mac: ./scripts/start-with-tunnel.sh`);
    console.log(`- Windows: .\\scripts\\start-with-tunnel.bat`);
    console.log('\n💡 La app detectará automáticamente si usar conexión local o remota.');
  } catch (error) {
    console.error('\n❌ Error durante la configuración:', error.message);
    process.exit(1);
  } finally {
    rl.close();
  }
}
setupCloudfareTunnel();

================
File: backend/scripts/start-with-tunnel.bat
================
@echo off
echo ====================================
echo   CloudBite con Cloudflare Tunnel
echo ====================================

REM Verificar si existe la carpeta dist
if not exist "dist" (
    echo [!] La aplicacion no esta compilada. Compilando...
    call npm run build
    echo.
)

echo [1] Iniciando CloudBite Backend...
start /b node dist/src/main.js

echo [2] Esperando a que el backend este listo...
timeout /t 8 /nobreak > nul

echo [3] Iniciando Cloudflare Tunnel...
cloudflared tunnel --config .cloudflared\config.yml run cloudbite-prod

================
File: backend/src/adjustments/adjustments.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  HttpStatus,
  HttpCode,
  NotFoundException,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
} from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { AdjustmentsService } from './adjustments.service';
import { CreateAdjustmentDto } from './dto/create-adjustment.dto';
import { UpdateAdjustmentDto } from './dto/update-adjustment.dto';
import { Adjustment } from './domain/adjustment';
@ApiTags('Adjustments')
@Controller({
  path: 'adjustments',
  version: '1',
})
@UseGuards(AuthGuard('jwt'), RolesGuard)
@ApiBearerAuth()
export class AdjustmentsController {
  constructor(private readonly adjustmentsService: AdjustmentsService) {}
  @Post('bulk')
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier)
  @ApiOperation({ summary: 'Apply multiple adjustments' })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'Adjustments created successfully',
    type: [Adjustment],
  })
  async createBulk(
    @Body() createAdjustmentDtos: CreateAdjustmentDto[],
  ): Promise<Adjustment[]> {
    return this.adjustmentsService.applyBulkAdjustments(createAdjustmentDtos);
  }
  @Get('order/:orderId')
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier)
  @ApiOperation({ summary: 'Get adjustments for a specific order' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'List of order adjustments',
    type: [Adjustment],
  })
  async findByOrder(@Param('orderId') orderId: string): Promise<Adjustment[]> {
    return this.adjustmentsService.findByOrderId(orderId);
  }
  @Get('order-item/:orderItemId')
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier)
  @ApiOperation({ summary: 'Get adjustments for a specific order item' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'List of order item adjustments',
    type: [Adjustment],
  })
  async findByOrderItem(
    @Param('orderItemId') orderItemId: string,
  ): Promise<Adjustment[]> {
    return this.adjustmentsService.findByOrderItemId(orderItemId);
  }
  @Patch(':id')
  @Roles(RoleEnum.admin)
  @ApiOperation({ summary: 'Update an adjustment' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Adjustment updated successfully',
    type: Adjustment,
  })
  async update(
    @Param('id') id: string,
    @Body() updateAdjustmentDto: UpdateAdjustmentDto,
  ): Promise<Adjustment> {
    const result = await this.adjustmentsService.update(
      id,
      updateAdjustmentDto,
    );
    if (!result) {
      throw new NotFoundException(`Adjustment with ID ${id} not found`);
    }
    return result;
  }
  @Delete(':id')
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete an adjustment' })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'Adjustment deleted successfully',
  })
  async remove(@Param('id') id: string): Promise<void> {
    await this.adjustmentsService.remove(id);
  }
}

================
File: backend/src/areas/areas.service.ts
================
import { Injectable, Inject } from '@nestjs/common';
import { Area } from './domain/area';
import { CreateAreaDto } from './dto/create-area.dto';
import { FindAllAreasDto } from './dto/find-all-areas.dto';
import { UpdateAreaDto } from './dto/update-area.dto';
import { AreaRepository } from './infrastructure/persistence/area.repository';
import { AREA_REPOSITORY } from '../common/tokens';
import { BaseCrudService } from '../common/application/base-crud.service';
import { Paginated } from '../common/types/paginated.type';
@Injectable()
export class AreasService extends BaseCrudService<
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  FindAllAreasDto
> {
  constructor(
    @Inject(AREA_REPOSITORY) protected readonly repo: AreaRepository,
  ) {
    super(repo);
  }
  async findAllPaginated(filter?: FindAllAreasDto): Promise<Paginated<Area>> {
    const page = filter?.page || 1;
    const limit = filter?.limit || 10;
    const allItems = await this.findAll(filter);
    return new Paginated(allItems, allItems.length, page, limit);
  }
}

================
File: backend/src/audio-order-processing/audio-order-processing.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { HttpModule } from '@nestjs/axios';
import { AudioOrderProcessingController } from './controllers/audio-order-processing.controller';
import { AudioOrderProcessingService } from './services/audio-order-processing.service';
import audioOrderConfig from './config/audio-order.config';
@Module({
  imports: [
    ConfigModule.forFeature(audioOrderConfig),
    HttpModule.register({
      timeout: 300000,
      maxRedirects: 5,
    }),
  ],
  controllers: [AudioOrderProcessingController],
  providers: [AudioOrderProcessingService],
  exports: [AudioOrderProcessingService],
})
export class AudioOrderProcessingModule {}

================
File: backend/src/audio-order-processing/controllers/audio-order-processing.controller.ts
================
import {
  Controller,
  Post,
  Get,
  Body,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
} from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { AudioOrderProcessingService } from '../services/audio-order-processing.service';
import {
  ProcessAudioOrderDto,
  AudioOrderResponseDto,
} from '../dto/process-audio-order.dto';
@ApiTags('Audio Orders')
@Controller({
  path: 'audio-orders',
  version: '1',
})
@UseGuards(AuthGuard('jwt'))
@ApiBearerAuth()
export class AudioOrderProcessingController {
  constructor(
    private readonly audioOrderProcessingService: AudioOrderProcessingService,
  ) {}
  @Post('process')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Process audio order',
    description:
      'Processes an audio recording with its transcription to create or modify orders',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Audio processed successfully',
    type: AudioOrderResponseDto,
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Invalid audio data or processing error',
  })
  @ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'Unauthorized',
  })
  async processAudioOrder(
    @Body() dto: ProcessAudioOrderDto,
  ): Promise<AudioOrderResponseDto> {
    return this.audioOrderProcessingService.processAudioOrder(dto);
  }
  @Get('health')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Check audio service availability',
    description:
      'Verifies if the audio processing service is available and can connect to the remote AI service',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Service is available',
    schema: {
      type: 'object',
      properties: {
        status: { type: 'string', example: 'ok' },
        available: { type: 'boolean', example: true },
        message: {
          type: 'string',
          example: 'Audio processing service is available',
        },
        timestamp: { type: 'string', example: '2024-01-20T12:00:00Z' },
      },
    },
  })
  @ApiResponse({
    status: HttpStatus.SERVICE_UNAVAILABLE,
    description: 'Service is not available',
    schema: {
      type: 'object',
      properties: {
        status: { type: 'string', example: 'error' },
        available: { type: 'boolean', example: false },
        message: {
          type: 'string',
          example: 'Cannot connect to audio processing service',
        },
        timestamp: { type: 'string', example: '2024-01-20T12:00:00Z' },
      },
    },
  })
  async checkHealth(): Promise<{
    status: string;
    available: boolean;
    message: string;
    timestamp: string;
  }> {
    return this.audioOrderProcessingService.checkServiceHealth();
  }
}

================
File: backend/src/auth/auth.service.ts
================
import {
  Injectable,
  NotFoundException,
  UnauthorizedException,
  UnprocessableEntityException,
} from '@nestjs/common';
import ms from 'ms';
import crypto from 'crypto';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { JwtService } from '@nestjs/jwt';
import bcrypt from 'bcryptjs';
import { AuthEmailLoginDto } from './dto/auth-email-login.dto';
import { AuthUpdateDto } from './dto/auth-update.dto';
import { AuthRegisterLoginDto } from './dto/auth-register-login.dto';
import { NullableType } from '../utils/types/nullable.type';
import { LoginResponseDto } from './dto/login-response.dto';
import { ConfigService } from '@nestjs/config';
import { JwtRefreshPayloadType } from './strategies/types/jwt-refresh-payload.type';
import { JwtPayloadType } from './strategies/types/jwt-payload.type';
import { UsersService } from '../users/users.service';
import { AllConfigType } from '../config/config.type';
import { MailService } from '../mail/mail.service';
import { RoleEnum } from '../roles/roles.enum';
import { Session } from '../session/domain/session';
import { SessionService } from '../session/session.service';
import { User } from '../users/domain/user';
import { ERROR_CODES } from '../common/constants/error-codes.constants';
@Injectable()
export class AuthService {
  constructor(
    private jwtService: JwtService,
    private usersService: UsersService,
    private sessionService: SessionService,
    private mailService: MailService,
    private configService: ConfigService<AllConfigType>,
  ) {}
  async validateLogin(loginDto: AuthEmailLoginDto): Promise<LoginResponseDto> {
    let user: NullableType<User> = null;
    if (loginDto.username) {
      user = await this.usersService.findByUsername(loginDto.username);
    }
    if (!user && loginDto.email) {
      user = await this.usersService.findByEmail(loginDto.email);
    }
    if (!user) {
      throw new UnprocessableEntityException({
        code: ERROR_CODES.AUTH_INVALID_CREDENTIALS,
        message: 'Usuario o contraseña incorrectos.',
      });
    }
    if (!user.password) {
      throw new UnprocessableEntityException({
        code: ERROR_CODES.AUTH_ACCOUNT_INACTIVE,
        message: 'La cuenta no tiene una contraseña configurada.',
      });
    }
    const isValidPassword = await bcrypt.compare(
      loginDto.password,
      user.password,
    );
    if (!isValidPassword) {
      throw new UnprocessableEntityException({
        code: ERROR_CODES.AUTH_INCORRECT_PASSWORD,
        message: 'La contraseña es incorrecta.',
      });
    }
    const hash = crypto
      .createHash('sha256')
      .update(randomStringGenerator())
      .digest('hex');
    const session = await this.sessionService.create({
      user,
      hash,
    });
    const { token, refreshToken, tokenExpires } = await this.getTokensData({
      id: user.id,
      role: user.role,
      sessionId: session.id,
      hash,
    });
    return {
      refreshToken,
      token,
      tokenExpires,
      user,
    };
  }
  async register(dto: AuthRegisterLoginDto): Promise<void> {
    const requiresConfirmation = !!dto.email;
    const initialIsActive = !requiresConfirmation;
    const user = await this.usersService.create({
      ...dto,
      email: dto.email,
      role: {
        id: RoleEnum.waiter,
      },
      isActive: initialIsActive,
    });
    if (requiresConfirmation) {
      const hash = await this.jwtService.signAsync(
        {
          confirmEmailUserId: user.id,
        },
        {
          secret: this.configService.get('auth.confirmEmailSecret', {
            infer: true,
          }),
          expiresIn: this.configService.get('auth.confirmEmailExpires', {
            infer: true,
          }),
        },
      );
      await this.mailService.userSignUp({
        to: dto.email!,
        data: {
          hash,
        },
      });
    }
  }
  async confirmEmail(hash: string): Promise<void> {
    let userId: User['id'];
    try {
      const jwtData = await this.jwtService.verifyAsync<{
        confirmEmailUserId: User['id'];
      }>(hash, {
        secret: this.configService.getOrThrow('auth.confirmEmailSecret', {
          infer: true,
        }),
      });
      userId = jwtData.confirmEmailUserId;
    } catch {
      throw new UnprocessableEntityException({
        code: ERROR_CODES.AUTH_INVALID_HASH,
        message: 'El enlace de confirmación es inválido o ha expirado.',
      });
    }
    const user = await this.usersService.findById(userId);
    if (!user) {
      throw new NotFoundException({
        code: ERROR_CODES.USER_NOT_FOUND,
        message: 'Usuario no encontrado.',
      });
    }
    if (user.isActive) {
      return;
    }
    await this.usersService.update(user.id, { isActive: true });
  }
  async confirmNewEmail(hash: string): Promise<void> {
    let userId: User['id'];
    let newEmail: User['email'];
    try {
      const jwtData = await this.jwtService.verifyAsync<{
        confirmEmailUserId: User['id'];
        newEmail: User['email'];
      }>(hash, {
        secret: this.configService.getOrThrow('auth.confirmEmailSecret', {
          infer: true,
        }),
      });
      userId = jwtData.confirmEmailUserId;
      newEmail = jwtData.newEmail;
    } catch {
      throw new UnprocessableEntityException({
        code: ERROR_CODES.AUTH_INVALID_HASH,
        message:
          'El enlace de confirmación de nuevo correo es inválido o ha expirado.',
      });
    }
    const user = await this.usersService.findById(userId);
    if (!user) {
      throw new NotFoundException({
        code: ERROR_CODES.USER_NOT_FOUND,
        message: 'Usuario asociado al enlace no encontrado.',
      });
    }
    await this.usersService.update(user.id, {
      email: newEmail,
      isActive: true,
    });
  }
  async forgotPassword(email: string): Promise<void> {
    const user = await this.usersService.findByEmail(email);
    if (!user) {
      throw new NotFoundException({
        code: ERROR_CODES.USER_NOT_FOUND,
        message: 'No se encontró un usuario con ese correo electrónico.',
      });
    }
    const tokenExpiresIn = this.configService.getOrThrow('auth.forgotExpires', {
      infer: true,
    });
    const tokenExpires = Date.now() + ms(tokenExpiresIn);
    const hash = await this.jwtService.signAsync(
      {
        forgotUserId: user.id,
      },
      {
        secret: this.configService.getOrThrow('auth.forgotSecret', {
          infer: true,
        }),
        expiresIn: tokenExpiresIn,
      },
    );
    await this.mailService.forgotPassword({
      to: email,
      data: {
        hash,
        tokenExpires,
      },
    });
  }
  async resetPassword(hash: string, password: string): Promise<void> {
    let userId: User['id'];
    try {
      const jwtData = await this.jwtService.verifyAsync<{
        forgotUserId: User['id'];
      }>(hash, {
        secret: this.configService.getOrThrow('auth.forgotSecret', {
          infer: true,
        }),
      });
      userId = jwtData.forgotUserId;
    } catch {
      throw new UnprocessableEntityException({
        code: ERROR_CODES.AUTH_INVALID_HASH,
        message:
          'El enlace para restablecer la contraseña es inválido o ha expirado.',
      });
    }
    const user = await this.usersService.findById(userId);
    if (!user) {
      throw new NotFoundException({
        code: ERROR_CODES.USER_NOT_FOUND,
        message: 'Usuario asociado al enlace no encontrado.',
      });
    }
    user.password = password;
    await this.sessionService.deleteByUserId({
      userId: user.id,
    });
    await this.usersService.update(user.id, user);
  }
  async me(userJwtPayload: JwtPayloadType): Promise<NullableType<User>> {
    return this.usersService.findById(userJwtPayload.id);
  }
  async update(
    userJwtPayload: JwtPayloadType,
    userDto: AuthUpdateDto,
  ): Promise<NullableType<User>> {
    const currentUser = await this.usersService.findById(userJwtPayload.id);
    if (!currentUser) {
      throw new NotFoundException({
        code: ERROR_CODES.USER_NOT_FOUND,
        message: 'Usuario actual no encontrado.',
      });
    }
    const userToUpdate = { ...currentUser };
    if (userDto.firstName !== undefined)
      userToUpdate.firstName = userDto.firstName;
    if (userDto.lastName !== undefined)
      userToUpdate.lastName = userDto.lastName;
    if (userDto.email !== undefined) userToUpdate.email = userDto.email;
    if (userDto.password !== undefined)
      userToUpdate.password = userDto.password;
    if (userDto.birthDate !== undefined)
      userToUpdate.birthDate = userDto.birthDate ? userDto.birthDate : null;
    if (userDto.gender !== undefined) userToUpdate.gender = userDto.gender;
    if (userDto.phoneNumber !== undefined)
      userToUpdate.phoneNumber = userDto.phoneNumber;
    if (userDto.address !== undefined) userToUpdate.address = userDto.address;
    if (userDto.city !== undefined) userToUpdate.city = userDto.city;
    if (userDto.state !== undefined) userToUpdate.state = userDto.state;
    if (userDto.country !== undefined) userToUpdate.country = userDto.country;
    if (userDto.zipCode !== undefined) userToUpdate.zipCode = userDto.zipCode;
    if (userDto.emergencyContact !== undefined)
      userToUpdate.emergencyContact = userDto.emergencyContact;
    if (userDto.password) {
      if (!userDto.oldPassword) {
        throw new UnprocessableEntityException({
          code: ERROR_CODES.AUTH_MISSING_OLD_PASSWORD,
          message:
            'Se requiere la contraseña anterior para establecer una nueva.',
          details: { field: 'oldPassword' },
        });
      }
      if (!currentUser.password) {
        throw new UnprocessableEntityException({
          code: ERROR_CODES.AUTH_INCORRECT_OLD_PASSWORD,
          message: 'La cuenta actual no tiene una contraseña configurada.',
          details: { field: 'oldPassword' },
        });
      }
      const isValidOldPassword = await bcrypt.compare(
        userDto.oldPassword,
        currentUser.password,
      );
      if (!isValidOldPassword) {
        throw new UnprocessableEntityException({
          code: ERROR_CODES.AUTH_INCORRECT_OLD_PASSWORD,
          message: 'La contraseña anterior es incorrecta.',
          details: { field: 'oldPassword' },
        });
      } else {
        await this.sessionService.deleteByUserIdWithExclude({
          userId: currentUser.id,
          excludeSessionId: userJwtPayload.sessionId,
        });
      }
    }
    if (userDto.email && userDto.email !== currentUser.email) {
      const userByEmail = await this.usersService.findByEmail(userDto.email);
      if (userByEmail && userByEmail.id !== currentUser.id) {
        throw new UnprocessableEntityException({
          code: ERROR_CODES.AUTH_DUPLICATE_EMAIL,
          message: 'El correo electrónico ya está registrado por otro usuario.',
          details: { field: 'email' },
        });
      }
      const hash = await this.jwtService.signAsync(
        {
          confirmEmailUserId: currentUser.id,
          newEmail: userDto.email,
        },
        {
          secret: this.configService.getOrThrow('auth.confirmEmailSecret', {
            infer: true,
          }),
          expiresIn: this.configService.getOrThrow('auth.confirmEmailExpires', {
            infer: true,
          }),
        },
      );
      await this.mailService.confirmNewEmail({
        to: userDto.email,
        data: {
          hash,
        },
      });
      userToUpdate.email = currentUser.email;
    }
    const updateData: Partial<User> = {
      firstName: userToUpdate.firstName,
      lastName: userToUpdate.lastName,
      password: userToUpdate.password,
      birthDate: userToUpdate.birthDate,
      gender: userToUpdate.gender,
      phoneNumber: userToUpdate.phoneNumber,
      address: userToUpdate.address,
      city: userToUpdate.city,
      state: userToUpdate.state,
      country: userToUpdate.country,
      zipCode: userToUpdate.zipCode,
      email: userToUpdate.email,
      emergencyContact: userToUpdate.emergencyContact,
    };
    return this.usersService.update(userJwtPayload.id, updateData);
  }
  async refreshToken(
    data: Pick<JwtRefreshPayloadType, 'sessionId' | 'hash'>,
  ): Promise<Omit<LoginResponseDto, 'user'>> {
    if (!data.sessionId) {
      throw new UnauthorizedException({
        code: ERROR_CODES.AUTH_SESSION_EXPIRED_OR_INVALID,
        message: 'Session ID es requerido.',
      });
    }
    const session = await this.sessionService.findById(data.sessionId);
    if (!session) {
      throw new UnauthorizedException({
        code: ERROR_CODES.AUTH_SESSION_EXPIRED_OR_INVALID,
        message: 'La sesión ha expirado o es inválida.',
      });
    }
    if (session.hash !== data.hash) {
      await this.sessionService.deleteById(session.id);
      throw new UnauthorizedException({
        code: ERROR_CODES.AUTH_SESSION_EXPIRED_OR_INVALID,
        message: 'Token de refresco inválido.',
      });
    }
    const hash = crypto
      .createHash('sha256')
      .update(randomStringGenerator())
      .digest('hex');
    const user = await this.usersService.findById(session.user.id);
    if (!user?.role) {
      await this.sessionService.deleteById(session.id);
      throw new UnauthorizedException({
        code: ERROR_CODES.AUTH_UNAUTHORIZED,
        message: 'Usuario asociado a la sesión no válido.',
      });
    }
    await this.sessionService.update(session.id, {
      hash,
    });
    const { token, refreshToken, tokenExpires } = await this.getTokensData({
      id: session.user.id,
      role: user.role,
      sessionId: session.id,
      hash,
    });
    return {
      token,
      refreshToken,
      tokenExpires,
    };
  }
  async softDelete(user: User): Promise<void> {
    await this.usersService.remove(user.id);
  }
  async logout(data: Pick<JwtRefreshPayloadType, 'sessionId'>) {
    if (!data.sessionId) {
      return;
    }
    return this.sessionService.deleteById(data.sessionId);
  }
  private async getTokensData(data: {
    id: User['id'];
    role: User['role'];
    sessionId: Session['id'];
    hash: Session['hash'];
  }) {
    const tokenExpiresIn = this.configService.getOrThrow('auth.expires', {
      infer: true,
    });
    const tokenExpires = Date.now() + ms(tokenExpiresIn);
    const [token, refreshToken] = await Promise.all([
      await this.jwtService.signAsync(
        {
          id: data.id,
          role: data.role,
          sessionId: data.sessionId,
        },
        {
          secret: this.configService.getOrThrow('auth.secret', { infer: true }),
          expiresIn: tokenExpiresIn,
        },
      ),
      await this.jwtService.signAsync(
        {
          sessionId: data.sessionId,
          hash: data.hash,
        },
        {
          secret: this.configService.getOrThrow('auth.refreshSecret', {
            infer: true,
          }),
          expiresIn: this.configService.getOrThrow('auth.refreshExpires', {
            infer: true,
          }),
        },
      ),
    ]);
    return {
      token,
      refreshToken,
      tokenExpires,
    };
  }
}

================
File: backend/src/categories/infrastructure/persistence/category.repository.ts
================
import { Category } from '../../domain/category';
import { IBaseRepository } from '../../../common/domain/repositories/base.repository';
import { FindAllCategoriesDto } from '../../dto/find-all-categories.dto';
import { CreateCategoryDto } from '../../dto/create-category.dto';
import { UpdateCategoryDto } from '../../dto/update-category.dto';
export interface CategoryRepository
  extends IBaseRepository<
    Category,
    FindAllCategoriesDto,
    CreateCategoryDto,
    UpdateCategoryDto
  > {
  findFullMenu(): Promise<Category[]>;
  findOrderMenu(): Promise<Category[]>;
}

================
File: backend/src/categories/infrastructure/persistence/relational/repositories/categories.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, ILike, FindOptionsWhere } from 'typeorm';
import { CategoryEntity } from '../entities/category.entity';
import { Category } from '../../../../domain/category';
import { CategoryMapper } from '../mappers/category.mapper';
import { BaseRelationalRepository } from '../../../../../common/infrastructure/persistence/relational/base-relational.repository';
import { FindAllCategoriesDto } from '../../../../dto/find-all-categories.dto';
@Injectable()
export class CategoriesRelationalRepository extends BaseRelationalRepository<
  CategoryEntity,
  Category,
  FindAllCategoriesDto
> {
  constructor(
    @InjectRepository(CategoryEntity)
    ormRepo: Repository<CategoryEntity>,
    mapper: CategoryMapper,
  ) {
    super(ormRepo, mapper);
  }
  protected override buildWhere(
    filter?: FindAllCategoriesDto,
  ): FindOptionsWhere<CategoryEntity> | undefined {
    if (!filter) return undefined;
    const where: FindOptionsWhere<CategoryEntity> = {};
    if (filter.name) {
      where.name = ILike(`%${filter.name}%`);
    }
    if (filter.isActive !== undefined) {
      where.isActive = filter.isActive;
    }
    return Object.keys(where).length > 0 ? where : undefined;
  }
  async findById(id: string): Promise<Category | null> {
    const entity = await this.ormRepo.findOne({
      where: { id },
      relations: ['photo'],
    });
    return entity ? this.mapper.toDomain(entity) : null;
  }
  async findAll(filter?: FindAllCategoriesDto): Promise<Category[]> {
    const where = this.buildWhere(filter);
    const entities = await this.ormRepo.find({
      where,
      relations: ['photo'],
      order: {
        sortOrder: 'ASC',
        name: 'ASC',
      },
    });
    return entities
      .map((e) => this.mapper.toDomain(e))
      .filter((d): d is Category => d !== null);
  }
  async findFullMenu(): Promise<Category[]> {
    const queryBuilder = this.ormRepo
      .createQueryBuilder('category')
      .leftJoinAndSelect('category.subcategories', 'subcategory')
      .leftJoinAndSelect('subcategory.products', 'product')
      .leftJoinAndSelect('product.variants', 'productVariant')
      .leftJoinAndSelect('product.modifierGroups', 'modifierGroup')
      .leftJoinAndSelect('modifierGroup.productModifiers', 'modifier')
      .leftJoinAndSelect('product.pizzaCustomizations', 'pizzaCustomization')
      .leftJoinAndSelect('product.pizzaConfiguration', 'pizzaConfiguration')
      .leftJoinAndSelect('category.photo', 'categoryPhoto')
      .leftJoinAndSelect('subcategory.photo', 'subcategoryPhoto')
      .leftJoinAndSelect('product.photo', 'productPhoto')
      .orderBy({
        'category.sortOrder': 'ASC',
        'category.name': 'ASC',
        'subcategory.sortOrder': 'ASC',
        'subcategory.name': 'ASC',
        'product.sortOrder': 'ASC',
        'product.name': 'ASC',
        'productVariant.sortOrder': 'ASC',
        'productVariant.name': 'ASC',
        'modifierGroup.sortOrder': 'ASC',
        'modifierGroup.name': 'ASC',
        'modifier.sortOrder': 'ASC',
        'modifier.name': 'ASC',
      });
    const entities = await queryBuilder.getMany();
    const domainResults = entities
      .map((entity) => this.mapper.toDomain(entity))
      .filter((item): item is Category => item !== null);
    return domainResults;
  }
  async findOrderMenu(): Promise<Category[]> {
    const queryBuilder = this.ormRepo
      .createQueryBuilder('category')
      .select([
        'category.id',
        'category.name',
        'category.isActive',
        'category.sortOrder',
      ])
      .leftJoin('category.subcategories', 'subcategory')
      .addSelect([
        'subcategory.id',
        'subcategory.name',
        'subcategory.isActive',
        'subcategory.sortOrder',
      ])
      .leftJoin('subcategory.products', 'product')
      .addSelect([
        'product.id',
        'product.name',
        'product.price',
        'product.description',
        'product.hasVariants',
        'product.isActive',
        'product.isPizza',
        'product.preparationScreenId',
        'product.sortOrder',
      ])
      .leftJoin('product.variants', 'productVariant')
      .addSelect([
        'productVariant.id',
        'productVariant.name',
        'productVariant.price',
        'productVariant.isActive',
        'productVariant.sortOrder',
      ])
      .leftJoin('product.modifierGroups', 'modifierGroup')
      .addSelect([
        'modifierGroup.id',
        'modifierGroup.name',
        'modifierGroup.description',
        'modifierGroup.minSelections',
        'modifierGroup.maxSelections',
        'modifierGroup.isRequired',
        'modifierGroup.allowMultipleSelections',
        'modifierGroup.sortOrder',
      ])
      .leftJoin('modifierGroup.productModifiers', 'modifier')
      .addSelect([
        'modifier.id',
        'modifier.name',
        'modifier.price',
        'modifier.isDefault',
        'modifier.isActive',
        'modifier.sortOrder',
      ])
      .leftJoinAndSelect('product.pizzaCustomizations', 'pizzaCustomization')
      .leftJoinAndSelect('product.pizzaConfiguration', 'pizzaConfiguration')
      .leftJoin('category.photo', 'categoryPhoto')
      .addSelect(['categoryPhoto.path'])
      .leftJoin('subcategory.photo', 'subcategoryPhoto')
      .addSelect(['subcategoryPhoto.path'])
      .leftJoin('product.photo', 'productPhoto')
      .addSelect(['productPhoto.path'])
      .orderBy('category.sortOrder', 'ASC')
      .addOrderBy('category.name', 'ASC')
      .addOrderBy('subcategory.sortOrder', 'ASC')
      .addOrderBy('subcategory.name', 'ASC')
      .addOrderBy('product.sortOrder', 'ASC')
      .addOrderBy('product.name', 'ASC')
      .addOrderBy('productVariant.sortOrder', 'ASC')
      .addOrderBy('productVariant.name', 'ASC')
      .addOrderBy('modifierGroup.sortOrder', 'ASC')
      .addOrderBy('modifierGroup.name', 'ASC')
      .addOrderBy('modifier.sortOrder', 'ASC')
      .addOrderBy('modifier.name', 'ASC');
    const entities = await queryBuilder.getMany();
    const domainResults = entities
      .map((entity) => this.mapper.toDomain(entity))
      .filter((item): item is Category => item !== null);
    return domainResults;
  }
}

================
File: backend/src/common/tokens.ts
================
export const SESSION_REPOSITORY = Symbol('SESSION_REPOSITORY');
export const AREA_REPOSITORY = Symbol('AREA_REPOSITORY');
export const CATEGORY_REPOSITORY = Symbol('CATEGORY_REPOSITORY');
export const SUBCATEGORY_REPOSITORY = Symbol('SUBCATEGORY_REPOSITORY');
export const PRODUCT_REPOSITORY = Symbol('PRODUCT_REPOSITORY');
export const PRODUCT_MODIFIER_REPOSITORY = Symbol(
  'PRODUCT_MODIFIER_REPOSITORY',
);
export const PAYMENT_REPOSITORY = Symbol('PAYMENT_REPOSITORY');
export const PREPARATION_SCREEN_REPOSITORY = Symbol(
  'PREPARATION_SCREEN_REPOSITORY',
);
export const PRODUCT_vARIANT_REPOSITORY = Symbol('PRODUCT_VARIANT_REPOSITORY');
export const TABLE_REPOSITORY = Symbol('TABLE_REPOSITORY');
export const CUSTOMER_REPOSITORY = Symbol('CUSTOMER_REPOSITORY');
export const ADDRESS_REPOSITORY = Symbol('ADDRESS_REPOSITORY');
export const FILE_REPOSITORY = Symbol('FILE_REPOSITORY');
export const MODIFIER_GROUP_REPOSITORY = Symbol('MODIFIER_GROUP_REPOSITORY');
export const PRODUCT_VARIANT_REPOSITORY = Symbol('PRODUCT_VARIANT_REPOSITORY');
export const THERMAL_PRINTER_REPOSITORY = Symbol('THERMAL_PRINTER_REPOSITORY');
export const USER_REPOSITORY = Symbol('USER_REPOSITORY');
export const SHIFTS_SERVICE = Symbol('SHIFTS_SERVICE');
export const ORDER_REPOSITORY = Symbol('ORDER_REPOSITORY');
export const ORDER_ITEM_REPOSITORY = Symbol('ORDER_ITEM_REPOSITORY');
export const TICKET_IMPRESSION_REPOSITORY = Symbol(
  'TICKET_IMPRESSION_REPOSITORY',
);
export const ORDER_HISTORY_REPOSITORY = Symbol('ORDER_HISTORY_REPOSITORY');
export const ORDER_PREPARATION_SCREEN_STATUS_REPOSITORY = Symbol(
  'ORDER_PREPARATION_SCREEN_STATUS_REPOSITORY',
);
export const ADJUSTMENT_REPOSITORY = Symbol('ADJUSTMENT_REPOSITORY');
export const PIZZA_INGREDIENT_REPOSITORY = Symbol(
  'PIZZA_INGREDIENT_REPOSITORY',
);

================
File: backend/src/config/app-config.type.ts
================
export type AppConfig = {
  nodeEnv: string;
  name: string;
  workingDirectory: string;
  frontendDomain?: string;
  backendDomain: string;
  port: number;
  apiPrefix: string;
  fallbackLanguage: string;
  headerLanguage: string;
  remoteUrl?: string;
};

================
File: backend/src/customers/addresses.service.ts
================
import { Injectable, Inject, NotFoundException } from '@nestjs/common';
import { BaseCrudService } from '../common/application/base-crud.service';
import { Address } from './domain/address';
import { CreateAddressDto } from './dto/create-address.dto';
import { UpdateAddressDto } from './dto/update-address.dto';
import { FindAllAddressesDto } from './dto/find-all-addresses.dto';
import { AddressRepository } from './infrastructure/persistence/address.repository';
import { ADDRESS_REPOSITORY } from '../common/tokens';
@Injectable()
export class AddressesService extends BaseCrudService<
  Address,
  CreateAddressDto,
  UpdateAddressDto,
  FindAllAddressesDto
> {
  constructor(
    @Inject(ADDRESS_REPOSITORY) protected readonly repo: AddressRepository,
  ) {
    super(repo);
  }
  async setDefaultAddress(
    customerId: string,
    addressId: string,
  ): Promise<void> {
    const address = await this.repo.findById(addressId);
    if (!address || address.customerId !== customerId) {
      throw new NotFoundException(
        `Dirección con ID ${addressId} no encontrada o no pertenece al cliente ${customerId}.`,
      );
    }
    if (address.isDefault) {
      return;
    }
    await this.unsetDefaultForOtherAddresses(customerId, addressId);
    await this.repo.update(addressId, { isDefault: true });
  }
  async unsetDefaultForOtherAddresses(
    customerId: string,
    excludeAddressId?: string,
  ): Promise<void> {
    const currentAddresses = await this.findAll({ customerId });
    for (const addr of currentAddresses) {
      if (addr.isDefault && addr.id !== excludeAddressId) {
        await this.repo.update(addr.id, { isDefault: false });
      }
    }
  }
}

================
File: backend/src/customers/customers.service.ts
================
import {
  Injectable,
  Inject,
  NotFoundException,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { CustomerRepository } from './infrastructure/persistence/customer.repository';
import { AddressesService } from './addresses.service';
import { Customer } from './domain/customer';
import { Address } from './domain/address';
import { CreateCustomerDto } from './dto/create-customer.dto';
import { UpdateCustomerDto } from './dto/update-customer.dto';
import { FindAllCustomersDto } from './dto/find-all-customers.dto';
import { CreateAddressDto } from './dto/create-address.dto';
import { UpdateAddressDto } from './dto/update-address.dto';
import { CUSTOMER_REPOSITORY } from '../common/tokens';
import { BaseCrudService } from '../common/application/base-crud.service';
@Injectable()
export class CustomersService extends BaseCrudService<
  Customer,
  CreateCustomerDto,
  UpdateCustomerDto,
  FindAllCustomersDto
> {
  constructor(
    @Inject(CUSTOMER_REPOSITORY)
    protected readonly repo: CustomerRepository,
    private readonly addressesService: AddressesService,
  ) {
    super(repo);
  }
  override async create(
    createCustomerDto: CreateCustomerDto,
  ): Promise<Customer> {
    const { addresses: addressDtos, ...customerData } = createCustomerDto;
    const createdCustomer = await super.create(customerData);
    if (addressDtos && addressDtos.length > 0) {
      let hasDefault = false;
      for (const addressDto of addressDtos) {
        if (addressDto.isDefault) {
          if (hasDefault) {
            throw new BadRequestException(
              'Solo puede haber una dirección predeterminada.',
            );
          }
          hasDefault = true;
        }
        await this.addAddressToCustomer(createdCustomer.id, addressDto);
      }
      return this.findOne(createdCustomer.id);
    }
    return createdCustomer;
  }
  override async update(
    id: string,
    updateCustomerDto: UpdateCustomerDto,
  ): Promise<Customer> {
    await this.findOne(id);
    const customerUpdatePayload: UpdateCustomerDto = {
      firstName: updateCustomerDto.firstName,
      lastName: updateCustomerDto.lastName,
      whatsappPhoneNumber: updateCustomerDto.whatsappPhoneNumber,
      email: updateCustomerDto.email,
      birthDate: updateCustomerDto.birthDate,
      isActive: updateCustomerDto.isActive,
      isBanned: updateCustomerDto.isBanned,
      fullChatHistory: updateCustomerDto.fullChatHistory,
      relevantChatHistory: updateCustomerDto.relevantChatHistory,
      lastInteraction: updateCustomerDto.lastInteraction,
    };
    await super.update(id, customerUpdatePayload);
    return this.findOne(id);
  }
  async addAddressToCustomer(
    customerId: string,
    dto: CreateAddressDto,
  ): Promise<Address> {
    await this.findOne(customerId);
    const fullDto = { ...dto, customerId };
    if (fullDto.isDefault) {
      await this.addressesService.unsetDefaultForOtherAddresses(customerId);
    }
    return this.addressesService.create(fullDto);
  }
  async updateCustomerAddress(
    customerId: string,
    addressId: string,
    dto: UpdateAddressDto,
  ): Promise<Address> {
    const address = await this.addressesService.findOne(addressId);
    if (address.customerId !== customerId) {
      throw new NotFoundException(
        `Dirección con ID ${addressId} no encontrada o no pertenece al cliente ${customerId}.`,
      );
    }
    if (dto.isDefault === true && !address.isDefault) {
      await this.addressesService.unsetDefaultForOtherAddresses(
        customerId,
        addressId,
      );
    } else if (dto.isDefault === false && address.isDefault) {
      const customerAddresses = await this.addressesService.findAll({
        customerId,
      });
      const defaultAddressesCount = customerAddresses.filter(
        (a) => a.isDefault,
      ).length;
      if (defaultAddressesCount <= 1) {
        throw new BadRequestException(
          'No se puede desmarcar la única dirección predeterminada.',
        );
      }
    }
    const updatedAddress = await this.addressesService.update(addressId, dto);
    if (!updatedAddress) {
      throw new InternalServerErrorException(
        `Error al actualizar la dirección con ID ${addressId}.`,
      );
    }
    return updatedAddress;
  }
  async removeCustomerAddress(
    customerId: string,
    addressId: string,
  ): Promise<void> {
    const address = await this.addressesService.findOne(addressId);
    if (address.customerId !== customerId) {
      throw new NotFoundException(
        `Dirección con ID ${addressId} no encontrada o no pertenece al cliente ${customerId}.`,
      );
    }
    if (address.isDefault) {
      throw new BadRequestException(
        'No puedes borrar la dirección predeterminada.',
      );
    }
    await this.addressesService.remove(addressId);
  }
  async appendToChatHistory(
    customerId: string,
    message: { role: 'user' | 'assistant' | 'system'; content: string },
  ): Promise<Customer> {
    const customer = await this.findOne(customerId);
    const newMessage = {
      ...message,
      timestamp: new Date(),
    };
    const fullChatHistory = customer.fullChatHistory || [];
    fullChatHistory.push(newMessage);
    await super.update(customerId, {
      fullChatHistory,
      lastInteraction: new Date().toISOString(),
    });
    return this.findOne(customerId);
  }
  async updateRelevantChatHistory(
    customerId: string,
    relevantHistory: any[],
  ): Promise<Customer> {
    await this.findOne(customerId);
    await super.update(customerId, {
      relevantChatHistory: relevantHistory,
    });
    return this.findOne(customerId);
  }
  async updateCustomerStats(
    customerId: string,
    stats: { totalOrders?: number; totalSpent?: number },
  ): Promise<Customer> {
    await this.findOne(customerId);
    const updatePayload: any = {};
    if (stats.totalOrders !== undefined) {
      updatePayload.totalOrders = stats.totalOrders;
    }
    if (stats.totalSpent !== undefined) {
      updatePayload.totalSpent = stats.totalSpent;
    }
    await this.repo.update(customerId, updatePayload);
    return this.findOne(customerId);
  }
  async getActiveCustomersWithRecentInteraction(
    daysAgo: number = 30,
  ): Promise<Customer[]> {
    const dateThreshold = new Date();
    dateThreshold.setDate(dateThreshold.getDate() - daysAgo);
    return this.repo.findAll({
      isActive: true,
      lastInteractionAfter: dateThreshold,
    });
  }
  async banCustomer(customerId: string, banReason: string): Promise<Customer> {
    const customer = await this.findOne(customerId);
    if (customer.isBanned) {
      throw new BadRequestException('El cliente ya está baneado');
    }
    await super.update(customerId, {
      isBanned: true,
      isActive: false,
    });
    await this.repo.ormRepo.update(customerId, {
      bannedAt: new Date(),
      banReason,
    });
    return this.findOne(customerId);
  }
  async unbanCustomer(customerId: string): Promise<Customer> {
    const customer = await this.findOne(customerId);
    if (!customer.isBanned) {
      throw new BadRequestException('El cliente no está baneado');
    }
    await super.update(customerId, {
      isBanned: false,
      isActive: true,
    });
    await this.repo.ormRepo.update(customerId, {
      bannedAt: null,
      banReason: null,
    });
    return this.findOne(customerId);
  }
  async getBannedCustomers(): Promise<Customer[]> {
    return this.repo.findBannedCustomers();
  }
  async isCustomerBanned(customerId: string): Promise<boolean> {
    try {
      const customer = await this.findOne(customerId);
      return customer.isBanned;
    } catch {
      return false;
    }
  }
}

================
File: backend/src/customers/dto/find-all-customers.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsEmail,
  IsOptional,
  IsPhoneNumber,
  IsString,
  IsBoolean,
  IsDateString,
} from 'class-validator';
import { Transform } from 'class-transformer';
import { PaginationParams } from '../../utils/types/pagination-params';
export class FindAllCustomersDto extends PaginationParams {
  @ApiPropertyOptional({
    description:
      'Filtrar por nombre (búsqueda parcial, insensible a mayúsculas)',
    example: 'Juan',
  })
  @IsOptional()
  @IsString()
  firstName?: string;
  @ApiPropertyOptional({
    description:
      'Filtrar por apellido (búsqueda parcial, insensible a mayúsculas)',
    example: 'Perez',
  })
  @IsOptional()
  @IsString()
  lastName?: string;
  @ApiPropertyOptional({
    description: 'Filtrar por correo electrónico exacto',
    example: 'juan.perez@example.com',
  })
  @IsOptional()
  @IsEmail()
  email?: string;
  @ApiPropertyOptional({
    description: 'Filtrar por número de WhatsApp exacto',
    example: '+525512345678',
  })
  @IsOptional()
  @IsPhoneNumber(undefined, { message: 'El número de WhatsApp no es válido' })
  whatsappPhoneNumber?: string;
  @ApiPropertyOptional({
    description: 'Filtrar por estado activo',
    example: true,
  })
  @IsOptional()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  @IsBoolean()
  isActive?: boolean;
  @ApiPropertyOptional({
    description: 'Filtrar por última interacción después de esta fecha',
    example: '2024-01-01',
  })
  @IsOptional()
  @IsDateString()
  lastInteractionAfter?: Date;
  @ApiPropertyOptional({
    description: 'Filtrar por estado de baneo',
    example: false,
  })
  @IsOptional()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  @IsBoolean()
  isBanned?: boolean;
}

================
File: backend/src/customers/infrastructure/persistence/address.repository.ts
================
import { NullableType } from '../../../utils/types/nullable.type';
import { Address } from '../../domain/address';
import { IBaseRepository } from '../../../common/domain/repositories/base.repository';
import { CreateAddressDto } from '../../dto/create-address.dto';
import { UpdateAddressDto } from '../../dto/update-address.dto';
import { FindAllAddressesDto } from '../../dto/find-all-addresses.dto';
export abstract class AddressRepository
  implements
    IBaseRepository<
      Address,
      FindAllAddressesDto,
      CreateAddressDto,
      UpdateAddressDto
    >
{
  abstract create(data: CreateAddressDto): Promise<Address>;
  abstract findById(id: Address['id']): Promise<NullableType<Address>>;
  abstract findAll(filter?: FindAllAddressesDto): Promise<Address[]>;
  abstract update(
    id: Address['id'],
    payload: UpdateAddressDto,
  ): Promise<NullableType<Address>>;
  abstract remove(id: Address['id']): Promise<void>;
}

================
File: backend/src/database/data-source.ts
================
import 'reflect-metadata';
import { DataSource, DataSourceOptions } from 'typeorm';
import { config } from 'dotenv';
config();
export const AppDataSource = new DataSource({
  type: process.env.DATABASE_TYPE as any,
  url: process.env.DATABASE_URL,
  host: process.env.DATABASE_HOST,
  port: process.env.DATABASE_PORT
    ? parseInt(process.env.DATABASE_PORT, 10)
    : 5432,
  username: process.env.DATABASE_USERNAME,
  password: process.env.DATABASE_PASSWORD,
  database: process.env.DATABASE_NAME,
  synchronize: process.env.DATABASE_SYNCHRONIZE === 'true',
  dropSchema: false,
  keepConnectionAlive: true,
  logging: process.env.NODE_ENV !== 'production',
  entities: ['src/**/*.entity{.ts,.js}'],
  migrations: ['src/database/migrations/**/*{.ts,.js}'],
  migrationsTableName: 'migrations',
  extra: {
    max: process.env.DATABASE_MAX_CONNECTIONS
      ? parseInt(process.env.DATABASE_MAX_CONNECTIONS, 10)
      : 100,
    timezone: 'UTC',
    ssl:
      process.env.DATABASE_SSL_ENABLED === 'true'
        ? {
            rejectUnauthorized:
              process.env.DATABASE_REJECT_UNAUTHORIZED === 'true',
            ca: process.env.DATABASE_CA ?? undefined,
            key: process.env.DATABASE_KEY ?? undefined,
            cert: process.env.DATABASE_CERT ?? undefined,
          }
        : undefined,
  },
} as DataSourceOptions);

================
File: backend/src/database/typeorm-config.service.ts
================
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { TypeOrmModuleOptions, TypeOrmOptionsFactory } from '@nestjs/typeorm';
import { AllConfigType } from '../config/config.type';
@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  constructor(private configService: ConfigService<AllConfigType>) {}
  createTypeOrmOptions(): TypeOrmModuleOptions {
    return {
      type: this.configService.get('database.type', { infer: true }),
      url: this.configService.get('database.url', { infer: true }),
      host: this.configService.get('database.host', { infer: true }),
      port: this.configService.get('database.port', { infer: true }),
      username: this.configService.get('database.username', { infer: true }),
      password: this.configService.get('database.password', { infer: true }),
      database: this.configService.get('database.name', { infer: true }),
      synchronize: this.configService.get('database.synchronize', {
        infer: true,
      }),
      dropSchema: false,
      keepConnectionAlive: true,
      logging: ['error', 'warn', 'migration'],
      entities: [__dirname + '/../**/*.entity{.ts,.js}'],
      migrations: [__dirname + '/migrations/**/*{.ts,.js}'],
      cli: {
        entitiesDir: 'src',
        subscribersDir: 'subscriber',
      },
      extra: {
        max: this.configService.get('database.maxConnections', { infer: true }),
        timezone: 'UTC',
        ssl: this.configService.get('database.sslEnabled', { infer: true })
          ? {
              rejectUnauthorized: this.configService.get(
                'database.rejectUnauthorized',
                { infer: true },
              ),
              ca:
                this.configService.get('database.ca', { infer: true }) ??
                undefined,
              key:
                this.configService.get('database.key', { infer: true }) ??
                undefined,
              cert:
                this.configService.get('database.cert', { infer: true }) ??
                undefined,
            }
          : undefined,
      },
    } as TypeOrmModuleOptions;
  }
}

================
File: backend/src/discovery/discovery.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { ConfigService } from '@nestjs/config';
interface DiscoveryResponse {
  type: string;
  name: string;
  version: string;
  port: number;
  features: string[];
  timestamp: number;
  remoteUrl?: string;
  tunnelEnabled?: boolean;
}
@ApiTags('Discovery')
@Controller({
  path: 'discovery',
  version: '1',
})
export class DiscoveryController {
  constructor(private readonly configService: ConfigService) {}
  @Get()
  @ApiOperation({
    summary: 'Service discovery endpoint',
    description: 'Returns service identification for auto-discovery',
  })
  @ApiResponse({
    status: 200,
    description: 'Service information',
    schema: {
      type: 'object',
      properties: {
        type: { type: 'string', example: 'cloudbite-api' },
        name: { type: 'string', example: 'CloudBite Restaurant API' },
        version: { type: 'string', example: '1.0.0' },
        port: { type: 'number', example: 3737 },
        features: {
          type: 'array',
          items: { type: 'string' },
          example: ['orders', 'thermal-printing', 'voice-orders', 'sync'],
        },
        timestamp: { type: 'number', example: 1234567890123 },
        remoteUrl: { type: 'string', example: 'https://api.ejemplo.com' },
        tunnelEnabled: { type: 'boolean', example: true },
      },
      required: ['type', 'name', 'version', 'port', 'features', 'timestamp'],
    },
  })
  identify(): DiscoveryResponse {
    const remoteUrl = this.configService.get('app.remoteUrl');
    const tunnelEnabled = !!remoteUrl;
    return {
      type: 'cloudbite-api',
      name: this.configService.get('app.name', 'CloudBite Restaurant API'),
      version: '1.0.0',
      port: this.configService.get('app.port', 3737),
      features: [
        'orders',
        'products',
        'thermal-printing',
        'voice-orders',
        'payments',
        'customers',
        'tables',
        'sync',
      ],
      timestamp: Date.now(),
      ...(tunnelEnabled && { remoteUrl, tunnelEnabled }),
    };
  }
}

================
File: backend/src/kitchen/dto/kitchen-order-response.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { OrderType } from '../../orders/domain/enums/order-type.enum';
import { PreparationStatus } from '../../orders/domain/order-item';
export class KitchenOrderItemDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  productName: string;
  @ApiProperty()
  variantName?: string;
  @ApiProperty({ type: [String] })
  modifiers: string[];
  @ApiProperty({ type: [Object] })
  pizzaCustomizations: any[];
  @ApiProperty()
  preparationNotes?: string;
  @ApiProperty({ enum: PreparationStatus })
  preparationStatus: PreparationStatus;
  @ApiProperty()
  preparedAt?: Date;
  @ApiProperty()
  preparedBy?: string;
  @ApiProperty()
  preparedByUser?: {
    firstName: string;
    lastName: string;
  };
  @ApiProperty()
  createdAt?: Date;
  @ApiProperty()
  quantity: number;
  @ApiProperty()
  belongsToMyScreen: boolean;
  @ApiProperty()
  preparationScreenId?: string;
}
export class PreparationScreenStatusDto {
  @ApiProperty()
  screenId: string;
  @ApiProperty()
  screenName: string;
  @ApiProperty()
  status: string;
  @ApiProperty({ required: false })
  startedAt?: Date;
  @ApiProperty({ required: false })
  completedAt?: Date;
  @ApiProperty({ required: false })
  startedBy?: {
    firstName: string;
    lastName: string;
  };
}
export class KitchenOrderDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  shiftOrderNumber: number;
  @ApiProperty({ enum: OrderType })
  orderType: OrderType;
  @ApiProperty()
  orderStatus: string;
  @ApiProperty()
  createdAt: Date;
  @ApiProperty()
  orderNotes?: string;
  @ApiProperty({ required: false })
  deliveryAddress?: string;
  @ApiProperty({ required: false })
  deliveryPhone?: string;
  @ApiProperty({ required: false })
  receiptName?: string;
  @ApiProperty({ required: false })
  customerPhone?: string;
  @ApiProperty({ required: false })
  areaName?: string;
  @ApiProperty({ required: false })
  tableName?: string;
  @ApiProperty({ type: [KitchenOrderItemDto] })
  items: KitchenOrderItemDto[];
  @ApiProperty()
  hasPendingItems: boolean;
  @ApiProperty({ type: [PreparationScreenStatusDto] })
  screenStatuses: PreparationScreenStatusDto[];
  @ApiProperty()
  myScreenStatus?: string;
}

================
File: backend/src/orders/dto/find-all-orders.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsDateString,
  IsEnum,
  IsOptional,
  IsString,
  IsArray,
} from 'class-validator';
import { OrderStatus } from '../domain/enums/order-status.enum';
import { OrderType } from '../domain/enums/order-type.enum';
export class FindAllOrdersDto {
  @ApiProperty({
    description: 'Filter orders by user ID',
    example: 'USER-1',
    required: false,
  })
  @IsOptional()
  @IsString()
  userId?: string;
  @ApiProperty({
    description: 'Filter orders by table ID',
    example: 'TABLE-1',
    required: false,
  })
  @IsOptional()
  @IsString()
  tableId?: string;
  @ApiProperty({
    description: 'Filter orders by shift ID',
    example: 'SHIFT-1',
    required: false,
  })
  @IsOptional()
  @IsString()
  shiftId?: string;
  @ApiProperty({
    description: 'Filter orders by status',
    enum: OrderStatus,
    example: OrderStatus.PENDING,
    required: false,
  })
  @IsOptional()
  @IsEnum(OrderStatus)
  orderStatus?: OrderStatus;
  @ApiProperty({
    description: 'Filter orders by multiple statuses',
    enum: OrderStatus,
    isArray: true,
    example: [OrderStatus.COMPLETED, OrderStatus.CANCELLED],
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsEnum(OrderStatus, { each: true })
  orderStatuses?: OrderStatus[];
  @ApiProperty({
    description: 'Filter orders by type',
    enum: OrderType,
    example: OrderType.DINE_IN,
    required: false,
  })
  @IsOptional()
  @IsEnum(OrderType)
  orderType?: OrderType;
  @ApiProperty({
    description: 'Filter orders created after this date',
    example: '2023-01-01T00:00:00Z',
    required: false,
  })
  @IsOptional()
  @IsDateString()
  startDate?: string;
  @ApiProperty({
    description: 'Filter orders created before this date',
    example: '2023-12-31T23:59:59Z',
    required: false,
  })
  @IsOptional()
  @IsDateString()
  endDate?: string;
}

================
File: backend/src/orders/dto/update-order.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsDateString,
  IsEnum,
  IsNumber,
  IsOptional,
  IsPositive,
  IsUUID,
  ValidateNested,
  IsString,
  IsBoolean,
} from 'class-validator';
import { OrderStatus } from '../domain/enums/order-status.enum';
import { OrderType } from '../domain/enums/order-type.enum';
import { Type } from 'class-transformer';
import { OrderItemInputDto } from './order-item-input.dto';
import { DeliveryInfoDto } from './delivery-info.dto';
export class UpdateOrderDto {
  @ApiProperty({
    type: String,
    example: '123e4567-e89b-12d3-a456-426614174000',
    description: 'ID del usuario que realiza la orden',
    required: false,
  })
  @IsOptional()
  @IsUUID()
  userId?: string;
  @ApiProperty({
    type: String,
    example: 'TABLE-1',
    description: 'ID de la mesa',
    required: false,
  })
  @IsOptional()
  @IsString()
  tableId?: string;
  @ApiProperty({
    type: Date,
    example: '2023-01-01T14:30:00.000Z',
    description: 'Fecha y hora programada para la orden',
    required: false,
  })
  @IsOptional()
  @IsDateString()
  scheduledAt?: Date;
  @ApiProperty({
    enum: OrderStatus,
    example: OrderStatus.PENDING,
    description: 'Estado de la orden',
    required: false,
  })
  @IsOptional()
  @IsEnum(OrderStatus)
  orderStatus?: OrderStatus;
  @ApiProperty({
    enum: OrderType,
    example: OrderType.DINE_IN,
    description: 'Tipo de orden',
    required: false,
  })
  @IsOptional()
  @IsEnum(OrderType)
  orderType?: OrderType;
  @ApiProperty({
    type: Number,
    example: 150.5,
    description: 'Subtotal de la orden',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  @IsPositive()
  subtotal?: number;
  @ApiProperty({
    type: Number,
    example: 177.59,
    description: 'Total de la orden',
    required: false,
  })
  @IsOptional()
  @IsNumber()
  @IsPositive()
  total?: number;
  @ApiProperty({
    type: String,
    example: 'Please make it spicy.',
    description: 'Optional notes for the order',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  notes?: string;
  @ApiProperty({
    type: String,
    example: 'CUST-1',
    description: 'ID del cliente',
    required: false,
  })
  @IsOptional()
  @IsString()
  customerId?: string;
  @ApiProperty({
    type: [OrderItemInputDto],
    description: 'Items de la orden',
    required: false,
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Type(() => OrderItemInputDto)
  items?: OrderItemInputDto[];
  @ApiProperty({
    type: DeliveryInfoDto,
    description: 'Información de entrega',
    required: false,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => DeliveryInfoDto)
  deliveryInfo?: DeliveryInfoDto;
  @ApiProperty({
    type: Boolean,
    example: false,
    description: 'Indica si se debe crear una mesa temporal',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isTemporaryTable?: boolean;
  @ApiProperty({
    type: String,
    example: 'Mesa Terraza 1',
    description: 'Nombre de la mesa temporal',
    required: false,
  })
  @IsOptional()
  @IsString()
  temporaryTableName?: string;
  @ApiProperty({
    type: String,
    example: 'AREA-1',
    description: 'ID del área para la mesa temporal',
    required: false,
  })
  @IsOptional()
  @IsString()
  temporaryTableAreaId?: string;
  @ApiProperty({
    type: Array,
    description: 'Ajustes de la orden',
    required: false,
  })
  @IsOptional()
  adjustments?: any[];
}

================
File: backend/src/orders/infrastructure/persistence/relational/entities/ticket-impression.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { OrderEntity } from './order.entity';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { TicketType } from '../../../../domain/enums/ticket-type.enum';
import { ThermalPrinterEntity } from '../../../../../thermal-printers/infrastructure/persistence/relational/entities/thermal-printer.entity';
@Entity({ name: 'ticket_impression' })
export class TicketImpressionEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ name: 'order_id', type: 'uuid' })
  orderId: string;
  @Column({ name: 'user_id', type: 'uuid' })
  userId: string;
  @Column({ name: 'printer_id', type: 'uuid', nullable: true })
  printerId?: string;
  @Column({ type: 'enum', enum: TicketType })
  ticketType: TicketType;
  @Column({ name: 'impression_time', type: 'timestamp with time zone' })
  impressionTime: Date;
  @ManyToOne(() => OrderEntity, (order) => order.ticketImpressions, {
    nullable: false,
  })
  @JoinColumn({ name: 'order_id' })
  order: OrderEntity;
  @ManyToOne(() => UserEntity, {
    nullable: false,
  })
  @JoinColumn({ name: 'user_id' })
  user: UserEntity;
  @ManyToOne(() => ThermalPrinterEntity, {
    nullable: true,
  })
  @JoinColumn({ name: 'printer_id' })
  printer?: ThermalPrinterEntity;
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/orders/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { OrderEntity } from './entities/order.entity';
import { OrderItemEntity } from './entities/order-item.entity';
import { TicketImpressionEntity } from './entities/ticket-impression.entity';
import { OrderHistoryEntity } from './entities/order-history.entity';
import { DeliveryInfoEntity } from './entities/delivery-info.entity';
import { OrderPreparationScreenStatusEntity } from './entities/order-preparation-screen-status.entity';
import { OrdersRelationalRepository } from './repositories/order.repository';
import { OrderItemRelationalRepository } from './repositories/order-item.repository';
import { TicketImpressionRelationalRepository } from './repositories/ticket-impression-relational.repository';
import { OrderHistoryRelationalRepository } from './repositories/order-history.repository';
import { OrderPreparationScreenStatusRelationalRepository } from './repositories/order-preparation-screen-status.repository';
import { OrderMapper } from './mappers/order.mapper';
import { OrderItemMapper } from './mappers/order-item.mapper';
import { TicketImpressionMapper } from './mappers/ticket-impression.mapper';
import { DeliveryInfoMapper } from './mappers/delivery-info.mapper';
import { OrderPreparationScreenStatusMapper } from './mappers/order-preparation-screen-status.mapper';
import {
  ORDER_REPOSITORY,
  ORDER_ITEM_REPOSITORY,
  TICKET_IMPRESSION_REPOSITORY,
  ORDER_HISTORY_REPOSITORY,
  ORDER_PREPARATION_SCREEN_STATUS_REPOSITORY,
} from '../../../../common/tokens';
import { RelationalUserPersistenceModule } from '../../../../users/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalTablePersistenceModule } from '../../../../tables/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalPaymentPersistenceModule } from '../../../../payments/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalProductPersistenceModule } from '../../../../products/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalProductVariantPersistenceModule } from '../../../../product-variants/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalProductModifierPersistenceModule } from '../../../../product-modifiers/infrastructure/persistence/relational/relational-persistence.module';
import { AdjustmentsRelationalPersistenceModule } from '../../../../adjustments/infrastructure/persistence/relational/relational-persistence.module';
import { ShiftsModule } from '../../../../shifts/shifts.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([
      OrderEntity,
      OrderItemEntity,
      TicketImpressionEntity,
      OrderHistoryEntity,
      DeliveryInfoEntity,
      OrderPreparationScreenStatusEntity,
    ]),
    RelationalUserPersistenceModule,
    RelationalTablePersistenceModule,
    forwardRef(() => RelationalPaymentPersistenceModule),
    RelationalProductPersistenceModule,
    RelationalProductVariantPersistenceModule,
    RelationalProductModifierPersistenceModule,
    forwardRef(() => AdjustmentsRelationalPersistenceModule),
    forwardRef(() => ShiftsModule),
  ],
  providers: [
    {
      provide: ORDER_REPOSITORY,
      useClass: OrdersRelationalRepository,
    },
    {
      provide: ORDER_ITEM_REPOSITORY,
      useClass: OrderItemRelationalRepository,
    },
    {
      provide: TICKET_IMPRESSION_REPOSITORY,
      useClass: TicketImpressionRelationalRepository,
    },
    {
      provide: ORDER_HISTORY_REPOSITORY,
      useClass: OrderHistoryRelationalRepository,
    },
    {
      provide: ORDER_PREPARATION_SCREEN_STATUS_REPOSITORY,
      useClass: OrderPreparationScreenStatusRelationalRepository,
    },
    OrderMapper,
    OrderItemMapper,
    TicketImpressionMapper,
    DeliveryInfoMapper,
    OrderPreparationScreenStatusMapper,
  ],
  exports: [
    ORDER_REPOSITORY,
    ORDER_ITEM_REPOSITORY,
    TICKET_IMPRESSION_REPOSITORY,
    ORDER_HISTORY_REPOSITORY,
    ORDER_PREPARATION_SCREEN_STATUS_REPOSITORY,
    OrderMapper,
    OrderItemMapper,
    TicketImpressionMapper,
    DeliveryInfoMapper,
    OrderPreparationScreenStatusMapper,
  ],
})
export class RelationalOrderPersistenceModule {}

================
File: backend/src/orders/infrastructure/persistence/relational/repositories/ticket-impression-relational.repository.ts
================
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FindOptionsWhere, Repository } from 'typeorm';
import { NullableType } from '../../../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../../../utils/types/pagination-options';
import { TicketImpression } from '../../../../domain/ticket-impression';
import { TicketImpressionRepository } from '../../ticket-impression.repository';
import { TicketImpressionEntity } from '../entities/ticket-impression.entity';
import { TicketImpressionMapper } from '../mappers/ticket-impression.mapper';
import { TicketType } from '../../../../domain/enums/ticket-type.enum';
@Injectable()
export class TicketImpressionRelationalRepository
  implements TicketImpressionRepository
{
  constructor(
    @InjectRepository(TicketImpressionEntity)
    private readonly repository: Repository<TicketImpressionEntity>,
    private readonly ticketImpressionMapper: TicketImpressionMapper,
  ) {}
  async create(
    data: Omit<
      TicketImpression,
      'id' | 'createdAt' | 'deletedAt' | 'updatedAt' | 'order' | 'user'
    >,
  ): Promise<TicketImpression> {
    const persistenceModel = this.ticketImpressionMapper.toEntity(
      data as TicketImpression,
    );
    if (!persistenceModel) {
      throw new InternalServerErrorException(
        'Error creating ticket impression entity',
      );
    }
    const newEntity = await this.repository.save(
      this.repository.create(persistenceModel),
    );
    const completeEntity = await this.repository.findOne({
      where: { id: newEntity.id },
      relations: ['order', 'user', 'printer'],
    });
    if (!completeEntity) {
      throw new InternalServerErrorException(
        'Failed to load created ticket impression after saving',
      );
    }
    const domainResult = this.ticketImpressionMapper.toDomain(completeEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping saved ticket impression entity to domain',
      );
    }
    return domainResult;
  }
  async findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: {
      orderId?: string;
      userId?: string;
      ticketType?: string;
    } | null;
    paginationOptions: IPaginationOptions;
  }): Promise<TicketImpression[]> {
    const where: FindOptionsWhere<TicketImpressionEntity> = {};
    if (filterOptions?.orderId) {
      where.orderId = filterOptions.orderId;
    }
    if (filterOptions?.userId) {
      where.userId = filterOptions.userId;
    }
    if (filterOptions?.ticketType) {
      where.ticketType = filterOptions.ticketType as TicketType;
    }
    const entities = await this.repository.find({
      skip: (paginationOptions.page - 1) * paginationOptions.limit,
      take: paginationOptions.limit,
      where: where,
      relations: ['order', 'user', 'printer'],
      order: {
        impressionTime: 'DESC',
      },
    });
    return entities
      .map((entity) => this.ticketImpressionMapper.toDomain(entity))
      .filter((item): item is TicketImpression => item !== null);
  }
  async findById(
    id: TicketImpression['id'],
  ): Promise<NullableType<TicketImpression>> {
    const entity = await this.repository.findOne({
      where: { id },
      relations: ['order', 'user', 'printer'],
    });
    const domainResult = entity
      ? this.ticketImpressionMapper.toDomain(entity)
      : null;
    return domainResult;
  }
  async findByOrderId(
    orderId: TicketImpression['orderId'],
  ): Promise<TicketImpression[]> {
    const entities = await this.repository.find({
      where: { orderId },
      relations: ['order', 'user', 'printer'],
      order: {
        impressionTime: 'DESC',
      },
    });
    return entities
      .map((entity) => this.ticketImpressionMapper.toDomain(entity))
      .filter((item): item is TicketImpression => item !== null);
  }
}

================
File: backend/src/orders/services/order-change-tracker-v2.service.ts
================
import { Injectable } from '@nestjs/common';
import { EntityManager } from 'typeorm';
import { OrderEntity } from '../infrastructure/persistence/relational/entities/order.entity';
import { OrderHistoryEntity } from '../infrastructure/persistence/relational/entities/order-history.entity';
import { classToPlain } from 'class-transformer';
export interface ConsolidatedChangesV2 {
  order?: {
    fields?: any;
    deliveryInfo?: any;
  };
  items?: {
    added?: any[];
    modified?: any[];
    removed?: any[];
  };
  summary?: string;
}
@Injectable()
export class OrderChangeTrackerV2Service {
  async trackOrderWithItems(
    operation: 'INSERT' | 'UPDATE' | 'DELETE',
    order: OrderEntity,
    previousState: OrderEntity | null,
    changedBy: string,
    manager: EntityManager,
  ): Promise<void> {
    let changes: ConsolidatedChangesV2 | null = null;
    if (operation === 'INSERT') {
      changes = this.createInsertDiff(order);
    } else if (operation === 'UPDATE' && previousState) {
      changes = this.detectChangesUsingSnapshots(order, previousState);
    }
    if (changes || operation !== 'UPDATE') {
      const historyRecord = manager.create(OrderHistoryEntity, {
        orderId: order.id,
        operation,
        changedBy,
        diff: changes,
        snapshot: this.createOrderSnapshot(order),
      });
      await manager.save(historyRecord);
    }
  }
  private createInsertDiff(order: OrderEntity): ConsolidatedChangesV2 {
    const changes: ConsolidatedChangesV2 = {};
    changes.order = {
      fields: {
        orderType: [null, order.orderType],
        orderStatus: [null, order.orderStatus],
        ...(order.tableId && { tableId: [null, order.tableId] }),
        ...(order.notes && { notes: [null, order.notes] }),
      },
    };
    if (order.deliveryInfo) {
      changes.order.deliveryInfo = {};
      const info = order.deliveryInfo;
      if (info.recipientName)
        changes.order.deliveryInfo.recipientName = [null, info.recipientName];
      if (info.recipientPhone)
        changes.order.deliveryInfo.recipientPhone = [null, info.recipientPhone];
      if (info.fullAddress)
        changes.order.deliveryInfo.fullAddress = [null, info.fullAddress];
    }
    if (order.orderItems && order.orderItems.length > 0) {
      changes.items = {
        added: order.orderItems.map((item) => this.createItemSnapshot(item)),
      };
    }
    const itemCount = order.orderItems?.length || 0;
    changes.summary = `Nueva orden creada con ${itemCount} producto${itemCount !== 1 ? 's' : ''}`;
    return changes;
  }
  detectChangesUsingSnapshots(
    current: OrderEntity,
    previous: OrderEntity,
  ): ConsolidatedChangesV2 | null {
    const changes: ConsolidatedChangesV2 = {};
    let hasChanges = false;
    const orderFieldChanges = this.detectOrderFieldChanges(current, previous);
    if (orderFieldChanges) {
      changes.order = orderFieldChanges;
      hasChanges = true;
    }
    const currentSnapshot = this.createOrderSnapshot(current);
    const previousSnapshot = this.createOrderSnapshot(previous);
    const itemChanges = this.compareItemSnapshots(
      currentSnapshot.orderItems || [],
      previousSnapshot.orderItems || [],
    );
    if (itemChanges) {
      changes.items = itemChanges;
      hasChanges = true;
    }
    if (!hasChanges) return null;
    const summaryParts: string[] = [];
    if (changes.order?.fields) {
      const fields = Object.keys(changes.order.fields);
      if (fields.length > 0) {
        summaryParts.push(`Orden: ${fields.join(', ')}`);
      }
    }
    if (changes.items) {
      const itemParts: string[] = [];
      if (changes.items.added?.length)
        itemParts.push(`${changes.items.added.length} agregados`);
      if (changes.items.modified?.length)
        itemParts.push(`${changes.items.modified.length} modificados`);
      if (changes.items.removed?.length)
        itemParts.push(`${changes.items.removed.length} eliminados`);
      if (itemParts.length > 0) {
        summaryParts.push(`Productos: ${itemParts.join(', ')}`);
      }
    }
    changes.summary = summaryParts.join(' | ');
    return changes;
  }
  detectStructuralChangesOnly(
    current: OrderEntity,
    previous: OrderEntity,
  ): boolean {
    const structuralFields = ['notes', 'scheduledAt', 'estimatedDeliveryTime'];
    let hasStructuralChanges = false;
    for (const field of structuralFields) {
      const currentValue = (current as any)[field];
      const previousValue = (previous as any)[field];
      if (field === 'estimatedDeliveryTime' || field === 'scheduledAt') {
        const currentTime = currentValue
          ? new Date(currentValue).getTime()
          : null;
        const previousTime = previousValue
          ? new Date(previousValue).getTime()
          : null;
        if (currentTime !== previousTime) {
          hasStructuralChanges = true;
          break;
        }
      } else if (currentValue !== previousValue) {
        hasStructuralChanges = true;
        break;
      }
    }
    if (current.deliveryInfo || previous.deliveryInfo) {
      const deliveryChanges = this.compareDeliveryInfo(
        previous.deliveryInfo || {},
        current.deliveryInfo || {},
      );
      if (deliveryChanges) {
        hasStructuralChanges = true;
      }
    }
    const currentSnapshot = this.createOrderSnapshot(current);
    const previousSnapshot = this.createOrderSnapshot(previous);
    const itemChanges = this.compareItemSnapshots(
      currentSnapshot.orderItems || [],
      previousSnapshot.orderItems || [],
    );
    if (itemChanges) {
      hasStructuralChanges = true;
    }
    return hasStructuralChanges;
  }
  private detectOrderFieldChanges(
    current: OrderEntity,
    previous: OrderEntity,
  ): any {
    const fields: any = {};
    let hasChanges = false;
    const compareFields = [
      'orderStatus',
      'orderType',
      'notes',
      'tableId',
      'customerId',
      'scheduledAt',
      'estimatedDeliveryTime',
      'isFromWhatsApp',
    ];
    for (const field of compareFields) {
      const currentValue = (current as any)[field];
      const previousValue = (previous as any)[field];
      if (field === 'estimatedDeliveryTime' || field === 'scheduledAt') {
        const currentTime = currentValue
          ? new Date(currentValue).getTime()
          : null;
        const previousTime = previousValue
          ? new Date(previousValue).getTime()
          : null;
        if (currentTime !== previousTime) {
          fields[field] = [previousValue, currentValue];
          hasChanges = true;
        }
      } else if (currentValue !== previousValue) {
        fields[field] = [previousValue, currentValue];
        hasChanges = true;
      }
    }
    if (current.deliveryInfo || previous.deliveryInfo) {
      const deliveryChanges = this.compareDeliveryInfo(
        previous.deliveryInfo || {},
        current.deliveryInfo || {},
      );
      if (deliveryChanges) {
        return {
          fields: hasChanges ? fields : undefined,
          deliveryInfo: deliveryChanges,
        };
      }
    }
    return hasChanges ? { fields } : null;
  }
  private compareDeliveryInfo(previous: any, current: any): any {
    const fields = [
      'recipientName',
      'recipientPhone',
      'fullAddress',
      'deliveryInstructions',
    ];
    const changes: any = {};
    let hasChanges = false;
    for (const field of fields) {
      if (previous[field] !== current[field]) {
        changes[field] = [previous[field], current[field]];
        hasChanges = true;
      }
    }
    return hasChanges ? changes : null;
  }
  private compareItemSnapshots(currentItems: any[], previousItems: any[]): any {
    const changes: any = {};
    const currentMap = new Map(currentItems.map((item) => [item.id, item]));
    const previousMap = new Map(previousItems.map((item) => [item.id, item]));
    const added: any[] = [];
    for (const [id, item] of currentMap) {
      if (!previousMap.has(id)) {
        added.push(this.normalizeItemSnapshot(item));
      }
    }
    const removed: any[] = [];
    for (const [id, item] of previousMap) {
      if (!currentMap.has(id)) {
        removed.push(this.normalizeItemSnapshot(item));
      }
    }
    const modified: any[] = [];
    for (const [id, currentItem] of currentMap) {
      const previousItem = previousMap.get(id);
      if (previousItem) {
        const itemChanges = this.detectItemChanges(currentItem, previousItem);
        if (itemChanges.length > 0) {
          modified.push({
            id,
            before: this.normalizeItemSnapshot(previousItem),
            after: this.normalizeItemSnapshot(currentItem),
          });
        }
      }
    }
    if (added.length > 0) changes.added = added;
    if (modified.length > 0) changes.modified = modified;
    if (removed.length > 0) changes.removed = removed;
    return Object.keys(changes).length > 0 ? changes : null;
  }
  private detectItemChanges(current: any, previous: any): string[] {
    const changes: string[] = [];
    if (
      current.productId !== previous.productId ||
      current.productName !== previous.productName
    ) {
      changes.push('producto');
    }
    if (
      current.variantId !== previous.variantId ||
      current.variantName !== previous.variantName
    ) {
      changes.push('variante');
    }
    const currentPrice = parseFloat(current.finalPrice || current.price || '0');
    const previousPrice = parseFloat(
      previous.finalPrice || previous.price || '0',
    );
    if (Math.abs(currentPrice - previousPrice) > 0.01) {
      changes.push('precio');
    }
    const currentMods = JSON.stringify((current.modifiers || []).sort());
    const previousMods = JSON.stringify((previous.modifiers || []).sort());
    if (currentMods !== previousMods) {
      changes.push('modificadores');
    }
    const currentCustom = JSON.stringify((current.customizations || []).sort());
    const previousCustom = JSON.stringify(
      (previous.customizations || []).sort(),
    );
    if (currentCustom !== previousCustom) {
      changes.push('personalizaciones');
    }
    if (current.preparationNotes !== previous.preparationNotes) {
      changes.push('notas');
    }
    if (current.preparationStatus !== previous.preparationStatus) {
      changes.push('estado_preparacion');
    }
    return changes;
  }
  private normalizeItemSnapshot(item: any): any {
    return {
      id: item.id,
      productId: item.productId,
      productName: item.productName || 'Producto',
      variantId: item.variantId,
      variantName: item.variantName,
      quantity: 1,
      modifiers: item.modifiers || [],
      customizations: item.customizations || [],
      finalPrice: parseFloat(item.finalPrice || item.price || '0'),
      basePrice: parseFloat(item.basePrice || '0'),
      preparationNotes: item.preparationNotes || item.notes || undefined,
      preparationStatus: item.preparationStatus,
    };
  }
  private createItemSnapshot(item: any): any {
    const snapshot = {
      id: item.id,
      productId: item.productId,
      productName: item.product?.name || item.productName || 'Producto',
      variantId: item.productVariantId || item.variantId,
      variantName: item.productVariant?.name || item.variantName,
      basePrice: item.basePrice,
      finalPrice: item.finalPrice,
      preparationStatus: item.preparationStatus,
      preparationNotes: item.preparationNotes,
      modifiers:
        item.productModifiers?.map((m: any) => m.name) || item.modifiers || [],
      customizations:
        item.selectedPizzaCustomizations?.map((pc: any) => {
          const action = pc.action === 'ADD' ? '+' : '-';
          const half = pc.half ? ` (${pc.half})` : '';
          return `${action}${pc.pizzaCustomization?.name || 'Personalización'}${half}`;
        }) ||
        item.customizations ||
        [],
    };
    return snapshot;
  }
  private createOrderSnapshot(order: OrderEntity): any {
    const snapshot = classToPlain(order);
    if (order.orderItems) {
      snapshot.orderItems = order.orderItems.map((item) =>
        this.createItemSnapshot(item),
      );
    }
    return snapshot;
  }
}

================
File: backend/src/payments/domain/payment.ts
================
import { Order } from '../../orders/domain/order';
import { PaymentMethod } from './enums/payment-method.enum';
import { PaymentStatus } from './enums/payment-status.enum';
export { PaymentStatus } from './enums/payment-status.enum';
export { PaymentMethod } from './enums/payment-method.enum';
export class Payment {
  id: string;
  orderId: string | null;
  paymentMethod: PaymentMethod;
  amount: number;
  paymentStatus: PaymentStatus;
  order: Order | null;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/payments/infrastructure/persistence/payment.repository.ts
================
import { Payment } from '../../domain/payment';
export interface PaymentRepository {
  findAll(): Promise<Payment[]>;
  findById(id: string): Promise<Payment | null>;
  findByOrderId(orderId: string): Promise<Payment[]>;
  findByDateRange(startDate: Date, endDate: Date): Promise<Payment[]>;
  create(payment: Payment): Promise<Payment>;
  update(id: string, payment: Payment): Promise<Payment>;
  delete(id: string): Promise<void>;
}

================
File: backend/src/payments/infrastructure/persistence/relational/repositories/payment.repository.ts
================
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between } from 'typeorm';
import { PaymentEntity } from '../entities/payment.entity';
import { PaymentRepository } from '../../payment.repository';
import { Payment } from '../../../../domain/payment';
import { PaymentMapper } from '../mappers/payment.mapper';
@Injectable()
export class RelationalPaymentRepository implements PaymentRepository {
  constructor(
    @InjectRepository(PaymentEntity)
    private readonly paymentRepository: Repository<PaymentEntity>,
    private readonly paymentMapper: PaymentMapper,
  ) {}
  async findAll(): Promise<Payment[]> {
    const paymentEntities = await this.paymentRepository.find();
    return paymentEntities
      .map((entity) => this.paymentMapper.toDomain(entity))
      .filter((item): item is Payment => item !== null);
  }
  async findById(id: string): Promise<Payment | null> {
    const paymentEntity = await this.paymentRepository.findOne({
      where: { id },
    });
    return paymentEntity ? this.paymentMapper.toDomain(paymentEntity) : null;
  }
  async findByOrderId(orderId: string): Promise<Payment[]> {
    const paymentEntities = await this.paymentRepository.find({
      where: { order: { id: orderId } },
      relations: ['order'],
    });
    return paymentEntities
      .map((entity) => this.paymentMapper.toDomain(entity))
      .filter((item): item is Payment => item !== null);
  }
  async findByDateRange(startDate: Date, endDate: Date): Promise<Payment[]> {
    const paymentEntities = await this.paymentRepository.find({
      where: {
        createdAt: Between(startDate, endDate),
      },
      relations: ['order'],
    });
    return paymentEntities
      .map((entity) => this.paymentMapper.toDomain(entity))
      .filter((item): item is Payment => item !== null);
  }
  async create(payment: Payment): Promise<Payment> {
    const paymentEntity = this.paymentMapper.toEntity(payment);
    if (!paymentEntity) {
      throw new InternalServerErrorException('Error creating payment entity');
    }
    const savedEntity = await this.paymentRepository.save(paymentEntity);
    const domainResult = this.paymentMapper.toDomain(savedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping saved payment entity to domain',
      );
    }
    return domainResult;
  }
  async update(id: string, payment: Payment): Promise<Payment> {
    const updateData: any = {};
    if (payment.paymentMethod !== undefined) {
      updateData.paymentMethod = payment.paymentMethod;
    }
    if (payment.amount !== undefined) {
      updateData.amount = payment.amount;
    }
    if (payment.paymentStatus !== undefined) {
      updateData.paymentStatus = payment.paymentStatus;
    }
    await this.paymentRepository.update(id, updateData);
    const updatedEntity = await this.paymentRepository.findOne({
      where: { id },
    });
    if (!updatedEntity) {
      throw new NotFoundException(
        `Payment with ID ${id} not found after update`,
      );
    }
    const domainResult = this.paymentMapper.toDomain(updatedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping updated payment entity to domain',
      );
    }
    return domainResult;
  }
  async delete(id: string): Promise<void> {
    const result = await this.paymentRepository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(`Payment with ID ${id} not found`);
    }
  }
}

================
File: backend/src/products/infrastructure/persistence/relational/repositories/product.repository.ts
================
import {
  Injectable,
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { ILike, In, Repository } from 'typeorm';
import { ProductEntity } from '../entities/product.entity';
import { ProductRepository } from '../../product.repository';
import { Product } from '../../../../domain/product';
import { ProductMapper } from '../mappers/product.mapper';
import { Paginated } from '../../../../../common/types/paginated.type';
@Injectable()
export class ProductRelationalRepository implements ProductRepository {
  constructor(
    @InjectRepository(ProductEntity)
    private readonly productRepository: Repository<ProductEntity>,
    private readonly productMapper: ProductMapper,
  ) {}
  async create(product: Product): Promise<Product> {
    const entity = this.productMapper.toEntity(product);
    if (!entity) {
      throw new InternalServerErrorException('Error creating product entity');
    }
    const savedEntity = await this.productRepository.save(entity);
    const domainResult = this.productMapper.toDomain(savedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping saved product entity to domain',
      );
    }
    return domainResult;
  }
  async findAll(options: {
    page: number;
    limit: number;
    subcategoryId?: string;
    hasVariants?: boolean;
    isActive?: boolean;
    search?: string;
  }): Promise<Paginated<Product>> {
    const where: any = {};
    if (options.subcategoryId) {
      where.subcategory = { id: options.subcategoryId };
    }
    if (options.hasVariants !== undefined) {
      where.hasVariants = options.hasVariants;
    }
    if (options.isActive !== undefined) {
      where.isActive = options.isActive;
    }
    if (options.search) {
      where.name = ILike(`%${options.search}%`);
    }
    const [entities, count] = await this.productRepository.findAndCount({
      where,
      skip: (options.page - 1) * options.limit,
      take: options.limit,
      relations: [
        'photo',
        'subcategory',
        'variants',
        'modifierGroups',
        'modifierGroups.productModifiers',
        'preparationScreen',
      ],
      order: {
        sortOrder: 'ASC',
        name: 'ASC',
      },
    });
    const products = entities
      .map((entity) => this.productMapper.toDomain(entity))
      .filter((item): item is Product => item !== null);
    return new Paginated(products, count, options.page, options.limit);
  }
  async findOne(id: string): Promise<Product> {
    const entity = await this.productRepository.findOne({
      where: { id },
      relations: [
        'photo',
        'subcategory',
        'variants',
        'modifierGroups',
        'modifierGroups.productModifiers',
        'preparationScreen',
      ],
    });
    if (!entity) {
      throw new NotFoundException(`Producto con ID ${id} no encontrado`);
    }
    const domainResult = this.productMapper.toDomain(entity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping found product entity to domain',
      );
    }
    return domainResult;
  }
  async findByIds(ids: string[]): Promise<Product[]> {
    if (!ids || ids.length === 0) {
      return [];
    }
    const entities = await this.productRepository.find({
      where: { id: In(ids) },
    });
    return entities
      .map((entity) => this.productMapper.toDomain(entity))
      .filter((item): item is Product => item !== null);
  }
  async update(
    id: string,
    productUpdatePayload: Partial<Product>,
  ): Promise<Product | null> {
    const entity = this.productMapper.toEntity(productUpdatePayload as Product);
    if (!entity) {
      throw new InternalServerErrorException(
        'Error creating product entity for update',
      );
    }
    const updateResult = await this.productRepository.update(id, entity);
    if (updateResult.affected === 0) {
      return null;
    }
    const updatedEntity = await this.productRepository.findOne({
      where: { id },
      relations: [
        'photo',
        'subcategory',
        'variants',
        'modifierGroups',
        'modifierGroups.productModifiers',
        'preparationScreen',
      ],
    });
    if (!updatedEntity) {
      throw new NotFoundException(
        `Producto con ID ${id} no encontrado después de actualizar`,
      );
    }
    const domainResult = this.productMapper.toDomain(updatedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping updated product entity to domain',
      );
    }
    return domainResult;
  }
  async save(product: Product): Promise<Product> {
    const entity = this.productMapper.toEntity(product);
    if (!entity) {
      throw new InternalServerErrorException(
        'Error creating product entity for save',
      );
    }
    const savedEntity = await this.productRepository.save(entity);
    const reloadedEntity = await this.productRepository.findOne({
      where: { id: savedEntity.id },
      relations: [
        'photo',
        'subcategory',
        'variants',
        'modifierGroups',
        'modifierGroups.productModifiers',
        'preparationScreen',
      ],
    });
    if (!reloadedEntity) {
      throw new NotFoundException(
        `Producto con ID ${savedEntity.id} no encontrado después de guardar`,
      );
    }
    const domainResult = this.productMapper.toDomain(reloadedEntity);
    if (!domainResult) {
      throw new InternalServerErrorException(
        'Error mapping reloaded product entity to domain',
      );
    }
    return domainResult;
  }
  async softDelete(id: string): Promise<void> {
    const result = await this.productRepository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(`Producto con ID ${id} no encontrado`);
    }
  }
  async updatePreparationScreen(
    productId: string,
    preparationScreenId: string,
  ): Promise<void> {
    const result = await this.productRepository.update(productId, {
      preparationScreenId: preparationScreenId,
    });
    if (result.affected === 0) {
      throw new NotFoundException(`Producto con ID ${productId} no encontrado`);
    }
  }
  async findOneWithPizzaCustomizations(id: string): Promise<Product | null> {
    const entity = await this.productRepository.findOne({
      where: { id },
      relations: ['pizzaCustomizations'],
    });
    if (!entity) {
      return null;
    }
    const domainResult = this.productMapper.toDomain(entity);
    return domainResult;
  }
  async updatePizzaCustomizations(
    productId: string,
    pizzaCustomizationIds: string[],
  ): Promise<void> {
    const product = await this.productRepository.findOne({
      where: { id: productId },
      relations: ['pizzaCustomizations'],
    });
    if (!product) {
      throw new NotFoundException(`Producto con ID ${productId} no encontrado`);
    }
    await this.productRepository
      .createQueryBuilder()
      .relation(ProductEntity, 'pizzaCustomizations')
      .of(product)
      .addAndRemove(
        pizzaCustomizationIds,
        product.pizzaCustomizations.map((pc) => pc.id),
      );
  }
  async findAllPizzas(): Promise<Product[]> {
    const entities = await this.productRepository.find({
      where: { isPizza: true, isActive: true },
      relations: [
        'photo',
        'subcategory',
        'pizzaCustomizations',
        'pizzaConfiguration',
        'variants',
      ],
      order: {
        sortOrder: 'ASC',
        name: 'ASC',
      },
    });
    return entities
      .map((entity) => this.productMapper.toDomain(entity))
      .filter((item): item is Product => item !== null);
  }
}

================
File: backend/src/restaurant-config/restaurant-config.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { RestaurantConfigService } from './restaurant-config.service';
import { RestaurantConfigController } from './restaurant-config.controller';
import { RelationalRestaurantConfigPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { ShiftsModule } from '../shifts/shifts.module';
@Module({
  imports: [
    RelationalRestaurantConfigPersistenceModule,
    forwardRef(() => ShiftsModule),
  ],
  controllers: [RestaurantConfigController],
  providers: [RestaurantConfigService],
  exports: [RestaurantConfigService],
})
export class RestaurantConfigModule {}

================
File: backend/src/shifts/dto/close-shift.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNumber, IsOptional, IsString, Min } from 'class-validator';
import { Transform } from 'class-transformer';
export class CloseShiftDto {
  @ApiProperty({
    description: 'Efectivo final contado en caja',
    example: 2500.0,
    minimum: 0,
  })
  @IsNumber()
  @Min(0)
  @Transform(({ value }) => parseFloat(value))
  finalCash: number;
  @ApiProperty({
    description: 'Notas opcionales de cierre',
    example: 'Cierre sin novedades, todo cuadra',
    required: false,
  })
  @IsOptional()
  @IsString()
  closeNotes?: string;
}

================
File: backend/src/shifts/dto/open-shift.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsNumber,
  IsOptional,
  IsString,
  Min,
  IsDateString,
} from 'class-validator';
import { Transform } from 'class-transformer';
export class OpenShiftDto {
  @ApiProperty({
    description: 'Efectivo inicial en caja',
    example: 500.0,
    minimum: 0,
  })
  @IsNumber()
  @Min(0)
  @Transform(({ value }) => parseFloat(value))
  initialCash: number;
  @ApiProperty({
    description: 'Notas opcionales de apertura',
    example: 'Apertura normal del turno',
    required: false,
  })
  @IsOptional()
  @IsString()
  notes?: string;
  @ApiProperty({
    description: 'Fecha del turno (opcional, por defecto hoy)',
    example: '2024-01-15',
    required: false,
  })
  @IsOptional()
  @IsDateString()
  date?: string;
}

================
File: backend/src/shifts/infrastructure/persistence/relational/entities/shift.entity.ts
================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  Index,
} from 'typeorm';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { ShiftStatus } from '../../../../domain/shift';
@Entity('shift')
@Index('IDX_shift_date', ['date'])
@Index('IDX_shift_status', ['status'])
@Index('IDX_shift_date_shift_number', ['date', 'shiftNumber'], { unique: true })
export class ShiftEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ type: 'date' })
  date: Date;
  @Column({ name: 'global_shift_number', type: 'int' })
  globalShiftNumber: number;
  @Column({ name: 'shift_number', type: 'int', default: 1 })
  shiftNumber: number;
  @Column({ name: 'opened_at', type: 'timestamptz' })
  openedAt: Date;
  @Column({ name: 'closed_at', type: 'timestamptz', nullable: true })
  closedAt: Date | null;
  @ManyToOne(() => UserEntity, { eager: true })
  @JoinColumn({ name: 'opened_by_id' })
  openedBy: UserEntity;
  @ManyToOne(() => UserEntity, { eager: true, nullable: true })
  @JoinColumn({ name: 'closed_by_id' })
  closedBy: UserEntity | null;
  @Column({ name: 'initial_cash', type: 'decimal', precision: 10, scale: 2 })
  initialCash: number;
  @Column({
    name: 'final_cash',
    type: 'decimal',
    precision: 10,
    scale: 2,
    nullable: true,
  })
  finalCash: number | null;
  @Column({
    name: 'total_sales',
    type: 'decimal',
    precision: 10,
    scale: 2,
    nullable: true,
  })
  totalSales: number | null;
  @Column({ name: 'total_orders', type: 'int', nullable: true })
  totalOrders: number | null;
  @Column({
    name: 'cash_difference',
    type: 'decimal',
    precision: 10,
    scale: 2,
    nullable: true,
  })
  cashDifference: number | null;
  @Column({
    type: 'enum',
    enum: ShiftStatus,
    default: ShiftStatus.OPEN,
  })
  status: ShiftStatus;
  @Column({ type: 'text', nullable: true })
  notes: string | null;
  @Column({ name: 'close_notes', type: 'text', nullable: true })
  closeNotes: string | null;
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/shifts/infrastructure/persistence/relational/mappers/shift.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { Shift } from '../../../../domain/shift';
import { ShiftEntity } from '../entities/shift.entity';
import { UserMapper } from '../../../../../users/infrastructure/persistence/relational/mappers/user.mapper';
@Injectable()
export class ShiftMapper {
  constructor(private readonly userMapper: UserMapper) {}
  toDomain(entity: ShiftEntity): Shift | null {
    if (!entity) {
      return null;
    }
    const domain = new Shift();
    domain.id = entity.id;
    domain.date = entity.date;
    domain.globalShiftNumber = entity.globalShiftNumber;
    domain.shiftNumber = entity.shiftNumber;
    domain.openedAt = entity.openedAt;
    domain.closedAt = entity.closedAt;
    domain.openedBy = this.userMapper.toDomain(entity.openedBy)!;
    domain.closedBy = entity.closedBy
      ? this.userMapper.toDomain(entity.closedBy)
      : null;
    domain.initialCash = Number(entity.initialCash);
    domain.finalCash = entity.finalCash ? Number(entity.finalCash) : null;
    domain.totalSales = entity.totalSales ? Number(entity.totalSales) : null;
    domain.totalOrders = entity.totalOrders;
    domain.cashDifference = entity.cashDifference
      ? Number(entity.cashDifference)
      : null;
    domain.status = entity.status;
    domain.notes = entity.notes;
    domain.closeNotes = entity.closeNotes;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  toPersistence(domain: Shift): ShiftEntity {
    const entity = new ShiftEntity();
    entity.id = domain.id;
    entity.date = domain.date;
    entity.globalShiftNumber = domain.globalShiftNumber;
    entity.shiftNumber = domain.shiftNumber;
    entity.openedAt = domain.openedAt;
    entity.closedAt = domain.closedAt;
    const openedByEntity = this.userMapper.toEntity(domain.openedBy);
    if (!openedByEntity) {
      throw new Error('Failed to map openedBy user to entity');
    }
    entity.openedBy = openedByEntity;
    entity.closedBy = domain.closedBy
      ? this.userMapper.toEntity(domain.closedBy)
      : null;
    entity.initialCash = domain.initialCash;
    entity.finalCash = domain.finalCash;
    entity.totalSales = domain.totalSales;
    entity.totalOrders = domain.totalOrders;
    entity.cashDifference = domain.cashDifference;
    entity.status = domain.status;
    entity.notes = domain.notes;
    entity.closeNotes = domain.closeNotes;
    entity.createdAt = domain.createdAt;
    entity.updatedAt = domain.updatedAt;
    entity.deletedAt = domain.deletedAt;
    return entity;
  }
}

================
File: backend/src/shifts/infrastructure/persistence/relational/relational-persistence.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ShiftEntity } from './entities/shift.entity';
import { ShiftRepository } from '../shift.repository';
import { ShiftRelationalRepository } from './repositories/shift.repository';
import { ShiftMapper } from './mappers/shift.mapper';
import { UsersModule } from '../../../../users/users.module';
@Module({
  imports: [TypeOrmModule.forFeature([ShiftEntity]), UsersModule],
  providers: [
    {
      provide: ShiftRepository,
      useClass: ShiftRelationalRepository,
    },
    ShiftMapper,
  ],
  exports: [ShiftRepository],
})
export class RelationalShiftPersistenceModule {}

================
File: backend/src/thermal-printers/discovery.service.ts
================
import { Injectable, Logger } from '@nestjs/common';
import { networkInterfaces } from 'os';
import net from 'net';
import pLimit from 'p-limit';
import { exec } from 'child_process';
import { promisify } from 'util';
import { DiscoveredPrinterDto } from './dto/discovered-printer.dto';
const execPromise = promisify(exec);
interface TcpScanOptions {
  scanTimeout?: number;
  maxConcurrency?: number;
  ports?: number[];
  subnet?: string | null;
}
@Injectable()
export class DiscoveryService {
  private readonly logger = new Logger(DiscoveryService.name);
  async discoverPrinters(
    opts: TcpScanOptions = {},
  ): Promise<DiscoveredPrinterDto[]> {
    const {
      scanTimeout = 1000,
      maxConcurrency = 100,
      ports = [9100, 631, 515],
      subnet = null,
    } = opts;
    const found = new Map<string, DiscoveredPrinterDto>();
    try {
      await this.scanTcpAndArp(found, {
        ports,
        scanTimeout,
        maxConcurrency,
        subnet,
      });
    } catch (error) {
      this.logger.error(
        `Error durante el escaneo TCP/ARP: ${error.message}`,
        error.stack,
      );
    }
    this.logger.log(
      `Descubrimiento TCP finalizado. Total impresoras encontradas: ${found.size}`,
    );
    return [...found.values()];
  }
  private async scanTcpAndArp(
    store: Map<string, DiscoveredPrinterDto>,
    cfg: {
      ports: number[];
      scanTimeout: number;
      maxConcurrency: number;
      subnet?: string | null;
    },
  ): Promise<void> {
    const { ports, scanTimeout, maxConcurrency, subnet } = cfg;
    let networkIp: string;
    let mask: number;
    try {
      [networkIp, mask] = subnet ? this.parseSubnet(subnet) : this.autoSubnet();
    } catch (error) {
      this.logger.error(
        `Error determinando la subred: ${error.message}. Abortando escaneo TCP.`,
      );
      return;
    }
    const limit = pLimit(maxConcurrency);
    const promises: Promise<void>[] = [];
    const ips = this.expandCidr(networkIp, mask);
    if (ips.length === 0) {
      this.logger.warn(
        `No se generaron IPs para escanear en la subred ${networkIp}/${mask}.`,
      );
      return;
    }
    this.logger.log(
      `⏳ Explorando ${ips.length} direcciones en ${ports.length} puertos (${ports.join(', ')}) con timeout ${scanTimeout}ms y concurrencia ${maxConcurrency}...`,
    );
    for (const ip of ips) {
      for (const port of ports) {
        promises.push(
          limit(async () => {
            try {
              const isOpen = await this.probe(ip, port, scanTimeout);
              if (!isOpen) return;
              const existingEntry = Array.from(store.values()).find(
                (p) => p.ip === ip,
              );
              if (!existingEntry) {
                const mac = await this.getMacFromArp(ip);
                store.set(ip, {
                  ip,
                  port,
                  type: 'tcp:raw',
                  name: `Printer @ ${ip}`,
                  mac: mac || undefined,
                });
                this.logger.verbose(
                  `🔎 TCP ⇒ ${ip}:${port} abierto. ${mac ? `MAC: ${mac}` : 'MAC no encontrada en ARP.'}`,
                );
              } else {
                this.logger.debug(
                  `TCP: IP ${ip} ya encontrada (en puerto ${existingEntry.port}), ignorando puerto ${port}.`,
                );
              }
            } catch (error) {
              this.logger.warn(
                `Error sondeando ${ip}:${port} - ${error.message}`,
              );
            }
          }),
        );
      }
    }
    await Promise.all(promises);
    this.logger.log(
      `✔️  Escaneo TCP finalizado. Total candidatos únicos por IP: ${store.size}`,
    );
  }
  private async getMacFromArp(ip: string): Promise<string | null> {
    try {
      const { stdout } = await execPromise('arp -a');
      const lines = stdout.split('\n');
      const line = lines.find((l) => l.includes(ip));
      if (!line) {
        this.logger.debug(`ARP: IP ${ip} no encontrada en la tabla ARP.`);
        return null;
      }
      const macMatch = line.match(/([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})/);
      if (macMatch && macMatch[0]) {
        const mac = macMatch[0].replace(/-/g, ':').toUpperCase();
        return mac;
      } else {
        this.logger.debug(
          `ARP: No se pudo extraer MAC de la línea para ${ip}: "${line.trim()}"`,
        );
        return null;
      }
    } catch (error) {
      this.logger.warn(
        `ARP: Error al ejecutar/parsear 'arp -a' para ${ip}: ${error.message}`,
      );
      return null;
    }
  }
  private probe(host: string, port: number, timeout: number): Promise<boolean> {
    return new Promise((resolve) => {
      const socket = new net.Socket();
      let connected = false;
      socket.setTimeout(timeout);
      socket.on('connect', () => {
        connected = true;
        socket.end();
        resolve(true);
      });
      socket.on('timeout', () => {
        socket.destroy();
        resolve(false);
      });
      socket.on('error', () => {
        socket.destroy();
        resolve(false);
      });
      socket.on('close', () => {
        if (!connected) resolve(false);
      });
      socket.connect(port, host);
    });
  }
  private parseSubnet(subnet: string): [string, number] {
    const parts = subnet.split('/');
    if (
      parts.length !== 2 ||
      !net.isIPv4(parts[0]) ||
      isNaN(parseInt(parts[1], 10))
    ) {
      throw new Error(
        `Formato de subred inválido: ${subnet}. Use ej: 192.168.1.0/24`,
      );
    }
    const mask = parseInt(parts[1], 10);
    if (mask < 1 || mask > 30) {
      throw new Error(
        `Máscara de subred /${mask} inválida o demasiado grande.`,
      );
    }
    return [parts[0], mask];
  }
  private autoSubnet(): [string, number] {
    const interfaces = networkInterfaces();
    for (const name of Object.keys(interfaces)) {
      const ifaceDetails = interfaces[name];
      if (!ifaceDetails) continue;
      for (const iface of ifaceDetails) {
        if (iface.family === 'IPv4' && !iface.internal && iface.cidr) {
          this.logger.log(`Autodetectada interfaz: ${name} (${iface.cidr})`);
          const [, maskStr] = iface.cidr.split('/');
          const mask = parseInt(maskStr, 10);
          if (!isNaN(mask) && mask >= 1 && mask <= 30) {
            const ipInt = this.ipToInt(iface.address);
            const maskInt = -1 << (32 - mask);
            const networkInt = ipInt & maskInt;
            const networkIp = this.intToIp(networkInt);
            return [networkIp, mask];
          }
        }
      }
    }
    throw new Error(
      'No se pudo autodetectar una interfaz de red IPv4 activa con CIDR válido.',
    );
  }
  private expandCidr(baseIp: string, mask: number): string[] {
    if (mask < 1 || mask > 30) {
      this.logger.warn(
        `Máscara /${mask} inválida o demasiado grande, no se expandirá.`,
      );
      return [];
    }
    const networkInt = this.ipToInt(baseIp);
    const hostBits = 32 - mask;
    const totalHosts = 1 << hostBits;
    const broadcastInt = networkInt | (totalHosts - 1);
    const ips: string[] = [];
    for (let i = networkInt + 1; i < broadcastInt; i++) {
      ips.push(this.intToIp(i));
    }
    return ips;
  }
  private ipToInt(ip: string): number {
    return ip
      .split('.')
      .reduce((res, octet) => (res << 8) | parseInt(octet, 10), 0);
  }
  private intToIp(int: number): string {
    return [
      (int >>> 24) & 255,
      (int >>> 16) & 255,
      (int >>> 8) & 255,
      int & 255,
    ].join('.');
  }
}

================
File: backend/src/thermal-printers/domain/thermal-printer.ts
================
export enum PrinterConnectionType {
  NETWORK = 'NETWORK',
  USB = 'USB',
  SERIAL = 'SERIAL',
  BLUETOOTH = 'BLUETOOTH',
}
export class ThermalPrinter {
  id: string;
  name: string;
  connectionType: PrinterConnectionType;
  ipAddress: string | null;
  port: number | null;
  path: string | null;
  isActive: boolean;
  macAddress: string | null;
  isDefaultPrinter: boolean;
  autoDeliveryPrint: boolean;
  autoPickupPrint: boolean;
  paperWidth: number;
  charactersPerLine: number;
  cutPaper: boolean;
  feedLines: number;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/thermal-printers/infrastructure/persistence/relational/entities/thermal-printer.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  Index,
  PrimaryGeneratedColumn,
  Unique,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { PrinterConnectionType } from '../../../../domain/thermal-printer';
@Entity({
  name: 'thermal_printer',
})
@Unique(['ipAddress'])
export class ThermalPrinterEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ type: 'varchar', length: 100 })
  name: string;
  @Column({ type: 'enum', enum: PrinterConnectionType })
  connectionType: PrinterConnectionType;
  @Index()
  @Column({ type: 'varchar', nullable: true })
  ipAddress: string | null;
  @Column({ type: 'int', nullable: true })
  port: number | null;
  @Column({ type: 'varchar', nullable: true })
  path: string | null;
  @Column({ type: 'boolean', default: true })
  isActive: boolean;
  @Index()
  @Column({ type: 'varchar', length: 17, nullable: true })
  macAddress: string | null;
  @Column({ type: 'boolean', default: false })
  isDefaultPrinter: boolean;
  @Column({ type: 'boolean', default: false })
  autoDeliveryPrint: boolean;
  @Column({ type: 'boolean', default: false })
  autoPickupPrint: boolean;
  @Column({ type: 'int', default: 80 })
  paperWidth: number;
  @Column({ type: 'int', default: 48 })
  charactersPerLine: number;
  @Column({ type: 'boolean', default: true })
  cutPaper: boolean;
  @Column({ type: 'int', default: 3 })
  feedLines: number;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/thermal-printers/infrastructure/persistence/relational/mappers/thermal-printer.mapper.ts
================
import { ThermalPrinter } from '../../../../domain/thermal-printer';
import { ThermalPrinterEntity } from '../entities/thermal-printer.entity';
export class ThermalPrinterMapper {
  static toDomain(entity: ThermalPrinterEntity): ThermalPrinter {
    const domain = new ThermalPrinter();
    domain.id = entity.id;
    domain.name = entity.name;
    domain.connectionType = entity.connectionType;
    domain.ipAddress = entity.ipAddress;
    domain.port = entity.port;
    domain.path = entity.path;
    domain.isActive = entity.isActive;
    domain.macAddress = entity.macAddress;
    domain.isDefaultPrinter = entity.isDefaultPrinter;
    domain.autoDeliveryPrint = entity.autoDeliveryPrint;
    domain.autoPickupPrint = entity.autoPickupPrint;
    domain.paperWidth = entity.paperWidth;
    domain.charactersPerLine = entity.charactersPerLine;
    domain.cutPaper = entity.cutPaper;
    domain.feedLines = entity.feedLines;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    return domain;
  }
  static toEntity(domain: ThermalPrinter): ThermalPrinterEntity {
    const entity = new ThermalPrinterEntity();
    entity.id = domain.id;
    entity.name = domain.name;
    entity.connectionType = domain.connectionType;
    entity.ipAddress = domain.ipAddress;
    entity.port = domain.port;
    entity.path = domain.path;
    entity.isActive = domain.isActive;
    entity.macAddress = domain.macAddress;
    entity.isDefaultPrinter = domain.isDefaultPrinter;
    entity.autoDeliveryPrint = domain.autoDeliveryPrint;
    entity.autoPickupPrint = domain.autoPickupPrint;
    entity.paperWidth = domain.paperWidth;
    entity.charactersPerLine = domain.charactersPerLine;
    entity.cutPaper = domain.cutPaper;
    entity.feedLines = domain.feedLines;
    return entity;
  }
}

================
File: backend/src/thermal-printers/printing.service.ts
================
import {
  Injectable,
  Inject,
  Logger,
  InternalServerErrorException,
  BadRequestException,
} from '@nestjs/common';
import { OrdersService } from '../orders/orders.service';
import { PrintOrderDto } from './dto/print-order.dto';
import { ThermalPrintersService } from './thermal-printers.service';
import { PrinterTypes, ThermalPrinter } from 'node-thermal-printer';
import { PrinterConnectionType } from './domain/thermal-printer';
@Injectable()
export class PrintingService {
  private readonly logger = new Logger(PrintingService.name);
  constructor(
    @Inject(OrdersService)
    private readonly ordersService: OrdersService,
    @Inject(ThermalPrintersService)
    private readonly thermalPrintersService: ThermalPrintersService,
  ) {}
  async printKitchenTicket(printOrderDto: PrintOrderDto): Promise<void> {
    const { orderId, printerId } = printOrderDto;
    const order = await this.ordersService.findOne(orderId);
    this.logger.log(`Orden ${orderId} encontrada.`);
    if (!printerId) {
      this.logger.error('No se proporcionó ID de impresora para la impresión.');
      throw new BadRequestException('Se requiere el ID de la impresora.');
    }
    const printerDetails = await this.thermalPrintersService.findOne(printerId);
    if (!printerDetails.isActive) {
      throw new BadRequestException(
        `La impresora ${printerId} no está activa.`,
      );
    }
    if (
      printerDetails.connectionType !== PrinterConnectionType.NETWORK ||
      !printerDetails.ipAddress ||
      !printerDetails.port
    ) {
      throw new BadRequestException(
        `La impresora ${printerId} no es una impresora de red válida (IP/Puerto).`,
      );
    }
    this.logger.log(
      `Usando impresora: ${printerDetails.name} (${printerDetails.ipAddress}:${printerDetails.port})`,
    );
    const printer = new ThermalPrinter({
      type: PrinterTypes.EPSON,
      interface: `tcp://${printerDetails.ipAddress}:${printerDetails.port}`,
    });
    try {
      const isConnected = await printer.isPrinterConnected();
      if (!isConnected) {
        this.logger.error(
          `No se pudo conectar a la impresora ${printerDetails.name} en ${printerDetails.ipAddress}:${printerDetails.port}`,
        );
        throw new InternalServerErrorException(
          'No se pudo conectar a la impresora.',
        );
      }
      this.logger.log(
        `Conectado a la impresora ${printerDetails.name}. Imprimiendo ticket de cocina...`,
      );
      printer.alignCenter();
      printer.bold(true);
      printer.println('*** TICKET DE COCINA ***');
      printer.bold(false);
      printer.newLine();
      printer.alignLeft();
      printer.println(`Orden ID: ${order.id}`);
      printer.println(`Folio del turno: ${order.shiftOrderNumber}`);
      printer.cut();
      await printer.execute();
      this.logger.log(
        `Ticket de cocina para orden ${orderId} enviado a ${printerDetails.name} exitosamente.`,
      );
    } catch (error) {
      this.logger.error(
        `Error al imprimir en ${printerDetails.name}: ${error.message}`,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Error al enviar la impresión: ${error.message}`,
      );
    }
  }
}

================
File: backend/src/thermal-printers/thermal-printers.service.ts
================
import {
  Injectable,
  NotFoundException,
  ConflictException,
  BadRequestException,
  Logger,
} from '@nestjs/common';
import { ThermalPrinterRepository } from './infrastructure/persistence/thermal-printer.repository';
import { CreateThermalPrinterDto } from './dto/create-thermal-printer.dto';
import { UpdateThermalPrinterDto } from './dto/update-thermal-printer.dto';
import {
  ThermalPrinter,
  PrinterConnectionType,
} from './domain/thermal-printer';
import { FindAllThermalPrintersDto } from './dto/find-all-thermal-printers.dto';
import * as net from 'net';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { QueryFailedError } from 'typeorm';
import { ERROR_CODES } from '../common/constants/error-codes.constants';
import { Inject } from '@nestjs/common';
import { THERMAL_PRINTER_REPOSITORY } from '../common/tokens';
@Injectable()
export class ThermalPrintersService {
  private readonly logger = new Logger(ThermalPrintersService.name);
  constructor(
    @Inject(THERMAL_PRINTER_REPOSITORY)
    private readonly thermalPrinterRepository: ThermalPrinterRepository,
  ) {}
  async create(createDto: CreateThermalPrinterDto): Promise<ThermalPrinter> {
    const existingPrinterByName =
      await this.thermalPrinterRepository.findByName(createDto.name);
    if (existingPrinterByName) {
      throw new ConflictException({
        code: ERROR_CODES.THERMAL_PRINTER_DUPLICATE_FIELD,
        message: `Ya existe una impresora con el nombre '${createDto.name}'.`,
        details: { field: 'name' },
      });
    }
    if (
      createDto.connectionType === PrinterConnectionType.NETWORK &&
      createDto.ipAddress
    ) {
      const existingPrinterByIp =
        await this.thermalPrinterRepository.findByIpAddress(
          createDto.ipAddress,
        );
      if (existingPrinterByIp) {
        throw new ConflictException({
          code: ERROR_CODES.THERMAL_PRINTER_DUPLICATE_FIELD,
          message: `Ya existe una impresora con la direcciรณn IP '${createDto.ipAddress}'.`,
          details: { field: 'ipAddress' },
        });
      }
    }
    const printer = new ThermalPrinter();
    printer.name = createDto.name;
    printer.connectionType = createDto.connectionType;
    printer.ipAddress = createDto.ipAddress || null;
    printer.port = createDto.port || null;
    printer.path = createDto.path || null;
    printer.isActive = createDto.isActive ?? true;
    printer.macAddress = createDto.macAddress || null;
    printer.isDefaultPrinter = createDto.isDefaultPrinter ?? false;
    printer.autoDeliveryPrint = createDto.autoDeliveryPrint ?? false;
    printer.autoPickupPrint = createDto.autoPickupPrint ?? false;
    printer.paperWidth = createDto.paperWidth ?? 80;
    printer.charactersPerLine = createDto.charactersPerLine ?? 48;
    printer.cutPaper = createDto.cutPaper ?? true;
    printer.feedLines = createDto.feedLines ?? 3;
    try {
      return await this.thermalPrinterRepository.create(printer);
    } catch (error) {
      if (
        error instanceof QueryFailedError &&
        error.driverError?.code === '23505'
      ) {
        const detail = error.driverError?.detail || '';
        let field = 'desconocido';
        if (detail.includes('ipAddress')) {
          field = 'direcciรณn IP';
        } else if (detail.includes('name')) {
          field = 'nombre';
        }
        throw new ConflictException({
          code: ERROR_CODES.THERMAL_PRINTER_DUPLICATE_FIELD,
          message: `Ya existe una impresora con el mismo ${field}.`,
          details: { field: field },
        });
      }
      throw error;
    }
  }
  async findAll(
    filterOptions: FindAllThermalPrintersDto,
    paginationOptions: IPaginationOptions,
  ): Promise<[ThermalPrinter[], number]> {
    return this.thermalPrinterRepository.findManyWithPagination({
      filterOptions,
      paginationOptions,
    });
  }
  async findOne(id: string): Promise<ThermalPrinter> {
    const printer = await this.thermalPrinterRepository.findById(id);
    if (!printer) {
      throw new NotFoundException(`Impresora con ID ${id} no encontrada.`);
    }
    return printer;
  }
  async update(
    id: string,
    updateDto: UpdateThermalPrinterDto,
  ): Promise<ThermalPrinter> {
    const existingPrinter = await this.findOne(id);
    if (updateDto.name && updateDto.name !== existingPrinter.name) {
      const conflictingPrinter = await this.thermalPrinterRepository.findByName(
        updateDto.name,
      );
      if (conflictingPrinter && conflictingPrinter.id !== id) {
        throw new ConflictException({
          code: ERROR_CODES.THERMAL_PRINTER_DUPLICATE_FIELD,
          message: `Ya existe otra impresora con el nombre '${updateDto.name}'.`,
          details: { field: 'name' },
        });
      }
    }
    if (
      (updateDto.connectionType === PrinterConnectionType.NETWORK ||
        (updateDto.connectionType === undefined &&
          existingPrinter.connectionType === PrinterConnectionType.NETWORK)) &&
      updateDto.ipAddress &&
      updateDto.ipAddress !== existingPrinter.ipAddress
    ) {
      const conflictingPrinterByIp =
        await this.thermalPrinterRepository.findByIpAddress(
          updateDto.ipAddress,
        );
      if (conflictingPrinterByIp && conflictingPrinterByIp.id !== id) {
        throw new ConflictException({
          code: ERROR_CODES.THERMAL_PRINTER_DUPLICATE_FIELD,
          message: `Ya existe otra impresora con la direcciรณn IP '${updateDto.ipAddress}'.`,
          details: { field: 'ipAddress' },
        });
      }
    }
    const updatePayload: Partial<ThermalPrinter> = {
      name: updateDto.name,
      connectionType: updateDto.connectionType,
      ipAddress: updateDto.ipAddress,
      port: updateDto.port,
      path: updateDto.path,
      isActive: updateDto.isActive,
      macAddress: updateDto.macAddress,
      isDefaultPrinter: updateDto.isDefaultPrinter,
      autoDeliveryPrint: updateDto.autoDeliveryPrint,
      autoPickupPrint: updateDto.autoPickupPrint,
      paperWidth: updateDto.paperWidth,
      charactersPerLine: updateDto.charactersPerLine,
      cutPaper: updateDto.cutPaper,
      feedLines: updateDto.feedLines,
    };
    Object.keys(updatePayload).forEach(
      (key) => updatePayload[key] === undefined && delete updatePayload[key],
    );
    const updatedPrinter = await this.thermalPrinterRepository.update(
      id,
      updatePayload,
    );
    if (!updatedPrinter) {
      throw new NotFoundException(`Impresora con ID ${id} no encontrada.`);
    }
    try {
      const updatedPrinter = await this.thermalPrinterRepository.update(
        id,
        updatePayload,
      );
      if (!updatedPrinter) {
        throw new NotFoundException(
          `Impresora con ID ${id} no encontrada despuรฉs de intentar actualizar.`,
        );
      }
      return updatedPrinter;
    } catch (error) {
      if (
        error instanceof QueryFailedError &&
        error.driverError?.code === '23505'
      ) {
        const detail = error.driverError?.detail || '';
        let field = 'desconocido';
        if (detail.includes('ipAddress')) {
          field = 'direcciรณn IP';
        } else if (detail.includes('name')) {
          field = 'nombre';
        }
        throw new ConflictException({
          code: ERROR_CODES.THERMAL_PRINTER_DUPLICATE_FIELD,
          message: `Ya existe otra impresora con el mismo ${field}.`,
          details: { field: field },
        });
      }
      throw error;
    }
  }
  async remove(id: string): Promise<void> {
    await this.findOne(id);
    return this.thermalPrinterRepository.remove(id);
  }
  async pingPrinter(id: string): Promise<{ status: string }> {
    this.logger.log(`Intentando hacer ping a la impresora con ID: ${id}`);
    const printer = await this.findOne(id);
    if (printer.connectionType !== PrinterConnectionType.NETWORK) {
      this.logger.warn(
        `Ping no aplicable para tipo de conexiรณn: ${printer.connectionType}`,
      );
      throw new BadRequestException(
        `La prueba de ping solo es aplicable a impresoras con conexiรณn NETWORK.`,
      );
    }
    if (!printer.ipAddress || !printer.port) {
      this.logger.error(
        `La impresora ${id} es NETWORK pero no tiene IP o puerto configurado.`,
      );
      throw new BadRequestException(
        'La impresora no tiene configurada una direcciรณn IP o puerto para realizar el ping.',
      );
    }
    const host = printer.ipAddress;
    const port = printer.port;
    const timeout = 2000;
    return new Promise((resolve) => {
      const socket = new net.Socket();
      let connected = false;
      socket.setTimeout(timeout);
      socket.on('connect', () => {
        connected = true;
        this.logger.log(`Ping exitoso a ${host}:${port}`);
        socket.end();
        resolve({ status: 'online' });
      });
      socket.on('timeout', () => {
        this.logger.warn(`Timeout al intentar conectar a ${host}:${port}`);
        socket.destroy();
        resolve({ status: 'offline' });
      });
      socket.on('error', (err) => {
        this.logger.error(
          `Error de conexiรณn a ${host}:${port}: ${err.message}`,
        );
        socket.destroy();
        resolve({ status: 'offline' });
      });
      socket.on('close', () => {
        if (!connected) {
          this.logger.log(`Socket cerrado sin conexiรณn a ${host}:${port}`);
          resolve({ status: 'offline' });
        }
      });
      this.logger.log(`Intentando conexiรณn TCP a ${host}:${port}...`);
      socket.connect(port, host);
    });
  }
  async testPrint(printerInfo: {
    ip: string;
    port: number;
    connectionType: string;
  }): Promise<{ success: boolean; message?: string }> {
    this.logger.log(
      `Intentando imprimir ticket de prueba en ${printerInfo.ip}:${printerInfo.port}`,
    );
    const timeout = 5000;
    return new Promise((resolve) => {
      const socket = new net.Socket();
      let connected = false;
      socket.setTimeout(timeout);
      socket.on('connect', () => {
        connected = true;
        this.logger.log(`Conectado a ${printerInfo.ip}:${printerInfo.port}`);
        try {
          const commands = [
            '\x1B\x40',
            '\x1B\x61\x01',
            '\x1B\x21\x30',
            'TICKET DE PRUEBA\n',
            '\x1B\x21\x00',
            '\x1B\x61\x00',
            '\n',
            `Fecha: ${new Date().toLocaleString()}\n`,
            `IP: ${printerInfo.ip}\n`,
            `Puerto: ${printerInfo.port}\n`,
            '\n',
            '\x1B\x61\x01',
            'Impresora configurada correctamente\n',
            '\n',
            '\x1B\x61\x00',
            '================================\n',
            '\n\n\n',
            '\x1D\x56\x00',
          ];
          const buffer = Buffer.from(commands.join(''), 'binary');
          socket.write(buffer, () => {
            this.logger.log('Ticket de prueba enviado exitosamente');
            socket.end();
            resolve({
              success: true,
              message: 'Ticket de prueba impreso correctamente',
            });
          });
        } catch (error) {
          this.logger.error('Error al enviar ticket de prueba:', error);
          socket.end();
          resolve({
            success: false,
            message: 'Error al enviar datos a la impresora',
          });
        }
      });
      socket.on('error', (err) => {
        this.logger.error(`Error de conexiรณn: ${err.message}`);
        resolve({
          success: false,
          message: `No se pudo conectar a la impresora: ${err.message}`,
        });
      });
      socket.on('timeout', () => {
        this.logger.warn('Timeout al conectar con la impresora');
        socket.destroy();
        if (!connected) {
          resolve({
            success: false,
            message: 'Tiempo de espera agotado al conectar con la impresora',
          });
        }
      });
      this.logger.log(
        `Intentando conexiรณn TCP a ${printerInfo.ip}:${printerInfo.port}...`,
      );
      socket.connect(printerInfo.port, printerInfo.ip);
    });
  }
}

================
File: shared/src/types/order.types.ts
================
export interface CloudOrderItem {
  productId: string;
  productVariantId?: string;
  quantity: number;
  comments?: string;
  selectedPizzaIngredients?: {
    pizzaIngredientId: string;
    half: 'left' | 'right' | 'full';
    action: 'add' | 'remove';
  }[];
  selectedModifiers?: {
    modifierId: string;
  }[];
}
export interface CloudOrder {
  id?: string;
  shiftOrderNumber?: number;
  orderType: 'delivery' | 'pickup';
  status: 'created' | 'accepted' | 'in_preparation' | 'prepared' | 'in_delivery' | 'finished' | 'canceled';
  items: CloudOrderItem[];
  customerId: string;
  customerPhone: string;
  deliveryInfo?: {
    address: string;
    additionalDetails?: string;
    latitude?: number;
    longitude?: number;
  };
  pickupName?: string;
  totalCost: number;
  estimatedTime?: number;
  scheduledDeliveryTime?: Date;
  syncedWithLocal: boolean;
  localId?: number;
  whatsappMessageId?: string;
  createdAt?: Date;
  updatedAt?: Date;
}

================
File: app/App.tsx
================
import React from 'react';
import { ActivityIndicator, View } from 'react-native';
import { Provider as PaperProvider } from 'react-native-paper';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import {
  useThemeStore,
  useSystemThemeDetector,
} from './src/app/store/themeStore';
import { AppNavigator } from './src/app/navigation/AppNavigator';
import GlobalSnackbar from './src/app/components/common/GlobalSnackbar';
import { useInitializeAuth } from './src/app/hooks/useInitializeAuth';
import { useServerConnection } from './src/app/hooks/useServerConnection';
import { es, registerTranslation } from 'react-native-paper-dates';
registerTranslation('es', es);
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      gcTime: 10 * 60 * 1000,
      refetchOnMount: false,
      refetchOnWindowFocus: false,
      refetchOnReconnect: 'always',
      retry: 0,
      refetchInterval: false,
    },
    mutations: {
      retry: 0,
    },
  },
});
function AppContent() {
  const isInitializingAuth = useInitializeAuth();
  useServerConnection();
  const activeTheme = useThemeStore((state) => state.activeTheme);
  if (isInitializingAuth) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: activeTheme.colors.background,
        }}
      >
        <ActivityIndicator size="large" color={activeTheme.colors.primary} />
      </View>
    );
  }
  return (
    <>
      <AppNavigator />
      <GlobalSnackbar />
    </>
  );
}
export default function App() {
  useSystemThemeDetector();
  const activeTheme = useThemeStore((state) => state.activeTheme);
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <QueryClientProvider client={queryClient}>
          <PaperProvider theme={activeTheme}>
            <AppContent />
          </PaperProvider>
        </QueryClientProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}

================
File: app/babel.config.js
================
module.exports = function (api) {
  api.cache(true);
  const isWeb = process.env.WEBPACK_DEV_SERVER === 'true' || process.env.PLATFORM === 'web';
  const plugins = [
    [
      "module-resolver",
      {
        root: ["./"],
        alias: {
          "@": "./src",
        },
      },
    ],
    'react-native-reanimated/plugin',
  ];
  if (isWeb) {
    plugins.push([
      function() {
        return {
          visitor: {
            MetaProperty(path) {
              if (path.node.meta.name === 'import' && path.node.property.name === 'meta') {
                path.replaceWith(
                  require('@babel/types').objectExpression([
                    require('@babel/types').objectProperty(
                      require('@babel/types').identifier('url'),
                      require('@babel/types').stringLiteral('')
                    )
                  ])
                );
              }
            }
          }
        };
      }
    ]);
  }
  return {
    presets: ["babel-preset-expo"],
    plugins,
  };
};

================
File: app/metro.config.js
================
const { getDefaultConfig } = require('expo/metro-config');
const config = getDefaultConfig(__dirname);
config.resolver.resolverMainFields = ['react-native', 'browser', 'main'];
config.resolver.sourceExts = [...config.resolver.sourceExts, 'mjs'];
module.exports = config;

================
File: app/src/app/components/common/AnimatedLabelSelector.tsx
================
import React, { useRef, useEffect } from 'react';
import {
  View,
  TouchableOpacity,
  Animated,
  StyleSheet,
  Text,
  StyleProp,
  ViewStyle,
  TextStyle,
  ActivityIndicator,
} from 'react-native';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Icon, IconButton } from 'react-native-paper';
interface AnimatedLabelSelectorProps {
  label: string;
  value: string | null | undefined;
  onPress: () => void;
  onClear?: () => void;
  containerStyle?: StyleProp<ViewStyle>;
  valueStyle?: StyleProp<TextStyle>;
  labelStyle?: StyleProp<TextStyle>;
  activeLabelColor?: string;
  inactiveLabelColor?: string;
  borderColor?: string;
  activeBorderColor?: string;
  disabled?: boolean;
  isLoading?: boolean;
  error?: boolean;
  errorColor?: string;
}
const AnimatedLabelSelector: React.FC<AnimatedLabelSelectorProps> = ({
  label,
  value,
  onPress,
  onClear,
  containerStyle,
  valueStyle,
  labelStyle,
  activeLabelColor,
  inactiveLabelColor,
  borderColor: defaultBorderColor,
  activeBorderColor: focusedBorderColor,
  disabled = false,
  isLoading = false,
  error = false,
  errorColor: customErrorColor,
  ...rest
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const isActive = value != null && value !== '';
  const animation = useRef(new Animated.Value(isActive ? 1 : 0)).current;
  const finalActiveLabelColor = activeLabelColor || theme.colors.primary;
  const finalInactiveLabelColor =
    inactiveLabelColor || theme.colors.onSurfaceVariant;
  const finalBorderColor = defaultBorderColor || theme.colors.outline;
  const finalActiveBorderColor = focusedBorderColor || theme.colors.primary;
  const finalErrorColor = customErrorColor || theme.colors.error;
  const currentBorderColor = disabled
    ? theme.colors.surfaceVariant
    : error
      ? finalErrorColor
      : isActive
        ? finalActiveBorderColor
        : finalBorderColor;
  useEffect(() => {
    Animated.timing(animation, {
      toValue: isActive ? 1 : 0,
      duration: 200,
      useNativeDriver: false,
    }).start();
  }, [isActive, animation]);
  const labelTranslateY = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -26],
  });
  const labelScale = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 0.8],
  });
  const labelColor = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [finalInactiveLabelColor, finalActiveLabelColor],
  });
  const styles = React.useMemo(
    () =>
      createStyles(theme, responsive, {
        disabled,
        finalInactiveLabelColor,
      }),
    [theme, responsive, disabled, finalInactiveLabelColor],
  );
  const animatedLabelStyle = {
    transform: [{ translateY: labelTranslateY }, { scale: labelScale }],
    color: labelColor,
    backgroundColor: animation.interpolate({
      inputRange: [0, 1],
      outputRange: ['transparent', theme.colors.background],
    }),
  };
  const staticLabelStyle = {
    paddingHorizontal: isActive ? 4 : 0,
    zIndex: isActive ? 2 : 0,
  };
  return (
    <View style={styles.outerContainer}>
      <TouchableOpacity
        onPress={onPress}
        disabled={disabled || isLoading}
        style={[
          styles.container,
          { borderColor: currentBorderColor },
          containerStyle,
        ]}
        activeOpacity={0.7}
        {...rest}
      >
        <Animated.Text
          style={[
            styles.label,
            staticLabelStyle,
            labelStyle,
            animatedLabelStyle,
          ]}
          numberOfLines={1}
        >
          {label}
        </Animated.Text>
        <View style={styles.valueContainer}>
          <Text style={[styles.valueText, valueStyle]} numberOfLines={1}>
            {!isLoading ? value || ' ' : ' '}
          </Text>
          <View style={styles.iconsContainer}>
            {isLoading ? (
              <ActivityIndicator
                size="small"
                color={theme.colors.primary}
                style={styles.loader}
              />
            ) : (
              <Icon
                source="chevron-down"
                size={20}
                color={
                  disabled
                    ? theme.colors.onSurfaceDisabled
                    : theme.colors.onSurfaceVariant
                }
              />
            )}
          </View>
        </View>
        {disabled && <View style={styles.disabledOverlay} />}
      </TouchableOpacity>
      {isActive && !disabled && !isLoading && onClear && (
        <View style={styles.clearButtonContainer}>
          <IconButton
            icon="close-circle"
            size={24}
            onPress={onClear}
            iconColor={theme.colors.onSurfaceVariant}
            style={styles.clearButton}
            rippleColor="rgba(0, 0, 0, .1)"
          />
        </View>
      )}
    </View>
  );
};
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
  props: {
    disabled: boolean;
    finalInactiveLabelColor: string;
  },
) =>
  StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.isTablet ? 16 : 18,
      paddingBottom: responsive.isTablet ? 4 : 6,
      position: 'relative',
      backgroundColor: theme.colors.background,
      minHeight: responsive.isTablet ? 52 : 58,
      justifyContent: 'center',
      flex: 1,
    },
    outerContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    label: {
      position: 'absolute',
      left: responsive.spacing(theme.spacing.m),
      top: responsive.isTablet ? 16 : 18,
      fontSize: responsive.fontSize(16),
      color: props.finalInactiveLabelColor,
      zIndex: 1,
    },
    valueContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      minHeight: responsive.isTablet ? 20 : 24,
    },
    valueText: {
      fontSize: responsive.fontSize(16),
      color: props.disabled
        ? theme.colors.onSurfaceDisabled
        : theme.colors.onSurface,
      flex: 1,
      marginRight: responsive.spacing(theme.spacing.xs),
    },
    loader: {},
    iconsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    clearButtonContainer: {
      marginLeft: responsive.spacing(theme.spacing.s),
      height: responsive.isTablet ? 52 : 58,
      justifyContent: 'center',
    },
    clearButton: {
      margin: 0,
    },
    icon: {},
    disabledOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: theme.dark
        ? 'rgba(0, 0, 0, 0.2)'
        : 'rgba(0, 0, 0, 0.05)',
      zIndex: 3,
      borderRadius: theme.roundness,
    },
  });
export default AnimatedLabelSelector;

================
File: app/src/app/components/common/AutoImage.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import {
  StyleSheet,
  Platform,
  View,
  ActivityIndicator,
  StyleProp,
  ViewStyle,
  DimensionValue,
} from 'react-native';
import { Image, ImageProps as ExpoImageProps } from 'expo-image';
import { Icon } from 'react-native-paper';
import { getCachedImageUri } from '../../lib/imageCache';
import { getImageUrl } from '../../lib/imageUtils';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
export interface AutoImageProps
  extends Omit<ExpoImageProps, 'source' | 'style'> {
  source: string | null | undefined;
  maxWidth?: number;
  maxHeight?: number;
  useCache?: boolean;
  placeholder?: ExpoImageProps['placeholder'];
  placeholderIcon?: string;
  contentFit?: ExpoImageProps['contentFit'];
  transition?: ExpoImageProps['transition'];
  style?: StyleProp<ViewStyle>;
}
function useAutoImageSize(
  maxWidth?: number,
  maxHeight?: number,
): { width?: number | string; height?: number | string } {
  return {
    width: maxWidth ?? '100%',
    height: maxHeight ?? '100%',
  };
}
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      overflow: 'hidden',
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.surfaceVariant,
    },
    loadingIndicator: {
      position: 'absolute',
    },
    image: {
      width: '100%',
      height: '100%',
    },
  });
export const AutoImage: React.FC<AutoImageProps> = ({
  source: originalSourceProp,
  maxWidth,
  maxHeight,
  useCache = true,
  style,
  placeholder,
  placeholderIcon = 'image-off-outline',
  contentFit = 'cover',
  transition = 300,
  ...restExpoImageProps
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const [processedUri, setProcessedUri] = useState<string | null>(null);
  const [isLoadingUri, setIsLoadingUri] = useState(true);
  const { width, height } = useAutoImageSize(maxWidth, maxHeight);
  useEffect(() => {
    let isMounted = true;
    setIsLoadingUri(true);
    setProcessedUri(null);
    if (!originalSourceProp) {
      if (isMounted) {
        setIsLoadingUri(false);
      }
      return;
    }
    const processSource = async () => {
      const fullRemoteUrl = await getImageUrl(originalSourceProp);
      if (!fullRemoteUrl) {
        if (isMounted) setIsLoadingUri(false);
        return;
      }
      if (
        !useCache ||
        Platform.OS === 'web' ||
        fullRemoteUrl.startsWith('file://')
      ) {
        if (isMounted) {
          setProcessedUri(fullRemoteUrl);
          setIsLoadingUri(false);
        }
        return;
      }
      try {
        const cachedUri = await getCachedImageUri(fullRemoteUrl);
        if (isMounted) {
          setProcessedUri(cachedUri ?? fullRemoteUrl);
          setIsLoadingUri(false);
        }
      } catch (error) {
        if (isMounted) {
          setProcessedUri(fullRemoteUrl);
          setIsLoadingUri(false);
        }
      }
    };
    processSource();
    return () => {
      isMounted = false;
    };
  }, [originalSourceProp, useCache]);
  const styles = useMemo(() => createStyles(theme), [theme]);
  const containerStyle: StyleProp<ViewStyle> = useMemo(
    () => [
      styles.container,
      { width: width as DimensionValue, height: height as DimensionValue },
      style,
    ],
    [styles, width, height, style],
  );
  const iconSize = useMemo(() => {
    if (typeof width === 'number' && typeof height === 'number') {
      return Math.min(width, height) * 0.4;
    }
    return responsive.dimensions.iconSize.large;
  }, [width, height, responsive.dimensions.iconSize.large]);
  return (
    <View style={containerStyle}>
      {processedUri ? (
        <>
          <Image
            source={{ uri: processedUri }}
            style={styles.image}
            placeholder={placeholder}
            contentFit={contentFit}
            transition={transition}
            cachePolicy="memory-disk"
            {...restExpoImageProps}
          />
          {isLoadingUri && originalSourceProp && (
            <ActivityIndicator
              style={styles.loadingIndicator}
              animating={true}
              color={theme.colors.primary}
              size="small"
            />
          )}
        </>
      ) : (
        !isLoadingUri && (
          <Icon
            source={placeholderIcon}
            size={iconSize}
            color={theme.colors.onSurfaceVariant}
          />
        )
      )}
    </View>
  );
};
export default AutoImage;

================
File: app/src/app/components/common/EmptyState.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Button, Icon } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
interface EmptyStateProps {
  icon?: string;
  title: string;
  message?: string;
  actionLabel?: string;
  onAction?: () => void;
}
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.isTablet ? responsive.spacing.l : theme.spacing.xl,
    },
    iconContainer: {
      marginBottom: responsive.isTablet
        ? responsive.spacing.m
        : theme.spacing.l,
    },
    title: {
      textAlign: 'center',
      marginBottom: theme.spacing.s,
      color: theme.colors.onSurface,
    },
    message: {
      textAlign: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing.m
        : theme.spacing.l,
      color: theme.colors.onSurfaceVariant,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing.l
        : theme.spacing.xl,
      fontSize: responsive.isTablet ? 14 : 16,
      lineHeight: responsive.isTablet ? 20 : 24,
    },
    button: {
      marginTop: responsive.isTablet ? responsive.spacing.s : theme.spacing.m,
    },
  });
const EmptyState: React.FC<EmptyStateProps> = ({
  icon = 'folder-open',
  title,
  message,
  actionLabel,
  onAction,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  return (
    <View style={styles.container}>
      <View style={styles.iconContainer}>
        <Icon
          source={icon}
          size={responsive.isTablet ? 56 : 64}
          color={theme.colors.onSurfaceVariant}
        />
      </View>
      <Text variant="headlineSmall" style={styles.title}>
        {title}
      </Text>
      {message && (
        <Text variant="bodyLarge" style={styles.message}>
          {message}
        </Text>
      )}
      {actionLabel && onAction && (
        <Button mode="contained" onPress={onAction} style={styles.button}>
          {actionLabel}
        </Button>
      )}
    </View>
  );
};
export default EmptyState;

================
File: app/src/app/components/ConnectionIndicator.tsx
================
import React, { useMemo, useState, useEffect } from 'react';
import { View } from 'react-native';
import { IconButton, Surface, Badge } from 'react-native-paper';
import { useAppTheme } from '../styles/theme';
import { useServerConnection } from '../hooks/useServerConnection';
import { useSnackbarStore } from '../store/snackbarStore';
import { healthMonitoringService } from '@/services/healthMonitoringService';
import { autoReconnectService } from '@/services/autoReconnectService';
export function ConnectionIndicator() {
  const theme = useAppTheme();
  const { hasWifi, isConnected, isSearching, isHealthy, error } =
    useServerConnection();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [isChecking, setIsChecking] = useState(false);
  const [isReconnecting, setIsReconnecting] = useState(false);
  useEffect(() => {
    const unsubscribe = autoReconnectService.subscribe((state) => {
      setIsReconnecting(state.isReconnecting && state.attempts > 0);
    });
    return () => {
      unsubscribe();
    };
  }, []);
  const getConnectionStatus = () => {
    if (!hasWifi) {
      return {
        icon: 'wifi-off',
        color: theme.colors.error,
        backgroundColor: theme.colors.errorContainer,
        message: 'Sin conexión WiFi',
      };
    }
    if (isSearching || isChecking) {
      return {
        icon: 'wifi-sync',
        color: theme.colors.warning || theme.colors.tertiary,
        backgroundColor:
          theme.colors.warningContainer || theme.colors.tertiaryContainer,
        message: isChecking
          ? 'Verificando conexión...'
          : 'Buscando servidor...',
      };
    }
    if (!isConnected) {
      return {
        icon: 'wifi-alert',
        color: theme.colors.error,
        backgroundColor: theme.colors.errorContainer,
        message: error || 'Sin conexión al servidor',
      };
    }
    if (!isHealthy) {
      return {
        icon: 'wifi-strength-2-alert',
        color: theme.colors.warning || theme.colors.tertiary,
        backgroundColor:
          theme.colors.warningContainer || theme.colors.tertiaryContainer,
        message: error || 'Servidor no responde',
      };
    }
    return {
      icon: 'wifi',
      color: theme.colors.onSurfaceVariant,
      backgroundColor: 'transparent',
      message: 'Conectado',
    };
  };
  const status = getConnectionStatus();
  const handlePress = async () => {
    const iconExplanation = getIconExplanation();
    showSnackbar({
      message: iconExplanation,
      type:
        !hasWifi || !isConnected ? 'error' : !isHealthy ? 'warning' : 'info',
      duration: 4000,
    });
    if (isReconnecting) {
      const reconnectState = autoReconnectService.getState();
      setTimeout(() => {
        showSnackbar({
          message: `Reconexión en progreso - Intento #${reconnectState.attempts}`,
          type: 'info',
          duration: 3000,
        });
      }, 500);
    }
    if (isConnected && !isChecking && !isReconnecting) {
      setIsChecking(true);
      setTimeout(async () => {
        try {
          const isHealthyNow = await healthMonitoringService.forceCheck();
          showSnackbar({
            message: isHealthyNow
              ? 'Servidor funcionando correctamente ✓'
              : 'El servidor no responde ✗',
            type: isHealthyNow ? 'success' : 'error',
            duration: 3000,
          });
        } catch (error) {
          showSnackbar({
            message: 'Error al verificar el servidor',
            type: 'error',
            duration: 3000,
          });
        } finally {
          setIsChecking(false);
        }
      }, 1000);
    }
    if (!isConnected && !isReconnecting && hasWifi) {
      showSnackbar({
        message: 'Iniciando proceso de reconexión...',
        type: 'info',
        duration: 2000,
      });
      setTimeout(() => {
        autoReconnectService.startAutoReconnect();
      }, 500);
    }
  };
  const getIconExplanation = () => {
    const reconnectInfo = isReconnecting
      ? '\n🔄 Reconectando automáticamente...'
      : '';
    switch (status.icon) {
      case 'wifi-off':
        return (
          '📡 Sin WiFi - Activa el WiFi y conéctate a la red' + reconnectInfo
        );
      case 'wifi-sync':
        return '🔄 Buscando servidor en la red...' + reconnectInfo;
      case 'wifi-alert':
        return '⚠️ Sin conexión al servidor' + reconnectInfo;
      case 'wifi-strength-2-alert':
        return '⚠️ Servidor no responde' + reconnectInfo;
      case 'wifi':
        return '✅ Conectado al servidor';
      default:
        return status.message + reconnectInfo;
    }
  };
  const containerStyle = useMemo(
    () => ({
      marginRight: 8,
      borderRadius: 20,
      overflow: 'hidden',
    }),
    [],
  );
  const surfaceStyle = useMemo(
    () => ({
      borderRadius: 20,
      backgroundColor: status.backgroundColor,
    }),
    [status.backgroundColor],
  );
  const iconButtonStyle = useMemo(
    () => ({
      margin: 0,
    }),
    [],
  );
  const showBackground =
    !hasWifi || !isConnected || isSearching || !isHealthy || isChecking;
  if (showBackground) {
    return (
      <View style={containerStyle}>
        <Surface style={surfaceStyle} elevation={0}>
          <IconButton
            icon={status.icon}
            iconColor={status.color}
            size={24}
            animated={isSearching || isChecking}
            onPress={handlePress}
            style={iconButtonStyle}
          />
        </Surface>
        {isReconnecting && !isSearching && (
          <Badge
            size={8}
            style={{
              position: 'absolute',
              top: 4,
              right: 4,
              backgroundColor: theme.colors.warning || theme.colors.tertiary,
            }}
          />
        )}
      </View>
    );
  }
  return (
    <View style={{ marginRight: 8, position: 'relative' }}>
      <IconButton
        icon={status.icon}
        iconColor={theme.colors.onPrimary}
        size={24}
        onPress={handlePress}
      />
      {isReconnecting && (
        <Badge
          size={8}
          style={{
            position: 'absolute',
            top: 8,
            right: 8,
            backgroundColor: theme.colors.warning || theme.colors.tertiary,
          }}
        />
      )}
    </View>
  );
}

================
File: app/src/app/components/DateTimePickerSafe.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import { Modal, Portal, Text, Button, Surface } from 'react-native-paper';
import DateTimePicker from '@react-native-community/datetimepicker';
interface DateTimePickerSafeProps {
  visible: boolean;
  mode: 'date' | 'time' | 'datetime';
  value: Date | null;
  onConfirm: (date: Date) => void;
  onCancel: () => void;
  minimumDate?: Date;
  maximumDate?: Date;
  minuteInterval?: number;
  title?: string;
  allowManualInput?: boolean;
}
export const DateTimePickerSafe: React.FC<DateTimePickerSafeProps> = ({
  visible,
  mode,
  value,
  onConfirm,
  onCancel,
  minimumDate,
  maximumDate,
  minuteInterval = 1,
  title,
  allowManualInput = false,
}) => {
  const [tempDate, setTempDate] = useState<Date>(() => {
    if (value) return new Date(value);
    const now = new Date();
    if (mode === 'time' && minuteInterval && minuteInterval > 1) {
      const minutes = now.getMinutes();
      const roundedMinutes =
        Math.round(minutes / minuteInterval) * minuteInterval;
      const roundedDate = new Date(now);
      roundedDate.setMinutes(roundedMinutes, 0, 0);
      return roundedDate;
    }
    return now;
  });
  useEffect(() => {
    if (visible && value) {
      setTempDate(new Date(value));
    }
  }, [visible, value]);
  const handleChange = (_event: any, selectedDate?: Date) => {
    if (selectedDate) {
      setTempDate(new Date(selectedDate));
    }
  };
  const handleConfirm = () => {
    onConfirm(new Date(tempDate));
  };
  const getTitle = () => {
    if (title) return title;
    switch (mode) {
      case 'date':
        return 'Seleccionar Fecha';
      case 'time':
        return 'Seleccionar Hora';
      case 'datetime':
        return 'Seleccionar Fecha y Hora';
      default:
        return '';
    }
  };
  if (Platform.OS === 'ios') {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onCancel}
          contentContainerStyle={styles.modalIOS}
        >
          <Surface style={styles.containerIOS}>
            <View style={styles.header}>
              <Button mode="text" onPress={onCancel}>
                Cancelar
              </Button>
              <Text variant="titleMedium">{getTitle()}</Text>
              <Button mode="text" onPress={handleConfirm}>
                Confirmar
              </Button>
            </View>
            <DateTimePicker
              testID="dateTimePicker"
              value={tempDate}
              mode={mode}
              is24Hour={false}
              display="spinner"
              onChange={handleChange}
              minimumDate={minimumDate}
              maximumDate={maximumDate}
              minuteInterval={minuteInterval as any}
              locale="es_ES"
            />
          </Surface>
        </Modal>
      </Portal>
    );
  }
  return (
    <>
      {visible && (
        <DateTimePicker
          testID="dateTimePicker"
          value={tempDate}
          mode={mode}
          is24Hour={false}
          display="default"
          onChange={(event, selectedDate) => {
            onCancel();
            if (event.type === 'set' && selectedDate) {
              onConfirm(new Date(selectedDate));
            }
          }}
          minimumDate={minimumDate}
          maximumDate={maximumDate}
          minuteInterval={minuteInterval as any}
          {...(allowManualInput && Platform.OS === 'android' && mode === 'time'
            ? {
                display: 'clock' as any,
              }
            : {})}
        />
      )}
    </>
  );
};
const styles = StyleSheet.create({
  modalIOS: {
    justifyContent: 'flex-end',
    margin: 0,
  },
  containerIOS: {
    backgroundColor: 'white',
    paddingBottom: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
});
export default DateTimePickerSafe;

================
File: app/src/app/components/responsive/ResponsiveImage.tsx
================
import React, { useMemo } from 'react';
import { Image } from 'expo-image';
import { ImageProps } from 'expo-image';
import { StyleProp, ImageStyle } from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';
interface ResponsiveImageProps
  extends Omit<ImageProps, 'style' | 'width' | 'height'> {
  style?: StyleProp<ImageStyle>;
  width?: number;
  height?: number;
  widthMobile?: number;
  widthTablet?: number;
  heightMobile?: number;
  heightTablet?: number;
  widthPortrait?: number;
  widthLandscape?: number;
  heightPortrait?: number;
  heightLandscape?: number;
  autoScale?: boolean;
  minScale?: number;
  maxScale?: number;
  aspectRatio?: number;
  maintainAspectRatio?: boolean;
  size?: 'small' | 'medium' | 'large' | 'xlarge';
  sizeTablet?: 'small' | 'medium' | 'large' | 'xlarge';
  fillContainer?: boolean;
  maxWidth?: number | string;
  maxHeight?: number | string;
  minWidth?: number | string;
  minHeight?: number | string;
  enableDPIScaling?: boolean;
  mobileStyle?: StyleProp<ImageStyle>;
  tabletStyle?: StyleProp<ImageStyle>;
  portraitStyle?: StyleProp<ImageStyle>;
  landscapeStyle?: StyleProp<ImageStyle>;
}
const PREDEFINED_SIZES = {
  small: { mobile: 40, tablet: 48 },
  medium: { mobile: 80, tablet: 96 },
  large: { mobile: 120, tablet: 160 },
  xlarge: { mobile: 200, tablet: 280 },
};
export const ResponsiveImage: React.FC<ResponsiveImageProps> = ({
  style,
  width,
  height,
  widthMobile,
  widthTablet,
  heightMobile,
  heightTablet,
  widthPortrait,
  widthLandscape,
  heightPortrait,
  heightLandscape,
  autoScale = true,
  minScale = 0.8,
  maxScale = 1.5,
  aspectRatio,
  maintainAspectRatio = true,
  size,
  sizeTablet,
  fillContainer = false,
  maxWidth,
  maxHeight,
  minWidth,
  minHeight,
  enableDPIScaling = true,
  mobileStyle,
  tabletStyle,
  portraitStyle,
  landscapeStyle,
  ...imageProps
}) => {
  const responsive = useResponsive();
  const { responsiveWidth, responsiveHeight } = useMemo(() => {
    let finalWidth: number | undefined;
    let finalHeight: number | undefined;
    if (size || sizeTablet) {
      const currentSize = responsive.isTablet && sizeTablet ? sizeTablet : size;
      if (currentSize) {
        const sizeValue = PREDEFINED_SIZES[currentSize];
        finalWidth = responsive.isTablet ? sizeValue.tablet : sizeValue.mobile;
        finalHeight = finalWidth;
      }
    }
    if (responsive.isTablet) {
      finalWidth = widthTablet || width || finalWidth;
      finalHeight = heightTablet || height || finalHeight;
    } else {
      finalWidth = widthMobile || width || finalWidth;
      finalHeight = heightMobile || height || finalHeight;
    }
    if (responsive.isPortrait) {
      finalWidth = widthPortrait || finalWidth;
      finalHeight = heightPortrait || finalHeight;
    } else if (responsive.isLandscape) {
      finalWidth = widthLandscape || finalWidth;
      finalHeight = heightLandscape || finalHeight;
    }
    if (autoScale && finalWidth) {
      finalWidth = responsive.scaleWithLimits(finalWidth, minScale, maxScale);
    }
    if (autoScale && finalHeight) {
      finalHeight = responsive.scaleWithLimits(finalHeight, minScale, maxScale);
    }
    if (maintainAspectRatio && aspectRatio && finalWidth && !finalHeight) {
      finalHeight = finalWidth / aspectRatio;
    } else if (
      maintainAspectRatio &&
      aspectRatio &&
      finalHeight &&
      !finalWidth
    ) {
      finalWidth = finalHeight * aspectRatio;
    }
    if (enableDPIScaling) {
      if (finalWidth) finalWidth = responsive.normalizeDPI(finalWidth);
      if (finalHeight) finalHeight = responsive.normalizeDPI(finalHeight);
    }
    return {
      responsiveWidth: finalWidth,
      responsiveHeight: finalHeight,
    };
  }, [
    width,
    height,
    widthMobile,
    widthTablet,
    heightMobile,
    heightTablet,
    widthPortrait,
    widthLandscape,
    heightPortrait,
    heightLandscape,
    size,
    sizeTablet,
    autoScale,
    minScale,
    maxScale,
    aspectRatio,
    maintainAspectRatio,
    enableDPIScaling,
    responsive,
  ]);
  const responsiveStyles = useMemo(() => {
    const baseStyle: ImageStyle = {};
    if (responsiveWidth) baseStyle.width = responsiveWidth;
    if (responsiveHeight) baseStyle.height = responsiveHeight;
    if (fillContainer) {
      baseStyle.width = '100%';
      baseStyle.height = '100%';
    }
    if (maxWidth) baseStyle.maxWidth = maxWidth as any;
    if (maxHeight) baseStyle.maxHeight = maxHeight as any;
    if (minWidth) baseStyle.minWidth = minWidth as any;
    if (minHeight) baseStyle.minHeight = minHeight as any;
    if (aspectRatio && !responsiveHeight && !fillContainer) {
      baseStyle.aspectRatio = aspectRatio;
    }
    const deviceStyle = responsive.isTablet ? tabletStyle : mobileStyle;
    const orientationStyle = responsive.isPortrait
      ? portraitStyle
      : landscapeStyle;
    return [baseStyle, deviceStyle, orientationStyle, style].filter(Boolean);
  }, [
    responsiveWidth,
    responsiveHeight,
    fillContainer,
    maxWidth,
    maxHeight,
    minWidth,
    minHeight,
    aspectRatio,
    mobileStyle,
    tabletStyle,
    portraitStyle,
    landscapeStyle,
    style,
    responsive,
  ]);
  const optimizedImageProps = useMemo(() => {
    const props: Partial<ImageProps> = {
      ...imageProps,
      style: responsiveStyles,
      cachePolicy: 'memory-disk',
      priority: responsive.isTablet ? 'normal' : 'high',
      contentFit: imageProps.contentFit || 'cover',
    };
    if (
      imageProps.source &&
      typeof imageProps.source === 'object' &&
      'uri' in imageProps.source
    ) {
      props.source = {
        ...imageProps.source,
      };
    }
    return props;
  }, [imageProps, responsiveStyles, responsive.isTablet]);
  return <Image {...optimizedImageProps} />;
};
export const ResponsiveAvatar: React.FC<
  ResponsiveImageProps & { rounded?: boolean }
> = ({ rounded = true, ...props }) => {
  const style: ImageStyle = rounded ? { borderRadius: 9999 } : {};
  return (
    <ResponsiveImage
      {...props}
      style={[style, props.style]}
      contentFit="cover"
      maintainAspectRatio={true}
      aspectRatio={1}
    />
  );
};
export const ResponsiveThumbnail: React.FC<ResponsiveImageProps> = (props) => {
  return (
    <ResponsiveImage
      size="medium"
      sizeTablet="large"
      contentFit="cover"
      enableDPIScaling={true}
      {...props}
    />
  );
};

================
File: app/src/app/components/responsive/ResponsiveModal.tsx
================
import React, { ReactNode, useMemo } from 'react';
import { Modal, Portal, Text, IconButton } from 'react-native-paper';
import {
  ScrollView,
  ViewStyle,
  StyleProp,
  View,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useAppTheme } from '@/app/styles/theme';
interface ResponsiveModalProps {
  visible: boolean;
  onDismiss: () => void;
  children: ReactNode;
  title?: string;
  hideCloseButton?: boolean;
  headerActions?: ReactNode;
  headerStyle?: StyleProp<ViewStyle>;
  contentContainerStyle?: StyleProp<ViewStyle>;
  style?: StyleProp<ViewStyle>;
  width?: number | string;
  widthMobile?: number | string;
  widthTablet?: number | string;
  maxWidth?: number | string;
  maxWidthMobile?: number | string;
  maxWidthTablet?: number | string;
  height?: number | string;
  heightMobile?: number | string;
  heightTablet?: number | string;
  maxHeight?: number | string;
  maxHeightMobile?: number | string;
  maxHeightTablet?: number | string;
  padding?: number;
  paddingMobile?: number;
  paddingTablet?: number;
  dismissable?: boolean;
  dismissableBackButton?: boolean;
  scrollable?: boolean;
  keyboardAvoiding?: boolean;
  fullScreen?: boolean;
  fullScreenMobile?: boolean;
  position?: 'center' | 'bottom' | 'top';
  positionMobile?: 'center' | 'bottom' | 'top';
  positionTablet?: 'center' | 'bottom' | 'top';
  animationType?: 'fade' | 'slide' | 'none';
  footer?: ReactNode;
  footerStyle?: StyleProp<ViewStyle>;
  stickyFooter?: boolean;
}
export const ResponsiveModal: React.FC<ResponsiveModalProps> = ({
  visible,
  onDismiss,
  children,
  title,
  hideCloseButton = false,
  headerActions,
  headerStyle,
  contentContainerStyle,
  style,
  width,
  widthMobile,
  widthTablet,
  maxWidth,
  maxWidthMobile,
  maxWidthTablet,
  height,
  heightMobile,
  heightTablet,
  maxHeight,
  maxHeightMobile,
  maxHeightTablet,
  padding,
  paddingMobile,
  paddingTablet,
  dismissable = true,
  dismissableBackButton = true,
  scrollable = true,
  keyboardAvoiding = true,
  fullScreen = false,
  fullScreenMobile = false,
  position = 'center',
  positionMobile,
  positionTablet,
  footer,
  footerStyle,
  stickyFooter = true,
}) => {
  const responsive = useResponsive();
  const theme = useAppTheme();
  const insets = useSafeAreaInsets();
  const isFullScreen =
    responsive.isMobile && fullScreenMobile ? true : fullScreen;
  const modalPosition = responsive.isTablet
    ? positionTablet || position
    : positionMobile || position;
  const modalDimensions = useMemo(() => {
    const dims: ViewStyle = {};
    if (responsive.isTablet) {
      dims.width = (widthTablet ||
        width ||
        responsive.dimensions.modalWidth) as any;
      dims.maxWidth = (maxWidthTablet || maxWidth || '90%') as any;
    } else {
      dims.width = (widthMobile ||
        width ||
        (isFullScreen ? '100%' : '95%')) as any;
      dims.maxWidth = (maxWidthMobile || maxWidth || '100%') as any;
    }
    if (height || heightMobile || heightTablet) {
      dims.height = (
        responsive.isTablet ? heightTablet || height : heightMobile || height
      ) as any;
    }
    if (maxHeight || maxHeightMobile || maxHeightTablet) {
      dims.maxHeight = (
        responsive.isTablet
          ? maxHeightTablet || maxHeight || '95%'
          : maxHeightMobile || maxHeight || '92%'
      ) as any;
    } else {
      dims.maxHeight = responsive.isTablet ? '95%' : '92%';
    }
    if (isFullScreen) {
      dims.width = '100%';
      dims.height = '100%';
      dims.maxWidth = '100%';
      dims.maxHeight = '100%';
    }
    return dims;
  }, [
    responsive,
    width,
    widthMobile,
    widthTablet,
    maxWidth,
    maxWidthMobile,
    maxWidthTablet,
    height,
    heightMobile,
    heightTablet,
    maxHeight,
    maxHeightMobile,
    maxHeightTablet,
    isFullScreen,
  ]);
  const modalPadding = useMemo(() => {
    if (isFullScreen) return 0;
    if (responsive.isTablet) {
      return paddingTablet || padding || responsive.spacing.l;
    } else {
      return paddingMobile || padding || responsive.spacing.m;
    }
  }, [responsive, padding, paddingMobile, paddingTablet, isFullScreen]);
  const positionStyles = useMemo(() => {
    const styles: ViewStyle = {};
    switch (modalPosition) {
      case 'bottom':
        styles.justifyContent = 'flex-end';
        break;
      case 'top':
        styles.justifyContent = 'flex-start';
        break;
      case 'center':
      default:
        styles.justifyContent = 'center';
        styles.alignItems = 'center';
        break;
    }
    return styles;
  }, [modalPosition]);
  const containerStyles = useMemo(() => {
    const baseStyles: ViewStyle = {
      backgroundColor: theme.colors.surface,
      borderRadius: isFullScreen ? 0 : theme.roundness * 2,
      overflow: 'hidden',
      ...modalDimensions,
    };
    if (modalPosition === 'bottom' && !isFullScreen) {
      baseStyles.borderBottomLeftRadius = 0;
      baseStyles.borderBottomRightRadius = 0;
      baseStyles.width = '100%';
      baseStyles.maxWidth = '100%';
    }
    if (modalPosition === 'top' && !isFullScreen) {
      baseStyles.borderTopLeftRadius = 0;
      baseStyles.borderTopRightRadius = 0;
      baseStyles.width = '100%';
      baseStyles.maxWidth = '100%';
    }
    if (isFullScreen) {
      baseStyles.paddingTop = insets.top;
      baseStyles.paddingBottom = insets.bottom;
    }
    return [baseStyles, contentContainerStyle];
  }, [
    theme,
    modalDimensions,
    modalPosition,
    isFullScreen,
    insets,
    contentContainerStyle,
  ]);
  const headerStyles = useMemo(
    () => ({
      flexDirection: 'row' as const,
      alignItems: 'center' as const,
      justifyContent: 'space-between' as const,
      paddingHorizontal: modalPadding,
      paddingVertical: modalPadding * 0.75,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    }),
    [theme, modalPadding],
  );
  const modalHeader = (title || headerActions || !hideCloseButton) && (
    <View style={[headerStyles, headerStyle]}>
      {title && (
        <Text
          variant="titleLarge"
          style={{
            color: theme.colors.onSurface,
            fontWeight: '600',
            flex: 1,
          }}
          numberOfLines={1}
        >
          {title}
        </Text>
      )}
      <View
        style={{
          flexDirection: 'row',
          alignItems: 'center',
          gap: responsive.spacing.s,
        }}
      >
        {headerActions}
        {!hideCloseButton && (
          <IconButton
            icon="close"
            size={24}
            onPress={onDismiss}
            style={{ marginRight: -responsive.spacing.s }}
          />
        )}
      </View>
    </View>
  );
  const modalContent = (
    <View
      style={{
        flex: scrollable ? 1 : undefined,
        padding: title ? 0 : modalPadding,
      }}
    >
      {title && modalHeader}
      <View
        style={{
          flex: scrollable ? 1 : undefined,
          padding: title ? modalPadding : 0,
        }}
      >
        {scrollable ? (
          <ScrollView
            showsVerticalScrollIndicator={false}
            contentContainerStyle={{ flexGrow: 1 }}
            keyboardShouldPersistTaps="handled"
          >
            {children}
          </ScrollView>
        ) : (
          children
        )}
      </View>
    </View>
  );
  const modalFooter = footer && (
    <View
      style={[
        {
          padding: modalPadding,
          paddingTop: modalPadding / 2,
          backgroundColor: theme.colors.surface,
          borderTopWidth: 1,
          borderTopColor: theme.colors.surfaceVariant,
        },
        footerStyle,
      ]}
    >
      {footer}
    </View>
  );
  return (
    <>
      {visible && (
        <Portal>
          <Modal
            visible={visible}
            onDismiss={onDismiss}
            dismissable={dismissable}
            dismissableBackButton={dismissableBackButton}
            contentContainerStyle={[positionStyles, style]}
            style={{ margin: isFullScreen ? 0 : undefined }}
          >
            {keyboardAvoiding && Platform.OS === 'ios' ? (
              <KeyboardAvoidingView
                behavior="padding"
                style={containerStyles}
                keyboardVerticalOffset={isFullScreen ? 0 : 100}
              >
                {modalContent}
                {stickyFooter && modalFooter}
              </KeyboardAvoidingView>
            ) : (
              <View style={containerStyles}>
                {modalContent}
                {stickyFooter && modalFooter}
              </View>
            )}
          </Modal>
        </Portal>
      )}
    </>
  );
};
interface ResponsiveConfirmModalProps
  extends Omit<ResponsiveModalProps, 'children'> {
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  onConfirm: () => void;
  onCancel?: () => void;
  destructive?: boolean;
}
export const ResponsiveConfirmModal: React.FC<ResponsiveConfirmModalProps> = ({
  title,
  message,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  onConfirm,
  onCancel,
  destructive = false,
  ...modalProps
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const handleCancel = () => {
    onCancel?.();
    modalProps.onDismiss();
  };
  const handleConfirm = () => {
    onConfirm();
    modalProps.onDismiss();
  };
  return (
    <ResponsiveModal
      {...modalProps}
      scrollable={false}
      maxWidthTablet={400}
      position="center"
    >
      <View style={{ paddingVertical: responsive.spacing.m }}>
        <Text
          style={[
            theme.fonts.headlineSmall,
            {
              color: theme.colors.onSurface,
              marginBottom: responsive.spacing.m,
            },
          ]}
        >
          {title}
        </Text>
        <Text
          style={[
            theme.fonts.bodyMedium,
            { color: theme.colors.onSurfaceVariant },
          ]}
        >
          {message}
        </Text>
      </View>
      <View
        style={{
          flexDirection: 'row',
          justifyContent: 'flex-end',
          gap: responsive.spacing.s,
          marginTop: responsive.spacing.l,
        }}
      >
        <Button mode="text" onPress={handleCancel} style={{ minWidth: 80 }}>
          {cancelText}
        </Button>
        <Button
          mode="contained"
          onPress={handleConfirm}
          buttonColor={destructive ? theme.colors.error : undefined}
          style={{ minWidth: 80 }}
        >
          {confirmText}
        </Button>
      </View>
    </ResponsiveModal>
  );
};
import { Button } from 'react-native-paper';

================
File: app/src/app/constants/rolePermissions.ts
================
import { RoleEnum } from '@/modules/users/types/user.types';
export type DrawerSection =
  | 'OrdersStack'
  | 'ReceiptsStack'
  | 'OrderFinalizationStack'
  | 'MenuStack'
  | 'AvailabilityStack'
  | 'ModifiersStack'
  | 'PizzaCustomizationsStack'
  | 'PreparationScreensStack'
  | 'AreasTablesStack'
  | 'PrintersStack'
  | 'RestaurantConfigStack'
  | 'CustomersStack'
  | 'SyncStack'
  | 'UsersStack'
  | 'KitchenStack'
  | 'ShiftAuditStack';
export const ROLE_PERMISSIONS: Record<RoleEnum, DrawerSection[]> = {
  [RoleEnum.ADMIN]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityStack',
    'ModifiersStack',
    'PizzaCustomizationsStack',
    'PreparationScreensStack',
    'AreasTablesStack',
    'PrintersStack',
    'RestaurantConfigStack',
    'CustomersStack',
    'SyncStack',
    'UsersStack',
    'ShiftAuditStack',
  ],
  [RoleEnum.MANAGER]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityStack',
    'ModifiersStack',
    'PizzaCustomizationsStack',
    'PreparationScreensStack',
    'AreasTablesStack',
    'PrintersStack',
    'RestaurantConfigStack',
    'CustomersStack',
    'SyncStack',
    'ShiftAuditStack',
  ],
  [RoleEnum.CASHIER]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityStack',
    'AreasTablesStack',
    'CustomersStack',
  ],
  [RoleEnum.WAITER]: [
    'OrdersStack',
    'MenuStack',
    'AvailabilityStack',
    'AreasTablesStack',
    'CustomersStack',
  ],
  [RoleEnum.KITCHEN]: ['KitchenStack'],
  [RoleEnum.DELIVERY]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'CustomersStack',
    'AreasTablesStack',
  ],
};
export const hasPermission = (
  roleId: number | undefined,
  section: DrawerSection,
): boolean => {
  if (!roleId) return false;
  const permissions = ROLE_PERMISSIONS[roleId as RoleEnum];
  return permissions ? permissions.includes(section) : false;
};
export const DRAWER_SECTIONS = {
  sales: {
    title: 'Ventas',
    items: [
      {
        route: 'OrdersStack',
        label: 'Órdenes',
        icon: 'clipboard-list-outline',
      },
      {
        route: 'OrderFinalizationStack',
        label: 'Finalización',
        icon: 'clipboard-check-outline',
      },
      { route: 'ReceiptsStack', label: 'Recibos', icon: 'receipt' },
    ],
  },
  configuration: {
    title: 'Configuración',
    items: [
      { route: 'MenuStack', label: 'Menú', icon: 'menu' },
      {
        route: 'AvailabilityStack',
        label: 'Disponibilidad',
        icon: 'eye-off-outline',
      },
      { route: 'ModifiersStack', label: 'Modificadores', icon: 'tune' },
      {
        route: 'PizzaCustomizationsStack',
        label: 'Personalización Pizzas',
        icon: 'pizza',
      },
      {
        route: 'PreparationScreensStack',
        label: 'Pantallas Preparación',
        icon: 'monitor-dashboard',
      },
      {
        route: 'AreasTablesStack',
        label: 'Áreas y Mesas',
        icon: 'map-marker-radius-outline',
      },
      { route: 'PrintersStack', label: 'Impresoras', icon: 'printer' },
      {
        route: 'RestaurantConfigStack',
        label: 'Configuración',
        icon: 'cog-outline',
      },
      {
        route: 'CustomersStack',
        label: 'Clientes',
        icon: 'account-group-outline',
      },
      { route: 'SyncStack', label: 'Sincronización', icon: 'sync' },
    ],
  },
  administration: {
    title: 'Administración',
    items: [
      { route: 'UsersStack', label: 'Usuarios', icon: 'account-multiple' },
      {
        route: 'ShiftAuditStack',
        label: 'Historial de Turnos',
        icon: 'history',
      },
    ],
  },
} as const;

================
File: app/src/app/hooks/useInitializeAuth.ts
================
import { useEffect, useState } from 'react';
import { initializeAuthStore } from '../store/authStore';
import { verifyStoredToken } from '../utils/tokenVerification';
export function useInitializeAuth() {
  const [isInitializing, setIsInitializing] = useState(true);
  useEffect(() => {
    const initialize = async () => {
      try {
        await initializeAuthStore();
        await verifyStoredToken();
      } catch (error) {
      } finally {
        setIsInitializing(false);
      }
    };
    initialize();
  }, []);
  return isInitializing;
}

================
File: app/src/app/hooks/useNativeDriver.ts
================
import { Platform } from 'react-native';
export function useNativeDriver(): boolean {
  return Platform.OS !== 'web';
}

================
File: app/src/app/lib/errorMapping.ts
================
import { ApiError } from './errors';
import { ERROR_CODES, ApiErrorCode } from '../constants/apiErrorCodes';
import { AxiosError } from 'axios';
const errorCodeMessages: { [key in ApiErrorCode | string]?: string } = {
  [ERROR_CODES.AUTH_INVALID_CREDENTIALS]:
    'El correo/usuario o la contraseña son incorrectos.',
  [ERROR_CODES.AUTH_INCORRECT_PASSWORD]: 'La contraseña es incorrecta.',
  [ERROR_CODES.AUTH_DUPLICATE_EMAIL]:
    'Este correo electrónico ya está registrado. Intenta iniciar sesión.',
  [ERROR_CODES.AUTH_DUPLICATE_USERNAME]:
    'Este nombre de usuario ya está en uso. Elige otro.',
  [ERROR_CODES.AUTH_UNAUTHORIZED]:
    'No autorizado. Por favor, inicia sesión de nuevo.',
  [ERROR_CODES.AUTH_FORBIDDEN]: 'No tienes permiso para realizar esta acción.',
  [ERROR_CODES.REFRESH_FAILED]:
    'Tu sesión ha expirado. Por favor, inicia sesión nuevamente.',
  [ERROR_CODES.VALIDATION_ERROR]: 'Por favor, revisa la información ingresada.',
  [ERROR_CODES.RESOURCE_NOT_FOUND]: 'El recurso solicitado no se encontró.',
  [ERROR_CODES.CONFLICT_ERROR]: 'Hubo un conflicto al procesar tu solicitud.',
  [ERROR_CODES.PRODUCT_NAME_EXISTS]:
    'Ya existe un producto con ese nombre. Por favor, elige otro nombre.',
  [ERROR_CODES.NETWORK_ERROR]:
    'Error de red. Verifica tu conexión e inténtalo de nuevo.',
  [ERROR_CODES.API_CLIENT_ERROR]: 'Error al comunicar con el servidor.',
  [ERROR_CODES.INTERNAL_SERVER_ERROR]:
    'Ocurrió un error en el servidor. Inténtalo de nuevo más tarde.',
  [ERROR_CODES.UNKNOWN_API_ERROR]:
    'Ocurrió un error inesperado al procesar tu solicitud.',
  [ERROR_CODES.UNKNOWN_ERROR]: 'Ocurrió un error desconocido.',
  [`status_400`]: 'La solicitud contiene datos inválidos.',
  [`status_401`]: 'No autorizado. Por favor, inicia sesión de nuevo.',
  [`status_403`]: 'No tienes permiso para realizar esta acción.',
  [`status_404`]: 'El recurso solicitado no se encontró.',
  [`status_409`]: 'Existe un conflicto con el estado actual del recurso.',
  [`status_422`]: 'Los datos enviados son inválidos o incompletos.',
  [`status_500`]: 'Error interno del servidor. Por favor, intenta más tarde.',
  [`status_502`]: 'Error de conexión con el servidor.',
  [`status_503`]: 'El servicio no está disponible temporalmente.',
  AUTH_USER_NOT_FOUND: 'Usuario no encontrado.',
  AUTH_EMAIL_NOT_CONFIRMED:
    'Por favor, confirma tu correo electrónico antes de iniciar sesión.',
  AUTH_ACCOUNT_LOCKED:
    'Tu cuenta ha sido bloqueada. Contacta al administrador.',
  AUTH_SESSION_EXPIRED:
    'Tu sesión ha expirado. Por favor, inicia sesión nuevamente.',
  VALIDATION_FAILED: 'Error de validación. Revisa los datos ingresados.',
  DUPLICATE_ENTRY: 'Ya existe un registro con estos datos.',
  INVALID_INPUT: 'Los datos ingresados no son válidos.',
  MISSING_REQUIRED_FIELD: 'Faltan campos obligatorios.',
  INSUFFICIENT_PERMISSIONS:
    'No tienes permisos suficientes para realizar esta acción.',
  RATE_LIMIT_EXCEEDED:
    'Has realizado demasiadas solicitudes. Intenta más tarde.',
  ORDER_NOT_FOUND: 'La orden no fue encontrada.',
  ORDER_ALREADY_COMPLETED: 'Esta orden ya fue completada.',
  ORDER_CANNOT_BE_MODIFIED:
    'Esta orden no puede ser modificada en su estado actual.',
  TABLE_ALREADY_OCCUPIED: 'La mesa seleccionada ya está ocupada.',
  INVALID_ORDER_TYPE: 'Tipo de orden inválido.',
  NO_ITEMS_IN_ORDER: 'La orden debe contener al menos un producto.',
  PRODUCT_NOT_FOUND: 'El producto no fue encontrado.',
  PRODUCT_NOT_AVAILABLE: 'El producto no está disponible en este momento.',
  PRODUCT_OUT_OF_STOCK: 'El producto está agotado.',
  INVALID_PRODUCT_VARIANT: 'La variante del producto no es válida.',
  INVALID_MODIFIER: 'El modificador seleccionado no es válido.',
  TABLE_NOT_FOUND: 'La mesa no fue encontrada.',
  AREA_NOT_FOUND: 'El área no fue encontrada.',
  TABLE_IN_USE: 'La mesa está siendo utilizada en otra orden.',
  PRINTER_NOT_FOUND: 'La impresora no fue encontrada.',
  PRINTER_OFFLINE: 'La impresora no está disponible.',
  PRINT_FAILED: 'Error al imprimir. Verifica la conexión de la impresora.',
  THERMAL_PRINTER_DUPLICATE_FIELD: 'Ya existe una impresora con ese nombre.',
  CATEGORY_NOT_FOUND: 'La categoría no fue encontrada.',
  SUBCATEGORY_NOT_FOUND: 'La subcategoría no fue encontrada.',
  CATEGORY_HAS_PRODUCTS:
    'No se puede eliminar la categoría porque tiene productos asociados.',
  [ERROR_CODES.UPLOAD_FAILED]:
    'Error al subir el archivo. Por favor, intenta nuevamente.',
  [ERROR_CODES.FILE_TOO_LARGE]:
    'El archivo es demasiado grande. El tamaño máximo permitido es 10MB.',
  cantUploadFileType:
    'El tipo de archivo no está permitido. Solo se permiten imágenes (JPG, JPEG, PNG, GIF).',
};
export function getApiErrorMessage(error: unknown): string {
  const defaultMessage = 'Ocurrió un error inesperado.';
  if (error instanceof ApiError) {
    if (
      error.originalMessage &&
      error.originalMessage !== 'Error desconocido de la API.' &&
      error.originalMessage !== 'Not Found' &&
      error.originalMessage !== 'Internal Server Error' &&
      error.originalMessage !==
        'Ocurrió un error inesperado al procesar tu solicitud.' &&
      !error.originalMessage.includes('<!DOCTYPE')
    ) {
      return error.originalMessage;
    }
    let message = errorCodeMessages[error.code];
    if (!message) {
      message = errorCodeMessages[`status_${error.status}`];
    }
    if (message === errorCodeMessages[`status_409`] && error.details?.message) {
      return error.details.message;
    }
    return message || defaultMessage;
  } else if (error instanceof AxiosError) {
    if (error.message === 'Network Error' || !error.response) {
      return errorCodeMessages[ERROR_CODES.NETWORK_ERROR] || 'Error de red.';
    }
    if (error.response?.status) {
      const statusMessage =
        errorCodeMessages[`status_${error.response.status}`];
      if (statusMessage) return statusMessage;
    }
    return errorCodeMessages[ERROR_CODES.UNKNOWN_API_ERROR] || defaultMessage;
  } else if (error instanceof Error) {
    if (
      error.message.toLowerCase().includes('network request failed') ||
      error.message.toLowerCase().includes('failed to fetch')
    ) {
      return errorCodeMessages[ERROR_CODES.NETWORK_ERROR] || 'Error de red.';
    }
    return error.message && !error.message.toLowerCase().includes('undefined')
      ? error.message
      : defaultMessage;
  } else {
    return defaultMessage;
  }
}

================
File: app/src/app/lib/formatters.ts
================
export function formatCurrency(
  amount: number | null | undefined,
  currency = 'MXN',
): string {
  if (amount === null || amount === undefined || isNaN(amount)) {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(0);
  }
  return new Intl.NumberFormat('es-MX', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
}
export function formatPhoneNumber(phoneNumber: string): string {
  const cleaned = phoneNumber.replace(/\D/g, '');
  // Formato mexicano: +52 55 1234 5678
  if (cleaned.length === 10) {
    return `${cleaned.slice(0, 2)} ${cleaned.slice(2, 6)} ${cleaned.slice(6)}`;
  } else if (cleaned.length === 12 && cleaned.startsWith('52')) {
    return `+${cleaned.slice(0, 2)} ${cleaned.slice(2, 4)} ${cleaned.slice(4, 8)} ${cleaned.slice(8)}`;
  }
  return phoneNumber;
}

================
File: app/src/app/lib/imageUtils.ts
================
import { serverConnectionService } from '@/services/serverConnectionService';
export const getImageUrl = async (
  imagePath: string | null | undefined,
): Promise<string | null> => {
  if (!imagePath || typeof imagePath !== 'string') {
    return null;
  }
  try {
    const connectionState = serverConnectionService.getState();
    if (!connectionState.serverUrl || !connectionState.isConnected) {
      return null;
    }
    const apiUrl = connectionState.serverUrl;
    const normalizedApiUrl = apiUrl.endsWith('/')
      ? apiUrl.slice(0, -1)
      : apiUrl;
    const normalizedPath = imagePath.replace(/\\/g, '/');
    if (normalizedPath.startsWith('http')) {
      const urlObj = new URL(normalizedPath);
      const pathPart = urlObj.pathname;
      return `${normalizedApiUrl}${pathPart}`;
    }
    const formattedPath = normalizedPath.startsWith('/')
      ? normalizedPath
      : `/${normalizedPath}`;
    return `${normalizedApiUrl}${formattedPath}`;
  } catch (error) {
    return null;
  }
};
export const getImageUrlSync = (
  imagePath: string | null | undefined,
  apiUrl: string,
): string | null => {
  if (!imagePath || typeof imagePath !== 'string') {
    return null;
  }
  const normalizedApiUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
  const normalizedPath = imagePath.replace(/\\/g, '/');
  if (normalizedPath.startsWith('http')) {
    const urlObj = new URL(normalizedPath);
    const pathPart = urlObj.pathname;
    return `${normalizedApiUrl}${pathPart}`;
  }
  const formattedPath = normalizedPath.startsWith('/')
    ? normalizedPath
    : `/${normalizedPath}`;
  return `${normalizedApiUrl}${formattedPath}`;
};
export const clearApiUrlCache = () => {
  cachedApiUrl = null;
  cacheTimestamp = 0;
};

================
File: app/src/app/lib/zodResolver.ts
================
import type { FieldErrors, FieldValues, ResolverResult } from 'react-hook-form';
import type { ZodSchema, ZodError } from 'zod';
export function zodResolver<T extends FieldValues>(schema: ZodSchema<T>) {
  return async (data: T): Promise<ResolverResult<T>> => {
    try {
      const validatedData = await schema.parseAsync(data);
      return {
        values: validatedData,
        errors: {},
      };
    } catch (error) {
      if (error instanceof Error && 'errors' in error) {
        const zodError = error as ZodError;
        const fieldErrors: FieldErrors<T> = {};
        zodError.errors.forEach((err) => {
          const path = err.path.join('.');
          if (path) {
            fieldErrors[path as keyof T] = {
              type: err.code,
              message: err.message,
            };
          }
        });
        return {
          values: {} as T,
          errors: fieldErrors,
        };
      }
      throw error;
    }
  };
}

================
File: app/src/app/navigation/components/WebDrawer.tsx
================
import React, { useEffect } from 'react';
import {
  View,
  StyleSheet,
  Pressable,
  Animated,
  Platform,
  ScrollView,
} from 'react-native';
import { Portal } from 'react-native-paper';
import { useAppTheme } from '../../styles/theme';
interface WebDrawerProps {
  open: boolean;
  onClose: () => void;
  children: React.ReactNode;
  drawerContent: React.ReactNode;
  drawerWidth?: number;
}
export function WebDrawer({
  open,
  onClose,
  children,
  drawerContent,
  drawerWidth = 320,
}: WebDrawerProps) {
  const theme = useAppTheme();
  const slideAnim = React.useRef(new Animated.Value(-drawerWidth)).current;
  const fadeAnim = React.useRef(new Animated.Value(0)).current;
  useEffect(() => {
    if (open) {
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: -drawerWidth,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [open, slideAnim, fadeAnim, drawerWidth]);
  useEffect(() => {
    if (Platform.OS === 'web' && open) {
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          onClose();
        }
      };
      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }
  }, [open, onClose]);
  const styles = StyleSheet.create({
    container: {
      flex: 1,
    },
    overlay: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      zIndex: 998,
    },
    drawer: {
      position: 'absolute',
      top: 0,
      left: 0,
      bottom: 0,
      width: drawerWidth,
      backgroundColor: theme.colors.surface,
      elevation: 16,
      shadowColor: '#000',
      shadowOffset: { width: 2, height: 0 },
      shadowOpacity: 0.25,
      shadowRadius: 10,
      zIndex: 999,
      borderRightWidth: 1,
      borderRightColor: theme.colors.outlineVariant,
    },
  });
  if (Platform.OS !== 'web') {
    return <>{children}</>;
  }
  return (
    <View style={styles.container}>
      {children}
      {open && (
        <Portal>
          <Animated.View
            style={[
              styles.overlay,
              {
                opacity: fadeAnim,
              },
            ]}
          >
            <Pressable style={StyleSheet.absoluteFill} onPress={onClose} />
          </Animated.View>
          <Animated.View
            style={[
              styles.drawer,
              {
                transform: [{ translateX: slideAnim }],
              },
            ]}
          >
            <ScrollView
              contentContainerStyle={{ flexGrow: 1 }}
              showsVerticalScrollIndicator={false}
            >
              {drawerContent}
            </ScrollView>
          </Animated.View>
        </Portal>
      )}
    </View>
  );
}

================
File: app/src/app/navigation/components/WebDrawerContent.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { ScrollView } from 'react-native';
import {
  Drawer as PaperDrawer,
  Text,
  Divider,
  Switch,
  TouchableRipple,
  Icon,
  Surface,
  Portal,
  Dialog,
  Button,
} from 'react-native-paper';
import { useThemeStore } from '../../store/themeStore';
import { THEME_MODE } from '../../types/theme.types';
import { useAuthStore } from '../../store/authStore';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
import { clearImageCache } from '../../lib/imageCache';
import { useSnackbarStore } from '../../store/snackbarStore';
import { RoleEnum } from '@/modules/users/types/user.types';
interface WebDrawerContentProps {
  onClose: () => void;
}
const ROLE_TRANSLATIONS: Record<number, string> = {
  [RoleEnum.ADMIN]: 'Administrador',
  [RoleEnum.MANAGER]: 'Gerente',
  [RoleEnum.CASHIER]: 'Cajero',
  [RoleEnum.WAITER]: 'Mesero',
  [RoleEnum.KITCHEN]: 'Cocina',
  [RoleEnum.DELIVERY]: 'Repartidor',
};
const getRoleTranslation = (roleId?: number): string => {
  if (!roleId) return 'Desconocido';
  return ROLE_TRANSLATIONS[roleId] || 'Desconocido';
};
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    userInfoSection: {
      padding: responsive.spacing(theme.spacing.m),
    },
    title: {
      ...theme.fonts.titleMedium,
      fontSize: responsive.fontSize(theme.fonts.titleMedium.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(4),
    },
    caption: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(2),
    },
    drawerSection: {
      marginTop: responsive.spacing(theme.spacing.s),
    },
    bottomDrawerSection: {
      marginBottom: responsive.spacing(theme.spacing.m),
      marginTop: 'auto',
      borderTopColor: theme.colors.outlineVariant,
      borderTopWidth: StyleSheet.hairlineWidth,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    preference: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
    },
    drawerItemLabel: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
    },
    drawerItemContainer: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      flexDirection: 'row',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xxs),
    },
    drawerItemIconContainer: {
      marginRight: responsive.spacing(theme.spacing.l),
      width: responsive.isTablet ? 20 : theme.spacing.l,
      alignItems: 'center',
    },
    divider: {
      marginVertical: responsive.spacing(theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m),
    },
    configSubheader: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
      color: theme.colors.onSurfaceVariant,
      paddingLeft: responsive.spacing(theme.spacing.l),
      paddingRight: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xxs),
    },
  });
export function WebDrawerContent({ onClose }: WebDrawerContentProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const logout = useAuthStore((state) => state.logout);
  const setThemePreference = useThemeStore((state) => state.setThemePreference);
  const user = useAuthStore((state) => state.user);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [showServerSettings, setShowServerSettings] = React.useState(false);
  React.useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [onClose]);
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const handleClearCache = async () => {
    try {
      await clearImageCache();
      showSnackbar({
        message: 'Caché de imágenes limpiado exitosamente',
        type: 'success',
      });
    } catch (error) {
      showSnackbar({
        message: 'Error al limpiar el caché',
        type: 'error',
      });
    }
  };
  return (
    <Surface style={styles.container} elevation={0}>
      <ScrollView
        contentContainerStyle={{ paddingTop: 0 }}
        showsVerticalScrollIndicator={false}
      >
        <View style={{ flex: 1 }}>
          <Surface style={styles.userInfoSection} elevation={0}>
            {user ? (
              <>
                <Text style={styles.title} numberOfLines={1}>
                  {`${user.firstName ?? ''} ${user.lastName ?? ''}`.trim() ||
                    user.username ||
                    'Usuario'}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  Rol: {getRoleTranslation(user.role?.id)}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  {user.email ?? ''}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  @{user.username ?? 'username'}
                </Text>
              </>
            ) : (
              <Text style={styles.title}>Invitado</Text>
            )}
          </Surface>
          <Divider style={styles.divider} />
          {}
          {user?.role?.id === 5 && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>Cocina</Text>
              <TouchableRipple
                onPress={() => {
                  onClose();
                }}
                style={styles.drawerItemContainer}
                rippleColor={`${theme.colors.primary}20`}
              >
                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                  <View style={styles.drawerItemIconContainer}>
                    <Icon
                      source="chef-hat"
                      size={responsive.isTablet ? 20 : 24}
                      color={theme.colors.primary}
                    />
                  </View>
                  <Text
                    style={[
                      styles.drawerItemLabel,
                      { color: theme.colors.primary },
                    ]}
                  >
                    Pantalla de Preparación
                  </Text>
                </View>
              </TouchableRipple>
            </PaperDrawer.Section>
          )}
        </View>
      </ScrollView>
      <PaperDrawer.Section style={styles.bottomDrawerSection}>
        <TouchableRipple
          onPress={() => {
            const newPreference = theme.dark
              ? THEME_MODE.LIGHT
              : THEME_MODE.DARK;
            setThemePreference(newPreference);
          }}
          style={styles.preference}
        >
          <View
            style={{
              flexDirection: 'row',
              alignItems: 'center',
              justifyContent: 'space-between',
              width: '100%',
            }}
          >
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              <View style={styles.drawerItemIconContainer}>
                <Icon
                  source={theme.dark ? 'weather-night' : 'white-balance-sunny'}
                  size={responsive.isTablet ? 20 : 24}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
              <Text
                style={[
                  styles.drawerItemLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                Modo Oscuro
              </Text>
            </View>
            <View style={{ pointerEvents: 'none' }}>
              <Switch value={theme.dark} color={theme.colors.primary} />
            </View>
          </View>
        </TouchableRipple>
        <TouchableRipple
          onPress={handleClearCache}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="broom"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Limpiar Caché
            </Text>
          </View>
        </TouchableRipple>
        <TouchableRipple
          onPress={() => {
            setShowServerSettings(true);
            onClose();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="server-network"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Configuración del Servidor
            </Text>
          </View>
        </TouchableRipple>
        <TouchableRipple
          onPress={() => {
            logout();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.error}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="logout"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.error}
              />
            </View>
            <Text
              style={[styles.drawerItemLabel, { color: theme.colors.error }]}
            >
              Cerrar Sesión
            </Text>
          </View>
        </TouchableRipple>
      </PaperDrawer.Section>
      {}
      {showServerSettings && (
        <Portal>
          <Dialog
            visible={showServerSettings}
            onDismiss={() => setShowServerSettings(false)}
            style={{ maxWidth: 600, alignSelf: 'center' }}
          >
            <Dialog.Title>Configuración del Servidor</Dialog.Title>
            <Dialog.ScrollArea style={{ maxHeight: 400 }}>
              <Text style={{ marginBottom: 16 }}>
                Para configurar el servidor en la versión web, utiliza la
                aplicación móvil.
              </Text>
              <Text style={{ marginBottom: 8 }}>
                La configuración del servidor incluye:
              </Text>
              <Text style={{ marginLeft: 16 }}>
                • Modo de conexión (Auto/Manual)
              </Text>
              <Text style={{ marginLeft: 16 }}>• URL del servidor</Text>
              <Text style={{ marginLeft: 16 }}>• Prueba de conexión</Text>
            </Dialog.ScrollArea>
            <Dialog.Actions>
              <Button onPress={() => setShowServerSettings(false)}>
                Cerrar
              </Button>
            </Dialog.Actions>
          </Dialog>
        </Portal>
      )}
    </Surface>
  );
}

================
File: app/src/app/navigation/KitchenWebNavigator.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Text,
} from 'react-native';
import { Icon, Surface, Checkbox } from 'react-native-paper';
import { WebDrawer } from './components/WebDrawer';
import { WebDrawerContent } from './components/WebDrawerContent';
import KitchenNavigator from '../../modules/kitchen/navigation/KitchenNavigator';
import { useAppTheme } from '../styles/theme';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { RefreshButton } from '../../modules/kitchen/components/RefreshButton';
import { useAuthStore } from '../store/authStore';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderType } from '../../modules/kitchen/types/kitchen.types';
import { KitchenProvider } from '../../modules/kitchen/context/KitchenContext';
export function KitchenWebNavigator() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const screenName = user?.preparationScreen?.name || 'Pantalla de Preparación';
  const [drawerOpen, setDrawerOpen] = useState(false);
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderType.DINE_IN:
        return ' • Mesa';
      case OrderType.TAKE_AWAY:
        return ' • Llevar';
      case OrderType.DELIVERY:
        return ' • Domicilio';
      default:
        return '';
    }
  };
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.primary,
      height: responsive.isWeb ? 80 : responsive.dimensions.headerHeight,
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: responsive.spacing.m,
      elevation: 2,
    },
    drawerButtonContainer: {
      width: 56,
      height: 56,
      justifyContent: 'center',
      alignItems: 'center',
      marginLeft: 0,
      borderRadius: 28,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    headerTitle: {
      ...theme.fonts.titleLarge,
      color: theme.colors.onPrimary,
      fontWeight: 'bold',
      fontSize: responsive.isWeb ? 26 : 22,
    },
    filterIndicator: {
      ...theme.fonts.titleMedium,
      fontWeight: '500',
      opacity: 0.9,
      color: theme.colors.onPrimary,
    },
    content: {
      flex: 1,
    },
  });
  return (
    <KitchenProvider>
      <View style={styles.container}>
        <StatusBar
          backgroundColor={theme.colors.primary}
          barStyle={theme.dark ? 'light-content' : 'dark-content'}
        />
        <WebDrawer
          open={drawerOpen}
          onClose={() => setDrawerOpen(false)}
          drawerWidth={
            responsive.isWeb ? 320 : responsive.dimensions.drawerWidth
          }
          drawerContent={
            <WebDrawerContent onClose={() => setDrawerOpen(false)} />
          }
        >
          <View style={styles.container}>
            {}
            <View style={styles.header}>
              <TouchableOpacity
                style={styles.drawerButtonContainer}
                onPress={() => setDrawerOpen(true)}
                hitSlop={{ top: 30, bottom: 30, left: 30, right: 30 }}
              >
                <Icon
                  source="menu"
                  size={responsive.isWeb ? 36 : 32}
                  color={theme.colors.onPrimary}
                />
              </TouchableOpacity>
              <View style={styles.headerContent}>
                <Surface
                  elevation={0}
                  style={{
                    backgroundColor: 'transparent',
                  }}
                >
                  <View style={styles.titleContainer}>
                    <Text style={styles.headerTitle}>{screenName}</Text>
                    {filters.orderType && (
                      <Text style={styles.filterIndicator}>
                        {getFilterText()}
                      </Text>
                    )}
                  </View>
                </Surface>
                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                  {}
                  <TouchableOpacity
                    style={{
                      flexDirection: 'row',
                      alignItems: 'center',
                      paddingHorizontal: 12,
                      paddingVertical: 8,
                      marginRight: 8,
                      backgroundColor: filters.showPrepared
                        ? 'rgba(255,255,255,0.2)'
                        : 'transparent',
                      borderRadius: 20,
                    }}
                    onPress={() =>
                      setFilters({
                        ...filters,
                        showPrepared: !filters.showPrepared,
                      })
                    }
                  >
                    <Checkbox
                      status={filters.showPrepared ? 'checked' : 'unchecked'}
                      onPress={() =>
                        setFilters({
                          ...filters,
                          showPrepared: !filters.showPrepared,
                        })
                      }
                      color={theme.colors.onPrimary}
                      uncheckedColor={theme.colors.onPrimary}
                    />
                    <Text
                      style={{
                        color: theme.colors.onPrimary,
                        fontSize: responsive.isWeb ? 16 : 14,
                        marginLeft: 4,
                        fontWeight: filters.showPrepared ? 'bold' : 'normal',
                      }}
                    >
                      Mostrar Listas
                    </Text>
                  </TouchableOpacity>
                  <KitchenFilterButton />
                  <RefreshButton />
                  <ConnectionIndicator />
                </View>
              </View>
            </View>
            {}
            <View style={styles.content}>
              <KitchenNavigator />
            </View>
          </View>
        </WebDrawer>
      </View>
    </KitchenProvider>
  );
}

================
File: app/src/app/schemas/domain/table.schema.ts
================
import { z } from 'zod';
export const tableSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  areaId: z.string().uuid(),
  capacity: z.number().int().nullable().optional(),
  isActive: z.boolean(),
  isAvailable: z.boolean(),
  isTemporary: z.boolean(),
  temporaryIdentifier: z.string().nullable().optional(),
  area: z
    .object({
      id: z.string().uuid(),
      name: z.string(),
    })
    .optional(),
  createdAt: z.union([z.string().datetime(), z.date()]).optional(),
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(),
});
export type Table = z.infer<typeof tableSchema>;

================
File: app/src/app/services/certificateValidator.ts
================
import { Platform } from 'react-native';
export class CertificateValidator {
  private static instance: CertificateValidator;
  private isProduction: boolean;
  private constructor() {
    this.isProduction = !__DEV__;
  }
  static getInstance(): CertificateValidator {
    if (!CertificateValidator.instance) {
      CertificateValidator.instance = new CertificateValidator();
    }
    return CertificateValidator.instance;
  }
  isSecureUrl(url: string): boolean {
    if (!this.isProduction) {
      return true;
    }
    try {
      const urlObj = new URL(url);
      if (this.isExternalDomain(urlObj.hostname)) {
        return urlObj.protocol === 'https:';
      }
      return this.isLocalNetwork(urlObj.hostname);
    } catch {
      return false;
    }
  }
  private isLocalNetwork(hostname: string): boolean {
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return true;
    }
    const parts = hostname.split('.');
    if (parts.length === 4) {
      const firstOctet = parseInt(parts[0]);
      const secondOctet = parseInt(parts[1]);
      if (firstOctet === 10) return true;
      if (firstOctet === 172 && secondOctet >= 16 && secondOctet <= 31)
        return true;
      if (firstOctet === 192 && secondOctet === 168) return true;
    }
    return false;
  }
  private isExternalDomain(hostname: string): boolean {
    return (
      !this.isLocalNetwork(hostname) &&
      !hostname.includes('.local') &&
      !hostname.includes('.internal')
    );
  }
  getAxiosSecurityConfig() {
    if (Platform.OS === 'android' && this.isProduction) {
      return {
        httpsAgent: {
          rejectUnauthorized: true,
        },
      };
    }
    return {};
  }
  validateConnection(url: string): void {
    if (!this.isSecureUrl(url)) {
      throw new Error(
        `Conexión insegura bloqueada: ${url}. ` +
          'En producción solo se permiten conexiones HTTPS a dominios externos.',
      );
    }
  }
}
export const certificateValidator = CertificateValidator.getInstance();

================
File: app/src/app/store/themeStore.ts
================
import React from 'react';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useColorScheme, Appearance } from 'react-native';
import {
  ThemePreference,
  THEME_PREFERENCE_STORAGE_KEY,
  THEME_MODE,
} from '../types/theme.types';
import { lightTheme, darkTheme } from '../styles/theme';
interface ThemeState {
  themePreference: ThemePreference;
  activeTheme: typeof lightTheme | typeof darkTheme;
  isSystemDarkMode: boolean | null;
  setThemePreference: (preference: ThemePreference) => void;
  setSystemDarkMode: (isDark: boolean | null) => void;
}
export const useThemeStore = create<ThemeState>()(
  persist(
    (set, get) => ({
      themePreference: THEME_MODE.SYSTEM,
      activeTheme: lightTheme,
      isSystemDarkMode: null,
      setThemePreference: (preference: ThemePreference) => {
        const { isSystemDarkMode } = get();
        set({ themePreference: preference });
        if (preference === THEME_MODE.SYSTEM) {
          if (isSystemDarkMode !== null) {
            set({ activeTheme: isSystemDarkMode ? darkTheme : lightTheme });
          }
        } else {
          set({
            activeTheme:
              preference === THEME_MODE.DARK ? darkTheme : lightTheme,
          });
        }
      },
      setSystemDarkMode: (isDark: boolean | null) => {
        const { themePreference } = get();
        set({ isSystemDarkMode: isDark });
        if (themePreference === THEME_MODE.SYSTEM && isDark !== null) {
          set({ activeTheme: isDark ? darkTheme : lightTheme });
        }
      },
    }),
    {
      name: THEME_PREFERENCE_STORAGE_KEY,
      storage: createJSONStorage(() => EncryptedStorage),
      partialize: (state) => ({ themePreference: state.themePreference }),
      onRehydrateStorage: () => {
        return (state, error) => {
          if (error) {
            return;
          }
          if (!state) {
            return;
          }
          const preference = state.themePreference;
          if (preference === THEME_MODE.LIGHT) {
            state.activeTheme = lightTheme;
            state.isSystemDarkMode = Appearance.getColorScheme() === 'dark';
          } else if (preference === THEME_MODE.DARK) {
            state.activeTheme = darkTheme;
            state.isSystemDarkMode = Appearance.getColorScheme() === 'dark';
          } else {
            const systemScheme = Appearance.getColorScheme();
            const isSystemDark = systemScheme === 'dark';
            state.isSystemDarkMode = isSystemDark;
            state.activeTheme = isSystemDark ? darkTheme : lightTheme;
          }
        };
      },
    },
  ),
);
export function useSystemThemeDetector() {
  const systemColorScheme = useColorScheme();
  const setSystemDarkMode = useThemeStore((state) => state.setSystemDarkMode);
  React.useEffect(() => {
    const isDarkMode = systemColorScheme === 'dark';
    if (useThemeStore.getState().isSystemDarkMode !== isDarkMode) {
      setSystemDarkMode(isDarkMode);
    }
  }, [systemColorScheme, setSystemDarkMode]);
}

================
File: app/src/app/utils/orderFormatters.ts
================
import type {
  OrderStatus,
  OrderType,
  Order,
} from '@/modules/orders/types/orders.types';
import {
  OrderStatusEnum,
  OrderTypeEnum,
} from '@/modules/orders/types/orders.types';
import type { OrderOpenList } from '@/modules/orders/types/orders.types';
import type { OrderForFinalizationList } from '@/modules/orderFinalization/types/orderFinalization.types';
export const formatOrderType = (type: OrderType): string => {
  switch (type) {
    case OrderTypeEnum.DINE_IN:
      return '🍽️ Para Comer Aquí';
    case OrderTypeEnum.TAKE_AWAY:
      return '🥡 Para Llevar';
    case OrderTypeEnum.DELIVERY:
      return '🚚 Domicilio';
    default:
      return type;
  }
};
export const formatOrderTypeShort = (type: OrderType | string): string => {
  switch (type) {
    case OrderTypeEnum.DINE_IN:
    case 'DINE_IN':
      return '🍽️ Local';
    case OrderTypeEnum.TAKE_AWAY:
    case 'TAKE_AWAY':
    case 'TAKEOUT':
      return '🥡 Llevar';
    case OrderTypeEnum.DELIVERY:
    case 'DELIVERY':
      return '🚚 Envío';
    default:
      return type;
  }
};
export const formatOrderStatus = (status: OrderStatus | string): string => {
  switch (status) {
    case OrderStatusEnum.PENDING:
    case 'PENDING':
      return 'Pendiente';
    case OrderStatusEnum.IN_PROGRESS:
    case 'IN_PROGRESS':
      return 'En Progreso';
    case OrderStatusEnum.IN_PREPARATION:
    case 'IN_PREPARATION':
      return 'En Preparación';
    case OrderStatusEnum.READY:
    case 'READY':
      return 'Lista';
    case OrderStatusEnum.DELIVERED:
    case 'DELIVERED':
      return 'Entregada';
    case OrderStatusEnum.COMPLETED:
    case 'COMPLETED':
      return 'Completada';
    case OrderStatusEnum.CANCELLED:
    case 'CANCELLED':
      return 'Cancelada';
    default:
      return status;
  }
};
export const formatOrderStatusAlt = (status: string): string => {
  switch (status) {
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En preparación';
    case 'READY':
      return 'Listo';
    case 'DELIVERED':
      return 'Entregado';
    default:
      return status;
  }
};
export const getStatusColor = (
  status: OrderStatus | string,
  theme?: any,
): string => {
  switch (status) {
    case OrderStatusEnum.PENDING:
    case 'PENDING':
      return '#FFA000';
    case OrderStatusEnum.IN_PROGRESS:
    case 'IN_PROGRESS':
      return theme?.colors?.primary || '#6200EE';
    case OrderStatusEnum.READY:
    case 'READY':
      return '#4CAF50';
    case OrderStatusEnum.DELIVERED:
    case 'DELIVERED':
      return theme?.colors?.tertiary || '#9C27B0';
    default:
      return theme?.colors?.onSurfaceVariant || '#757575';
  }
};
export const getPaymentStatus = (
  order: Order | OrderOpenList | OrderForFinalizationList,
): 'unpaid' | 'partial' | 'paid' => {
  if (!order) {
    return 'unpaid';
  }
  if ('paymentsSummary' in order) {
    const totalPaid = order.paymentsSummary?.totalPaid || 0;
    const orderTotal =
      typeof order.total === 'string'
        ? parseFloat(order.total)
        : order.total || 0;
    if (totalPaid >= orderTotal) {
      return 'paid';
    } else if (totalPaid > 0) {
      return 'partial';
    } else {
      return 'unpaid';
    }
  }
  if (!order.payments || order.payments.length === 0) {
    return 'unpaid';
  }
  const totalPaid = order.payments
    .filter((payment: any) => payment.paymentStatus === 'COMPLETED')
    .reduce((sum: number, payment: any) => sum + (payment.amount || 0), 0);
  const orderTotal =
    typeof order.total === 'string'
      ? parseFloat(order.total)
      : order.total || 0;
  if (totalPaid === 0) {
    return 'unpaid';
  } else if (totalPaid >= orderTotal) {
    return 'paid';
  } else {
    return 'partial';
  }
};
export const getPaymentStatusColor = (
  paymentStatus: 'unpaid' | 'partial' | 'paid',
): string => {
  switch (paymentStatus) {
    case 'paid':
      return '#10B981';
    case 'partial':
      return '#F59E0B';
    case 'unpaid':
      return '#EF4444';
    default:
      return '#757575';
  }
};
export const formatPaymentStatus = (
  paymentStatus: 'unpaid' | 'partial' | 'paid',
): string => {
  switch (paymentStatus) {
    case 'paid':
      return '💵 Pagado';
    case 'partial':
      return '💵 Parcial';
    case 'unpaid':
      return '💵 Pendiente';
    default:
      return '💵 Desconocido';
  }
};

================
File: app/src/app/utils/tokenVerification.ts
================
import { authService } from '@/modules/auth/services/authService';
import { useAuthStore } from '@/app/store/authStore';
import EncryptedStorage from '@/app/services/secureStorageService';
const AUTH_TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';
const USER_INFO_KEY = 'user_info';
export async function verifyStoredToken(): Promise<boolean> {
  try {
    const { accessToken } = useAuthStore.getState();
    if (!accessToken) {
      return false;
    }
    const isTokenValid = await authService.verifyToken();
    if (!isTokenValid) {
      await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
      await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
      await EncryptedStorage.removeItem(USER_INFO_KEY);
      useAuthStore.setState({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });
      return false;
    }
    return true;
  } catch (error) {
    console.error('Error verificando token:', error);
    return false;
  }
}

================
File: app/src/hooks/useAudioRecorder.ts
================
import { useState, useCallback, useRef, useEffect } from 'react';
import {
  useAudioRecorder as useExpoAudioRecorder,
  AudioModule,
  RecordingPresets,
} from 'expo-audio';
import {
  ExpoSpeechRecognitionModule,
  useSpeechRecognitionEvent,
} from 'expo-speech-recognition';
interface UseAudioRecorderReturn {
  isRecording: boolean;
  isPreparing: boolean;
  isProcessing: boolean;
  audioUri: string | null;
  transcription: string | null;
  startRecording: () => Promise<void>;
  stopRecording: () => Promise<void>;
  resetRecording: () => void;
  error: string | null;
}
export const useAudioRecorder = (): UseAudioRecorderReturn => {
  const [isRecording, setIsRecording] = useState(false);
  const [isPreparing, setIsPreparing] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [audioUri, setAudioUri] = useState<string | null>(null);
  const [transcription, setTranscription] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const audioRecorder = useExpoAudioRecorder({
    ...RecordingPresets.HIGH_QUALITY,
    android: {
      ...RecordingPresets.HIGH_QUALITY.android,
      extension: '.mp4',
      outputFormat: 'mpeg4',
      audioEncoder: 'aac',
      sampleRate: 16000,
      numberOfChannels: 1,
      bitRate: 64000,
    },
    ios: {
      ...RecordingPresets.HIGH_QUALITY.ios,
      extension: '.m4a',
      sampleRate: 16000,
      numberOfChannels: 1,
      bitRate: 64000,
    },
  });
  const [currentTranscription, setCurrentTranscription] = useState<string>('');
  const currentTranscriptionRef = useRef<string>('');
  const isTranscribing = useRef(false);
  const isMounted = useRef(true);
  // Verificar que el audio recorder esté listo
  useEffect(() => {
    if (audioRecorder && typeof audioRecorder.record === 'function') {
      setIsInitialized(true);
    }
  }, [audioRecorder]);
  const isStopping = useRef(false);
  useSpeechRecognitionEvent('result', (event) => {
    if (!isMounted.current) return;
    const results = event.results;
    if (results && results.length > 0) {
      const bestResult = results[0];
      if (bestResult && bestResult.transcript) {
        const newTranscript = bestResult.transcript;
        currentTranscriptionRef.current = newTranscript;
        setCurrentTranscription(newTranscript);
        if (event.isFinal || bestResult.isFinal) {
          setTranscription(newTranscript);
        }
      }
    }
  });
  useSpeechRecognitionEvent('end', () => {
    if (!isMounted.current) return;
    isTranscribing.current = false;
  });
  const startRecording = useCallback(async () => {
    if (!isMounted.current) return;
    if (!isInitialized || !audioRecorder) {
      setError('El grabador de audio no está listo');
      return;
    }
    try {
      setError(null);
      setIsPreparing(true);
      setCurrentTranscription('');
      currentTranscriptionRef.current = '';
      setTranscription('');
      // Solicitar permisos de audio
      const audioPermission =
        await AudioModule.requestRecordingPermissionsAsync();
      if (!audioPermission.granted) {
        throw new Error('Se requiere permiso para grabar audio');
      }
      const speechPermissions =
        await ExpoSpeechRecognitionModule.requestPermissionsAsync();
      if (!speechPermissions.granted) {
        throw new Error('Se requiere permiso para reconocimiento de voz');
      }
      isTranscribing.current = true;
      setCurrentTranscription('');
      try {
        await ExpoSpeechRecognitionModule.start({
          lang: 'es-MX',
          interimResults: true,
          continuous: true,
          maxAlternatives: 1,
        });
      } catch (speechError) {
      }
      await new Promise((resolve) => setTimeout(resolve, 300));
      await audioRecorder.prepareToRecordAsync();
      await audioRecorder.record();
      if (isMounted.current) {
        setIsRecording(true);
        setIsPreparing(false);
      }
    } catch (err) {
      if (isMounted.current) {
        setIsPreparing(false);
        const errorMessage =
          err instanceof Error ? err.message : 'Error al iniciar grabación';
        setError(errorMessage);
      }
    }
  }, [audioRecorder, isInitialized]);
  const stopRecording = useCallback(async () => {
    if (!isMounted.current) return;
    if (isStopping.current) {
      return;
    }
    try {
      const isCurrentlyRecording = audioRecorder.isRecording;
      if (!isCurrentlyRecording) {
        return;
      }
      isStopping.current = true;
      setIsProcessing(true);
      setIsRecording(false);
      if (isTranscribing.current) {
        try {
          await ExpoSpeechRecognitionModule.stop();
          await new Promise((resolve) => setTimeout(resolve, 500));
        } catch (error) {
        } finally {
          isTranscribing.current = false;
        }
      }
      let uri: string | undefined;
      try {
        await audioRecorder.stop();
        uri = audioRecorder.uri;
      } catch (audioError) {
        if (audioError?.message?.includes('stop failed')) {
          uri = audioRecorder.uri;
        } else {
          throw audioError;
        }
      }
      if (!uri) {
        throw new Error('No se pudo obtener el archivo de audio');
      }
      if (isMounted.current) {
        const finalTranscription =
          currentTranscriptionRef.current ||
          currentTranscription ||
          transcription ||
          '';
        if (finalTranscription) {
          setTranscription(finalTranscription);
        } else {
          setTranscription('');
        }
        // Establecer el URI del audio al final
        setAudioUri(uri);
        setIsProcessing(false);
      }
    } catch (err) {
      if (isMounted.current) {
        setIsProcessing(false);
        const errorMessage =
          err instanceof Error ? err.message : 'Error al detener grabación';
        setError(errorMessage);
      }
    } finally {
      isStopping.current = false;
    }
  }, [audioRecorder, currentTranscription, transcription]);
  const resetRecording = useCallback(() => {
    if (!isMounted.current) return;
    if (isTranscribing.current) {
      try {
        const stopPromise = ExpoSpeechRecognitionModule.stop();
        if (stopPromise && typeof stopPromise.catch === 'function') {
          stopPromise.catch((_err) => {});
        }
      } catch (_err) {}
      isTranscribing.current = false;
    }
    if (audioRecorder && audioRecorder.isRecording) {
      try {
        const stopPromise = audioRecorder.stop();
        if (stopPromise && typeof stopPromise.catch === 'function') {
          stopPromise.catch((_err) => {
          });
        }
      } catch (err) {
      }
    }
    setAudioUri(null);
    setTranscription(null);
    setCurrentTranscription('');
    currentTranscriptionRef.current = '';
    setError(null);
    setIsRecording(false);
    setIsProcessing(false);
    setIsPreparing(false);
    isStopping.current = false;
  }, [audioRecorder]);
  // Limpiar al desmontar
  useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
      // Limpiar el reconocimiento de voz
      if (isTranscribing.current) {
        isTranscribing.current = false;
        try {
          const stopPromise = ExpoSpeechRecognitionModule.stop();
          if (stopPromise && typeof stopPromise.catch === 'function') {
            stopPromise.catch(() => {});
          }
        } catch (err) {
        }
      }
    };
  }, []);
  return {
    isRecording,
    isPreparing,
    isProcessing,
    audioUri,
    transcription,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  };
};

================
File: app/src/hooks/useGoogleMapsConfig.ts
================
import { useState, useEffect } from 'react';
import { appConfigService } from '@/services/appConfig';
import { GOOGLE_MAPS_CONFIG } from '@/modules/customers/constants/maps.config';
export interface GoogleMapsConfigWithApiKey {
  apiKey: string;
  defaultCenter: {
    lat: number;
    lng: number;
  };
  defaultZoom: number;
  locationZoom: number;
  mapOptions: {
    disableDefaultUI: boolean;
    zoomControl: boolean;
    mapTypeControl: boolean;
    scaleControl: boolean;
    streetViewControl: boolean;
    rotateControl: boolean;
    fullscreenControl: boolean;
    clickableIcons: boolean;
  };
}
export function useGoogleMapsConfig() {
  const [config, setConfig] = useState<GoogleMapsConfigWithApiKey | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    async function loadConfig() {
      try {
        const apiKey = await appConfigService.getMapsApiKey();
        setConfig({
          ...GOOGLE_MAPS_CONFIG,
          apiKey,
        });
      } catch (err) {
        setError('No se pudo cargar la configuración de mapas');
      } finally {
        setLoading(false);
      }
    }
    loadConfig();
  }, []);
  return { config, loading, error };
}

================
File: app/src/modules/areasTables/services/tableService.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '../../../app/services/apiClient';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  FindAllTablesDto,
} from '../schema/table.schema';
export const getTables = async (
  filterOptions: FindAllTablesDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 10 },
): Promise<Table[]> => {
  const response = await apiClient.get<{
    items: Table[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.TABLES, {
    params: {
      ...filterOptions,
      page: paginationOptions.page,
      limit: paginationOptions.limit,
    },
  });
  return response.data.items;
};
export const getTablesByAreaId = async (areaId: string): Promise<Table[]> => {
  const response = await apiClient.get<{
    items: Table[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.TABLES_BY_AREA.replace(':areaId', areaId));
  return response.data.items;
};
export const getTableById = async (id: string): Promise<Table> => {
  const response = await apiClient.get<Table>(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
  );
  return response.data;
};
export const createTable = async (data: CreateTableDto): Promise<Table> => {
  const response = await apiClient.post<Table>(API_PATHS.TABLES, data);
  return response.data;
};
export const updateTable = async (
  id: string,
  data: UpdateTableDto,
): Promise<Table> => {
  const response = await apiClient.patch<Table>(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};
export const deleteTable = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.TABLES_BY_ID.replace(':id', id));
};
const tableQueryKeys = {
  base: ['tables'] as const,
  byArea: (areaId: string | null | undefined) =>
    [...tableQueryKeys.base, 'area', areaId] as const,
};
export function useGetTablesByArea(areaId: string | null | undefined) {
  return useQuery<Table[], ApiError>({
    queryKey: tableQueryKeys.byArea(areaId),
    queryFn: () => {
      if (!areaId) {
        return Promise.resolve([]);
      }
      return getTablesByAreaId(areaId);
    },
    enabled: !!areaId,
  });
}

================
File: app/src/modules/auth/services/authService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  AuthEmailLoginDto,
  LoginResponseDto,
  LoginFormInputs,
  RegisterFormInputs,
} from '../schema/auth.schema';
class AuthService {
  async login(loginData: LoginFormInputs): Promise<LoginResponseDto> {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const isEmail = emailRegex.test(loginData.emailOrUsername);
    const sanitizedInput = loginData.emailOrUsername.trim().toLowerCase();
    const payload: AuthEmailLoginDto = {
      password: loginData.password,
      ...(isEmail ? { email: sanitizedInput } : { username: sanitizedInput }),
    };
    const response = await apiClient.post<LoginResponseDto>(
      API_PATHS.AUTH_EMAIL_LOGIN,
      payload,
    );
    return response.data;
  }
  async register(data: RegisterFormInputs): Promise<void> {
    await apiClient.post<{ message?: string }>(
      API_PATHS.AUTH_EMAIL_REGISTER,
      data,
    );
  }
  async verifyToken(): Promise<boolean> {
    try {
      const response = await apiClient.get(API_PATHS.AUTH_ME);
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }
}
export const authService = new AuthService();

================
File: app/src/modules/availability/components/ModifierGroupAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch } from 'react-native-paper';
import { ModifierGroupAvailability } from '../types/availability.types';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';
interface ModifierGroupAvailabilityItemProps {
  modifierGroup: ModifierGroupAvailability;
  onRefresh?: () => void;
}
export const ModifierGroupAvailabilityItem: React.FC<
  ModifierGroupAvailabilityItemProps
> = ({ modifierGroup, onRefresh: _onRefresh }) => {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();
  const handleGroupToggle = (value: boolean) => {
    updateAvailability.mutate({
      type: 'modifierGroup',
      id: modifierGroup.id,
      isActive: value,
      cascade: true,
    });
  };
  const handleModifierToggle = (modifierId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'modifier',
      id: modifierId,
      isActive: value,
    });
  };
  const totalModifiers = modifierGroup.modifiers.length;
  const activeModifiers = modifierGroup.modifiers.filter(
    (m) => m.isActive,
  ).length;
  return (
    <AvailabilityListItem
      title={modifierGroup.name}
      subtitle={`${activeModifiers}/${totalModifiers} modificadores activos`}
      icon="tune-variant"
      isActive={modifierGroup.isActive}
      onToggle={handleGroupToggle}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      <View style={styles.modifiersContainer}>
        {modifierGroup.modifiers.map((modifier) => (
          <View
            key={modifier.id}
            style={[
              styles.modifierItem,
              { opacity: !modifier.isActive ? 0.5 : 1 },
            ]}
          >
            <Text
              style={[
                styles.modifierTitle,
                !modifier.isActive && styles.strikethrough,
                { color: theme.colors.onSurface },
              ]}
            >
              {modifier.name}
            </Text>
            <Switch
              value={modifier.isActive}
              onValueChange={(value) =>
                handleModifierToggle(modifier.id, value)
              }
              disabled={!modifierGroup.isActive}
            />
          </View>
        ))}
      </View>
    </AvailabilityListItem>
  );
};
const styles = StyleSheet.create({
  modifiersContainer: {
    paddingLeft: 16,
  },
  modifierItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  modifierTitle: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
});

================
File: app/src/modules/customers/constants/maps.config.ts
================
export const GOOGLE_MAPS_CONFIG = {
  defaultCenter: {
    lat: 23.6345,
    lng: -102.5528,
  },
  defaultZoom: 5,
  locationZoom: 16,
  mapOptions: {
    disableDefaultUI: false,
    zoomControl: true,
    mapTypeControl: false,
    scaleControl: false,
    streetViewControl: false,
    rotateControl: false,
    fullscreenControl: false,
    clickableIcons: false,
  },
};

================
File: app/src/modules/customers/hooks/useCustomersQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { customersService } from '../services/customersService';
import {
  CreateCustomerDto,
  UpdateCustomerDto,
  FindAllCustomersQuery,
  ChatMessage,
  Address,
} from '../types/customer.types';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
export const customerKeys = {
  all: ['customers'] as const,
  lists: () => [...customerKeys.all, 'list'] as const,
  list: (filters?: FindAllCustomersQuery) =>
    [...customerKeys.lists(), filters] as const,
  details: () => [...customerKeys.all, 'detail'] as const,
  detail: (id: string) => [...customerKeys.details(), id] as const,
  activeRecent: (daysAgo: number) =>
    [...customerKeys.all, 'active-recent', daysAgo] as const,
  addresses: (customerId: string) =>
    [...customerKeys.all, 'addresses', customerId] as const,
};
export function useCustomers(filters?: FindAllCustomersQuery) {
  return useQuery({
    queryKey: customerKeys.list(filters),
    queryFn: () => customersService.findAll(filters),
  });
}
export function useCustomer(id: string, enabled = true) {
  return useQuery({
    queryKey: customerKeys.detail(id),
    queryFn: () => customersService.findOne(id),
    enabled: enabled && !!id,
  });
}
export function useCreateCustomer() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: CreateCustomerDto) => customersService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}
export function useUpdateCustomer() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateCustomerDto }) =>
      customersService.update(id, data),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}
export function useDeleteCustomer() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: string) => customersService.remove(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}
export function useAppendChatMessage() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({
      customerId,
      message,
    }: {
      customerId: string;
      message: Omit<ChatMessage, 'timestamp'>;
    }) => customersService.appendChatMessage(customerId, message),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
    },
  });
}
export function useUpdateRelevantChatHistory() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({
      customerId,
      relevantHistory,
    }: {
      customerId: string;
      relevantHistory: ChatMessage[];
    }) =>
      customersService.updateRelevantChatHistory(customerId, relevantHistory),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
    },
  });
}
export function useUpdateCustomerStats() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({
      customerId,
      stats,
    }: {
      customerId: string;
      stats: { totalOrders?: number; totalSpent?: number };
    }) => customersService.updateCustomerStats(customerId, stats),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}
export function useActiveCustomersWithRecentInteraction(daysAgo = 30) {
  return useQuery({
    queryKey: customerKeys.activeRecent(daysAgo),
    queryFn: () => customersService.getActiveWithRecentInteraction(daysAgo),
  });
}
export function useGetAddressesByCustomer(
  customerId: string,
  options?: { enabled?: boolean },
) {
  return useQuery({
    queryKey: customerKeys.addresses(customerId),
    queryFn: async () => {
      const response = await apiClient.get<Address[]>(
        `${API_PATHS.CUSTOMERS}/${customerId}/addresses`,
      );
      if (!response.ok || !response.data) {
        return [];
      }
      return response.data;
    },
    enabled: options?.enabled ?? true,
  });
}

================
File: app/src/modules/customers/services/customersService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Customer,
  CreateCustomerDto,
  UpdateCustomerDto,
  FindAllCustomersQuery,
  ChatMessage,
} from '../types/customer.types';
async function findAll(params?: FindAllCustomersQuery): Promise<Customer[]> {
  const response = await apiClient.get<Customer[]>(API_PATHS.CUSTOMERS, { params });
  return response.data;
}
async function findOne(id: string): Promise<Customer> {
  const response = await apiClient.get<Customer>(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
  );
  return response.data;
}
async function create(data: CreateCustomerDto): Promise<Customer> {
  const response = await apiClient.post<Customer>(API_PATHS.CUSTOMERS, data);
  return response.data;
}
async function update(id: string, data: UpdateCustomerDto): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
}
async function remove(id: string): Promise<void> {
  await apiClient.delete(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
  );
}
async function appendChatMessage(
  customerId: string,
  message: Omit<ChatMessage, 'timestamp'>,
): Promise<Customer> {
  const response = await apiClient.post<Customer>(
    API_PATHS.CUSTOMERS_CHAT_MESSAGE.replace(':customerId', customerId),
    message,
  );
  return response.data;
}
async function updateRelevantChatHistory(
  customerId: string,
  relevantHistory: ChatMessage[],
): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_CHAT_HISTORY.replace(':customerId', customerId),
    { relevantHistory },
  );
  return response.data;
}
async function updateCustomerStats(
  customerId: string,
  stats: { totalOrders?: number; totalSpent?: number },
): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_STATS.replace(':customerId', customerId),
    stats,
  );
  return response.data;
}
async function getActiveWithRecentInteraction(
  daysAgo: number = 30,
): Promise<Customer[]> {
  const response = await apiClient.get<Customer[]>(
    API_PATHS.CUSTOMERS_ACTIVE_RECENT,
    { params: { daysAgo } },
  );
  return response.data;
}
export const customersService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  appendChatMessage,
  updateRelevantChatHistory,
  updateCustomerStats,
  getActiveWithRecentInteraction,
};

================
File: app/src/modules/kitchen/hooks/useKitchenSnackbar.ts
================
import { useSnackbar } from '@/hooks/useSnackbar';
export function useKitchenSnackbar() {
  const { showSnackbar } = useSnackbar();
  const showError = (message: string) => {
    showSnackbar(message, 'error', 2000);
  };
  return {
    showError,
  };
}

================
File: app/src/modules/menu/components/VariantFormModal.tsx
================
import React, { useEffect, useMemo, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Portal,
  Modal,
  Card,
  TextInput,
  Button,
  Switch,
  Text,
  HelperText,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { ProductVariant } from '../schema/products.schema';
import { z } from 'zod';
import { useAppTheme } from '@/app/styles/theme';
const variantFormSchema = z.object({
  id: z.string().optional(),
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce
    .number({
      invalid_type_error: 'El precio debe ser un número',
      required_error: 'El precio es requerido',
    })
    .positive('El precio debe ser mayor a 0'),
  isActive: z.boolean(),
  sortOrder: z.number().optional().default(0),
});
type VariantFormData = z.infer<typeof variantFormSchema>;
interface VariantFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: ProductVariant) => void;
  initialData?: Partial<ProductVariant>;
}
function VariantFormModal({
  visible,
  onDismiss,
  onSubmit,
  initialData,
}: VariantFormModalProps): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const isEditing = !!initialData?.name;
  const [priceInputValue, setPriceInputValue] = useState<string>('');
  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors, isSubmitting },
  } = useForm<VariantFormData>({
    resolver: zodResolver(variantFormSchema),
    defaultValues: {
      name: initialData?.name ?? '',
      price: initialData?.price ?? 0,
      isActive: initialData?.isActive ?? true,
      sortOrder: initialData?.sortOrder ?? 0,
      id: initialData?.id,
    },
  });
  const priceValue = watch('price');
  useEffect(() => {
    if (visible) {
      reset({
        name: initialData?.name ?? '',
        price: initialData?.price ?? 0,
        isActive: initialData?.isActive ?? true,
        sortOrder: initialData?.sortOrder ?? 0,
        id: initialData?.id,
      });
    }
  }, [visible, initialData, reset]);
  useEffect(() => {
    setPriceInputValue(
      priceValue !== undefined && priceValue !== null ? String(priceValue) : '',
    );
  }, [priceValue]);
  const handleFormSubmit = (data: VariantFormData) => {
    const finalData: ProductVariant = {
      ...data,
      ...(initialData?.id && { id: initialData.id }),
    } as ProductVariant;
    onSubmit(finalData);
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Card style={styles.card}>
          <Card.Title
            title={isEditing ? 'Editar Variante' : 'Nueva Variante'}
          />
          <Card.Content style={styles.content}>
            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="name"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Nombre Variante *"
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.name}
                    style={styles.input}
                    autoFocus={!isEditing}
                  />
                )}
              />
              {errors.name && (
                <HelperText type="error" visible={!!errors.name}>
                  {errors.name.message}
                </HelperText>
              )}
            </View>
            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="price"
                render={({ field }) => (
                  <TextInput
                    label="Precio *"
                    value={priceInputValue}
                    onChangeText={(text) => {
                      const formattedText = text.replace(/,/g, '.');
                      if (/^(\d*\.?\d*)$/.test(formattedText)) {
                        setPriceInputValue(formattedText);
                        if (formattedText === '') {
                          field.onChange(undefined);
                        } else if (formattedText !== '.') {
                          const numericValue = parseFloat(formattedText);
                          if (!isNaN(numericValue)) {
                            field.onChange(numericValue);
                          }
                        }
                      }
                    }}
                    onBlur={field.onBlur}
                    error={!!errors.price}
                    style={styles.input}
                    keyboardType="decimal-pad"
                  />
                )}
              />
              {errors.price && (
                <HelperText type="error" visible={!!errors.price}>
                  {errors.price.message}
                </HelperText>
              )}
            </View>
            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="sortOrder"
                render={({ field }) => (
                  <TextInput
                    mode="outlined"
                    label="Orden de visualización"
                    value={String(field.value || 0)}
                    onChangeText={(text) => {
                      const value = parseInt(text, 10);
                      field.onChange(isNaN(value) ? 0 : value);
                    }}
                    onBlur={field.onBlur}
                    error={!!errors.sortOrder}
                    style={styles.input}
                    keyboardType="numeric"
                  />
                )}
              />
              {errors.sortOrder && (
                <HelperText type="error" visible={!!errors.sortOrder}>
                  {errors.sortOrder.message}
                </HelperText>
              )}
            </View>
            <View style={[styles.fieldContainer, styles.switchContainer]}>
              <Text style={styles.label}>Variante Activa</Text>
              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <Switch value={!!value} onValueChange={onChange} />
                )}
              />
            </View>
          </Card.Content>
          <Card.Actions style={styles.actions}>
            <Button onPress={onDismiss} disabled={isSubmitting}>
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(handleFormSubmit)}
              loading={isSubmitting}
              disabled={isSubmitting}
            >
              Guardar
            </Button>
          </Card.Actions>
        </Card>
      </Modal>
    </Portal>
  );
}
const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      padding: theme.spacing.l, // Más padding exterior
    },
    card: {
      backgroundColor: theme.colors.inverseOnSurface,
      borderRadius: theme.roundness * 3, // Un poco más redondeado
    },
    content: {
      paddingHorizontal: theme.spacing.m, // Padding horizontal para el contenido
      paddingBottom: theme.spacing.s, // Pequeño padding inferior antes de las acciones
    },
    fieldContainer: {
      marginBottom: theme.spacing.m, // Espacio uniforme debajo de cada campo/grupo
    },
    input: {},
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    label: {
      color: theme.colors.onSurfaceVariant,
    },
    actions: {
      justifyContent: 'flex-end',
      padding: theme.spacing.m,
    },
  });
export default VariantFormModal;

================
File: app/src/modules/menu/schema/products.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/query.types';
import {
  photoSchema,
  type Photo,
} from '../../../app/schemas/domain/photo.schema';
import {
  productVariantSchema,
  type ProductVariant,
} from '../../../app/schemas/domain/product-variant.schema';
import { modifierGroupSchema } from '../../../app/schemas/domain/modifier-group.schema';
import {
  productSchema as domainProductSchema,
  type Product,
} from '../../../app/schemas/domain/product.schema';
const productVariantFormSchema = productVariantSchema
  .omit({ id: true })
  .extend({
    id: z.string().optional(),
    sortOrder: z.number().optional().default(0),
  });
const productFormBaseSchema = domainProductSchema
  .omit({
    id: true,
    photo: true,
    variants: true,
    modifierGroups: true,
    pizzaCustomizations: true,
    pizzaConfiguration: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend({
    id: z.string().optional(),
    photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
    imageUri: z
      .string()
      .url()
      .or(z.string().startsWith('file://'))
      .optional()
      .nullable(),
    variants: z.array(productVariantFormSchema).optional(),
    variantsToDelete: z.array(z.string()).optional(),
    modifierGroupIds: z.array(z.string()).optional(),
  });
export const productSchema = productFormBaseSchema.superRefine((data, ctx) => {
  if (data.hasVariants) {
    if (!data.variants || data.variants.length === 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Debe añadir al menos una variante si marca esta opción.',
        path: ['variants'],
      });
    }
    if (data.price !== null && data.price !== undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'El precio principal debe estar vacío si el producto tiene variantes.',
        path: ['price'],
      });
    }
  } else {
    if (data.price === null || data.price === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El precio es requerido si el producto no tiene variantes.',
        path: ['price'],
      });
    }
    if (data.variants && data.variants.length > 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'No debe haber variantes si el producto no está marcado como "Tiene Variantes".',
        path: ['variants'],
      });
    }
  }
});
export type ProductFormInputs = z.infer<typeof productSchema>;
export const updateProductSchema = productFormBaseSchema
  .partial()
  .superRefine((data, ctx) => {
    if (data.hasVariants !== undefined) {
      if (data.hasVariants) {
        if (data.variants !== undefined && data.variants.length === 0) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: 'Debe añadir al menos una variante si marca esta opción.',
            path: ['variants'],
          });
        }
        if (data.price !== null && data.price !== undefined) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message:
              'El precio principal debe estar vacío si el producto tiene variantes.',
            path: ['price'],
          });
        }
      } else {
        if (data.price === null || data.price === undefined) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message:
              'El precio es requerido si el producto no tiene variantes.',
            path: ['price'],
          });
        }
        if (data.variants && data.variants.length > 0) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message:
              'No debe haber variantes si el producto no está marcado como "Tiene Variantes".',
            path: ['variants'],
          });
        }
      }
    }
  });
export type UpdateProductFormInputs = z.infer<typeof updateProductSchema>;
export const productResponseSchema = domainProductSchema;
export const productsListResponseSchema = z.tuple([
  z.array(productResponseSchema),
  z.number(),
]);
export type ProductsListResponse = z.infer<typeof productsListResponseSchema>;
export const findAllProductsQuerySchema = baseListQuerySchema.extend({
  subcategoryId: z.string().optional(),
  hasVariants: z.boolean().optional(),
  isActive: z.boolean().optional(),
  search: z.string().optional(),
});
export type FindAllProductsQuery = z.infer<typeof findAllProductsQuerySchema>;
export const assignModifierGroupsSchema = z.object({
  modifierGroupIds: z
    .array(z.string())
    .min(1, 'Se requiere al menos un ID de grupo'),
});
export type AssignModifierGroupsInput = z.infer<
  typeof assignModifierGroupsSchema
>;
export type { Photo, ProductVariant, Product };

================
File: app/src/modules/menu/services/categoryService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import type {
  Category,
  CreateCategoryDto,
  UpdateCategoryDto,
} from '../schema/category.schema';
import { PaginatedResponse } from '../../../app/types/api.types';
export const getCategories = async (params?: {
  isActive?: boolean;
  page?: number;
  limit?: number;
}): Promise<PaginatedResponse<Category>> => {
  const response = await apiClient.get<{
    items: Category[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.CATEGORIES, { params });
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};
export const getCategory = async (id: string): Promise<Category> => {
  const response = await apiClient.get<Category>(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
  );
  return response.data;
};
export const createCategory = async (
  data: CreateCategoryDto,
): Promise<Category> => {
  const response = await apiClient.post<Category>(API_PATHS.CATEGORIES, data);
  return response.data;
};
export const updateCategory = async (
  id: string,
  data: UpdateCategoryDto,
): Promise<Category> => {
  const response = await apiClient.patch<Category>(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};
export const deleteCategory = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.CATEGORIES_BY_ID.replace(':id', id));
};
export async function getOrderMenu(): Promise<Category[]> {
  const response = await apiClient.get<Category[]>(
    API_PATHS.CATEGORIES_ORDER_MENU,
  );
  return response.data;
}
const categoryService = {
  getCategories,
  getCategory,
  createCategory,
  updateCategory,
  deleteCategory,
  getOrderMenu,
};
export default categoryService;

================
File: app/src/modules/menu/services/productsService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Product,
  ProductFormInputs,
  FindAllProductsQuery,
  AssignModifierGroupsInput,
} from '../schema/products.schema';
import { PaginatedResponse } from '@/app/types/api.types';
async function findAll(
  params: FindAllProductsQuery,
): Promise<PaginatedResponse<Product>> {
  const response = await apiClient.get<{
    items: Product[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.PRODUCTS, { params });
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
}
async function findOne(id: string): Promise<Product> {
  const response = await apiClient.get<Product>(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
  );
  return response.data;
}
async function create(data: ProductFormInputs): Promise<Product> {
  const response = await apiClient.post<Product>(API_PATHS.PRODUCTS, data);
  return response.data;
}
async function update(
  id: string,
  data: Partial<ProductFormInputs>,
): Promise<Product> {
  const response = await apiClient.patch<Product>(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
}
async function remove(id: string): Promise<void> {
  await apiClient.delete(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
  );
}
async function assignModifierGroups(
  productId: string,
  data: AssignModifierGroupsInput,
): Promise<Product> {
  const response = await apiClient.post<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
    data,
  );
  return response.data;
}
async function getModifierGroups(productId: string): Promise<Product> {
  const response = await apiClient.get<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
  );
  return response.data;
}
async function removeModifierGroups(
  productId: string,
  data: AssignModifierGroupsInput,
): Promise<Product> {
  const response = await apiClient.delete<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
    data,
  );
  return response.data;
}
async function findAllPizzas(): Promise<Product[]> {
  const response = await apiClient.get<Product[]>(API_PATHS.PRODUCTS_PIZZAS);
  return response.data;
}
async function getPizzaCustomizations(productId: string): Promise<any[]> {
  const response = await apiClient.get<any[]>(
    API_PATHS.PRODUCTS_PIZZA_CUSTOMIZATIONS.replace(':productId', productId),
  );
  return response.data;
}
async function updatePizzaCustomizations(
  productId: string,
  pizzaCustomizationIds: string[],
): Promise<Product> {
  const response = await apiClient.put<Product>(
    API_PATHS.PRODUCTS_PIZZA_CUSTOMIZATIONS.replace(':productId', productId),
    pizzaCustomizationIds,
  );
  return response.data;
}
async function bulkUpdatePizzaCustomizations(
  updates: Array<{ productId: string; customizationIds: string[] }>,
): Promise<void> {
  await apiClient.put(
    API_PATHS.PRODUCTS_PIZZAS_CUSTOMIZATIONS_BULK,
    { updates },
  );
}
export const productsService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  assignModifierGroups,
  getModifierGroups,
  removeModifierGroups,
  findAllPizzas,
  getPizzaCustomizations,
  updatePizzaCustomizations,
  bulkUpdatePizzaCustomizations,
};

================
File: app/src/modules/modifiers/components/ModifierGroupFormModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  Switch,
  HelperText,
  ActivityIndicator,
} from 'react-native-paper';
import { useForm, Controller, SubmitHandler } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { modifierGroupService } from '../services/modifierGroupService';
import {
  ModifierGroup,
  ModifierGroupFormInputs,
  modifierGroupSchema,
  createModifierGroupSchema,
  CreateModifierGroupInput,
  UpdateModifierGroupInput,
} from '../schema/modifierGroup.schema';
interface Props {
  visible: boolean;
  onDismiss: () => void;
  onSaveSuccess: () => void;
  initialData?: ModifierGroup | null;
}
const QUERY_KEY_TO_INVALIDATE = ['modifierGroups'];
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: theme.spacing.l,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
      fontSize: 20,
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.xl,
    },
    input: {
      marginBottom: theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
    },
    row: {
      flexDirection: 'row',
      marginHorizontal: -theme.spacing.xs,
      marginBottom: theme.spacing.m,
    },
    column: {
      flex: 1,
      paddingHorizontal: theme.spacing.xs,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
      flexShrink: 1,
      marginRight: theme.spacing.m,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: theme.spacing.m,
    },
    cancelButton: {
      marginRight: theme.spacing.m,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 10,
      borderRadius: theme.roundness * 2,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    divider: {
      marginVertical: theme.spacing.m,
      backgroundColor: theme.colors.outlineVariant,
    },
  });
const ModifierGroupFormModal: React.FC<Props> = ({
  visible,
  onDismiss,
  onSaveSuccess,
  initialData,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const isEditing = !!initialData;
  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors, isSubmitting },
  } = useForm<ModifierGroupFormInputs>({
    resolver: zodResolver(modifierGroupSchema),
    defaultValues: {
      name: '',
      description: null,
      minSelections: 0,
      maxSelections: 2,
      isRequired: false,
      allowMultipleSelections: false,
      isActive: true,
      sortOrder: 0,
    },
  });
  const watchedAllowMultipleSelections = watch('allowMultipleSelections');
  useEffect(() => {
    if (visible) {
      if (initialData) {
        reset({
          name: initialData.name,
          description: initialData.description,
          minSelections: initialData.minSelections ?? 0,
          maxSelections: initialData.maxSelections ?? 1,
          isRequired: initialData.isRequired ?? false,
          allowMultipleSelections: initialData.allowMultipleSelections ?? false,
          isActive: initialData.isActive ?? true,
          sortOrder: initialData.sortOrder ?? 0,
        });
      } else {
        reset({
          name: '',
          description: null,
          minSelections: 0,
          maxSelections: 2,
          isRequired: false,
          allowMultipleSelections: false,
          isActive: true,
          sortOrder: 0,
        });
      }
    }
  }, [initialData, visible, reset]);
  const mutation = useMutation<
    ModifierGroup,
    Error,
    CreateModifierGroupInput | UpdateModifierGroupInput
  >({
    mutationFn: (data) => {
      if (isEditing && initialData) {
        return modifierGroupService.update(
          initialData.id,
          data as UpdateModifierGroupInput,
        );
      } else {
        const createData = createModifierGroupSchema.parse(
          data as ModifierGroupFormInputs,
        );
        return modifierGroupService.create(createData);
      }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEY_TO_INVALIDATE });
      showSnackbar({
        message: `Grupo "${data.name}" ${
          isEditing ? 'actualizado' : 'creado'
        } correctamente`,
        type: 'success',
      });
      onSaveSuccess();
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
    },
  });
  const onSubmit: SubmitHandler<ModifierGroupFormInputs> = (formData) => {
    mutation.mutate(formData);
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting}
      >
        <View style={styles.formContainer}>
          <View style={styles.modalHeader}>
            <Text variant="titleLarge" style={styles.modalTitle}>
              {isEditing
                ? 'Editar Grupo de Modificadores'
                : 'Crear Nuevo Grupo'}
            </Text>
          </View>
          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            <Controller
              name="name"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Nombre *"
                  value={value}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.name}
                  style={styles.input}
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.name && (
              <HelperText
                type="error"
                visible={!!errors.name}
                style={styles.helperText}
              >
                {errors.name.message}
              </HelperText>
            )}
            <Controller
              name="description"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Descripción (Opcional)"
                  value={value ?? ''}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.description}
                  style={styles.input}
                  multiline
                  numberOfLines={3}
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.description && (
              <HelperText
                type="error"
                visible={!!errors.description}
                style={styles.helperText}
              >
                {errors.description.message}
              </HelperText>
            )}
            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>
                Permitir Múltiples Selecciones
              </Text>
              <Controller
                name="allowMultipleSelections"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.allowMultipleSelections && (
              <HelperText
                type="error"
                visible={!!errors.allowMultipleSelections}
                style={styles.helperText}
              >
                {errors.allowMultipleSelections.message}
              </HelperText>
            )}
            <View
              style={[
                styles.row,
                !watchedAllowMultipleSelections ? { opacity: 0.5 } : {},
              ]}
            >
              <View style={styles.column}>
                <Controller
                  name="minSelections"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Mín. Selecciones"
                      value={String(value ?? 0)}
                      onChangeText={(text) => onChange(parseInt(text, 10) || 0)}
                      onBlur={onBlur}
                      error={!!errors.minSelections}
                      style={styles.input}
                      keyboardType="numeric"
                      disabled={!watchedAllowMultipleSelections || isSubmitting}
                      mode="outlined"
                    />
                  )}
                />
                {errors.minSelections && (
                  <HelperText
                    type="error"
                    visible={!!errors.minSelections}
                    style={styles.helperText}
                  >
                    {errors.minSelections.message}
                  </HelperText>
                )}
              </View>
              <View style={styles.column}>
                <Controller
                  name="maxSelections"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Máx. Selecciones *"
                      value={String(value ?? 1)}
                      onChangeText={(text) => onChange(parseInt(text, 10) || 1)}
                      onBlur={onBlur}
                      error={!!errors.maxSelections}
                      style={styles.input}
                      keyboardType="numeric"
                      disabled={!watchedAllowMultipleSelections || isSubmitting}
                      mode="outlined"
                    />
                  )}
                />
                {errors.maxSelections && (
                  <HelperText
                    type="error"
                    visible={!!errors.maxSelections}
                    style={styles.helperText}
                  >
                    {errors.maxSelections.message}
                  </HelperText>
                )}
              </View>
            </View>
            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>Es Requerido</Text>
              <Controller
                name="isRequired"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isRequired && (
              <HelperText
                type="error"
                visible={!!errors.isRequired}
                style={styles.helperText}
              >
                {errors.isRequired.message}
              </HelperText>
            )}
            <Controller
              name="sortOrder"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Orden de visualización"
                  value={String(value ?? 0)}
                  onChangeText={(text) => onChange(parseInt(text, 10) || 0)}
                  onBlur={onBlur}
                  error={!!errors.sortOrder}
                  style={styles.input}
                  keyboardType="numeric"
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.sortOrder && (
              <HelperText
                type="error"
                visible={!!errors.sortOrder}
                style={styles.helperText}
              >
                {errors.sortOrder.message}
              </HelperText>
            )}
            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>Está Activo</Text>
              <Controller
                name="isActive"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isActive && (
              <HelperText
                type="error"
                visible={!!errors.isActive}
                style={styles.helperText}
              >
                {errors.isActive.message}
              </HelperText>
            )}
          </ScrollView>
          {isSubmitting && (
            <View style={styles.loadingOverlay}>
              <ActivityIndicator
                animating={true}
                size="large"
                color={theme.colors.primary}
              />
            </View>
          )}
          <View style={styles.modalActions}>
            <Button
              mode="outlined"
              onPress={onDismiss}
              style={[styles.formButton, styles.cancelButton]}
              disabled={isSubmitting}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              style={styles.formButton}
              loading={isSubmitting}
              disabled={isSubmitting}
            >
              {isEditing ? 'Actualizar' : 'Crear'}
            </Button>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};
export default ModifierGroupFormModal;

================
File: app/src/modules/modifiers/hooks/useModifierGroupsQuery.ts
================
import {
  useQuery,
  type UseQueryOptions,
  type UseQueryResult,
} from '@tanstack/react-query';
import { modifierGroupService } from '../services/modifierGroupService';
import { ModifierGroup } from '../schema/modifierGroup.schema';
import { ApiError } from '@/app/lib/errors';
import { PaginatedResponse } from '@/app/types/api.types';
const modifierGroupKeys = {
  all: ['modifierGroups'] as const,
  lists: () => [...modifierGroupKeys.all, 'list'] as const,
  list: (filters: FindAllModifierGroupsQuery) =>
    [...modifierGroupKeys.lists(), filters] as const,
};
interface FindAllModifierGroupsQuery {
  page?: number;
  limit?: number;
  isActive?: boolean;
  search?: string;
}
export const useModifierGroupsQuery = (
  filters: FindAllModifierGroupsQuery = {},
  options?: Omit<
    UseQueryOptions<PaginatedResponse<ModifierGroup>, ApiError>,
    'queryKey' | 'queryFn'
  >,
): UseQueryResult<PaginatedResponse<ModifierGroup>, ApiError> => {
  const queryKey = modifierGroupKeys.list(filters);
  return useQuery<PaginatedResponse<ModifierGroup>, ApiError>({
    queryKey: queryKey,
    queryFn: () => modifierGroupService.findAll(filters),
    ...options,
  });
};

================
File: app/src/modules/orders/components/AdjustmentFormModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Chip,
  IconButton,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import type {
  OrderAdjustment,
  AdjustmentFormData,
} from '../types/adjustments.types';
interface AdjustmentFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSave: (adjustment: OrderAdjustment) => void;
  adjustment?: OrderAdjustment | null;
  orderSubtotal: number;
}
export const AdjustmentFormModal: React.FC<AdjustmentFormModalProps> = ({
  visible,
  onDismiss,
  onSave,
  adjustment,
  orderSubtotal,
}) => {
  const theme = useAppTheme();
  const [formData, setFormData] = useState<AdjustmentFormData>({
    name: '',
    isPercentage: true,
    value: 0,
    amount: 0,
  });
  // Estados separados para los campos de texto
  const [percentageText, setPercentageText] = useState('');
  const [amountText, setAmountText] = useState('');
  const [isDiscount, setIsDiscount] = useState(false);
  const [nameWasEdited, setNameWasEdited] = useState(false);
  const [errors, setErrors] = useState<{
    name?: string;
    value?: string;
    amount?: string;
  }>({});
  // Inicializar formulario cuando se abre o cambia el ajuste
  useEffect(() => {
    if (visible) {
      if (adjustment) {
        setFormData({
          name: adjustment.name,
          isPercentage: adjustment.isPercentage,
          value: adjustment.value || 0,
          amount: adjustment.amount || 0,
        });
        setPercentageText(Math.abs(adjustment.value || 0).toString());
        setAmountText(Math.abs(adjustment.amount || 0).toString());
        setIsDiscount((adjustment.value || adjustment.amount || 0) < 0);
        setNameWasEdited(true); // Si es edición, asumimos que el nombre fue editado
      } else {
        setFormData({
          name: 'Cargo adicional',
          isPercentage: true,
          value: 0,
          amount: 0,
        });
        setPercentageText('');
        setAmountText('');
        setIsDiscount(false);
        setNameWasEdited(false);
      }
      setErrors({});
    }
  }, [visible, adjustment]);
  // Calcular el monto cuando cambia el valor o tipo
  useEffect(() => {
    if (formData.isPercentage && formData.value !== undefined) {
      const calculatedAmount = (orderSubtotal * formData.value) / 100;
      setFormData((prev) => ({ ...prev, amount: calculatedAmount }));
    }
  }, [formData.isPercentage, formData.value, orderSubtotal]);
  const handleTypeChange = (isPercentage: boolean) => {
    setFormData((prev) => ({
      ...prev,
      isPercentage,
      value: isPercentage ? 0 : undefined,
      amount: isPercentage ? 0 : prev.amount,
    }));
    if (isPercentage) {
      setPercentageText('');
    } else {
      setAmountText('');
    }
  };
  const validateForm = (): boolean => {
    const newErrors: typeof errors = {};
    if (!formData.name.trim()) {
      newErrors.name = 'El nombre es requerido';
    }
    if (formData.isPercentage) {
      if (formData.value === undefined || formData.value === null) {
        newErrors.value = 'El porcentaje es requerido';
      } else if (formData.value === 0) {
        newErrors.value = 'El porcentaje no puede ser 0';
      } else if (formData.value < -100 || formData.value > 100) {
        newErrors.value = 'El porcentaje debe estar entre -100 y 100';
      }
    } else {
      if (formData.amount === undefined || formData.amount === null) {
        newErrors.amount = 'El monto es requerido';
      } else if (formData.amount === 0) {
        newErrors.amount = 'El monto no puede ser 0';
      }
    }
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  const handleSave = () => {
    if (!validateForm()) return;
    const adjustmentData: OrderAdjustment = {
      id: adjustment?.id || undefined,
      name: formData.name.trim(),
      isPercentage: formData.isPercentage,
      value: formData.isPercentage ? formData.value : undefined,
      amount: formData.amount,
      isNew: !adjustment?.id,
    };
    onSave(adjustmentData);
    onDismiss();
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modal,
          { backgroundColor: theme.colors.surface },
        ]}
      >
        {}
        <View
          style={[styles.header, { backgroundColor: theme.colors.primary }]}
        >
          <Text
            variant="titleLarge"
            style={[styles.title, { color: theme.colors.onPrimary }]}
          >
            {adjustment ? 'Editar Ajuste' : 'Nuevo Ajuste'}
          </Text>
          <IconButton
            icon="close"
            size={20}
            onPress={onDismiss}
            style={styles.closeButton}
            iconColor={theme.colors.onPrimary}
          />
        </View>
        {}
        <View style={styles.content}>
          {}
          <TextInput
            label="Nombre"
            value={formData.name}
            onChangeText={(text) => {
              setFormData((prev) => ({ ...prev, name: text }));
              setNameWasEdited(
                text !== 'Descuento' && text !== 'Cargo adicional',
              );
            }}
            mode="outlined"
            error={!!errors.name}
            placeholder="Ej: Descuento especial"
            style={styles.input}
          />
          {errors.name && (
            <HelperText type="error" visible={true}>
              {errors.name}
            </HelperText>
          )}
          {}
          <View style={styles.typeContainer}>
            <Text
              variant="labelLarge"
              style={[styles.label, { color: theme.colors.onSurface }]}
            >
              Tipo de ajuste
            </Text>
            <View style={styles.chipGroup}>
              <Chip
                mode={formData.isPercentage ? 'flat' : 'outlined'}
                onPress={() => handleTypeChange(true)}
                selected={formData.isPercentage}
                style={[
                  styles.chip,
                  formData.isPercentage && {
                    backgroundColor: theme.colors.primaryContainer,
                  },
                ]}
                textStyle={
                  formData.isPercentage && {
                    color: theme.colors.onPrimaryContainer,
                  }
                }
              >
                Porcentaje
              </Chip>
              <Chip
                mode={!formData.isPercentage ? 'flat' : 'outlined'}
                onPress={() => handleTypeChange(false)}
                selected={!formData.isPercentage}
                style={[
                  styles.chip,
                  !formData.isPercentage && {
                    backgroundColor: theme.colors.primaryContainer,
                  },
                ]}
                textStyle={
                  !formData.isPercentage && {
                    color: theme.colors.onPrimaryContainer,
                  }
                }
              >
                Monto fijo
              </Chip>
            </View>
          </View>
          {}
          <View style={styles.operationContainer}>
            <Text
              variant="labelLarge"
              style={[styles.label, { color: theme.colors.onSurface }]}
            >
              Tipo de operación
            </Text>
            <View style={styles.operationButtons}>
              <Button
                mode={isDiscount ? 'contained' : 'outlined'}
                onPress={() => {
                  setIsDiscount(true);
                  if (!nameWasEdited) {
                    setFormData((prev) => ({ ...prev, name: 'Descuento' }));
                  }
                  if (formData.isPercentage) {
                    const absValue = Math.abs(parseFloat(percentageText) || 0);
                    setFormData((prev) => ({ ...prev, value: -absValue }));
                  } else {
                    const absValue = Math.abs(parseFloat(amountText) || 0);
                    setFormData((prev) => ({ ...prev, amount: -absValue }));
                  }
                }}
                style={[
                  styles.operationButton,
                  isDiscount && {
                    backgroundColor: theme.colors.errorContainer,
                    borderColor: theme.colors.error,
                  },
                ]}
                labelStyle={{
                  color: isDiscount
                    ? theme.colors.onErrorContainer
                    : theme.colors.error,
                }}
                icon="minus"
              >
                Descuento
              </Button>
              <Button
                mode={!isDiscount ? 'contained' : 'outlined'}
                onPress={() => {
                  setIsDiscount(false);
                  if (!nameWasEdited) {
                    setFormData((prev) => ({
                      ...prev,
                      name: 'Cargo adicional',
                    }));
                  }
                  if (formData.isPercentage) {
                    const absValue = Math.abs(parseFloat(percentageText) || 0);
                    setFormData((prev) => ({ ...prev, value: absValue }));
                  } else {
                    const absValue = Math.abs(parseFloat(amountText) || 0);
                    setFormData((prev) => ({ ...prev, amount: absValue }));
                  }
                }}
                style={[
                  styles.operationButton,
                  !isDiscount && {
                    backgroundColor: theme.colors.primaryContainer,
                    borderColor: theme.colors.primary,
                  },
                ]}
                labelStyle={{
                  color: !isDiscount
                    ? theme.colors.onPrimaryContainer
                    : theme.colors.primary,
                }}
                icon="plus"
              >
                Cargo
              </Button>
            </View>
          </View>
          {}
          {formData.isPercentage ? (
            <TextInput
              label="Porcentaje"
              value={percentageText}
              onChangeText={(text) => {
                const regex = /^\d*\.?\d*$/;
                if (regex.test(text) || text === '') {
                  setPercentageText(text);
                  const value = parseFloat(text) || 0;
                  setFormData((prev) => ({
                    ...prev,
                    value: isDiscount ? -value : value,
                  }));
                }
              }}
              mode="outlined"
              keyboardType="numeric"
              error={!!errors.value}
              right={<TextInput.Affix text="%" />}
              style={styles.input}
            />
          ) : (
            <TextInput
              label="Monto"
              value={amountText}
              onChangeText={(text) => {
                // Solo permitir números positivos
                const regex = /^\d*\.?\d*$/;
                if (regex.test(text) || text === '') {
                  setAmountText(text);
                  const amount = parseFloat(text) || 0;
                  setFormData((prev) => ({
                    ...prev,
                    amount: isDiscount ? -amount : amount,
                  }));
                }
              }}
              mode="outlined"
              keyboardType="numeric"
              error={!!errors.amount}
              left={<TextInput.Affix text="$" />}
              style={styles.input}
            />
          )}
          {(errors.value || errors.amount) && (
            <HelperText type="error" visible={true}>
              {errors.value || errors.amount}
            </HelperText>
          )}
        </View>
        {/* Botones de acción */}
        <View
          style={[
            styles.actions,
            { borderTopColor: theme.colors.outlineVariant },
          ]}
        >
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[
              styles.actionButton,
              {
                borderColor: theme.colors.outline,
                backgroundColor: theme.colors.secondaryContainer,
              },
            ]}
            textColor={theme.colors.onSecondaryContainer}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSave}
            style={[styles.actionButton, styles.saveButton]}
            buttonColor={theme.colors.primary}
          >
            {adjustment ? 'Actualizar' : 'Guardar'}
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};
const styles = StyleSheet.create({
  modal: {
    borderRadius: 16,
    margin: 20,
    maxWidth: 400,
    width: '90%',
    maxHeight: '80%',
    alignSelf: 'center',
    elevation: 5,
    ...Platform.select({
      web: {
        boxShadow: '0px 2px 3.84px rgba(0, 0, 0, 0.25)',
      },
      default: {
        shadowColor: '#000',
        shadowOffset: {
          width: 0,
          height: 2,
        },
        shadowOpacity: 0.25,
        shadowRadius: 3.84,
      },
    }),
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    minHeight: 48,
  },
  title: {
    flex: 1,
    fontWeight: '500',
  },
  closeButton: {
    margin: -4,
  },
  content: {
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 16,
  },
  input: {
    marginBottom: 16,
  },
  typeContainer: {
    marginBottom: 16,
  },
  label: {
    marginBottom: 8,
    fontWeight: '500',
  },
  chipGroup: {
    flexDirection: 'row',
    gap: 12,
  },
  chip: {
    flex: 1,
  },
  operationContainer: {
    marginBottom: 16,
  },
  operationButtons: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 8,
  },
  operationButton: {
    flex: 1,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderTopWidth: 1,
    gap: 12,
  },
  actionButton: {
    minWidth: 100,
  },
  saveButton: {
    marginLeft: 4,
  },
});

================
File: app/src/modules/orders/components/PizzaCustomizationSection.tsx
================
import React, { useState, useMemo, useCallback, memo } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Text,
  Checkbox,
  Card,
  ActivityIndicator,
  Surface,
  Switch,
  IconButton,
  TouchableRipple,
  RadioButton,
} from 'react-native-paper';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import type {
  PizzaCustomization,
  PizzaConfiguration,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import {
  PizzaHalf,
  CustomizationAction,
  CustomizationType,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import { useAppTheme } from '@/app/styles/theme';
interface PizzaCustomizationSectionProps {
  pizzaCustomizations: PizzaCustomization[];
  pizzaConfiguration: PizzaConfiguration | null;
  selectedPizzaCustomizations: SelectedPizzaCustomization[];
  onCustomizationChange: (customizations: SelectedPizzaCustomization[]) => void;
  loading?: boolean;
}
interface FlavorItemProps {
  flavor: PizzaCustomization;
  isSelected: boolean;
  isDisabled: boolean;
  onToggle: (flavorId: string) => void;
  styles: any;
  theme: any;
}
const FlavorItem = memo<FlavorItemProps>(
  ({ flavor, isSelected, isDisabled, onToggle, styles, theme }) => (
    <Surface
      style={[
        styles.flavorChip,
        isSelected && styles.flavorChipSelected,
        isDisabled && styles.flavorChipDisabled,
      ]}
      elevation={isSelected ? 2 : 0}
    >
      <TouchableRipple
        onPress={() => !isDisabled && onToggle(flavor.id)}
        disabled={isDisabled}
        style={{
          paddingVertical: 12,
          paddingHorizontal: 16,
          borderRadius: 8,
        }}
      >
        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
          <RadioButton
            value={flavor.id}
            status={isSelected ? 'checked' : 'unchecked'}
            disabled={isDisabled}
            onPress={() => !isDisabled && onToggle(flavor.id)}
          />
          <View style={{ flex: 1, marginLeft: 8 }}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                gap: 8,
              }}
            >
              <Text
                style={[
                  styles.flavorLabel,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                {flavor.name}
              </Text>
              <Text
                style={[
                  styles.toppingValue,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                ({flavor.toppingValue})
              </Text>
            </View>
            {flavor.ingredients && (
              <Text
                style={[
                  styles.ingredientsText,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                {flavor.ingredients}
              </Text>
            )}
          </View>
        </View>
      </TouchableRipple>
    </Surface>
  ),
);
const PizzaCustomizationSection = memo<PizzaCustomizationSectionProps>(
  ({
    pizzaCustomizations,
    pizzaConfiguration,
    selectedPizzaCustomizations,
    onCustomizationChange,
    loading = false,
  }) => {
    const theme = useAppTheme();
    const styles = useMemo(() => createStyles(theme), [theme]);
    const [manualHalvesMode, setManualHalvesMode] = useState(false);
    const [expandedIngredients, setExpandedIngredients] = useState<{
      full: boolean;
      half1: boolean;
      half2: boolean;
    }>({
      full: false,
      half1: false,
      half2: false,
    });
    const [expandedFlavors, setExpandedFlavors] = useState(true);
    const flavors = useMemo(
      () =>
        pizzaCustomizations.filter((c) => c.type === CustomizationType.FLAVOR),
      [pizzaCustomizations],
    );
    const ingredients = useMemo(
      () =>
        pizzaCustomizations.filter(
          (c) => c.type === CustomizationType.INGREDIENT,
        ),
      [pizzaCustomizations],
    );
    const selectedFlavors = useMemo(
      () =>
        selectedPizzaCustomizations.filter(
          (sc) =>
            sc.action === CustomizationAction.ADD &&
            flavors.some((f) => f.id === sc.pizzaCustomizationId),
        ),
      [selectedPizzaCustomizations, flavors],
    );
    const getFlavorName = useCallback(
      (flavorId: string) => {
        const flavor = flavors.find((f) => f.id === flavorId);
        return flavor?.name || '';
      },
      [flavors],
    );
    const handleFlavorToggle = useCallback(
      (flavorId: string) => {
        const isSelected = selectedPizzaCustomizations.some(
          (sc) =>
            sc.pizzaCustomizationId === flavorId &&
            sc.action === CustomizationAction.ADD,
        );
        if (isSelected) {
          // Deseleccionar
          const remainingFlavorSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !(
                sc.pizzaCustomizationId === flavorId &&
                sc.action === CustomizationAction.ADD
              ),
          );
          // Si queda solo un sabor después de deseleccionar, cambiar su half a FULL
          const remainingFlavors = remainingFlavorSelections.filter(
            (sc) =>
              sc.action === CustomizationAction.ADD &&
              flavors.some((f) => f.id === sc.pizzaCustomizationId),
          );
          if (remainingFlavors.length === 1) {
            const otherFlavorId = remainingFlavors[0].pizzaCustomizationId;
            const nonFlavorSelections = remainingFlavorSelections.filter(
              (sc) =>
                !flavors.some((f) => f.id === sc.pizzaCustomizationId) ||
                sc.action !== CustomizationAction.ADD,
            );
            onCustomizationChange([
              ...nonFlavorSelections,
              {
                pizzaCustomizationId: otherFlavorId,
                half: PizzaHalf.FULL,
                action: CustomizationAction.ADD,
              },
            ]);
          } else {
            onCustomizationChange(remainingFlavorSelections);
          }
        } else {
          // Seleccionar
          const currentFlavors = selectedPizzaCustomizations.filter(
            (sc) =>
              sc.action === CustomizationAction.ADD &&
              flavors.some((f) => f.id === sc.pizzaCustomizationId),
          );
          if (currentFlavors.length >= 2) {
            return; // No permitir más de 2
          }
          const nonFlavorSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !flavors.some((f) => f.id === sc.pizzaCustomizationId) ||
              sc.action !== CustomizationAction.ADD,
          );
          if (currentFlavors.length === 0) {
            // Primer sabor - va completo o a mitad 1 si está el modo manual
            if (manualHalvesMode) {
              onCustomizationChange([
                ...nonFlavorSelections,
                {
                  pizzaCustomizationId: flavorId,
                  half: PizzaHalf.HALF_1,
                  action: CustomizationAction.ADD,
                },
              ]);
            } else {
              onCustomizationChange([
                ...nonFlavorSelections,
                {
                  pizzaCustomizationId: flavorId,
                  half: PizzaHalf.FULL,
                  action: CustomizationAction.ADD,
                },
              ]);
            }
          } else if (currentFlavors.length === 1) {
            // Segundo sabor - convertir a mitades
            const existingFlavor = currentFlavors[0];
            // Cambiar el sabor existente a mitad 1
            nonFlavorSelections.push({
              pizzaCustomizationId: existingFlavor.pizzaCustomizationId,
              half: PizzaHalf.HALF_1,
              action: CustomizationAction.ADD,
            });
            // Agregar el nuevo sabor a mitad 2
            nonFlavorSelections.push({
              pizzaCustomizationId: flavorId,
              half: PizzaHalf.HALF_2,
              action: CustomizationAction.ADD,
            });
            onCustomizationChange(nonFlavorSelections);
          }
        }
      },
      [
        selectedPizzaCustomizations,
        flavors,
        onCustomizationChange,
        manualHalvesMode,
      ],
    );
    const toggleIngredient = useCallback(
      (ingredientId: string, half: PizzaHalf, action: CustomizationAction) => {
        const existingIndex = selectedPizzaCustomizations.findIndex(
          (sc) =>
            sc.pizzaCustomizationId === ingredientId &&
            sc.half === half &&
            sc.action === action,
        );
        let newSelections: SelectedPizzaCustomization[];
        if (existingIndex >= 0) {
          newSelections = selectedPizzaCustomizations.filter(
            (_, index) => index !== existingIndex,
          );
        } else {
          // Remover cualquier acción previa del mismo ingrediente en la misma mitad
          newSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !(sc.pizzaCustomizationId === ingredientId && sc.half === half),
          );
          newSelections.push({
            pizzaCustomizationId: ingredientId,
            half,
            action,
          });
        }
        onCustomizationChange(newSelections);
      },
      [selectedPizzaCustomizations, onCustomizationChange],
    );
    const isIngredientSelected = useCallback(
      (
        ingredientId: string,
        half: PizzaHalf,
        action: CustomizationAction,
      ): boolean => {
        return selectedPizzaCustomizations.some(
          (sc) =>
            sc.pizzaCustomizationId === ingredientId &&
            sc.half === half &&
            sc.action === action,
        );
      },
      [selectedPizzaCustomizations],
    );
    // Determinar si mostrar modo mitades (2 sabores o modo manual activado)
    const showHalvesMode =
      selectedFlavors.length === 2 ||
      (manualHalvesMode && selectedFlavors.length <= 1);
    // Returns condicionales al final, después de todos los hooks
    if (loading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator animating size="large" />
          <Text style={styles.loadingText}>Cargando opciones de pizza...</Text>
        </View>
      );
    }
    if (!pizzaConfiguration || pizzaCustomizations.length === 0) {
      return null;
    }
    // Renderizar sección de personalización
    const renderCustomizationSection = (
      half: PizzaHalf,
      sectionTitle: string,
      flavorName?: string,
    ) => {
      const sectionKey =
        half === PizzaHalf.FULL
          ? 'full'
          : half === PizzaHalf.HALF_1
            ? 'half1'
            : 'half2';
      const isExpanded = expandedIngredients[sectionKey];
      const getDynamicTitle = () => {
        const customizationsForHalf = selectedPizzaCustomizations.filter(
          (sc) => sc.half === half,
        );
        const parts: string[] = [];
        if (flavorName) {
          parts.push(flavorName);
        } else if (half !== PizzaHalf.FULL) {
          parts.push('Sin sabor');
        }
        const addedIngredients: string[] = [];
        const removedIngredients: string[] = [];
        customizationsForHalf.forEach((sc) => {
          const customization = ingredients.find(
            (c) => c.id === sc.pizzaCustomizationId,
          );
          if (customization) {
            if (sc.action === CustomizationAction.ADD) {
              addedIngredients.push(customization.name);
            } else {
              removedIngredients.push(customization.name);
            }
          }
        });
        if (addedIngredients.length > 0) {
          parts.push(`con: ${addedIngredients.join(', ')}`);
        }
        if (removedIngredients.length > 0) {
          parts.push(`sin: ${removedIngredients.join(', ')}`);
        }
        return parts.length > 0
          ? parts.join(' - ')
          : flavorName || 'Sin personalizar';
      };
      return (
        <Card style={styles.optionCard}>
          <Card.Content style={{ paddingVertical: 16, paddingHorizontal: 16 }}>
            <View style={styles.sectionHeader}>
              <Text style={styles.sectionTitle}>
                {sectionTitle}:{' '}
                <Text style={styles.pizzaFormat}>{getDynamicTitle()}</Text>
              </Text>
            </View>
            <Surface style={styles.subsectionSurface} elevation={1}>
              <TouchableRipple
                onPress={() =>
                  setExpandedIngredients((prev) => ({
                    ...prev,
                    [sectionKey]: !prev[sectionKey],
                  }))
                }
                style={{ paddingVertical: 12, paddingHorizontal: 16 }}
              >
                <View style={styles.subsectionHeader}>
                  <Text style={styles.subsectionTitle}>
                    Personalizar Ingredientes
                  </Text>
                  <IconButton
                    icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                    size={20}
                    style={{ margin: -8 }}
                  />
                </View>
              </TouchableRipple>
              {isExpanded && (
                <View style={{ paddingHorizontal: 16, paddingBottom: 12 }}>
                  {ingredients.map((ingredient) => {
                    const isAddSelected = isIngredientSelected(
                      ingredient.id,
                      half,
                      CustomizationAction.ADD,
                    );
                    const isRemoveSelected = isIngredientSelected(
                      ingredient.id,
                      half,
                      CustomizationAction.REMOVE,
                    );
                    const isSelected = isAddSelected || isRemoveSelected;
                    const currentAction = isAddSelected
                      ? CustomizationAction.ADD
                      : CustomizationAction.REMOVE;
                    return (
                      <Surface
                        key={ingredient.id}
                        style={styles.ingredientItem}
                        elevation={0}
                      >
                        <TouchableRipple
                          onPress={() => {
                            if (isSelected) {
                              toggleIngredient(
                                ingredient.id,
                                half,
                                currentAction,
                              );
                            } else {
                              toggleIngredient(
                                ingredient.id,
                                half,
                                CustomizationAction.ADD,
                              );
                            }
                          }}
                          style={{ paddingVertical: 8, paddingHorizontal: 8 }}
                        >
                          <View
                            style={{
                              flexDirection: 'row',
                              alignItems: 'center',
                            }}
                          >
                            <View style={{ flex: 1 }}>
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  gap: 6,
                                }}
                              >
                                <Text style={styles.ingredientLabel}>
                                  {ingredient.name}
                                </Text>
                                <Text style={styles.toppingValueSmall}>
                                  ({ingredient.toppingValue})
                                </Text>
                              </View>
                            </View>
                            {isSelected && (
                              <View style={styles.actionToggle}>
                                <Text
                                  style={[
                                    styles.toggleLabel,
                                    currentAction === CustomizationAction.ADD &&
                                      styles.activeLabel,
                                  ]}
                                >
                                  Agregar
                                </Text>
                                <Switch
                                  value={
                                    currentAction === CustomizationAction.REMOVE
                                  }
                                  onValueChange={(value) => {
                                    const newAction = value
                                      ? CustomizationAction.REMOVE
                                      : CustomizationAction.ADD;
                                    toggleIngredient(
                                      ingredient.id,
                                      half,
                                      newAction,
                                    );
                                  }}
                                  style={styles.switch}
                                />
                                <Text
                                  style={[
                                    styles.toggleLabel,
                                    currentAction ===
                                      CustomizationAction.REMOVE &&
                                      styles.activeLabel,
                                  ]}
                                >
                                  Quitar
                                </Text>
                              </View>
                            )}
                            <RadioButton
                              value={ingredient.id}
                              status={isSelected ? 'checked' : 'unchecked'}
                              onPress={() => {
                                if (isSelected) {
                                  toggleIngredient(
                                    ingredient.id,
                                    half,
                                    currentAction,
                                  );
                                } else {
                                  toggleIngredient(
                                    ingredient.id,
                                    half,
                                    CustomizationAction.ADD,
                                  );
                                }
                              }}
                            />
                          </View>
                        </TouchableRipple>
                      </Surface>
                    );
                  })}
                </View>
              )}
            </Surface>
          </Card.Content>
        </Card>
      );
    };
    return (
      <View style={styles.container}>
        {}
        <Card style={styles.optionCard}>
          <Card.Content style={{ paddingVertical: 16, paddingHorizontal: 16 }}>
            <TouchableRipple
              onPress={() => setExpandedFlavors(!expandedFlavors)}
              style={{ marginBottom: expandedFlavors ? 12 : 0 }}
            >
              <View style={styles.sectionHeaderWithSwitch}>
                <View style={{ flex: 1 }}>
                  <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                    <Text style={styles.sectionTitle}>
                      Sabores
                      {selectedFlavors.length > 0 && (
                        <Text style={styles.pizzaFormat}>
                          {' - '}
                          {selectedFlavors
                            .map((sf) => {
                              const flavor = flavors.find(
                                (f) => f.id === sf.pizzaCustomizationId,
                              );
                              return flavor?.name || '';
                            })
                            .join(' / ')}
                        </Text>
                      )}
                    </Text>
                    <IconButton
                      icon={expandedFlavors ? 'chevron-up' : 'chevron-down'}
                      size={20}
                      style={{ margin: -8 }}
                    />
                  </View>
                  {expandedFlavors && (
                    <Text style={styles.helperText}>
                      Selecciona hasta 2 sabores
                    </Text>
                  )}
                </View>
                {expandedFlavors && selectedFlavors.length <= 1 && (
                  <View style={styles.halvesSwitch}>
                    <Text style={styles.switchLabel}>Dividir mitades</Text>
                    <Switch
                      value={manualHalvesMode}
                      onValueChange={(value) => {
                        setManualHalvesMode(value);
                        if (value && selectedFlavors.length <= 1) {
                          const updatedCustomizations =
                            selectedPizzaCustomizations.map((sc) => {
                              if (sc.half === PizzaHalf.FULL) {
                                return { ...sc, half: PizzaHalf.HALF_1 };
                              }
                              return sc;
                            });
                          onCustomizationChange(updatedCustomizations);
                        }
                        else if (!value && selectedFlavors.length === 1) {
                          const updatedCustomizations =
                            selectedPizzaCustomizations.map((sc) => {
                              if (
                                sc.half === PizzaHalf.HALF_1 ||
                                sc.half === PizzaHalf.HALF_2
                              ) {
                                return { ...sc, half: PizzaHalf.FULL };
                              }
                              return sc;
                            });
                          onCustomizationChange(updatedCustomizations);
                        }
                      }}
                    />
                  </View>
                )}
              </View>
            </TouchableRipple>
            {expandedFlavors && (
              <View style={styles.flavorsGrid}>
                {flavors.map((flavor) => {
                  const isSelected = selectedFlavors.some(
                    (sf) => sf.pizzaCustomizationId === flavor.id,
                  );
                  const isDisabled = selectedFlavors.length >= 2 && !isSelected;
                  return (
                    <FlavorItem
                      key={flavor.id}
                      flavor={flavor}
                      isSelected={isSelected}
                      isDisabled={isDisabled}
                      onToggle={handleFlavorToggle}
                      styles={styles}
                      theme={theme}
                    />
                  );
                })}
              </View>
            )}
          </Card.Content>
        </Card>
        {}
        {showHalvesMode ? (
          <>
            {renderCustomizationSection(
              PizzaHalf.HALF_1,
              'Mitad 1',
              selectedFlavors[0]
                ? getFlavorName(selectedFlavors[0].pizzaCustomizationId)
                : undefined,
            )}
            {renderCustomizationSection(
              PizzaHalf.HALF_2,
              'Mitad 2',
              selectedFlavors[1]
                ? getFlavorName(selectedFlavors[1].pizzaCustomizationId)
                : undefined,
            )}
          </>
        ) : (
          renderCustomizationSection(
            PizzaHalf.FULL,
            'Pizza Completa',
            selectedFlavors[0]
              ? getFlavorName(selectedFlavors[0].pizzaCustomizationId)
              : undefined,
          )
        )}
      </View>
    );
  },
);
const createStyles = (theme: any) =>
  StyleSheet.create({
    container: {
      gap: 8,
    },
    loadingContainer: {
      padding: 32,
      alignItems: 'center',
    },
    loadingText: {
      marginTop: 16,
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    optionCard: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      elevation: 1,
    },
    pizzaFormat: {
      fontSize: 16,
      fontWeight: 'normal',
      color: theme.colors.primary,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 12,
    },
    sectionHeaderWithSwitch: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    halvesSwitch: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    switchLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    sectionTitle: {
      fontSize: 18,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    flavorInline: {
      fontSize: 16,
      fontWeight: 'normal',
      color: theme.colors.primary,
    },
    helperText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 12,
    },
    flavorsGrid: {
      gap: 8,
    },
    flavorChip: {
      backgroundColor: theme.colors.surface,
      borderRadius: 8,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      elevation: 0,
      overflow: 'hidden',
    },
    flavorChipSelected: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    flavorChipDisabled: {
      opacity: 0.5,
    },
    flavorLabel: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    flavorLabelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    ingredientsText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    toppingValue: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
    },
    toppingValueSmall: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.5,
    },
    subsectionSurface: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 8,
      marginTop: 8,
    },
    subsectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    subsectionTitle: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    ingredientItem: {
      backgroundColor: 'transparent',
      marginTop: 4,
    },
    ingredientLabel: {
      fontSize: 14,
      color: theme.colors.onSurface,
    },
    actionToggle: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    toggleLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
    },
    activeLabel: {
      color: theme.colors.primary,
      fontWeight: 'bold',
    },
    switch: {
      marginHorizontal: 8,
      transform: [{ scale: 1.2 }],
    },
    priceInfoText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
  });
PizzaCustomizationSection.displayName = 'PizzaCustomizationSection';
export default PizzaCustomizationSection;

================
File: app/src/modules/orders/components/PrinterSelectionModal.tsx
================
import React, { useMemo } from 'react';
import { StyleSheet, FlatList, ListRenderItemInfo } from 'react-native';
import { Modal, Portal, List, Divider, Appbar } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { usePrintersQuery } from '../../printers/hooks/usePrintersQueries';
import type { ThermalPrinter } from '../../printers/types/printer.types';
import { useListState } from '../../../app/hooks/useListState';
interface PrinterSelectionModalProps {
  visible: boolean;
  onDismiss: () => void;
  onPrinterSelect: (printer: ThermalPrinter) => void;
  title?: string;
}
const PrinterSelectionModal: React.FC<PrinterSelectionModalProps> = ({
  visible,
  onDismiss,
  onPrinterSelect,
  title = 'Seleccionar Impresora',
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const {
    data: printersResponse,
    isLoading,
    isError,
    error: _error,
    refetch: _refetch,
  } = usePrintersQuery(
    { isActive: true, limit: 100, page: 1 },
    { enabled: visible },
  );
  const printers = useMemo(
    () => printersResponse?.data ?? [],
    [printersResponse],
  );
  const renderPrinterItem = ({ item }: ListRenderItemInfo<ThermalPrinter>) => (
    <List.Item
      title={item.name}
      description={`Tipo: ${item.connectionType}${item.ipAddress ? ` - IP: ${item.ipAddress}` : ''}`}
      left={(props) => <List.Icon {...props} icon="printer" />}
      onPress={() => onPrinterSelect(item)}
      style={styles.listItem}
      titleStyle={styles.itemTitle}
      descriptionStyle={styles.itemDescription}
    />
  );
  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: printers,
    emptyConfig: {
      title: 'No hay impresoras activas',
      message: 'No hay impresoras activas configuradas.',
      icon: 'printer-off',
    },
  });
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
      >
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction
            onPress={onDismiss}
            color={theme.colors.onSurface}
          />
          <Appbar.Content title={title} titleStyle={styles.appBarTitle} />
        </Appbar.Header>
        <FlatList
          data={printers}
          renderItem={renderPrinterItem}
          keyExtractor={(item: ThermalPrinter) => item.id}
          ItemSeparatorComponent={() => <Divider style={styles.divider} />}
          contentContainerStyle={styles.listContentContainer}
          ListEmptyComponent={ListEmptyComponent}
        />
      </Modal>
    </Portal>
  );
};
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '90%',
      maxHeight: '70%',
      alignSelf: 'center',
      borderRadius: theme.roundness * 2,
      elevation: 5,
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column',
    },
    appBar: {
      backgroundColor: theme.colors.elevation.level2,
    },
    appBarTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
    },
    listContentContainer: {
      paddingBottom: theme.spacing.m,
    },
    centeredView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
      minHeight: 150,
    },
    statusText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      marginTop: theme.spacing.m,
      color: theme.colors.error,
      textAlign: 'center',
      marginBottom: theme.spacing.m,
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      paddingHorizontal: theme.spacing.m,
    },
    itemTitle: {
      fontWeight: '500',
    },
    itemDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    divider: {
      height: StyleSheet.hairlineWidth,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: theme.spacing.m,
    },
  });
export default PrinterSelectionModal;

================
File: app/src/modules/orders/services/orderPrintService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
interface PrintTicketPayload {
  printerId: string;
  ticketType: 'GENERAL' | 'BILLING';
}
export const orderPrintService = {
  printTicket: async (orderId: string, payload: PrintTicketPayload) => {
    const response = await apiClient.post(
      API_PATHS.ORDERS_PRINT_TICKET.replace(':orderId', orderId),
      payload,
    );
    return response.data;
  },
};

================
File: app/src/modules/orders/services/paymentService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import type {
  Payment,
  CreatePaymentDto,
  UpdatePaymentDto,
  PaymentMethod,
  PaymentStatus,
} from '../types/payment.types';
class PaymentService {
  async createPayment(dto: CreatePaymentDto): Promise<Payment> {
    const response = await apiClient.post<Payment>(API_PATHS.PAYMENTS, dto);
    return response.data;
  }
  async getPayments(filters?: {
    orderId?: string;
    paymentMethod?: PaymentMethod;
    paymentStatus?: PaymentStatus;
  }): Promise<Payment[]> {
    const response = await apiClient.get<Payment[]>(API_PATHS.PAYMENTS, {
      params: filters,
    });
    return response.data;
  }
  async getPaymentById(id: string): Promise<Payment> {
    const response = await apiClient.get<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
    );
    return response.data;
  }
  async getPaymentsByOrderId(orderId: string): Promise<Payment[]> {
    const response = await apiClient.get<Payment[]>(
      API_PATHS.PAYMENTS_BY_ORDER.replace(':orderId', orderId),
    );
    return response.data;
  }
  async updatePayment(id: string, dto: UpdatePaymentDto): Promise<Payment> {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
      dto,
    );
    return response.data;
  }
  async deletePayment(id: string): Promise<void> {
    await apiClient.delete(API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id));
  }
}
export const paymentService = new PaymentService();

================
File: app/src/modules/payments/services/prepaymentService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Payment } from '../types/payment.types';
interface CreatePrepaymentDto {
  paymentMethod: 'CASH' | 'CARD' | 'TRANSFER';
  amount: number;
}
interface UpdatePrepaymentDto {
  paymentMethod?: 'CASH' | 'CARD' | 'TRANSFER';
  amount?: number;
}
export const prepaymentService = {
  createPrepayment: async (data: CreatePrepaymentDto): Promise<Payment> => {
    const response = await apiClient.post<Payment>(
      API_PATHS.PAYMENTS_PREPAYMENT,
      data,
    );
    return response.data;
  },
  updatePrepayment: async (
    paymentId: string,
    data: UpdatePrepaymentDto,
  ): Promise<Payment> => {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', paymentId),
      data,
    );
    return response.data;
  },
  associateToOrder: async (
    paymentId: string,
    orderId: string,
  ): Promise<Payment> => {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_ASSOCIATE.replace(':paymentId', paymentId).replace(
        ':orderId',
        orderId,
      ),
    );
    return response.data;
  },
  deletePrepayment: async (paymentId: string): Promise<void> => {
    await apiClient.delete(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', paymentId),
    );
  },
};

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationDetailModal.tsx
================
import React from 'react';
import GenericDetailModal from '@/app/components/crud/GenericDetailModal';
import {
  CustomizationType,
  PizzaCustomization,
} from '../types/pizzaCustomization.types';
interface PizzaCustomizationDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  customization: PizzaCustomization | null;
  onEdit?: (customization: PizzaCustomization) => void;
  onDelete?: (customization: PizzaCustomization) => void;
  isDeleting?: boolean;
}
export function PizzaCustomizationDetailModal({
  visible,
  onDismiss,
  customization,
  onEdit,
  onDelete,
  isDeleting = false,
}: PizzaCustomizationDetailModalProps) {
  if (!customization) return null;
  const handleEdit = () => {
    if (onEdit) {
      onEdit(customization);
    }
  };
  const handleDelete = () => {
    if (onDelete) {
      onDelete(customization);
    }
  };
  const fieldsToDisplay = [
    {
      field: 'type',
      label: 'Tipo',
      render: (type) =>
        type === CustomizationType.FLAVOR ? 'Sabor' : 'Ingrediente',
    },
    ...(customization.type === CustomizationType.FLAVOR
      ? [
          {
            field: 'ingredients',
            label: 'Ingredientes',
            render: (ingredients) => ingredients || 'Sin ingredientes',
          },
        ]
      : []),
    {
      field: 'toppingValue',
      label: 'Valor de topping',
      render: (value) => value?.toString() || '0',
    },
    {
      field: 'sortOrder',
      label: 'Orden de visualización',
      render: (value) => value?.toString() || '0',
    },
    {
      field: 'products',
      label: 'Asociado a productos',
      render: (products) => {
        if (!products || products.length === 0) {
          return 'No asociado a ningún producto';
        }
        const productNames = products.map((p) => p.name).join(', ');
        return `${products.length} producto${products.length > 1 ? 's' : ''}: ${productNames}`;
      },
    },
  ];
  return (
    <GenericDetailModal
      visible={visible}
      onDismiss={onDismiss}
      item={customization}
      titleField="name"
      statusConfig={{
        field: 'isActive',
        activeValue: true,
        activeLabel: 'Activo',
        inactiveLabel: 'Inactivo',
      }}
      fieldsToDisplay={fieldsToDisplay}
      onEdit={onEdit ? handleEdit : undefined}
      onDelete={onDelete ? handleDelete : undefined}
      isDeleting={isDeleting}
    />
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationsTab.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Text,
  Searchbar,
  ActivityIndicator,
  Menu,
  IconButton,
  Badge,
  Chip,
  Surface,
} from 'react-native-paper';
import { FlashList } from '@shopify/flash-list';
import { useAppTheme } from '@/app/styles/theme';
import {
  usePizzaCustomizationsList,
  useDeletePizzaCustomization,
} from '../hooks/usePizzaCustomizationsQueries';
import { PizzaCustomizationDetailModal } from './PizzaCustomizationDetailModal';
import { PizzaCustomizationFormModal } from './PizzaCustomizationFormModal';
import {
  CustomizationType,
  PizzaCustomization,
} from '../types/pizzaCustomization.types';
import EmptyState from '@/app/components/common/EmptyState';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
export function PizzaCustomizationsTab() {
  const theme = useAppTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedType, setSelectedType] = useState<CustomizationType | 'all'>(
    'all',
  );
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const [selectedCustomization, setSelectedCustomization] =
    useState<PizzaCustomization | null>(null);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [deleteConfirmVisible, setDeleteConfirmVisible] = useState(false);
  const [customizationToDelete, setCustomizationToDelete] =
    useState<PizzaCustomization | null>(null);
  const [formModalVisible, setFormModalVisible] = useState(false);
  const [editingCustomizationId, setEditingCustomizationId] = useState<
    string | undefined
  >();
  const deleteMutation = useDeletePizzaCustomization();
  const {
    data,
    isLoading,
    isError: _isError,
    refetch,
  } = usePizzaCustomizationsList({
    search: searchQuery || undefined,
    type: selectedType === 'all' ? undefined : selectedType,
    limit: 100,
  });
  const filteredData = data?.data || [];
  const hasActiveFilter = selectedType !== 'all';
  const handleItemPress = (item: PizzaCustomization) => {
    setSelectedCustomization(item);
    setDetailModalVisible(true);
  };
  const handleEdit = (customization: PizzaCustomization) => {
    setDetailModalVisible(false);
    setEditingCustomizationId(customization.id);
    setFormModalVisible(true);
  };
  const handleDelete = (customization: PizzaCustomization) => {
    setCustomizationToDelete(customization);
    setDetailModalVisible(false);
    setDeleteConfirmVisible(true);
  };
  const confirmDelete = async () => {
    if (customizationToDelete) {
      await deleteMutation.mutateAsync(customizationToDelete.id);
      setDeleteConfirmVisible(false);
      setCustomizationToDelete(null);
    }
  };
  const renderItem = ({ item }: { item: any }) => (
    <TouchableOpacity onPress={() => handleItemPress(item)}>
      <Surface
        style={[
          styles.cardWrapper,
          !item.isActive && styles.cardWrapperInactive,
        ]}
        elevation={1}
      >
        <View style={styles.cardContent}>
          <View style={styles.cardHeader}>
            <View style={styles.titleRow}>
              <View style={styles.titleContainer}>
                <Text
                  variant="titleMedium"
                  style={[
                    styles.cardTitle,
                    !item.isActive && styles.textInactive,
                  ]}
                  numberOfLines={1}
                >
                  {item.name}
                </Text>
                {!item.isActive && (
                  <Badge style={styles.inactiveBadge} size={16}>
                    Inactivo
                  </Badge>
                )}
              </View>
              <Chip
                mode="flat"
                compact
                icon={
                  item.type === CustomizationType.FLAVOR ? 'pizza' : 'cheese'
                }
                style={[
                  styles.typeChip,
                  {
                    backgroundColor:
                      item.type === CustomizationType.FLAVOR
                        ? theme.colors.errorContainer
                        : theme.colors.secondaryContainer,
                  },
                  !item.isActive && styles.chipInactive,
                ]}
                textStyle={styles.chipText}
              >
                {item.type === CustomizationType.FLAVOR
                  ? 'Sabor'
                  : 'Ingrediente'}
              </Chip>
            </View>
            <View style={styles.statsContainer}>
              <View
                style={[
                  styles.statusIndicator,
                  item.isActive ? styles.statusActive : styles.statusInactive,
                ]}
              />
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                Orden: {item.sortOrder || 0}
              </Text>
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                • Valor: {item.toppingValue || 0}
              </Text>
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                • {item.products?.length || 0} pizzas
              </Text>
            </View>
          </View>
          {item.ingredients && (
            <Text
              variant="bodySmall"
              style={[
                styles.ingredientsText,
                !item.isActive && styles.textInactive,
              ]}
              numberOfLines={1}
            >
              {item.ingredients}
            </Text>
          )}
        </View>
      </Surface>
    </TouchableOpacity>
  );
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      padding: theme.spacing.m,
      backgroundColor: theme.colors.background,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: theme.spacing.xs,
    },
    content: {
      flex: 1,
    },
    listContainer: {
      padding: theme.spacing.s,
    },
    cardWrapper: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    cardWrapperInactive: {
      opacity: 0.7,
    },
    cardContent: {
      padding: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
    },
    cardHeader: {
      marginBottom: theme.spacing.xs,
    },
    titleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      gap: theme.spacing.s,
    },
    titleContainer: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    cardTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 16,
    },
    textInactive: {
      color: theme.colors.onSurfaceVariant,
    },
    inactiveBadge: {
      backgroundColor: theme.colors.errorContainer,
      color: theme.colors.onErrorContainer,
      fontSize: 10,
      fontWeight: '600',
    },
    typeChip: {
      height: 24,
    },
    chipInactive: {
      opacity: 0.6,
    },
    chipText: {
      fontSize: 11,
      marginHorizontal: theme.spacing.xs,
      marginVertical: 0,
    },
    statsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      marginTop: theme.spacing.xs,
    },
    statusIndicator: {
      width: 8,
      height: 8,
      borderRadius: 4,
    },
    statusActive: {
      backgroundColor: theme.colors.primary,
    },
    statusInactive: {
      backgroundColor: theme.colors.error,
    },
    statText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    ingredientsText: {
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      fontSize: 12,
      marginTop: theme.spacing.xs,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
  });
  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }
  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder="Buscar personalización..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={
                    selectedType === 'all'
                      ? 'filter-variant'
                      : selectedType === CustomizationType.FLAVOR
                        ? 'pizza'
                        : 'cheese'
                  }
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                  iconColor={
                    selectedType !== 'all'
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setSelectedType('all');
                  setFilterMenuVisible(false);
                }}
                title="Todas"
                leadingIcon="filter-variant"
                trailingIcon={selectedType === 'all' ? 'check' : undefined}
                titleStyle={
                  selectedType === 'all'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setSelectedType(CustomizationType.FLAVOR);
                  setFilterMenuVisible(false);
                }}
                title="Sabores"
                leadingIcon="pizza"
                trailingIcon={
                  selectedType === CustomizationType.FLAVOR
                    ? 'check'
                    : undefined
                }
                titleStyle={
                  selectedType === CustomizationType.FLAVOR
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setSelectedType(CustomizationType.INGREDIENT);
                  setFilterMenuVisible(false);
                }}
                title="Ingredientes"
                leadingIcon="cheese"
                trailingIcon={
                  selectedType === CustomizationType.INGREDIENT
                    ? 'check'
                    : undefined
                }
                titleStyle={
                  selectedType === CustomizationType.INGREDIENT
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
            </Menu>
            {hasActiveFilter && <Badge style={styles.filterBadge} size={8} />}
          </View>
        </View>
      </View>
      <View style={styles.content}>
        <FlashList
          data={filteredData}
          renderItem={renderItem}
          estimatedItemSize={120}
          ListEmptyComponent={
            <EmptyState
              title="No hay personalizaciones"
              message={
                selectedType === CustomizationType.FLAVOR
                  ? 'No hay sabores disponibles'
                  : selectedType === CustomizationType.INGREDIENT
                    ? 'No hay ingredientes disponibles'
                    : 'No hay personalizaciones disponibles'
              }
              icon="cheese"
            />
          }
          contentContainerStyle={styles.listContainer}
          keyExtractor={(item) => item.id}
          refreshing={isLoading}
          onRefresh={refetch}
        />
      </View>
      <PizzaCustomizationDetailModal
        visible={detailModalVisible}
        onDismiss={() => {
          setDetailModalVisible(false);
          setSelectedCustomization(null);
        }}
        customization={selectedCustomization}
        onEdit={handleEdit}
        onDelete={handleDelete}
        isDeleting={deleteMutation.isPending}
      />
      <ConfirmationModal
        visible={deleteConfirmVisible}
        title="Eliminar personalización"
        message={`¿Estás seguro de que quieres eliminar "${customizationToDelete?.name}"?`}
        confirmText="Eliminar"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={confirmDelete}
        onCancel={() => {
          setDeleteConfirmVisible(false);
          setCustomizationToDelete(null);
        }}
        onDismiss={() => {
          setDeleteConfirmVisible(false);
          setCustomizationToDelete(null);
        }}
      />
      <PizzaCustomizationFormModal
        visible={formModalVisible}
        onDismiss={() => {
          setFormModalVisible(false);
          setEditingCustomizationId(undefined);
        }}
        customizationId={editingCustomizationId}
        onSuccess={() => {
          refetch();
        }}
      />
    </View>
  );
}

================
File: app/src/modules/preparationScreens/schema/preparationScreen.schema.ts
================
import { z } from 'zod';
import {
  preparationScreenSchema as domainPreparationScreenSchema,
  type PreparationScreen as DomainPreparationScreen,
} from '../../../app/schemas/domain/preparation-screen.schema';
export const PreparationScreenSchema = domainPreparationScreenSchema.extend({
  id: z.string().uuid(),
  products: z
    .array(
      z.object({
        id: z.string(),
        name: z.string(),
      }),
    )
    .optional(),
  users: z
    .array(
      z.object({
        id: z.string(),
        username: z.string(),
        firstName: z.string().nullable().optional(),
        lastName: z.string().nullable().optional(),
      }),
    )
    .nullable()
    .optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});
export const CreatePreparationScreenSchema = domainPreparationScreenSchema
  .omit({ id: true })
  .extend({
    name: z
      .string()
      .min(1, 'El nombre es requerido')
      .max(100, 'El nombre no puede exceder los 100 caracteres'),
    description: z
      .string()
      .max(255, 'La descripción no puede exceder los 255 caracteres')
      .nullable()
      .optional(),
    isActive: z.boolean().optional().default(true),
    productIds: z.array(z.string().uuid()).optional(),
    userId: z
      .string()
      .min(1, 'Debe seleccionar un usuario de cocina')
      .uuid({ message: 'Debe seleccionar un usuario de cocina válido' }),
  });
export const UpdatePreparationScreenSchema = CreatePreparationScreenSchema.omit(
  { userId: true },
).extend({
  name: z
    .string()
    .min(1, 'El nombre es requerido')
    .max(100, 'El nombre no puede exceder los 100 caracteres')
    .optional(),
  description: z
    .string()
    .max(255, 'La descripción no puede exceder los 255 caracteres')
    .nullable()
    .optional(),
  isActive: z.boolean().optional(),
  userId: z
    .string()
    .min(1, 'Debe seleccionar un usuario de cocina')
    .uuid({ message: 'Debe seleccionar un usuario de cocina válido' })
    .optional(),
});
export type PreparationScreen = z.infer<typeof PreparationScreenSchema>;
export type CreatePreparationScreenDto = z.infer<
  typeof CreatePreparationScreenSchema
>;
export type UpdatePreparationScreenDto = z.infer<
  typeof UpdatePreparationScreenSchema
>;
export type { DomainPreparationScreen };
export const FindAllPreparationScreensSchema = z.object({
  name: z.string().optional(),
  isActive: z.boolean().optional(),
});
export type FindAllPreparationScreensDto = z.infer<
  typeof FindAllPreparationScreensSchema
>;

================
File: app/src/modules/preparationScreens/services/preparationScreenService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { PaginatedResponse } from '../../../app/types/api.types';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  FindAllPreparationScreensDto,
} from '../schema/preparationScreen.schema';
export const getPreparationScreens = async (
  filterOptions: FindAllPreparationScreensDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 15 },
): Promise<PaginatedResponse<PreparationScreen>> => {
  const response = await apiClient.get<PaginatedResponse<PreparationScreen>>(
    API_PATHS.PREPARATION_SCREENS,
    {
      params: {
        ...filterOptions,
        page: paginationOptions.page,
        limit: paginationOptions.limit,
      },
    },
  );
  if (
    typeof response.data === 'object' &&
    'items' in response.data &&
    Array.isArray(response.data.items) &&
    'total' in response.data &&
    'page' in response.data &&
    'limit' in response.data
  ) {
    return {
      data: response.data.items,
      total: response.data.total,
      page: response.data.page,
      limit: response.data.limit,
      totalPages: Math.ceil(response.data.total / response.data.limit),
    };
  } else {
    throw new Error('Invalid response format from API');
  }
};
export const getPreparationScreenById = async (
  id: string,
): Promise<PreparationScreen> => {
  const response = await apiClient.get<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
  );
  return response.data;
};
export const createPreparationScreen = async (
  data: CreatePreparationScreenDto,
): Promise<PreparationScreen> => {
  const response = await apiClient.post<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS,
    data,
  );
  return response.data;
};
export const updatePreparationScreen = async (
  id: string,
  data: UpdatePreparationScreenDto,
): Promise<PreparationScreen> => {
  const response = await apiClient.patch<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};
export const deletePreparationScreen = async (id: string): Promise<void> => {
  await apiClient.delete(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
  );
};
export const getPreparationScreenProducts = async (
  id: string,
): Promise<any[]> => {
  const response = await apiClient.get<any[]>(
    API_PATHS.PREPARATION_SCREENS_PRODUCTS.replace(':id', id),
  );
  return response.data;
};
export const getMenuWithAssociations = async (id: string): Promise<any> => {
  const response = await apiClient.get<any>(
    API_PATHS.PREPARATION_SCREENS_MENU_WITH_ASSOCIATIONS.replace(':id', id),
  );
  return response.data;
};
export const associateProducts = async (
  id: string,
  productIds: string[],
): Promise<PreparationScreen> => {
  const response = await apiClient.post<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_PRODUCTS.replace(':id', id),
    { productIds },
  );
  return response.data;
};

================
File: app/src/modules/printers/components/NumericField.tsx
================
import React, { useState, useEffect } from 'react';
import AnimatedLabelInput from '../../../app/components/common/AnimatedLabelInput';
interface NumericFieldProps {
  label: string;
  value: number | undefined;
  onChange: (value: number | undefined) => void;
  onBlur: () => void;
  error?: boolean;
  disabled?: boolean;
  defaultValue: number;
}
const NumericField: React.FC<NumericFieldProps> = ({
  label,
  value,
  onChange,
  onBlur,
  error,
  disabled,
  defaultValue,
}) => {
  const [displayValue, setDisplayValue] = useState(() =>
    value !== undefined ? String(value) : '',
  );
  const [isFocused, setIsFocused] = useState(false);
  // Sincronizar valor externo con display solo cuando no está enfocado
  useEffect(() => {
    if (!isFocused && value !== undefined) {
      setDisplayValue(String(value));
    }
  }, [value, isFocused]);
  const handleChangeText = (text: string) => {
    // Permitir solo números
    const numericText = text.replace(/[^0-9]/g, '');
    setDisplayValue(numericText);
    if (numericText === '') {
      onChange(undefined);
    } else {
      const numValue = parseInt(numericText, 10);
      if (!isNaN(numValue)) {
        onChange(numValue);
      }
    }
  };
  const handleBlur = () => {
    setIsFocused(false);
    if (value === undefined || isNaN(Number(value))) {
      onChange(defaultValue);
      setDisplayValue(String(defaultValue));
    }
    onBlur();
  };
  const handleFocus = () => {
    setIsFocused(true);
  };
  return (
    <AnimatedLabelInput
      label={label}
      value={displayValue}
      onChangeText={handleChangeText}
      onBlur={handleBlur}
      onFocus={handleFocus}
      error={error}
      disabled={disabled}
      keyboardType="number-pad"
      containerStyle={{ marginBottom: 12 }}
    />
  );
};
export default NumericField;

================
File: app/src/modules/printers/components/PrinterAdvancedConfig.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Text,
  SegmentedButtons,
  HelperText,
  Switch,
  Card,
  Chip,
} from 'react-native-paper';
import { Controller, Control, FieldErrors } from 'react-hook-form';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PrinterFormData } from '../schema/printer.schema';
import NumericField from './NumericField';
interface PrinterAdvancedConfigProps {
  control: Control<PrinterFormData>;
  errors: FieldErrors<PrinterFormData>;
  isSubmitting: boolean;
}
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginTop: theme.spacing.m,
    },
    sectionTitle: {
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.l,
      color: theme.colors.primary,
      fontWeight: '600',
    },
    input: {
      marginBottom: theme.spacing.m,
    },
    switchContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: theme.spacing.m,
      fontSize: 16,
      flexShrink: 1,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    segmentedButtons: {
      marginBottom: theme.spacing.m,
    },
    recommendationCard: {
      marginBottom: theme.spacing.m,
      padding: theme.spacing.m,
      backgroundColor: theme.colors.primaryContainer,
    },
    recommendationTitle: {
      fontWeight: '600',
      marginBottom: theme.spacing.xs,
      color: theme.colors.onPrimaryContainer,
    },
    recommendationRow: {
      flexDirection: 'row',
      alignItems: 'center',
      marginVertical: theme.spacing.xs,
    },
    recommendationText: {
      marginLeft: theme.spacing.s,
      color: theme.colors.onPrimaryContainer,
    },
    chip: {
      marginRight: theme.spacing.xs,
    },
  });
const PrinterAdvancedConfig: React.FC<PrinterAdvancedConfigProps> = ({
  control,
  errors,
  isSubmitting,
}) => {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  return (
    <View style={styles.container}>
      <Text variant="titleMedium" style={styles.sectionTitle}>
        Configuración del Papel
      </Text>
      {}
      <Card style={styles.recommendationCard}>
        <Card.Content>
          <Text variant="bodyMedium" style={styles.recommendationTitle}>
            Recomendaciones de configuración:
          </Text>
          <View style={styles.recommendationRow}>
            <Chip compact style={styles.chip}>
              80mm
            </Chip>
            <Text variant="bodySmall" style={styles.recommendationText}>
              48 caracteres (normal) • 64 (comprimido)
            </Text>
          </View>
          <View style={styles.recommendationRow}>
            <Chip compact style={styles.chip}>
              58mm
            </Chip>
            <Text variant="bodySmall" style={styles.recommendationText}>
              32 caracteres (normal) • 42 (comprimido)
            </Text>
          </View>
        </Card.Content>
      </Card>
      {}
      <Controller
        name="paperWidth"
        control={control}
        render={({ field: { onChange, value } }) => (
          <View>
            <Text variant="bodyMedium" style={{ marginBottom: 8 }}>
              Ancho del papel
            </Text>
            <SegmentedButtons
              value={String(value)}
              onValueChange={(val) => onChange(Number(val))}
              buttons={[
                {
                  value: '58',
                  label: '58mm',
                  disabled: isSubmitting,
                },
                {
                  value: '80',
                  label: '80mm',
                  disabled: isSubmitting,
                },
              ]}
              style={styles.segmentedButtons}
            />
          </View>
        )}
      />
      {}
      <Controller
        name="charactersPerLine"
        control={control}
        render={({ field: { onChange, onBlur, value } }) => (
          <NumericField
            label="Caracteres por línea"
            value={value}
            onChange={onChange}
            onBlur={onBlur}
            error={!!errors.charactersPerLine}
            disabled={isSubmitting}
            defaultValue={48}
          />
        )}
      />
      {errors.charactersPerLine && (
        <HelperText
          type="error"
          visible={!!errors.charactersPerLine}
          style={styles.helperText}
        >
          {errors.charactersPerLine.message}
        </HelperText>
      )}
      <HelperText type="info" visible={true} style={styles.helperText}>
        Ajusta según el ancho real de impresión de tu impresora
      </HelperText>
      <Text variant="titleMedium" style={styles.sectionTitle}>
        Configuración de Corte
      </Text>
      {}
      <View style={styles.switchContainer}>
        <Text variant="bodyLarge" style={styles.switchLabel}>
          Cortar papel automáticamente
        </Text>
        <Controller
          name="cutPaper"
          control={control}
          render={({ field: { onChange, value } }) => (
            <Switch
              value={value}
              onValueChange={onChange}
              disabled={isSubmitting}
            />
          )}
        />
      </View>
      {}
      <Controller
        name="feedLines"
        control={control}
        render={({ field: { onChange, onBlur, value } }) => (
          <NumericField
            label="Líneas de avance antes del corte"
            value={value}
            onChange={onChange}
            onBlur={onBlur}
            error={!!errors.feedLines}
            disabled={isSubmitting}
            defaultValue={3}
          />
        )}
      />
      {errors.feedLines && (
        <HelperText
          type="error"
          visible={!!errors.feedLines}
          style={styles.helperText}
        >
          {errors.feedLines.message}
        </HelperText>
      )}
      <HelperText type="info" visible={true} style={styles.helperText}>
        Líneas en blanco para que el ticket salga completamente (0-50)
      </HelperText>
    </View>
  );
};
export default PrinterAdvancedConfig;

================
File: app/src/modules/printers/components/PrinterDetailModal.tsx
================
import React from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Surface,
  IconButton,
  Divider,
  Button,
  Chip,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { ThermalPrinter } from '../types/printer.types';
interface PrinterDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  printer: ThermalPrinter | null;
  onEdit?: () => void;
  onDelete?: () => void;
  onTestPrint?: () => void;
  isDeleting?: boolean;
  isTestPrinting?: boolean;
}
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      borderRadius: theme.roundness * 3,
      margin: theme.spacing.l,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    header: {
      backgroundColor: theme.colors.primary,
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.m,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    headerTextContainer: {
      flex: 1,
    },
    headerTitle: {
      color: theme.colors.onPrimary,
      fontSize: 20,
      fontWeight: '700',
    },
    headerSubtitle: {
      color: theme.colors.onPrimary,
      opacity: 0.8,
      fontSize: 14,
      marginTop: 4,
    },
    closeButton: {
      margin: -theme.spacing.xs,
    },
    scrollView: {
      maxHeight: 400,
    },
    scrollContent: {
      padding: theme.spacing.l,
    },
    section: {
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.primary,
      marginBottom: theme.spacing.s,
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    infoLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    infoValue: {
      fontSize: 14,
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
      flex: 1,
      marginLeft: theme.spacing.m,
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.m,
    },
    statusChip: {
      paddingHorizontal: theme.spacing.xs,
    },
    activeChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    inactiveChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    featuresGrid: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.s,
      marginTop: theme.spacing.s,
    },
    featureCard: {
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surfaceVariant,
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      minWidth: '45%',
      flex: 1,
    },
    featureIcon: {
      backgroundColor: theme.colors.secondaryContainer,
      borderRadius: theme.roundness,
      padding: theme.spacing.xs,
    },
    featureText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    divider: {
      marginVertical: theme.spacing.m,
    },
    testPrintButton: {
      marginBottom: theme.spacing.m,
      borderColor: theme.colors.primary,
    },
    footer: {
      padding: theme.spacing.l,
      paddingTop: 0,
      gap: theme.spacing.s,
    },
    footerButtons: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    footerButton: {
      flex: 1,
    },
    deleteButton: {
      borderColor: theme.colors.error,
    },
    emptyState: {
      padding: theme.spacing.xl,
      alignItems: 'center',
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
    },
  });
const PrinterDetailModal: React.FC<PrinterDetailModalProps> = ({
  visible,
  onDismiss,
  printer,
  onEdit,
  onDelete,
  onTestPrint,
  isDeleting = false,
  isTestPrinting = false,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);
  if (!printer && visible) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContent}
        >
          <View style={styles.emptyState}>
            <Text style={styles.emptyText}>No se encontró la impresora</Text>
          </View>
        </Modal>
      </Portal>
    );
  }
  if (!printer) return null;
  const getConnectionInfo = () => {
    if (printer.connectionType === 'NETWORK') {
      return `${printer.ipAddress || 'N/A'}:${printer.port || 9100}`;
    }
    return printer.path || 'N/A';
  };
  const formatDate = (dateString?: string) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString('es-ES', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
      >
        <View>
          <Surface style={styles.header}>
            <View style={styles.headerContent}>
              <View style={styles.headerTextContainer}>
                <Text style={styles.headerTitle}>{printer.name}</Text>
                <Text style={styles.headerSubtitle}>
                  {printer.connectionType} • {getConnectionInfo()}
                </Text>
              </View>
              <IconButton
                icon="close"
                size={24}
                iconColor={theme.colors.onPrimary}
                onPress={onDismiss}
                style={styles.closeButton}
              />
            </View>
          </Surface>
          <ScrollView
            style={styles.scrollView}
            contentContainerStyle={styles.scrollContent}
          >
            {}
            <View style={styles.section}>
              <View style={styles.statusContainer}>
                <Chip
                  mode="flat"
                  style={[
                    styles.statusChip,
                    printer.isActive ? styles.activeChip : styles.inactiveChip,
                  ]}
                  textStyle={{
                    color: printer.isActive
                      ? theme.colors.onPrimaryContainer
                      : theme.colors.onErrorContainer,
                  }}
                >
                  {printer.isActive ? 'Activa' : 'Inactiva'}
                </Chip>
                {printer.isDefaultPrinter && (
                  <Chip
                    mode="flat"
                    style={[styles.statusChip, styles.activeChip]}
                    icon="star"
                    textStyle={{ color: theme.colors.onPrimaryContainer }}
                  >
                    Predeterminada
                  </Chip>
                )}
              </View>
              <View style={styles.featuresGrid}>
                {printer.autoDeliveryPrint && (
                  <Surface style={styles.featureCard}>
                    <View style={styles.featureIcon}>
                      <IconButton
                        icon="home-export-outline"
                        size={16}
                        iconColor={theme.colors.onSecondaryContainer}
                        style={{ margin: 0 }}
                      />
                    </View>
                    <Text style={styles.featureText}>
                      Impresión automática para domicilio
                    </Text>
                  </Surface>
                )}
                {printer.autoPickupPrint && (
                  <Surface style={styles.featureCard}>
                    <View style={styles.featureIcon}>
                      <IconButton
                        icon="bag-checked"
                        size={16}
                        iconColor={theme.colors.onSecondaryContainer}
                        style={{ margin: 0 }}
                      />
                    </View>
                    <Text style={styles.featureText}>
                      Impresión automática para llevar
                    </Text>
                  </Surface>
                )}
              </View>
            </View>
            <Divider style={styles.divider} />
            {}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Información de Conexión</Text>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Tipo de conexión</Text>
                <Text style={styles.infoValue}>{printer.connectionType}</Text>
              </View>
              {printer.connectionType === 'NETWORK' && (
                <>
                  <View style={styles.infoRow}>
                    <Text style={styles.infoLabel}>Dirección IP</Text>
                    <Text style={styles.infoValue}>
                      {printer.ipAddress || 'N/A'}
                    </Text>
                  </View>
                  <View style={styles.infoRow}>
                    <Text style={styles.infoLabel}>Puerto</Text>
                    <Text style={styles.infoValue}>
                      {printer.port || 'N/A'}
                    </Text>
                  </View>
                  {printer.macAddress && (
                    <View style={styles.infoRow}>
                      <Text style={styles.infoLabel}>Dirección MAC</Text>
                      <Text style={styles.infoValue}>{printer.macAddress}</Text>
                    </View>
                  )}
                </>
              )}
              {printer.connectionType !== 'NETWORK' && printer.path && (
                <View style={styles.infoRow}>
                  <Text style={styles.infoLabel}>Ruta/ID</Text>
                  <Text style={styles.infoValue}>{printer.path}</Text>
                </View>
              )}
            </View>
            <Divider style={styles.divider} />
            {}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Configuración del Papel</Text>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Ancho del papel</Text>
                <Text style={styles.infoValue}>{printer.paperWidth}mm</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Caracteres por línea</Text>
                <Text style={styles.infoValue}>
                  {printer.charactersPerLine}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Corte automático</Text>
                <Text style={styles.infoValue}>
                  {printer.cutPaper ? 'Sí' : 'No'}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Líneas de avance</Text>
                <Text style={styles.infoValue}>{printer.feedLines}</Text>
              </View>
            </View>
            <Divider style={styles.divider} />
            {}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Información Adicional</Text>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Creada</Text>
                <Text style={styles.infoValue}>
                  {formatDate(printer.createdAt)}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Última actualización</Text>
                <Text style={styles.infoValue}>
                  {formatDate(printer.updatedAt)}
                </Text>
              </View>
            </View>
          </ScrollView>
          <View style={styles.footer}>
            {onTestPrint && (
              <Button
                mode="outlined"
                icon="printer-check"
                onPress={onTestPrint}
                loading={isTestPrinting}
                disabled={isTestPrinting || isDeleting}
                style={styles.testPrintButton}
              >
                Imprimir Ticket de Prueba
              </Button>
            )}
            <View style={styles.footerButtons}>
              {onEdit && (
                <Button
                  mode="contained-tonal"
                  onPress={onEdit}
                  disabled={isDeleting || isTestPrinting}
                  style={styles.footerButton}
                >
                  Editar
                </Button>
              )}
              {onDelete && (
                <Button
                  mode="outlined"
                  onPress={onDelete}
                  loading={isDeleting}
                  disabled={isDeleting || isTestPrinting}
                  style={[styles.footerButton, styles.deleteButton]}
                  textColor={theme.colors.error}
                >
                  Eliminar
                </Button>
              )}
            </View>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};
export default PrinterDetailModal;

================
File: app/src/modules/printers/components/PrinterFormModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Switch,
  HelperText,
  ActivityIndicator,
  RadioButton,
} from 'react-native-paper';
import { useForm, Controller, SubmitHandler } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import {
  PrinterFormData,
  printerFormSchema,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
} from '../schema/printer.schema';
import {
  useCreatePrinterMutation,
  useUpdatePrinterMutation,
} from '../hooks/usePrintersQueries';
import AnimatedLabelInput from '../../../app/components/common/AnimatedLabelInput';
import PrinterAdvancedConfig from './PrinterAdvancedConfig';
interface PrinterFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  editingItem: ThermalPrinter | null;
  initialDataFromDiscovery?: Partial<PrinterFormData>;
}
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: theme.spacing.l,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.xl,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
    },
    input: {
      marginBottom: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: theme.spacing.m,
      fontSize: 16,
      flexShrink: 1,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    radioGroupContainer: {
      marginBottom: theme.spacing.m,
    },
    radioGroupLabel: {
      marginBottom: theme.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    radioGroupHorizontal: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      flexWrap: 'wrap',
    },
    radioButtonItem: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: theme.spacing.s,
      paddingVertical: 0,
    },
    radioLabel: {
      fontSize: 14,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: theme.spacing.m,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: theme.spacing.xs,
      flex: 1,
      maxWidth: 200,
    },
    cancelButton: {},
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      zIndex: 10,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
  });
const PrinterFormModal: React.FC<PrinterFormModalProps> = ({
  visible,
  onDismiss,
  editingItem,
  initialDataFromDiscovery,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const isEditing = !!editingItem;
  const createMutation = useCreatePrinterMutation();
  const updateMutation = useUpdatePrinterMutation();
  const isSubmitting = createMutation.isPending || updateMutation.isPending;
  const defaultValues = useMemo((): PrinterFormData => {
    const baseDefaults: PrinterFormData = {
      name: '',
      connectionType: 'NETWORK',
      ipAddress: undefined,
      port: undefined,
      path: undefined,
      isActive: true,
      macAddress: undefined,
      isDefaultPrinter: false,
      autoDeliveryPrint: false,
      autoPickupPrint: false,
      paperWidth: 80,
      charactersPerLine: 48,
      cutPaper: true,
      feedLines: 3,
    };
    if (isEditing && editingItem) {
      return {
        name: editingItem.name,
        connectionType: editingItem.connectionType,
        ipAddress: editingItem.ipAddress ?? undefined,
        port: editingItem.port ?? undefined,
        path: editingItem.path ?? undefined,
        isActive: editingItem.isActive,
        macAddress: editingItem.macAddress ?? undefined,
        isDefaultPrinter: editingItem.isDefaultPrinter ?? false,
        autoDeliveryPrint: editingItem.autoDeliveryPrint ?? false,
        autoPickupPrint: editingItem.autoPickupPrint ?? false,
        paperWidth: editingItem.paperWidth ?? 80,
        charactersPerLine: editingItem.charactersPerLine ?? 48,
        cutPaper: editingItem.cutPaper ?? true,
        feedLines: editingItem.feedLines ?? 3,
      };
    }
    if (!isEditing && initialDataFromDiscovery) {
      return {
        ...baseDefaults,
        name:
          initialDataFromDiscovery.name ||
          `Impresora ${initialDataFromDiscovery.ipAddress}`,
        connectionType: 'NETWORK',
        ipAddress: initialDataFromDiscovery.ipAddress,
        port: initialDataFromDiscovery.port,
        macAddress: initialDataFromDiscovery.macAddress,
      };
    }
    return baseDefaults;
  }, [editingItem, isEditing, initialDataFromDiscovery]);
  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors },
  } = useForm<PrinterFormData>({
    resolver: zodResolver(printerFormSchema),
    defaultValues: defaultValues,
  });
  const connectionType = watch('connectionType');
  useEffect(() => {
    if (visible) {
      reset(defaultValues);
    }
  }, [visible, editingItem, initialDataFromDiscovery, reset, defaultValues]);
  const onSubmit: SubmitHandler<PrinterFormData> = async (formData) => {
    const dataToSend = { ...formData };
    if (dataToSend.connectionType === 'NETWORK') {
      dataToSend.path = undefined;
    } else {
      dataToSend.ipAddress = undefined;
      dataToSend.port = undefined;
    }
    if (dataToSend.port && typeof dataToSend.port === 'string') {
      dataToSend.port = parseInt(dataToSend.port, 10);
      if (isNaN(dataToSend.port)) {
        dataToSend.port = undefined;
      }
    }
    try {
      if (isEditing && editingItem) {
        await updateMutation.mutateAsync({
          id: editingItem.id,
          data: dataToSend as UpdateThermalPrinterDto,
        });
      } else {
        await createMutation.mutateAsync(dataToSend as CreateThermalPrinterDto);
      }
      onDismiss();
    } catch (error) {}
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting}
      >
        <View style={styles.formContainer}>
          <View style={styles.modalHeader}>
            <Text variant="titleLarge" style={styles.modalTitle}>
              {isEditing ? 'Editar Impresora' : 'Nueva Impresora'}
            </Text>
          </View>
          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            {}
            <Controller
              name="name"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <AnimatedLabelInput
                  label="Nombre *"
                  value={value}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.name}
                  disabled={isSubmitting}
                  containerStyle={styles.input}
                />
              )}
            />
            {errors.name && (
              <HelperText
                type="error"
                visible={!!errors.name}
                style={styles.helperText}
              >
                {errors.name.message}
              </HelperText>
            )}
            {}
            <View style={styles.radioGroupContainer}>
              <Text style={styles.radioGroupLabel}>Tipo de Conexión *</Text>
              <Controller
                name="connectionType"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <RadioButton.Group onValueChange={onChange} value={value}>
                    <View style={styles.radioGroupHorizontal}>
                      <RadioButton.Item
                        label="Red"
                        value="NETWORK"
                        style={styles.radioButtonItem}
                        labelStyle={styles.radioLabel}
                        position="leading"
                        disabled={isSubmitting}
                      />
                      <RadioButton.Item
                        label="USB"
                        value="USB"
                        style={styles.radioButtonItem}
                        labelStyle={styles.radioLabel}
                        position="leading"
                        disabled={true}
                      />
                    </View>
                  </RadioButton.Group>
                )}
              />
              {errors.connectionType && (
                <HelperText
                  type="error"
                  visible={!!errors.connectionType}
                  style={styles.helperText}
                >
                  {errors.connectionType.message}
                </HelperText>
              )}
            </View>
            {}
            {connectionType === 'NETWORK' && (
              <>
                <Controller
                  name="ipAddress"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Dirección IP *"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.ipAddress}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      keyboardType="decimal-pad"
                    />
                  )}
                />
                {errors.ipAddress && (
                  <HelperText
                    type="error"
                    visible={!!errors.ipAddress}
                    style={styles.helperText}
                  >
                    {errors.ipAddress.message}
                  </HelperText>
                )}
                <Controller
                  name="port"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Puerto *"
                      value={
                        value !== undefined && value !== null
                          ? String(value)
                          : ''
                      }
                      onChangeText={(text) => {
                        if (!text) {
                          onChange(undefined);
                          return;
                        }
                        const parsedPort = parseInt(text, 10);
                        onChange(isNaN(parsedPort) ? undefined : parsedPort);
                      }}
                      onBlur={onBlur}
                      error={!!errors.port}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      keyboardType="number-pad"
                    />
                  )}
                />
                {errors.port && (
                  <HelperText
                    type="error"
                    visible={!!errors.port}
                    style={styles.helperText}
                  >
                    {errors.port.message}
                  </HelperText>
                )}
                <Controller
                  name="macAddress"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Dirección MAC (Opcional)"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.macAddress}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      autoCapitalize="characters"
                    />
                  )}
                />
                {errors.macAddress && (
                  <HelperText
                    type="error"
                    visible={!!errors.macAddress}
                    style={styles.helperText}
                  >
                    {errors.macAddress.message}
                  </HelperText>
                )}
              </>
            )}
            {connectionType !== 'NETWORK' && (
              <>
                <Controller
                  name="path"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Ruta / Identificador *"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.path}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      placeholder={
                        connectionType === 'USB'
                          ? '/dev/usb/lp0'
                          : connectionType === 'SERIAL'
                            ? '/dev/ttyS0'
                            : 'Dirección BT'
                      }
                    />
                  )}
                />
                {errors.path && (
                  <HelperText
                    type="error"
                    visible={!!errors.path}
                    style={styles.helperText}
                  >
                    {errors.path.message}
                  </HelperText>
                )}
              </>
            )}
            {}
            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Activa
              </Text>
              <Controller
                name="isActive"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isActive && (
              <HelperText
                type="error"
                visible={!!errors.isActive}
                style={styles.helperText}
              >
                {errors.isActive.message}
              </HelperText>
            )}
            {}
            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Impresora Predeterminada
              </Text>
              <Controller
                name="isDefaultPrinter"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Imprimir Automáticamente Domicilio
              </Text>
              <Controller
                name="autoDeliveryPrint"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Imprimir Automáticamente Para Llevar
              </Text>
              <Controller
                name="autoPickupPrint"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {}
            <PrinterAdvancedConfig
              control={control}
              errors={errors}
              isSubmitting={isSubmitting}
            />
          </ScrollView>
          {isSubmitting && (
            <View style={styles.loadingOverlay}>
              <ActivityIndicator
                animating={true}
                size="large"
                color={theme.colors.primary}
              />
            </View>
          )}
          <View style={styles.modalActions}>
            <Button
              mode="outlined"
              onPress={onDismiss}
              style={[styles.formButton, styles.cancelButton]}
              disabled={isSubmitting}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              loading={isSubmitting}
              disabled={isSubmitting}
              style={styles.formButton}
            >
              {isEditing ? 'Guardar' : 'Crear'}
            </Button>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};
export default PrinterFormModal;

================
File: app/src/modules/printers/schema/printer.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/query.types';
export const PrinterConnectionTypeSchema = z.enum([
  'NETWORK',
  'USB',
  'SERIAL',
  'BLUETOOTH',
]);
export type PrinterConnectionType = z.infer<typeof PrinterConnectionTypeSchema>;
const macRegex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/i;
export const thermalPrinterSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  connectionType: PrinterConnectionTypeSchema,
  ipAddress: z.string().ip({ version: 'v4' }).nullable(),
  port: z.number().int().positive().nullable(),
  path: z.string().nullable(),
  isActive: z.boolean(),
  macAddress: z.string().regex(macRegex, 'MAC inválida').nullable().optional(),
  isDefaultPrinter: z.boolean().optional().default(false),
  autoDeliveryPrint: z.boolean().optional().default(false),
  autoPickupPrint: z.boolean().optional().default(false),
  paperWidth: z.number().optional().default(80),
  charactersPerLine: z.number().optional().default(48),
  cutPaper: z.boolean().optional().default(true),
  feedLines: z.number().optional().default(3),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
  deletedAt: z.string().datetime().nullable().optional(),
});
export type ThermalPrinter = z.infer<typeof thermalPrinterSchema>;
const thermalPrinterDtoObjectSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  connectionType: PrinterConnectionTypeSchema,
  ipAddress: z
    .string()
    .ip({ version: 'v4', message: 'IP inválida' })
    .optional(),
  port: z.coerce
    .number()
    .int()
    .positive('El puerto debe ser un número positivo')
    .optional(),
  path: z.string().optional(),
  isActive: z.boolean().optional().default(true),
  macAddress: z.string().regex(macRegex, 'MAC inválida').optional(),
  isDefaultPrinter: z.boolean().optional().default(false),
  autoDeliveryPrint: z.boolean().optional().default(false),
  autoPickupPrint: z.boolean().optional().default(false),
  paperWidth: z
    .number()
    .min(58, 'El ancho del papel debe ser de al menos 58mm')
    .optional()
    .default(80),
  charactersPerLine: z
    .number()
    .min(32, 'Debe tener al menos 32 caracteres por línea')
    .optional()
    .default(48),
  cutPaper: z.boolean().optional().default(true),
  feedLines: z
    .number()
    .min(0, 'No puede ser menor a 0 líneas')
    .max(50, 'No puede ser mayor a 50 líneas')
    .optional()
    .default(3),
});
const refinePrinterDto = (
  data: Partial<z.infer<typeof thermalPrinterDtoObjectSchema>>,
  ctx: z.RefinementCtx,
) => {
  if (data.connectionType === undefined) return;
  if (data.connectionType === 'NETWORK') {
    if (!data.ipAddress) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La dirección IP es requerida para conexión NETWORK',
        path: ['ipAddress'],
      });
    }
    if (!data.port) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El puerto es requerido para conexión NETWORK',
        path: ['port'],
      });
    }
    if (data.path !== undefined && data.path !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La ruta debe estar vacía para conexión NETWORK',
        path: ['path'],
      });
    }
  } else {
    if (!data.path) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'La ruta/identificador es requerido para este tipo de conexión',
        path: ['path'],
      });
    }
    if (data.ipAddress !== undefined && data.ipAddress !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La IP debe estar vacía para este tipo de conexión',
        path: ['ipAddress'],
      });
    }
    if (data.port !== undefined && data.port !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El puerto debe estar vacío para este tipo de conexión',
        path: ['port'],
      });
    }
  }
};
export const createThermalPrinterDtoSchema =
  thermalPrinterDtoObjectSchema.superRefine(refinePrinterDto);
export type CreateThermalPrinterDto = z.infer<
  typeof createThermalPrinterDtoSchema
>;
export const updateThermalPrinterDtoSchema = thermalPrinterDtoObjectSchema
  .partial()
  .superRefine(refinePrinterDto);
export type UpdateThermalPrinterDto = z.infer<
  typeof updateThermalPrinterDtoSchema
>;
export const findAllThermalPrintersFilterSchema = baseListQuerySchema.extend({
  name: z.string().optional(),
  connectionType: PrinterConnectionTypeSchema.optional(),
  isActive: z.boolean().optional(),
});
export type FindAllThermalPrintersDto = z.infer<
  typeof findAllThermalPrintersFilterSchema
>;
export const printerFormSchema = createThermalPrinterDtoSchema;
export type PrinterFormData = z.input<typeof printerFormSchema>;
export const discoveredPrinterSchema = z.object({
  ip: z.string().ip({ version: 'v4' }),
  port: z.number().int().positive(),
  name: z.string().optional(),
  model: z.string().optional(),
  type: z.string(),
  mac: z.string().regex(macRegex, 'MAC inválida').optional(),
});
export type DiscoveredPrinter = z.infer<typeof discoveredPrinterSchema>;

================
File: app/src/modules/receipts/hooks/useReceiptsQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import {
  receiptService,
  receiptQueryOptions,
} from '../services/receiptService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
export const useReceipts = (filters?: {
  startDate?: string;
  endDate?: string;
  orderType?: string;
}) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const query = useQuery({
    ...receiptQueryOptions.receipts(filters || {}),
  });
  if (query.error) {
    showSnackbar({
      message: query.error.message || 'Error al cargar los recibos',
      type: 'error',
    });
  }
  return query;
};
export const useReceipt = (id: string) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const query = useQuery({
    ...receiptQueryOptions.receipt(id),
  });
  if (query.error) {
    showSnackbar({
      message: query.error.message || 'Error al cargar el recibo',
      type: 'error',
    });
  }
  return query;
};
export const useRecoverOrder = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation({
    mutationFn: (orderId: string) => receiptService.recoverOrder(orderId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['receipts'] });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Orden recuperada exitosamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al recuperar la orden',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/restaurantConfig/components/BusinessHoursForm.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Switch, Chip, Card } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import {
  BusinessHours,
  CreateBusinessHoursDto,
} from '../types/restaurantConfig.types';
interface BusinessHoursFormProps {
  businessHours: BusinessHours[] | CreateBusinessHoursDto[];
  isEditing: boolean;
  onChange: (businessHours: CreateBusinessHoursDto[]) => void;
}
const DAYS_OF_WEEK = [
  'Domingo',
  'Lunes',
  'Martes',
  'Miércoles',
  'Jueves',
  'Viernes',
  'Sábado',
];
const BusinessHoursForm: React.FC<BusinessHoursFormProps> = ({
  businessHours,
  isEditing,
  onChange,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const [showTimePicker, setShowTimePicker] = React.useState(false);
  const [currentPickerConfig, setCurrentPickerConfig] = React.useState<{
    dayIndex: number;
    type: 'opening' | 'closing';
    currentDate: Date;
  } | null>(null);
  const initializedHours = React.useMemo(() => {
    if (businessHours.length === 0) {
      return DAYS_OF_WEEK.map((_, index) => ({
        dayOfWeek: index,
        openingTime: '09:00',
        closingTime: '22:00',
        isClosed: false,
        closesNextDay: false,
      }));
    }
    return businessHours.map((hour) => {
      if (hour.openingTime && hour.closingTime && !hour.isClosed) {
        const [openHour, openMin] = hour.openingTime.split(':').map(Number);
        const [closeHour, closeMin] = hour.closingTime.split(':').map(Number);
        const closesNextDay =
          closeHour < openHour ||
          (closeHour === openHour && closeMin < openMin);
        return { ...hour, closesNextDay };
      }
      return { ...hour, closesNextDay: false };
    });
  }, [businessHours]);
  const checkScheduleConflict = (dayIndex: number): string | null => {
    const currentDay = initializedHours.find((h) => h.dayOfWeek === dayIndex);
    if (!currentDay || currentDay.isClosed || !currentDay.openingTime) {
      return null;
    }
    const previousDayIndex = dayIndex === 0 ? 6 : dayIndex - 1;
    const previousDay = initializedHours.find(
      (h) => h.dayOfWeek === previousDayIndex,
    );
    if (
      !previousDay ||
      previousDay.isClosed ||
      !previousDay.closesNextDay ||
      !previousDay.closingTime
    ) {
      return null;
    }
    const [currentOpenHour, currentOpenMin] = currentDay.openingTime
      .split(':')
      .map(Number);
    const [prevCloseHour, prevCloseMin] = previousDay.closingTime
      .split(':')
      .map(Number);
    const currentOpenMinutes = currentOpenHour * 60 + currentOpenMin;
    const prevCloseMinutes = prevCloseHour * 60 + prevCloseMin;
    if (currentOpenMinutes <= prevCloseMinutes) {
      return `Conflicto: ${DAYS_OF_WEEK[previousDayIndex]} cierra a las ${previousDay.closingTime}. Debe haber al menos 1 minuto de diferencia`;
    }
    return null;
  };
  const handleTimeChange = (
    dayIndex: number,
    type: 'opening' | 'closing',
    time: string | null,
  ) => {
    if (!onChange || !isEditing) return;
    const updatedHours = [...initializedHours];
    const hourIndex = updatedHours.findIndex((h) => h.dayOfWeek === dayIndex);
    if (hourIndex !== -1 && time !== null) {
      if (type === 'opening') {
        updatedHours[hourIndex].openingTime = time;
      } else {
        updatedHours[hourIndex].closingTime = time;
      }
      const hour = updatedHours[hourIndex];
      if (hour.openingTime && hour.closingTime) {
        const [openHour, openMin] = hour.openingTime.split(':').map(Number);
        const [closeHour, closeMin] = hour.closingTime.split(':').map(Number);
        hour.closesNextDay =
          closeHour < openHour ||
          (closeHour === openHour && closeMin < openMin);
      } else {
        hour.closesNextDay = false;
      }
      onChange(updatedHours as CreateBusinessHoursDto[]);
    }
  };
  const handleClosedChange = (dayIndex: number, isClosed: boolean) => {
    if (!onChange || !isEditing) return;
    const updatedHours = [...initializedHours];
    const hourIndex = updatedHours.findIndex((h) => h.dayOfWeek === dayIndex);
    if (hourIndex !== -1) {
      updatedHours[hourIndex].isClosed = isClosed;
      if (isClosed) {
        updatedHours[hourIndex].openingTime = null;
        updatedHours[hourIndex].closingTime = null;
      }
      onChange(updatedHours as CreateBusinessHoursDto[]);
    }
  };
  const formatTimeForDisplay = (
    timeString: string | null | undefined,
  ): string => {
    if (!timeString) return '';
    // Si el string tiene segundos (formato HH:MM:SS), mostrar solo HH:MM
    if (timeString.length > 5) {
      return timeString.substring(0, 5);
    }
    return timeString;
  };
  const openTimePicker = (dayIndex: number, type: 'opening' | 'closing') => {
    if (!isEditing) return;
    const dayHours = initializedHours.find((h) => h.dayOfWeek === dayIndex);
    const currentTimeString =
      dayHours?.[type === 'opening' ? 'openingTime' : 'closingTime'];
    const date = new Date();
    if (currentTimeString) {
      const [hours, minutes] = currentTimeString.split(':').map(Number);
      date.setHours(hours, minutes, 0, 0);
    } else {
      date.setHours(type === 'opening' ? 9 : 22, 0, 0, 0);
    }
    setCurrentPickerConfig({ dayIndex, type, currentDate: date });
    setShowTimePicker(true);
  };
  const handleTimeConfirm = (date: Date) => {
    setShowTimePicker(false);
    if (currentPickerConfig && onChange) {
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const timeString = `${hours}:${minutes}`;
      handleTimeChange(
        currentPickerConfig.dayIndex,
        currentPickerConfig.type,
        timeString,
      );
    }
    setCurrentPickerConfig(null);
  };
  const handleTimeCancel = () => {
    setShowTimePicker(false);
    setCurrentPickerConfig(null);
  };
  return (
    <>
      <View style={styles.container}>
        {DAYS_OF_WEEK.map((day, index) => {
          const dayHours = initializedHours.find(
            (h) => h.dayOfWeek === index,
          ) || {
            dayOfWeek: index,
            openingTime: null,
            closingTime: null,
            isClosed: false,
          };
          return (
            <Card key={index} style={styles.dayCard} mode="elevated">
              <View style={styles.dayHeader}>
                <Text style={styles.dayName}>{day}</Text>
                <View style={styles.dayActions}>
                  <Switch
                    value={!dayHours.isClosed}
                    onValueChange={(value) => {
                      if (isEditing && onChange) {
                        handleClosedChange(index, !value);
                      }
                    }}
                    disabled={!isEditing}
                    color={theme.colors.primary}
                  />
                </View>
              </View>
              {!dayHours.isClosed ? (
                <View style={styles.timeContainer}>
                  <TouchableOpacity
                    style={[
                      styles.timeButton,
                      !isEditing && styles.timeButtonDisabled,
                    ]}
                    onPress={() =>
                      isEditing && openTimePicker(index, 'opening')
                    }
                    disabled={!isEditing}
                  >
                    <View style={styles.timeButtonContent}>
                      <MaterialCommunityIcons
                        name="clock-outline"
                        size={20}
                        color={
                          !isEditing
                            ? theme.colors.onSurfaceDisabled
                            : theme.colors.primary
                        }
                      />
                      <View style={styles.timeTextContainer}>
                        <Text
                          style={[
                            styles.timeLabel,
                            !isEditing && styles.timeLabelDisabled,
                          ]}
                        >
                          Apertura
                        </Text>
                        <Text
                          style={[
                            styles.timeValue,
                            !isEditing && styles.timeValueDisabled,
                          ]}
                        >
                          {formatTimeForDisplay(dayHours.openingTime) ||
                            '--:--'}
                        </Text>
                      </View>
                    </View>
                  </TouchableOpacity>
                  <MaterialCommunityIcons
                    name="arrow-right"
                    size={24}
                    color={
                      !isEditing
                        ? theme.colors.onSurfaceDisabled
                        : theme.colors.onSurfaceVariant
                    }
                    style={styles.arrow}
                  />
                  <TouchableOpacity
                    style={[
                      styles.timeButton,
                      !isEditing && styles.timeButtonDisabled,
                    ]}
                    onPress={() =>
                      isEditing && openTimePicker(index, 'closing')
                    }
                    disabled={!isEditing}
                  >
                    <View style={styles.timeButtonContent}>
                      <MaterialCommunityIcons
                        name="clock-check-outline"
                        size={20}
                        color={
                          !isEditing
                            ? theme.colors.onSurfaceDisabled
                            : theme.colors.primary
                        }
                      />
                      <View style={styles.timeTextContainer}>
                        <Text
                          style={[
                            styles.timeLabel,
                            !isEditing && styles.timeLabelDisabled,
                          ]}
                        >
                          Cierre
                        </Text>
                        <Text
                          style={[
                            styles.timeValue,
                            !isEditing && styles.timeValueDisabled,
                          ]}
                        >
                          {formatTimeForDisplay(dayHours.closingTime) ||
                            '--:--'}
                        </Text>
                      </View>
                      {dayHours.closesNextDay && (
                        <View style={styles.nextDayBadge}>
                          <MaterialCommunityIcons
                            name="moon-waning-crescent"
                            size={12}
                            color={theme.colors.onPrimaryContainer}
                          />
                        </View>
                      )}
                    </View>
                  </TouchableOpacity>
                </View>
              ) : (
                <View style={styles.closedContainer}>
                  <Chip
                    icon="store-off"
                    mode="flat"
                    style={styles.closedChip}
                    textStyle={styles.closedChipText}
                  >
                    Cerrado
                  </Chip>
                </View>
              )}
              {}
              {(() => {
                const conflict = checkScheduleConflict(index);
                if (conflict && !dayHours.isClosed) {
                  return (
                    <View style={styles.conflictWarning}>
                      <MaterialCommunityIcons
                        name="alert-circle"
                        size={16}
                        color={theme.colors.error}
                      />
                      <Text style={styles.conflictText}>{conflict}</Text>
                    </View>
                  );
                }
                return null;
              })()}
            </Card>
          );
        })}
      </View>
      <DateTimePickerSafe
        visible={showTimePicker}
        mode="time"
        value={currentPickerConfig?.currentDate || new Date()}
        onConfirm={handleTimeConfirm}
        onCancel={handleTimeCancel}
        minuteInterval={1}
        title={
          currentPickerConfig?.type === 'opening'
            ? `${DAYS_OF_WEEK[currentPickerConfig.dayIndex || 0]} - Apertura`
            : currentPickerConfig?.type === 'closing'
              ? `${DAYS_OF_WEEK[currentPickerConfig.dayIndex || 0]} - Cierre`
              : 'Seleccionar Hora'
        }
        allowManualInput={true}
      />
    </>
  );
};
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      gap: theme.spacing.s,
    },
    dayCard: {
      marginBottom: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      overflow: 'hidden',
      padding: theme.spacing.m,
    },
    dayHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    dayName: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    dayActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    copyButton: {
      margin: 0,
    },
    timeContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    timeButton: {
      flex: 1,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 12,
      padding: theme.spacing.m,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      overflow: 'visible',
    },
    timeButtonDisabled: {
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.surfaceVariant,
    },
    timeButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      position: 'relative',
    },
    timeTextContainer: {
      flex: 1,
    },
    timeLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    timeLabelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    timeValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    timeValueDisabled: {
      color: theme.colors.onSurfaceDisabled,
      fontWeight: '500',
    },
    arrow: {
      marginHorizontal: theme.spacing.xs,
    },
    closedContainer: {
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    closedChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    closedChipText: {
      fontSize: 12,
      color: theme.colors.onErrorContainer,
    },
    nextDayBadge: {
      position: 'absolute',
      top: -4,
      right: -4,
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: 10,
      width: 20,
      height: 20,
      justifyContent: 'center',
      alignItems: 'center',
      borderWidth: 2,
      borderColor: theme.colors.surface,
    },
    conflictWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.errorContainer,
      padding: theme.spacing.s,
      marginTop: theme.spacing.s,
      borderRadius: 8,
      gap: theme.spacing.xs,
    },
    conflictText: {
      flex: 1,
      fontSize: 12,
      color: theme.colors.onErrorContainer,
      lineHeight: 16,
    },
  });
export default BusinessHoursForm;

================
File: app/src/modules/restaurantConfig/components/TimeZoneSelector.tsx
================
import React, { useState, useMemo } from 'react';
import { View, StyleSheet, TouchableOpacity, FlatList } from 'react-native';
import {
  Text,
  Portal,
  Modal,
  Searchbar,
  List,
  Divider,
  Surface,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
interface TimeZoneSelectorProps {
  value: string;
  onChange: (timezone: string) => void;
  disabled?: boolean;
}
const TIMEZONES = [
  { value: 'America/Mexico_City', label: 'Ciudad de México', offset: 'UTC-6' },
  { value: 'America/Tijuana', label: 'Tijuana', offset: 'UTC-8' },
  { value: 'America/Cancun', label: 'Cancún', offset: 'UTC-5' },
  { value: 'America/Hermosillo', label: 'Hermosillo', offset: 'UTC-7' },
  { value: 'America/Monterrey', label: 'Monterrey', offset: 'UTC-6' },
  { value: 'America/Mazatlan', label: 'Mazatlán', offset: 'UTC-7' },
  { value: 'America/Chihuahua', label: 'Chihuahua', offset: 'UTC-7' },
  { value: 'America/New_York', label: 'Nueva York', offset: 'UTC-5' },
  { value: 'America/Chicago', label: 'Chicago', offset: 'UTC-6' },
  { value: 'America/Denver', label: 'Denver', offset: 'UTC-7' },
  { value: 'America/Los_Angeles', label: 'Los Ángeles', offset: 'UTC-8' },
  { value: 'America/Phoenix', label: 'Phoenix', offset: 'UTC-7' },
  { value: 'America/Guatemala', label: 'Guatemala', offset: 'UTC-6' },
  { value: 'America/El_Salvador', label: 'El Salvador', offset: 'UTC-6' },
  { value: 'America/Tegucigalpa', label: 'Honduras', offset: 'UTC-6' },
  { value: 'America/Managua', label: 'Nicaragua', offset: 'UTC-6' },
  { value: 'America/Costa_Rica', label: 'Costa Rica', offset: 'UTC-6' },
  { value: 'America/Panama', label: 'Panamá', offset: 'UTC-5' },
  { value: 'America/Bogota', label: 'Bogotá', offset: 'UTC-5' },
  { value: 'America/Lima', label: 'Lima', offset: 'UTC-5' },
  { value: 'America/Quito', label: 'Quito', offset: 'UTC-5' },
  { value: 'America/Caracas', label: 'Caracas', offset: 'UTC-4' },
  { value: 'America/La_Paz', label: 'La Paz', offset: 'UTC-4' },
  { value: 'America/Santiago', label: 'Santiago', offset: 'UTC-3' },
  { value: 'America/Buenos_Aires', label: 'Buenos Aires', offset: 'UTC-3' },
  { value: 'America/Sao_Paulo', label: 'São Paulo', offset: 'UTC-3' },
  { value: 'America/Montevideo', label: 'Montevideo', offset: 'UTC-3' },
  { value: 'America/Asuncion', label: 'Asunción', offset: 'UTC-3' },
  { value: 'America/Havana', label: 'La Habana', offset: 'UTC-5' },
  { value: 'America/Santo_Domingo', label: 'Santo Domingo', offset: 'UTC-4' },
  { value: 'America/Puerto_Rico', label: 'Puerto Rico', offset: 'UTC-4' },
];
const TimeZoneSelector: React.FC<TimeZoneSelectorProps> = ({
  value,
  onChange,
  disabled = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const [visible, setVisible] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const selectedTimeZone = useMemo(
    () => TIMEZONES.find((tz) => tz.value === value) || TIMEZONES[0],
    [value],
  );
  const filteredTimeZones = useMemo(() => {
    if (!searchQuery.trim()) return TIMEZONES;
    const query = searchQuery.toLowerCase();
    return TIMEZONES.filter(
      (tz) =>
        tz.label.toLowerCase().includes(query) ||
        tz.value.toLowerCase().includes(query) ||
        tz.offset.toLowerCase().includes(query),
    );
  }, [searchQuery]);
  const handleSelect = (timezone: string) => {
    onChange(timezone);
    setVisible(false);
    setSearchQuery('');
  };
  const renderTimeZoneItem = ({ item }: { item: (typeof TIMEZONES)[0] }) => (
    <>
      <List.Item
        title={item.label}
        description={`${item.value} (${item.offset})`}
        onPress={() => handleSelect(item.value)}
        left={(props) => <List.Icon {...props} icon="clock-outline" />}
        right={(props) =>
          item.value === value ? (
            <List.Icon {...props} icon="check" color={theme.colors.primary} />
          ) : null
        }
        style={[styles.listItem, item.value === value && styles.selectedItem]}
        titleStyle={[
          styles.listItemTitle,
          item.value === value && styles.selectedItemText,
        ]}
        descriptionStyle={styles.listItemDescription}
      />
      <Divider />
    </>
  );
  return (
    <>
      <TouchableOpacity
        style={[styles.selector, disabled && styles.selectorDisabled]}
        onPress={() => !disabled && setVisible(true)}
        disabled={disabled}
      >
        <View style={styles.selectorContent}>
          <MaterialCommunityIcons
            name="earth"
            size={24}
            color={
              disabled ? theme.colors.onSurfaceDisabled : theme.colors.primary
            }
          />
          <View style={styles.textContainer}>
            <Text style={[styles.label, disabled && styles.labelDisabled]}>
              Zona Horaria
            </Text>
            <Text style={[styles.value, disabled && styles.valueDisabled]}>
              {selectedTimeZone.label}
            </Text>
            <Text style={[styles.offset, disabled && styles.offsetDisabled]}>
              {selectedTimeZone.offset}
            </Text>
          </View>
          <MaterialCommunityIcons
            name="chevron-down"
            size={24}
            color={
              disabled
                ? theme.colors.onSurfaceDisabled
                : theme.colors.onSurfaceVariant
            }
          />
        </View>
      </TouchableOpacity>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={() => {
            setVisible(false);
            setSearchQuery('');
          }}
          contentContainerStyle={styles.modal}
        >
          <Surface style={styles.modalContent} elevation={3}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Seleccionar Zona Horaria</Text>
              <IconButton
                icon="close"
                size={24}
                onPress={() => {
                  setVisible(false);
                  setSearchQuery('');
                }}
              />
            </View>
            <Searchbar
              placeholder="Buscar zona horaria..."
              onChangeText={setSearchQuery}
              value={searchQuery}
              style={styles.searchbar}
              inputStyle={styles.searchbarInput}
              icon="magnify"
              clearIcon="close"
            />
            <FlatList
              data={filteredTimeZones}
              renderItem={renderTimeZoneItem}
              keyExtractor={(item) => item.value}
              style={styles.list}
              contentContainerStyle={styles.listContent}
              showsVerticalScrollIndicator={true}
              ListEmptyComponent={
                <View style={styles.emptyContainer}>
                  <MaterialCommunityIcons
                    name="magnify-close"
                    size={48}
                    color={theme.colors.onSurfaceVariant}
                  />
                  <Text style={styles.emptyText}>
                    No se encontraron zonas horarias
                  </Text>
                </View>
              }
            />
          </Surface>
        </Modal>
      </Portal>
    </>
  );
};
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    selector: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 12,
      padding: theme.spacing.m,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    selectorDisabled: {
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.surfaceVariant,
    },
    selectorContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    textContainer: {
      flex: 1,
    },
    label: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    labelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    value: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    valueDisabled: {
      color: theme.colors.onSurfaceDisabled,
      fontWeight: '500',
    },
    offset: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    offsetDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    modal: {
      margin: theme.spacing.l,
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: 16,
      maxHeight: '80%',
      backgroundColor: theme.colors.surface,
    },
    modalHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: theme.spacing.l,
      paddingTop: theme.spacing.l,
      paddingBottom: theme.spacing.s,
    },
    modalTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    searchbar: {
      marginHorizontal: theme.spacing.l,
      marginBottom: theme.spacing.m,
      elevation: 0,
      backgroundColor: theme.colors.surfaceVariant,
    },
    searchbarInput: {
      fontSize: 14,
    },
    list: {
      maxHeight: 400,
    },
    listContent: {
      paddingBottom: theme.spacing.m,
    },
    listItem: {
      paddingHorizontal: theme.spacing.l,
    },
    selectedItem: {
      backgroundColor: theme.colors.primaryContainer,
    },
    listItemTitle: {
      fontSize: 16,
      color: theme.colors.onSurface,
    },
    selectedItemText: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    listItemDescription: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    emptyContainer: {
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl * 2,
    },
    emptyText: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.m,
    },
  });
export default TimeZoneSelector;

================
File: app/src/modules/settings/navigation/SettingsStackNavigator.tsx
================
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { ServerSettingsScreen } from '../screens/ServerSettingsScreen';
import { getDefaultScreenOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';
import type { SettingsStackParamList } from './types';
const Stack = createStackNavigator<SettingsStackParamList>();
export function SettingsStackNavigator() {
  const theme = useAppTheme();
  return (
    <Stack.Navigator
      screenOptions={{
        ...getDefaultScreenOptions(theme),
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="ServerSettings"
        component={ServerSettingsScreen}
        options={{
          title: 'Configuración del Servidor',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/settings/navigation/types.ts
================
export type SettingsStackParamList = {
  ServerSettings: undefined;
};

================
File: app/src/modules/settings/screens/ServerSettingsScreen.tsx
================
import React, { useEffect, useState } from 'react';
import {
  ScrollView,
  View,
  StyleSheet,
  ActivityIndicator,
  Platform,
} from 'react-native';
import {
  Text,
  Card,
  RadioButton,
  TextInput,
  Button,
  HelperText,
  Portal,
  Dialog,
  Paragraph,
  IconButton,
  Chip,
  Surface,
  Icon,
  TouchableRipple,
  ProgressBar,
} from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import { useSnackbar } from '@/hooks/useSnackbar';
import {
  serverConnectionService,
  ConnectionMode,
} from '@/services/serverConnectionService';
import { discoveryService } from '@/app/services/discoveryService';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useServerConnection } from '@/app/hooks/useServerConnection';
import axios from 'axios';
const STORAGE_KEYS = {
  CONNECTION_MODE: 'connection_mode',
  MANUAL_URL: 'manual_server_url',
};
export function ServerSettingsScreen() {
  const navigation = useNavigation();
  const { showSnackbar } = useSnackbar();
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { isConnected, isHealthy, serverUrl, isSearching } =
    useServerConnection();
  const [mode, setMode] = useState<ConnectionMode>('auto');
  const [manualUrl, setManualUrl] = useState('');
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [showInfo, setShowInfo] = useState(false);
  const [isDiscovering, setIsDiscovering] = useState(false);
  const [discoveryProgress, setDiscoveryProgress] = useState({
    current: 0,
    total: 0,
    message: '',
  });
  useEffect(() => {
    loadSettings();
  }, []);
  useEffect(() => {
    // Actualizar el campo manual cuando cambie serverUrl
    if (serverUrl && !loading) {
      try {
        const url = new URL(serverUrl);
        setManualUrl(url.hostname);
      } catch {
        // Si no es una URL válida, intentar extraer la IP
        const cleanUrl = serverUrl.replace(/^https?:\/\//, '').split(':')[0];
        setManualUrl(cleanUrl);
      }
    }
  }, [serverUrl, loading]);
  const loadSettings = async () => {
    try {
      const [savedMode, savedUrl] = await Promise.all([
        EncryptedStorage.getItem(
          STORAGE_KEYS.CONNECTION_MODE,
        ) as Promise<ConnectionMode>,
        EncryptedStorage.getItem(STORAGE_KEYS.MANUAL_URL),
      ]);
      if (savedMode) setMode(savedMode);
      // Si hay una URL de servidor actual (de cualquier fuente), usarla para el campo manual
      if (serverUrl) {
        try {
          const url = new URL(serverUrl);
          setManualUrl(url.hostname);
        } catch {
          // Si no es una URL válida, intentar extraer la IP
          const cleanUrl = serverUrl.replace(/^https?:\/\//, '').split(':')[0];
          setManualUrl(cleanUrl);
        }
      } else if (savedUrl) {
        // Si no hay servidor actual pero sí una URL manual guardada, usarla
        try {
          const url = new URL(savedUrl);
          setManualUrl(url.hostname);
        } catch {
          // Si no es una URL válida, usar como está
          setManualUrl(savedUrl);
        }
      }
    } catch (error) {
    } finally {
      setLoading(false);
    }
  };
  const validateUrl = (url: string): boolean => {
    // Validar que sea una IP válida o un dominio
    const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const domainRegex =
      /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9](?:\.[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])*$/;
    // Quitar espacios
    const trimmed = url.trim();
    // No debe incluir protocolo ni puerto
    if (
      trimmed.includes('http:
      trimmed.includes('https://') ||
      trimmed.includes(':')
    ) {
      return false;
    }
    return ipRegex.test(trimmed) || domainRegex.test(trimmed);
  };
  const saveSettings = async () => {
    setSaving(true);
    try {
      if (mode === 'manual') {
        if (!validateUrl(manualUrl)) {
          showSnackbar('Por favor ingresa una URL válida', 'error');
          setSaving(false);
          return;
        }
      }
      await EncryptedStorage.setItem(STORAGE_KEYS.CONNECTION_MODE, mode);
      if (mode === 'manual') {
        const fullUrl = `http://${manualUrl.trim()}:3737`;
        await EncryptedStorage.setItem(STORAGE_KEYS.MANUAL_URL, fullUrl);
      }
      let urlToCheck: string | null = null;
      if (mode === 'manual') {
        const fullUrl = `http://${manualUrl.trim()}:3737`;
        await discoveryService.setServerUrl(fullUrl, true);
        urlToCheck = fullUrl;
      } else if (mode === 'auto') {
        await discoveryService.setServerUrl(null, true);
      }
      await serverConnectionService.setConnectionMode(mode);
      if (mode === 'auto') {
        setIsDiscovering(true);
        showSnackbar('Iniciando búsqueda de servidor...', 'info');
        try {
          await discoveryService.setServerUrl(null, true);
          discoveryService.setProgressCallback((progress) => {
            setDiscoveryProgress(progress);
          });
          const discoveredUrl = await discoveryService.discoverServer();
          if (discoveredUrl) {
            showSnackbar('Servidor encontrado ✓', 'success');
            const { healthMonitoringService } = await import(
              '@/services/healthMonitoringService'
            );
            healthMonitoringService.startMonitoring();
          } else {
            showSnackbar('No se encontró servidor en la red', 'error');
          }
        } catch (error) {
          showSnackbar('Error al buscar servidor', 'error');
        } finally {
          setIsDiscovering(false);
          discoveryService.setProgressCallback(null);
          setDiscoveryProgress({ current: 0, total: 0, message: '' });
        }
      } else {
        // Para manual, hacer reconnect para aplicar la nueva configuración
        showSnackbar('Aplicando configuración...', 'info');
        try {
          await serverConnectionService.reconnect();
          showSnackbar('Configuración guardada - Conectado ✓', 'success');
        } catch (error) {
          showSnackbar('Verificando conexión...', 'info');
          const { healthMonitoringService } = await import(
            '@/services/healthMonitoringService'
          );
          try {
            const isHealthy = await healthMonitoringService.forceCheck();
            if (isHealthy) {
              showSnackbar(
                'Configuración guardada - Servidor accesible ✓',
                'success',
              );
              healthMonitoringService.startMonitoring();
            } else {
              showSnackbar(
                'Configuración guardada - El servidor no responde ✗',
                'warning',
              );
            }
          } catch (error) {
            showSnackbar(
              'Configuración guardada - Error al verificar servidor',
              'warning',
            );
          }
        }
      }
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al guardar la configuración',
        'error',
      );
    } finally {
      setSaving(false);
    }
  };
  const renderConnectionStatus = () => {
    let chipIcon = 'alert-circle';
    let chipText = 'Sin conexión';
    let chipColor = theme.colors.error;
    let chipBgColor = theme.dark
      ? 'rgba(244, 67, 54, 0.2)'
      : 'rgba(244, 67, 54, 0.1)';
    if (isSearching) {
      chipIcon = 'wifi-sync';
      chipText = 'Buscando...';
      chipColor = theme.colors.warning || '#FF9800';
      chipBgColor = theme.dark
        ? 'rgba(255, 152, 0, 0.2)'
        : 'rgba(255, 152, 0, 0.1)';
    } else if (isConnected && isHealthy) {
      chipIcon = 'check-circle';
      chipText = 'Conectado';
      chipColor = theme.colors.success || '#4CAF50';
      chipBgColor = theme.dark
        ? 'rgba(76, 175, 80, 0.2)'
        : 'rgba(76, 175, 80, 0.1)';
    }
    return (
      <Chip
        icon={chipIcon}
        mode="flat"
        compact
        style={{
          backgroundColor: chipBgColor,
          transform: [{ scale: 0.85 }],
        }}
        textStyle={{ color: chipColor, fontSize: 12 }}
      >
        {chipText}
      </Chip>
    );
  };
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }
  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.scrollContent}
    >
      {}
      <View style={styles.section}>
        <View style={styles.sectionHeader}>
          <Text style={styles.sectionTitle}>Estado de Conexión</Text>
          {renderConnectionStatus()}
          <View style={{ flex: 1 }} />
          <IconButton
            icon="information"
            size={20}
            onPress={() => setShowInfo(true)}
            iconColor={theme.colors.onSurfaceVariant}
          />
        </View>
        <View>
          <Surface style={styles.infoCard} elevation={0}>
            <View style={styles.infoRow}>
              <View style={styles.infoItem}>
                <Icon
                  source="server"
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
                <View style={styles.infoContent}>
                  <Text variant="labelSmall" style={styles.infoLabel}>
                    Servidor
                  </Text>
                  <Text variant="bodyMedium" style={styles.infoValue}>
                    {serverUrl
                      ? serverUrl.replace(/^https?:\/\//, '').split(':')[0]
                      : '-'}
                  </Text>
                </View>
              </View>
              <View style={styles.infoDivider} />
              <View style={styles.infoItem}>
                <Icon
                  source="ethernet-cable"
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
                <View style={styles.infoContent}>
                  <Text variant="labelSmall" style={styles.infoLabel}>
                    Puerto
                  </Text>
                  <Text variant="bodyMedium" style={styles.infoValue}>
                    {serverUrl
                      ? serverUrl.split(':').pop()?.split('/')[0] || '3737'
                      : '3737'}
                  </Text>
                </View>
              </View>
            </View>
            {serverUrl && !isHealthy && isConnected && (
              <View style={styles.healthWarning}>
                <Icon
                  source="alert"
                  size={16}
                  color={theme.colors.warning || '#FF9800'}
                />
                <Text variant="labelSmall" style={styles.healthWarningText}>
                  El servidor no responde correctamente
                </Text>
              </View>
            )}
          </Surface>
        </View>
      </View>
      {}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Modo de Conexión</Text>
        <RadioButton.Group
          onValueChange={(value) => setMode(value as ConnectionMode)}
          value={mode}
        >
          <TouchableRipple
            onPress={() => setMode('auto')}
            style={[
              styles.radioOption,
              mode === 'auto' && styles.radioOptionActive,
            ]}
            rippleColor={`${theme.colors.primary}20`}
          >
            <View style={styles.radioContent}>
              <Icon
                source="wifi"
                size={24}
                color={
                  mode === 'auto'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              <View style={styles.radioTextContainer}>
                <Text
                  variant="titleMedium"
                  style={[
                    styles.radioTitle,
                    mode === 'auto' && { color: theme.colors.primary },
                  ]}
                >
                  Automático
                </Text>
                <Text variant="bodySmall" style={styles.radioSubtitle}>
                  Busca el servidor en tu red local
                </Text>
              </View>
              <RadioButton
                value="auto"
                status={mode === 'auto' ? 'checked' : 'unchecked'}
              />
            </View>
          </TouchableRipple>
          <TouchableRipple
            onPress={() => setMode('manual')}
            style={[
              styles.radioOption,
              mode === 'manual' && styles.radioOptionActive,
              { marginBottom: 0 },
            ]}
            rippleColor={`${theme.colors.primary}20`}
          >
            <View>
              <View style={styles.radioContent}>
                <Icon
                  source="pencil-outline"
                  size={24}
                  color={
                    mode === 'manual'
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
                <View style={styles.radioTextContainer}>
                  <Text
                    variant="titleMedium"
                    style={[
                      styles.radioTitle,
                      mode === 'manual' && { color: theme.colors.primary },
                    ]}
                  >
                    Manual
                  </Text>
                  <Text variant="bodySmall" style={styles.radioSubtitle}>
                    Especifica la URL del servidor
                  </Text>
                </View>
                <RadioButton
                  value="manual"
                  status={mode === 'manual' ? 'checked' : 'unchecked'}
                />
              </View>
              {mode === 'manual' && (
                <View style={styles.manualInputContainer}>
                  <TextInput
                    label="Dirección IP o Dominio"
                    value={manualUrl}
                    onChangeText={setManualUrl}
                    placeholder="192.168.1.100"
                    mode="outlined"
                    autoCapitalize="none"
                    autoCorrect={false}
                    keyboardType="default"
                    error={manualUrl !== '' && !validateUrl(manualUrl)}
                    outlineColor={theme.colors.outline}
                    activeOutlineColor={theme.colors.primary}
                    style={styles.manualInput}
                  />
                  <HelperText
                    type={
                      manualUrl !== '' && !validateUrl(manualUrl)
                        ? 'error'
                        : 'info'
                    }
                    visible={true}
                  >
                    {manualUrl !== '' && !validateUrl(manualUrl)
                      ? 'Ingresa solo la IP (ej: 192.168.1.100) sin http:
                      : 'Solo la dirección IP sin protocolo. El puerto 3737 se añadirá automáticamente.'}
                  </HelperText>
                </View>
              )}
            </View>
          </TouchableRipple>
        </RadioButton.Group>
      </View>
      {}
      {isDiscovering && (
        <View style={styles.discoveryProgressContainer}>
          <Surface style={styles.discoveryProgressCard} elevation={1}>
            <View style={styles.discoveryHeader}>
              <Icon
                source="magnify-scan"
                size={24}
                color={theme.colors.primary}
              />
              <Text style={styles.discoveryTitle}>
                Buscando servidor en la red
              </Text>
            </View>
            <ProgressBar
              progress={
                discoveryProgress.total > 0
                  ? discoveryProgress.current / discoveryProgress.total
                  : 0
              }
              color={theme.colors.primary}
              style={styles.progressBar}
            />
            <Text style={styles.discoveryMessage}>
              {discoveryProgress.message || 'Iniciando búsqueda...'}
            </Text>
            {discoveryProgress.total > 0 && (
              <Text style={styles.discoveryStats}>
                {discoveryProgress.current} de {discoveryProgress.total} IPs
                escaneadas
              </Text>
            )}
          </Surface>
        </View>
      )}
      {}
      <View style={styles.actionButtons}>
        <Button
          mode="contained"
          onPress={saveSettings}
          loading={saving}
          disabled={saving || isDiscovering}
          icon="content-save"
          style={styles.saveButton}
          contentStyle={styles.buttonContent}
          labelStyle={styles.buttonLabel}
        >
          Guardar Configuración
        </Button>
      </View>
      <Portal>
        <Dialog visible={showInfo} onDismiss={() => setShowInfo(false)}>
          <Dialog.Title>Información de Conexión</Dialog.Title>
          <Dialog.Content>
            <Paragraph style={styles.infoParagraph}>
              <Text style={styles.boldText}>Modo Automático:</Text>
              {'\n'}Ideal para uso en el restaurante. La app busca el servidor
              en la red local.
            </Paragraph>
            <Paragraph style={styles.infoParagraph}>
              <Text style={styles.boldText}>Modo Manual:</Text>
              {'\n'}Configura manualmente la URL del servidor para casos
              especiales.
            </Paragraph>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowInfo(false)}>Cerrar</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </ScrollView>
  );
}
const createStyles = (theme: any, responsive: any) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: 40,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.background,
    },
    section: {
      marginHorizontal: 16,
      marginTop: 20,
      marginBottom: 16,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 16,
    },
    sectionTitle: {
      fontSize: responsive?.isWeb ? 20 : 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginRight: 12,
    },
    infoCard: {
      backgroundColor: theme.dark
        ? theme.colors.surfaceVariant
        : theme.colors.surface,
      borderRadius: 12,
      padding: 20,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-around',
    },
    infoItem: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
      gap: 8,
    },
    infoContent: {
      flex: 1,
    },
    infoLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
      fontSize: responsive?.isWeb ? 12 : 11,
    },
    infoValue: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      fontSize: responsive?.isWeb ? 16 : 14,
    },
    infoDivider: {
      width: 1,
      height: 40,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: 12,
    },
    healthWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 4,
      marginTop: 12,
      paddingTop: 12,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    healthWarningText: {
      color: theme.colors.warning || '#FF9800',
      flex: 1,
    },
    radioOption: {
      marginBottom: 12,
      borderRadius: 12,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      overflow: 'hidden',
    },
    radioOptionActive: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.dark
        ? 'rgba(103, 80, 164, 0.08)'
        : 'rgba(103, 80, 164, 0.05)',
    },
    radioContent: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: 16,
      gap: 12,
    },
    radioTextContainer: {
      flex: 1,
    },
    radioTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    radioSubtitle: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    radioDetails: {
      marginTop: 8,
      marginLeft: 48,
      marginRight: 16,
      marginBottom: 12,
      padding: 8,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 8,
    },
    radioDetailsText: {
      color: theme.colors.onSurfaceVariant,
      fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    },
    manualInputContainer: {
      paddingTop: 8,
      paddingHorizontal: 16,
      paddingBottom: 12,
    },
    manualInput: {
      backgroundColor: theme.colors.surface,
    },
    actionButtons: {
      marginHorizontal: 16,
      marginTop: 12,
      marginBottom: 20,
    },
    saveButton: {
      backgroundColor: theme.colors.primary,
    },
    buttonContent: {
      paddingVertical: 8,
    },
    buttonLabel: {
      fontSize: responsive?.isWeb ? 16 : 14,
    },
    infoParagraph: {
      marginBottom: 12,
      color: theme.colors.onSurfaceVariant,
      lineHeight: responsive?.isWeb ? 24 : 20,
    },
    boldText: {
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    discoveryProgressContainer: {
      marginHorizontal: 16,
      marginTop: 16,
      marginBottom: 8,
    },
    discoveryProgressCard: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      padding: 16,
      borderWidth: 1,
      borderColor: theme.colors.primary,
    },
    discoveryHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      marginBottom: 12,
    },
    discoveryTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    progressBar: {
      height: 6,
      borderRadius: 3,
      marginBottom: 12,
    },
    discoveryMessage: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
    },
    discoveryStats: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
  });

================
File: app/src/modules/shared/components/PrintTicketModal.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  TouchableOpacity,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  RadioButton,
  Button,
  Surface,
  IconButton,
  Divider,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { usePrintersQuery } from '@/modules/printers/hooks/usePrintersQueries';
interface OrderBasicInfo {
  shiftOrderNumber: number;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN' | 'TAKEOUT';
}
interface PrintTicketModalProps {
  visible: boolean;
  onDismiss: () => void;
  order: OrderBasicInfo | null;
  onPrint: (
    printerId: string,
    ticketType: 'GENERAL' | 'BILLING',
  ) => Promise<void>;
}
export const PrintTicketModal: React.FC<PrintTicketModalProps> = ({
  visible,
  onDismiss,
  order,
  onPrint,
}) => {
  const theme = useAppTheme();
  const { data: printersResponse, isLoading: isLoadingPrinters } =
    usePrintersQuery({ page: 1, limit: 100 });
  const [selectedTicketType, setSelectedTicketType] = useState<
    'GENERAL' | 'BILLING'
  >('GENERAL');
  const [selectedPrinterId, setSelectedPrinterId] = useState<string>('');
  const [isPrinting, setIsPrinting] = useState(false);
  // Extraer impresoras del response paginado y filtrar solo las activas
  const printers = printersResponse?.data || [];
  const activePrinters = printers.filter((printer) => printer.isActive);
  // Seleccionar la primera impresora activa por defecto
  useEffect(() => {
    if (activePrinters.length > 0 && !selectedPrinterId) {
      setSelectedPrinterId(activePrinters[0].id);
    }
  }, [activePrinters, selectedPrinterId]);
  // Seleccionar tipo de ticket según el tipo de orden
  useEffect(() => {
    if (order) {
      // Para órdenes DINE_IN, usar BILLING (ticket de cuenta)
      // Para TAKE_AWAY, TAKEOUT, DELIVERY, usar GENERAL
      if (order.orderType === 'DINE_IN') {
        setSelectedTicketType('BILLING');
      } else {
        setSelectedTicketType('GENERAL');
      }
    }
  }, [order]);
  const handlePrint = async () => {
    if (!selectedPrinterId || !order) return;
    setIsPrinting(true);
    try {
      await onPrint(selectedPrinterId, selectedTicketType);
      onDismiss();
    } catch (error) {
    } finally {
      setIsPrinting(false);
    }
  };
  if (!order) return null;
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContent,
          { backgroundColor: theme.colors.background },
        ]}
      >
        <View style={styles.header}>
          <Text style={[styles.title, { color: theme.colors.onSurface }]}>
            Imprimir Ticket - Orden #{order.shiftOrderNumber}
          </Text>
          <IconButton
            icon="close"
            size={24}
            onPress={onDismiss}
            style={styles.closeButton}
          />
        </View>
        <Divider />
        <ScrollView style={styles.content}>
          {}
          <View style={styles.section}>
            <Text
              style={[styles.sectionTitle, { color: theme.colors.primary }]}
            >
              Tipo de Ticket
            </Text>
            <RadioButton.Group
              onValueChange={(value) =>
                setSelectedTicketType(value as 'GENERAL' | 'BILLING')
              }
              value={selectedTicketType}
            >
              <TouchableOpacity
                activeOpacity={0.7}
                onPress={() => setSelectedTicketType('GENERAL')}
              >
                <Surface
                  style={[
                    styles.radioItem,
                    {
                      backgroundColor: theme.colors.surface,
                      borderColor:
                        selectedTicketType === 'GENERAL'
                          ? theme.colors.primary
                          : 'transparent',
                      borderWidth: selectedTicketType === 'GENERAL' ? 2 : 0,
                    },
                  ]}
                >
                  <View style={styles.radioContent}>
                    <RadioButton value="GENERAL" color={theme.colors.primary} />
                    <View style={styles.radioTextContainer}>
                      <Text
                        style={[
                          styles.radioLabel,
                          { color: theme.colors.onSurface },
                        ]}
                      >
                        📋 Ticket General
                      </Text>
                      <Text
                        style={[
                          styles.radioDescription,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        Para cocina y delivery (letras grandes)
                      </Text>
                    </View>
                  </View>
                </Surface>
              </TouchableOpacity>
              <TouchableOpacity
                activeOpacity={0.7}
                onPress={() => setSelectedTicketType('BILLING')}
              >
                <Surface
                  style={[
                    styles.radioItem,
                    {
                      backgroundColor: theme.colors.surface,
                      borderColor:
                        selectedTicketType === 'BILLING'
                          ? theme.colors.primary
                          : 'transparent',
                      borderWidth: selectedTicketType === 'BILLING' ? 2 : 0,
                    },
                  ]}
                >
                  <View style={styles.radioContent}>
                    <RadioButton value="BILLING" color={theme.colors.primary} />
                    <View style={styles.radioTextContainer}>
                      <Text
                        style={[
                          styles.radioLabel,
                          { color: theme.colors.onSurface },
                        ]}
                      >
                        💵 Ticket de Cuenta
                      </Text>
                      <Text
                        style={[
                          styles.radioDescription,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        Para cobro al cliente (formato cuenta)
                      </Text>
                    </View>
                  </View>
                </Surface>
              </TouchableOpacity>
            </RadioButton.Group>
          </View>
          {}
          <View style={styles.section}>
            <Text
              style={[styles.sectionTitle, { color: theme.colors.primary }]}
            >
              Seleccionar Impresora
            </Text>
            {isLoadingPrinters ? (
              <ActivityIndicator size="small" color={theme.colors.primary} />
            ) : activePrinters.length === 0 ? (
              <Text
                style={[styles.noPrintersText, { color: theme.colors.error }]}
              >
                No hay impresoras activas disponibles
              </Text>
            ) : (
              <RadioButton.Group
                onValueChange={(value) => setSelectedPrinterId(value)}
                value={selectedPrinterId}
              >
                {activePrinters.map((printer) => (
                  <TouchableOpacity
                    key={printer.id}
                    activeOpacity={0.7}
                    onPress={() => setSelectedPrinterId(printer.id)}
                  >
                    <Surface
                      style={[
                        styles.radioItem,
                        {
                          backgroundColor: theme.colors.surface,
                          borderColor:
                            selectedPrinterId === printer.id
                              ? theme.colors.primary
                              : 'transparent',
                          borderWidth: selectedPrinterId === printer.id ? 2 : 0,
                        },
                      ]}
                    >
                      <View style={styles.radioContent}>
                        <RadioButton
                          value={printer.id}
                          color={theme.colors.primary}
                        />
                        <View style={styles.radioTextContainer}>
                          <Text
                            style={[
                              styles.radioLabel,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            🖨️ {printer.name}
                          </Text>
                          <Text
                            style={[
                              styles.radioDescription,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {printer.ipAddress} - Puerto {printer.port}
                          </Text>
                        </View>
                      </View>
                    </Surface>
                  </TouchableOpacity>
                ))}
              </RadioButton.Group>
            )}
          </View>
        </ScrollView>
        <Divider />
        <View style={styles.footer}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            textColor={theme.colors.error}
            style={[styles.footerButton, { borderColor: theme.colors.error }]}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handlePrint}
            loading={isPrinting}
            disabled={
              !selectedPrinterId || activePrinters.length === 0 || isPrinting
            }
            style={[styles.footerButton, styles.printButton]}
            buttonColor={theme.colors.primary}
          >
            Imprimir
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};
const styles = StyleSheet.create({
  modalContent: {
    margin: 16,
    borderRadius: 16,
    maxHeight: '85%',
    overflow: 'hidden',
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  title: {
    fontSize: 18,
    fontWeight: '700',
    flex: 1,
  },
  closeButton: {
    margin: -8,
  },
  content: {
    maxHeight: 400,
  },
  section: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 8,
  },
  radioItem: {
    marginBottom: 6,
    borderRadius: 10,
    elevation: 1,
    padding: 2,
  },
  radioContent: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  radioTextContainer: {
    flex: 1,
    marginLeft: 8,
  },
  radioLabel: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 2,
  },
  radioDescription: {
    fontSize: 11,
    opacity: 0.7,
  },
  noPrintersText: {
    fontSize: 13,
    textAlign: 'center',
    padding: 12,
    fontWeight: '500',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    gap: 12,
  },
  footerButton: {
    minWidth: 100,
    borderRadius: 8,
  },
  printButton: {
    paddingHorizontal: 4,
  },
});

================
File: app/src/modules/shiftAudit/components/index.ts
================
export { ShiftOrdersModal } from './ShiftOrdersModal';
export { OrderDetailsView } from './OrderDetailsView';
export { OrderHistoryView } from './OrderHistoryView';
export { ShiftSalesSummaryView } from './ShiftSalesSummaryView';

================
File: app/src/modules/shiftAudit/components/OrderDetailsView.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Surface,
  Text,
  Divider,
  Appbar,
  ActivityIndicator,
  IconButton,
  Chip,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import type { Receipt } from '@/modules/receipts/types/receipt.types';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
interface OrderDetailsViewProps {
  order: Receipt | null;
  onBack: () => void;
  onShowHistory?: () => void;
  isLoading?: boolean;
}
const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';
  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalf.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalf.HALF_2
            ? 'HALF_2'
            : 'FULL';
      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }
      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;
      if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationType.INGREDIENT
      ) {
        if (curr.action === CustomizationAction.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }
      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );
  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };
    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';
    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }
  return '';
};
export const OrderDetailsView: React.FC<OrderDetailsViewProps> = ({
  order,
  onBack,
  onShowHistory,
  isLoading = false,
}) => {
  const theme = useAppTheme();
  const [showPrintHistory, setShowPrintHistory] = useState(false);
  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return '🍽️ Local';
      case 'TAKE_AWAY':
        return '🥡 Llevar';
      case 'DELIVERY':
        return '🚚 Envío';
      default:
        return type;
    }
  };
  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparación';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      case 'COMPLETED':
        return 'Completado';
      case 'CANCELLED':
        return 'Cancelado';
      default:
        return status;
    }
  };
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0';
      case 'COMPLETED':
        return '#10B981';
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceVariant;
    }
  };
  const getPaymentStatus = () => {
    if (order?.payments && order.payments.length > 0) {
      const totalPaid = order.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof order.total === 'string'
          ? parseFloat(order.total)
          : order.total || 0;
      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };
  const paymentStatus = order
    ? getPaymentStatus()
    : { label: 'Pendiente', color: '#EF4444' };
  const renderItem = (item: any) => {
    const quantity = item.quantity || 1;
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;
    return (
      <Surface
        key={`${item.id}`}
        style={[
          styles.itemCard,
          { backgroundColor: theme.colors.elevation.level1, marginBottom: 8 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>
          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}
            {item.productModifiers && item.productModifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.productModifiers.map((modifier: any) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      • {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}
            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📝 {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>
          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total ×{quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };
  if (isLoading) {
    return (
      <View style={styles.container}>
        <Appbar.Header style={styles.appbarHeader}>
          <Appbar.BackAction onPress={onBack} />
          <Appbar.Content title="Cargando..." />
        </Appbar.Header>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text
            style={[
              styles.loadingText,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Cargando detalles del recibo...
          </Text>
        </View>
      </View>
    );
  }
  if (!order) {
    return null;
  }
  return (
    <View
      style={[styles.container, { backgroundColor: theme.colors.background }]}
    >
      <Appbar.Header style={styles.appbarHeader}>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content title={`Recibo #${order?.shiftOrderNumber || ''}`} />
        <Appbar.Action
          icon="history"
          size={28}
          onPress={onShowHistory}
          disabled={!onShowHistory}
        />
      </Appbar.Header>
      <View style={styles.header}>
        <View style={styles.headerInfo}>
          <View style={styles.headerTopRow}>
            <View style={styles.headerLeft}>
              <Text style={[styles.orderType, { color: theme.colors.primary }]}>
                {order ? getOrderTypeLabel(order.orderType) : ''}
              </Text>
            </View>
          </View>
          <View style={styles.headerBottomRow}>
            <View style={styles.chipsRow}>
              <View
                style={[
                  styles.headerStatusChip,
                  {
                    backgroundColor: order
                      ? getStatusColor(order.orderStatus)
                      : theme.colors.surfaceVariant,
                  },
                ]}
              >
                <Text style={styles.headerStatusChipText}>
                  {order ? getOrderStatusLabel(order.orderStatus) : ''}
                </Text>
              </View>
              {order?.preparationScreens &&
                order.preparationScreens.map((screen, index) => (
                  <Chip
                    key={index}
                    mode="outlined"
                    compact
                    style={styles.screenChip}
                    textStyle={styles.screenChipText}
                  >
                    🍳 {screen}
                  </Chip>
                ))}
            </View>
          </View>
          <View style={styles.headerDatesRow}>
            <Text
              style={[
                styles.headerDate,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Creado:{' '}
              {order?.createdAt
                ? format(new Date(order.createdAt), 'dd/MM/yyyy HH:mm', {
                    locale: es,
                  })
                : ''}
            </Text>
            {order?.finalizedAt && (
              <Text
                style={[styles.headerDate, { color: theme.colors.primary }]}
              >
                Finalizado:{' '}
                {format(new Date(order.finalizedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            )}
          </View>
        </View>
      </View>
      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.scrollContent}
      >
        <View style={styles.infoSection}>
          {order?.deliveryInfo?.recipientName && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                👤 Nombre del Cliente: {order.deliveryInfo.recipientName}
              </Text>
            </View>
          )}
          {order?.deliveryInfo?.recipientPhone && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                📞 Teléfono: {order.deliveryInfo.recipientPhone}
              </Text>
            </View>
          )}
          {order?.orderType === 'DELIVERY' &&
            order?.deliveryInfo?.fullAddress && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.addressText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📦 Dirección de Entrega: {order.deliveryInfo.fullAddress}
                </Text>
              </View>
            )}
          {order?.orderType === 'DINE_IN' && order?.table && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.tableText, { color: theme.colors.onSurface }]}
              >
                🏛️ Mesa: {order.table.area?.name || 'Sin área'} -{' '}
                {order.table.number}
              </Text>
            </View>
          )}
          {order?.scheduledAt && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.primary, fontWeight: '600' },
                ]}
              >
                ⏰ Hora de Entrega Programada:{' '}
                {format(new Date(order.scheduledAt), 'HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          )}
          {order?.user && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                👨‍💼 Atendido por: {order.user.firstName} {order.user.lastName}
              </Text>
            </View>
          )}
          {order?.notes && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.notesText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                📋 Notas: {order.notes}
              </Text>
            </View>
          )}
        </View>
        <Divider style={styles.divider} />
        <View style={styles.itemsList}>
          {order?.orderItems?.map((item) => renderItem(item)) || []}
        </View>
        <Divider style={styles.divider} />
        {order?.payments && order.payments.length > 0 && (
          <>
            <View style={styles.paymentsSection}>
              <View style={styles.paymentSummaryCompact}>
                <View style={styles.summaryCompactRow}>
                  <Text
                    style={[
                      styles.summaryCompactLabel,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    Total: $
                    {typeof order.total === 'string'
                      ? parseFloat(order.total).toFixed(2)
                      : (order.total || 0).toFixed(2)}
                  </Text>
                  <Text
                    style={[styles.summaryCompactLabel, { color: '#10B981' }]}
                  >
                    Pagado: $
                    {order.payments
                      .reduce((sum, p) => sum + p.amount, 0)
                      .toFixed(2)}
                  </Text>
                  {(() => {
                    const totalAmount =
                      typeof order.total === 'string'
                        ? parseFloat(order.total)
                        : order.total || 0;
                    const totalPaid = order.payments.reduce(
                      (sum, p) => sum + p.amount,
                      0,
                    );
                    const remaining = totalAmount - totalPaid;
                    if (remaining > 0) {
                      return (
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            {
                              color: theme.colors.error,
                              fontWeight: '600',
                            },
                          ]}
                        >
                          Resta: ${remaining.toFixed(2)}
                        </Text>
                      );
                    }
                    return null;
                  })()}
                </View>
              </View>
              {order.payments.map((payment, index) => {
                const getPaymentMethodLabel = (method: string) => {
                  switch (method) {
                    case 'CASH':
                    case 'cash':
                      return 'Efectivo';
                    case 'CREDIT_CARD':
                    case 'card':
                      return 'Tarjeta de Crédito';
                    case 'DEBIT_CARD':
                      return 'Tarjeta de Débito';
                    case 'TRANSFER':
                    case 'transfer':
                      return 'Transferencia';
                    case 'OTHER':
                      return 'Otro';
                    default:
                      return method;
                  }
                };
                const getPaymentStatusColor = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return '#10B981';
                    case 'PENDING':
                      return '#F59E0B';
                    case 'FAILED':
                      return theme.colors.error;
                    case 'REFUNDED':
                      return '#6B7280';
                    case 'CANCELLED':
                      return theme.colors.error;
                    default:
                      return theme.colors.onSurfaceVariant;
                  }
                };
                const getPaymentStatusLabel = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return 'Completado';
                    case 'PENDING':
                      return 'Pendiente';
                    case 'FAILED':
                      return 'Fallido';
                    case 'REFUNDED':
                      return 'Reembolsado';
                    case 'CANCELLED':
                      return 'Cancelado';
                    default:
                      return status;
                  }
                };
                return (
                  <View
                    key={payment.id || index}
                    style={styles.paymentRowCompact}
                  >
                    <Text
                      style={[
                        styles.paymentMethodCompact,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      💳 {getPaymentMethodLabel(payment.paymentMethod)}
                    </Text>
                    <Text
                      style={[
                        styles.paymentDateCompact,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {format(new Date(payment.createdAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                    <View
                      style={[
                        styles.paymentStatusBadgeCompact,
                        {
                          backgroundColor:
                            getPaymentStatusColor(payment.paymentStatus) + '20',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.paymentStatusTextCompact,
                          {
                            color: getPaymentStatusColor(payment.paymentStatus),
                          },
                        ]}
                      >
                        {getPaymentStatusLabel(payment.paymentStatus)}
                      </Text>
                    </View>
                    <Text
                      style={[
                        styles.paymentAmountCompact,
                        { color: theme.colors.primary },
                      ]}
                    >
                      ${payment.amount.toFixed(2)}
                    </Text>
                  </View>
                );
              })}
            </View>
            <Divider style={styles.divider} />
          </>
        )}
        {order?.ticketImpressions && order.ticketImpressions.length > 0 && (
          <>
            <View style={styles.ticketImpressionsSection}>
              <TouchableOpacity
                style={styles.collapsibleHeader}
                onPress={() => setShowPrintHistory(!showPrintHistory)}
                activeOpacity={0.7}
              >
                <Text
                  style={[styles.sectionTitle, { color: theme.colors.primary }]}
                >
                  🖨️ Historial de Impresiones ({order.ticketImpressions.length})
                </Text>
                <IconButton
                  icon={showPrintHistory ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  style={styles.collapseIcon}
                />
              </TouchableOpacity>
              {showPrintHistory && (
                <View style={styles.collapsibleContent}>
                  {order.ticketImpressions.map((impression, index) => {
                    const getTicketTypeLabel = (type: string) => {
                      switch (type) {
                        case 'KITCHEN':
                          return '🍳 Cocina';
                        case 'BAR':
                          return '🍺 Barra';
                        case 'BILLING':
                          return '💵 Cuenta';
                        case 'CUSTOMER_COPY':
                          return '📄 Copia Cliente';
                        case 'GENERAL':
                          return '📋 General';
                        default:
                          return type;
                      }
                    };
                    return (
                      <View
                        key={impression.id || index}
                        style={styles.impressionRow}
                      >
                        <View style={styles.impressionLeft}>
                          <Text
                            style={[
                              styles.impressionType,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            {getTicketTypeLabel(impression.ticketType)}
                          </Text>
                          <View style={styles.impressionDetails}>
                            {impression.user && (
                              <Text
                                style={[
                                  styles.impressionUser,
                                  { color: theme.colors.onSurfaceVariant },
                                ]}
                              >
                                por {impression.user.firstName || ''}{' '}
                                {impression.user.lastName || ''}
                              </Text>
                            )}
                            {impression.printer && (
                              <Text
                                style={[
                                  styles.impressionPrinter,
                                  { color: theme.colors.onSurfaceVariant },
                                ]}
                              >
                                🖨️ {impression.printer.name}
                              </Text>
                            )}
                          </View>
                        </View>
                        <Text
                          style={[
                            styles.impressionTime,
                            { color: theme.colors.onSurfaceVariant },
                          ]}
                        >
                          {format(
                            new Date(impression.impressionTime),
                            'HH:mm:ss',
                            { locale: es },
                          )}
                        </Text>
                      </View>
                    );
                  })}
                </View>
              )}
            </View>
          </>
        )}
      </ScrollView>
      <Divider style={styles.divider} />
      <View style={styles.footer}>
        <View style={styles.footerLeft}>
          <Text
            style={[
              styles.totalLabel,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Total:
          </Text>
          <Text style={[styles.totalAmount, { color: theme.colors.primary }]}>
            $
            {order
              ? typeof order.total === 'string'
                ? parseFloat(order.total).toFixed(2)
                : (order.total || 0).toFixed(2)
              : '0.00'}
          </Text>
        </View>
        <View
          style={[
            styles.paymentBadge,
            { backgroundColor: paymentStatus.color },
          ]}
        >
          <Text style={styles.paymentBadgeText}>💵 {paymentStatus.label}</Text>
        </View>
      </View>
    </View>
  );
};
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  appbarHeader: {
    elevation: 0,
  },
  header: {
    paddingHorizontal: 16,
    paddingTop: 10,
    paddingBottom: 6,
  },
  headerTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  headerLeft: {
    flex: 1,
  },
  headerBottomRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  headerDatesRow: {
    gap: 8,
    marginTop: 4,
  },
  chipsRow: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    flexWrap: 'wrap',
  },
  headerSeparator: {
    fontSize: 14,
    marginHorizontal: 6,
  },
  orderType: {
    fontSize: 15,
    fontWeight: '600',
  },
  headerDate: {
    fontSize: 13,
  },
  headerInfo: {
  },
  infoSection: {
    paddingHorizontal: 16,
    paddingTop: 4,
    paddingBottom: 6,
    gap: 4,
  },
  infoRow: {
    marginVertical: 2,
  },
  contactText: {
    fontSize: 14,
  },
  addressText: {
    fontSize: 14,
    lineHeight: 18,
  },
  tableText: {
    fontSize: 14,
  },
  screenChip: {
    height: 24,
  },
  screenChipText: {
    fontSize: 12,
    marginVertical: -2,
  },
  paymentBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  paymentBadgeText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },
  totalAmount: {
    fontSize: 18,
    fontWeight: '700',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.08)',
    backgroundColor: 'inherit',
  },
  footerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  totalLabel: {
    fontSize: 16,
    fontWeight: '600',
  },
  divider: {
    marginVertical: 2,
  },
  headerStatusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  headerStatusChipText: {
    color: 'white',
    fontSize: 13,
    fontWeight: '600',
  },
  scrollView: {
    flexGrow: 0,
    flexShrink: 1,
    maxHeight: '70%',
  },
  scrollContent: {
    paddingBottom: 8,
  },
  itemsList: {
    padding: 12,
    paddingBottom: 16,
  },
  itemCard: {
    borderRadius: 8,
    overflow: 'hidden',
  },
  itemContent: {
    padding: 10,
  },
  itemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  nameContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  itemQuantity: {
    fontSize: 16,
    fontWeight: '700',
    marginRight: 6,
  },
  itemName: {
    fontSize: 15,
    fontWeight: '600',
    flex: 1,
    lineHeight: 18,
  },
  statusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusChipText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  itemDetailsContainer: {
    marginBottom: 6,
  },
  customizationContainer: {
    marginBottom: 4,
  },
  pizzaCustomizationText: {
    fontSize: 13,
    fontStyle: 'italic',
    lineHeight: 16,
  },
  modifiersContainer: {
    marginTop: 2,
  },
  modifierRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 1,
  },
  modifierText: {
    fontSize: 13,
    flex: 1,
    lineHeight: 16,
  },
  modifierPrice: {
    fontSize: 13,
    fontWeight: '500',
    marginLeft: 4,
  },
  notesContainer: {
    marginTop: 4,
    paddingTop: 4,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  notesText: {
    fontSize: 13,
    fontStyle: 'italic',
    lineHeight: 16,
  },
  priceContainer: {
    marginTop: 6,
    paddingTop: 6,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  priceLabel: {
    fontSize: 13,
    opacity: 0.7,
  },
  priceValue: {
    fontSize: 14,
    fontWeight: '600',
  },
  totalPrice: {
    fontSize: 16,
    fontWeight: '700',
  },
  paymentsSection: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  paymentSummaryCompact: {
    marginBottom: 8,
  },
  summaryCompactRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  summaryCompactLabel: {
    fontSize: 14,
    fontWeight: '500',
  },
  paymentRowCompact: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
    gap: 8,
  },
  paymentMethodCompact: {
    fontSize: 13,
    fontWeight: '500',
    flex: 1,
  },
  paymentDateCompact: {
    fontSize: 12,
  },
  paymentAmountCompact: {
    fontSize: 14,
    fontWeight: '600',
    minWidth: 50,
    textAlign: 'right',
  },
  paymentStatusBadgeCompact: {
    paddingHorizontal: 6,
    paddingVertical: 1,
    borderRadius: 10,
  },
  paymentStatusTextCompact: {
    fontSize: 11,
    fontWeight: '600',
  },
  ticketImpressionsSection: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  collapsibleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingRight: 4,
  },
  collapseIcon: {
    margin: -8,
  },
  collapsibleContent: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 0,
  },
  impressionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
    paddingLeft: 8,
  },
  impressionLeft: {
    flex: 1,
    gap: 2,
  },
  impressionType: {
    fontSize: 14,
    fontWeight: '500',
  },
  impressionDetails: {
    gap: 2,
  },
  impressionUser: {
    fontSize: 13,
    opacity: 0.7,
  },
  impressionPrinter: {
    fontSize: 13,
    opacity: 0.7,
    fontStyle: 'italic',
  },
  impressionTime: {
    fontSize: 13,
    opacity: 0.7,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
});

================
File: app/src/modules/shiftAudit/components/ShiftSalesSummaryView.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Text,
  IconButton,
  Divider,
  ActivityIndicator,
  DataTable,
  ProgressBar,
  Appbar,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { formatCurrency } from '@/app/lib/formatters';
import { useShiftSalesSummary } from '../hooks/useShiftSalesSummary';
import type {
  CategorySalesSummary,
  SubcategorySalesSummary,
} from '../hooks/useShiftSalesSummary';
interface Props {
  shiftId: string;
  shiftNumber?: number;
  onBack: () => void;
}
export function ShiftSalesSummaryView({ shiftId, shiftNumber, onBack }: Props) {
  const theme = useAppTheme();
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set(),
  );
  const [expandedSubcategories, setExpandedSubcategories] = useState<
    Set<string>
  >(new Set());
  const { data: summary, isLoading, error } = useShiftSalesSummary(shiftId);
  const toggleCategory = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };
  const toggleSubcategory = (subcategoryId: string) => {
    const newExpanded = new Set(expandedSubcategories);
    if (newExpanded.has(subcategoryId)) {
      newExpanded.delete(subcategoryId);
    } else {
      newExpanded.add(subcategoryId);
    }
    setExpandedSubcategories(newExpanded);
  };
  const renderHeader = () => (
    <Appbar.Header elevated>
      <Appbar.BackAction onPress={onBack} />
      <Appbar.Content
        title={`Resumen de Ventas - Turno #${shiftNumber || summary?.shiftNumber || 'N/A'}`}
        titleStyle={{ fontSize: 18 }}
      />
    </Appbar.Header>
  );
  const renderSummaryCards = () => {
    if (!summary) return null;
    return (
      <View style={styles.summaryCardsContainer}>
        <View style={styles.summaryRow}>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>VENTAS</Text>
            <Text style={styles.summaryCardValue}>
              {formatCurrency(summary.totalSales)}
            </Text>
          </View>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>ÓRDENES</Text>
            <Text style={styles.summaryCardValue}>
              {summary.completedOrders}
            </Text>
          </View>
        </View>
        <View style={styles.summaryRow}>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>PRODUCTOS</Text>
            <Text style={styles.summaryCardValue}>{summary.totalQuantity}</Text>
          </View>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>PROMEDIO</Text>
            <Text style={styles.summaryCardValue}>
              {formatCurrency(summary.averageTicket)}
            </Text>
          </View>
        </View>
        <Text style={styles.adjustmentNote}>
          * Los totales incluyen ajustes aplicados (descuentos y cargos)
        </Text>
      </View>
    );
  };
  const renderCategoryItem = (category: CategorySalesSummary) => {
    const isExpanded = expandedCategories.has(category.categoryId);
    return (
      <View key={category.categoryId}>
        <TouchableOpacity
          onPress={() => toggleCategory(category.categoryId)}
          activeOpacity={0.7}
        >
          <View style={styles.categoryItem}>
            <View style={styles.categoryHeader}>
              <View style={styles.categoryInfo}>
                <View style={styles.categoryTitleRow}>
                  <Text style={styles.categoryName}>
                    {category.categoryName}
                  </Text>
                  <Text style={styles.categoryPercentage}>
                    {category.percentage.toFixed(1)}%
                  </Text>
                </View>
                <View style={styles.categoryStatsRow}>
                  <Text style={styles.categoryQuantity}>
                    {category.quantity} productos vendidos
                  </Text>
                  <Text style={styles.categoryAmount}>
                    {formatCurrency(category.totalAmount)}
                  </Text>
                </View>
                <ProgressBar
                  progress={category.percentage / 100}
                  style={styles.progressBar}
                  color={theme.colors.primary}
                />
              </View>
              <IconButton
                icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                size={24}
                iconColor={theme.colors.onSurfaceVariant}
                style={styles.expandIcon}
              />
            </View>
          </View>
        </TouchableOpacity>
        {isExpanded && category.subcategories.length > 0 && (
          <View style={styles.subcategoriesContainer}>
            {category.subcategories.map((subcategory) =>
              renderSubcategoryItem(subcategory),
            )}
          </View>
        )}
      </View>
    );
  };
  const renderSubcategoryItem = (subcategory: SubcategorySalesSummary) => {
    const isExpanded = expandedSubcategories.has(subcategory.subcategoryId);
    return (
      <View key={subcategory.subcategoryId}>
        <TouchableOpacity
          onPress={() => toggleSubcategory(subcategory.subcategoryId)}
          activeOpacity={0.7}
        >
          <View style={styles.subcategoryItem}>
            <View style={styles.subcategoryHeader}>
              <View style={styles.subcategoryInfo}>
                <Text style={styles.subcategoryName}>
                  {subcategory.subcategoryName}
                </Text>
                <Text style={styles.subcategoryStats}>
                  {subcategory.quantity} productos •{' '}
                  {formatCurrency(subcategory.totalAmount)}
                </Text>
              </View>
              <IconButton
                icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                size={18}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>
          </View>
        </TouchableOpacity>
        {isExpanded && subcategory.products.length > 0 && (
          <View style={styles.productsContainer}>
            {subcategory.products.map((product) => (
              <View key={product.productId} style={styles.productItem}>
                <Text style={styles.productName}>{product.productName}</Text>
                <View style={styles.productStats}>
                  <Text style={styles.productQuantity}>
                    {product.quantity}x
                  </Text>
                  <Text style={styles.productAmount}>
                    {formatCurrency(product.totalAmount)}
                  </Text>
                </View>
              </View>
            ))}
          </View>
        )}
      </View>
    );
  };
  const renderTopProducts = () => {
    if (!summary || !summary.topProducts || summary.topProducts.length === 0) {
      return null;
    }
    return (
      <View style={styles.topProductsSection}>
        <Text style={styles.sectionTitle}>Top 10 Productos Más Vendidos</Text>
        <View style={styles.topProductsTable}>
          <DataTable>
            <DataTable.Header>
              <DataTable.Title style={styles.rankColumn}>#</DataTable.Title>
              <DataTable.Title style={styles.productColumn}>
                Producto
              </DataTable.Title>
              <DataTable.Title numeric style={styles.quantityColumn}>
                Cant.
              </DataTable.Title>
              <DataTable.Title numeric style={styles.amountColumn}>
                Total
              </DataTable.Title>
            </DataTable.Header>
            {summary.topProducts.slice(0, 10).map((product, index) => (
              <DataTable.Row key={product.productId}>
                <DataTable.Cell style={styles.rankColumn}>
                  <Text style={styles.rankNumber}>{index + 1}</Text>
                </DataTable.Cell>
                <DataTable.Cell style={styles.productColumn}>
                  <Text style={styles.topProductName} numberOfLines={2}>
                    {product.productName}
                  </Text>
                </DataTable.Cell>
                <DataTable.Cell numeric style={styles.quantityColumn}>
                  {product.quantity}
                </DataTable.Cell>
                <DataTable.Cell numeric style={styles.amountColumn}>
                  {formatCurrency(product.totalAmount)}
                </DataTable.Cell>
              </DataTable.Row>
            ))}
          </DataTable>
        </View>
      </View>
    );
  };
  const renderContent = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
          <Text style={styles.loadingText}>Cargando resumen de ventas...</Text>
        </View>
      );
    }
    if (error) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>
            Error al cargar el resumen de ventas
          </Text>
        </View>
      );
    }
    if (!summary) {
      return (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>No hay datos disponibles</Text>
        </View>
      );
    }
    return (
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {renderSummaryCards()}
        <Divider style={styles.sectionDivider} />
        <View style={styles.categoriesSection}>
          <Text style={styles.sectionTitle}>Ventas por Categoría</Text>
          {summary.categories.map(renderCategoryItem)}
        </View>
        <Divider style={styles.sectionDivider} />
        {renderTopProducts()}
      </ScrollView>
    );
  };
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: theme.spacing.xl,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    errorText: {
      color: theme.colors.error,
      fontSize: 16,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
    },
    summaryCardsContainer: {
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    summaryRow: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    summaryCard: {
      flex: 1,
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
    },
    summaryCardLabel: {
      fontSize: 10,
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 0.3,
    },
    summaryCardValue: {
      fontSize: 16,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginTop: 2,
    },
    adjustmentNote: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      textAlign: 'center',
      marginTop: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
    },
    sectionDivider: {
      marginVertical: theme.spacing.s,
      marginHorizontal: theme.spacing.m,
    },
    categoriesSection: {
      paddingHorizontal: theme.spacing.m,
    },
    sectionTitle: {
      fontSize: 18,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.m,
    },
    categoryItem: {
      marginBottom: theme.spacing.s,
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      elevation: 1,
    },
    categoryHeader: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    categoryInfo: {
      flex: 1,
    },
    categoryTitleRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    categoryName: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    categoryPercentage: {
      fontSize: 18,
      fontWeight: '700',
      color: theme.colors.primary,
    },
    categoryStatsRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    categoryQuantity: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    categoryAmount: {
      fontSize: 15,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    expandIcon: {
      marginLeft: theme.spacing.xs,
    },
    progressBar: {
      height: 4,
      borderRadius: 2,
      backgroundColor: theme.colors.surfaceVariant,
    },
    subcategoriesContainer: {
      paddingLeft: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    subcategoryItem: {
      marginBottom: theme.spacing.xs,
      marginHorizontal: theme.spacing.xs,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.background,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    subcategoryHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    subcategoryInfo: {
      flex: 1,
    },
    subcategoryName: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    subcategoryStats: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 4,
    },
    productsContainer: {
      paddingLeft: theme.spacing.m,
      paddingTop: theme.spacing.xs,
    },
    productItem: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
      marginHorizontal: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    productName: {
      flex: 1,
      fontSize: 12,
      color: theme.colors.onSurface,
    },
    productStats: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    productQuantity: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
      minWidth: 30,
      textAlign: 'right',
    },
    productAmount: {
      fontSize: 12,
      fontWeight: '600',
      color: theme.colors.primary,
      minWidth: 60,
      textAlign: 'right',
    },
    topProductsSection: {
      paddingHorizontal: theme.spacing.m,
      paddingBottom: theme.spacing.m,
    },
    topProductsTable: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    rankColumn: {
      flex: 0.5,
    },
    productColumn: {
      flex: 3,
    },
    quantityColumn: {
      flex: 1,
    },
    amountColumn: {
      flex: 1.5,
    },
    rankNumber: {
      fontWeight: '700',
      color: theme.colors.primary,
    },
    topProductName: {
      fontSize: 13,
      color: theme.colors.onSurface,
    },
  });
  return (
    <View style={styles.container}>
      {renderHeader()}
      {renderContent()}
    </View>
  );
}

================
File: app/src/modules/shiftAudit/hooks/useShiftOrders.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService } from '@/services/shifts';
import type { Order } from '@/app/schemas/domain/order.schema';
import type { Shift, ShiftSummary } from '../types';
export const useShiftOrders = (shiftId: string | undefined) => {
  return useQuery<Order[], Error>({
    queryKey: ['shifts', shiftId, 'orders'],
    queryFn: () => shiftsService.getOrdersByShift(shiftId!),
    enabled: !!shiftId,
    staleTime: 300000,
  });
};
export const useShiftSummary = (shiftId: string | undefined) => {
  const shiftQuery = useQuery<Shift, Error>({
    queryKey: ['shifts', shiftId],
    queryFn: () => shiftsService.getById(shiftId!),
    enabled: !!shiftId,
  });
  const ordersQuery = useQuery<Order[], Error>({
    queryKey: ['shifts', shiftId, 'orders'],
    queryFn: () => shiftsService.getOrdersByShift(shiftId!),
    enabled: !!shiftId && shiftQuery.isSuccess,
  });
  const summary: ShiftSummary | undefined =
    shiftQuery.data && ordersQuery.data
      ? shiftsService.calculateShiftSummary(shiftQuery.data, ordersQuery.data)
      : undefined;
  return {
    summary,
    isLoading: shiftQuery.isLoading || ordersQuery.isLoading,
    error: shiftQuery.error || ordersQuery.error,
  };
};

================
File: app/src/modules/shiftAudit/navigation/ShiftAuditStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ShiftsListScreen } from '../screens/ShiftsListScreen';
import type { ShiftAuditStackParamList } from './types';
const Stack = createNativeStackNavigator<ShiftAuditStackParamList>();
export function ShiftAuditStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="ShiftsList"
        component={ShiftsListScreen}
        options={{
          title: 'Historial de Turnos',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/shiftAudit/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { CompositeScreenProps } from '@react-navigation/native';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import type { DrawerNavigatorParamList } from '@/app/navigation/types';
export type ShiftAuditStackParamList = {
  ShiftsList: undefined;
};
export type ShiftAuditStackScreenProps<
  T extends keyof ShiftAuditStackParamList,
> = CompositeScreenProps<
  NativeStackScreenProps<ShiftAuditStackParamList, T>,
  DrawerScreenProps<DrawerNavigatorParamList>
>;
export type ShiftsListScreenNavigationProp =
  ShiftAuditStackScreenProps<'ShiftsList'>['navigation'];
export type ShiftsListScreenRouteProp =
  ShiftAuditStackScreenProps<'ShiftsList'>['route'];
export type ShiftAuditStackNavigationProp = ShiftsListScreenNavigationProp;

================
File: app/src/modules/shiftAudit/screens/index.ts
================
export { ShiftsListScreen } from './ShiftsListScreen';

================
File: app/src/modules/shiftAudit/types/index.ts
================
export interface Shift {
  id: string;
  date: string;
  globalShiftNumber: number;
  shiftNumber: number;
  status: 'open' | 'closed';
  openedAt: string;
  closedAt: string | null;
  openedBy: User;
  closedBy: User | null;
  initialCash: number;
  finalCash: number | null;
  totalSales: number | null;
  totalOrders: number | null;
  cashDifference: number | null;
  expectedCash?: number | null;
  notes: string | null;
  closeNotes: string | null;
  createdAt?: string;
  updatedAt?: string;
}
export interface User {
  id: string;
  email?: string;
  firstName: string;
  lastName: string;
}
export interface ShiftSummary {
  shift: Shift;
  ordersCount: number;
  totalSales: number;
  paymentMethodsSummary: PaymentMethodSummary[];
  productsSummary: ProductSummary[];
}
export interface PaymentMethodSummary {
  method: string;
  count: number;
  total: number;
}
export interface ProductSummary {
  productName: string;
  quantity: number;
  total: number;
}
export interface ShiftOrder {
  id: string;
  orderNumber: string;
  total: number;
  status: string;
  paymentMethod: string;
  customerName: string | null;
  createdAt: string;
  items: OrderItem[];
}
export interface OrderItem {
  id: string;
  productName: string;
  quantity: number;
  unitPrice: number;
  total: number;
  modifiers?: string[];
}

================
File: app/src/modules/sync/screens/SyncStatusScreen.tsx
================
import React, { useState } from 'react';
import {
  ScrollView,
  RefreshControl,
  View,
  useWindowDimensions,
} from 'react-native';
import {
  Card,
  List,
  Text,
  ActivityIndicator,
  Divider,
  Icon,
  Chip,
  Surface,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useQuery } from '@tanstack/react-query';
import { formatDistanceToNow } from 'date-fns';
import { es } from 'date-fns/locale';
import { syncService } from '../services/syncService';
import {
  SyncActivity,
  SyncStatus,
  SyncActivityType,
  SYNC_TYPE_LABELS,
  SYNC_DIRECTION_LABELS,
} from '../types/sync.types';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { StyleSheet } from 'react-native';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
export function SyncStatusScreen() {
  const theme = useAppTheme();
  const { width: screenWidth } = useWindowDimensions();
  const { isTablet, deviceType } = useResponsive();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [refreshing, setRefreshing] = useState(false);
  const contentPadding = isTablet ? theme.spacing.l : theme.spacing.m;
  const {
    data: syncStatus,
    isLoading: isLoadingStatus,
    error: statusError,
    refetch: refetchStatus,
  } = useQuery({
    queryKey: ['sync-status'],
    queryFn: () => syncService.getSyncStatus(),
    refetchInterval: 30000,
  });
  const {
    data: syncActivity,
    isLoading: isLoadingActivity,
    error: activityError,
    refetch: refetchActivity,
  } = useQuery({
    queryKey: ['sync-activity'],
    queryFn: () => syncService.getSyncActivity(20),
    refetchInterval: 30000,
  });
  const handleRefresh = async () => {
    setRefreshing(true);
    try {
      await Promise.all([refetchStatus(), refetchActivity()]);
    } catch (error) {
      showSnackbar('Error al actualizar información', 'error');
    } finally {
      setRefreshing(false);
    }
  };
  const formatTimestamp = (timestamp: string) => {
    try {
      return formatDistanceToNow(new Date(timestamp), {
        addSuffix: true,
        locale: es,
      });
    } catch {
      return 'Fecha inválida';
    }
  };
  const getActivityIcon = (type: SyncActivityType) => {
    switch (type) {
      case SyncActivityType.PULL_CHANGES:
        return 'cloud-download';
      case SyncActivityType.RESTAURANT_DATA:
        return 'store';
      case SyncActivityType.ORDER_STATUS:
        return 'check-circle';
      default:
        return 'sync';
    }
  };
  const getStatusColor = (success: boolean) => {
    return success ? theme.colors.success : theme.colors.error;
  };
  const styles = React.useMemo(
    () => createStyles(theme, isTablet),
    [theme, isTablet],
  );
  if (isLoadingStatus || isLoadingActivity) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>Cargando información...</Text>
        </View>
      </SafeAreaView>
    );
  }
  if (statusError || activityError) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.errorContainer}>
          <Icon source="alert-circle" size={48} color={theme.colors.error} />
          <Text style={styles.errorText}>
            Error al cargar información de sincronización
          </Text>
        </View>
      </SafeAreaView>
    );
  }
  return (
    <SafeAreaView style={styles.container}>
      <ScrollView
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={[
          styles.scrollContent,
          { padding: contentPadding },
          isTablet && styles.scrollContentTablet,
        ]}
      >
        {}
        <Card style={styles.card} mode="elevated">
          <Card.Title
            title="Estado del Servicio"
            titleVariant="headlineSmall"
            left={(props) => <Icon {...props} source="information" />}
          />
          <Card.Content>
            <List.Item
              title="Sincronización"
              titleStyle={styles.listItemTitle}
              description={syncStatus?.enabled ? 'Habilitada' : 'Deshabilitada'}
              descriptionStyle={styles.listItemDescription}
              left={(props) => (
                <List.Icon
                  {...props}
                  icon={syncStatus?.enabled ? 'check-circle' : 'close-circle'}
                  color={
                    syncStatus?.enabled
                      ? theme.colors.success
                      : theme.colors.error
                  }
                />
              )}
            />
            <List.Item
              title="WebSocket"
              titleStyle={styles.listItemTitle}
              description={
                syncStatus?.webSocketEnabled
                  ? syncStatus?.webSocketConnected
                    ? 'Conectado'
                    : syncStatus?.webSocketFailed
                      ? 'Conexión fallida'
                      : 'Intentando conectar...'
                  : 'Deshabilitado'
              }
              descriptionStyle={[
                styles.listItemDescription,
                syncStatus?.webSocketFailed && { color: theme.colors.error },
              ]}
              left={(props) => (
                <List.Icon
                  {...props}
                  icon={
                    syncStatus?.webSocketFailed
                      ? 'access-point-off'
                      : 'access-point'
                  }
                  color={
                    syncStatus?.webSocketConnected
                      ? theme.colors.success
                      : syncStatus?.webSocketFailed
                        ? theme.colors.error
                        : syncStatus?.webSocketEnabled
                          ? theme.colors.warning
                          : theme.colors.outline
                  }
                />
              )}
            />
            {syncStatus?.remoteUrl && (
              <List.Item
                title="Servidor Remoto"
                titleStyle={styles.listItemTitle}
                description={syncStatus.remoteUrl}
                descriptionStyle={styles.listItemDescription}
                left={(props) => <List.Icon {...props} icon="server" />}
              />
            )}
            <List.Item
              title="Modo"
              titleStyle={styles.listItemTitle}
              description="Pull (bajo demanda)"
              descriptionStyle={styles.listItemDescription}
              left={(props) => <List.Icon {...props} icon="download" />}
            />
          </Card.Content>
        </Card>
        {}
        <Card style={styles.card} mode="elevated">
          <Card.Title
            title="Actividad Reciente"
            titleVariant="headlineSmall"
            subtitle={`Últimas ${syncActivity?.length || 0} sincronizaciones`}
            left={(props) => <Icon {...props} source="history" />}
          />
          <Card.Content>
            {syncActivity && syncActivity.length > 0 ? (
              syncActivity.map((activity, index) => (
                <React.Fragment key={activity.id}>
                  <Surface
                    style={[
                      styles.activityItem,
                      !activity.success && styles.activityItemError,
                    ]}
                    elevation={0}
                  >
                    <View style={styles.activityHeader}>
                      <View style={styles.activityLeft}>
                        <Icon
                          source={getActivityIcon(activity.type)}
                          size={24}
                          color={getStatusColor(activity.success)}
                        />
                        <View style={styles.activityInfo}>
                          <Text
                            variant="bodyMedium"
                            style={styles.activityType}
                          >
                            {SYNC_TYPE_LABELS[activity.type]}
                          </Text>
                          <Text variant="bodySmall" style={styles.activityTime}>
                            {formatTimestamp(activity.timestamp)}
                          </Text>
                        </View>
                      </View>
                      <View style={styles.activityRight}>
                        <Chip
                          compact
                          mode="flat"
                          textStyle={[
                            styles.chipText,
                            {
                              color:
                                activity.direction === 'IN'
                                  ? theme.colors.onInfoContainer
                                  : theme.colors.onSuccessContainer,
                            },
                          ]}
                          style={[
                            styles.directionChip,
                            activity.direction === 'IN'
                              ? styles.chipIn
                              : styles.chipOut,
                          ]}
                        >
                          {SYNC_DIRECTION_LABELS[activity.direction]}
                        </Chip>
                        <Icon
                          source={activity.success ? 'check' : 'close'}
                          size={20}
                          color={getStatusColor(activity.success)}
                        />
                      </View>
                    </View>
                  </Surface>
                  {index < syncActivity.length - 1 && (
                    <Divider style={styles.divider} />
                  )}
                </React.Fragment>
              ))
            ) : (
              <View style={styles.emptyState}>
                <Icon
                  source="cloud-off-outline"
                  size={48}
                  color={theme.colors.outline}
                />
                <Text
                  variant="bodyMedium"
                  style={[styles.emptyText, { color: theme.colors.outline }]}
                >
                  No hay actividad reciente
                </Text>
              </View>
            )}
          </Card.Content>
        </Card>
        {}
        <Card style={[styles.card, styles.infoCard]} mode="contained">
          <Card.Content>
            <View style={styles.infoRow}>
              <Icon
                source="information-outline"
                size={20}
                color={theme.colors.onInfoContainer}
              />
              <Text variant="bodySmall" style={styles.infoText}>
                La sincronización se ejecuta automáticamente cuando hay cambios
                pendientes. No es necesaria ninguna acción manual.
              </Text>
            </View>
          </Card.Content>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
}
const createStyles = (
  theme: ReturnType<typeof useAppTheme>,
  isTablet: boolean,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: theme.spacing.xl,
    },
    scrollContentTablet: {
      maxWidth: 800,
      alignSelf: 'center',
      width: '100%',
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    errorText: {
      marginTop: theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    card: {
      marginBottom: theme.spacing.m,
      elevation: 2,
    },
    listItemTitle: {
      fontSize: isTablet ? 16 : 14,
      color: theme.colors.onSurface,
    },
    listItemDescription: {
      fontSize: isTablet ? 14 : 12,
      color: theme.colors.onSurfaceVariant,
    },
    activityItem: {
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.surfaceVariant,
    },
    activityItemError: {
      backgroundColor: theme.colors.errorContainer,
    },
    activityHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    activityLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    activityInfo: {
      marginLeft: theme.spacing.m,
      flex: 1,
    },
    activityType: {
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    activityTime: {
      opacity: 0.7,
      marginTop: 2,
      color: theme.colors.onSurfaceVariant,
    },
    activityRight: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    directionChip: {
      height: 24,
    },
    chipText: {
      fontSize: isTablet ? 12 : 11,
      marginVertical: 0,
      marginHorizontal: theme.spacing.s,
    },
    chipIn: {
      backgroundColor: theme.colors.infoContainer,
    },
    chipOut: {
      backgroundColor: theme.colors.successContainer,
    },
    divider: {
      marginVertical: theme.spacing.xs,
    },
    emptyState: {
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    emptyText: {
      marginTop: theme.spacing.m,
    },
    infoCard: {
      backgroundColor: theme.colors.infoContainer,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    infoText: {
      marginLeft: theme.spacing.s,
      flex: 1,
      lineHeight: 20,
      color: theme.colors.onInfoContainer,
    },
  });

================
File: app/src/modules/sync/types/sync.types.ts
================
export enum SyncActivityType {
  PULL_CHANGES = 'PULL_CHANGES',
  RESTAURANT_DATA = 'RESTAURANT_DATA',
  ORDER_STATUS = 'ORDER_STATUS',
}
export type SyncDirection = 'IN' | 'OUT';
export interface SyncActivity {
  id: string;
  type: SyncActivityType;
  direction: SyncDirection;
  success: boolean;
  timestamp: string;
}
export interface SyncStatus {
  enabled: boolean;
  webSocketEnabled: boolean;
  webSocketConnected?: boolean;
  webSocketFailed?: boolean;
  remoteUrl: string | null;
  mode: string;
}
export const SYNC_TYPE_LABELS: Record<SyncActivityType, string> = {
  [SyncActivityType.PULL_CHANGES]: 'Órdenes y Clientes',
  [SyncActivityType.RESTAURANT_DATA]: 'Menú y Configuración',
  [SyncActivityType.ORDER_STATUS]: 'Estado de Orden',
};
export const SYNC_DIRECTION_LABELS: Record<SyncDirection, string> = {
  IN: 'Desde la nube',
  OUT: 'Hacia la nube',
};

================
File: app/src/modules/users/services/usersApi.service.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type {
  User,
  CreateUserDto,
  UpdateUserDto,
  UsersQuery,
  UsersResponse,
} from '../types';
export const usersApiService = {
  async findAll(params?: UsersQuery): Promise<UsersResponse> {
    const queryParams: Record<string, any> = {};
    if (params?.page) queryParams.page = params.page.toString();
    if (params?.limit) queryParams.limit = params.limit.toString();
    if (params?.search) queryParams.search = params.search;
    if (params?.sortBy) queryParams.sortBy = params.sortBy;
    if (params?.sortOrder) queryParams.sortOrder = params.sortOrder;
    if (params?.filters) {
      if (params.filters.isActive !== undefined) {
        queryParams['filters[isActive]'] = params.filters.isActive.toString();
      }
      if (params.filters.roles && params.filters.roles.length > 0) {
        queryParams['filters[roles]'] = JSON.stringify(params.filters.roles);
      }
    }
    const response = await apiClient.get(API_PATHS.USERS, {
      params: queryParams,
    });
    return response.data;
  },
  async findOne(id: string): Promise<User> {
    const response = await apiClient.get(
      API_PATHS.USERS_BY_ID.replace(':id', id),
    );
    return response.data;
  },
  async create(data: CreateUserDto): Promise<User> {
    const response = await apiClient.post(API_PATHS.USERS, data);
    return response.data;
  },
  async update(id: string, data: UpdateUserDto): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      data,
    );
    return response.data;
  },
  async remove(id: string): Promise<void> {
    await apiClient.delete(API_PATHS.USERS_BY_ID.replace(':id', id));
  },
  async resetPassword(id: string, newPassword: string): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      {
        password: newPassword,
      },
    );
    return response.data;
  },
  async toggleActive(id: string, isActive: boolean): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      {
        isActive,
      },
    );
    return response.data;
  },
};

================
File: app/src/services/serverConnectionService.ts
================
import { discoveryService } from '@/app/services/discoveryService';
import { healthMonitoringService } from '@/services/healthMonitoringService';
import { autoReconnectService } from '@/services/autoReconnectService';
import EncryptedStorage from '@/app/services/secureStorageService';
import NetInfo from '@react-native-community/netinfo';
export type ConnectionMode = 'auto' | 'manual';
interface ConnectionState {
  isConnected: boolean;
  isConnecting: boolean;
  lastError: string | null;
  mode: ConnectionMode;
  currentUrl: string | null;
  hasWifi: boolean;
  isHealthy: boolean;
  isSearching: boolean;
  error: string | null;
}
class ServerConnectionService {
  private state: ConnectionState = {
    isConnected: false,
    isConnecting: false,
    lastError: null,
    mode: 'auto',
    currentUrl: null,
    hasWifi: false,
    isHealthy: false,
    isSearching: false,
    error: null,
  };
  private listeners: Array<(state: ConnectionState) => void> = [];
  private connectionPromise: Promise<void> | null = null;
  private healthUnsubscribe: (() => void) | null = null;
  private reconnectUnsubscribe: (() => void) | null = null;
  private netInfoUnsubscribe: (() => void) | null = null;
  constructor() {
    this.loadConnectionMode();
    this.initializeListeners();
    setTimeout(() => {
      if (!this.state.isConnected && !this.state.isConnecting) {
        this.connect().catch(() => {});
      }
    }, 1000);
  }
  private async loadConnectionMode() {
    try {
      const savedMode = (await EncryptedStorage.getItem(
        'connection_mode',
      )) as ConnectionMode;
      if (savedMode) {
        this.state.mode = savedMode;
      }
    } catch (error) {}
  }
  private initializeListeners() {
    this.netInfoUnsubscribe = NetInfo.addEventListener((state) => {
      const hasWifi =
        !!state.isConnected &&
        (state.type === 'wifi' || state.type === 'ethernet');
      const previousHasWifi = this.state.hasWifi;
      if (!hasWifi && previousHasWifi) {
        this.updateState({
          hasWifi: false,
          isConnected: false,
          isHealthy: false,
          error: 'Sin conexión WiFi',
        });
        healthMonitoringService.stopMonitoring();
      }
      else if (hasWifi && !previousHasWifi) {
        this.updateState({ hasWifi });
        setTimeout(() => {
          if (!this.state.isConnected && !this.state.isConnecting) {
            this.connect().catch(() => {});
          }
        }, 1000);
      } else {
        this.updateState({ hasWifi });
      }
    });
    this.healthUnsubscribe = healthMonitoringService.subscribe(
      (healthState) => {
        const previousHealthy = this.state.isHealthy;
        this.updateState({
          isHealthy: healthState.isAvailable,
          error: healthState.message || this.state.error,
        });
        if (!previousHealthy && healthState.isAvailable && this.state.hasWifi) {
          this.updateState({
            isConnected: true,
            isHealthy: true,
            error: null,
            isSearching: false,
          });
        }
      },
    );
    this.reconnectUnsubscribe = autoReconnectService.subscribe(
      (reconnectState) => {
        this.updateState({
          isSearching: reconnectState.isReconnecting,
          error: reconnectState.lastError || this.state.error,
        });
      },
    );
    autoReconnectService.on('reconnected', async () => {
      const apiUrl = await discoveryService.getApiUrl();
      const { reinitializeApiClient } = await import(
        '@/app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl);
      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
        lastError: null,
        isSearching: false,
      });
      healthMonitoringService.startMonitoring();
    });
    healthMonitoringService.on('recovered', async () => {
      const apiUrl = await discoveryService.getApiUrl();
      const { reinitializeApiClient } = await import(
        '@/app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl);
      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
        lastError: null,
        isSearching: false,
      });
      if (!healthMonitoringService.isMonitoring()) {
        healthMonitoringService.startMonitoring();
      }
    });
    NetInfo.fetch().then((state) => {
      const hasWifi =
        !!state.isConnected &&
        (state.type === 'wifi' || state.type === 'ethernet');
      this.updateState({ hasWifi });
      if (hasWifi && !this.state.isConnected && !this.state.isConnecting) {
        setTimeout(() => {
          this.connect().catch(() => {});
        }, 1000);
      }
    });
  }
  async setConnectionMode(mode: ConnectionMode) {
    this.state.mode = mode;
    if (mode === 'manual') {
      const url = await discoveryService.getApiUrl();
      if (url) {
        this.updateState({ currentUrl: url });
      }
    }
    this.notifyListeners();
  }
  getConnectionMode(): ConnectionMode {
    return this.state.mode;
  }
  async connect(): Promise<void> {
    if (this.connectionPromise) {
      return this.connectionPromise;
    }
    this.connectionPromise = this.performConnection();
    try {
      await this.connectionPromise;
    } finally {
      this.connectionPromise = null;
    }
  }
  private async performConnection(): Promise<void> {
    this.updateState({ isConnecting: true, lastError: null });
    try {
      let apiUrl: string | null = null;
      switch (this.state.mode) {
        case 'auto':
          apiUrl = await discoveryService.getLastKnownUrl();
          if (apiUrl) {
            const isHealthy =
              await healthMonitoringService.checkHealthWithUrl(apiUrl);
            if (!isHealthy) {
              apiUrl = await discoveryService.discoverServer();
            }
          } else {
            apiUrl = await discoveryService.discoverServer();
          }
          break;
        case 'manual':
          apiUrl = await discoveryService.getApiUrl();
          if (!apiUrl) {
            throw new Error('No se ha configurado una URL manual');
          }
          break;
      }
      if (!apiUrl) {
        throw new Error('No se pudo establecer conexión con el servidor');
      }
      if (this.state.mode === 'auto') {
        await discoveryService.setServerUrl(apiUrl, false);
      }
      const isHealthy =
        await healthMonitoringService.checkHealthWithUrl(apiUrl);
      if (!isHealthy) {
        throw new Error('El servidor no está respondiendo correctamente');
      }
      healthMonitoringService.startMonitoring();
      const { reinitializeApiClient } = await import(
        '@/app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl);
      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
      });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Error desconocido';
      this.updateState({
        isConnected: false,
        isConnecting: false,
        lastError: errorMessage,
        error: errorMessage,
        isHealthy: false,
      });
      throw error;
    }
  }
  async reconnect(): Promise<void> {
    return this.connect();
  }
  retry(): void {
    if (!this.state.isConnected && this.state.hasWifi) {
      autoReconnectService.startAutoReconnect();
    } else if (!this.state.hasWifi) {
      this.updateState({
        error: 'Sin conexión WiFi',
        lastError: 'Sin conexión WiFi',
      });
    }
  }
  async disconnect(): void {
    healthMonitoringService.stopMonitoring();
    autoReconnectService.stopAutoReconnect();
    this.updateState({
      isConnected: false,
      isConnecting: false,
      currentUrl: null,
      isHealthy: false,
    });
  }
  destroy() {
    if (this.healthUnsubscribe) {
      this.healthUnsubscribe();
    }
    if (this.reconnectUnsubscribe) {
      this.reconnectUnsubscribe();
    }
    if (this.netInfoUnsubscribe) {
      this.netInfoUnsubscribe();
    }
    autoReconnectService.off('reconnected');
    healthMonitoringService.off('recovered');
  }
  subscribe(listener: (state: ConnectionState) => void): () => void {
    this.listeners.push(listener);
    listener(this.state);
    return () => {
      this.listeners = this.listeners.filter((l) => l !== listener);
    };
  }
  getState(): ConnectionState {
    return { ...this.state };
  }
  isConnected(): boolean {
    return this.state.isConnected;
  }
  getCurrentUrl(): string | null {
    return this.state.currentUrl;
  }
  private updateState(updates: Partial<ConnectionState>): void {
    this.state = { ...this.state, ...updates };
    this.notifyListeners();
  }
  private notifyListeners(): void {
    this.listeners.forEach((listener) => listener(this.state));
  }
}
export const serverConnectionService = new ServerConnectionService();

================
File: backend/docs/installing-and-running.md
================
# Installation

NestJS Boilerplate uses [TypeORM](https://www.npmjs.com/package/typeorm) with [PostgreSQL](https://www.postgresql.org/) as the main database.

---

## Table of Contents <!-- omit in toc -->

- [Comfortable development](#comfortable-development)
  - [Video guideline](#video-guideline)
- [Quick run](#quick-run)
- [Links](#links)

---

## Comfortable development

1. Clone repository

   ```bash
   git clone --depth 1 https://github.com/brocoders/nestjs-boilerplate.git my-app
   ```

1. Go to folder, and copy `env-example-relational` as `.env`.

   ```bash
   cd my-app/
   cp env-example-relational .env
   ```

1. Change `DATABASE_HOST=postgres` to `DATABASE_HOST=localhost`

   Change `MAIL_HOST=maildev` to `MAIL_HOST=localhost`

1. Run additional container:

   ```bash
   docker compose up -d postgres adminer maildev
   ```

1. Install dependency

   ```bash
   npm install
   ```

1. Run app configuration

   > You should run this command only the first time on initialization of your project, all next time skip it.

   > If you want to contribute to the boilerplate, you should NOT run this command.

   ```bash
   npm run app:config
   ```

1. Run migrations

   ```bash
   npm run migration:run
   ```

   > **Nota para usuarios de Windows**: Si encuentras el error `/usr/bin/bash: Files\Git\bin\bash.exe: No such file or directory`, esto se debe a que `env-cmd` tiene problemas con las rutas de Git Bash que contienen espacios.
   > 
   > Para **generar** nuevas migraciones, en lugar de usar:
   > ```bash
   > npm run migration:generate -- src/database/migrations/MigrationName
   > ```
   > Usa este comando alternativo:
   > ```bash
   > npx typeorm-ts-node-commonjs migration:generate -d src/database/data-source.ts src/database/migrations/MigrationName
   > ```
   > 
   > Para **ejecutar** migraciones, en lugar de usar:
   > ```bash
   > npm run migration:run
   > ```
   > Usa este comando alternativo:
   > ```bash
   > npx typeorm-ts-node-commonjs migration:run -d src/database/data-source.ts
   > ```
   > 
   > Estos comandos evitan el problema con env-cmd y funcionan correctamente en Windows.

1. Run seeds

   ```bash
   npm run seed:run:relational
   ```

1. Run app in dev mode

   ```bash
   npm run start:dev
   ```

1. Open <http://localhost:3000>

### Video guideline

<https://github.com/user-attachments/assets/136a16aa-f94a-4b20-8eaf-6b4262964315>

---

## Quick run

If you want quick run your app, you can use following commands:

1. Clone repository

   ```bash
   git clone --depth 1 https://github.com/brocoders/nestjs-boilerplate.git my-app
   ```

1. Go to folder, and copy `env-example-relational` as `.env`.

   ```bash
   cd my-app/
   cp env-example-relational .env
   ```

1. Run containers

   ```bash
   docker compose up -d
   ```

1. For check status run

   ```bash
   docker compose logs
   ```

1. Open <http://localhost:3000>

---

## Links

- Swagger (API docs): <http://localhost:3000/docs>
- Adminer (client for DB): <http://localhost:8080>
- Maildev: <http://localhost:1080>

---

Previous: [Introduction](introduction.md)

Next: [Architecture](architecture.md)

================
File: backend/src/app-config/app-config.controller.ts
================
import { Controller, Get, HttpCode, HttpStatus } from '@nestjs/common';
import { ApiOkResponse, ApiTags } from '@nestjs/swagger';
@ApiTags('App Config')
@Controller({
  path: 'app-config',
  version: '1',
})
export class AppConfigController {
  @Get()
  @ApiOkResponse({
    description: 'Get app configuration',
  })
  @HttpCode(HttpStatus.OK)
  getConfig() {
    const apiKey = process.env.GOOGLE_MAPS_API_KEY || '';
    return {
      maps: {
        apiKey,
      },
    };
  }
}

================
File: backend/src/app-config/app-config.module.ts
================
import { Module } from '@nestjs/common';
import { AppConfigController } from './app-config.controller';
@Module({
  controllers: [AppConfigController],
})
export class AppConfigModule {}

================
File: backend/src/app.module.ts
================
import { Module } from '@nestjs/common';
import { UsersModule } from './users/users.module';
import { FilesModule } from './files/files.module';
import { AuthModule } from './auth/auth.module';
import databaseConfig from './database/config/database.config';
import authConfig from './auth/config/auth.config';
import appConfig from './config/app.config';
import mailConfig from './mail/config/mail.config';
import fileConfig from './files/config/file.config';
import syncConfig from './sync/config/sync.config';
import audioOrderConfig from './audio-order-processing/config/audio-order.config';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TypeOrmConfigService } from './database/typeorm-config.service';
import { MailModule } from './mail/mail.module';
import { HomeModule } from './home/home.module';
import { DataSource, DataSourceOptions } from 'typeorm';
import { SessionModule } from './session/session.module';
import { MailerModule } from './mailer/mailer.module';
import { AreasModule } from './areas/areas.module';
import { TablesModule } from './tables/tables.module';
import { CategoriesModule } from './categories/categories.module';
import { SubcategoriesModule } from './subcategories/subcategories.module';
import { ProductsModule } from './products/products.module';
import { ProductVariantsModule } from './product-variants/product-variants.module';
import { ModifierGroupsModule } from './modifier-groups/modifier-groups.module';
import { ProductModifiersModule } from './product-modifiers/product-modifiers.module';
import { OrdersModule } from './orders/orders.module';
import { PaymentsModule } from './payments/payments.module';
import { ThermalPrintersModule } from './thermal-printers/thermal-printers.module';
import { CustomersModule } from './customers/customers.module';
import { PreparationScreensModule } from './preparation-screens/preparation-screens.module';
import { CommonModule } from './common/common.module';
import { AvailabilityModule } from './availability/availability.module';
import { AdjustmentsModule } from './adjustments/adjustments.module';
import { RestaurantConfigModule } from './restaurant-config/restaurant-config.module';
import { PizzaCustomizationsModule } from './pizza-customizations/pizza-customizations.module';
import { PizzaConfigurationsModule } from './pizza-configurations/pizza-configurations.module';
import { SyncModule } from './sync/sync.module';
import { AudioOrderProcessingModule } from './audio-order-processing/audio-order-processing.module';
import { DiscoveryModule } from './discovery/discovery.module';
import { KitchenModule } from './kitchen/kitchen.module';
import { HealthModule } from './health/health.module';
import { ShiftsModule } from './shifts/shifts.module';
import { AppConfigModule } from './app-config/app-config.module';
const infrastructureDatabaseModule = TypeOrmModule.forRootAsync({
  useClass: TypeOrmConfigService,
  dataSourceFactory: async (options: DataSourceOptions) => {
    return new DataSource(options).initialize();
  },
});
@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [
        databaseConfig,
        authConfig,
        appConfig,
        mailConfig,
        fileConfig,
        syncConfig,
        audioOrderConfig,
      ],
      envFilePath: ['.env'],
    }),
    infrastructureDatabaseModule,
    CommonModule,
    UsersModule,
    FilesModule,
    AuthModule,
    SessionModule,
    MailModule,
    MailerModule,
    HomeModule,
    AreasModule,
    TablesModule,
    CategoriesModule,
    SubcategoriesModule,
    ProductsModule,
    ProductVariantsModule,
    ModifierGroupsModule,
    ProductModifiersModule,
    OrdersModule,
    PaymentsModule,
    ThermalPrintersModule,
    CustomersModule,
    PreparationScreensModule,
    AvailabilityModule,
    AdjustmentsModule,
    RestaurantConfigModule,
    PizzaCustomizationsModule,
    PizzaConfigurationsModule,
    SyncModule,
    AudioOrderProcessingModule,
    DiscoveryModule,
    KitchenModule,
    HealthModule,
    ShiftsModule,
    AppConfigModule,
  ],
})
export class AppModule {}

================
File: backend/src/audio-order-processing/services/audio-order-processing.service.ts
================
import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';
import { AxiosError } from 'axios';
import {
  ProcessAudioOrderDto,
  AudioOrderResponseDto,
  CloudApiRequestDto,
  CloudApiResponseDto,
} from '../dto/process-audio-order.dto';
@Injectable()
export class AudioOrderProcessingService {
  private readonly logger = new Logger(AudioOrderProcessingService.name);
  private readonly cloudApiUrl: string;
  private readonly cloudApiKey: string;
  private readonly isEnabled: boolean;
  private readonly timeout: number;
  private readonly maxAudioSizeMb: number;
  constructor(
    private readonly configService: ConfigService,
    private readonly httpService: HttpService,
  ) {
    const audioConfig = this.configService.get<any>('audioOrder');
    this.isEnabled = audioConfig?.enabled || false;
    this.cloudApiUrl = audioConfig?.cloudApiUrl || '';
    this.cloudApiKey = audioConfig?.cloudApiKey || '';
    this.timeout = audioConfig?.timeout || 30000;
    this.maxAudioSizeMb = audioConfig?.maxAudioSizeMb || 10;
    if (!this.cloudApiUrl || !this.cloudApiKey) {
      this.logger.warn(
        'Audio order processing missing configuration (CLOUD_API_URL or CLOUD_API_KEY)',
      );
    }
  }
  async processAudioOrder(
    dto: ProcessAudioOrderDto,
  ): Promise<AudioOrderResponseDto> {
    try {
      if (!this.isEnabled) {
        throw new BadRequestException(
          'El procesamiento de audio no está habilitado',
        );
      }
      const audioSizeMb = this.calculateBase64SizeMb(dto.audioData);
      if (audioSizeMb > this.maxAudioSizeMb) {
        throw new BadRequestException(
          `El archivo de audio excede el tamaño máximo permitido de ${this.maxAudioSizeMb}MB`,
        );
      }
      const cloudRequest: CloudApiRequestDto = {
        audio: dto.audioData,
        transcript: dto.transcription,
        metadata: {
          customerId: dto.customerId,
          orderId: dto.orderId,
          timestamp: new Date().toISOString(),
        },
      };
      const cloudResponse = await this.callCloudApi(cloudRequest);
      if (cloudResponse.success === false || cloudResponse.error) {
        return {
          success: false,
          message: 'No se pudo procesar el audio',
          error: cloudResponse.error || {
            code: 'PROCESSING_ERROR',
            message: 'Error desconocido al procesar el audio',
          },
        };
      }
      const result = await this.processCloudResponse(
        cloudResponse.data || cloudResponse,
      );
      return result;
    } catch (error) {
      this.logger.error('Error processing audio order:', error);
      if (error instanceof BadRequestException) {
        throw error;
      }
      return {
        success: false,
        message: 'Error al procesar la orden de audio',
        error: {
          code: 'INTERNAL_ERROR',
          message: error.message || 'Error interno del servidor',
        },
      };
    }
  }
  private async callCloudApi(
    request: CloudApiRequestDto,
  ): Promise<CloudApiResponseDto> {
    try {
      const audioBuffer = Buffer.from(request.audio, 'base64');
      const FormData = require('form-data');
      const formData = new FormData();
      formData.append('audio', audioBuffer, {
        filename: `order_${Date.now()}.mp4`,
        contentType: 'audio/mp4',
      });
      formData.append('transcription', request.transcript);
      const response = await firstValueFrom(
        this.httpService.post<any>(
          `${this.cloudApiUrl}/api/v1/audio/process-order`,
          formData,
          {
            headers: {
              ...formData.getHeaders(),
              'X-API-Key': this.cloudApiKey,
            },
            timeout: this.timeout,
          },
        ),
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      this.logger.error('Cloud API call failed:', axiosError.message);
      if (axiosError.response?.data) {
        return axiosError.response.data as CloudApiResponseDto;
      }
      return {
        success: false,
        error: {
          code: 'CLOUD_API_ERROR',
          message: 'Error al comunicarse con el servidor de procesamiento',
        },
      };
    }
  }
  private async processCloudResponse(
    data: any,
  ): Promise<AudioOrderResponseDto> {
    const orderType = data.orderType || 'DELIVERY';
    return {
      success: true,
      message: 'Audio procesado exitosamente',
      extractedData: {
        orderItems: data.orderItems || [],
        deliveryInfo: data.deliveryInfo || {},
        scheduledDelivery: data.scheduledDelivery || {},
        orderType: orderType,
        warnings: data.warnings,
        processingTime: data.processingTime,
      },
    };
  }
  private calculateBase64SizeMb(base64String: string): number {
    const base64Data = base64String.split(',')[1] || base64String;
    const sizeInBytes = (base64Data.length * 3) / 4;
    return sizeInBytes / (1024 * 1024);
  }
  async checkServiceHealth(): Promise<{
    status: string;
    available: boolean;
    message: string;
    timestamp: string;
  }> {
    try {
      if (!this.isEnabled) {
        return {
          status: 'disabled',
          available: false,
          message: 'El servicio de procesamiento de audio está deshabilitado',
          timestamp: new Date().toISOString(),
        };
      }
      if (!this.cloudApiUrl || !this.cloudApiKey) {
        return {
          status: 'misconfigured',
          available: false,
          message: 'Configuración del servicio incompleta',
          timestamp: new Date().toISOString(),
        };
      }
      const healthCheckUrl = this.cloudApiUrl.includes('/api/v1/audio')
        ? `${this.cloudApiUrl}/health`
        : `${this.cloudApiUrl}/api/v1/audio/health`;
      const response = await firstValueFrom(
        this.httpService.get(healthCheckUrl, {
          headers: {
            'X-API-Key': this.cloudApiKey,
          },
          timeout: 5000,
        }),
      );
      if (response.status === 200) {
        return {
          status: 'ok',
          available: true,
          message: 'Servicio de procesamiento de audio disponible',
          timestamp: new Date().toISOString(),
        };
      }
      return {
        status: 'error',
        available: false,
        message: 'Servicio no responde correctamente',
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      this.logger.error('Error verificando salud del servicio:', error);
      let message = 'No se puede conectar con el servicio de procesamiento';
      if (error instanceof AxiosError) {
        if (error.code === 'ECONNREFUSED') {
          message = 'Servicio de procesamiento no disponible';
        } else if (error.code === 'ETIMEDOUT') {
          message = 'Tiempo de espera agotado al conectar con el servicio';
        }
      }
      return {
        status: 'error',
        available: false,
        message,
        timestamp: new Date().toISOString(),
      };
    }
  }
}

================
File: backend/src/categories/categories.controller.ts
================
import {
  Get,
  HttpCode,
  HttpStatus,
  Controller,
  Post,
  Body,
  Query,
  Param,
  Patch,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { ApiOperation, ApiTags, ApiBearerAuth } from '@nestjs/swagger';
import { CategoriesService } from './categories.service';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';
import { FindAllCategoriesDto } from './dto/find-all-categories.dto';
import { Category } from './domain/category';
import { AuthGuard } from '@nestjs/passport';
import { Paginated } from '../common/types/paginated.type';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
@ApiTags('Categorías')
@Controller({ path: 'categories', version: '1' })
export class CategoriesController {
  constructor(private readonly service: CategoriesService) {}
  @Post()
  @ApiOperation({ summary: 'Create a new category' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.CREATED)
  create(@Body() dto: CreateCategoryDto): Promise<Category> {
    return this.service.create(dto);
  }
  @Get()
  @ApiOperation({ summary: 'Find all categories' })
  @HttpCode(HttpStatus.OK)
  findAll(@Query() q: FindAllCategoriesDto): Promise<Paginated<Category>> {
    return this.service.findAllPaginated(q);
  }
  @Get('full-menu')
  @ApiOperation({
    summary:
      'Obtener el menú completo (categorías, subcategorías, productos, modificadores)',
  })
  @HttpCode(HttpStatus.OK)
  getFullMenu(): Promise<Category[]> {
    return this.service.getFullMenu();
  }
  @Get('order-menu')
  @ApiOperation({
    summary: 'Obtener el menú para creación de órdenes',
    description:
      'Endpoint optimizado que devuelve solo los campos necesarios para la creación y edición de órdenes, ' +
      'excluyendo timestamps y otros campos innecesarios para reducir el ancho de banda.',
  })
  @HttpCode(HttpStatus.OK)
  getOrderMenu(): Promise<Category[]> {
    return this.service.getOrderMenu();
  }
  @Get(':id')
  @ApiOperation({ summary: 'Find one category by ID' })
  @HttpCode(HttpStatus.OK)
  findOne(@Param('id') id: string): Promise<Category> {
    return this.service.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({ summary: 'Update a category' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  update(
    @Param('id') id: string,
    @Body() dto: UpdateCategoryDto,
  ): Promise<Category | null> {
    return this.service.update(id, dto);
  }
  @Delete(':id')
  @ApiOperation({ summary: 'Remove a category' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async remove(@Param('id') id: string): Promise<void> {
    await this.service.remove(id);
  }
}

================
File: backend/src/categories/categories.service.ts
================
import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { CategoryRepository } from './infrastructure/persistence/category.repository';
import { CATEGORY_REPOSITORY } from '../common/tokens';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';
import { Category } from './domain/category';
import { FindAllCategoriesDto } from './dto/find-all-categories.dto';
import { BaseCrudService } from '../common/application/base-crud.service';
import { Paginated } from '../common/types/paginated.type';
import {
  CustomIdService,
  EntityPrefix,
} from '../common/services/custom-id.service';
@Injectable()
export class CategoriesService extends BaseCrudService<
  Category,
  CreateCategoryDto,
  UpdateCategoryDto,
  FindAllCategoriesDto
> {
  constructor(
    @Inject(CATEGORY_REPOSITORY) repo: CategoryRepository,
    private readonly customIdService: CustomIdService,
  ) {
    super(repo);
  }
  async create(createCategoryDto: CreateCategoryDto): Promise<Category> {
    const id = await this.customIdService.generateId(
      EntityPrefix.CATEGORY,
      'category',
    );
    const categoryData = {
      ...createCategoryDto,
      id,
    } as any;
    return this.repo.create(categoryData);
  }
  async update(
    id: string,
    updateCategoryDto: UpdateCategoryDto,
  ): Promise<Category> {
    const result = await this.repo.update(id, updateCategoryDto);
    if (!result) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return result;
  }
  async findAllPaginated(
    filter?: FindAllCategoriesDto,
  ): Promise<Paginated<Category>> {
    const page = filter?.page || 1;
    const limit = filter?.limit || 10;
    const allItems = await this.findAll(filter);
    return new Paginated(allItems, allItems.length, page, limit);
  }
  async getFullMenu(): Promise<Category[]> {
    return (this.repo as CategoryRepository).findFullMenu();
  }
  async getOrderMenu(): Promise<Category[]> {
    return (this.repo as CategoryRepository).findOrderMenu();
  }
}

================
File: backend/src/config/app.config.ts
================
import { registerAs } from '@nestjs/config';
import { AppConfig } from './app-config.type';
import validateConfig from '../utils/validate-config';
import {
  IsEnum,
  IsInt,
  IsOptional,
  IsString,
  IsUrl,
  Max,
  Min,
} from 'class-validator';
enum Environment {
  Development = 'development',
  Production = 'production',
  Test = 'test',
}
class EnvironmentVariablesValidator {
  @IsEnum(Environment)
  @IsOptional()
  NODE_ENV: Environment;
  @IsInt()
  @Min(0)
  @Max(65535)
  @IsOptional()
  APP_PORT: number;
  @IsUrl({ require_tld: false })
  @IsOptional()
  FRONTEND_DOMAIN: string;
  @IsUrl({ require_tld: false })
  @IsOptional()
  BACKEND_DOMAIN: string;
  @IsString()
  @IsOptional()
  API_PREFIX: string;
  @IsString()
  @IsOptional()
  APP_FALLBACK_LANGUAGE: string;
  @IsString()
  @IsOptional()
  APP_HEADER_LANGUAGE: string;
  @IsUrl({ require_tld: false })
  @IsOptional()
  REMOTE_URL: string;
}
export default registerAs<AppConfig>('app', () => {
  validateConfig(process.env, EnvironmentVariablesValidator);
  return {
    nodeEnv: process.env.NODE_ENV || 'development',
    name: process.env.APP_NAME || 'app',
    workingDirectory: process.env.PWD || process.cwd(),
    frontendDomain: process.env.FRONTEND_DOMAIN,
    backendDomain: process.env.BACKEND_DOMAIN ?? 'http://localhost',
    port: process.env.APP_PORT
      ? parseInt(process.env.APP_PORT, 10)
      : process.env.PORT
        ? parseInt(process.env.PORT, 10)
        : 3000,
    apiPrefix: process.env.API_PREFIX || 'api',
    fallbackLanguage: process.env.APP_FALLBACK_LANGUAGE || 'en',
    headerLanguage: process.env.APP_HEADER_LANGUAGE || 'x-custom-lang',
    remoteUrl: process.env.REMOTE_URL,
  };
});

================
File: backend/src/customers/addresses.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus,
  HttpCode,
  UseGuards,
  NotFoundException,
} from '@nestjs/common';
import {
  ApiTags,
  ApiBearerAuth,
  ApiOperation,
  ApiParam,
} from '@nestjs/swagger';
import { Address } from './domain/address';
import { CreateAddressDto } from './dto/create-address.dto';
import { UpdateAddressDto } from './dto/update-address.dto';
import { FindAllAddressesDto } from './dto/find-all-addresses.dto';
import { AddressesService } from './addresses.service';
import { RoleEnum } from '../roles/roles.enum';
import { Roles } from '../roles/roles.decorator';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
@ApiTags('Addresses')
@Controller({ path: 'addresses', version: '1' })
export class AddressesController {
  constructor(private readonly addressesService: AddressesService) {}
  @Post()
  @ApiOperation({ summary: 'Create a new address' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createAddressDto: CreateAddressDto): Promise<Address> {
    return this.addressesService.create(createAddressDto);
  }
  @Get()
  @ApiOperation({ summary: 'Find all addresses' })
  @HttpCode(HttpStatus.OK)
  findAll(@Query() query: FindAllAddressesDto): Promise<Address[]> {
    return this.addressesService.findAll(query);
  }
  @Get(':id')
  @ApiOperation({ summary: 'Find one address by ID' })
  @ApiParam({ name: 'id', description: 'Address ID' })
  @HttpCode(HttpStatus.OK)
  findOne(@Param('id') id: string): Promise<Address> {
    return this.addressesService.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({ summary: 'Update an address' })
  @ApiParam({ name: 'id', description: 'Address ID' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  async update(
    @Param('id') id: string,
    @Body() updateAddressDto: UpdateAddressDto,
  ): Promise<Address> {
    const result = await this.addressesService.update(id, updateAddressDto);
    if (!result) {
      throw new NotFoundException('Address not found');
    }
    return result;
  }
  @Delete(':id')
  @ApiOperation({ summary: 'Remove an address' })
  @ApiParam({ name: 'id', description: 'Address ID' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async remove(@Param('id') id: string): Promise<void> {
    await this.addressesService.remove(id);
  }
}

================
File: backend/src/customers/dto/create-customer.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsArray,
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsDateString,
  IsBoolean,
  MaxLength,
  ValidateNested,
} from 'class-validator';
import { Type, Transform } from 'class-transformer';
import { CreateAddressDto } from './create-address.dto';
export class CreateCustomerDto {
  @ApiPropertyOptional({
    type: String,
    example: 'Juan',
    description: 'Nombre del cliente (opcional)',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  firstName?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'Pérez',
    description: 'Apellido del cliente (opcional)',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  lastName?: string;
  @ApiProperty({
    type: String,
    example: '+525512345678',
    description: 'Número de WhatsApp del cliente (obligatorio)',
  })
  @IsNotEmpty({ message: 'El número de WhatsApp es obligatorio' })
  @IsString()
  @MaxLength(20, { message: 'El número de teléfono es demasiado largo' })
  whatsappPhoneNumber: string;
  @ApiPropertyOptional({
    type: String,
    example: 'juan.perez@example.com',
    description: 'Correo electrónico del cliente (opcional, debe ser único)',
  })
  @Transform(({ value }) => (value === '' ? undefined : value))
  @IsOptional()
  @IsEmail({}, { message: 'El correo electrónico no es válido' })
  @MaxLength(255)
  email?: string;
  @ApiPropertyOptional({
    type: String,
    example: '1990-01-15',
    description: 'Fecha de nacimiento del cliente',
  })
  @Transform(({ value }) => (value === '' ? undefined : value))
  @IsOptional()
  @IsDateString()
  birthDate?: string;
  @ApiPropertyOptional({
    type: Boolean,
    example: true,
    description: 'Indica si el cliente está activo',
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    description: 'Indica si el cliente está baneado',
  })
  @IsOptional()
  @IsBoolean()
  isBanned?: boolean;
  @ApiPropertyOptional({
    type: () => [CreateAddressDto],
    description: 'Lista de direcciones iniciales para el cliente (opcional)',
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateAddressDto)
  addresses?: CreateAddressDto[];
}

================
File: backend/src/customers/dto/update-customer.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsEmail,
  IsOptional,
  IsString,
  IsDateString,
  IsBoolean,
  IsArray,
  MaxLength,
} from 'class-validator';
import { Transform } from 'class-transformer';
export class UpdateCustomerDto {
  @ApiPropertyOptional({
    type: String,
    example: 'Juan',
    description: 'Nombre del cliente',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  firstName?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'Pérez',
    description: 'Apellido del cliente',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  lastName?: string;
  @ApiPropertyOptional({
    type: String,
    example: '+525512345678',
    description: 'Número de WhatsApp del cliente',
  })
  @IsOptional()
  @IsString()
  @MaxLength(20, { message: 'El número de teléfono es demasiado largo' })
  whatsappPhoneNumber?: string;
  @ApiPropertyOptional({
    type: String,
    example: 'juan.perez@example.com',
    description: 'Correo electrónico del cliente (debe ser único)',
  })
  @Transform(({ value }) => (value === '' ? undefined : value))
  @IsOptional()
  @IsEmail({}, { message: 'El correo electrónico no es válido' })
  @MaxLength(255)
  email?: string | null;
  @ApiPropertyOptional({
    type: String,
    example: '1990-01-15',
    description: 'Fecha de nacimiento del cliente',
  })
  @Transform(({ value }) => (value === '' ? undefined : value))
  @IsOptional()
  @IsDateString()
  birthDate?: string | null;
  @ApiPropertyOptional({
    type: Boolean,
    example: true,
    description: 'Indica si el cliente está activo',
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    description: 'Indica si el cliente está baneado',
  })
  @IsOptional()
  @IsBoolean()
  isBanned?: boolean;
  @ApiPropertyOptional({
    type: 'array',
    description:
      'Historial completo de chat (para actualizaciones específicas)',
  })
  @IsOptional()
  @IsArray()
  fullChatHistory?: any[];
  @ApiPropertyOptional({
    type: 'array',
    description: 'Historial relevante de chat',
  })
  @IsOptional()
  @IsArray()
  relevantChatHistory?: any[];
  @ApiPropertyOptional({
    type: String,
    format: 'date-time',
    description: 'Última interacción con el cliente',
  })
  @IsOptional()
  @IsDateString()
  lastInteraction?: string;
}

================
File: backend/src/customers/infrastructure/persistence/relational/repositories/address.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, FindOptionsWhere, ILike } from 'typeorm';
import { AddressEntity } from '../entities/address.entity';
import { AddressRepository } from '../../address.repository';
import { Address } from '../../../../domain/address';
import { AddressMapper } from '../mappers/address.mapper';
import { BaseRelationalRepository } from '../../../../../common/infrastructure/persistence/relational/base-relational.repository';
import { CreateAddressDto } from '../../../../dto/create-address.dto';
import { UpdateAddressDto } from '../../../../dto/update-address.dto';
import { FindAllAddressesDto } from '../../../../dto/find-all-addresses.dto';
@Injectable()
export class AddressRelationalRepository
  extends BaseRelationalRepository<
    AddressEntity,
    Address,
    FindAllAddressesDto,
    CreateAddressDto,
    UpdateAddressDto
  >
  implements AddressRepository
{
  constructor(
    @InjectRepository(AddressEntity)
    ormRepo: Repository<AddressEntity>,
    mapper: AddressMapper,
  ) {
    super(ormRepo, mapper);
  }
  protected override buildWhere(
    filter?: FindAllAddressesDto,
  ): FindOptionsWhere<AddressEntity> | undefined {
    const where: FindOptionsWhere<AddressEntity> = {};
    if (filter?.customerId) {
      where.customer = { id: filter.customerId } as any;
    }
    if (filter?.isDefault !== undefined) {
      where.isDefault = filter.isDefault;
    }
    if (filter?.zipCode) {
      where.zipCode = filter.zipCode;
    }
    if (filter?.city) {
      where.city = ILike(`%${filter.city}%`);
    }
    return Object.keys(where).length > 0 ? where : undefined;
  }
  override async update(
    id: Address['id'],
    payload: UpdateAddressDto,
  ): Promise<Address | null> {
    const existing = await this.ormRepo.findOne({
      where: { id } as FindOptionsWhere<AddressEntity>,
      relations: ['customer'],
    });
    if (!existing) {
      return null;
    }
    const updateData = Object.keys(payload).reduce((acc, key) => {
      const value = payload[key];
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {} as any);
    updateData.customer = existing.customer;
    const merged = this.ormRepo.merge(existing, updateData);
    const saved = await this.ormRepo.save(merged);
    return this.mapper.toDomain(saved);
  }
}

================
File: backend/src/customers/infrastructure/persistence/relational/repositories/customer.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  FindOptionsWhere,
  ILike,
  Repository,
  MoreThanOrEqual,
} from 'typeorm';
import { CustomerEntity } from '../entities/customer.entity';
import { CustomerRepository } from '../../customer.repository';
import { Customer } from '../../../../domain/customer';
import { CustomerMapper } from '../mappers/customer.mapper';
import { NullableType } from '../../../../../utils/types/nullable.type';
import { FindAllCustomersDto } from '../../../../dto/find-all-customers.dto';
import { BaseRelationalRepository } from '../../../../../common/infrastructure/persistence/relational/base-relational.repository';
import { CreateCustomerDto } from '../../../../dto/create-customer.dto';
import { UpdateCustomerDto } from '../../../../dto/update-customer.dto';
@Injectable()
export class CustomerRelationalRepository
  extends BaseRelationalRepository<
    CustomerEntity,
    Customer,
    FindAllCustomersDto,
    CreateCustomerDto,
    UpdateCustomerDto
  >
  implements CustomerRepository
{
  constructor(
    @InjectRepository(CustomerEntity)
    ormRepo: Repository<CustomerEntity>,
    mapper: CustomerMapper,
  ) {
    super(ormRepo, mapper);
  }
  protected override buildWhere(
    filter?: FindAllCustomersDto,
  ): FindOptionsWhere<CustomerEntity> | undefined {
    const where: FindOptionsWhere<CustomerEntity> = {};
    if (filter?.firstName) {
      where.firstName = ILike(`%${filter.firstName}%`);
    }
    if (filter?.lastName) {
      where.lastName = ILike(`%${filter.lastName}%`);
    }
    if (filter?.email) {
      where.email = filter.email;
    }
    if (filter?.whatsappPhoneNumber) {
      where.whatsappPhoneNumber = filter.whatsappPhoneNumber;
    }
    if (filter?.isActive !== undefined) {
      where.isActive = filter.isActive;
    }
    if (filter?.lastInteractionAfter) {
      where.lastInteraction = MoreThanOrEqual(filter.lastInteractionAfter);
    }
    if (filter?.isBanned !== undefined) {
      where.isBanned = filter.isBanned;
    }
    return Object.keys(where).length > 0 ? where : undefined;
  }
  async findByEmail(email: Customer['email']): Promise<NullableType<Customer>> {
    if (!email) return null;
    const entity = await this.ormRepo.findOne({
      where: { email },
      relations: ['addresses'],
    });
    return entity ? this.mapper.toDomain(entity) : null;
  }
  async findByPhone(
    phone: Customer['whatsappPhoneNumber'],
  ): Promise<NullableType<Customer>> {
    if (!phone) return null;
    const entity = await this.ormRepo.findOne({
      where: { whatsappPhoneNumber: phone },
      relations: ['addresses'],
    });
    return entity ? this.mapper.toDomain(entity) : null;
  }
  override async findAll(filter?: FindAllCustomersDto): Promise<Customer[]> {
    const where = this.buildWhere(filter);
    const entities = await this.ormRepo.find({
      where,
      relations: ['addresses'],
    });
    return entities
      .map((e) => this.mapper.toDomain(e))
      .filter((d): d is Customer => d !== null);
  }
  override async findById(id: Customer['id']): Promise<NullableType<Customer>> {
    const found = await this.ormRepo.findOne({
      where: { id } as FindOptionsWhere<CustomerEntity>,
      relations: ['addresses'],
    });
    return found ? this.mapper.toDomain(found) : null;
  }
  async findBannedCustomers(): Promise<Customer[]> {
    const entities = await this.ormRepo
      .createQueryBuilder('customer')
      .where('customer.isBanned = :isBanned', { isBanned: true })
      .orderBy('customer.bannedAt', 'DESC')
      .getMany();
    return entities
      .map((entity) => this.mapper.toDomain(entity))
      .filter(Boolean) as Customer[];
  }
}

================
File: backend/src/database/migrations/1737313200000-AddMinimumOrderValueForDelivery.ts
================
import { MigrationInterface, QueryRunner } from 'typeorm';
export class AddMinimumOrderValueForDelivery1737313200000
  implements MigrationInterface
{
  name = 'AddMinimumOrderValueForDelivery1737313200000';
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE "restaurant_config" ADD "minimumOrderValueForDelivery" numeric(10,2) NOT NULL DEFAULT '0'`,
    );
  }
  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE "restaurant_config" DROP COLUMN "minimumOrderValueForDelivery"`,
    );
  }
}

================
File: backend/src/database/migrations/1752788001059-InitialSchema.ts
================
import { MigrationInterface, QueryRunner } from 'typeorm';
export class InitialSchema1752788001059 implements MigrationInterface {
  name = 'InitialSchema1752788001059';
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "role" ("id" integer NOT NULL, "name" character varying NOT NULL, CONSTRAINT "PK_b36bcfe02fc8de3c57a8b2391c2" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "file" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "path" character varying NOT NULL, CONSTRAINT "PK_36b46d232307066b3a2c9ea3a1d" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "category" ("id" character varying(20) NOT NULL, "name" character varying NOT NULL, "description" character varying, "isActive" boolean NOT NULL DEFAULT true, "sortOrder" integer NOT NULL DEFAULT '0', "photo_id" uuid, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "UQ_23c05c292c439d77b0de816b500" UNIQUE ("name"), CONSTRAINT "PK_9c4e4a89e3674fc9f382d733f03" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "subcategory" ("id" character varying(20) NOT NULL, "name" character varying NOT NULL, "description" character varying, "isActive" boolean NOT NULL DEFAULT true, "sortOrder" integer NOT NULL DEFAULT '0', "category_id" character varying(20) NOT NULL, "photo_id" uuid, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_5ad0b82340b411f9463c8e9554d" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "area" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "name" character varying NOT NULL, "description" character varying NOT NULL DEFAULT '', "isActive" boolean NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "UQ_644ffaf8fbde4db798cb47712fe" UNIQUE ("name"), CONSTRAINT "PK_39d5e4de490139d6535d75f42ff" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "table" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "name" character varying NOT NULL, "capacity" integer, "isActive" boolean NOT NULL DEFAULT true, "isAvailable" boolean NOT NULL DEFAULT true, "isTemporary" boolean NOT NULL DEFAULT false, "temporaryIdentifier" character varying, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, "area_id" uuid NOT NULL, CONSTRAINT "PK_28914b55c485fc2d7a101b1b2a4" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "address" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "name" character varying(100) NOT NULL, "street" character varying(200) NOT NULL, "number" character varying(50) NOT NULL, "interiorNumber" character varying(50), "neighborhood" character varying(150), "city" character varying(100), "state" character varying(100), "zipCode" character varying(10), "country" character varying(100), "delivery_instructions" text, "latitude" numeric(10,8), "longitude" numeric(11,8), "isDefault" boolean NOT NULL DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, "customer_id" uuid NOT NULL, CONSTRAINT "PK_d92de1f82754668b5f5f5dd4fd5" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_49bc1e3cd91c06dc434318abd9" ON "address" ("zipCode") `,
    );
    await queryRunner.query(
      `CREATE TABLE "customer" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "firstName" character varying(100), "lastName" character varying(100), "whatsappPhoneNumber" character varying(20) NOT NULL, "stripeCustomerId" character varying(255), "email" character varying(255), "birthDate" date, "fullChatHistory" jsonb, "relevantChatHistory" jsonb, "lastInteraction" TIMESTAMP WITH TIME ZONE, "totalOrders" integer NOT NULL DEFAULT '0', "totalSpent" numeric(10,2) NOT NULL DEFAULT '0', "isActive" boolean NOT NULL DEFAULT true, "isBanned" boolean NOT NULL DEFAULT false, "bannedAt" TIMESTAMP WITH TIME ZONE, "banReason" text, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_a7a13f4cacb744524e44dfdad32" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_2af7646e11a0872eb9a0212545" ON "customer" ("firstName") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_2b5187e7475dcc88f25bec3967" ON "customer" ("lastName") `,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "uq_customer_whatsapp" ON "customer" ("whatsappPhoneNumber") `,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "uq_customer_email" ON "customer" ("email") WHERE email IS NOT NULL`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."shift_status_enum" AS ENUM('OPEN', 'CLOSED')`,
    );
    await queryRunner.query(
      `CREATE TABLE "shift" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "date" date NOT NULL, "global_shift_number" integer NOT NULL, "shift_number" integer NOT NULL DEFAULT '1', "opened_at" TIMESTAMP WITH TIME ZONE NOT NULL, "closed_at" TIMESTAMP WITH TIME ZONE, "initial_cash" numeric(10,2) NOT NULL, "final_cash" numeric(10,2), "total_sales" numeric(10,2), "total_orders" integer, "cash_difference" numeric(10,2), "status" "public"."shift_status_enum" NOT NULL DEFAULT 'OPEN', "notes" text, "close_notes" text, "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deleted_at" TIMESTAMP WITH TIME ZONE, "opened_by_id" uuid, "closed_by_id" uuid, CONSTRAINT "PK_53071a6485a1e9dc75ec3db54b9" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_shift_date_shift_number" ON "shift" ("date", "shift_number") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_shift_status" ON "shift" ("status") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_shift_date" ON "shift" ("date") `,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."payment_paymentmethod_enum" AS ENUM('CASH', 'CREDIT_CARD', 'DEBIT_CARD', 'TRANSFER', 'OTHER')`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."payment_paymentstatus_enum" AS ENUM('PENDING', 'COMPLETED', 'FAILED', 'REFUNDED', 'CANCELLED')`,
    );
    await queryRunner.query(
      `CREATE TABLE "payment" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "paymentMethod" "public"."payment_paymentmethod_enum" NOT NULL DEFAULT 'CASH', "amount" numeric(10,2) NOT NULL, "paymentStatus" "public"."payment_paymentstatus_enum" NOT NULL DEFAULT 'PENDING', "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, "order_id" uuid, CONSTRAINT "PK_fcaec7df5adf9cac408c686b2ab" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."thermal_printer_connectiontype_enum" AS ENUM('NETWORK', 'USB', 'SERIAL', 'BLUETOOTH')`,
    );
    await queryRunner.query(
      `CREATE TABLE "thermal_printer" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "name" character varying(100) NOT NULL, "connectionType" "public"."thermal_printer_connectiontype_enum" NOT NULL, "ipAddress" character varying, "port" integer, "path" character varying, "isActive" boolean NOT NULL DEFAULT true, "macAddress" character varying(17), "isDefaultPrinter" boolean NOT NULL DEFAULT false, "autoDeliveryPrint" boolean NOT NULL DEFAULT false, "autoPickupPrint" boolean NOT NULL DEFAULT false, "paperWidth" integer NOT NULL DEFAULT '80', "charactersPerLine" integer NOT NULL DEFAULT '48', "cutPaper" boolean NOT NULL DEFAULT true, "feedLines" integer NOT NULL DEFAULT '3', "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "UQ_cd20a8ea69e128597672d5c7813" UNIQUE ("ipAddress"), CONSTRAINT "PK_fa2e4d506b3ae2a00b5c62d894c" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_cd20a8ea69e128597672d5c781" ON "thermal_printer" ("ipAddress") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_7f20d400228dc58a946e3b4ecb" ON "thermal_printer" ("macAddress") `,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."ticket_impression_tickettype_enum" AS ENUM('KITCHEN', 'BAR', 'BILLING', 'CUSTOMER_COPY', 'GENERAL')`,
    );
    await queryRunner.query(
      `CREATE TABLE "ticket_impression" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "order_id" uuid NOT NULL, "user_id" uuid NOT NULL, "printer_id" uuid, "ticketType" "public"."ticket_impression_tickettype_enum" NOT NULL, "impression_time" TIMESTAMP WITH TIME ZONE NOT NULL, "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deleted_at" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_58ccde2bdf3edda5fda63d62965" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "adjustment" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "orderId" uuid, "orderItemId" uuid, "name" character varying(100) NOT NULL, "isPercentage" boolean NOT NULL DEFAULT false, "value" numeric(10,2) NOT NULL DEFAULT '0', "amount" numeric(10,2) NOT NULL, "appliedById" uuid NOT NULL, "appliedAt" TIMESTAMP NOT NULL, "createdAt" TIMESTAMP NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP, CONSTRAINT "PK_f84d8d269b59850fb017ee1630b" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_b860d19aac2598cd33a2d77143" ON "adjustment" ("orderItemId") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_4a0fb0ce34a62a1d1536355589" ON "adjustment" ("orderId") `,
    );
    await queryRunner.query(
      `CREATE TABLE "delivery_info" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "order_id" uuid NOT NULL, "full_address" text, "street" character varying, "number" character varying, "interior_number" character varying, "neighborhood" character varying, "city" character varying, "state" character varying, "zip_code" character varying, "country" character varying, "recipient_name" character varying, "recipient_phone" character varying, "delivery_instructions" text, "latitude" numeric(10,8), "longitude" numeric(11,8), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), CONSTRAINT "UQ_2af51779cec2b29aa564e8547b5" UNIQUE ("order_id"), CONSTRAINT "REL_2af51779cec2b29aa564e8547b" UNIQUE ("order_id"), CONSTRAINT "PK_7e51a51ae402707415bef51c6d4" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."order_preparation_screen_status_status_enum" AS ENUM('PENDING', 'IN_PREPARATION', 'READY')`,
    );
    await queryRunner.query(
      `CREATE TABLE "order_preparation_screen_status" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "order_id" uuid NOT NULL, "preparation_screen_id" uuid NOT NULL, "status" "public"."order_preparation_screen_status_status_enum" NOT NULL DEFAULT 'PENDING', "startedAt" TIMESTAMP WITH TIME ZONE, "completedAt" TIMESTAMP WITH TIME ZONE, "started_by_id" uuid, "completed_by_id" uuid, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), CONSTRAINT "UQ_4cc383eb1e5bad9c32eabd0fb5b" UNIQUE ("order_id", "preparation_screen_id"), CONSTRAINT "PK_d6616b40d43ccf71d4bd6cdf251" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_9ed77bea90710afe76a90f6202" ON "order_preparation_screen_status" ("order_id", "status") `,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."orders_orderstatus_enum" AS ENUM('PENDING', 'IN_PROGRESS', 'IN_PREPARATION', 'READY', 'IN_DELIVERY', 'DELIVERED', 'COMPLETED', 'CANCELLED')`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."orders_ordertype_enum" AS ENUM('DINE_IN', 'TAKE_AWAY', 'DELIVERY')`,
    );
    await queryRunner.query(
      `CREATE TABLE "orders" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "shift_order_number" integer NOT NULL, "shift_id" uuid NOT NULL, "user_id" uuid, "table_id" uuid, "orderStatus" "public"."orders_orderstatus_enum" NOT NULL DEFAULT 'IN_PROGRESS', "orderType" "public"."orders_ordertype_enum" NOT NULL DEFAULT 'DINE_IN', "scheduledAt" TIMESTAMP WITH TIME ZONE, "subtotal" numeric(10,2) NOT NULL DEFAULT '0', "total" numeric(10,2) NOT NULL DEFAULT '0', "notes" text, "customer_id" uuid, "is_from_whatsapp" boolean NOT NULL DEFAULT false, "estimated_delivery_time" TIMESTAMP WITH TIME ZONE, "finalized_at" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_710e2d4957aa5878dfe94e4ac2f" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."pizza_customization_type_enum" AS ENUM('FLAVOR', 'INGREDIENT')`,
    );
    await queryRunner.query(
      `CREATE TABLE "pizza_customization" ("id" character varying(50) NOT NULL, "name" character varying NOT NULL, "type" "public"."pizza_customization_type_enum" NOT NULL DEFAULT 'INGREDIENT', "ingredients" text, "topping_value" integer NOT NULL DEFAULT '1', "is_active" boolean NOT NULL DEFAULT true, "sort_order" integer NOT NULL DEFAULT '0', "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deleted_at" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_c34de896262f8a0181e9be39da9" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."selected_pizza_customization_half_enum" AS ENUM('FULL', 'HALF_1', 'HALF_2')`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."selected_pizza_customization_action_enum" AS ENUM('ADD', 'REMOVE')`,
    );
    await queryRunner.query(
      `CREATE TABLE "selected_pizza_customization" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "order_item_id" uuid NOT NULL, "pizza_customization_id" character varying(50) NOT NULL, "half" "public"."selected_pizza_customization_half_enum" NOT NULL DEFAULT 'FULL', "action" "public"."selected_pizza_customization_action_enum" NOT NULL DEFAULT 'ADD', "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deleted_at" TIMESTAMP WITH TIME ZONE, CONSTRAINT "UQ_8779dd2df5f34fc274f935b2643" UNIQUE ("order_item_id", "pizza_customization_id", "half", "action"), CONSTRAINT "PK_38d567a986aa95dbde8cb34af46" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "modifier_group" ("id" character varying(20) NOT NULL, "name" character varying NOT NULL, "description" character varying, "minSelections" integer NOT NULL DEFAULT '0', "maxSelections" integer NOT NULL, "isRequired" boolean NOT NULL DEFAULT false, "allowMultipleSelections" boolean NOT NULL DEFAULT false, "isActive" boolean NOT NULL DEFAULT true, "sortOrder" integer NOT NULL DEFAULT '0', "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_bda4dae1e8b5e69941a9c26b363" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "product_modifier" ("id" character varying(20) NOT NULL, "modifier_group_id" character varying(20) NOT NULL, "name" character varying NOT NULL, "description" character varying, "price" numeric(10,2), "sort_order" integer NOT NULL DEFAULT '0', "is_default" boolean NOT NULL DEFAULT false, "is_active" boolean NOT NULL DEFAULT true, "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deleted_at" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_cc4550313748a41f5e5af826e20" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."order_item_preparationstatus_enum" AS ENUM('PENDING', 'IN_PROGRESS', 'READY', 'DELIVERED', 'CANCELLED')`,
    );
    await queryRunner.query(
      `CREATE TABLE "order_item" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "order_id" uuid NOT NULL, "product_id" character varying NOT NULL, "product_variant_id" character varying, "basePrice" numeric(10,2) NOT NULL, "finalPrice" numeric(10,2) NOT NULL, "preparationStatus" "public"."order_item_preparationstatus_enum" NOT NULL DEFAULT 'PENDING', "statusChangedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "preparationNotes" character varying, "preparedAt" TIMESTAMP WITH TIME ZONE, "prepared_by_id" uuid, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_d01158fe15b1ead5c26fd7f4e90" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "product_variant" ("id" character varying(20) NOT NULL, "product_id" character varying(20) NOT NULL, "name" character varying NOT NULL, "price" numeric(10,2) NOT NULL, "isActive" boolean NOT NULL DEFAULT true, "sortOrder" integer NOT NULL DEFAULT '0', "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_1ab69c9935c61f7c70791ae0a9f" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "pizza_configuration" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "product_id" character varying NOT NULL, "included_toppings" integer NOT NULL DEFAULT '0', "extra_topping_cost" numeric(10,2) NOT NULL DEFAULT '20', "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deleted_at" TIMESTAMP WITH TIME ZONE, CONSTRAINT "UQ_89f61ab515bf344975fd9811313" UNIQUE ("product_id"), CONSTRAINT "REL_89f61ab515bf344975fd981131" UNIQUE ("product_id"), CONSTRAINT "PK_4cac6f06b77ee88633bb1706e00" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "product" ("id" character varying(20) NOT NULL, "name" character varying NOT NULL, "description" text, "price" numeric(10,2), "hasVariants" boolean NOT NULL DEFAULT false, "isActive" boolean NOT NULL DEFAULT true, "is_pizza" boolean NOT NULL DEFAULT false, "sortOrder" integer NOT NULL DEFAULT '0', "subcategory_id" character varying(20) NOT NULL, "photo_id" uuid, "estimatedPrepTime" integer NOT NULL, "preparation_screen_id" uuid, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_bebc9158e480b949565b4dc7a82" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "preparation_screens" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "name" character varying(100) NOT NULL, "description" character varying(255), "isActive" boolean NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "PK_7ac7b3fa4460e49952d274aa1d5" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."user_gender_enum" AS ENUM('male', 'female', 'other', 'prefer_not_to_say')`,
    );
    await queryRunner.query(
      `CREATE TABLE "user" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "email" character varying, "username" character varying NOT NULL, "password" character varying, "firstName" character varying, "lastName" character varying, "birthDate" date, "gender" "public"."user_gender_enum", "phoneNumber" character varying, "address" character varying, "city" character varying, "state" character varying, "country" character varying, "zipCode" character varying, "emergencyContact" jsonb, "isActive" boolean NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, "roleId" integer NOT NULL, "preparationScreenId" uuid, CONSTRAINT "UQ_e12875dfb3b1d92d7d7c5377e22" UNIQUE ("email"), CONSTRAINT "UQ_78a916df40e02a9deb1c4b75edb" UNIQUE ("username"), CONSTRAINT "PK_cace4a159ff9f2512dd42373760" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_58e4dbff0e1a32a9bdc861bb29" ON "user" ("firstName") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_f0e1b4ecdca13b177e2e3a0613" ON "user" ("lastName") `,
    );
    await queryRunner.query(
      `CREATE TYPE "public"."sync_activity_type_enum" AS ENUM('PULL_CHANGES', 'RESTAURANT_DATA', 'ORDER_STATUS')`,
    );
    await queryRunner.query(
      `CREATE TABLE "sync_activity" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "type" "public"."sync_activity_type_enum" NOT NULL, "direction" character varying(10) NOT NULL, "success" boolean NOT NULL DEFAULT true, "timestamp" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), CONSTRAINT "PK_6317920934104aee696f8439424" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "session" ("id" SERIAL NOT NULL, "hash" character varying NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, "userId" uuid, CONSTRAINT "PK_f55da76ac1c3ac420f444d2ff11" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_3d2f174ef04fb312fdebd0ddc5" ON "session" ("userId") `,
    );
    await queryRunner.query(
      `CREATE TABLE "business_hours" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "dayOfWeek" integer NOT NULL, "openingTime" TIME, "closingTime" TIME, "isClosed" boolean NOT NULL DEFAULT false, "restaurant_config_id" uuid NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "deletedAt" TIMESTAMP WITH TIME ZONE, CONSTRAINT "UQ_35ab61b36059d2fe8461fd1c11d" UNIQUE ("restaurant_config_id", "dayOfWeek"), CONSTRAINT "PK_560a76077605005da835fe505a5" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "restaurant_config" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "restaurantName" character varying(200) NOT NULL DEFAULT 'Restaurant', "phoneMain" character varying(20), "phoneSecondary" character varying(20), "address" text, "city" character varying(100), "state" character varying(100), "postalCode" character varying(20), "country" character varying(100), "acceptingOrders" boolean NOT NULL DEFAULT true, "estimatedPickupTime" integer NOT NULL DEFAULT '20', "estimatedDeliveryTime" integer NOT NULL DEFAULT '40', "estimatedDineInTime" integer NOT NULL DEFAULT '25', "openingGracePeriod" integer NOT NULL DEFAULT '30', "closingGracePeriod" integer NOT NULL DEFAULT '30', "timeZone" character varying(50) NOT NULL DEFAULT 'America/Mexico_City', "scheduledOrdersLeadTime" integer NOT NULL DEFAULT '60', "deliveryCoverageArea" jsonb, "createdAt" TIMESTAMP NOT NULL DEFAULT now(), "updatedAt" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "PK_7507a8162b2370c15747a6e546d" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "order_history" ("id" SERIAL NOT NULL, "order_id" uuid NOT NULL, "operation" character varying(10) NOT NULL, "changed_by" uuid NOT NULL, "changed_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), "diff" jsonb, "snapshot" jsonb NOT NULL, CONSTRAINT "PK_cc71513680d03ecb01b96655b0c" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_a2937c330238ea84f26c912104" ON "order_history" ("order_id", "changed_at") `,
    );
    await queryRunner.query(
      `CREATE TABLE "order_item_product_modifiers" ("order_item_id" uuid NOT NULL, "product_modifier_id" character varying(20) NOT NULL, CONSTRAINT "PK_65a1f401639e329d75e8a456eca" PRIMARY KEY ("order_item_id", "product_modifier_id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_174da1d397a53ad90de24113aa" ON "order_item_product_modifiers" ("order_item_id") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_ab1f24d4d8899260a7f3a220a7" ON "order_item_product_modifiers" ("product_modifier_id") `,
    );
    await queryRunner.query(
      `CREATE TABLE "product_modifier_group" ("product_id" character varying(20) NOT NULL, "modifier_group_id" character varying(20) NOT NULL, CONSTRAINT "PK_37bc0163dbdbccfc385cf524d57" PRIMARY KEY ("product_id", "modifier_group_id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_e35ee74f60bf7607fcfa5b5a44" ON "product_modifier_group" ("product_id") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_5b42ef2ec32ad54c8df5de8833" ON "product_modifier_group" ("modifier_group_id") `,
    );
    await queryRunner.query(
      `CREATE TABLE "product_pizza_customization" ("product_id" character varying(20) NOT NULL, "pizza_customization_id" character varying(50) NOT NULL, CONSTRAINT "PK_d05a432ca912f8f61a64bd86828" PRIMARY KEY ("product_id", "pizza_customization_id"))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_36cfc9221deb83153bdc348908" ON "product_pizza_customization" ("product_id") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_a370300f78f7d36da3e12bc61b" ON "product_pizza_customization" ("pizza_customization_id") `,
    );
    await queryRunner.query(
      `ALTER TABLE "category" ADD CONSTRAINT "FK_0b23b34cf4f29fdcac4a65d9b62" FOREIGN KEY ("photo_id") REFERENCES "file"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "subcategory" ADD CONSTRAINT "FK_b36496504b71c57762246db74d7" FOREIGN KEY ("photo_id") REFERENCES "file"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "subcategory" ADD CONSTRAINT "FK_23584d8b8d26287e4fca0e1aaab" FOREIGN KEY ("category_id") REFERENCES "category"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "table" ADD CONSTRAINT "FK_65407279bef3b9e1458bb4ac588" FOREIGN KEY ("area_id") REFERENCES "area"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "address" ADD CONSTRAINT "FK_9c9614b2f9d01665800ea8dbff7" FOREIGN KEY ("customer_id") REFERENCES "customer"("id") ON DELETE CASCADE ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "shift" ADD CONSTRAINT "FK_5f6b7929ee1eab2ac3429c31572" FOREIGN KEY ("opened_by_id") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "shift" ADD CONSTRAINT "FK_9213f00f25e73a46f8939951508" FOREIGN KEY ("closed_by_id") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "payment" ADD CONSTRAINT "FK_f5221735ace059250daac9d9803" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "ticket_impression" ADD CONSTRAINT "FK_39045644ff19bb02fc961bb482f" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "ticket_impression" ADD CONSTRAINT "FK_bdcc1d40a49fed2ee030cc0aac5" FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "ticket_impression" ADD CONSTRAINT "FK_a606de7eac1188f69862ed98974" FOREIGN KEY ("printer_id") REFERENCES "thermal_printer"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "adjustment" ADD CONSTRAINT "FK_4a0fb0ce34a62a1d1536355589c" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE CASCADE ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "adjustment" ADD CONSTRAINT "FK_b860d19aac2598cd33a2d77143a" FOREIGN KEY ("orderItemId") REFERENCES "order_item"("id") ON DELETE CASCADE ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "adjustment" ADD CONSTRAINT "FK_3462da297d831de3621394c5ebe" FOREIGN KEY ("appliedById") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "delivery_info" ADD CONSTRAINT "FK_2af51779cec2b29aa564e8547b5" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE CASCADE ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_preparation_screen_status" ADD CONSTRAINT "FK_032eb00af16911d930cd78964b9" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE CASCADE ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_preparation_screen_status" ADD CONSTRAINT "FK_1d8a43c801b71b1513311f1ed2e" FOREIGN KEY ("preparation_screen_id") REFERENCES "preparation_screens"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_preparation_screen_status" ADD CONSTRAINT "FK_e863dab712b10b8b468bde6baf1" FOREIGN KEY ("started_by_id") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_preparation_screen_status" ADD CONSTRAINT "FK_e5e6be61e60a72ae6a37d51f08d" FOREIGN KEY ("completed_by_id") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "orders" ADD CONSTRAINT "FK_a47d559598368bc78800dd5175b" FOREIGN KEY ("shift_id") REFERENCES "shift"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "orders" ADD CONSTRAINT "FK_a922b820eeef29ac1c6800e826a" FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "orders" ADD CONSTRAINT "FK_3d36410e89a795172fa6e0dd968" FOREIGN KEY ("table_id") REFERENCES "table"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "orders" ADD CONSTRAINT "FK_772d0ce0473ac2ccfa26060dbe9" FOREIGN KEY ("customer_id") REFERENCES "customer"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "selected_pizza_customization" ADD CONSTRAINT "FK_af0507c028ab56aa1857150fb3c" FOREIGN KEY ("order_item_id") REFERENCES "order_item"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "selected_pizza_customization" ADD CONSTRAINT "FK_506bfd144314f3a36669d4366a8" FOREIGN KEY ("pizza_customization_id") REFERENCES "pizza_customization"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_modifier" ADD CONSTRAINT "FK_d2bb79aa24d24bfaa21687de8c6" FOREIGN KEY ("modifier_group_id") REFERENCES "modifier_group"("id") ON DELETE CASCADE ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item" ADD CONSTRAINT "FK_4f22693817205af9eb18672c473" FOREIGN KEY ("prepared_by_id") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item" ADD CONSTRAINT "FK_e9674a6053adbaa1057848cddfa" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item" ADD CONSTRAINT "FK_5e17c017aa3f5164cb2da5b1c6b" FOREIGN KEY ("product_id") REFERENCES "product"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item" ADD CONSTRAINT "FK_19fe8036263238b4fb3866243bf" FOREIGN KEY ("product_variant_id") REFERENCES "product_variant"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_variant" ADD CONSTRAINT "FK_ca67dd080aac5ecf99609960cd2" FOREIGN KEY ("product_id") REFERENCES "product"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "pizza_configuration" ADD CONSTRAINT "FK_89f61ab515bf344975fd9811313" FOREIGN KEY ("product_id") REFERENCES "product"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "product" ADD CONSTRAINT "FK_6c701613676cfa922e429eb1bae" FOREIGN KEY ("photo_id") REFERENCES "file"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "product" ADD CONSTRAINT "FK_0c9ba3f2d09244e06fc22ff618d" FOREIGN KEY ("subcategory_id") REFERENCES "subcategory"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "product" ADD CONSTRAINT "FK_43b6baaae5d58553d5269e26f6e" FOREIGN KEY ("preparation_screen_id") REFERENCES "preparation_screens"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "user" ADD CONSTRAINT "FK_c28e52f758e7bbc53828db92194" FOREIGN KEY ("roleId") REFERENCES "role"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "user" ADD CONSTRAINT "FK_72a26f0f47516be04ae20149289" FOREIGN KEY ("preparationScreenId") REFERENCES "preparation_screens"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "session" ADD CONSTRAINT "FK_3d2f174ef04fb312fdebd0ddc53" FOREIGN KEY ("userId") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "business_hours" ADD CONSTRAINT "FK_26f01c683dff7f6253d7b2b22c7" FOREIGN KEY ("restaurant_config_id") REFERENCES "restaurant_config"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item_product_modifiers" ADD CONSTRAINT "FK_174da1d397a53ad90de24113aa7" FOREIGN KEY ("order_item_id") REFERENCES "order_item"("id") ON DELETE CASCADE ON UPDATE CASCADE`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item_product_modifiers" ADD CONSTRAINT "FK_ab1f24d4d8899260a7f3a220a7d" FOREIGN KEY ("product_modifier_id") REFERENCES "product_modifier"("id") ON DELETE CASCADE ON UPDATE CASCADE`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_modifier_group" ADD CONSTRAINT "FK_e35ee74f60bf7607fcfa5b5a44e" FOREIGN KEY ("product_id") REFERENCES "product"("id") ON DELETE CASCADE ON UPDATE CASCADE`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_modifier_group" ADD CONSTRAINT "FK_5b42ef2ec32ad54c8df5de88337" FOREIGN KEY ("modifier_group_id") REFERENCES "modifier_group"("id") ON DELETE CASCADE ON UPDATE CASCADE`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_pizza_customization" ADD CONSTRAINT "FK_36cfc9221deb83153bdc3489087" FOREIGN KEY ("product_id") REFERENCES "product"("id") ON DELETE CASCADE ON UPDATE CASCADE`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_pizza_customization" ADD CONSTRAINT "FK_a370300f78f7d36da3e12bc61b3" FOREIGN KEY ("pizza_customization_id") REFERENCES "pizza_customization"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }
  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE "product_pizza_customization" DROP CONSTRAINT "FK_a370300f78f7d36da3e12bc61b3"`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_pizza_customization" DROP CONSTRAINT "FK_36cfc9221deb83153bdc3489087"`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_modifier_group" DROP CONSTRAINT "FK_5b42ef2ec32ad54c8df5de88337"`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_modifier_group" DROP CONSTRAINT "FK_e35ee74f60bf7607fcfa5b5a44e"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item_product_modifiers" DROP CONSTRAINT "FK_ab1f24d4d8899260a7f3a220a7d"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item_product_modifiers" DROP CONSTRAINT "FK_174da1d397a53ad90de24113aa7"`,
    );
    await queryRunner.query(
      `ALTER TABLE "business_hours" DROP CONSTRAINT "FK_26f01c683dff7f6253d7b2b22c7"`,
    );
    await queryRunner.query(
      `ALTER TABLE "session" DROP CONSTRAINT "FK_3d2f174ef04fb312fdebd0ddc53"`,
    );
    await queryRunner.query(
      `ALTER TABLE "user" DROP CONSTRAINT "FK_72a26f0f47516be04ae20149289"`,
    );
    await queryRunner.query(
      `ALTER TABLE "user" DROP CONSTRAINT "FK_c28e52f758e7bbc53828db92194"`,
    );
    await queryRunner.query(
      `ALTER TABLE "product" DROP CONSTRAINT "FK_43b6baaae5d58553d5269e26f6e"`,
    );
    await queryRunner.query(
      `ALTER TABLE "product" DROP CONSTRAINT "FK_0c9ba3f2d09244e06fc22ff618d"`,
    );
    await queryRunner.query(
      `ALTER TABLE "product" DROP CONSTRAINT "FK_6c701613676cfa922e429eb1bae"`,
    );
    await queryRunner.query(
      `ALTER TABLE "pizza_configuration" DROP CONSTRAINT "FK_89f61ab515bf344975fd9811313"`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_variant" DROP CONSTRAINT "FK_ca67dd080aac5ecf99609960cd2"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item" DROP CONSTRAINT "FK_19fe8036263238b4fb3866243bf"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item" DROP CONSTRAINT "FK_5e17c017aa3f5164cb2da5b1c6b"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item" DROP CONSTRAINT "FK_e9674a6053adbaa1057848cddfa"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_item" DROP CONSTRAINT "FK_4f22693817205af9eb18672c473"`,
    );
    await queryRunner.query(
      `ALTER TABLE "product_modifier" DROP CONSTRAINT "FK_d2bb79aa24d24bfaa21687de8c6"`,
    );
    await queryRunner.query(
      `ALTER TABLE "selected_pizza_customization" DROP CONSTRAINT "FK_506bfd144314f3a36669d4366a8"`,
    );
    await queryRunner.query(
      `ALTER TABLE "selected_pizza_customization" DROP CONSTRAINT "FK_af0507c028ab56aa1857150fb3c"`,
    );
    await queryRunner.query(
      `ALTER TABLE "orders" DROP CONSTRAINT "FK_772d0ce0473ac2ccfa26060dbe9"`,
    );
    await queryRunner.query(
      `ALTER TABLE "orders" DROP CONSTRAINT "FK_3d36410e89a795172fa6e0dd968"`,
    );
    await queryRunner.query(
      `ALTER TABLE "orders" DROP CONSTRAINT "FK_a922b820eeef29ac1c6800e826a"`,
    );
    await queryRunner.query(
      `ALTER TABLE "orders" DROP CONSTRAINT "FK_a47d559598368bc78800dd5175b"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_preparation_screen_status" DROP CONSTRAINT "FK_e5e6be61e60a72ae6a37d51f08d"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_preparation_screen_status" DROP CONSTRAINT "FK_e863dab712b10b8b468bde6baf1"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_preparation_screen_status" DROP CONSTRAINT "FK_1d8a43c801b71b1513311f1ed2e"`,
    );
    await queryRunner.query(
      `ALTER TABLE "order_preparation_screen_status" DROP CONSTRAINT "FK_032eb00af16911d930cd78964b9"`,
    );
    await queryRunner.query(
      `ALTER TABLE "delivery_info" DROP CONSTRAINT "FK_2af51779cec2b29aa564e8547b5"`,
    );
    await queryRunner.query(
      `ALTER TABLE "adjustment" DROP CONSTRAINT "FK_3462da297d831de3621394c5ebe"`,
    );
    await queryRunner.query(
      `ALTER TABLE "adjustment" DROP CONSTRAINT "FK_b860d19aac2598cd33a2d77143a"`,
    );
    await queryRunner.query(
      `ALTER TABLE "adjustment" DROP CONSTRAINT "FK_4a0fb0ce34a62a1d1536355589c"`,
    );
    await queryRunner.query(
      `ALTER TABLE "ticket_impression" DROP CONSTRAINT "FK_a606de7eac1188f69862ed98974"`,
    );
    await queryRunner.query(
      `ALTER TABLE "ticket_impression" DROP CONSTRAINT "FK_bdcc1d40a49fed2ee030cc0aac5"`,
    );
    await queryRunner.query(
      `ALTER TABLE "ticket_impression" DROP CONSTRAINT "FK_39045644ff19bb02fc961bb482f"`,
    );
    await queryRunner.query(
      `ALTER TABLE "payment" DROP CONSTRAINT "FK_f5221735ace059250daac9d9803"`,
    );
    await queryRunner.query(
      `ALTER TABLE "shift" DROP CONSTRAINT "FK_9213f00f25e73a46f8939951508"`,
    );
    await queryRunner.query(
      `ALTER TABLE "shift" DROP CONSTRAINT "FK_5f6b7929ee1eab2ac3429c31572"`,
    );
    await queryRunner.query(
      `ALTER TABLE "address" DROP CONSTRAINT "FK_9c9614b2f9d01665800ea8dbff7"`,
    );
    await queryRunner.query(
      `ALTER TABLE "table" DROP CONSTRAINT "FK_65407279bef3b9e1458bb4ac588"`,
    );
    await queryRunner.query(
      `ALTER TABLE "subcategory" DROP CONSTRAINT "FK_23584d8b8d26287e4fca0e1aaab"`,
    );
    await queryRunner.query(
      `ALTER TABLE "subcategory" DROP CONSTRAINT "FK_b36496504b71c57762246db74d7"`,
    );
    await queryRunner.query(
      `ALTER TABLE "category" DROP CONSTRAINT "FK_0b23b34cf4f29fdcac4a65d9b62"`,
    );
    await queryRunner.query(
      `DROP INDEX "public"."IDX_a370300f78f7d36da3e12bc61b"`,
    );
    await queryRunner.query(
      `DROP INDEX "public"."IDX_36cfc9221deb83153bdc348908"`,
    );
    await queryRunner.query(`DROP TABLE "product_pizza_customization"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_5b42ef2ec32ad54c8df5de8833"`,
    );
    await queryRunner.query(
      `DROP INDEX "public"."IDX_e35ee74f60bf7607fcfa5b5a44"`,
    );
    await queryRunner.query(`DROP TABLE "product_modifier_group"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_ab1f24d4d8899260a7f3a220a7"`,
    );
    await queryRunner.query(
      `DROP INDEX "public"."IDX_174da1d397a53ad90de24113aa"`,
    );
    await queryRunner.query(`DROP TABLE "order_item_product_modifiers"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_a2937c330238ea84f26c912104"`,
    );
    await queryRunner.query(`DROP TABLE "order_history"`);
    await queryRunner.query(`DROP TABLE "restaurant_config"`);
    await queryRunner.query(`DROP TABLE "business_hours"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_3d2f174ef04fb312fdebd0ddc5"`,
    );
    await queryRunner.query(`DROP TABLE "session"`);
    await queryRunner.query(`DROP TABLE "sync_activity"`);
    await queryRunner.query(`DROP TYPE "public"."sync_activity_type_enum"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_f0e1b4ecdca13b177e2e3a0613"`,
    );
    await queryRunner.query(
      `DROP INDEX "public"."IDX_58e4dbff0e1a32a9bdc861bb29"`,
    );
    await queryRunner.query(`DROP TABLE "user"`);
    await queryRunner.query(`DROP TYPE "public"."user_gender_enum"`);
    await queryRunner.query(`DROP TABLE "preparation_screens"`);
    await queryRunner.query(`DROP TABLE "product"`);
    await queryRunner.query(`DROP TABLE "pizza_configuration"`);
    await queryRunner.query(`DROP TABLE "product_variant"`);
    await queryRunner.query(`DROP TABLE "order_item"`);
    await queryRunner.query(
      `DROP TYPE "public"."order_item_preparationstatus_enum"`,
    );
    await queryRunner.query(`DROP TABLE "product_modifier"`);
    await queryRunner.query(`DROP TABLE "modifier_group"`);
    await queryRunner.query(`DROP TABLE "selected_pizza_customization"`);
    await queryRunner.query(
      `DROP TYPE "public"."selected_pizza_customization_action_enum"`,
    );
    await queryRunner.query(
      `DROP TYPE "public"."selected_pizza_customization_half_enum"`,
    );
    await queryRunner.query(`DROP TABLE "pizza_customization"`);
    await queryRunner.query(
      `DROP TYPE "public"."pizza_customization_type_enum"`,
    );
    await queryRunner.query(`DROP TABLE "orders"`);
    await queryRunner.query(`DROP TYPE "public"."orders_ordertype_enum"`);
    await queryRunner.query(`DROP TYPE "public"."orders_orderstatus_enum"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_9ed77bea90710afe76a90f6202"`,
    );
    await queryRunner.query(`DROP TABLE "order_preparation_screen_status"`);
    await queryRunner.query(
      `DROP TYPE "public"."order_preparation_screen_status_status_enum"`,
    );
    await queryRunner.query(`DROP TABLE "delivery_info"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_4a0fb0ce34a62a1d1536355589"`,
    );
    await queryRunner.query(
      `DROP INDEX "public"."IDX_b860d19aac2598cd33a2d77143"`,
    );
    await queryRunner.query(`DROP TABLE "adjustment"`);
    await queryRunner.query(`DROP TABLE "ticket_impression"`);
    await queryRunner.query(
      `DROP TYPE "public"."ticket_impression_tickettype_enum"`,
    );
    await queryRunner.query(
      `DROP INDEX "public"."IDX_7f20d400228dc58a946e3b4ecb"`,
    );
    await queryRunner.query(
      `DROP INDEX "public"."IDX_cd20a8ea69e128597672d5c781"`,
    );
    await queryRunner.query(`DROP TABLE "thermal_printer"`);
    await queryRunner.query(
      `DROP TYPE "public"."thermal_printer_connectiontype_enum"`,
    );
    await queryRunner.query(`DROP TABLE "payment"`);
    await queryRunner.query(`DROP TYPE "public"."payment_paymentstatus_enum"`);
    await queryRunner.query(`DROP TYPE "public"."payment_paymentmethod_enum"`);
    await queryRunner.query(`DROP INDEX "public"."IDX_shift_date"`);
    await queryRunner.query(`DROP INDEX "public"."IDX_shift_status"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_shift_date_shift_number"`,
    );
    await queryRunner.query(`DROP TABLE "shift"`);
    await queryRunner.query(`DROP TYPE "public"."shift_status_enum"`);
    await queryRunner.query(`DROP INDEX "public"."uq_customer_email"`);
    await queryRunner.query(`DROP INDEX "public"."uq_customer_whatsapp"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_2b5187e7475dcc88f25bec3967"`,
    );
    await queryRunner.query(
      `DROP INDEX "public"."IDX_2af7646e11a0872eb9a0212545"`,
    );
    await queryRunner.query(`DROP TABLE "customer"`);
    await queryRunner.query(
      `DROP INDEX "public"."IDX_49bc1e3cd91c06dc434318abd9"`,
    );
    await queryRunner.query(`DROP TABLE "address"`);
    await queryRunner.query(`DROP TABLE "table"`);
    await queryRunner.query(`DROP TABLE "area"`);
    await queryRunner.query(`DROP TABLE "subcategory"`);
    await queryRunner.query(`DROP TABLE "category"`);
    await queryRunner.query(`DROP TABLE "file"`);
    await queryRunner.query(`DROP TABLE "role"`);
  }
}

================
File: backend/src/database/seeds/relational/restaurant-config/restaurant-config-seed.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { RestaurantConfigEntity } from '../../../../restaurant-config/infrastructure/persistence/relational/entities/restaurant-config.entity';
import { BusinessHoursEntity } from '../../../../restaurant-config/infrastructure/persistence/relational/entities/business-hours.entity';
@Injectable()
export class RestaurantConfigSeedService {
  constructor(
    @InjectRepository(RestaurantConfigEntity)
    private repository: Repository<RestaurantConfigEntity>,
    @InjectRepository(BusinessHoursEntity)
    private businessHoursRepository: Repository<BusinessHoursEntity>,
  ) {}
  async run() {
    const countConfig = await this.repository.count();
    if (!countConfig) {
      const restaurantConfig = await this.repository.save(
        this.repository.create({
          restaurantName: 'La Leña',
          phoneMain: '3919160126',
          phoneSecondary: '3338423316',
          address: 'C. Ogazón Sur 36, Centro',
          city: 'Tototlán',
          state: 'Jalisco',
          postalCode: '47730',
          country: 'México',
          acceptingOrders: true,
          estimatedPickupTime: 20,
          estimatedDeliveryTime: 40,
          estimatedDineInTime: 30,
          openingGracePeriod: 30,
          closingGracePeriod: 30,
          timeZone: 'America/Mexico_City',
          scheduledOrdersLeadTime: 60,
          minimumOrderValueForDelivery: 50,
          deliveryCoverageArea: [
            { lat: 20.552083014344916, lng: -102.80691765951832 },
            { lat: 20.533011128610994, lng: -102.80691765951832 },
            { lat: 20.533011128610994, lng: -102.78047795060189 },
            { lat: 20.552083014344916, lng: -102.78047795060189 },
            { lat: 20.552083014344916, lng: -102.80691765951832 },
          ],
        }),
      );
      const businessHours = [
        {
          dayOfWeek: 0,
          openingTime: '14:00',
          closingTime: '21:00',
          isClosed: false,
        },
        {
          dayOfWeek: 1,
          openingTime: '04:00',
          closingTime: '23:00',
          isClosed: false,
        },
        {
          dayOfWeek: 2,
          openingTime: '04:00',
          closingTime: '22:00',
          isClosed: false,
        },
        {
          dayOfWeek: 3,
          openingTime: '04:00',
          closingTime: '23:00',
          isClosed: false,
        },
        {
          dayOfWeek: 4,
          openingTime: '04:00',
          closingTime: '22:00',
          isClosed: false,
        },
        {
          dayOfWeek: 5,
          openingTime: '04:00',
          closingTime: '22:00',
          isClosed: false,
        },
        {
          dayOfWeek: 6,
          openingTime: '04:00',
          closingTime: '22:00',
          isClosed: false,
        },
      ];
      for (const hours of businessHours) {
        await this.businessHoursRepository.save(
          this.businessHoursRepository.create({
            ...hours,
            restaurantConfig: restaurantConfig,
          }),
        );
      }
    }
  }
}

================
File: backend/src/kitchen/controllers/kitchen.controller.ts
================
import {
  Controller,
  Get,
  Patch,
  Param,
  Query,
  Body,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiBearerAuth,
  ApiResponse,
} from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../../roles/roles.guard';
import { Roles } from '../../roles/roles.decorator';
import { RoleEnum } from '../../roles/roles.enum';
import { CurrentUser } from '../../auth/decorators/current-user.decorator';
import { KitchenService } from '../services/kitchen.service';
import { KitchenOrderFilterDto } from '../dto/kitchen-order-filter.dto';
import { MarkItemPreparedDto } from '../dto/mark-item-prepared.dto';
import { KitchenOrderOptimizedDto } from '../dto/kitchen-order-optimized.dto';
@ApiTags('Cocina')
@Controller({
  path: 'kitchen',
  version: '1',
})
@ApiBearerAuth()
@UseGuards(AuthGuard('jwt'), RolesGuard)
export class KitchenController {
  constructor(private readonly kitchenService: KitchenService) {}
  @Get('orders')
  @ApiOperation({
    summary: 'Obtener órdenes para preparación en cocina',
    description:
      'Retorna las órdenes filtradas según la pantalla de preparación del usuario',
  })
  @ApiResponse({
    status: 200,
    description: 'Lista de órdenes para preparación',
    type: [KitchenOrderOptimizedDto],
  })
  @Roles(RoleEnum.kitchen, RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  async getKitchenOrders(
    @CurrentUser('id') userId: string,
    @Query() filters: KitchenOrderFilterDto,
  ): Promise<KitchenOrderOptimizedDto[]> {
    return this.kitchenService.getKitchenOrders(userId, filters);
  }
  @Patch('order-items/:id/prepare')
  @ApiOperation({
    summary: 'Marcar item de orden como preparado',
    description:
      'Marca uno o varios items (si están agrupados) como preparados',
  })
  @ApiResponse({
    status: 204,
    description: 'Item marcado como preparado exitosamente',
  })
  @Roles(RoleEnum.kitchen, RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async markItemPrepared(
    @Param('id') itemId: string,
    @CurrentUser('id') userId: string,
    @Body() dto: MarkItemPreparedDto,
  ): Promise<void> {
    await this.kitchenService.markItemPrepared(
      itemId,
      userId,
      dto.isPrepared ?? true,
    );
  }
  @Patch('order-items/:id/unprepare')
  @ApiOperation({
    summary: 'Desmarcar item de orden como preparado',
    description:
      'Desmarca uno o varios items (si están agrupados) como no preparados',
  })
  @ApiResponse({
    status: 204,
    description: 'Item desmarcado exitosamente',
  })
  @Roles(RoleEnum.kitchen, RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async unmarkItemPrepared(
    @Param('id') itemId: string,
    @CurrentUser('id') userId: string,
  ): Promise<void> {
    await this.kitchenService.markItemPrepared(itemId, userId, false);
  }
  @Get('orders/:orderId/history')
  @ApiOperation({
    summary: 'Obtener historial de cambios de una orden',
    description:
      'Retorna el historial completo de cambios de una orden específica',
  })
  @ApiResponse({
    status: 200,
    description: 'Historial de cambios de la orden',
  })
  @Roles(RoleEnum.kitchen, RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  async getOrderHistory(
    @Param('orderId') orderId: string,
    @CurrentUser('id') userId: string,
  ) {
    return {
      orderId,
      history: [],
      message: 'El historial de órdenes se implementará próximamente',
    };
  }
  @Get('my-screen')
  @ApiOperation({
    summary: 'Obtener pantalla de preparación asignada al usuario',
    description:
      'Retorna la pantalla de preparación predeterminada del usuario actual',
  })
  @ApiResponse({
    status: 200,
    description: 'Información de la pantalla asignada',
  })
  @Roles(RoleEnum.kitchen, RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  async getMyScreen(@CurrentUser('id') userId: string) {
    const screen = await this.kitchenService.getUserDefaultScreen(userId);
    return { screen };
  }
  @Patch('orders/:orderId/start-preparation')
  @ApiOperation({
    summary: 'Iniciar preparación para una pantalla específica',
    description:
      'Marca el inicio de preparación de una orden para la pantalla del usuario',
  })
  @ApiResponse({
    status: 204,
    description: 'Preparación iniciada exitosamente',
  })
  @Roles(RoleEnum.kitchen, RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async startPreparationForScreen(
    @Param('orderId') orderId: string,
    @CurrentUser('id') userId: string,
  ): Promise<void> {
    await this.kitchenService.startPreparationForScreen(orderId, userId);
  }
  @Patch('orders/:orderId/complete-preparation')
  @ApiOperation({
    summary: 'Completar preparación para una pantalla específica',
    description:
      'Marca como completada la preparación de una orden para la pantalla del usuario',
  })
  @ApiResponse({
    status: 204,
    description: 'Preparación completada exitosamente',
  })
  @Roles(RoleEnum.kitchen, RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async completePreparationForScreen(
    @Param('orderId') orderId: string,
    @CurrentUser('id') userId: string,
  ): Promise<void> {
    await this.kitchenService.completePreparationForScreen(orderId, userId);
  }
  @Patch('orders/:orderId/cancel-preparation')
  @ApiOperation({
    summary: 'Cancelar preparación para una pantalla específica',
    description:
      'Regresa el estado de preparación de una orden para la pantalla del usuario',
  })
  @ApiResponse({
    status: 204,
    description: 'Preparación cancelada exitosamente',
  })
  @Roles(RoleEnum.kitchen, RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async cancelPreparationForScreen(
    @Param('orderId') orderId: string,
    @CurrentUser('id') userId: string,
  ): Promise<void> {
    await this.kitchenService.cancelPreparationForScreen(orderId, userId);
  }
}

================
File: backend/src/kitchen/dto/kitchen-order-optimized.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { OrderType } from '../../orders/domain/enums/order-type.enum';
import { PreparationStatus } from '../../orders/domain/order-item';
export class KitchenOrderItemOptimizedDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  productName: string;
  @ApiProperty({ required: false })
  variantName?: string;
  @ApiProperty({ type: [String] })
  modifiers: string[];
  @ApiProperty({ type: [Object], required: false })
  pizzaCustomizations?: any[];
  @ApiProperty({ required: false })
  preparationNotes?: string;
  @ApiProperty({ enum: PreparationStatus })
  preparationStatus: PreparationStatus;
  @ApiProperty({ required: false })
  preparedAt?: Date;
  @ApiProperty({ required: false })
  preparedByUser?: {
    firstName: string;
    lastName: string;
  };
  @ApiProperty()
  quantity: number;
  @ApiProperty()
  belongsToMyScreen: boolean;
}
export class ScreenStatusOptimizedDto {
  @ApiProperty()
  screenId: string;
  @ApiProperty()
  screenName: string;
  @ApiProperty()
  status: string;
}
export class KitchenOrderOptimizedDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  shiftOrderNumber: number;
  @ApiProperty({ enum: OrderType })
  orderType: OrderType;
  @ApiProperty()
  orderStatus: string;
  @ApiProperty()
  createdAt: Date;
  @ApiProperty({ required: false })
  orderNotes?: string;
  @ApiProperty({ required: false })
  deliveryAddress?: string;
  @ApiProperty({ required: false })
  deliveryPhone?: string;
  @ApiProperty({ required: false })
  receiptName?: string;
  @ApiProperty({ required: false })
  customerPhone?: string;
  @ApiProperty({ required: false })
  areaName?: string;
  @ApiProperty({ required: false })
  tableName?: string;
  @ApiProperty({ type: [KitchenOrderItemOptimizedDto] })
  items: KitchenOrderItemOptimizedDto[];
  @ApiProperty()
  hasPendingItems: boolean;
  @ApiProperty({ type: [ScreenStatusOptimizedDto] })
  screenStatuses: ScreenStatusOptimizedDto[];
  @ApiProperty({ required: false })
  myScreenStatus?: string;
}

================
File: backend/src/main.ts
================
import 'dotenv/config';
process.env.TZ = 'UTC';
import {
  ClassSerializerInterceptor,
  ValidationPipe,
  VersioningType,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { NestFactory, Reflector } from '@nestjs/core';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { useContainer } from 'class-validator';
import { AppModule } from './app.module';
import validationOptions from './utils/validation-options';
import { AllConfigType } from './config/config.type';
import { ResolvePromisesInterceptor } from './utils/serializer.interceptor';
import { AllExceptionsFilter } from './common/filters/http-exception.filter';
import { UniqueViolationFilter } from './common/filters/unique-violation.filter';
import { UserContextInterceptor } from './common/interceptors/user-context.interceptor';
import { UserContextService } from './common/services/user-context.service';
import * as express from 'express';
async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    cors: {
      origin: true,
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
      allowedHeaders: ['Content-Type', 'Authorization', 'Cache-Control'],
    },
    bodyParser: false,
  });
  app.use(express.json({ limit: '50mb' }));
  app.use(express.urlencoded({ limit: '50mb', extended: true }));
  const server = app.getHttpServer();
  server.setTimeout(300000);
  server.keepAliveTimeout = 120000;
  server.headersTimeout = 121000;
  useContainer(app.select(AppModule), { fallbackOnErrors: true });
  const configService = app.get(ConfigService<AllConfigType>);
  app.enableShutdownHooks();
  app.setGlobalPrefix(
    configService.getOrThrow('app.apiPrefix', { infer: true }),
    {
      exclude: ['/'],
    },
  );
  app.enableVersioning({
    type: VersioningType.URI,
  });
  app.useGlobalPipes(new ValidationPipe(validationOptions));
  const userContextService = app.get(UserContextService);
  app.useGlobalInterceptors(
    new UserContextInterceptor(userContextService),
    new ResolvePromisesInterceptor(),
    new ClassSerializerInterceptor(app.get(Reflector)),
  );
  app.useGlobalFilters(new UniqueViolationFilter());
  app.useGlobalFilters(new AllExceptionsFilter());
  const options = new DocumentBuilder()
    .setTitle('API')
    .setDescription('API docs')
    .setVersion('1.0')
    .addBearerAuth()
    .build();
  const document = SwaggerModule.createDocument(app, options);
  SwaggerModule.setup('docs', app, document);
  const port = configService.getOrThrow('app.port', { infer: true });
  await app.listen(port, '0.0.0.0');
  const os = await import('os');
  const networkInterfaces = os.networkInterfaces();
  const addresses: string[] = [];
  for (const interfaces of Object.values(networkInterfaces)) {
    for (const iface of interfaces || []) {
      if (iface.family === 'IPv4' && !iface.internal) {
        addresses.push(iface.address);
      }
    }
  }
}
void bootstrap();

================
File: backend/src/orders/domain/ticket-impression.ts
================
import { Order } from './order';
import { User } from '../../users/domain/user';
import { TicketType } from './enums/ticket-type.enum';
import { ThermalPrinter } from '../../thermal-printers/domain/thermal-printer';
export class TicketImpression {
  id: string;
  orderId: string;
  userId: string;
  printerId?: string;
  ticketType: TicketType;
  impressionTime: Date;
  order?: Order;
  user?: User | null;
  printer?: ThermalPrinter | null;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

================
File: backend/src/orders/dto/sales-summary.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
export class ProductSalesSummaryDto {
  @ApiProperty({
    description: 'ID del producto',
    example: 'PR-001',
  })
  productId: string;
  @ApiProperty({
    description: 'Nombre del producto',
    example: 'Pizza Margarita',
  })
  productName: string;
  @ApiProperty({
    description: 'Cantidad vendida',
    example: 10,
  })
  quantity: number;
  @ApiProperty({
    description: 'Total vendido del producto',
    example: 1500.0,
  })
  totalAmount: number;
  @ApiProperty({
    description: 'Precio promedio por unidad',
    example: 150.0,
  })
  averagePrice: number;
}
export class SubcategorySalesSummaryDto {
  @ApiProperty({
    description: 'ID de la subcategoría',
    example: 'SUB-001',
  })
  subcategoryId: string;
  @ApiProperty({
    description: 'Nombre de la subcategoría',
    example: 'Pizzas Especiales',
  })
  subcategoryName: string;
  @ApiProperty({
    description: 'Cantidad total de productos vendidos en la subcategoría',
    example: 25,
  })
  quantity: number;
  @ApiProperty({
    description: 'Total vendido en la subcategoría',
    example: 3750.0,
  })
  totalAmount: number;
  @ApiProperty({
    description: 'Productos vendidos en esta subcategoría',
    type: [ProductSalesSummaryDto],
  })
  products: ProductSalesSummaryDto[];
}
export class CategorySalesSummaryDto {
  @ApiProperty({
    description: 'ID de la categoría',
    example: 'CAT-001',
  })
  categoryId: string;
  @ApiProperty({
    description: 'Nombre de la categoría',
    example: 'Pizzas',
  })
  categoryName: string;
  @ApiProperty({
    description: 'Cantidad total de productos vendidos en la categoría',
    example: 50,
  })
  quantity: number;
  @ApiProperty({
    description: 'Total vendido en la categoría',
    example: 7500.0,
  })
  totalAmount: number;
  @ApiProperty({
    description: 'Porcentaje del total de ventas',
    example: 45.5,
  })
  percentage: number;
  @ApiProperty({
    description: 'Subcategorías de esta categoría',
    type: [SubcategorySalesSummaryDto],
  })
  subcategories: SubcategorySalesSummaryDto[];
}
export class ShiftSalesSummaryDto {
  @ApiProperty({
    description: 'ID del turno',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  shiftId: string;
  @ApiProperty({
    description: 'Número del turno',
    example: 1,
  })
  shiftNumber: number;
  @ApiProperty({
    description: 'Fecha del turno',
    example: '2024-01-20',
  })
  date: Date;
  @ApiProperty({
    description: 'Total general de ventas',
    example: 15000.0,
  })
  totalSales: number;
  @ApiProperty({
    description: 'Cantidad total de productos vendidos',
    example: 100,
  })
  totalQuantity: number;
  @ApiProperty({
    description: 'Cantidad de órdenes completadas',
    example: 25,
  })
  completedOrders: number;
  @ApiProperty({
    description: 'Ticket promedio',
    example: 600.0,
  })
  averageTicket: number;
  @ApiProperty({
    description: 'Resumen de ventas por categoría',
    type: [CategorySalesSummaryDto],
  })
  categories: CategorySalesSummaryDto[];
  @ApiProperty({
    description: 'Productos más vendidos (top 10)',
    type: [ProductSalesSummaryDto],
  })
  topProducts: ProductSalesSummaryDto[];
  @ApiProperty({
    description: 'Hora de inicio del turno',
  })
  startTime: Date;
  @ApiProperty({
    description: 'Hora de fin del turno (null si está abierto)',
    nullable: true,
  })
  endTime: Date | null;
}

================
File: backend/src/orders/infrastructure/persistence/relational/entities/order.entity.ts
================
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  OneToMany,
  OneToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { TableEntity } from '../../../../../tables/infrastructure/persistence/relational/entities/table.entity';
import { CustomerEntity } from '../../../../../customers/infrastructure/persistence/relational/entities/customer.entity';
import { ShiftEntity } from '../../../../../shifts/infrastructure/persistence/relational/entities/shift.entity';
import { OrderStatus } from '../../../../domain/enums/order-status.enum';
import { OrderType } from '../../../../domain/enums/order-type.enum';
import { OrderItemEntity } from './order-item.entity';
import { PaymentEntity } from '../../../../../payments/infrastructure/persistence/relational/entities/payment.entity';
import { TicketImpressionEntity } from './ticket-impression.entity';
import { AdjustmentEntity } from '../../../../../adjustments/infrastructure/persistence/relational/entities/adjustment.entity';
import { DeliveryInfoEntity } from './delivery-info.entity';
import { OrderPreparationScreenStatusEntity } from './order-preparation-screen-status.entity';
@Entity({
  name: 'orders',
})
export class OrderEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ name: 'shift_order_number' })
  shiftOrderNumber: number;
  @Column({ name: 'shift_id', type: 'uuid' })
  shiftId: string;
  @ManyToOne(() => ShiftEntity)
  @JoinColumn({ name: 'shift_id' })
  shift: ShiftEntity;
  @Column({ name: 'user_id', type: 'uuid', nullable: true })
  userId: string | null;
  @ManyToOne(() => UserEntity, { nullable: true })
  @JoinColumn({ name: 'user_id' })
  user: UserEntity | null;
  @Column({ name: 'table_id', type: 'uuid', nullable: true })
  tableId: string | null;
  @ManyToOne(() => TableEntity, { nullable: true })
  @JoinColumn({ name: 'table_id' })
  table: TableEntity | null;
  @Column({
    type: 'enum',
    enum: OrderStatus,
    default: OrderStatus.IN_PROGRESS,
  })
  orderStatus: OrderStatus;
  @Column({
    type: 'enum',
    enum: OrderType,
    default: OrderType.DINE_IN,
  })
  orderType: OrderType;
  @Column({ type: 'timestamptz', nullable: true })
  scheduledAt: Date | null;
  @Column({ type: 'decimal', precision: 10, scale: 2, default: 0 })
  subtotal: number;
  @Column({ type: 'decimal', precision: 10, scale: 2, default: 0 })
  total: number;
  @Column({ type: 'text', nullable: true })
  notes: string | null;
  @Column({ name: 'customer_id', type: 'uuid', nullable: true })
  customerId: string | null;
  @ManyToOne(() => CustomerEntity, (customer) => customer.orders, {
    nullable: true,
  })
  @JoinColumn({ name: 'customer_id' })
  customer: CustomerEntity | null;
  @Column({ name: 'is_from_whatsapp', type: 'boolean', default: false })
  isFromWhatsApp: boolean;
  @OneToMany(() => OrderItemEntity, (orderItem) => orderItem.order)
  orderItems: OrderItemEntity[];
  @OneToMany(() => PaymentEntity, (payment) => payment.order)
  payments: PaymentEntity[];
  @OneToMany(() => TicketImpressionEntity, (impression) => impression.order)
  ticketImpressions: TicketImpressionEntity[];
  @OneToMany(() => AdjustmentEntity, (adjustment) => adjustment.order)
  adjustments: AdjustmentEntity[];
  @OneToOne(() => DeliveryInfoEntity, (deliveryInfo) => deliveryInfo.order, {
    cascade: true,
    nullable: true,
  })
  deliveryInfo: DeliveryInfoEntity | null;
  @OneToMany(() => OrderPreparationScreenStatusEntity, (status) => status.order)
  preparationScreenStatuses: OrderPreparationScreenStatusEntity[];
  @Column({
    name: 'estimated_delivery_time',
    type: 'timestamptz',
    nullable: true,
  })
  estimatedDeliveryTime: Date | null;
  @Column({
    name: 'finalized_at',
    type: 'timestamptz',
    nullable: true,
  })
  finalizedAt: Date | null;
  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;
  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;
  @DeleteDateColumn({ type: 'timestamptz' })
  deletedAt: Date | null;
}

================
File: backend/src/orders/orders.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { OrdersService } from './orders.service';
import { OrdersController } from './orders.controller';
import { TicketImpressionsController } from './ticket-impressions.controller';
import { OrderSubscriber } from './infrastructure/persistence/relational/subscribers/order.subscriber';
import { OrderChangeLogService } from './order-change-log.service';
import { OrderChangeTrackerV2Service } from './services/order-change-tracker-v2.service';
import { UsersModule } from '../users/users.module';
import { TablesModule } from '../tables/tables.module';
import { PaymentsModule } from '../payments/payments.module';
import { ProductsModule } from '../products/products.module';
import { ProductVariantsModule } from '../product-variants/product-variants.module';
import { ProductModifiersModule } from '../product-modifiers/product-modifiers.module';
import { RelationalOrderPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { RelationalProductPersistenceModule } from '../products/infrastructure/persistence/relational/relational-persistence.module';
import { CommonModule } from '../common/common.module';
import { CustomersModule } from '../customers/customers.module';
import { PizzaPriceCalculatorService } from './services/pizza-price-calculator.service';
import { RestaurantConfigModule } from '../restaurant-config/restaurant-config.module';
import { ShiftsModule } from '../shifts/shifts.module';
import { ThermalPrintersModule } from '../thermal-printers/thermal-printers.module';
@Module({
  imports: [
    RelationalOrderPersistenceModule,
    forwardRef(() => RelationalProductPersistenceModule),
    CommonModule,
    UsersModule,
    TablesModule,
    PaymentsModule,
    forwardRef(() => ProductsModule),
    forwardRef(() => ProductVariantsModule),
    forwardRef(() => ProductModifiersModule),
    CustomersModule,
    RestaurantConfigModule,
    forwardRef(() => ShiftsModule),
    forwardRef(() => ThermalPrintersModule),
  ],
  controllers: [OrdersController, TicketImpressionsController],
  providers: [
    OrdersService,
    OrderSubscriber,
    OrderChangeLogService,
    PizzaPriceCalculatorService,
    OrderChangeTrackerV2Service,
  ],
  exports: [
    OrdersService,
    OrderChangeLogService,
    RelationalOrderPersistenceModule,
  ],
})
export class OrdersModule {}

================
File: backend/src/product-modifiers/product-modifiers.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus,
  HttpCode,
  ParseBoolPipe,
} from '@nestjs/common';
import { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';
import { ProductModifiersService } from './product-modifiers.service';
import { CreateProductModifierDto } from './dto/create-product-modifier.dto';
import { UpdateProductModifierDto } from './dto/update-product-modifier.dto';
import { FindAllProductModifiersDto } from './dto/find-all-product-modifiers.dto';
import { ProductModifier } from './domain/product-modifier';
import { Paginated } from '../common/types/paginated.type';
@ApiTags('Product Modifiers')
@Controller({ path: 'product-modifiers', version: '1' })
export class ProductModifiersController {
  constructor(
    private readonly productModifiersService: ProductModifiersService,
  ) {}
  @Post()
  @ApiOperation({ summary: 'Create a new product modifier' })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'The product modifier has been successfully created.',
    type: ProductModifier,
  })
  create(
    @Body() createProductModifierDto: CreateProductModifierDto,
  ): Promise<ProductModifier> {
    return this.productModifiersService.create(createProductModifierDto);
  }
  @Get()
  @ApiOperation({ summary: 'Get all product modifiers with pagination' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Return a paginated list of product modifiers',
  })
  findAll(
    @Query() filterDto: FindAllProductModifiersDto,
    @Query('page') page = 1,
    @Query('limit') limit = 10,
  ): Promise<Paginated<ProductModifier>> {
    return this.productModifiersService.findAll(filterDto, {
      page,
      limit,
    });
  }
  @Get(':id')
  @ApiOperation({ summary: 'Get a product modifier by id' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Return the product modifier with the specified id',
    type: ProductModifier,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Product modifier not found',
  })
  findOne(@Param('id') id: string): Promise<ProductModifier> {
    return this.productModifiersService.findOne(id);
  }
  @Get('by-group/:modifierGroupId')
  @ApiOperation({ summary: 'Get all product modifiers by group id' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Return all product modifiers for the specified group id',
    type: [ProductModifier],
  })
  findByGroupId(
    @Param('modifierGroupId') modifierGroupId: string,
    @Query('isActive', new ParseBoolPipe({ optional: true }))
    isActive?: boolean,
    @Query('search') search?: string,
  ): Promise<ProductModifier[]> {
    return this.productModifiersService.findByGroupId(modifierGroupId, {
      isActive,
      search,
    });
  }
  @Patch(':id')
  @ApiOperation({ summary: 'Update a product modifier' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'The product modifier has been successfully updated.',
    type: ProductModifier,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Product modifier not found',
  })
  update(
    @Param('id') id: string,
    @Body() updateProductModifierDto: UpdateProductModifierDto,
  ): Promise<ProductModifier> {
    return this.productModifiersService.update(id, updateProductModifierDto);
  }
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete a product modifier' })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'The product modifier has been successfully deleted.',
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Product modifier not found',
  })
  remove(@Param('id') id: string): Promise<void> {
    return this.productModifiersService.remove(id);
  }
}

================
File: backend/src/restaurant-config/domain/restaurant-config.ts
================
import { BusinessHours } from './business-hours';
export class RestaurantConfig {
  id: string;
  restaurantName: string;
  phoneMain: string | null;
  phoneSecondary: string | null;
  address: string | null;
  city: string | null;
  state: string | null;
  postalCode: string | null;
  country: string | null;
  acceptingOrders: boolean;
  estimatedPickupTime: number;
  estimatedDeliveryTime: number;
  estimatedDineInTime: number;
  openingGracePeriod: number;
  closingGracePeriod: number;
  timeZone: string;
  scheduledOrdersLeadTime: number;
  deliveryCoverageArea: any | null;
  minimumOrderValueForDelivery: number;
  businessHours: BusinessHours[];
  createdAt: Date;
  updatedAt: Date;
}

================
File: backend/src/restaurant-config/dto/restaurant-config.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { BusinessHoursDto } from './business-hours.dto';
export class RestaurantConfigDto {
  @ApiProperty({
    type: String,
    example: 'cbcfa8b8-3a25-4adb-a9c6-e325f0d0f3ae',
  })
  id: string;
  @ApiProperty({
    type: String,
    example: 'La Leña',
    description: 'Nombre del restaurante',
  })
  restaurantName: string;
  @ApiPropertyOptional({
    type: String,
    example: '+52 555 123 4567',
    description: 'Teléfono principal',
  })
  phoneMain: string | null;
  @ApiPropertyOptional({
    type: String,
    example: '+52 555 987 6543',
    description: 'Teléfono secundario',
  })
  phoneSecondary: string | null;
  @ApiPropertyOptional({
    type: String,
    example: 'Av. Principal 123, Col. Centro',
    description: 'Dirección completa',
  })
  address: string | null;
  @ApiPropertyOptional({
    type: String,
    example: 'Ciudad de México',
    description: 'Ciudad',
  })
  city: string | null;
  @ApiPropertyOptional({
    type: String,
    example: 'CDMX',
    description: 'Estado',
  })
  state: string | null;
  @ApiPropertyOptional({
    type: String,
    example: '06000',
    description: 'Código postal',
  })
  postalCode: string | null;
  @ApiPropertyOptional({
    type: String,
    example: 'México',
    description: 'País',
  })
  country: string | null;
  @ApiProperty({
    type: Boolean,
    example: true,
    description: 'Indica si se están aceptando pedidos',
  })
  acceptingOrders: boolean;
  @ApiProperty({
    type: Number,
    example: 20,
    description: 'Tiempo estimado de recolección en minutos',
  })
  estimatedPickupTime: number;
  @ApiProperty({
    type: Number,
    example: 40,
    description: 'Tiempo estimado de entrega en minutos',
  })
  estimatedDeliveryTime: number;
  @ApiProperty({
    type: Number,
    example: 25,
    description: 'Tiempo estimado para servir en mesa en minutos',
  })
  estimatedDineInTime: number;
  @ApiProperty({
    type: Number,
    example: 30,
    description: 'Minutos después de abrir antes de aceptar pedidos',
  })
  openingGracePeriod: number;
  @ApiProperty({
    type: Number,
    example: 30,
    description: 'Minutos antes de cerrar para dejar de aceptar pedidos',
  })
  closingGracePeriod: number;
  @ApiProperty({
    type: String,
    example: 'America/Mexico_City',
    description: 'Zona horaria del restaurante',
  })
  timeZone: string;
  @ApiProperty({
    type: Number,
    example: 60,
    description:
      'Minutos antes de la hora programada para mostrar órdenes en preparación',
  })
  scheduledOrdersLeadTime: number;
  @ApiPropertyOptional({
    type: 'object',
    description: 'Polígono de cobertura de delivery',
    example: [
      { lat: 19.4326, lng: -99.1332 },
      { lat: 19.435, lng: -99.135 },
      { lat: 19.43, lng: -99.138 },
    ],
    additionalProperties: true,
  })
  deliveryCoverageArea: any | null;
  @ApiProperty({
    type: Number,
    example: 50,
    description: 'Valor mínimo de orden para entrega a domicilio',
  })
  minimumOrderValueForDelivery: number;
  @ApiProperty({
    type: () => [BusinessHoursDto],
    description: 'Horarios de operación por día',
  })
  @Type(() => BusinessHoursDto)
  businessHours: BusinessHoursDto[];
  @ApiProperty()
  createdAt: Date;
  @ApiProperty()
  updatedAt: Date;
}

================
File: backend/src/restaurant-config/dto/update-restaurant-config.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsBoolean,
  IsInt,
  IsOptional,
  Min,
  IsString,
  MaxLength,
  IsArray,
  ValidateNested,
  IsNumber,
} from 'class-validator';
import { Type } from 'class-transformer';
import { CreateBusinessHoursDto } from './create-business-hours.dto';
export class UpdateRestaurantConfigDto {
  @ApiPropertyOptional({
    type: String,
    example: 'La Leña',
    description: 'Nombre del restaurante',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  restaurantName?: string;
  @ApiPropertyOptional({
    type: String,
    example: '+52 555 123 4567',
    description: 'Teléfono principal',
  })
  @IsOptional()
  @IsString()
  @MaxLength(20)
  phoneMain?: string | null;
  @ApiPropertyOptional({
    type: String,
    example: '+52 555 987 6543',
    description: 'Teléfono secundario',
  })
  @IsOptional()
  @IsString()
  @MaxLength(20)
  phoneSecondary?: string | null;
  @ApiPropertyOptional({
    type: String,
    example: 'Av. Principal 123, Col. Centro',
    description: 'Dirección completa',
  })
  @IsOptional()
  @IsString()
  address?: string | null;
  @ApiPropertyOptional({
    type: String,
    example: 'Ciudad de México',
    description: 'Ciudad',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  city?: string | null;
  @ApiPropertyOptional({
    type: String,
    example: 'CDMX',
    description: 'Estado',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  state?: string | null;
  @ApiPropertyOptional({
    type: String,
    example: '06000',
    description: 'Código postal',
  })
  @IsOptional()
  @IsString()
  @MaxLength(20)
  postalCode?: string | null;
  @ApiPropertyOptional({
    type: String,
    example: 'México',
    description: 'País',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  country?: string | null;
  @ApiPropertyOptional({
    type: Boolean,
    example: true,
    description: 'Indica si se están aceptando pedidos',
  })
  @IsOptional()
  @IsBoolean()
  acceptingOrders?: boolean;
  @ApiPropertyOptional({
    type: Number,
    example: 20,
    description: 'Tiempo estimado de recolección en minutos',
  })
  @IsOptional()
  @IsInt()
  @Min(1)
  estimatedPickupTime?: number;
  @ApiPropertyOptional({
    type: Number,
    example: 40,
    description: 'Tiempo estimado de entrega en minutos',
  })
  @IsOptional()
  @IsInt()
  @Min(1)
  estimatedDeliveryTime?: number;
  @ApiPropertyOptional({
    type: Number,
    example: 25,
    description: 'Tiempo estimado para servir en mesa en minutos',
  })
  @IsOptional()
  @IsInt()
  @Min(1)
  estimatedDineInTime?: number;
  @ApiPropertyOptional({
    type: Number,
    example: 30,
    description: 'Minutos después de abrir antes de aceptar pedidos',
  })
  @IsOptional()
  @IsInt()
  @Min(0)
  openingGracePeriod?: number;
  @ApiPropertyOptional({
    type: Number,
    example: 30,
    description: 'Minutos antes de cerrar para dejar de aceptar pedidos',
  })
  @IsOptional()
  @IsInt()
  @Min(0)
  closingGracePeriod?: number;
  @ApiPropertyOptional({
    type: String,
    example: 'America/Mexico_City',
    description: 'Zona horaria del restaurante',
  })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  timeZone?: string;
  @ApiPropertyOptional({
    type: Number,
    example: 60,
    description:
      'Minutos antes de la hora programada para mostrar órdenes en preparación',
  })
  @IsOptional()
  @IsInt()
  @Min(1)
  scheduledOrdersLeadTime?: number;
  @ApiPropertyOptional({
    type: 'object',
    description: 'Polígono de cobertura de delivery',
    example: [
      { lat: 19.4326, lng: -99.1332 },
      { lat: 19.435, lng: -99.135 },
      { lat: 19.43, lng: -99.138 },
    ],
    additionalProperties: true,
  })
  @IsOptional()
  deliveryCoverageArea?: any | null;
  @ApiPropertyOptional({
    type: Number,
    example: 50,
    description: 'Valor mínimo de orden para entrega a domicilio',
  })
  @IsOptional()
  @IsNumber()
  @Min(0)
  minimumOrderValueForDelivery?: number;
  @ApiPropertyOptional({
    type: () => [CreateBusinessHoursDto],
    description: 'Horarios de operación por día',
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateBusinessHoursDto)
  businessHours?: CreateBusinessHoursDto[];
}

================
File: backend/src/restaurant-config/infrastructure/persistence/relational/entities/restaurant-config.entity.ts
================
import {
  CreateDateColumn,
  Entity,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
  Column,
  OneToMany,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
import { BusinessHoursEntity } from './business-hours.entity';
@Entity({
  name: 'restaurant_config',
})
export class RestaurantConfigEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({ type: 'varchar', length: 200, default: 'Restaurant' })
  restaurantName: string;
  @Column({ type: 'varchar', length: 20, nullable: true })
  phoneMain: string | null;
  @Column({ type: 'varchar', length: 20, nullable: true })
  phoneSecondary: string | null;
  @Column({ type: 'text', nullable: true })
  address: string | null;
  @Column({ type: 'varchar', length: 100, nullable: true })
  city: string | null;
  @Column({ type: 'varchar', length: 100, nullable: true })
  state: string | null;
  @Column({ type: 'varchar', length: 20, nullable: true })
  postalCode: string | null;
  @Column({ type: 'varchar', length: 100, nullable: true })
  country: string | null;
  @Column({ type: 'boolean', default: true })
  acceptingOrders: boolean;
  @Column({ type: 'int', default: 20 })
  estimatedPickupTime: number;
  @Column({ type: 'int', default: 40 })
  estimatedDeliveryTime: number;
  @Column({ type: 'int', default: 25 })
  estimatedDineInTime: number;
  @Column({ type: 'int', default: 30 })
  openingGracePeriod: number;
  @Column({ type: 'int', default: 30 })
  closingGracePeriod: number;
  @Column({ type: 'varchar', length: 50, default: 'America/Mexico_City' })
  timeZone: string;
  @Column({ type: 'int', default: 60 })
  scheduledOrdersLeadTime: number;
  @Column({ type: 'jsonb', nullable: true })
  deliveryCoverageArea: any | null;
  @Column({ type: 'decimal', precision: 10, scale: 2, default: 0 })
  minimumOrderValueForDelivery: number;
  @OneToMany(
    () => BusinessHoursEntity,
    (businessHours) => businessHours.restaurantConfig,
  )
  businessHours: BusinessHoursEntity[];
  @CreateDateColumn()
  createdAt: Date;
  @UpdateDateColumn()
  updatedAt: Date;
}

================
File: backend/src/restaurant-config/restaurant-config.service.ts
================
import {
  Injectable,
  NotFoundException,
  Inject,
  forwardRef,
  BadRequestException,
} from '@nestjs/common';
import { RestaurantConfigRepository } from './infrastructure/persistence/restaurant-config.repository';
import { RestaurantConfig } from './domain/restaurant-config';
import { UpdateRestaurantConfigDto } from './dto/update-restaurant-config.dto';
import { ShiftsService } from '../shifts/shifts.service';
@Injectable()
export class RestaurantConfigService {
  constructor(
    private readonly restaurantConfigRepository: RestaurantConfigRepository,
    @Inject(forwardRef(() => ShiftsService))
    private readonly shiftsService: ShiftsService,
  ) {}
  async findOrCreate(): Promise<RestaurantConfig> {
    let config = await this.restaurantConfigRepository.findFirst();
    if (!config) {
      const defaultConfig = new RestaurantConfig();
      defaultConfig.restaurantName = 'Restaurante Ejemplo';
      defaultConfig.phoneMain = null;
      defaultConfig.phoneSecondary = null;
      defaultConfig.address = null;
      defaultConfig.city = null;
      defaultConfig.state = null;
      defaultConfig.postalCode = null;
      defaultConfig.country = null;
      defaultConfig.acceptingOrders = true;
      defaultConfig.estimatedPickupTime = 20;
      defaultConfig.estimatedDeliveryTime = 40;
      defaultConfig.estimatedDineInTime = 25;
      defaultConfig.openingGracePeriod = 30;
      defaultConfig.closingGracePeriod = 30;
      defaultConfig.timeZone = 'America/Mexico_City';
      defaultConfig.deliveryCoverageArea = null;
      defaultConfig.businessHours = [];
      config = await this.restaurantConfigRepository.create(defaultConfig);
    }
    return config;
  }
  async getConfig(): Promise<RestaurantConfig> {
    return this.findOrCreate();
  }
  async updateConfig(
    updateRestaurantConfigDto: UpdateRestaurantConfigDto,
  ): Promise<RestaurantConfig> {
    const config = await this.findOrCreate();
    if (
      updateRestaurantConfigDto.acceptingOrders !== undefined &&
      updateRestaurantConfigDto.acceptingOrders !== config.acceptingOrders
    ) {
      const isShiftOpen = await this.shiftsService.isShiftOpen();
      if (!isShiftOpen) {
        throw new BadRequestException(
          'No se puede cambiar el estado de "Aceptar Pedidos" porque no hay ningún turno abierto.',
        );
      }
    }
    const updated = await this.restaurantConfigRepository.update(
      config.id,
      updateRestaurantConfigDto as Partial<RestaurantConfig>,
    );
    if (!updated) {
      throw new NotFoundException('Configuration not found');
    }
    return updated;
  }
}

================
File: backend/src/shifts/domain/shift.ts
================
import { User } from '../../users/domain/user';
export enum ShiftStatus {
  OPEN = 'OPEN',
  CLOSED = 'CLOSED',
}
export class Shift {
  id: string;
  date: Date;
  globalShiftNumber: number;
  shiftNumber: number;
  openedAt: Date;
  closedAt: Date | null;
  openedBy: User;
  closedBy: User | null;
  initialCash: number;
  finalCash: number | null;
  totalSales: number | null;
  totalOrders: number | null;
  cashDifference: number | null;
  status: ShiftStatus;
  notes: string | null;
  closeNotes: string | null;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
  isOpen(): boolean {
    return this.status === ShiftStatus.OPEN;
  }
  isClosed(): boolean {
    return this.status === ShiftStatus.CLOSED;
  }
  canClose(): boolean {
    return this.isOpen() && this.finalCash !== null;
  }
  calculateCashDifference(expectedCash: number): number {
    if (this.finalCash === null) {
      return 0;
    }
    return this.finalCash - expectedCash;
  }
}

================
File: backend/src/shifts/dto/shift-summary.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { ShiftStatus } from '../domain/shift';
export class ShiftSummaryDto {
  @ApiProperty({
    description: 'ID del turno',
    example: 'f47ac10b-58cc-4372-a567-0e02b2c3d479',
  })
  id: string;
  @ApiProperty({
    description: 'Fecha del turno',
    example: '2024-01-15',
  })
  date: Date;
  @ApiProperty({
    description: 'Número consecutivo global del turno',
    example: 145,
  })
  globalShiftNumber: number;
  @ApiProperty({
    description: 'Número de turno de la fecha',
    example: 1,
  })
  shiftNumber: number;
  @ApiProperty({
    description: 'Estado del turno',
    enum: ShiftStatus,
    example: ShiftStatus.OPEN,
  })
  status: ShiftStatus;
  @ApiProperty({
    description: 'Hora de apertura',
    example: '2024-01-15T11:00:00Z',
  })
  openedAt: Date;
  @ApiProperty({
    description: 'Hora de cierre',
    example: '2024-01-16T02:30:00Z',
    nullable: true,
  })
  closedAt: Date | null;
  @ApiProperty({
    description: 'Usuario que abrió el turno',
    example: { id: 'user-id', firstName: 'Juan', lastName: 'Pérez' },
  })
  openedBy: {
    id: string;
    firstName: string;
    lastName: string;
  };
  @ApiProperty({
    description: 'Usuario que cerró el turno',
    example: { id: 'user-id', firstName: 'María', lastName: 'García' },
    nullable: true,
  })
  closedBy: {
    id: string;
    firstName: string;
    lastName: string;
  } | null;
  @ApiProperty({
    description: 'Efectivo inicial',
    example: 500.0,
  })
  initialCash: number;
  @ApiProperty({
    description: 'Efectivo final',
    example: 2500.0,
    nullable: true,
  })
  finalCash: number | null;
  @ApiProperty({
    description: 'Total de ventas del turno',
    example: 2000.0,
    nullable: true,
  })
  totalSales: number | null;
  @ApiProperty({
    description: 'Total de órdenes del turno',
    example: 45,
    nullable: true,
  })
  totalOrders: number | null;
  @ApiProperty({
    description: 'Diferencia de efectivo (final - esperado)',
    example: 0.0,
    nullable: true,
  })
  cashDifference: number | null;
  @ApiProperty({
    description: 'Efectivo esperado (inicial + ventas en efectivo)',
    example: 2500.0,
    nullable: true,
  })
  expectedCash?: number | null;
  @ApiProperty({
    description: 'Notas de apertura',
    example: 'Apertura normal',
    nullable: true,
  })
  notes: string | null;
  @ApiProperty({
    description: 'Notas de cierre',
    example: 'Todo cuadra correctamente',
    nullable: true,
  })
  closeNotes: string | null;
}

================
File: backend/src/shifts/infrastructure/persistence/relational/repositories/shift.repository.ts
================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ShiftRepository } from '../../shift.repository';
import { ShiftEntity } from '../entities/shift.entity';
import { ShiftMapper } from '../mappers/shift.mapper';
import { Shift, ShiftStatus } from '../../../../domain/shift';
@Injectable()
export class ShiftRelationalRepository extends ShiftRepository {
  constructor(
    @InjectRepository(ShiftEntity)
    private readonly shiftRepository: Repository<ShiftEntity>,
    private readonly shiftMapper: ShiftMapper,
  ) {
    super();
  }
  async create(shift: Shift): Promise<Shift> {
    const entity = this.shiftMapper.toPersistence(shift);
    const savedEntity = await this.shiftRepository.save(entity);
    return this.shiftMapper.toDomain(savedEntity)!;
  }
  async findById(id: string): Promise<Shift | null> {
    const entity = await this.shiftRepository.findOne({
      where: { id },
      relations: ['openedBy', 'closedBy'],
    });
    return entity ? this.shiftMapper.toDomain(entity) : null;
  }
  async findByDate(date: Date): Promise<Shift | null> {
    const entity = await this.shiftRepository.findOne({
      where: { date },
      relations: ['openedBy', 'closedBy'],
    });
    return entity ? this.shiftMapper.toDomain(entity) : null;
  }
  async findAllByDate(date: Date): Promise<Shift[]> {
    const entities = await this.shiftRepository.find({
      where: { date },
      relations: ['openedBy', 'closedBy'],
      order: { openedAt: 'ASC' },
    });
    return entities
      .map((entity) => this.shiftMapper.toDomain(entity))
      .filter((shift): shift is Shift => shift !== null);
  }
  async findCurrent(): Promise<Shift | null> {
    const entity = await this.shiftRepository.findOne({
      where: { status: ShiftStatus.OPEN },
      relations: ['openedBy', 'closedBy'],
      order: { openedAt: 'DESC' },
    });
    return entity ? this.shiftMapper.toDomain(entity) : null;
  }
  async findLastClosed(): Promise<Shift | null> {
    const entity = await this.shiftRepository.findOne({
      where: { status: ShiftStatus.CLOSED },
      relations: ['openedBy', 'closedBy'],
      order: { closedAt: 'DESC' },
    });
    return entity ? this.shiftMapper.toDomain(entity) : null;
  }
  async findByStatus(status: ShiftStatus): Promise<Shift[]> {
    const entities = await this.shiftRepository.find({
      where: { status },
      relations: ['openedBy', 'closedBy'],
      order: { openedAt: 'DESC' },
    });
    return entities
      .map((entity) => this.shiftMapper.toDomain(entity))
      .filter((domain): domain is Shift => domain !== null);
  }
  async update(id: string, payload: Partial<Shift>): Promise<Shift | null> {
    await this.shiftRepository.update(id, payload as any);
    const updated = await this.findById(id);
    return updated;
  }
  async getNextGlobalShiftNumber(): Promise<number> {
    const lastShifts = await this.shiftRepository.find({
      order: { globalShiftNumber: 'DESC' },
      take: 1,
    });
    const lastShift = lastShifts[0];
    return lastShift ? lastShift.globalShiftNumber + 1 : 1;
  }
}

================
File: backend/src/shifts/infrastructure/persistence/shift.repository.ts
================
import { Shift, ShiftStatus } from '../../domain/shift';
export abstract class ShiftRepository {
  abstract create(shift: Shift): Promise<Shift>;
  abstract findById(id: string): Promise<Shift | null>;
  abstract findByDate(date: Date): Promise<Shift | null>;
  abstract findAllByDate(date: Date): Promise<Shift[]>;
  abstract findCurrent(): Promise<Shift | null>;
  abstract findLastClosed(): Promise<Shift | null>;
  abstract findByStatus(status: ShiftStatus): Promise<Shift[]>;
  abstract update(id: string, payload: Partial<Shift>): Promise<Shift | null>;
  abstract getNextGlobalShiftNumber(): Promise<number>;
}

================
File: backend/src/shifts/shifts.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { ShiftsController } from './shifts.controller';
import { ShiftsService } from './shifts.service';
import { RelationalShiftPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { RestaurantConfigModule } from '../restaurant-config/restaurant-config.module';
import { RelationalOrderPersistenceModule } from '../orders/infrastructure/persistence/relational/relational-persistence.module';
import { RelationalPaymentPersistenceModule } from '../payments/infrastructure/persistence/relational/relational-persistence.module';
@Module({
  imports: [
    RelationalShiftPersistenceModule,
    forwardRef(() => RestaurantConfigModule),
    forwardRef(() => RelationalOrderPersistenceModule),
    forwardRef(() => RelationalPaymentPersistenceModule),
  ],
  controllers: [ShiftsController],
  providers: [ShiftsService],
  exports: [ShiftsService],
})
export class ShiftsModule {}

================
File: backend/src/sync/dto/pull-changes-request.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsArray, IsUUID } from 'class-validator';
export class PullChangesRequestDto {
  @ApiPropertyOptional({
    description: 'IDs de órdenes procesadas exitosamente en el pull anterior',
    example: ['order_123', 'order_456'],
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsUUID('4', { each: true })
  confirmedOrderIds?: string[];
  @ApiPropertyOptional({
    description: 'IDs de clientes procesados exitosamente en el pull anterior',
    example: ['customer_789', 'customer_012'],
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsUUID('4', { each: true })
  confirmedCustomerIds?: string[];
}

================
File: backend/src/sync/dto/pull-changes-response.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { Order } from '../../orders/domain/order';
import { Customer } from '../../customers/domain/customer';
export class PullChangesResponseDto {
  @ApiProperty({
    type: [Order],
    description: 'Lista de pedidos pendientes de sincronización',
  })
  pending_orders: Order[];
  @ApiProperty({
    type: [Customer],
    description: 'Lista de clientes actualizados pendientes de sincronización',
  })
  updated_customers: Customer[];
}

================
File: backend/src/sync/dto/restaurant-data-query.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsDateString } from 'class-validator';
export class RestaurantDataQueryDto {
  @ApiPropertyOptional({
    description:
      'Devolver datos solo si fueron modificados después de esta fecha',
    example: '2024-01-15T10:00:00Z',
  })
  @IsOptional()
  @IsDateString()
  if_modified_since?: string;
}

================
File: backend/src/sync/dto/restaurant-data-response.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { Category } from '../../categories/domain/category';
import { RestaurantConfig } from '../../restaurant-config/domain/restaurant-config';
import { BusinessHours } from '../../restaurant-config/domain/business-hours';
class MenuDataDto {
  @ApiProperty({
    type: [Category],
    description: 'Lista completa de categorías con productos',
  })
  categories: Category[];
  @ApiProperty({
    description: 'Fecha de última actualización del menú',
    example: '2024-01-15T10:30:00Z',
  })
  lastUpdated: Date;
}
class ConfigDataDto {
  @ApiProperty({
    type: RestaurantConfig,
    description: 'Configuración completa del restaurante',
  })
  restaurantConfig: RestaurantConfig;
  @ApiProperty({
    type: [BusinessHours],
    description: 'Horarios de operación del restaurante',
  })
  businessHours: BusinessHours[];
  @ApiProperty({
    description: 'Fecha de última actualización de la configuración',
    example: '2024-01-15T10:30:00Z',
  })
  lastUpdated: Date;
}
export class RestaurantDataResponseDto {
  @ApiProperty({
    type: MenuDataDto,
    description: 'Datos completos del menú',
  })
  menu: MenuDataDto;
  @ApiProperty({
    type: ConfigDataDto,
    description: 'Datos completos de configuración',
  })
  config: ConfigDataDto;
  @ApiProperty({
    description: 'Timestamp del momento de la respuesta',
    example: '2024-01-15T10:30:00Z',
  })
  timestamp: Date;
}

================
File: backend/src/sync/dto/update-order-status-response.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
export class UpdateOrderStatusResponseDto {
  @ApiProperty({
    description: 'Indica si la actualización fue exitosa',
    example: true,
  })
  success: boolean;
  @ApiProperty({
    description: 'Mensaje de respuesta',
    example: 'Estado del pedido actualizado correctamente',
  })
  message: string;
  @ApiProperty({
    description: 'Timestamp de cuando se realizó la actualización',
    example: '2024-01-15T12:03:00Z',
  })
  updatedAt: string;
  @ApiProperty({
    description: 'Indica si se notificó al cliente por WhatsApp',
    example: true,
  })
  customerNotified: boolean;
}

================
File: backend/src/sync/dto/update-order-status.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEnum, IsUUID } from 'class-validator';
import { OrderStatus } from '../../orders/domain/enums/order-status.enum';
export class UpdateOrderStatusDto {
  @ApiProperty({
    description: 'ID del pedido a actualizar',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsUUID()
  orderId: string;
  @ApiProperty({
    description: 'Nuevo estado del pedido',
    enum: OrderStatus,
    example: OrderStatus.IN_PROGRESS,
  })
  @IsEnum(OrderStatus)
  newStatus: OrderStatus;
}

================
File: backend/src/sync/infrastructure/persistence/relational/entities/sync-activity.entity.ts
================
import {
  Column,
  CreateDateColumn,
  Entity,
  PrimaryGeneratedColumn,
} from 'typeorm';
import { EntityRelationalHelper } from '../../../../../utils/relational-entity-helper';
export enum SyncActivityType {
  PULL_CHANGES = 'PULL_CHANGES',
  RESTAURANT_DATA = 'RESTAURANT_DATA',
  ORDER_STATUS = 'ORDER_STATUS',
}
@Entity({
  name: 'sync_activity',
})
export class SyncActivityEntity extends EntityRelationalHelper {
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Column({
    type: 'enum',
    enum: SyncActivityType,
  })
  type: SyncActivityType;
  @Column({ type: 'varchar', length: 10 })
  direction: 'IN' | 'OUT';
  @Column({ type: 'boolean', default: true })
  success: boolean;
  @CreateDateColumn({ type: 'timestamptz' })
  timestamp: Date;
}

================
File: backend/src/sync/sync.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { HttpModule } from '@nestjs/axios';
import { LocalSyncService } from './services/local-sync.service';
import { SyncController } from './controllers/sync.controller';
import syncConfig from './config/sync.config';
import { CategoriesModule } from '../categories/categories.module';
import { RestaurantConfigModule } from '../restaurant-config/restaurant-config.module';
const providers = [LocalSyncService];
@Module({
  imports: [
    ConfigModule.forFeature(syncConfig),
    HttpModule,
    CategoriesModule,
    RestaurantConfigModule,
  ],
  controllers: [SyncController],
  providers,
  exports: [LocalSyncService],
})
export class SyncModule {}

================
File: backend/src/thermal-printers/dto/create-thermal-printer.dto.ts
================
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsBoolean,
  IsEnum,
  IsIP,
  IsInt,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsMACAddress,
  MaxLength,
  Min,
  ValidateIf,
} from 'class-validator';
import { PrinterConnectionType } from '../domain/thermal-printer';
export class CreateThermalPrinterDto {
  @ApiProperty({
    type: String,
    example: 'Cocina Principal',
    description: 'Nombre descriptivo de la impresora',
  })
  @IsNotEmpty()
  @IsString()
  @MaxLength(100)
  name: string;
  @ApiProperty({
    enum: PrinterConnectionType,
    example: PrinterConnectionType.NETWORK,
    description: 'Tipo de conexión de la impresora',
  })
  @IsNotEmpty()
  @IsEnum(PrinterConnectionType)
  connectionType: PrinterConnectionType;
  @ApiPropertyOptional({
    type: String,
    example: '192.168.1.100',
    description: 'Dirección IP (requerida si connectionType es NETWORK)',
  })
  @IsOptional()
  @ValidateIf((o) => o.connectionType === PrinterConnectionType.NETWORK)
  @IsNotEmpty({ message: 'La dirección IP es requerida para conexión NETWORK' })
  @IsIP('4', { message: 'La dirección IP no es válida' })
  ipAddress?: string;
  @ApiPropertyOptional({
    type: Number,
    example: 9100,
    description: 'Puerto (requerido si connectionType es NETWORK)',
  })
  @IsOptional()
  @ValidateIf((o) => o.connectionType === PrinterConnectionType.NETWORK)
  @IsNotEmpty({ message: 'El puerto es requerido para conexión NETWORK' })
  @IsInt()
  @Min(1)
  port?: number;
  @ApiPropertyOptional({
    type: String,
    example: '/dev/usb/lp0',
    description:
      'Ruta o identificador del dispositivo (requerido si connectionType es USB, SERIAL o BLUETOOTH)',
  })
  @IsOptional()
  @ValidateIf((o) =>
    [
      PrinterConnectionType.USB,
      PrinterConnectionType.SERIAL,
      PrinterConnectionType.BLUETOOTH,
    ].includes(o.connectionType),
  )
  @IsNotEmpty({
    message:
      'La ruta/identificador es requerido para conexiones USB/SERIAL/BLUETOOTH',
  })
  @IsString()
  path?: string;
  @ApiPropertyOptional({
    type: Boolean,
    example: true,
    description: 'Indica si la impresora está activa',
    default: true,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiPropertyOptional({
    type: String,
    example: '00:1A:2B:3C:4D:5E',
    description: 'Dirección MAC de la impresora (opcional)',
  })
  @IsOptional()
  @IsMACAddress({ message: 'La dirección MAC no es válida' })
  macAddress?: string;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    description: 'Marca la impresora como predeterminada para el sistema',
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isDefaultPrinter?: boolean;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    description: 'Habilita la impresión automática para órdenes de delivery',
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  autoDeliveryPrint?: boolean;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    description:
      'Habilita la impresión automática para órdenes de pickup (take away)',
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  autoPickupPrint?: boolean;
  @ApiPropertyOptional({
    type: Number,
    example: 80,
    description: 'Ancho del papel en milímetros (58 o 80 son los más comunes)',
    default: 80,
  })
  @IsOptional()
  @IsInt()
  @Min(58)
  paperWidth?: number;
  @ApiPropertyOptional({
    type: Number,
    example: 48,
    description: 'Número de caracteres por línea en modo normal',
    default: 48,
  })
  @IsOptional()
  @IsInt()
  @Min(32)
  charactersPerLine?: number;
  @ApiPropertyOptional({
    type: Boolean,
    example: true,
    description: 'Cortar el papel automáticamente al final del ticket',
    default: true,
  })
  @IsOptional()
  @IsBoolean()
  cutPaper?: boolean;
  @ApiPropertyOptional({
    type: Number,
    example: 3,
    description:
      'Líneas en blanco a añadir al final del ticket antes del corte',
    default: 3,
  })
  @IsOptional()
  @IsInt()
  @Min(0)
  feedLines?: number;
}

================
File: backend/src/thermal-printers/dto/update-thermal-printer.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsBoolean,
  IsEnum,
  IsIP,
  IsInt,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsMACAddress,
  MaxLength,
  Min,
  ValidateIf,
} from 'class-validator';
import { PrinterConnectionType } from '../domain/thermal-printer';
export class UpdateThermalPrinterDto {
  @ApiPropertyOptional({
    type: String,
    example: 'Cocina Principal',
    description: 'Nombre descriptivo de la impresora',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  name?: string;
  @ApiPropertyOptional({
    enum: PrinterConnectionType,
    example: PrinterConnectionType.NETWORK,
    description: 'Tipo de conexión de la impresora',
  })
  @IsOptional()
  @IsEnum(PrinterConnectionType)
  connectionType?: PrinterConnectionType;
  @ApiPropertyOptional({
    type: String,
    example: '192.168.1.100',
    description: 'Dirección IP (requerida si connectionType es NETWORK)',
  })
  @IsOptional()
  @ValidateIf((o) => o.connectionType === PrinterConnectionType.NETWORK)
  @IsNotEmpty({ message: 'La dirección IP es requerida para conexión NETWORK' })
  @IsIP('4', { message: 'La dirección IP no es válida' })
  ipAddress?: string | null;
  @ApiPropertyOptional({
    type: Number,
    example: 9100,
    description: 'Puerto (requerido si connectionType es NETWORK)',
  })
  @IsOptional()
  @ValidateIf((o) => o.connectionType === PrinterConnectionType.NETWORK)
  @IsNotEmpty({ message: 'El puerto es requerido para conexión NETWORK' })
  @IsInt()
  @Min(1)
  port?: number | null;
  @ApiPropertyOptional({
    type: String,
    example: '/dev/usb/lp0',
    description:
      'Ruta o identificador del dispositivo (requerido si connectionType es USB, SERIAL o BLUETOOTH)',
  })
  @IsOptional()
  @ValidateIf((o) =>
    [
      PrinterConnectionType.USB,
      PrinterConnectionType.SERIAL,
      PrinterConnectionType.BLUETOOTH,
    ].includes(o.connectionType),
  )
  @IsNotEmpty({
    message:
      'La ruta/identificador es requerido para conexiones USB/SERIAL/BLUETOOTH',
  })
  @IsString()
  path?: string | null;
  @ApiPropertyOptional({
    type: Boolean,
    example: true,
    description: 'Indica si la impresora está activa',
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
  @ApiPropertyOptional({
    type: String,
    example: '00:1A:2B:3C:4D:5E',
    description: 'Dirección MAC de la impresora (opcional)',
    nullable: true,
  })
  @IsOptional()
  @IsMACAddress({ message: 'La dirección MAC no es válida' })
  macAddress?: string | null;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    description: 'Marca la impresora como predeterminada para el sistema',
  })
  @IsOptional()
  @IsBoolean()
  isDefaultPrinter?: boolean;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    description: 'Habilita la impresión automática para órdenes de delivery',
  })
  @IsOptional()
  @IsBoolean()
  autoDeliveryPrint?: boolean;
  @ApiPropertyOptional({
    type: Boolean,
    example: false,
    description:
      'Habilita la impresión automática para órdenes de pickup (take away)',
  })
  @IsOptional()
  @IsBoolean()
  autoPickupPrint?: boolean;
  @ApiPropertyOptional({
    type: Number,
    example: 80,
    description: 'Ancho del papel en milímetros (58 o 80 son los más comunes)',
  })
  @IsOptional()
  @IsInt()
  @Min(58)
  paperWidth?: number;
  @ApiPropertyOptional({
    type: Number,
    example: 48,
    description: 'Número de caracteres por línea en modo normal',
  })
  @IsOptional()
  @IsInt()
  @Min(32)
  charactersPerLine?: number;
  @ApiPropertyOptional({
    type: Boolean,
    example: true,
    description: 'Cortar el papel automáticamente al final del ticket',
  })
  @IsOptional()
  @IsBoolean()
  cutPaper?: boolean;
  @ApiPropertyOptional({
    type: Number,
    example: 3,
    description:
      'Líneas en blanco a añadir al final del ticket antes del corte',
  })
  @IsOptional()
  @IsInt()
  @Min(0)
  feedLines?: number;
}

================
File: backend/src/thermal-printers/utils/advanced-ticket-example.ts
================
import { ThermalPrinter, PrinterTypes } from 'node-thermal-printer';
import { TicketFormatter } from './ticket-formatter';
export class AdvancedTicketExample {
  static async printAdvancedTicket(printer: ThermalPrinter, order: any) {
    const formatter = new TicketFormatter(80);
    printer.alignCenter();
    printer.setTextSize(2, 2);
    printer.bold(true);
    printer.println('MI RESTAURANTE');
    printer.setTextNormal();
    printer.bold(false);
    printer.invert(true);
    printer.println(' TICKET DE VENTA ');
    printer.invert(false);
    printer.newLine();
    const orderCode = String(order.shiftOrderNumber).padStart(8, '0');
    printer.code128(orderCode, {
      width: 'LARGE',
      height: 80,
      text: 2,
    });
    printer.newLine();
    const boxLines = formatter.createBox(
      `Orden #${order.shiftOrderNumber} - ${new Date().toLocaleDateString('es-MX')}`,
    );
    for (const line of boxLines) {
      printer.println(line);
    }
    printer.newLine();
    printer.println(formatter.createDivider('='));
    const headerRow = formatter.formatTable([
      { col1: 'PRODUCTO', col2: 'CANT', col3: 'PRECIO' },
    ]);
    printer.bold(true);
    printer.println(headerRow[0]);
    printer.bold(false);
    printer.println(formatter.createDivider('-'));
    const productRows = order.orderItems.map((item: any) => ({
      col1: item.product.name.substring(0, 25),
      col2: '1',
      col3: `$${item.finalPrice}`,
    }));
    const formattedProducts = formatter.formatTable(productRows);
    for (const line of formattedProducts) {
      printer.println(line);
    }
    printer.println(formatter.createDivider('='));
    printer.alignCenter();
    printer.newLine();
    printer.println('Seguimiento en línea:');
    printer.printQR(`https://mirestaurante.com/orden/${order.id}`, {
      cellSize: 6,
      correction: 'M',
      model: 2,
    });
    printer.newLine();
    printer.setTextSize(0, 1);
    printer.println('Conserve este ticket para cualquier aclaración');
    printer.setTextNormal();
    printer.beep(2, 3);
    printer.cut();
    return printer.execute();
  }
  static async printKitchenTicket(printer: ThermalPrinter, order: any) {
    const formatter = new TicketFormatter(80);
    printer.alignCenter();
    printer.invert(true);
    printer.setTextSize(2, 2);
    printer.println(' COCINA ');
    printer.invert(false);
    printer.setTextNormal();
    printer.setTextSize(1, 2);
    printer.println(new Date().toLocaleTimeString('es-MX'));
    printer.setTextNormal();
    printer.setTextSize(3, 3);
    printer.bold(true);
    printer.println(`#${order.shiftOrderNumber}`);
    printer.bold(false);
    printer.setTextNormal();
    const orderTypeBox = formatter.createBox(order.orderType);
    for (const line of orderTypeBox) {
      printer.println(line);
    }
    printer.drawLine();
    printer.alignLeft();
    for (const item of order.orderItems) {
      printer.setTextSize(1, 2);
      printer.bold(true);
      printer.println(`[ ] ${item.product.name}`);
      printer.setTextNormal();
      printer.bold(false);
      if (item.productVariant) {
        printer.println(`    Variante: ${item.productVariant.name}`);
      }
      if (item.productModifiers?.length > 0) {
        printer.println('    Modificadores:');
        for (const mod of item.productModifiers) {
          printer.println(`    - ${mod.name}`);
        }
      }
      if (item.preparationNotes) {
        printer.invert(true);
        printer.println(` NOTA: ${item.preparationNotes} `);
        printer.invert(false);
      }
      printer.newLine();
    }
    if (order.notes) {
      printer.drawLine();
      printer.setTextSize(1, 2);
      printer.bold(true);
      printer.println('NOTAS ESPECIALES:');
      printer.bold(false);
      const wrappedNotes = formatter.wrapText(order.notes, 'expanded');
      for (const line of wrappedNotes) {
        printer.println(line);
      }
      printer.setTextNormal();
    }
    printer.beep(3, 5);
    printer.cut();
    return printer.execute();
  }
}

================
File: app/plugins/withCustomIcons.js
================
const { withDangerousMod } = require('@expo/config-plugins');
const fs = require('fs');
const path = require('path');
function withCustomIcons(config) {
  return withDangerousMod(config, [
    'android',
    async (config) => {
      const projectRoot = config.modRequest.projectRoot;
      const iconPath = path.join(projectRoot, 'assets', 'icon.png');
      const adaptiveIconPath = path.join(
        projectRoot,
        'assets',
        'adaptive-icon.png',
      );
      const splashPath = path.join(projectRoot, 'assets', 'splash.png');
      console.log('🎨 CloudBite Icon Plugin - Starting icon generation...');
      if (!fs.existsSync(iconPath)) {
        console.error('❌ Icon not found at:', iconPath);
        return config;
      }
      console.log('✅ Icon found at:', iconPath);
      console.log('📱 Icons will be processed during EAS build');
      if (fs.existsSync(splashPath)) {
        console.log('✅ Splash screen found at:', splashPath);
      }
      if (fs.existsSync(adaptiveIconPath)) {
        console.log('✅ Adaptive icon found at:', adaptiveIconPath);
      }
      return config;
    },
  ]);
}
module.exports = withCustomIcons;

================
File: app/src/app/components/common/AnimatedLabelInput.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  TextInput,
  Animated,
  StyleSheet,
  TextInputProps,
  StyleProp,
  ViewStyle,
  TextStyle,
  TouchableWithoutFeedback,
  Easing,
} from 'react-native';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
interface AnimatedLabelInputProps extends TextInputProps {
  label: string;
  containerStyle?: StyleProp<ViewStyle>;
  inputStyle?: StyleProp<TextStyle>;
  labelStyle?: StyleProp<TextStyle>;
  activeLabelColor?: string;
  inactiveLabelColor?: string;
  borderColor?: string;
  activeBorderColor?: string;
  error?: boolean;
  errorColor?: string;
  disabled?: boolean;
}
const AnimatedLabelInput = React.forwardRef<TextInput, AnimatedLabelInputProps>(
  (
    {
      label,
      value,
      onChangeText,
      onFocus,
      onBlur,
      style,
      containerStyle,
      inputStyle,
      labelStyle,
      activeLabelColor,
      inactiveLabelColor,
      borderColor: defaultBorderColor,
      activeBorderColor: focusedBorderColor,
      error = false,
      errorColor: customErrorColor,
      multiline,
      disabled = false,
      ...rest
    },
    ref,
  ) => {
    const theme = useAppTheme();
    const responsive = useResponsive();
    const [isFocused, setIsFocused] = useState(false);
    const animation = useRef(new Animated.Value(value ? 1 : 0)).current;
    const isActive = isFocused || (value != null && value !== '');
    const finalActiveLabelColor = activeLabelColor || theme.colors.primary;
    const finalInactiveLabelColor =
      inactiveLabelColor || theme.colors.onSurfaceVariant;
    const finalBorderColor = defaultBorderColor || theme.colors.outline;
    const finalActiveBorderColor = focusedBorderColor || theme.colors.primary;
    const finalErrorColor = customErrorColor || theme.colors.error;
    useEffect(() => {
      Animated.timing(animation, {
        toValue: isActive ? 1 : 0,
        duration: 150,
        useNativeDriver: false,
        easing: Easing.bezier(0.4, 0.0, 0.2, 1), // Material Design easing
      }).start();
    }, [isActive, animation]);
    const handleFocus = (e: any) => {
      setIsFocused(true);
      onFocus?.(e);
    };
    const handleBlur = (e: any) => {
      setIsFocused(false);
      onBlur?.(e);
    };
    // Usar ref externa o crear una nueva
    const inputRef = useRef<TextInput>(null);
    const finalRef = ref || inputRef;
    const labelScale = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [1, 0.8], // Escala más sutil
    });
    const labelColor = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [finalInactiveLabelColor, finalActiveLabelColor],
    });
    const currentBorderColor = error
      ? finalErrorColor
      : isFocused
        ? finalActiveBorderColor
        : finalBorderColor;
    const styles = React.useMemo(
      () =>
        createStyles(theme, responsive, {
          multiline,
          disabled,
          finalInactiveLabelColor,
        }),
      [theme, responsive, multiline, disabled, finalInactiveLabelColor],
    );
    const animatedTranslateY = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0, -28],
    });
    const animatedTranslateX = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0, -4],
    });
    const animatedLabelStyle = {
      position: 'absolute' as const,
      top: 20,
      left: 12,
      zIndex: 10,
      transform: [
        { translateX: animatedTranslateX },
        { translateY: animatedTranslateY },
        { scale: labelScale },
      ],
      color: labelColor,
      backgroundColor: theme.colors.background,
      maxWidth: isActive ? ('85%' as `${number}%`) : ('90%' as `${number}%`),
    };
    const staticLabelStyle = {
      paddingHorizontal: isActive ? 4 : 0,
      paddingVertical: isActive ? 1 : 0,
    };
    const handleContainerPress = () => {
      if (
        !disabled &&
        finalRef &&
        typeof finalRef !== 'function' &&
        finalRef.current
      ) {
        finalRef.current.focus();
      }
    };
    return (
      <TouchableWithoutFeedback
        onPress={handleContainerPress}
        disabled={disabled}
      >
        <View
          style={[
            styles.container,
            { borderColor: currentBorderColor },
            containerStyle,
          ]}
        >
          {}
          <Animated.View
            style={{
              position: 'absolute',
              top: -1,
              left: 10,
              height: 2,
              backgroundColor: theme.colors.background,
              zIndex: 5,
              opacity: animation.interpolate({
                inputRange: [0, 0.5, 1],
                outputRange: [0, 0.8, 1],
              }),
              transform: [
                {
                  scaleX: animation.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0, 1],
                  }),
                },
              ],
              width: Math.min(label.length * 6.5 + 16, 200),
            }}
          />
          <Animated.Text
            style={[
              styles.label,
              staticLabelStyle,
              labelStyle,
              animatedLabelStyle,
            ]}
            numberOfLines={1}
            ellipsizeMode="tail"
          >
            {label}
          </Animated.Text>
          <View style={[styles.inputContainer, { pointerEvents: 'box-none' }]}>
            <TextInput
              ref={finalRef}
              value={value}
              onChangeText={onChangeText}
              onFocus={handleFocus}
              onBlur={handleBlur}
              style={[styles.input, inputStyle, style]}
              placeholder=""
              editable={!disabled}
              pointerEvents={disabled ? 'none' : 'auto'}
              underlineColorAndroid="transparent"
              placeholderTextColor={finalInactiveLabelColor}
              multiline={multiline}
              autoCorrect={false}
              keyboardAppearance={theme.dark ? 'dark' : 'light'}
              {...rest}
            />
          </View>
        </View>
      </TouchableWithoutFeedback>
    );
  },
);
AnimatedLabelInput.displayName = 'AnimatedLabelInput';
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
  props: {
    multiline?: boolean;
    disabled: boolean;
    finalInactiveLabelColor: string;
  },
) =>
  StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      position: 'relative',
      backgroundColor: theme.colors.background,
      minHeight: responsive.isTablet ? 52 : 58,
    },
    inputContainer: {
      flexDirection: 'row',
      alignItems: props.multiline ? 'flex-start' : 'center',
      paddingTop: responsive.isTablet ? 16 : 18,
      paddingBottom: responsive.isTablet ? 4 : 6,
      minHeight: responsive.isTablet ? 36 : 40,
    },
    label: {
      fontSize: responsive.fontSize(16),
      color: props.finalInactiveLabelColor,
    },
    input: {
      flex: 1,
      fontSize: responsive.fontSize(16),
      color: props.disabled
        ? theme.colors.onSurfaceDisabled
        : theme.colors.onSurface,
      paddingVertical: 0,
      paddingHorizontal: 0,
      margin: 0,
      borderWidth: 0,
      backgroundColor: 'transparent',
      textAlignVertical: props.multiline ? 'top' : 'center',
    },
  });
export default AnimatedLabelInput;

================
File: app/src/app/components/common/ConfirmationModal.tsx
================
import React from 'react';
import { ResponsiveConfirmModal } from '../responsive/ResponsiveModal';
interface ConfirmationModalProps {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel?: () => void;
  onDismiss?: () => void;
  confirmText?: string;
  cancelText?: string;
  confirmButtonColor?: string;
}
const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  visible,
  title,
  message,
  onConfirm,
  onCancel,
  onDismiss,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  confirmButtonColor,
}) => {
  const destructive =
    confirmButtonColor &&
    (confirmButtonColor.includes('error') ||
      confirmButtonColor === '#f44336' ||
      confirmButtonColor === '#F44336' ||
      confirmButtonColor === 'error');
  return (
    <ResponsiveConfirmModal
      visible={visible}
      onDismiss={onDismiss || (() => {})}
      title={title}
      message={message}
      onConfirm={onConfirm}
      onCancel={onCancel}
      confirmText={confirmText}
      cancelText={cancelText}
      destructive={destructive}
      maxWidth={450}
      widthTablet="70%"
      widthMobile="90%"
    />
  );
};
export default ConfirmationModal;

================
File: app/src/app/components/common/GlobalSnackbar.tsx
================
import React from 'react';
import { Snackbar, Portal, Text } from 'react-native-paper';
import { StyleSheet } from 'react-native';
import {
  useSnackbarStore,
  SnackbarType,
} from '../../../app/store/snackbarStore';
import { useAppTheme } from '../../../app/styles/theme';
const GlobalSnackbar: React.FC = () => {
  const { visible, message, type, duration, hideSnackbar } = useSnackbarStore();
  const theme = useAppTheme();
  React.useEffect(() => {
    if (visible && message) {
      const timer = setTimeout(() => {
        hideSnackbar();
      }, duration || 2500);
      return () => clearTimeout(timer);
    }
  }, [visible, message, duration, hideSnackbar]);
  const getBackgroundColor = (snackbarType: SnackbarType) => {
    switch (snackbarType) {
      case 'success':
        return theme.colors.successContainer;
      case 'error':
        return theme.colors.errorContainer;
      case 'warning':
        return theme.colors.warningContainer || theme.colors.tertiaryContainer;
      case 'info':
        return theme.colors.infoContainer || theme.colors.surfaceVariant;
      default:
        return theme.colors.inverseSurface;
    }
  };
  const getTextColor = (snackbarType: SnackbarType) => {
    const defaultTextColor = theme.dark
      ? theme.colors.surface
      : theme.colors.onSurface;
    switch (snackbarType) {
      case 'success':
        return theme.colors.onSuccessContainer || defaultTextColor;
      case 'error':
        return theme.colors.onErrorContainer;
      case 'warning':
        return (
          theme.colors.onWarningContainer || theme.colors.onTertiaryContainer
        );
      case 'info':
        return theme.colors.onInfoContainer || theme.colors.onSurfaceVariant;
      default:
        return theme.colors.inverseOnSurface;
    }
  };
  const backgroundColor = getBackgroundColor(type);
  const textColor = getTextColor(type);
  return (
    <Portal>
      <Snackbar
        visible={visible}
        onDismiss={hideSnackbar}
        duration={duration || 2500}
        style={[
          styles.snackbar,
          {
            backgroundColor,
            marginBottom: 40,
          },
        ]}
        theme={{
          ...theme,
          colors: {
            ...theme.colors,
            inversePrimary: textColor,
            inverseOnSurface: textColor,
          },
        }}
      >
        <Text style={styles.messageText}>{message || ''}</Text>
      </Snackbar>
    </Portal>
  );
};
const styles = StyleSheet.create({
  snackbar: {
    marginHorizontal: 16,
    borderRadius: 8,
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 3,
    },
    shadowOpacity: 0.27,
    shadowRadius: 4.65,
  },
  messageText: {
    textAlign: 'center',
    width: '100%',
  },
});
export default GlobalSnackbar;

================
File: app/src/app/components/OrientationTransition.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { View, ActivityIndicator, StyleSheet, Platform } from 'react-native';
import { Text } from 'react-native-paper';
import * as ScreenOrientation from 'expo-screen-orientation';
import { useAppTheme } from '../styles/theme';
interface OrientationTransitionProps {
  children: React.ReactNode;
  targetOrientation?: ScreenOrientation.OrientationLock;
}
const TRANSITION_DELAYS = {
  UNLOCK: 100,
  LOCK: 300,
} as const;
export const OrientationTransition: React.FC<OrientationTransitionProps> = ({
  children,
  targetOrientation = ScreenOrientation.OrientationLock.PORTRAIT_UP,
}) => {
  const theme = useAppTheme();
  const [isTransitioning, setIsTransitioning] = useState(Platform.OS !== 'web');
  const handleOrientationChange = useCallback(async () => {
    if (Platform.OS === 'web') {
      return;
    }
    setIsTransitioning(true);
    try {
      await ScreenOrientation.unlockAsync();
      await new Promise((resolve) =>
        setTimeout(resolve, TRANSITION_DELAYS.UNLOCK),
      );
      await ScreenOrientation.lockAsync(targetOrientation);
      await new Promise((resolve) =>
        setTimeout(resolve, TRANSITION_DELAYS.LOCK),
      );
    } catch (error) {
    } finally {
      setIsTransitioning(false);
    }
  }, [targetOrientation]);
  useEffect(() => {
    handleOrientationChange();
  }, [handleOrientationChange]);
  if (isTransitioning && Platform.OS !== 'web') {
    return (
      <View
        style={[styles.container, { backgroundColor: theme.colors.background }]}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={[styles.text, { color: theme.colors.onBackground }]}>
          Ajustando pantalla...
        </Text>
      </View>
    );
  }
  return <>{children}</>;
};
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    marginTop: 16,
    fontSize: 16,
  },
});

================
File: app/src/app/components/ServerConfigModal.tsx
================
import React, { useEffect, useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  Platform,
} from 'react-native';
import {
  Text,
  Modal,
  Portal,
  Surface,
  RadioButton,
  TextInput,
  Button,
  HelperText,
  Chip,
  IconButton,
  useTheme,
} from 'react-native-paper';
import { useSnackbar } from '@/hooks/useSnackbar';
import {
  serverConnectionService,
  ConnectionMode,
} from '@/services/serverConnectionService';
import { discoveryService } from '@/app/services/discoveryService';
import EncryptedStorage from '@/app/services/secureStorageService';
import axios from 'axios';
const STORAGE_KEYS = {
  CONNECTION_MODE: 'connection_mode',
  MANUAL_URL: 'manual_server_url',
};
interface ServerConfigModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSuccess?: () => void;
}
export function ServerConfigModal({
  visible,
  onDismiss,
  onSuccess,
}: ServerConfigModalProps) {
  const theme = useTheme();
  const { showSnackbar } = useSnackbar();
  const [mode, setMode] = useState<ConnectionMode>('auto');
  const [manualUrl, setManualUrl] = useState('');
  const [currentUrl, setCurrentUrl] = useState<string | null>(null);
  const [testing, setTesting] = useState(false);
  const [loading, setLoading] = useState(true);
  const [remoteUrlAvailable, setRemoteUrlAvailable] = useState<string | null>(
    null,
  );
  useEffect(() => {
    if (visible) {
      loadSettings();
    }
  }, [visible]);
  const loadSettings = async () => {
    try {
      setLoading(true);
      const savedMode = (await EncryptedStorage.getItem(
        STORAGE_KEYS.CONNECTION_MODE,
      )) as ConnectionMode;
      const savedUrl = await EncryptedStorage.getItem(STORAGE_KEYS.MANUAL_URL);
      const currentApiUrl = await discoveryService.getApiUrl();
      if (savedMode) setMode(savedMode);
      if (savedUrl) setManualUrl(savedUrl);
      if (currentApiUrl) setCurrentUrl(currentApiUrl);
      if (currentApiUrl) {
        try {
          const response = await axios.get(`${currentApiUrl}/api/v1/discovery`);
          if (response.data.remoteUrl) {
            setRemoteUrlAvailable(response.data.remoteUrl);
          }
        } catch (error) {}
      }
    } catch (error) {
      console.error('Error loading settings:', error);
    } finally {
      setLoading(false);
    }
  };
  const normalizeUrl = (url: string): string => {
    if (!url.startsWith('http:
      url = 'http://' + url;
    }
    try {
      const parsed = new URL(url);
      if (
        !parsed.port &&
        (parsed.hostname.startsWith('192.168.') ||
          parsed.hostname.startsWith('10.') ||
          parsed.hostname.startsWith('172.') ||
          parsed.hostname === 'localhost' ||
          /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(parsed.hostname))
      ) {
        parsed.port = '3737';
      }
      return `${parsed.protocol}//${parsed.host}`;
    } catch {
      return url;
    }
  };
  const validateUrl = (url: string): boolean => {
    try {
      const normalized = normalizeUrl(url);
      const parsed = new URL(normalized);
      return ['http:', 'https:'].includes(parsed.protocol);
    } catch {
      return false;
    }
  };
  const testConnection = async () => {
    if (mode === 'manual' && !validateUrl(manualUrl)) {
      showSnackbar('Por favor ingresa una URL válida', 'error');
      return;
    }
    setTesting(true);
    try {
      let urlToTest = '';
      if (mode === 'auto') {
        const discovered = await discoveryService.discoverServer();
        if (!discovered) {
          throw new Error('No se pudo encontrar el servidor en la red local');
        }
        urlToTest = discovered;
      } else if (mode === 'remote' && remoteUrlAvailable) {
        urlToTest = remoteUrlAvailable;
      } else {
        urlToTest = normalizeUrl(manualUrl);
      }
      const response = await axios.get(`${urlToTest}/api/v1/discovery`, {
        timeout: 5000,
      });
      if (response.data.type !== 'cloudbite-api') {
        throw new Error('El servidor no es compatible');
      }
      showSnackbar('Conexión exitosa', 'success');
      setCurrentUrl(urlToTest);
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al conectar con el servidor',
        'error',
      );
    } finally {
      setTesting(false);
    }
  };
  const saveSettings = async () => {
    try {
      await EncryptedStorage.setItem(STORAGE_KEYS.CONNECTION_MODE, mode);
      if (mode === 'manual') {
        if (!validateUrl(manualUrl)) {
          showSnackbar('Por favor ingresa una URL válida', 'error');
          return;
        }
        const normalizedUrl = normalizeUrl(manualUrl);
        await EncryptedStorage.setItem(STORAGE_KEYS.MANUAL_URL, normalizedUrl);
        await discoveryService.setServerUrl(normalizedUrl, true);
        if (Platform.OS === 'web') {
          try {
            const response = await axios.get(
              `${normalizedUrl}/api/v1/discovery`,
              {
                timeout: 5000,
              },
            );
            if (response.data.type === 'cloudbite-api') {
            }
          } catch (error) {
            console.error(
              'Error verificando conexión después de guardar:',
              error,
            );
          }
        }
      } else if (mode === 'remote' && remoteUrlAvailable) {
        await discoveryService.setServerUrl(remoteUrlAvailable, true);
      } else {
        await discoveryService.setServerUrl(null, true);
      }
      showSnackbar('Configuración guardada', 'success');
      onSuccess?.();
      onDismiss();
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al guardar la configuración',
        'error',
      );
    }
  };
  const styles = StyleSheet.create({
    modal: {
      justifyContent: 'center',
      alignItems: 'center',
      margin: 20,
    },
    container: {
      width: '100%',
      maxWidth: 500,
      maxHeight: '90%',
      backgroundColor: theme.colors.surface,
      borderRadius: 16,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    title: {
      fontSize: 20,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    content: {
      padding: 16,
    },
    loadingContainer: {
      padding: 40,
      alignItems: 'center',
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      marginBottom: 16,
    },
    successChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    errorChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    urlText: {
      flex: 1,
      marginLeft: 8,
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    section: {
      marginBottom: 16,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      marginBottom: 8,
      color: theme.colors.onSurface,
    },
    manualConfig: {
      marginTop: 8,
      marginLeft: 32,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      gap: 8,
      padding: 16,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
  });
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modal}
        dismissable={!testing}
      >
        <Surface style={styles.container}>
          <View style={styles.header}>
            <Text style={styles.title}>Configuración del Servidor</Text>
            <IconButton
              icon="close"
              size={24}
              onPress={onDismiss}
              disabled={testing}
            />
          </View>
          <ScrollView style={styles.content}>
            {loading ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" />
              </View>
            ) : (
              <>
                {}
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Estado de Conexión</Text>
                  {currentUrl ? (
                    <View style={styles.statusContainer}>
                      <Chip
                        icon="check-circle"
                        mode="flat"
                        style={styles.successChip}
                      >
                        Conectado
                      </Chip>
                      <Text
                        variant="bodySmall"
                        style={styles.urlText}
                        numberOfLines={1}
                      >
                        {currentUrl}
                      </Text>
                    </View>
                  ) : (
                    <View style={styles.statusContainer}>
                      <Chip
                        icon="alert-circle"
                        mode="flat"
                        style={styles.errorChip}
                      >
                        Sin conexión
                      </Chip>
                    </View>
                  )}
                </View>
                {}
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Modo de Conexión</Text>
                  <RadioButton.Group
                    onValueChange={(value) => setMode(value as ConnectionMode)}
                    value={mode}
                  >
                    <RadioButton.Item
                      label="Automático (Red Local)"
                      value="auto"
                      status={mode === 'auto' ? 'checked' : 'unchecked'}
                    />
                    <HelperText type="info" visible={mode === 'auto'}>
                      Busca automáticamente el servidor en tu red local
                    </HelperText>
                    {remoteUrlAvailable && (
                      <>
                        <RadioButton.Item
                          label="Remoto (Internet)"
                          value="remote"
                          status={mode === 'remote' ? 'checked' : 'unchecked'}
                        />
                        <HelperText type="info" visible={mode === 'remote'}>
                          Usa el servidor remoto: {remoteUrlAvailable}
                        </HelperText>
                      </>
                    )}
                    <RadioButton.Item
                      label="Manual"
                      value="manual"
                      status={mode === 'manual' ? 'checked' : 'unchecked'}
                    />
                    {mode === 'manual' && (
                      <View style={styles.manualConfig}>
                        <TextInput
                          label="URL del Servidor"
                          value={manualUrl}
                          onChangeText={setManualUrl}
                          placeholder="192.168.1.230 o http://192.168.1.230:3737"
                          mode="outlined"
                          autoCapitalize="none"
                          autoCorrect={false}
                          keyboardType="url"
                          error={manualUrl !== '' && !validateUrl(manualUrl)}
                        />
                        <HelperText
                          type="info"
                          visible={mode === 'manual' && manualUrl === ''}
                        >
                          Puedes ingresar solo la IP. El puerto 3737 se agregará
                          automáticamente.
                        </HelperText>
                        <HelperText
                          type="error"
                          visible={manualUrl !== '' && !validateUrl(manualUrl)}
                        >
                          URL inválida
                        </HelperText>
                      </View>
                    )}
                  </RadioButton.Group>
                </View>
              </>
            )}
          </ScrollView>
          <View style={styles.actions}>
            <Button mode="text" onPress={onDismiss} disabled={testing}>
              Cancelar
            </Button>
            <Button
              mode="outlined"
              onPress={testConnection}
              loading={testing}
              disabled={testing || loading}
              icon="connection"
            >
              Probar
            </Button>
            <Button
              mode="contained"
              onPress={saveSettings}
              disabled={testing || loading}
              icon="content-save"
            >
              Guardar
            </Button>
          </View>
        </Surface>
      </Modal>
    </Portal>
  );
}

================
File: app/src/app/constants/navigationPaths.ts
================
export const NAVIGATION_PATHS = {
  LOGIN: 'Login',
  MAIN_DRAWER: 'MainDrawer',
  ORDERS_STACK: 'OrdersStack',
  ORDERS: 'Orders',
  CREATE_ORDER: 'CreateOrder',
  OPEN_ORDERS: 'OpenOrders',
  ADD_PRODUCTS_TO_ORDER: 'AddProductsToOrder',
  MENU_STACK: 'MenuStack',
  CATEGORIES: 'CategoriesScreen',
  SUBCATEGORIES: 'SubcategoriesScreen',
  PRODUCTS: 'Products',
  AREAS_TABLES_STACK: 'AreasTablesStack',
  AREAS_LIST: 'AreasList',
  TABLES_LIST: 'TablesList',
  MODIFIERS_STACK: 'ModifiersStack',
  MODIFIER_GROUPS: 'ModifierGroupsScreen',
  MODIFIERS: 'ModifiersScreen',
  KITCHEN_STACK: 'KitchenStack',
  KITCHEN_ORDERS: 'KitchenOrders',
  KITCHEN: 'Kitchen',
  RECEIPTS_STACK: 'ReceiptsStack',
  RECEIPTS_LIST: 'ReceiptsList',
  ORDER_FINALIZATION_STACK: 'OrderFinalizationStack',
  ORDER_FINALIZATION: 'OrderFinalizationScreen',
  AVAILABILITY_STACK: 'AvailabilityStack',
  AVAILABILITY: 'AvailabilityScreen',
  RESTAURANT_CONFIG_STACK: 'RestaurantConfigStack',
  RESTAURANT_CONFIG: 'RestaurantConfig',
  CUSTOMERS_STACK: 'CustomersStack',
  CUSTOMERS: 'Customers',
  PIZZA_CUSTOMIZATIONS_STACK: 'PizzaCustomizationsStack',
  PIZZA_CUSTOMIZATIONS_LIST: 'PizzaCustomizationsList',
  SYNC_STACK: 'SyncStack',
  SYNC_STATUS: 'SyncStatus',
  USERS_STACK: 'UsersStack',
  USERS_LIST: 'UsersList',
  SHIFT_AUDIT_STACK: 'ShiftAuditStack',
  SHIFTS_LIST: 'ShiftsList',
  PRINTERS_STACK: 'PrintersStack',
  PRINTERS_LIST: 'PrintersList',
  PREPARATION_SCREENS_STACK: 'PreparationScreensStack',
  PREPARATION_SCREENS_LIST: 'PreparationScreensList',
} as const;
export type RootStackParamList = {
  [NAVIGATION_PATHS.LOGIN]: undefined;
  [NAVIGATION_PATHS.MAIN_DRAWER]: undefined;
};
export type OrdersStackParamList = {
  [NAVIGATION_PATHS.ORDERS]: undefined;
  [NAVIGATION_PATHS.CREATE_ORDER]: undefined;
  [NAVIGATION_PATHS.OPEN_ORDERS]: undefined;
  [NAVIGATION_PATHS.ADD_PRODUCTS_TO_ORDER]: {
    orderId: number;
    orderNumber: string;
    existingOrderItemsCount: number;
    existingTempProducts?: any[];
    onProductsAdded?: () => void;
  };
};
export type MenuStackParamList = {
  [NAVIGATION_PATHS.CATEGORIES]: undefined;
  [NAVIGATION_PATHS.SUBCATEGORIES]: {
    categoryId: number;
    categoryName: string;
  };
  [NAVIGATION_PATHS.PRODUCTS]: {
    subcategoryId: number;
    subCategoryName: string;
  };
};
export type AreasTablesStackParamList = {
  [NAVIGATION_PATHS.AREAS_LIST]: undefined;
  [NAVIGATION_PATHS.TABLES_LIST]: {
    areaId: number;
    areaName: string;
  };
};
export type ModifiersStackParamList = {
  [NAVIGATION_PATHS.MODIFIER_GROUPS]: undefined;
  [NAVIGATION_PATHS.MODIFIERS]: {
    groupId: number;
    groupName: string;
  };
};
export type KitchenStackParamList = {
  [NAVIGATION_PATHS.KITCHEN_ORDERS]: undefined;
};

================
File: app/src/app/constants/network.ts
================
export const NETWORK_CONFIG = {
  DISCOVERY_PORT: 3737,
  DISCOVERY_TIMEOUT: 1000,
  HEALTH_CHECK_TIMEOUT: 3000,
  API_TIMEOUT: 5000,
  HEALTH_CHECK_INTERVAL: 30000,
  HEALTH_RETRY_INTERVALS: [5000, 10000, 20000, 30000],
  MIN_DISCOVERY_INTERVAL: 10000,
  RECONNECT_CYCLE_DELAY: 10000,
  HEALTH_CHECK_ATTEMPTS: 3,
  MAX_CONCURRENT_REQUESTS: 50,
  COMMON_SUBNETS: ['192.168.1', '192.168.0', '10.0.0'],
} as const;

================
File: app/src/app/hooks/useGlobalShift.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService, type Shift } from '@/services/shifts';
export const useGlobalShift = () => {
  return useQuery<Shift | null, Error>({
    queryKey: ['global', 'shift', 'current'],
    queryFn: () => shiftsService.getCurrentShift(),
    staleTime: 60 * 1000,
    cacheTime: 5 * 60 * 1000,
    refetchInterval: 2 * 60 * 1000,
    refetchOnWindowFocus: false,
    refetchOnMount: 'always',
    refetchOnReconnect: true,
    retry: 1,
    retryDelay: 1000,
  });
};

================
File: app/src/app/hooks/useRefreshOnFocus.ts
================
import { useEffect, useCallback } from 'react';
import { useFocusEffect } from '@react-navigation/native';
import { useQueryClient } from '@tanstack/react-query';
export function useRefreshOnFocus(
  queryKeys: (string | readonly unknown[])[],
  options?: {
    enabled?: boolean;
    refetchOnMount?: boolean;
  },
) {
  const queryClient = useQueryClient();
  const { enabled = true, refetchOnMount = true } = options || {};
  useFocusEffect(
    useCallback(() => {
      if (!enabled) return;
      queryKeys.forEach((queryKey) => {
        queryClient.invalidateQueries({
          queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
        });
      });
    }, [enabled, queryKeys, queryClient]),
  );
  useEffect(() => {
    if (!enabled || !refetchOnMount) return;
    queryKeys.forEach((queryKey) => {
      queryClient.invalidateQueries({
        queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
      });
    });
  }, [enabled, refetchOnMount, queryKeys, queryClient]);
  return {
    refetch: () => {
      queryKeys.forEach((queryKey) => {
        queryClient.invalidateQueries({
          queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
        });
      });
    },
  };
}
export function useRefreshModuleOnFocus(
  modulePrefix: string,
  options?: {
    enabled?: boolean;
  },
) {
  const queryClient = useQueryClient();
  const { enabled = true } = options || {};
  useFocusEffect(
    useCallback(() => {
      if (!enabled) return;
      queryClient.invalidateQueries({
        predicate: (query) => {
          const queryKey = query.queryKey;
          if (Array.isArray(queryKey) && queryKey.length > 0) {
            return queryKey[0] === modulePrefix;
          }
          return false;
        },
      });
    }, [enabled, modulePrefix, queryClient]),
  );
}

================
File: app/src/app/hooks/useResponsive.ts
================
import { useState, useEffect, useCallback, useMemo } from 'react';
import { Dimensions, PixelRatio, ScaledSize, Platform } from 'react-native';
import {
  BREAKPOINTS,
  DEVICE_TYPES,
  getDeviceType,
  isTablet as checkIsTablet,
  scaleWidth,
  scaleHeight,
  scaleWithLimits,
  getResponsiveDimension,
  RESPONSIVE_SPACING,
  RESPONSIVE_FONT_SIZES,
  RESPONSIVE_DIMENSIONS,
  applyResponsiveStyle,
  getGridColumns,
  getOrientation as getOrientationUtil,
  maintainAspectRatio,
  normalizeDPI,
} from '@/app/styles/responsive';
interface ResponsiveInfo {
  width: number;
  height: number;
  deviceType: string;
  isTablet: boolean;
  isMobile: boolean;
  isSmallMobile: boolean;
  isWeb: boolean;
  isDesktop: boolean;
  orientation: 'portrait' | 'landscape';
  isPortrait: boolean;
  isLandscape: boolean;
  pixelRatio: number;
  fontScale: number;
  scaleWidth: (size: number) => number;
  scaleHeight: (size: number) => number;
  scaleWithLimits: (
    size: number,
    minScale?: number,
    maxScale?: number,
  ) => number;
  getResponsiveDimension: (mobile: number, tablet: number) => number;
  spacing: (value: number) => number;
  spacingPreset: {
    xxxs: number;
    xxs: number;
    xs: number;
    s: number;
    m: number;
    l: number;
    xl: number;
    xxl: number;
  };
  fontSize: (value: number) => number;
  fontSizePreset: {
    xs: number;
    s: number;
    m: number;
    l: number;
    xl: number;
    xxl: number;
    xxxl: number;
  };
  dimensions: {
    drawerWidth: number;
    modalWidth: number;
    headerHeight: number;
    buttonHeight: number;
    iconSize: {
      small: number;
      medium: number;
      large: number;
    };
    productImageSize: number;
    cardMinWidth: number;
  };
  applyResponsiveStyle: <T>(styles: {
    xs?: T;
    sm?: T;
    md?: T;
    lg?: T;
    xl?: T;
    xxl?: T;
  }) => T | undefined;
  getGridColumns: (
    minItemWidth?: number,
    gap?: number,
    padding?: number,
  ) => number;
  maintainAspectRatio: (
    originalWidth: number,
    originalHeight: number,
    maxWidth: number,
    maxHeight: number,
  ) => { width: number; height: number };
  normalizeDPI: (size: number) => number;
  breakpoints: typeof BREAKPOINTS;
  isBreakpoint: {
    xs: boolean;
    sm: boolean;
    md: boolean;
    lg: boolean;
    xl: boolean;
    xxl: boolean;
  };
}
export const useResponsive = (): ResponsiveInfo => {
  const [dimensions, setDimensions] = useState<ScaledSize>(() =>
    Dimensions.get('window'),
  );
  useEffect(() => {
    const subscription = Dimensions.addEventListener('change', ({ window }) => {
      setDimensions(window);
    });
    return () => subscription?.remove();
  }, []);
  const pixelRatio = PixelRatio.get();
  const fontScale = PixelRatio.getFontScale();
  const deviceType = useMemo(
    () => getDeviceType(dimensions.width),
    [dimensions.width],
  );
  const isWeb = Platform.OS === 'web';
  const isDesktop = useMemo(
    () => isWeb && dimensions.width >= BREAKPOINTS.lg,
    [isWeb, dimensions.width],
  );
  const isTablet = useMemo(
    () =>
      checkIsTablet(dimensions.width) ||
      (isWeb &&
        dimensions.width >= BREAKPOINTS.md &&
        dimensions.width < BREAKPOINTS.lg),
    [dimensions.width, isWeb],
  );
  const isMobile = useMemo(
    () => !isTablet && !isDesktop,
    [isTablet, isDesktop],
  );
  const isSmallMobile = useMemo(
    () => deviceType === DEVICE_TYPES.MOBILE_SMALL,
    [deviceType],
  );
  const orientation = useMemo(
    () => getOrientationUtil(dimensions.width, dimensions.height),
    [dimensions.width, dimensions.height],
  );
  const isPortrait = orientation === 'portrait';
  const isLandscape = orientation === 'landscape';
  const scaleWidthMemo = useCallback(
    (size: number) => scaleWidth(size, dimensions.width),
    [dimensions.width],
  );
  const scaleHeightMemo = useCallback(
    (size: number) => scaleHeight(size, dimensions.height),
    [dimensions.height],
  );
  const scaleWithLimitsMemo = useCallback(
    (size: number, minScale?: number, maxScale?: number) =>
      scaleWithLimits(size, minScale, maxScale, dimensions.width),
    [dimensions.width],
  );
  const getResponsiveDimensionMemo = useCallback(
    (mobile: number, tablet: number) =>
      getResponsiveDimension(mobile, tablet, dimensions.width),
    [dimensions.width],
  );
  const spacingPreset = useMemo(
    () => ({
      xxxs: RESPONSIVE_SPACING.xxxs(dimensions.width),
      xxs: RESPONSIVE_SPACING.xxs(dimensions.width),
      xs: RESPONSIVE_SPACING.xs(dimensions.width),
      s: RESPONSIVE_SPACING.s(dimensions.width),
      m: RESPONSIVE_SPACING.m(dimensions.width),
      l: RESPONSIVE_SPACING.l(dimensions.width),
      xl: RESPONSIVE_SPACING.xl(dimensions.width),
      xxl: RESPONSIVE_SPACING.xxl(dimensions.width),
    }),
    [dimensions.width],
  );
  const spacing = useCallback(
    (value: number) => {
      if (isDesktop) {
        return Math.round(value * 1.3);
      }
      if (isTablet) {
        return Math.round(value * 0.7);
      }
      return value;
    },
    [isTablet, isDesktop],
  );
  const fontSizePreset = useMemo(
    () => ({
      xs: RESPONSIVE_FONT_SIZES.xs(dimensions.width),
      s: RESPONSIVE_FONT_SIZES.s(dimensions.width),
      m: RESPONSIVE_FONT_SIZES.m(dimensions.width),
      l: RESPONSIVE_FONT_SIZES.l(dimensions.width),
      xl: RESPONSIVE_FONT_SIZES.xl(dimensions.width),
      xxl: RESPONSIVE_FONT_SIZES.xxl(dimensions.width),
      xxxl: RESPONSIVE_FONT_SIZES.xxxl(dimensions.width),
    }),
    [dimensions.width],
  );
  const fontSize = useCallback(
    (value: number) => {
      if (isDesktop) {
        return Math.round(value * 1.4);
      }
      if (isWeb && isTablet) {
        return Math.round(value * 1.2);
      }
      if (isTablet) {
        return Math.round(value * 0.87);
      }
      return value;
    },
    [isTablet, isDesktop, isWeb],
  );
  const commonDimensions = useMemo(
    () => ({
      drawerWidth: RESPONSIVE_DIMENSIONS.drawerWidth(dimensions.width),
      modalWidth: RESPONSIVE_DIMENSIONS.modalWidth(dimensions.width),
      headerHeight: RESPONSIVE_DIMENSIONS.headerHeight(dimensions.width),
      buttonHeight: RESPONSIVE_DIMENSIONS.buttonHeight(dimensions.width),
      iconSize: {
        small: RESPONSIVE_DIMENSIONS.iconSize.small(dimensions.width),
        medium: RESPONSIVE_DIMENSIONS.iconSize.medium(dimensions.width),
        large: RESPONSIVE_DIMENSIONS.iconSize.large(dimensions.width),
      },
      productImageSize: RESPONSIVE_DIMENSIONS.productImageSize(
        dimensions.width,
      ),
      cardMinWidth: RESPONSIVE_DIMENSIONS.cardMinWidth(dimensions.width),
    }),
    [dimensions.width],
  );
  const applyResponsiveStyleMemo = useCallback(
    <T>(styles: { xs?: T; sm?: T; md?: T; lg?: T; xl?: T; xxl?: T }) =>
      applyResponsiveStyle(dimensions.width, styles),
    [dimensions.width],
  );
  const getGridColumnsMemo = useCallback(
    (minItemWidth?: number, gap?: number, padding?: number) =>
      getGridColumns(dimensions.width, minItemWidth, gap, padding),
    [dimensions.width],
  );
  const isBreakpoint = useMemo(
    () => ({
      xs:
        dimensions.width >= BREAKPOINTS.xs && dimensions.width < BREAKPOINTS.sm,
      sm:
        dimensions.width >= BREAKPOINTS.sm && dimensions.width < BREAKPOINTS.md,
      md:
        dimensions.width >= BREAKPOINTS.md && dimensions.width < BREAKPOINTS.lg,
      lg:
        dimensions.width >= BREAKPOINTS.lg && dimensions.width < BREAKPOINTS.xl,
      xl:
        dimensions.width >= BREAKPOINTS.xl &&
        dimensions.width < BREAKPOINTS.xxl,
      xxl: dimensions.width >= BREAKPOINTS.xxl,
    }),
    [dimensions.width],
  );
  return {
    width: dimensions.width,
    height: dimensions.height,
    deviceType,
    isTablet,
    isMobile,
    isSmallMobile,
    isWeb,
    isDesktop,
    orientation,
    isPortrait,
    isLandscape,
    pixelRatio,
    fontScale,
    scaleWidth: scaleWidthMemo,
    scaleHeight: scaleHeightMemo,
    scaleWithLimits: scaleWithLimitsMemo,
    getResponsiveDimension: getResponsiveDimensionMemo,
    spacing,
    spacingPreset,
    fontSize,
    fontSizePreset,
    dimensions: commonDimensions,
    applyResponsiveStyle: applyResponsiveStyleMemo,
    getGridColumns: getGridColumnsMemo,
    maintainAspectRatio,
    normalizeDPI,
    breakpoints: BREAKPOINTS,
    isBreakpoint,
  };
};
import { useAppTheme } from '@/app/styles/theme';
export const useResponsiveStyles = <T extends Record<string, any>>(
  styleFactory: (theme: any, responsive: ResponsiveInfo) => T,
): T => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  return useMemo(
    () => styleFactory(theme, responsive),
    [theme, responsive, styleFactory],
  );
};

================
File: app/src/app/services/secureStorageService.ts
================
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';
class SecureStorageService {
  private isAvailable(): boolean {
    return Platform.OS !== 'web';
  }
  async setItem(key: string, value: string): Promise<void> {
    if (!this.isAvailable()) {
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.setItem(key, value);
      }
      return;
    }
    try {
      await SecureStore.setItemAsync(key, value);
    } catch (error) {
      console.error('Error storing secure item:', error);
      throw error;
    }
  }
  async getItem(key: string): Promise<string | null> {
    if (!this.isAvailable()) {
      if (typeof window !== 'undefined' && window.localStorage) {
        return window.localStorage.getItem(key);
      }
      return null;
    }
    try {
      return await SecureStore.getItemAsync(key);
    } catch (error) {
      console.error('Error retrieving secure item:', error);
      return null;
    }
  }
  async removeItem(key: string): Promise<void> {
    if (!this.isAvailable()) {
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.removeItem(key);
      }
      return;
    }
    try {
      await SecureStore.deleteItemAsync(key);
    } catch (error) {
      console.error('Error removing secure item:', error);
      throw error;
    }
  }
  async clear(): Promise<void> {
    const keysToRemove = [
      'auth_token',
      'refresh_token',
      'user_info',
      'last_known_api_url',
      'kitchen_filters_preferences',
      'app_theme_preference',
      'user_credentials',
      'remember_me_preference',
      'connection_mode',
      'manual_server_url',
    ];
    for (const key of keysToRemove) {
      try {
        await this.removeItem(key);
      } catch (error) {
        console.error(`Error removing key ${key}:`, error);
      }
    }
  }
}
const secureStorage = new SecureStorageService();
export default {
  setItem: (key: string, value: string) => secureStorage.setItem(key, value),
  getItem: (key: string) => secureStorage.getItem(key),
  removeItem: (key: string) => secureStorage.removeItem(key),
  clear: () => secureStorage.clear(),
};
export { SecureStorageService };

================
File: app/src/app/styles/responsive.ts
================
import { Dimensions, PixelRatio } from 'react-native';
const { width: screenWidth, height: screenHeight } = Dimensions.get('window');
export const BREAKPOINTS = {
  xs: 0,
  sm: 360,
  md: 600,
  lg: 900,
  xl: 1200,
  xxl: 1536,
} as const;
export const DEVICE_TYPES = {
  MOBILE_SMALL: 'mobile_small',
  MOBILE: 'mobile',
  TABLET_SMALL: 'tablet_small',
  TABLET: 'tablet',
  TABLET_LARGE: 'tablet_large',
} as const;
export const PIXEL_DENSITIES = {
  MDPI: 1,
  HDPI: 1.5,
  XHDPI: 2,
  XXHDPI: 3,
  XXXHDPI: 4,
} as const;
export const REFERENCE_DIMENSIONS = {
  width: 360,
  height: 640,
} as const;
export const getDeviceType = (width: number = screenWidth): string => {
  if (width < BREAKPOINTS.sm) return DEVICE_TYPES.MOBILE_SMALL;
  if (width < BREAKPOINTS.md) return DEVICE_TYPES.MOBILE;
  if (width < BREAKPOINTS.lg) return DEVICE_TYPES.TABLET_SMALL;
  if (width < BREAKPOINTS.xl) return DEVICE_TYPES.TABLET;
  return DEVICE_TYPES.TABLET_LARGE;
};
export const isTablet = (width: number = screenWidth): boolean => {
  return width >= BREAKPOINTS.md;
};
export const getWidthScale = (width: number = screenWidth): number => {
  return width / REFERENCE_DIMENSIONS.width;
};
export const getHeightScale = (height: number = screenHeight): number => {
  return height / REFERENCE_DIMENSIONS.height;
};
export const scaleWidth = (
  size: number,
  width: number = screenWidth,
): number => {
  const scale = getWidthScale(width);
  return Math.round(size * scale);
};
export const scaleHeight = (
  size: number,
  height: number = screenHeight,
): number => {
  const scale = getHeightScale(height);
  return Math.round(size * scale);
};
export const scaleWithLimits = (
  size: number,
  minScale: number = 0.8,
  maxScale: number = 1.5,
  width: number = screenWidth,
): number => {
  const scale = Math.max(minScale, Math.min(maxScale, getWidthScale(width)));
  return Math.round(size * scale);
};
export const getResponsiveDimension = (
  mobile: number,
  tablet: number,
  width: number = screenWidth,
): number => {
  return isTablet(width) ? tablet : mobile;
};
export const RESPONSIVE_SPACING = {
  xxxs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(2, width) : scaleWidth(1, width),
  xxs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(4, width) : scaleWidth(2, width),
  xs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(6, width) : scaleWidth(4, width),
  s: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(10, width) : scaleWidth(8, width),
  m: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(16, width) : scaleWidth(16, width),
  l: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(24, width) : scaleWidth(24, width),
  xl: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(32, width) : scaleWidth(32, width),
  xxl: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(40, width) : scaleWidth(40, width),
} as const;
export const RESPONSIVE_FONT_SIZES = {
  xs: (width: number = screenWidth) =>
    isTablet(width) ? 10 : scaleWithLimits(10, 0.9, 1.1, width),
  s: (width: number = screenWidth) =>
    isTablet(width) ? 12 : scaleWithLimits(12, 0.9, 1.1, width),
  m: (width: number = screenWidth) =>
    isTablet(width) ? 14 : scaleWithLimits(14, 0.9, 1.2, width),
  l: (width: number = screenWidth) =>
    isTablet(width) ? 16 : scaleWithLimits(16, 0.9, 1.2, width),
  xl: (width: number = screenWidth) =>
    isTablet(width) ? 18 : scaleWithLimits(20, 0.9, 1.3, width),
  xxl: (width: number = screenWidth) =>
    isTablet(width) ? 22 : scaleWithLimits(24, 0.9, 1.3, width),
  xxxl: (width: number = screenWidth) =>
    isTablet(width) ? 28 : scaleWithLimits(32, 0.9, 1.4, width),
} as const;
export const RESPONSIVE_DIMENSIONS = {
  drawerWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return 280;
    if (width < BREAKPOINTS.md) return 300;
    if (width < BREAKPOINTS.lg) return 340;
    if (width < BREAKPOINTS.xl) return 360;
    return 380;
  },
  modalWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return width * 0.95;
    if (width < BREAKPOINTS.md) return width * 0.85;
    if (width < BREAKPOINTS.lg) return Math.min(width * 0.6, 500);
    return Math.min(width * 0.45, 550);
  },
  headerHeight: (width: number = screenWidth) => {
    return getResponsiveDimension(56, 64, width);
  },
  buttonHeight: (width: number = screenWidth) => {
    return getResponsiveDimension(48, 44, width);
  },
  iconSize: {
    small: (width: number = screenWidth) =>
      getResponsiveDimension(16, 16, width),
    medium: (width: number = screenWidth) =>
      getResponsiveDimension(24, 24, width),
    large: (width: number = screenWidth) =>
      getResponsiveDimension(32, 32, width),
  },
  productImageSize: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return 80;
    if (width < BREAKPOINTS.md) return 100;
    if (width < BREAKPOINTS.lg) return 90;
    return 100;
  },
  cardMinWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return width - 32;
    if (width < BREAKPOINTS.md) return 280;
    if (width < BREAKPOINTS.lg) return 320;
    return 360;
  },
} as const;
export const applyResponsiveStyle = <T>(
  width: number,
  styles: {
    xs?: T;
    sm?: T;
    md?: T;
    lg?: T;
    xl?: T;
    xxl?: T;
  },
): T | undefined => {
  const breakpoints = Object.keys(BREAKPOINTS).reverse() as Array<
    keyof typeof BREAKPOINTS
  >;
  for (const breakpoint of breakpoints) {
    if (width >= BREAKPOINTS[breakpoint] && styles[breakpoint]) {
      return styles[breakpoint];
    }
  }
  return undefined;
};
export const getGridColumns = (
  width: number = screenWidth,
  minItemWidth: number = 150,
  gap: number = 16,
  padding: number = 16,
): number => {
  const availableWidth = width - padding * 2;
  const columns = Math.floor((availableWidth + gap) / (minItemWidth + gap));
  return Math.max(1, columns);
};
export const getOrientation = (
  width: number = screenWidth,
  height: number = screenHeight,
) => {
  return width > height ? 'landscape' : 'portrait';
};
export const maintainAspectRatio = (
  originalWidth: number,
  originalHeight: number,
  maxWidth: number,
  maxHeight: number,
) => {
  const aspectRatio = originalWidth / originalHeight;
  let width = maxWidth;
  let height = maxWidth / aspectRatio;
  if (height > maxHeight) {
    height = maxHeight;
    width = maxHeight * aspectRatio;
  }
  return { width: Math.round(width), height: Math.round(height) };
};
export const normalizeDPI = (size: number): number => {
  const pixelRatio = PixelRatio.get();
  return Math.round(size * pixelRatio) / pixelRatio;
};
export const getScreenDimensions = () => {
  return Dimensions.get('window');
};
export const TABLET_DENSITY_MULTIPLIER = 0.75;
export const getCompactSize = (
  mobileSize: number,
  width: number = screenWidth,
  compactRatio: number = TABLET_DENSITY_MULTIPLIER,
): number => {
  return isTablet(width) ? Math.round(mobileSize * compactRatio) : mobileSize;
};
export const getCompactFontSize = (
  mobileSize: number,
  width: number = screenWidth,
  compactRatio: number = 0.85,
): number => {
  return isTablet(width) ? Math.round(mobileSize * compactRatio) : mobileSize;
};
export const getCompactSpacing = (
  mobileSpacing: number,
  width: number = screenWidth,
  compactRatio: number = 0.65,
): number => {
  return isTablet(width)
    ? Math.round(mobileSpacing * compactRatio)
    : mobileSpacing;
};

================
File: app/src/modules/areasTables/services/areaService.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '../../../app/services/apiClient';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  FindAllAreasDto,
} from '../schema/area.schema';
export const getAreas = async (
  filterOptions: FindAllAreasDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 10 },
): Promise<Area[]> => {
  const response = await apiClient.get<{
    items: Area[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.AREAS, {
    params: {
      ...filterOptions,
      page: paginationOptions.page,
      limit: paginationOptions.limit,
    },
  });
  return response.data.items;
};
export const getAreaById = async (id: string): Promise<Area> => {
  const response = await apiClient.get<Area>(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
  );
  return response.data;
};
export const createArea = async (data: CreateAreaDto): Promise<Area> => {
  const response = await apiClient.post<Area>(API_PATHS.AREAS, data);
  return response.data;
};
export const updateArea = async (
  id: string,
  data: UpdateAreaDto,
): Promise<Area> => {
  const response = await apiClient.patch<Area>(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};
export const deleteArea = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.AREAS_BY_ID.replace(':id', id));
};
const areaQueryKeys = {
  all: ['areas'] as const,
};
export function useGetAreas() {
  return useQuery<Area[], ApiError>({
    queryKey: areaQueryKeys.all,
    queryFn: () => getAreas(),
  });
}

================
File: app/src/modules/auth/components/RegisterForm.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useMutation } from '@tanstack/react-query';
import { authService } from '../services/authService';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
const registerFormSchema = z.object({
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .max(20, 'El nombre de usuario no puede exceder 20 caracteres')
    .regex(/^[a-zA-Z0-9_]+$/, 'Solo se permiten letras, números y guión bajo'),
  email: z.string().email('Email inválido'),
  password: z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
  firstName: z
    .string()
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres'),
  lastName: z
    .string()
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(50, 'El apellido no puede exceder 50 caracteres'),
  phoneNumber: z
    .union([
      z.string().regex(/^\+?[0-9\s-]+$/, 'Número de teléfono inválido'),
      z.literal(''),
    ])
    .optional(),
  role: z.number(),
});
type RegisterFormInputs = z.infer<typeof registerFormSchema>;
interface RegisterModalProps {
  visible: boolean;
  onDismiss: () => void;
  onRegisterSuccess?: (username: string, password: string) => void;
}
export function RegisterModal({
  visible,
  onDismiss,
  onRegisterSuccess,
}: RegisterModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showPassword, setShowPassword] = useState(false);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<RegisterFormInputs>({
    resolver: zodResolver(registerFormSchema),
    defaultValues: {
      username: '',
      email: '',
      password: '',
      firstName: '',
      lastName: '',
      phoneNumber: '',
      role: 4, // Default a Mesero
    },
  });
  const { mutate: register, isPending } = useMutation({
    mutationFn: (data: RegisterFormInputs) => {
      const registerData = {
        username: data.username,
        email: data.email,
        password: data.password,
        firstName: data.firstName,
        lastName: data.lastName,
        phoneNumber: data.phoneNumber || undefined,
        role: { id: data.role },
        isActive: true,
      };
      return authService.register(registerData as any);
    },
    onSuccess: (_, variables) => {
      showSnackbar({
        message: 'Registro exitoso. Ya puedes iniciar sesión.',
        type: 'success',
      });
      if (onRegisterSuccess) {
        onRegisterSuccess(variables.username, variables.password);
      }
      reset();
      onDismiss();
    },
    onError: (error: unknown) => {
      const userMessage = getApiErrorMessage(error);
      showSnackbar({
        message: userMessage,
        type: 'error',
        duration: 5000,
      });
    },
  });
  const onSubmit = (data: RegisterFormInputs) => {
    register(data);
  };
  const handleDismiss = () => {
    reset();
    setShowPassword(false);
    onDismiss();
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.modalContent} elevation={5}>
          <View
            style={[
              styles.headerContainer,
              { backgroundColor: theme.colors.primary },
            ]}
          >
            <View style={styles.headerLeft}>
              <Avatar.Icon
                size={32}
                icon="account-plus"
                style={[
                  styles.headerIcon,
                  { backgroundColor: theme.colors.onPrimary + '20' },
                ]}
                color={theme.colors.onPrimary}
              />
              <View style={styles.headerTextContainer}>
                <Text
                  style={[styles.modalTitle, { color: theme.colors.onPrimary }]}
                  variant="titleMedium"
                >
                  Crear cuenta
                </Text>
              </View>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={handleDismiss}
              disabled={isPending}
              iconColor={theme.colors.onPrimary}
            />
          </View>
          <ScrollView
            style={styles.formContainer}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-key"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información de Cuenta
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>
              <Controller
                control={control}
                name="username"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre de usuario"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.username}
                      mode="outlined"
                      placeholder="usuario123"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.username && (
                      <HelperText type="error" visible={!!errors.username}>
                        {errors.username.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="email"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Email"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.email}
                      mode="outlined"
                      placeholder="usuario@ejemplo.com"
                      keyboardType="email-address"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="email" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.email && (
                      <HelperText type="error" visible={!!errors.email}>
                        {errors.email.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="password"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Contraseña"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.password}
                      mode="outlined"
                      placeholder="••••••"
                      secureTextEntry={!showPassword}
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="lock" />}
                      right={
                        <TextInput.Icon
                          icon={showPassword ? 'eye-off' : 'eye'}
                          onPress={() => setShowPassword(!showPassword)}
                        />
                      }
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.password && (
                      <HelperText type="error" visible={!!errors.password}>
                        {errors.password.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="role"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="badge-account"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Tipo de cuenta
                      </Text>
                    </View>
                    <View style={styles.rolesContainer}>
                      {[
                        {
                          value: 4,
                          label: 'Mesero',
                          icon: 'room-service',
                          description: 'Tomar y gestionar órdenes',
                        },
                        {
                          value: 6,
                          label: 'Repartidor',
                          icon: 'moped',
                          description: 'Entregar pedidos',
                        },
                      ].map((role) => (
                        <Surface
                          key={role.value}
                          style={[
                            styles.roleCard,
                            value === role.value && styles.roleCardActive,
                          ]}
                          elevation={value === role.value ? 2 : 0}
                        >
                          <TouchableOpacity
                            onPress={() => onChange(role.value)}
                            style={styles.roleCardContent}
                          >
                            <Icon
                              source={role.icon}
                              size={24}
                              color={
                                value === role.value
                                  ? theme.colors.primary
                                  : theme.colors.onSurfaceVariant
                              }
                            />
                            <Text
                              style={[
                                styles.roleLabel,
                                value === role.value && styles.roleLabelActive,
                              ]}
                              variant="labelMedium"
                            >
                              {role.label}
                            </Text>
                            <Text
                              style={styles.roleDescription}
                              variant="bodySmall"
                              numberOfLines={2}
                            >
                              {role.description}
                            </Text>
                          </TouchableOpacity>
                        </Surface>
                      ))}
                    </View>
                  </View>
                )}
              />
            </View>
            <Divider style={styles.divider} />
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-circle"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información Personal
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>
              <Controller
                control={control}
                name="firstName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.firstName}
                      mode="outlined"
                      placeholder="Juan"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.firstName && (
                      <HelperText type="error" visible={!!errors.firstName}>
                        {errors.firstName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="lastName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Apellido"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.lastName}
                      mode="outlined"
                      placeholder="Pérez"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.lastName && (
                      <HelperText type="error" visible={!!errors.lastName}>
                        {errors.lastName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="phoneNumber"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Teléfono (opcional)"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.phoneNumber}
                      mode="outlined"
                      placeholder="+52 55 1234 5678"
                      keyboardType="phone-pad"
                      left={<TextInput.Icon icon="phone" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.phoneNumber && (
                      <HelperText type="error" visible={!!errors.phoneNumber}>
                        {errors.phoneNumber.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
            </View>
          </ScrollView>
          <Surface style={styles.buttonContainer} elevation={2}>
            <Button
              onPress={handleDismiss}
              disabled={isPending}
              style={[styles.button, styles.cancelButton]}
              textColor={theme.colors.onSecondaryContainer}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              disabled={isPending}
              loading={isPending}
              style={[styles.button, styles.confirmButton]}
              buttonColor={theme.colors.primary}
            >
              Registrarse
            </Button>
          </Surface>
        </Surface>
      </Modal>
    </Portal>
  );
}
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? 20 : 12,
      maxWidth: responsive.isTablet ? 600 : '100%',
      alignSelf: 'center',
      width: responsive.isTablet ? '80%' : '94%',
    },
    modalContent: {
      borderRadius: responsive.isTablet
        ? theme.roundness * 3
        : theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      maxHeight: responsive.isTablet ? '90%' : '92%',
      minHeight: responsive.isTablet ? 600 : 550,
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing.m
        : responsive.spacing.s,
      paddingTop: responsive.isTablet
        ? responsive.spacing.s
        : responsive.spacing.xs,
      paddingBottom: responsive.spacing.xs,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.s
        : responsive.spacing.xs,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.isTablet ? theme.spacing.xs : 6,
      gap: responsive.isTablet ? theme.spacing.xs : 6,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 13,
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.primary + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '40',
    },
    requiredChipText: {
      color: theme.colors.primary,
      fontSize: responsive.isTablet ? 11 : 10,
      fontWeight: '600',
    },
    inputContainer: {
      marginBottom: responsive.isTablet ? theme.spacing.xs : 6,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
    },
    input: {
      fontSize: responsive.isTablet ? 14 : 13,
      backgroundColor: theme.colors.surface,
      height: responsive.isTablet ? 48 : 44,
    },
    inputContent: {
      paddingVertical: responsive.isTablet ? 4 : 2,
      fontSize: responsive.isTablet ? 14 : 13,
      fontFamily: 'System',
    },
    fieldLabelContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : 6,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    rolesContainer: {
      flexDirection: 'row',
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      justifyContent: 'center',
    },
    roleCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      backgroundColor: theme.colors.surface,
      minWidth: responsive.isTablet ? 140 : 125,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
      elevation: 1,
    },
    roleCardActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
      elevation: 3,
    },
    roleCardContent: {
      alignItems: 'center',
    },
    roleLabel: {
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.isTablet ? theme.spacing.xs : 4,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 14 : 13,
    },
    roleLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '700',
    },
    roleDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: responsive.isTablet ? 11 : 10,
      textAlign: 'center',
    },
    divider: {
      marginVertical: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      marginHorizontal: responsive.isTablet
        ? -theme.spacing.m
        : -theme.spacing.s,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    button: {
      flex: 1,
      maxWidth: responsive.isTablet ? 150 : 140,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
  });

================
File: app/src/modules/kitchen/components/OrderItemRow.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity, Platform } from 'react-native';
import { Text, useTheme, Chip } from 'react-native-paper';
import { KitchenOrderItem, PreparationStatus } from '../types/kitchen.types';
import { useResponsive } from '@/app/hooks/useResponsive';
interface OrderItemRowProps {
  item: KitchenOrderItem;
  onPress?: () => void;
  onTogglePrepared?: (itemId: string, currentStatus: boolean) => void;
  isOrderInPreparation?: boolean;
}
export const OrderItemRow = React.memo<OrderItemRowProps>(
  ({ item, onTogglePrepared, isOrderInPreparation }) => {
    const theme = useTheme();
    const responsive = useResponsive();
    const isPrepared = item.preparationStatus === PreparationStatus.READY;
    const isInProgress =
      item.preparationStatus === PreparationStatus.IN_PROGRESS;
    const isDisabled = !item.belongsToMyScreen;
    const canToggle =
      isOrderInPreparation &&
      (isInProgress || isPrepared) &&
      item.belongsToMyScreen &&
      onTogglePrepared;
    const buildItemName = () => {
      const displayName = item.variantName || item.productName;
      return `${item.quantity}x ${displayName}`;
    };
    const buildItemDetails = () => {
      const details: string[] = [];
      const allCustoms: string[] = [];
      if (item.modifiers.length > 0) {
        allCustoms.push(...item.modifiers);
      }
      if (item.pizzaCustomizations && item.pizzaCustomizations.length > 0) {
        const customizations = item.pizzaCustomizations.map((pc) => {
          let text = pc.customizationName;
          if (pc.action) text += ` (${pc.action})`;
          if (pc.half) text += ` - ${pc.half}`;
          return text;
        });
        allCustoms.push(...customizations);
      }
      if (allCustoms.length > 0) {
        details.push(allCustoms.join(', '));
      }
      if (item.preparationNotes) {
        details.push(`📝 ${item.preparationNotes}`);
      }
      return details;
    };
    const styles = StyleSheet.create({
      container: {
        paddingHorizontal: responsive.isWeb
          ? responsive.spacing.m
          : responsive.spacing.s,
        paddingVertical: responsive.isWeb
          ? responsive.spacing.s
          : responsive.spacing.xs,
        minHeight: responsive.isWeb ? 52 : responsive.isTablet ? 40 : 36,
        display: 'flex',
        justifyContent: 'center',
      },
      disabled: {
        opacity: 0.5,
      },
      row: {
        flexDirection: 'row',
        alignItems: 'center',
        flex: 1,
      },
      content: {
        flex: 1,
      },
      withBorder: {
        borderRadius: theme.roundness / 2,
        borderWidth: 1,
        borderColor: theme.colors.outline,
        borderStyle: 'dashed',
      },
      clickable: {
        backgroundColor: 'rgba(0, 0, 0, 0.02)',
      },
      itemName: {
        fontWeight: '500',
        fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 13 : 14,
        lineHeight: responsive.isWeb ? 24 : responsive.isTablet ? 18 : 20,
      },
      detail: {
        color: theme.colors.onSurfaceVariant,
        marginTop: responsive.isWeb ? 2 : -1,
        fontSize: responsive.isWeb ? 14 : responsive.isTablet ? 11 : 12,
        lineHeight: responsive.isWeb ? 20 : responsive.isTablet ? 14 : 16,
      },
      strikethrough: {
        textDecorationLine: 'line-through',
        textDecorationStyle: 'solid',
        textDecorationColor: theme.colors.error,
        opacity: 0.7,
      },
      disabledText: {
        color: theme.colors.onSurfaceDisabled || '#999',
      },
    });
    const handlePress = () => {
      if (canToggle) {
        onTogglePrepared(item.id, isPrepared);
      }
    };
    const Container = canToggle ? TouchableOpacity : View;
    return (
      <Container
        onPress={canToggle ? handlePress : undefined}
        activeOpacity={0.7}
        style={[
          styles.container,
          styles.withBorder,
          isDisabled && styles.disabled,
          canToggle && styles.clickable,
        ]}
      >
        <View style={styles.row}>
          <View style={styles.content}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                gap: responsive.spacing.xs,
              }}
            >
              <Text
                variant="bodyMedium"
                style={[
                  styles.itemName,
                  isPrepared && styles.strikethrough,
                  isDisabled && styles.disabledText,
                ]}
              >
                {buildItemName()}
              </Text>
            </View>
            {buildItemDetails().map((detail, index) => (
              <Text
                key={index}
                variant="labelSmall"
                style={[
                  styles.detail,
                  isPrepared && styles.strikethrough,
                  isDisabled && styles.disabledText,
                ]}
              >
                {detail}
              </Text>
            ))}
          </View>
        </View>
      </Container>
    );
  },
);
OrderItemRow.displayName = 'OrderItemRow';

================
File: app/src/modules/kitchen/services/kitchenService.ts
================
import apiClient from '@/app/services/apiClient';
import { KitchenOrder, KitchenFilters } from '../types/kitchen.types';
import { API_PATHS } from '@/app/constants/apiPaths';
interface _PaginationResponse<T> {
  data: T[];
  hasNextPage: boolean;
}
class KitchenService {
  async getKitchenOrders(
    filters: Partial<KitchenFilters> = {},
  ): Promise<KitchenOrder[]> {
    const queryParams = new URLSearchParams();
    if (filters.orderType) {
      queryParams.append('orderType', filters.orderType);
    }
    if (filters.showPrepared !== undefined) {
      queryParams.append('showPrepared', String(filters.showPrepared));
    }
    if (filters.showAllProducts !== undefined) {
      queryParams.append('showAllProducts', String(filters.showAllProducts));
    }
    if (filters.ungroupProducts !== undefined) {
      queryParams.append('ungroupProducts', String(filters.ungroupProducts));
    }
    if (filters.screenId !== undefined) {
      queryParams.append('screenId', filters.screenId);
    }
    const queryString = queryParams.toString();
    const url = queryString
      ? `${API_PATHS.KITCHEN_ORDERS}?${queryString}`
      : API_PATHS.KITCHEN_ORDERS;
    const response = await apiClient.get<KitchenOrder[]>(url);
    return response.data || [];
  }
  async markItemPrepared(
    itemId: string,
    isPrepared: boolean = true,
  ): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_MARK_PREPARED.replace(':itemId', itemId),
      {
        isPrepared,
      },
    );
  }
  async unmarkItemPrepared(itemId: string): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_MARK_UNPREPARED.replace(':itemId', itemId),
    );
  }
  async startOrderPreparation(orderId: string): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_ORDERS_START_PREPARATION.replace(':orderId', orderId),
    );
  }
  async cancelOrderPreparation(orderId: string): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_ORDERS_CANCEL_PREPARATION.replace(':orderId', orderId),
    );
  }
  async completeOrderPreparation(orderId: string): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_ORDERS_COMPLETE_PREPARATION.replace(
        ':orderId',
        orderId,
      ),
    );
  }
}
export const kitchenService = new KitchenService();

================
File: app/src/modules/kitchen/types/kitchen.types.ts
================
export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKE_AWAY = 'TAKE_AWAY',
  DELIVERY = 'DELIVERY',
}
export enum PreparationStatus {
  PENDING = 'PENDING',
  IN_PROGRESS = 'IN_PROGRESS',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  CANCELLED = 'CANCELLED',
}
export enum PreparationScreenStatus {
  PENDING = 'PENDING',
  IN_PREPARATION = 'IN_PREPARATION',
  READY = 'READY',
}
export interface KitchenOrderItem {
  id: string;
  productName: string;
  variantName?: string;
  modifiers: string[];
  pizzaCustomizations?: Array<{
    customizationName: string;
    action: string;
    half?: string;
  }>;
  preparationNotes?: string;
  preparationStatus: PreparationStatus;
  preparedAt?: string;
  preparedByUser?: {
    firstName: string;
    lastName: string;
  };
  quantity: number;
  belongsToMyScreen: boolean;
}
export interface PreparationScreenStatusInfo {
  screenId: string;
  screenName: string;
  status: PreparationScreenStatus;
}
export interface KitchenOrder {
  id: string;
  shiftOrderNumber: number;
  orderType: OrderType;
  orderStatus: string;
  createdAt: string;
  orderNotes?: string;
  deliveryAddress?: string;
  deliveryPhone?: string;
  receiptName?: string;
  customerPhone?: string;
  areaName?: string;
  tableName?: string;
  items: KitchenOrderItem[];
  hasPendingItems: boolean;
  screenStatuses: PreparationScreenStatusInfo[];
  myScreenStatus?: PreparationScreenStatus;
  isFromWhatsApp?: boolean;
}
export interface KitchenFilters {
  orderType?: OrderType;
  showPrepared: boolean;
  showAllProducts: boolean;
  ungroupProducts: boolean;
  screenId?: string;
}
export interface PreparationScreen {
  id: string;
  name: string;
  description?: string;
  isActive: boolean;
}

================
File: app/src/modules/menu/services/fileService.ts
================
import apiClient from '../../../app/services/apiClient';
import { ApiError } from '../../../app/lib/errors';
import { Platform } from 'react-native';
import { API_PATHS } from '../../../app/constants/apiPaths';
import NetInfo from '@react-native-community/netinfo';
export interface FileUploadResponse {
  file: {
    id: string;
    path: string;
  };
  presignedUrl?: string;
}
export interface FileObject {
  uri: string;
  name: string;
  type: string;
}
const checkNetworkConnection = async (): Promise<boolean> => {
  const state = await NetInfo.fetch();
  return state.isConnected === true && state.isInternetReachable !== false;
};
export const uploadFile = async (
  fileToUpload: FileObject,
  maxRetries: number = 3,
): Promise<FileUploadResponse> => {
  const isConnected = await checkNetworkConnection();
  if (!isConnected) {
    throw new ApiError(
      'NETWORK_ERROR',
      'Sin conexión a internet. Verifica tu conexión e intenta nuevamente.',
      0,
    );
  }
  const formData = new FormData();
  formData.append('file', {
    uri:
      Platform.OS === 'android'
        ? fileToUpload.uri
        : fileToUpload.uri.replace('file://', ''),
    name: fileToUpload.name,
    type: fileToUpload.type,
  } as any);
  let lastError: any;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await apiClient.post<FileUploadResponse>(
        API_PATHS.FILES_UPLOAD,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
            'Cache-Control': 'no-cache',
          },
          timeout: 120000,
          maxContentLength: Infinity,
          maxBodyLength: Infinity,
        },
      );
      if (!response.data || !response.data.file) {
        throw new ApiError(
          'UPLOAD_FAILED',
          'Error al recibir respuesta del servidor',
          500,
        );
      }
      return response.data;
    } catch (error) {
      lastError = error;
      if (
        error instanceof ApiError &&
        error.status >= 400 &&
        error.status < 500
      ) {
        throw error;
      }
      if (attempt === maxRetries) {
        if (error instanceof ApiError) throw error;
        throw new ApiError(
          'UPLOAD_FAILED',
          `Error al subir archivo después de ${maxRetries} intentos: ${error instanceof Error ? error.message : 'Error desconocido'}`,
          500,
        );
      }
      const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
  throw (
    lastError ||
    new ApiError('UPLOAD_FAILED', 'Error desconocido al subir archivo', 500)
  );
};
const fileService = {
  uploadFile,
  uploadImage: uploadFile,
};
export default fileService;

================
File: app/src/modules/modifiers/services/modifierGroupService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  ModifierGroup,
  CreateModifierGroupInput,
  UpdateModifierGroupInput,
  modifierGroupApiSchema,
} from '../schema/modifierGroup.schema';
import { z } from 'zod';
import { PaginatedResponse } from '@/app/types/api.types';
const _modifierGroupsListSchema = z.array(modifierGroupApiSchema);
const paginatedModifierGroupsSchema = z.object({
  items: z.array(modifierGroupApiSchema),
  total: z.number(),
  page: z.number(),
  limit: z.number(),
  hasNextPage: z.boolean(),
  hasPrevPage: z.boolean(),
});
interface FindAllParams {
  page?: number;
  limit?: number;
  isActive?: boolean;
  search?: string;
}
export const modifierGroupService = {
  async findAll(
    params: FindAllParams = {},
  ): Promise<PaginatedResponse<ModifierGroup>> {
    const queryParams = {
      page: params.page ?? 1,
      limit: params.limit ?? 10,
      ...(params.isActive !== undefined && { isActive: params.isActive }),
      ...(params.search && { search: params.search }),
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIER_GROUPS,
      queryParams,
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
    const paginatedResult = paginatedModifierGroupsSchema.safeParse(
      response.data,
    );
    if (paginatedResult.success) {
      return {
        data: paginatedResult.data.items,
        total: paginatedResult.data.total,
        page: paginatedResult.data.page,
        limit: paginatedResult.data.limit,
        totalPages: Math.ceil(
          paginatedResult.data.total / paginatedResult.data.limit,
        ),
      };
    }
    throw new Error('Received invalid data format for modifier groups.');
  },
  async findOne(id: string): Promise<ModifierGroup> {
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(`Received invalid data format for modifier group ${id}.`);
    }
    return validationResult.data;
  },
  async create(data: CreateModifierGroupInput): Promise<ModifierGroup> {
    const response = await apiClient.post<unknown>(
      API_PATHS.MODIFIER_GROUPS,
      data,
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(
        'Received invalid data format after creating modifier group.',
      );
    }
    return validationResult.data;
  },
  async update(
    id: string,
    data: UpdateModifierGroupInput,
  ): Promise<ModifierGroup> {
    const response = await apiClient.patch<unknown>(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
      data,
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(
        `Received invalid data format after updating modifier group ${id}.`,
      );
    }
    return validationResult.data;
  },
  async remove(id: string): Promise<void> {
    const response = await apiClient.delete(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
    );
    if (!response.ok) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
  },
};

================
File: app/src/modules/modifiers/services/modifierService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Modifier,
  CreateModifierInput,
  UpdateModifierInput,
  modifierApiSchema,
} from '../schema/modifier.schema';
import { z } from 'zod';
import { PaginatedResponse } from '@/app/types/api.types';
const modifiersListSchema = z.array(modifierApiSchema);
const paginatedModifiersSchema = z.object({
  items: z.array(modifierApiSchema),
  total: z.number(),
  page: z.number(),
  limit: z.number(),
  hasNextPage: z.boolean(),
  hasPrevPage: z.boolean(),
});
interface FindAllModifiersParams {
  page?: number;
  limit?: number;
  groupId?: string;
}
export const modifierService = {
  async findAll(
    params?: FindAllModifiersParams,
  ): Promise<PaginatedResponse<Modifier>> {
    const queryParams = {
      page: params?.page ?? 1,
      limit: params?.limit ?? 10,
      ...params,
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS,
      queryParams,
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
    const paginatedResult = paginatedModifiersSchema.safeParse(response.data);
    if (paginatedResult.success) {
      return {
        data: paginatedResult.data.items,
        total: paginatedResult.data.total,
        page: paginatedResult.data.page,
        limit: paginatedResult.data.limit,
        totalPages: Math.ceil(
          paginatedResult.data.total / paginatedResult.data.limit,
        ),
      };
    }
    throw new Error('Received invalid data format for modifiers.');
  },
  async findOne(id: string): Promise<Modifier> {
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(`Received invalid data format for modifier ${id}.`);
    }
    return validationResult.data;
  },
  async findByGroupId(
    modifierGroupId: string,
    params: { isActive?: boolean; search?: string } = {},
  ): Promise<Modifier[]> {
    const queryParams = {
      ...(params.isActive !== undefined && { isActive: params.isActive }),
      ...(params.search && { search: params.search }),
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS_BY_GROUP.replace(':modifierGroupId', modifierGroupId),
      queryParams,
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
    const validationResult = modifiersListSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(
        `Received invalid data format for modifiers of group ${modifierGroupId}.`,
      );
    }
    return validationResult.data;
  },
  async create(data: CreateModifierInput): Promise<Modifier> {
    const response = await apiClient.post<unknown>(API_PATHS.MODIFIERS, data);
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error('Received invalid data format after creating modifier.');
    }
    return validationResult.data;
  },
  async update(id: string, data: UpdateModifierInput): Promise<Modifier> {
    const response = await apiClient.patch<unknown>(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
      data,
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(
        `Received invalid data format after updating modifier ${id}.`,
      );
    }
    return validationResult.data;
  },
  async remove(id: string): Promise<void> {
    const response = await apiClient.delete(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
    );
    if (!response.ok) {
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
  },
};

================
File: app/src/modules/orderFinalization/hooks/useOrderFinalizationQueries.ts
================
import { useQuery } from '@tanstack/react-query';
import { orderFinalizationService } from '../services/orderFinalizationService';
export const useOrdersForFinalizationList = () => {
  return useQuery({
    queryKey: ['orders', 'for-finalization-list'],
    queryFn: orderFinalizationService.getOrdersForFinalizationList,
    refetchInterval: 10000,
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000,
    keepPreviousData: true,
    notifyOnChangeProps: ['data', 'error'],
  });
};
export const useOrderForFinalizationDetail = (orderId: string | null) => {
  return useQuery({
    queryKey: ['orders', 'for-finalization-detail', orderId],
    queryFn: () =>
      orderId
        ? orderFinalizationService.getOrderForFinalizationDetail(orderId)
        : null,
    enabled: !!orderId,
    staleTime: 30000,
  });
};

================
File: app/src/modules/orders/components/ChangeCalculatorModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Button, TextInput } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';
interface ChangeCalculatorModalProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: () => void;
  amountToPay: number;
}
export const ChangeCalculatorModal: React.FC<ChangeCalculatorModalProps> = ({
  visible,
  onDismiss,
  onConfirm,
  amountToPay,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const [receivedAmount, setReceivedAmount] = useState('');
  // Calcular cambio
  const changeAmount = useMemo(() => {
    const received = parseFloat(receivedAmount);
    if (isNaN(received)) return 0;
    return Math.max(0, received - amountToPay);
  }, [receivedAmount, amountToPay]);
  // Determinar qué botones de billetes mostrar
  const availableBills = useMemo(() => {
    const bills = [50, 100, 200, 500, 1000];
    // Filtrar billetes que sean mayores o iguales al monto a pagar
    const validBills = bills.filter((bill) => bill >= amountToPay);
    // Tomar máximo 4 opciones para que quepan en una línea
    return validBills.slice(0, 4);
  }, [amountToPay]);
  // Resetear cuando se abre
  useEffect(() => {
    if (visible) {
      setReceivedAmount(amountToPay.toFixed(2));
    }
  }, [visible, amountToPay]);
  const handleConfirm = () => {
    const received = parseFloat(receivedAmount);
    if (!isNaN(received) && received >= amountToPay) {
      onConfirm();
    }
  };
  const footerActions = (
    <View style={styles.footer}>
      <Button
        mode="outlined"
        onPress={onDismiss}
        style={styles.cancelButton}
        labelStyle={styles.cancelButtonLabel}
        contentStyle={styles.footerButtonContent}
      >
        Cancelar
      </Button>
      <Button
        mode="contained"
        onPress={handleConfirm}
        disabled={
          !receivedAmount ||
          isNaN(parseFloat(receivedAmount)) ||
          parseFloat(receivedAmount) < amountToPay
        }
        style={styles.confirmButton}
        contentStyle={styles.footerButtonContent}
        labelStyle={styles.confirmButtonLabel}
      >
        Confirmar Pago
      </Button>
    </View>
  );
  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title="Calcular Cambio"
      widthTablet={480}
      maxWidthMobile="95%"
      scrollable={false}
      footer={footerActions}
    >
      <View style={styles.content}>
        {/* Inputs en línea */}
        <View style={styles.inputsRow}>
          {/* Total a pagar */}
          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Total a pagar</Text>
            <TextInput
              value={`$${amountToPay.toFixed(2)}`}
              editable={false}
              mode="flat"
              style={styles.totalInput}
              dense
              theme={{
                colors: {
                  primary: theme.colors.primary,
                  background: 'rgba(255, 255, 255, 0.05)',
                  text: theme.dark ? '#FFFFFF' : '#000000',
                },
              }}
            />
          </View>
          {}
          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Monto recibido</Text>
            <TextInput
              value={receivedAmount}
              onChangeText={setReceivedAmount}
              keyboardType="decimal-pad"
              mode="flat"
              left={<TextInput.Affix text="$" />}
              style={styles.receivedInput}
              error={
                receivedAmount !== '' &&
                (isNaN(parseFloat(receivedAmount)) ||
                  parseFloat(receivedAmount) < amountToPay)
              }
              dense
              theme={{
                colors: {
                  primary: theme.colors.primary,
                  background: 'rgba(255, 255, 255, 0.05)',
                },
              }}
            />
          </View>
        </View>
        {/* Error message */}
        {receivedAmount !== '' &&
          (isNaN(parseFloat(receivedAmount)) ||
            parseFloat(receivedAmount) < amountToPay) && (
            <Text style={styles.errorText}>Monto insuficiente</Text>
          )}
        {/* Botones de billetes comunes */}
        {availableBills.length > 0 && (
          <View style={styles.quickAmountsRow}>
            {availableBills.map((bill) => (
              <Pressable
                key={bill}
                onPress={() => setReceivedAmount(`${bill}.00`)}
                style={({ pressed }) => [
                  styles.quickAmountButton,
                  pressed && styles.quickAmountButtonPressed,
                ]}
              >
                <Text style={styles.quickAmountButtonText}>
                  ${bill >= 1000 ? '1k' : bill}
                </Text>
              </Pressable>
            ))}
          </View>
        )}
        {}
        {receivedAmount !== '' &&
          !isNaN(parseFloat(receivedAmount)) &&
          parseFloat(receivedAmount) >= amountToPay && (
            <View style={styles.changeSection}>
              <Text style={styles.changeLabel}>Cambio</Text>
              <Text style={styles.changeAmount}>
                ${changeAmount.toFixed(2)}
              </Text>
            </View>
          )}
      </View>
    </ResponsiveModal>
  );
};
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    content: {
      // Ya no necesita padding ya que ResponsiveModal lo maneja
    },
    inputsRow: {
      flexDirection: 'row',
      gap: 16,
      marginBottom: 20,
    },
    inputContainer: {
      flex: 1,
    },
    inputLabel: {
      ...theme.fonts.bodyMedium,
      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',
      marginBottom: 8,
      fontSize: 14,
    },
    totalInput: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.08)'
        : 'rgba(0, 0, 0, 0.04)',
      borderRadius: 12,
      fontSize: 20,
      height: 56,
      paddingHorizontal: 16,
      opacity: 0.8,
    },
    receivedInput: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.08)'
        : 'rgba(0, 0, 0, 0.04)',
      borderRadius: 12,
      fontSize: 20,
      height: 56,
      paddingHorizontal: 16,
    },
    quickAmountsRow: {
      flexDirection: 'row',
      gap: 12,
      marginTop: 16,
      justifyContent: 'center',
    },
    quickAmountButton: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.1)'
        : 'rgba(0, 0, 0, 0.05)',
      paddingHorizontal: 20,
      paddingVertical: 16,
      borderRadius: 12,
      flex: 1,
      alignItems: 'center',
      minHeight: 56,
      justifyContent: 'center',
    },
    quickAmountButtonPressed: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.2)'
        : 'rgba(0, 0, 0, 0.1)',
    },
    quickAmountButtonText: {
      ...theme.fonts.labelLarge,
      color: theme.dark ? '#FFFFFF' : '#000000',
      fontWeight: '700',
      fontSize: 18,
    },
    errorText: {
      ...theme.fonts.bodyMedium,
      color: '#FF4444',
      marginTop: 4,
      marginLeft: 4,
      fontSize: 14,
    },
    changeSection: {
      backgroundColor: theme.dark
        ? 'rgba(16, 185, 129, 0.1)'
        : 'rgba(16, 185, 129, 0.08)',
      padding: 20,
      borderRadius: 16,
      alignItems: 'center',
      marginTop: 16,
    },
    changeLabel: {
      ...theme.fonts.bodyLarge,
      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',
      marginBottom: 4,
      fontSize: 16,
    },
    changeAmount: {
      ...theme.fonts.headlineMedium,
      color: '#10B981',
      fontWeight: '700',
      letterSpacing: -0.5,
      fontSize: 32,
    },
    footer: {
      flexDirection: 'row',
      gap: 16,
    },
    cancelButton: {
      flex: 1,
      borderColor: theme.colors.error,
      backgroundColor: theme.colors.errorContainer,
    },
    cancelButtonLabel: {
      fontSize: 16,
      fontWeight: '700',
      color: theme.colors.onErrorContainer,
    },
    confirmButton: {
      flex: 2,
      backgroundColor: '#10B981',
    },
    confirmButtonLabel: {
      fontSize: 16,
      fontWeight: '700',
      color: '#FFFFFF',
    },
    footerButtonContent: {
      height: 48,
    },
  });
export default ChangeCalculatorModal;

================
File: app/src/modules/orders/components/CloseShiftModal.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Surface,
  Divider,
  Card,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { shiftsService, type Shift } from '@/services/shifts';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
interface CloseShiftModalProps {
  visible: boolean;
  onDismiss: () => void;
  onShiftClosed: () => void;
  shift: Shift | null;
}
export const CloseShiftModal: React.FC<CloseShiftModalProps> = ({
  visible,
  onDismiss,
  onShiftClosed,
  shift,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [finalCash, setFinalCash] = useState('');
  const [closeNotes, setCloseNotes] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const handleFinalCashChange = (text: string) => {
    // Permitir solo números y un punto decimal
    const cleaned = text.replace(/[^0-9.]/g, '');
    // Prevenir múltiples puntos decimales
    const parts = cleaned.split('.');
    if (parts.length > 2) return;
    // Limitar a 2 decimales
    if (parts[1] && parts[1].length > 2) {
      setFinalCash(parts[0] + '.' + parts[1].substring(0, 2));
    } else {
      setFinalCash(cleaned);
    }
  };
  const handleCloseShift = async () => {
    if (!finalCash) {
      setError('El efectivo final es requerido');
      return;
    }
    const cashAmount = parseFloat(finalCash);
    if (isNaN(cashAmount) || cashAmount < 0) {
      setError('Ingresa un monto válido');
      return;
    }
    setLoading(true);
    setError('');
    try {
      await shiftsService.closeShift({
        finalCash: cashAmount,
        closeNotes: closeNotes || undefined,
      });
      showSnackbar({ message: 'Turno cerrado exitosamente', type: 'success' });
      setFinalCash('');
      setCloseNotes('');
      onShiftClosed();
      onDismiss();
    } catch (error: any) {
      let errorMessage = 'Error al cerrar el turno';
      if (error?.message) {
        errorMessage = error.message;
      } else if (typeof error === 'string') {
        errorMessage = error;
      }
      setError(errorMessage);
      showSnackbar({ message: errorMessage, type: 'error' });
    } finally {
      setLoading(false);
    }
  };
  const handleDismiss = () => {
    if (!loading) {
      setFinalCash('');
      setCloseNotes('');
      setError('');
      onDismiss();
    }
  };
  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency: 'MXN',
    }).format(amount);
  };
  const formatTime = (dateString: string) => {
    return format(new Date(dateString), 'HH:mm', { locale: es });
  };
  const calculateDifference = () => {
    if (!finalCash || !shift?.expectedCash) return null;
    const cash = parseFloat(finalCash);
    if (isNaN(cash)) return null;
    return cash - shift.expectedCash;
  };
  const difference = calculateDifference();
  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
        dismissable={!loading}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <ScrollView
            contentContainerStyle={styles.scrollViewContent}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          >
            <Surface style={styles.modal} elevation={3}>
              {}
              <View style={styles.header}>
                <View style={styles.iconContainer}>
                  <MaterialCommunityIcons
                    name="store-off"
                    size={48}
                    color="#FF5722"
                  />
                </View>
                <Text variant="headlineMedium" style={styles.title}>
                  Cierre de Turno
                </Text>
                <Text variant="bodyLarge" style={styles.date}>
                  {todayFormatted}
                </Text>
              </View>
              <Divider style={styles.divider} />
              {}
              {shift && (
                <View style={styles.content}>
                  <Card style={styles.summaryCard}>
                    <Card.Content>
                      <Text variant="titleMedium" style={styles.sectionTitle}>
                        Resumen del Turno #{shift.globalShiftNumber}
                      </Text>
                      <View style={styles.summaryRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto a las:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatTime(shift.openedAt)}
                        </Text>
                      </View>
                      <View style={styles.summaryRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Efectivo inicial:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatCurrency(shift.initialCash)}
                        </Text>
                      </View>
                      {shift.totalSales !== null && (
                        <View style={styles.summaryRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Ventas del turno:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.totalSales)}
                          </Text>
                        </View>
                      )}
                      {shift.expectedCash !== null && (
                        <View style={styles.summaryRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Efectivo esperado:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.expectedCash)}
                          </Text>
                        </View>
                      )}
                    </Card.Content>
                  </Card>
                  {}
                  <View style={styles.inputSection}>
                    <Text variant="titleMedium" style={styles.sectionTitle}>
                      Información de Cierre
                    </Text>
                    <TextInput
                      label="Efectivo final en caja"
                      value={finalCash}
                      onChangeText={handleFinalCashChange}
                      keyboardType="decimal-pad"
                      mode="outlined"
                      left={<TextInput.Affix text="$" />}
                      style={styles.input}
                      disabled={loading}
                      error={!!error}
                      placeholder="0.00"
                      outlineColor={
                        error ? theme.colors.error : theme.colors.outline
                      }
                      activeOutlineColor={
                        error ? theme.colors.error : theme.colors.primary
                      }
                    />
                    {difference !== null && (
                      <View
                        style={[
                          styles.differenceContainer,
                          difference < 0
                            ? styles.negativeDifference
                            : styles.positiveDifference,
                        ]}
                      >
                        <MaterialCommunityIcons
                          name={
                            difference >= 0 ? 'trending-up' : 'trending-down'
                          }
                          size={20}
                          color={difference >= 0 ? '#4CAF50' : '#FF5722'}
                        />
                        <Text
                          style={[
                            styles.differenceText,
                            { color: difference >= 0 ? '#4CAF50' : '#FF5722' },
                          ]}
                        >
                          {difference >= 0 ? 'Sobrante: ' : 'Faltante: '}
                          {formatCurrency(Math.abs(difference))}
                        </Text>
                      </View>
                    )}
                    <HelperText
                      type="error"
                      visible={!!error}
                      style={styles.errorText}
                    >
                      {error}
                    </HelperText>
                    <SpeechRecognitionInput
                      key="close-notes-input"
                      label="Notas de cierre (opcional)"
                      value={closeNotes}
                      onChangeText={setCloseNotes}
                      multiline
                      speechLang="es-MX"
                      placeholder="Ej: Observaciones del turno, incidencias..."
                      autoCapitalize="sentences"
                      autoCorrect={false}
                      disabled={loading}
                    />
                  </View>
                </View>
              )}
              {}
              <View style={styles.footer}>
                <Button
                  mode="text"
                  onPress={handleDismiss}
                  style={[styles.button, styles.cancelButton]}
                  labelStyle={styles.cancelButtonText}
                  disabled={loading}
                >
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleCloseShift}
                  style={[styles.button, styles.confirmButton]}
                  contentStyle={styles.confirmButtonContent}
                  labelStyle={styles.confirmButtonText}
                  loading={loading}
                  disabled={loading}
                  icon="stop-circle"
                >
                  Cerrar Turno
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
};
const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
    },
    scrollViewContent: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.m,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 8,
      },
      shadowOpacity: 0.25,
      shadowRadius: 16,
      elevation: 8,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surfaceVariant,
    },
    iconContainer: {
      width: 90,
      height: 90,
      borderRadius: 45,
      backgroundColor: theme.colors.surface,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      borderWidth: 3,
      borderColor: '#FF5722',
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 4,
      },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 4,
    },
    title: {
      color: theme.colors.onSurfaceVariant,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    summaryCard: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    value: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
    },
    highlight: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    inputSection: {
      marginTop: theme.spacing.s,
    },
    input: {
      backgroundColor: theme.colors.surface,
      marginBottom: theme.spacing.s,
    },
    differenceContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.s,
      gap: theme.spacing.s,
    },
    positiveDifference: {
      backgroundColor: 'rgba(76, 175, 80, 0.1)',
      borderWidth: 1,
      borderColor: '#4CAF50',
    },
    negativeDifference: {
      backgroundColor: 'rgba(255, 87, 34, 0.1)',
      borderWidth: 1,
      borderColor: '#FF5722',
    },
    differenceText: {
      fontWeight: '600',
    },
    errorText: {
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      borderBottomLeftRadius: theme.roundness * 3,
      borderBottomRightRadius: theme.roundness * 3,
    },
    button: {
      flex: 1,
    },
    cancelButton: {
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    cancelButtonText: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    confirmButton: {
      backgroundColor: '#FF5722',
      borderWidth: 2,
      borderColor: '#FF5722',
      borderRadius: theme.roundness * 2,
    },
    confirmButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    confirmButtonText: {
      color: '#FFFFFF',
      fontWeight: '600',
    },
  });

================
File: app/src/modules/orders/components/OpenShiftModal.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  TextInput as _RNTextInput,
  Platform,
  KeyboardAvoidingView,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Surface,
  Divider,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { shiftsService } from '@/services/shifts';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
interface OpenShiftModalProps {
  visible: boolean;
  onDismiss: () => void;
  onShiftOpened: () => void;
}
export const OpenShiftModal: React.FC<OpenShiftModalProps> = ({
  visible,
  onDismiss,
  onShiftOpened,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [initialCash, setInitialCash] = useState('');
  const [notes, setNotes] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const handleInitialCashChange = (text: string) => {
    // Permitir solo números y un punto decimal
    const cleaned = text.replace(/[^0-9.]/g, '');
    // Prevenir múltiples puntos decimales
    const parts = cleaned.split('.');
    if (parts.length > 2) return;
    // Limitar a 2 decimales
    if (parts[1] && parts[1].length > 2) {
      setInitialCash(parts[0] + '.' + parts[1].substring(0, 2));
    } else {
      setInitialCash(cleaned);
    }
  };
  const handleOpenShift = async () => {
    if (!initialCash) {
      setError('El monto inicial es requerido');
      return;
    }
    const cashAmount = parseFloat(initialCash);
    if (isNaN(cashAmount) || cashAmount < 0) {
      setError('Ingresa un monto válido');
      return;
    }
    setLoading(true);
    setError('');
    try {
      await shiftsService.openShift({
        initialCash: cashAmount,
        notes: notes || undefined,
      });
      showSnackbar({ message: 'Turno abierto exitosamente', type: 'success' });
      setInitialCash('');
      setNotes('');
      onShiftOpened();
      onDismiss();
    } catch (error: any) {
      const errorMessage =
        error.response?.data?.message || 'Error al abrir el turno';
      setError(errorMessage);
      showSnackbar({ message: errorMessage, type: 'error' });
    } finally {
      setLoading(false);
    }
  };
  const handleDismiss = () => {
    if (!loading) {
      setInitialCash('');
      setNotes('');
      setError('');
      onDismiss();
    }
  };
  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
        dismissable={!loading}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <ScrollView
            contentContainerStyle={styles.scrollViewContent}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          >
            <Surface style={styles.modal} elevation={3}>
              {}
              <View style={styles.header}>
                <View style={styles.iconContainer}>
                  <MaterialCommunityIcons
                    name="store-check"
                    size={48}
                    color={theme.colors.primary}
                  />
                </View>
                <Text variant="headlineMedium" style={styles.title}>
                  Apertura de Turno
                </Text>
                <Text variant="bodyLarge" style={styles.date}>
                  {todayFormatted}
                </Text>
              </View>
              <Divider style={styles.divider} />
              {}
              <View style={styles.content}>
                <View style={styles.infoCard}>
                  <MaterialCommunityIcons
                    name="information"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text variant="bodyMedium" style={styles.infoText}>
                    Registra el monto inicial para comenzar las operaciones del
                    turno.
                  </Text>
                </View>
                <View style={styles.inputSection}>
                  <Text variant="titleMedium" style={styles.sectionTitle}>
                    Información de Apertura
                  </Text>
                  <TextInput
                    label="Monto inicial en caja"
                    value={initialCash}
                    onChangeText={handleInitialCashChange}
                    keyboardType="decimal-pad"
                    mode="outlined"
                    left={<TextInput.Affix text="$" />}
                    style={styles.input}
                    disabled={loading}
                    error={!!error}
                    placeholder="0.00"
                    outlineColor={
                      error ? theme.colors.error : theme.colors.outline
                    }
                    activeOutlineColor={
                      error ? theme.colors.error : theme.colors.primary
                    }
                  />
                  <HelperText
                    type="error"
                    visible={!!error}
                    style={styles.errorText}
                  >
                    {error}
                  </HelperText>
                  <SpeechRecognitionInput
                    key="notes-input-shift"
                    label="Notas adicionales (opcional)"
                    value={notes}
                    onChangeText={setNotes}
                    multiline
                    speechLang="es-MX"
                    placeholder="Ej: Estado de la caja, observaciones..."
                    autoCapitalize="sentences"
                    autoCorrect={false}
                    disabled={loading}
                  />
                </View>
              </View>
              {}
              <View style={styles.footer}>
                <Button
                  mode="text"
                  onPress={handleDismiss}
                  style={[styles.button, styles.cancelButton]}
                  labelStyle={styles.cancelButtonText}
                  disabled={loading}
                >
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleOpenShift}
                  style={[styles.button, styles.confirmButton]}
                  contentStyle={styles.confirmButtonContent}
                  labelStyle={styles.confirmButtonText}
                  loading={loading}
                  disabled={loading}
                  icon="play-circle"
                >
                  Abrir Turno
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
};
const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
    },
    scrollViewContent: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 2,
      marginHorizontal: theme.spacing.m,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
    },
    iconContainer: {
      width: 80,
      height: 80,
      borderRadius: 40,
      backgroundColor: theme.colors.primaryContainer,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    title: {
      color: theme.colors.onSurface,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    infoCard: {
      flexDirection: 'row',
      backgroundColor: theme.colors.primaryContainer,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.l,
      gap: theme.spacing.s,
    },
    infoText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
      lineHeight: 20,
    },
    inputSection: {
      marginTop: theme.spacing.s,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    input: {
      backgroundColor: theme.colors.surface,
    },
    errorText: {
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
    },
    button: {
      flex: 1,
    },
    cancelButton: {
      borderColor: theme.colors.outline,
      borderWidth: 1,
    },
    cancelButtonText: {
      color: theme.colors.onSurfaceVariant,
    },
    confirmButton: {
      backgroundColor: theme.colors.primary,
      elevation: 0,
    },
    confirmButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    confirmButtonText: {
      color: theme.colors.onPrimary,
      fontWeight: '600',
    },
  });

================
File: app/src/modules/orders/components/ProductCustomizationModal.tsx
================
import React, { useState, useEffect, useMemo, useCallback, memo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  RadioButton,
  Divider,
  Appbar,
  TouchableRipple,
  IconButton,
  Card,
  Chip,
  Surface,
} from 'react-native-paper';
import { useForm, Controller, FieldValues } from 'react-hook-form';
import { useAppTheme } from '@/app/styles/theme';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import {
  FullMenuProduct as Product,
  ProductVariant,
  Modifier,
  FullMenuModifierGroup,
} from '../types/orders.types';
import { CartItemModifier, CartItem } from '../stores/useCartStore';
import { AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import type {
  PizzaCustomization,
  PizzaConfiguration,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import {
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import PizzaCustomizationSection from './PizzaCustomizationSection';
interface ProductCustomizationModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product;
  editingItem?: CartItem | null;
  onAddToCart: (
    product: Product,
    quantity: number,
    variantId?: string,
    modifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  onUpdateItem?: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
}
interface NotesFormData extends FieldValues {
  preparationNotes: string;
}
const ProductCustomizationModal = memo<ProductCustomizationModalProps>(
  ({ visible, onDismiss, product, editingItem, onAddToCart, onUpdateItem }) => {
    const theme = useAppTheme();
    const styles = useMemo(() => createStyles(theme), [theme]);
    const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
    const { control, reset, watch } = useForm<NotesFormData>({
      defaultValues: { preparationNotes: '' },
    });
    const watchedPreparationNotes = watch('preparationNotes');
    const [selectedVariantId, setSelectedVariantId] = useState<
      string | undefined
    >(
      product &&
        product.variants &&
        Array.isArray(product.variants) &&
        product.variants.length > 0
        ? product.variants[0].id
        : undefined,
    );
    const [selectedModifiersByGroup, setSelectedModifiersByGroup] = useState<
      Record<string, CartItemModifier[]>
    >({});
    const selectedModifiers = useMemo(() => {
      return Object.values(selectedModifiersByGroup).flat();
    }, [selectedModifiersByGroup]);
    const hasVariants = useMemo(
      () =>
        product?.variants &&
        Array.isArray(product.variants) &&
        product.variants.length > 0,
      [product?.variants],
    );
    const [quantity, setQuantity] = useState(1);
    const [showExitConfirmation, setShowExitConfirmation] = useState(false);
    const [hasChanges, setHasChanges] = useState(false);
    const [validationErrors, setValidationErrors] = useState<
      Record<string, string>
    >({});
    const [pizzaCustomizations, setPizzaCustomizations] = useState<
      PizzaCustomization[]
    >([]);
    const [pizzaConfiguration, setPizzaConfiguration] =
      useState<PizzaConfiguration | null>(null);
    const [selectedPizzaCustomizations, setSelectedPizzaCustomizations] =
      useState<SelectedPizzaCustomization[]>([]);
    const calculatePizzaExtraCost = useCallback(() => {
      if (!product.isPizza || !pizzaConfiguration) return 0;
      let totalToppingValue = 0;
      const addedCustomizations = selectedPizzaCustomizations.filter(
        (c) => c.action === CustomizationAction.ADD,
      );
      for (const selected of addedCustomizations) {
        const customization = pizzaCustomizations.find(
          (c) => c.id === selected.pizzaCustomizationId,
        );
        if (!customization) continue;
        if (selected.half === PizzaHalf.FULL) {
          totalToppingValue += customization.toppingValue;
        } else {
          totalToppingValue += customization.toppingValue / 2;
        }
      }
      if (totalToppingValue > pizzaConfiguration.includedToppings) {
        const extraToppings =
          totalToppingValue - pizzaConfiguration.includedToppings;
        return extraToppings * Number(pizzaConfiguration.extraToppingCost);
      }
      return 0;
    }, [
      product.isPizza,
      pizzaConfiguration,
      selectedPizzaCustomizations,
      pizzaCustomizations,
    ]);
    const checkForChanges = useCallback(() => {
      if (!editingItem) return false;
      if (quantity !== editingItem.quantity) return true;
      if (selectedVariantId !== editingItem.variantId) return true;
      if (watchedPreparationNotes !== (editingItem.preparationNotes || ''))
        return true;
      // Comparar modificadores
      const currentModifierIds = selectedModifiers.map((m) => m.id).sort();
      const originalModifierIds = editingItem.modifiers.map((m) => m.id).sort();
      if (currentModifierIds.length !== originalModifierIds.length) return true;
      for (let i = 0; i < currentModifierIds.length; i++) {
        if (currentModifierIds[i] !== originalModifierIds[i]) return true;
      }
      return false;
    }, [
      editingItem,
      quantity,
      selectedVariantId,
      watchedPreparationNotes,
      selectedModifiers,
    ]);
    useEffect(() => {
      if (!product) return;
      if (editingItem) {
        // Si estamos editando, usar los valores del item
        setSelectedVariantId(editingItem.variantId);
        setQuantity(editingItem.quantity);
        reset({ preparationNotes: editingItem.preparationNotes || '' });
        // Reconstruir los modificadores por grupo
        const modifiersByGroup: Record<string, CartItemModifier[]> = {};
        if (editingItem.modifiers && product.modifierGroups) {
          editingItem.modifiers.forEach((mod) => {
            // Encontrar a qué grupo pertenece este modificador
            const group = product.modifierGroups?.find((g) =>
              g.productModifiers?.some((pm) => pm.id === mod.id),
            );
            if (group) {
              if (!modifiersByGroup[group.id]) {
                modifiersByGroup[group.id] = [];
              }
              modifiersByGroup[group.id].push(mod);
            }
          });
        }
        setSelectedModifiersByGroup(modifiersByGroup);
      } else {
        // Si es un nuevo item, valores por defecto
        if (
          product.variants &&
          Array.isArray(product.variants) &&
          product.variants.length > 0
        ) {
          setSelectedVariantId(product.variants[0].id);
        } else {
          setSelectedVariantId(undefined);
        }
        // Aplicar modificadores por defecto
        const defaultModifiersByGroup: Record<string, CartItemModifier[]> = {};
        if (product.modifierGroups) {
          product.modifierGroups.forEach((group) => {
            const defaultModifiers: CartItemModifier[] = [];
            if (group.productModifiers) {
              group.productModifiers.forEach((modifier) => {
                if (modifier.isDefault && modifier.isActive) {
                  defaultModifiers.push({
                    id: modifier.id,
                    modifierGroupId: group.id,
                    name: modifier.name,
                    price: Number(modifier.price) || 0,
                  });
                }
              });
            }
            if (defaultModifiers.length > 0) {
              // Respetar el límite máximo de selecciones
              const maxSelections =
                group.maxSelections || defaultModifiers.length;
              defaultModifiersByGroup[group.id] = defaultModifiers.slice(
                0,
                maxSelections,
              );
            }
          });
        }
        setSelectedModifiersByGroup(defaultModifiersByGroup);
        setQuantity(1);
        reset({ preparationNotes: '' });
      }
    }, [product, editingItem, reset]);
    // Usar datos de pizza que ya vienen con el producto
    useEffect(() => {
      if (!product || !visible) return;
      // Si es una pizza, usar los datos que ya vienen con el producto
      if (product.isPizza) {
        if (product.pizzaConfiguration) {
          setPizzaConfiguration(product.pizzaConfiguration);
        }
        if (product.pizzaCustomizations) {
          setPizzaCustomizations(product.pizzaCustomizations);
        }
        // Si estamos editando, cargar las personalizaciones seleccionadas
        if (editingItem && editingItem.selectedPizzaCustomizations) {
          setSelectedPizzaCustomizations(
            editingItem.selectedPizzaCustomizations,
          );
        }
      }
    }, [product, visible, editingItem]);
    // Detectar cambios
    useEffect(() => {
      if (editingItem) {
        setHasChanges(checkForChanges());
      }
    }, [editingItem, checkForChanges]);
    // Validar en tiempo real
    useEffect(() => {
      const errors: Record<string, string> = {};
      if (product.modifierGroups) {
        product.modifierGroups.forEach((group) => {
          const selectedInGroup = selectedModifiersByGroup[group.id] || [];
          const selectedCount = selectedInGroup.length;
          const minRequired = Math.max(
            group.minSelections || 0,
            group.isRequired ? 1 : 0,
          );
          if (selectedCount < minRequired) {
            if (group.isRequired && minRequired === 1) {
              errors[group.id] = 'Requerido';
            } else {
              errors[group.id] = `Mínimo ${minRequired}`;
            }
          }
        });
      }
      setValidationErrors(errors);
    }, [product, selectedModifiersByGroup]);
    const handleVariantSelect = useCallback((variantId: string) => {
      setSelectedVariantId(variantId);
    }, []);
    const handleModifierToggle = (
      modifier: Modifier,
      group: FullMenuModifierGroup,
    ) => {
      const currentGroupModifiers = selectedModifiersByGroup[group.id] || [];
      const isSelected = currentGroupModifiers.some(
        (mod) => mod.id === modifier.id,
      );
      const updatedModifiersByGroup = { ...selectedModifiersByGroup };
      if (isSelected) {
        const newCount = currentGroupModifiers.length - 1;
        const minRequired = Math.max(
          group.minSelections || 0,
          group.isRequired ? 1 : 0,
        );
        if (newCount < minRequired) {
          showSnackbar({
            message: `No puedes deseleccionar. "${group.name}" requiere al menos ${minRequired} ${minRequired === 1 ? 'opción seleccionada' : 'opciones seleccionadas'}.`,
            type: 'warning',
          });
          return;
        }
        updatedModifiersByGroup[group.id] = currentGroupModifiers.filter(
          (mod) => mod.id !== modifier.id,
        );
      } else {
        const newModifier: CartItemModifier = {
          id: modifier.id,
          modifierGroupId: group.id,
          name: modifier.name,
          price: Number(modifier.price) || 0,
        };
        if (!group.allowMultipleSelections) {
          updatedModifiersByGroup[group.id] = [newModifier];
        } else {
          if (currentGroupModifiers.length < (group.maxSelections || 0)) {
            updatedModifiersByGroup[group.id] = [
              ...currentGroupModifiers,
              newModifier,
            ];
          } else {
            showSnackbar({
              message: `Solo puedes seleccionar hasta ${group.maxSelections || 0} opciones en ${group.name}`,
              type: 'warning',
            });
            return;
          }
        }
      }
      setSelectedModifiersByGroup(updatedModifiersByGroup);
    };
    const handleAddToCart = () => {
      if (product.modifierGroups) {
        for (const group of product.modifierGroups) {
          const selectedInGroup = selectedModifiersByGroup[group.id] || [];
          const selectedCount = selectedInGroup.length;
          if (
            group.isRequired ||
            (group.minSelections && group.minSelections > 0)
          ) {
            const minRequired = Math.max(
              group.minSelections || 0,
              group.isRequired ? 1 : 0,
            );
            if (selectedCount < minRequired) {
              let message = '';
              if (group.isRequired && minRequired === 1) {
                message = `"${group.name}" es requerido. Debes seleccionar al menos una opción.`;
              } else if (minRequired > 1) {
                message = `Debes seleccionar al menos ${minRequired} ${minRequired === 1 ? 'opción' : 'opciones'} en "${group.name}"`;
              } else {
                message = `Debes seleccionar al menos una opción en "${group.name}"`;
              }
              showSnackbar({
                message,
                type: 'error',
              });
              return;
            }
          }
          // Validar máximo de selecciones (esto ya se valida en handleModifierToggle, pero por si acaso)
          if (group.maxSelections && selectedCount > group.maxSelections) {
            showSnackbar({
              message: `No puedes seleccionar más de ${group.maxSelections} ${group.maxSelections === 1 ? 'opción' : 'opciones'} en "${group.name}"`,
              type: 'error',
            });
            return;
          }
        }
      }
      if (editingItem && onUpdateItem) {
        // Si estamos editando, actualizar el item existente
        const variant = product.variants?.find(
          (v) => v.id === selectedVariantId,
        );
        const unitPrice = variant
          ? Number(variant.price)
          : Number(product.price) || 0;
        onUpdateItem(
          editingItem.id,
          quantity,
          selectedModifiers,
          watchedPreparationNotes,
          selectedVariantId,
          variant?.name,
          unitPrice,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
      } else {
        // Si es un nuevo item, agregarlo al carrito
        onAddToCart(
          product,
          quantity,
          selectedVariantId,
          selectedModifiers,
          watchedPreparationNotes,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
      }
      onDismiss();
    };
    const increaseQuantity = useCallback(
      () => setQuantity((prev) => prev + 1),
      [],
    );
    const decreaseQuantity = useCallback(
      () => setQuantity((prev) => (prev > 1 ? prev - 1 : 1)),
      [],
    );
    const handleDismiss = useCallback(() => {
      if (editingItem && hasChanges) {
        setShowExitConfirmation(true);
      } else {
        onDismiss();
      }
    }, [editingItem, hasChanges, onDismiss]);
    const handleConfirmExit = useCallback(() => {
      setShowExitConfirmation(false);
      onDismiss();
    }, [onDismiss]);
    const handleCancelExit = useCallback(() => {
      setShowExitConfirmation(false);
    }, []);
    if (!product || !visible) {
      return null;
    }
    const selectedVariant = useMemo(
      () =>
        hasVariants
          ? product.variants.find(
              (variant: ProductVariant) => variant.id === selectedVariantId,
            )
          : undefined,
      [hasVariants, product?.variants, selectedVariantId],
    );
    const basePrice = selectedVariant
      ? Number(selectedVariant.price)
      : Number(product.price) || 0;
    const modifiersPrice = selectedModifiers.reduce(
      (sum, mod) => sum + Number(mod.price || 0),
      0,
    );
    const pizzaExtraCost = calculatePizzaExtraCost();
    const totalPrice = (basePrice + modifiersPrice + pizzaExtraCost) * quantity;
    if (!visible) {
      return null;
    }
    return (
      <>
        <Portal>
          <Modal
            visible={visible}
            onDismiss={handleDismiss}
            contentContainerStyle={styles.modalContent}
          >
            {/* Encabezado Refactorizado con Appbar */}
            <Appbar.Header style={styles.appBar} elevated>
              <Appbar.BackAction
                onPress={handleDismiss}
                color={theme.colors.onSurface}
              />
              <Appbar.Content
                title={product?.name || 'Producto'}
                titleStyle={styles.appBarTitle}
                style={styles.appBarContent}
              />
              {/* Espaciador si no hay acción a la derecha */}
              <View style={styles.appBarSpacer} />
            </Appbar.Header>
            <ScrollView
              style={styles.scrollView}
              contentContainerStyle={{ paddingBottom: 20 }}
              showsVerticalScrollIndicator={true}
              keyboardShouldPersistTaps="handled"
              nestedScrollEnabled={true}
            >
              {product.hasVariants &&
                product.variants &&
                Array.isArray(product.variants) &&
                product.variants.length > 0 && (
                  <Card style={styles.sectionCard}>
                    <Card.Content>
                      <View style={styles.sectionHeader}>
                        <Text style={styles.sectionTitle}>Variantes</Text>
                        <Chip mode="flat" compact style={styles.requiredChip}>
                          Requerido
                        </Chip>
                      </View>
                      <RadioButton.Group
                        onValueChange={(value) => handleVariantSelect(value)}
                        value={selectedVariantId || ''}
                      >
                        {product.variants.map((variant: ProductVariant) => (
                          <Surface
                            key={variant.id}
                            style={[
                              styles.variantSurface,
                              selectedVariantId === variant.id &&
                                styles.variantSurfaceSelected,
                              !variant.isActive &&
                                styles.inactiveVariantSurface,
                            ]}
                            elevation={
                              selectedVariantId === variant.id &&
                              variant.isActive
                                ? 2
                                : 0
                            }
                          >
                            <TouchableRipple
                              onPress={() =>
                                variant.isActive &&
                                handleVariantSelect(variant.id)
                              }
                              disabled={!variant.isActive}
                              style={styles.variantTouchable}
                            >
                              <View style={styles.variantRow}>
                                <RadioButton
                                  value={variant.id}
                                  status={
                                    selectedVariantId === variant.id
                                      ? 'checked'
                                      : 'unchecked'
                                  }
                                  onPress={() =>
                                    variant.isActive &&
                                    handleVariantSelect(variant.id)
                                  }
                                  disabled={!variant.isActive}
                                />
                                <Text
                                  style={[
                                    styles.variantName,
                                    !variant.isActive && styles.inactiveText,
                                  ]}
                                >
                                  {variant.name}
                                  {!variant.isActive && ' (No disponible)'}
                                </Text>
                                <Text
                                  style={[
                                    styles.variantPrice,
                                    !variant.isActive && styles.inactiveText,
                                  ]}
                                >
                                  ${Number(variant.price).toFixed(2)}
                                </Text>
                              </View>
                            </TouchableRipple>
                          </Surface>
                        ))}
                      </RadioButton.Group>
                    </Card.Content>
                  </Card>
                )}
              {/* Sección de Personalización de Pizza - Después de variantes */}
              {product.isPizza && (
                <PizzaCustomizationSection
                  pizzaCustomizations={pizzaCustomizations}
                  pizzaConfiguration={pizzaConfiguration}
                  selectedPizzaCustomizations={selectedPizzaCustomizations}
                  onCustomizationChange={setSelectedPizzaCustomizations}
                  loading={false}
                />
              )}
              {product.modifierGroups &&
                Array.isArray(product.modifierGroups) &&
                product.modifierGroups.length > 0 &&
                product.modifierGroups.map((group: FullMenuModifierGroup) => (
                  <Card key={group.id} style={styles.sectionCard}>
                    <Card.Content>
                      <View style={styles.sectionHeader}>
                        <View style={styles.groupTitleContainer}>
                          <Text style={styles.groupTitle}>{group.name}</Text>
                          <View style={styles.selectionInfo}>
                            {group.minSelections !== undefined &&
                              group.maxSelections !== undefined && (
                                <Text style={styles.selectionRules}>
                                  {(group.minSelections || 0) === 0 &&
                                  group.maxSelections === 1
                                    ? 'Hasta 1 opción'
                                    : (group.minSelections || 0) ===
                                        group.maxSelections
                                      ? `Elegir ${group.maxSelections}`
                                      : `${group.minSelections || 0}-${group.maxSelections} opciones`}
                                </Text>
                              )}
                            {group.allowMultipleSelections && (
                              <Text style={styles.selectedCount}>
                                (
                                {
                                  (selectedModifiersByGroup[group.id] || [])
                                    .length
                                }{' '}
                                seleccionadas)
                              </Text>
                            )}
                          </View>
                        </View>
                        <View style={styles.chipContainer}>
                          {validationErrors[group.id] && (
                            <Chip
                              mode="flat"
                              compact
                              style={styles.errorChip}
                              icon="alert-circle"
                            >
                              {validationErrors[group.id]}
                            </Chip>
                          )}
                          <Chip
                            mode="flat"
                            compact
                            style={
                              group.isRequired
                                ? styles.requiredChip
                                : styles.optionalChip
                            }
                          >
                            {group.isRequired ? 'Requerido' : 'Opcional'}
                          </Chip>
                        </View>
                      </View>
                      {group.allowMultipleSelections ? (
                        <View style={styles.modifiersContainer}>
                          {Array.isArray(group.productModifiers) &&
                            group.productModifiers.map((modifier: Modifier) => {
                              const groupModifiers =
                                selectedModifiersByGroup[group.id] || [];
                              const isSelected = groupModifiers.some(
                                (mod) => mod.id === modifier.id,
                              );
                              return (
                                <Surface
                                  key={modifier.id}
                                  style={[
                                    styles.modifierSurface,
                                    isSelected &&
                                      styles.modifierSurfaceSelected,
                                    !modifier.isActive &&
                                      styles.inactiveModifierSurface,
                                  ]}
                                  elevation={
                                    isSelected && modifier.isActive ? 1 : 0
                                  }
                                >
                                  <TouchableRipple
                                    onPress={() =>
                                      modifier.isActive &&
                                      handleModifierToggle(modifier, group)
                                    }
                                    disabled={!modifier.isActive}
                                    style={styles.modifierTouchable}
                                  >
                                    <View style={styles.modifierRow}>
                                      <RadioButton
                                        value={modifier.id}
                                        status={
                                          isSelected ? 'checked' : 'unchecked'
                                        }
                                        disabled={!modifier.isActive}
                                        onPress={() =>
                                          modifier.isActive &&
                                          handleModifierToggle(modifier, group)
                                        }
                                      />
                                      <Text
                                        style={[
                                          styles.modifierName,
                                          !modifier.isActive &&
                                            styles.inactiveText,
                                        ]}
                                      >
                                        {modifier.name}
                                        {!modifier.isActive &&
                                          ' (No disponible)'}
                                      </Text>
                                      {Number(modifier.price) > 0 && (
                                        <Text
                                          style={[
                                            styles.modifierPrice,
                                            !modifier.isActive &&
                                              styles.inactiveText,
                                          ]}
                                        >
                                          +${Number(modifier.price).toFixed(2)}
                                        </Text>
                                      )}
                                    </View>
                                  </TouchableRipple>
                                </Surface>
                              );
                            })}
                        </View>
                      ) : (
                        <RadioButton.Group
                          onValueChange={(value) => {
                            const modifier = group.productModifiers?.find(
                              (m: Modifier) => m.id === value,
                            );
                            if (modifier) {
                              handleModifierToggle(modifier, group);
                            }
                          }}
                          value={
                            selectedModifiersByGroup[group.id]?.[0]?.id || ''
                          }
                        >
                          <View style={styles.modifiersContainer}>
                            {Array.isArray(group.productModifiers) &&
                              group.productModifiers.map(
                                (modifier: Modifier) => {
                                  const isSelected =
                                    selectedModifiersByGroup[group.id]?.[0]
                                      ?.id === modifier.id;
                                  return (
                                    <Surface
                                      key={modifier.id}
                                      style={[
                                        styles.modifierSurface,
                                        isSelected &&
                                          styles.modifierSurfaceSelected,
                                        !modifier.isActive &&
                                          styles.inactiveModifierSurface,
                                      ]}
                                      elevation={
                                        isSelected && modifier.isActive ? 1 : 0
                                      }
                                    >
                                      <TouchableRipple
                                        onPress={() =>
                                          modifier.isActive &&
                                          handleModifierToggle(modifier, group)
                                        }
                                        disabled={!modifier.isActive}
                                        style={styles.modifierTouchable}
                                      >
                                        <View style={styles.modifierRow}>
                                          <RadioButton
                                            value={modifier.id}
                                            status={
                                              isSelected
                                                ? 'checked'
                                                : 'unchecked'
                                            }
                                            disabled={!modifier.isActive}
                                            onPress={() =>
                                              modifier.isActive &&
                                              handleModifierToggle(
                                                modifier,
                                                group,
                                              )
                                            }
                                          />
                                          <Text
                                            style={[
                                              styles.modifierName,
                                              !modifier.isActive &&
                                                styles.inactiveText,
                                            ]}
                                          >
                                            {modifier.name}
                                            {!modifier.isActive &&
                                              ' (No disponible)'}
                                          </Text>
                                          {Number(modifier.price) > 0 && (
                                            <Text
                                              style={[
                                                styles.modifierPrice,
                                                !modifier.isActive &&
                                                  styles.inactiveText,
                                              ]}
                                            >
                                              +$
                                              {Number(modifier.price).toFixed(
                                                2,
                                              )}
                                            </Text>
                                          )}
                                        </View>
                                      </TouchableRipple>
                                    </Surface>
                                  );
                                },
                              )}
                          </View>
                        </RadioButton.Group>
                      )}
                    </Card.Content>
                  </Card>
                ))}
              {}
              <Card style={styles.sectionCard}>
                <Card.Content>
                  <Text style={styles.sectionTitle}>Cantidad</Text>
                  <View style={styles.quantityContainer}>
                    <IconButton
                      icon="minus-circle-outline"
                      size={36}
                      onPress={decreaseQuantity}
                      style={[
                        styles.quantityIconButton,
                        quantity <= 1 && styles.quantityIconButtonDisabled,
                      ]}
                      iconColor={
                        quantity <= 1
                          ? theme.colors.onSurfaceDisabled
                          : theme.colors.primary
                      }
                      disabled={quantity <= 1}
                    />
                    <Surface style={styles.quantityBadge} elevation={1}>
                      <Text style={styles.quantityText}>{quantity}</Text>
                    </Surface>
                    <IconButton
                      icon="plus-circle-outline"
                      size={36}
                      onPress={increaseQuantity}
                      style={styles.quantityIconButton}
                      iconColor={theme.colors.primary}
                    />
                  </View>
                </Card.Content>
              </Card>
              {}
              <Card style={styles.sectionCard}>
                <Card.Content>
                  <Controller
                    control={control}
                    name="preparationNotes"
                    render={({ field: { onChange, value } }) => (
                      <SpeechRecognitionInput
                        key="preparation-notes-input"
                        label="Notas de Preparación"
                        value={value}
                        onChangeText={onChange}
                        multiline
                        numberOfLines={2}
                        style={styles.preparationInput}
                        speechLang="es-MX"
                      />
                    )}
                  />
                </Card.Content>
              </Card>
              {}
              <Card style={[styles.sectionCard, styles.summaryCard]}>
                <Card.Content>
                  <Text style={styles.sectionTitle}>Resumen del pedido</Text>
                  <View style={styles.summaryContent}>
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Precio base:</Text>
                      <Text style={styles.summaryValue}>
                        ${basePrice.toFixed(2)}
                      </Text>
                    </View>
                    {selectedModifiers.length > 0 && (
                      <View style={styles.summaryRow}>
                        <Text style={styles.summaryLabel}>Adicionales:</Text>
                        <Text style={styles.summaryValue}>
                          +${modifiersPrice.toFixed(2)}
                        </Text>
                      </View>
                    )}
                    {pizzaExtraCost > 0 && (
                      <View style={styles.summaryRow}>
                        <Text style={styles.summaryLabel}>Toppings extra:</Text>
                        <Text style={styles.summaryValue}>
                          +${pizzaExtraCost.toFixed(2)}
                        </Text>
                      </View>
                    )}
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Cantidad:</Text>
                      <Text style={styles.summaryValue}>×{quantity}</Text>
                    </View>
                    <Divider style={styles.summaryDivider} />
                    <View style={[styles.summaryRow, styles.totalRow]}>
                      <Text style={styles.totalLabel}>Total:</Text>
                      <Text style={styles.totalValue}>
                        ${totalPrice.toFixed(2)}
                      </Text>
                    </View>
                  </View>
                </Card.Content>
              </Card>
            </ScrollView>
            {}
            <View style={styles.footer}>
              <Button
                mode="contained"
                onPress={handleAddToCart}
                style={styles.confirmButton}
                icon={editingItem ? 'cart-check' : 'cart-plus'}
              >
                {editingItem
                  ? `Actualizar Item - $${totalPrice.toFixed(2)}`
                  : `Agregar al Carrito - $${totalPrice.toFixed(2)}`}
              </Button>
            </View>
          </Modal>
        </Portal>
        {}
        <Portal>
          <ConfirmationModal
            visible={showExitConfirmation}
            onDismiss={handleCancelExit}
            onConfirm={handleConfirmExit}
            title="¿Descartar cambios?"
            message="Tienes cambios sin guardar. ¿Estás seguro de que quieres salir?"
            confirmText="Descartar"
            cancelText="Cancelar"
            confirmButtonColor={theme.colors.error}
          />
        </Portal>
      </>
    );
  },
);
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '100%',
      height: '100%',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0,
    },
    appBar: {
      backgroundColor: theme.colors.elevation.level2,
    },
    appBarTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
    },
    appBarContent: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    appBarSpacer: {
      width: 48,
    },
    modifierGroup: {
      marginBottom: theme.spacing.s,
    },
    modifierGroupHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    groupTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    groupDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    requiredText: {
      fontSize: 12,
      color: theme.colors.error,
      fontWeight: '500',
    },
    optionalText: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '500',
    },
    selectionRules: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.xs,
      fontStyle: 'italic',
    },
    selectionInfo: {
      marginTop: 2,
    },
    selectedCount: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '500',
      marginTop: 2,
    },
    productImage: {
      height: 150,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.m,
    },
    imagePlaceholder: {
      backgroundColor: theme.colors.surfaceVariant,
      justifyContent: 'center',
      alignItems: 'center',
    },
    placeholderText: {
      fontSize: 50,
      color: theme.colors.onSurfaceVariant,
    },
    scrollView: {
      flex: 1,
      padding: theme.spacing.m,
    },
    section: {
      marginBottom: theme.spacing.s,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    sectionCard: {
      marginBottom: theme.spacing.m,
      borderRadius: theme.roundness * 2,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    groupTitleContainer: {
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
      marginLeft: theme.spacing.s,
    },
    optionalChip: {
      backgroundColor: theme.colors.secondaryContainer,
      marginLeft: theme.spacing.s,
    },
    chipContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    errorChip: {
      backgroundColor: theme.colors.errorContainer,
      marginRight: theme.spacing.xs,
    },
    variantSurface: {
      marginBottom: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    variantSurfaceSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    variantTouchable: {
      padding: 0,
    },
    variantRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    variantName: {
      flex: 1,
      fontSize: 16,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    modifiersContainer: {
      marginTop: theme.spacing.xs,
    },
    modifierSurface: {
      marginBottom: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    modifierSurfaceSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    modifierTouchable: {
      padding: 0,
    },
    modifierRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    modifierName: {
      flex: 1,
      fontSize: 15,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    quantityBadge: {
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.primaryContainer,
    },
    quantityIconButtonDisabled: {
      opacity: 0.5,
    },
    summaryCard: {
      backgroundColor: theme.dark
        ? theme.colors.elevation.level3
        : theme.colors.secondaryContainer,
      borderWidth: theme.dark ? 1 : 0,
      borderColor: theme.dark ? theme.colors.outlineVariant : undefined,
    },
    summaryContent: {
      marginTop: theme.spacing.xs,
    },
    summaryLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    summaryValue: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    summaryDivider: {
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.onSurfaceVariant,
      opacity: 0.3,
    },
    optionContainer: {
      marginBottom: 2,
    },
    optionTouchable: {
      paddingVertical: 4,
    },
    optionRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 8,
      paddingVertical: 8,
    },
    optionContent: {
      flex: 1,
      justifyContent: 'center',
    },
    checkbox: {
      marginRight: 8,
    },
    optionDivider: {
      height: 1,
      backgroundColor: theme.colors.outlineVariant,
    },
    radioItem: {
      flex: 1,
      paddingVertical: 4,
    },
    modifierTitle: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    variantPrice: {
      fontSize: 14,
      fontWeight: 'bold',
      color: theme.colors.onSurfaceVariant,
      marginLeft: 'auto',
      marginRight: 8,
    },
    inactiveVariantSurface: {
      opacity: 0.6,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    inactiveModifierSurface: {
      opacity: 0.6,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    inactiveText: {
      color: theme.colors.onSurfaceDisabled,
      textDecorationLine: 'line-through',
    },
    modifierPrice: {
      fontSize: 14,
      fontWeight: 'bold',
      color: theme.colors.onSurfaceVariant,
      marginLeft: 'auto',
      paddingHorizontal: 8,
    },
    quantityContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      marginVertical: theme.spacing.s,
    },
    quantityIconButton: {
      margin: 0,
      borderRadius: 18,
    },
    quantityText: {
      fontSize: 18,
      fontWeight: 'bold',
      minWidth: 40,
      textAlign: 'center',
      marginHorizontal: theme.spacing.s,
      color: theme.colors.onSurface,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
    },
    totalRow: {
      marginTop: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingTop: theme.spacing.s,
    },
    totalLabel: {
      fontWeight: 'bold',
      fontSize: 18,
      color: theme.colors.onSurface,
    },
    totalValue: {
      fontWeight: 'bold',
      fontSize: 18,
      color: theme.colors.primary,
    },
    footer: {
      padding: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    },
    confirmButton: {
      paddingVertical: theme.spacing.s,
    },
    preparationInput: {
      marginVertical: theme.spacing.xs,
      textAlignVertical: 'center',
    },
    divider: {
      marginVertical: theme.spacing.s,
      backgroundColor: theme.colors.outlineVariant,
    },
  });
ProductCustomizationModal.displayName = 'ProductCustomizationModal';
export default ProductCustomizationModal;

================
File: app/src/modules/orders/components/ShiftStatusBanner.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Button, ActivityIndicator, Card } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import type { Shift } from '@/services/shifts';
interface ShiftStatusBannerProps {
  shift: Shift | null;
  loading: boolean;
  onOpenShift: () => void;
  canOpenShift: boolean;
}
export const ShiftStatusBanner: React.FC<ShiftStatusBannerProps> = ({
  shift,
  loading,
  onOpenShift,
  canOpenShift,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="small" />
      </View>
    );
  }
  if (!shift || shift.status !== 'OPEN') {
    return (
      <Card style={styles.statusCard} mode="elevated">
        <Card.Content style={styles.closedShiftContent}>
          <View style={styles.iconContainer}>
            <MaterialCommunityIcons
              name="store-clock"
              size={64}
              color={theme.colors.primary}
            />
          </View>
          <Text variant="headlineSmall" style={styles.closedTitle}>
            {canOpenShift ? '¡Bienvenido!' : 'Turno Cerrado'}
          </Text>
          <Text variant="bodyLarge" style={styles.closedDescription}>
            {canOpenShift
              ? 'Para comenzar a operar, necesitas abrir el turno.'
              : 'El restaurante aún no ha abierto operaciones.'}
          </Text>
          {canOpenShift && (
            <View style={styles.adminInfo}>
              <MaterialCommunityIcons
                name="shield-crown"
                size={20}
                color={theme.colors.primary}
              />
              <Text variant="labelMedium" style={styles.adminText}>
                Como administrador, puedes iniciar las operaciones del turno
              </Text>
            </View>
          )}
          {canOpenShift && (
            <Button
              mode="contained"
              onPress={onOpenShift}
              style={styles.openShiftButton}
              icon="play-circle"
              contentStyle={styles.openShiftButtonContent}
            >
              Abrir Turno
            </Button>
          )}
          {!canOpenShift && (
            <View style={styles.contactInfo}>
              <MaterialCommunityIcons
                name="information"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
              <Text variant="bodyMedium" style={styles.contactText}>
                Contacta a tu administrador o gerente para iniciar operaciones
              </Text>
            </View>
          )}
        </Card.Content>
      </Card>
    );
  }
  return (
    <Card style={styles.openStatusCard} mode="elevated">
      <Card.Content>
        <View style={styles.statusHeader}>
          <View style={styles.openIconContainer}>
            <MaterialCommunityIcons
              name="store-check"
              size={28}
              color={theme.colors.primary}
            />
          </View>
          <View style={styles.statusHeaderText}>
            <Text variant="titleMedium" style={styles.statusTitle}>
              Turno Activo
            </Text>
            <Text variant="labelMedium" style={styles.statusSubtitle}>
              {format(new Date(shift.date), "EEEE, d 'de' MMMM", {
                locale: es,
              })}
            </Text>
          </View>
        </View>
        <View style={styles.statusInfoGrid}>
          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="counter"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Turno Global
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              #{shift.globalShiftNumber}
            </Text>
          </View>
          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="calendar-today"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Turno de Hoy
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              #{shift.shiftNumber}
            </Text>
          </View>
          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="account-clock"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Abierto desde
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              {format(new Date(shift.openedAt), 'HH:mm', {
                locale: es,
              })}
            </Text>
          </View>
        </View>
        <View style={styles.openedByInfo}>
          <MaterialCommunityIcons
            name="account-circle"
            size={16}
            color={theme.colors.onSurfaceVariant}
          />
          <Text variant="bodySmall" style={styles.openedByText}>
            Abierto por {shift.openedBy.firstName} {shift.openedBy.lastName}
          </Text>
        </View>
      </Card.Content>
    </Card>
  );
};
const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    loadingContainer: {
      padding: theme.spacing.m,
      alignItems: 'center',
    },
    statusCard: {
      margin: theme.spacing.m,
      marginBottom: theme.spacing.l,
      backgroundColor: theme.colors.surface,
      elevation: 4,
    },
    closedShiftContent: {
      alignItems: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
    },
    iconContainer: {
      marginBottom: theme.spacing.l,
      padding: theme.spacing.m,
      borderRadius: 100,
      backgroundColor: theme.colors.primaryContainer,
    },
    closedTitle: {
      color: theme.colors.onSurface,
      fontWeight: '700',
      marginBottom: theme.spacing.s,
      textAlign: 'center',
    },
    closedDescription: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: theme.spacing.l,
      paddingHorizontal: theme.spacing.m,
    },
    adminInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      marginBottom: theme.spacing.l,
    },
    adminText: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '500',
    },
    openShiftButton: {
      marginTop: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    openShiftButtonContent: {
      paddingVertical: theme.spacing.s,
    },
    contactInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      backgroundColor: theme.colors.surfaceVariant,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.m,
    },
    contactText: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    openStatusCard: {
      margin: theme.spacing.m,
      marginBottom: theme.spacing.l,
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    statusHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
      marginBottom: theme.spacing.l,
    },
    openIconContainer: {
      padding: theme.spacing.s,
      borderRadius: 50,
      backgroundColor: theme.colors.primaryContainer,
    },
    statusHeaderText: {
      flex: 1,
    },
    statusTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    statusSubtitle: {
      color: theme.colors.onSurfaceVariant,
      textTransform: 'capitalize',
    },
    statusInfoGrid: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.m,
    },
    infoCard: {
      flex: 1,
      backgroundColor: theme.colors.surfaceVariant,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    infoCardLabel: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    infoCardValue: {
      color: theme.colors.primary,
      fontWeight: '700',
      textAlign: 'center',
    },
    openedByInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      paddingTop: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    openedByText: {
      color: theme.colors.onSurfaceVariant,
    },
  });

================
File: app/src/modules/preparationScreens/components/ProductSelectionModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Checkbox,
  Button,
  Searchbar,
  Divider,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from 'react-native-paper';
interface Product {
  id: string;
  name: string;
  photo: any;
  price: string | number | null | undefined;
  isAssociated: boolean;
  currentPreparationScreenId: string | null;
}
interface Subcategory {
  id: string;
  name: string;
  photo: any;
  products: Product[];
}
interface Category {
  id: string;
  name: string;
  photo: any;
  subcategories: Subcategory[];
}
interface MenuData {
  screenId: string;
  screenName: string;
  menu: Category[];
  screenAssignments?: Record<string, string>;
}
interface ProductSelectionModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSave: (productIds: string[]) => void;
  screenId: string;
  menuData?: MenuData;
  loading?: boolean;
}
export const ProductSelectionModal: React.FC<ProductSelectionModalProps> = ({
  visible,
  onDismiss,
  onSave,
  screenId,
  menuData,
  loading = false,
}) => {
  const theme = useTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedProducts, setSelectedProducts] = useState<Set<string>>(
    new Set(),
  );
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set(),
  );
  const [expandedSubcategories, setExpandedSubcategories] = useState<
    Set<string>
  >(new Set());
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [conflictingProducts, setConflictingProducts] = useState<
    Array<{ id: string; name: string; currentScreen: string }>
  >([]);
  // Inicializar productos seleccionados
  useEffect(() => {
    if (menuData) {
      const associatedProducts = new Set<string>();
      menuData.menu.forEach((category) => {
        category.subcategories.forEach((subcategory) => {
          subcategory.products.forEach((product) => {
            if (product.isAssociated) {
              associatedProducts.add(product.id);
            }
          });
        });
      });
      setSelectedProducts(associatedProducts);
    }
  }, [menuData]);
  // Crear mapeo de productos a nombres de pantalla para el mensaje de conflicto
  const getScreenNameForProduct = (productId: string): string => {
    // Primero intentar obtener el nombre desde screenAssignments
    if (menuData?.screenAssignments && menuData.screenAssignments[productId]) {
      return menuData.screenAssignments[productId];
    }
    // Si no está disponible, usar un nombre genérico
    return 'otra pantalla de preparación';
  };
  const filteredMenu = useMemo(() => {
    if (!menuData || !searchQuery) return menuData?.menu || [];
    const query = searchQuery.toLowerCase();
    return menuData.menu
      .map((category) => ({
        ...category,
        subcategories: category.subcategories
          .map((subcategory) => ({
            ...subcategory,
            products: subcategory.products.filter((product) =>
              product.name.toLowerCase().includes(query),
            ),
          }))
          .filter((subcategory) => subcategory.products.length > 0),
      }))
      .filter((category) => category.subcategories.length > 0);
  }, [menuData, searchQuery]);
  const toggleCategory = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };
  const toggleSubcategory = (subcategoryId: string) => {
    const newExpanded = new Set(expandedSubcategories);
    if (newExpanded.has(subcategoryId)) {
      newExpanded.delete(subcategoryId);
    } else {
      newExpanded.add(subcategoryId);
    }
    setExpandedSubcategories(newExpanded);
  };
  const toggleProduct = (productId: string) => {
    const newSelected = new Set(selectedProducts);
    if (newSelected.has(productId)) {
      newSelected.delete(productId);
    } else {
      newSelected.add(productId);
    }
    setSelectedProducts(newSelected);
  };
  const toggleAllInCategory = (category: Category) => {
    const newSelected = new Set(selectedProducts);
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );
    const allSelected = categoryProducts.every((id) => newSelected.has(id));
    if (allSelected) {
      categoryProducts.forEach((id) => newSelected.delete(id));
    } else {
      categoryProducts.forEach((id) => newSelected.add(id));
    }
    setSelectedProducts(newSelected);
  };
  const toggleAllInSubcategory = (subcategory: Subcategory) => {
    const newSelected = new Set(selectedProducts);
    const subcategoryProducts = subcategory.products.map((p) => p.id);
    const allSelected = subcategoryProducts.every((id) => newSelected.has(id));
    if (allSelected) {
      subcategoryProducts.forEach((id) => newSelected.delete(id));
    } else {
      subcategoryProducts.forEach((id) => newSelected.add(id));
    }
    setSelectedProducts(newSelected);
  };
  const isCategoryPartiallySelected = (category: Category) => {
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );
    const selectedCount = categoryProducts.filter((id) =>
      selectedProducts.has(id),
    ).length;
    return selectedCount > 0 && selectedCount < categoryProducts.length;
  };
  const isCategoryFullySelected = (category: Category) => {
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );
    return (
      categoryProducts.length > 0 &&
      categoryProducts.every((id) => selectedProducts.has(id))
    );
  };
  const isSubcategoryPartiallySelected = (subcategory: Subcategory) => {
    const selectedCount = subcategory.products.filter((p) =>
      selectedProducts.has(p.id),
    ).length;
    return selectedCount > 0 && selectedCount < subcategory.products.length;
  };
  const isSubcategoryFullySelected = (subcategory: Subcategory) => {
    return (
      subcategory.products.length > 0 &&
      subcategory.products.every((p) => selectedProducts.has(p.id))
    );
  };
  const handleSave = () => {
    const conflicts: Array<{
      id: string;
      name: string;
      currentScreen: string;
    }> = [];
    if (menuData) {
      menuData.menu.forEach((category) => {
        category.subcategories.forEach((subcategory) => {
          subcategory.products.forEach((product) => {
            if (
              selectedProducts.has(product.id) &&
              product.currentPreparationScreenId &&
              product.currentPreparationScreenId !== screenId
            ) {
              const screenName = getScreenNameForProduct(product.id);
              conflicts.push({
                id: product.id,
                name: product.name,
                currentScreen: screenName,
              });
            }
          });
        });
      });
    }
    if (conflicts.length > 0) {
      setConflictingProducts(conflicts);
      setShowConfirmDialog(true);
    } else {
      onSave(Array.from(selectedProducts));
    }
  };
  const handleConfirmSave = () => {
    setShowConfirmDialog(false);
    onSave(Array.from(selectedProducts));
  };
  const handleCancelSave = () => {
    setShowConfirmDialog(false);
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContainer,
          { backgroundColor: theme.colors.surface },
        ]}
      >
        <View style={styles.header}>
          <Text variant="headlineSmall">Seleccionar Productos</Text>
        </View>
        <Searchbar
          placeholder="Buscar productos..."
          onChangeText={setSearchQuery}
          value={searchQuery}
          style={styles.searchBar}
        />
        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
          </View>
        ) : (
          <ScrollView
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
          >
            {filteredMenu.map((category) => (
              <View key={category.id} style={styles.categoryContainer}>
                <TouchableOpacity
                  style={styles.categoryHeader}
                  onPress={() => toggleCategory(category.id)}
                >
                  <View style={styles.categoryTitleContainer}>
                    <IconButton
                      icon={
                        expandedCategories.has(category.id)
                          ? 'chevron-down'
                          : 'chevron-right'
                      }
                      size={20}
                    />
                    <Text variant="titleMedium" style={styles.categoryTitle}>
                      {category.name}
                    </Text>
                  </View>
                  <Checkbox.Android
                    status={
                      isCategoryFullySelected(category)
                        ? 'checked'
                        : isCategoryPartiallySelected(category)
                          ? 'indeterminate'
                          : 'unchecked'
                    }
                    onPress={() => toggleAllInCategory(category)}
                  />
                </TouchableOpacity>
                {expandedCategories.has(category.id) && (
                  <View style={styles.subcategoriesContainer}>
                    {category.subcategories.map((subcategory) => (
                      <View
                        key={subcategory.id}
                        style={styles.subcategoryContainer}
                      >
                        <TouchableOpacity
                          style={styles.subcategoryHeader}
                          onPress={() => toggleSubcategory(subcategory.id)}
                        >
                          <View style={styles.subcategoryTitleContainer}>
                            <IconButton
                              icon={
                                expandedSubcategories.has(subcategory.id)
                                  ? 'chevron-down'
                                  : 'chevron-right'
                              }
                              size={16}
                            />
                            <Text
                              variant="titleSmall"
                              style={styles.subcategoryTitle}
                            >
                              {subcategory.name}
                            </Text>
                          </View>
                          <Checkbox.Android
                            status={
                              isSubcategoryFullySelected(subcategory)
                                ? 'checked'
                                : isSubcategoryPartiallySelected(subcategory)
                                  ? 'indeterminate'
                                  : 'unchecked'
                            }
                            onPress={() => toggleAllInSubcategory(subcategory)}
                          />
                        </TouchableOpacity>
                        {expandedSubcategories.has(subcategory.id) && (
                          <View style={styles.productsContainer}>
                            {subcategory.products.map((product) => (
                              <TouchableOpacity
                                key={product.id}
                                style={styles.productItem}
                                onPress={() => toggleProduct(product.id)}
                              >
                                <View style={styles.productInfo}>
                                  <Text variant="bodyMedium">
                                    {product.name}
                                  </Text>
                                  {product.currentPreparationScreenId &&
                                    product.currentPreparationScreenId !==
                                      screenId && (
                                      <View style={styles.warningContainer}>
                                        <MaterialCommunityIcons
                                          name="alert"
                                          size={12}
                                          color={theme.colors.error}
                                        />
                                        <Text
                                          variant="bodySmall"
                                          style={[
                                            styles.warningText,
                                            { color: theme.colors.error },
                                          ]}
                                        >
                                          Asignado a otra pantalla
                                        </Text>
                                      </View>
                                    )}
                                </View>
                                <Checkbox.Android
                                  status={
                                    selectedProducts.has(product.id)
                                      ? 'checked'
                                      : 'unchecked'
                                  }
                                  onPress={() => toggleProduct(product.id)}
                                />
                              </TouchableOpacity>
                            ))}
                          </View>
                        )}
                      </View>
                    ))}
                  </View>
                )}
                <Divider style={styles.divider} />
              </View>
            ))}
          </ScrollView>
        )}
        <View style={styles.actions}>
          <Button mode="outlined" onPress={onDismiss}>
            Cancelar
          </Button>
          <Button mode="contained" onPress={handleSave} disabled={loading}>
            Guardar
          </Button>
        </View>
      </Modal>
      {}
      <Modal
        visible={showConfirmDialog}
        onDismiss={handleCancelSave}
        contentContainerStyle={{
          backgroundColor: theme.colors.surface,
          margin: 20,
          borderRadius: 16,
          maxHeight: '75%',
          elevation: 8,
        }}
      >
        {}
        <View
          style={{
            flexDirection: 'row',
            alignItems: 'center',
            padding: 20,
            paddingBottom: 16,
            borderBottomWidth: 1,
            borderBottomColor: theme.colors.surfaceVariant,
          }}
        >
          <View
            style={{
              width: 40,
              height: 40,
              borderRadius: 20,
              backgroundColor: theme.colors.errorContainer,
              justifyContent: 'center',
              alignItems: 'center',
              marginRight: 12,
            }}
          >
            <MaterialCommunityIcons
              name="alert"
              size={24}
              color={theme.colors.error}
            />
          </View>
          <Text variant="headlineSmall" style={{ flex: 1 }}>
            Reasignar Productos
          </Text>
        </View>
        {}
        <View style={{ paddingHorizontal: 20, paddingTop: 16 }}>
          <Text
            variant="bodyLarge"
            style={{
              color: theme.colors.onSurfaceVariant,
            }}
          >
            {conflictingProducts.length === 1
              ? 'El siguiente producto será reasignado:'
              : `Los siguientes ${conflictingProducts.length} productos serán reasignados:`}
          </Text>
        </View>
        {}
        <ScrollView
          style={{
            maxHeight: 250,
            marginTop: 16,
            marginHorizontal: 20,
          }}
          showsVerticalScrollIndicator={true}
        >
          {conflictingProducts.map((product, _index) => (
            <View
              key={product.id}
              style={{
                paddingVertical: 14,
                paddingHorizontal: 16,
                backgroundColor: theme.colors.surfaceVariant,
                borderRadius: 12,
                marginBottom: 8,
                borderLeftWidth: 4,
                borderLeftColor: theme.colors.error,
              }}
            >
              <Text
                variant="bodyLarge"
                style={{
                  fontWeight: '600',
                  color: theme.colors.onSurface,
                  marginBottom: 8,
                }}
              >
                {product.name}
              </Text>
              <View
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor: theme.colors.surface,
                  padding: 8,
                  borderRadius: 8,
                }}
              >
                <View style={{ flex: 1, alignItems: 'center' }}>
                  <Text
                    variant="labelSmall"
                    style={{
                      color: theme.colors.onSurfaceVariant,
                      marginBottom: 2,
                    }}
                  >
                    Desde
                  </Text>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.error,
                      fontWeight: '500',
                    }}
                  >
                    {product.currentScreen}
                  </Text>
                </View>
                <MaterialCommunityIcons
                  name="arrow-right"
                  size={20}
                  color={theme.colors.primary}
                  style={{ marginHorizontal: 8 }}
                />
                <View style={{ flex: 1, alignItems: 'center' }}>
                  <Text
                    variant="labelSmall"
                    style={{
                      color: theme.colors.onSurfaceVariant,
                      marginBottom: 2,
                    }}
                  >
                    Hacia
                  </Text>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '500',
                    }}
                  >
                    {menuData?.screenName || 'Esta pantalla'}
                  </Text>
                </View>
              </View>
            </View>
          ))}
        </ScrollView>
        {}
        <View
          style={{
            margin: 20,
            marginTop: 16,
            marginBottom: 0,
            padding: 16,
            backgroundColor: theme.colors.secondaryContainer,
            borderRadius: 12,
            flexDirection: 'row',
            alignItems: 'center',
          }}
        >
          <MaterialCommunityIcons
            name="information"
            size={20}
            color={theme.colors.onSecondaryContainer}
            style={{ marginRight: 12 }}
          />
          <Text
            variant="bodySmall"
            style={{
              color: theme.colors.onSecondaryContainer,
              flex: 1,
            }}
          >
            Los productos serán removidos automáticamente de sus pantallas
            actuales al confirmar.
          </Text>
        </View>
        {}
        <View
          style={{
            flexDirection: 'row',
            justifyContent: 'center',
            alignItems: 'center',
            padding: 20,
            paddingTop: 16,
            gap: 16,
            borderTopWidth: 1,
            borderTopColor: theme.colors.surfaceVariant,
            marginTop: 16,
          }}
        >
          <Button
            onPress={handleCancelSave}
            mode="outlined"
            style={{
              flex: 1,
              maxWidth: 150,
              borderColor: theme.colors.outline,
            }}
            contentStyle={{ paddingVertical: 4 }}
          >
            Cancelar
          </Button>
          <Button
            onPress={handleConfirmSave}
            mode="contained"
            buttonColor={theme.colors.error}
            icon="check-circle"
            style={{
              flex: 1,
              maxWidth: 150,
            }}
            contentStyle={{ paddingVertical: 4 }}
          >
            Reasignar
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};
const styles = StyleSheet.create({
  modalContainer: {
    margin: 20,
    padding: 20,
    borderRadius: 8,
    maxHeight: '90%',
  },
  header: {
    marginBottom: 16,
  },
  searchBar: {
    marginBottom: 16,
  },
  scrollView: {
    maxHeight: 400,
  },
  loadingContainer: {
    height: 200,
    justifyContent: 'center',
    alignItems: 'center',
  },
  categoryContainer: {
    marginBottom: 8,
  },
  categoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
  },
  categoryTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  categoryTitle: {
    fontWeight: 'bold',
  },
  subcategoriesContainer: {
    paddingLeft: 20,
  },
  subcategoryContainer: {
    marginBottom: 4,
  },
  subcategoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  subcategoryTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  subcategoryTitle: {
    fontWeight: '600',
  },
  productsContainer: {
    paddingLeft: 20,
  },
  productItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    paddingLeft: 16,
  },
  productInfo: {
    flex: 1,
  },
  warningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 2,
  },
  warningText: {
    marginLeft: 4,
    fontSize: 11,
  },
  divider: {
    marginTop: 8,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
});

================
File: app/src/modules/preparationScreens/hooks/usePreparationScreensQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as preparationScreenService from '../services/preparationScreenService';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  FindAllPreparationScreensDto,
} from '../schema/preparationScreen.schema';
import { BaseListQuery } from '../../../app/types/query.types';
import { PaginatedResponse } from '../../../app/types/api.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
const preparationScreensQueryKeys = {
  all: ['preparationScreens'] as const,
  lists: () => [...preparationScreensQueryKeys.all, 'list'] as const,
  list: (filters: FindAllPreparationScreensDto & BaseListQuery) =>
    [...preparationScreensQueryKeys.lists(), filters] as const,
  details: () => [...preparationScreensQueryKeys.all, 'detail'] as const,
  detail: (id: string) =>
    [...preparationScreensQueryKeys.details(), id] as const,
  products: (id: string) =>
    [...preparationScreensQueryKeys.detail(id), 'products'] as const,
  menuWithAssociations: (id: string) =>
    [
      ...preparationScreensQueryKeys.detail(id),
      'menuWithAssociations',
    ] as const,
};
export const useGetPreparationScreens = (
  filters: FindAllPreparationScreensDto = {},
  pagination: BaseListQuery = { page: 1, limit: 15 },
) => {
  const queryKey = preparationScreensQueryKeys.list({
    ...filters,
    ...pagination,
  });
  return useQuery<PaginatedResponse<PreparationScreen>, Error>({
    queryKey,
    queryFn: () =>
      preparationScreenService.getPreparationScreens(filters, pagination),
  });
};
export const useGetPreparationScreenById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.detail(id!);
  return useQuery<PreparationScreen, Error>({
    queryKey,
    queryFn: () => preparationScreenService.getPreparationScreenById(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};
export const useCreatePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<PreparationScreen, Error, CreatePreparationScreenDto>({
    mutationFn: preparationScreenService.createPreparationScreen,
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      showSnackbar({
        message: 'Pantalla de preparación creada con éxito',
        type: 'success',
      });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};
export const useUpdatePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  type UpdatePreparationScreenContext = { previousDetail?: PreparationScreen };
  return useMutation<
    PreparationScreen,
    Error,
    { id: string; data: UpdatePreparationScreenDto },
    UpdatePreparationScreenContext
  >({
    mutationFn: ({ id, data }) =>
      preparationScreenService.updatePreparationScreen(id, data),
    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = preparationScreensQueryKeys.detail(id);
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousDetail =
        queryClient.getQueryData<PreparationScreen>(detailQueryKey);
      if (previousDetail) {
        queryClient.setQueryData<PreparationScreen>(detailQueryKey, (old) =>
          old ? { ...old, ...data } : undefined,
        );
      }
      return { previousDetail };
    },
    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      if (context?.previousDetail) {
        queryClient.setQueryData(
          preparationScreensQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },
    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.detail(variables.id),
      });
      if (!error && data) {
        showSnackbar({
          message: 'Pantalla de preparación actualizada con éxito',
          type: 'success',
        });
      }
    },
  });
};
export const useDeletePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  type DeletePreparationScreenContext = { previousDetail?: PreparationScreen };
  return useMutation<void, Error, string, DeletePreparationScreenContext>({
    mutationFn: preparationScreenService.deletePreparationScreen,
    onMutate: async (deletedId) => {
      const detailQueryKey = preparationScreensQueryKeys.detail(deletedId);
      await queryClient.cancelQueries({ queryKey: detailQueryKey });
      const previousDetail =
        queryClient.getQueryData<PreparationScreen>(detailQueryKey);
      queryClient.removeQueries({ queryKey: detailQueryKey });
      return { previousDetail };
    },
    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      if (context?.previousDetail) {
        queryClient.setQueryData(
          preparationScreensQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },
    onSettled: (_, error, deletedId) => {
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      if (!error) {
        queryClient.removeQueries({
          queryKey: preparationScreensQueryKeys.detail(deletedId),
        });
        showSnackbar({
          message: 'Pantalla de preparación eliminada con éxito',
          type: 'success',
        });
      }
    },
  });
};
export const useGetPreparationScreenProducts = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.products(id!);
  return useQuery<any[], Error>({
    queryKey,
    queryFn: () => preparationScreenService.getPreparationScreenProducts(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};
export const useGetMenuWithAssociations = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.menuWithAssociations(id!);
  return useQuery<any, Error>({
    queryKey,
    queryFn: () => preparationScreenService.getMenuWithAssociations(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};
export const useAssociateProducts = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<
    PreparationScreen,
    Error,
    { id: string; productIds: string[] }
  >({
    mutationFn: ({ id, productIds }) =>
      preparationScreenService.associateProducts(id, productIds),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.detail(variables.id),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.products(variables.id),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.menuWithAssociations(
          variables.id,
        ),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      showSnackbar({
        message: 'Productos asociados con éxito',
        type: 'success',
      });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};

================
File: app/src/modules/printers/hooks/usePrintersQueries.ts
================
import {
  useMutation,
  UseMutationResult,
  useQuery,
  UseQueryResult,
  useQueryClient,
} from '@tanstack/react-query';
import { printerService } from '../services/printerService';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
  FindAllThermalPrintersDto,
} from '../types/printer.types';
import { ApiError } from '../../../app/lib/errors';
import { PaginatedResponse } from '../../../app/types/api.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
const printerKeys = {
  all: ['thermalPrinters'] as const,
  lists: () => [...printerKeys.all, 'list'] as const,
  list: (filters: FindAllThermalPrintersDto) =>
    [...printerKeys.lists(), filters] as const,
  details: () => [...printerKeys.all, 'detail'] as const,
  detail: (id: string) => [...printerKeys.details(), id] as const,
  discover: ['discoverPrinters'] as const,
};
export const useDiscoverPrinters = (): UseMutationResult<
  DiscoveredPrinter[],
  ApiError,
  number | undefined
> => {
  return useMutation<DiscoveredPrinter[], ApiError, number | undefined>({
    mutationFn: (duration: number | undefined) =>
      printerService.discoverPrinters(duration),
  });
};
export const usePrintersQuery = (
  params: FindAllThermalPrintersDto = { page: 1, limit: 10 },
  options?: { enabled?: boolean },
): UseQueryResult<PaginatedResponse<ThermalPrinter>, ApiError> => {
  const queryKey = printerKeys.list(params);
  return useQuery<PaginatedResponse<ThermalPrinter>, ApiError>({
    queryKey: queryKey,
    queryFn: () => printerService.findAllPrinters(params),
    enabled: options?.enabled ?? true,
  });
};
export const usePrinterQuery = (
  id: string | undefined,
  options?: { enabled?: boolean },
): UseQueryResult<ThermalPrinter, ApiError> => {
  const queryKey = printerKeys.detail(id!);
  return useQuery<ThermalPrinter, ApiError>({
    queryKey: queryKey,
    queryFn: () => printerService.findOnePrinter(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};
export const useCreatePrinterMutation = (): UseMutationResult<
  ThermalPrinter,
  ApiError,
  CreateThermalPrinterDto
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<ThermalPrinter, ApiError, CreateThermalPrinterDto>({
    mutationFn: printerService.createPrinter,
    onSuccess: (newPrinter) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      showSnackbar({
        message: `Impresora "${newPrinter.name}" creada con éxito`,
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: getApiErrorMessage(error),
        type: 'error',
      });
    },
  });
};
export const useUpdatePrinterMutation = (): UseMutationResult<
  ThermalPrinter,
  ApiError,
  { id: string; data: UpdateThermalPrinterDto }
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<
    ThermalPrinter,
    ApiError,
    { id: string; data: UpdateThermalPrinterDto }
  >({
    mutationFn: ({ id, data }) => printerService.updatePrinter(id, data),
    onSuccess: (updatedPrinter, variables) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: printerKeys.detail(variables.id),
      });
      showSnackbar({
        message: `Impresora "${updatedPrinter.name}" actualizada`,
        type: 'success',
      });
    },
    onError: (error, _variables) => {
      showSnackbar({
        message: getApiErrorMessage(error),
        type: 'error',
      });
    },
  });
};
export const useDeletePrinterMutation = (): UseMutationResult<
  void,
  ApiError,
  string
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<void, ApiError, string>({
    mutationFn: printerService.deletePrinter,
    onSuccess: (_, deletedId) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      queryClient.removeQueries({ queryKey: printerKeys.detail(deletedId) });
      showSnackbar({ message: 'Impresora eliminada', type: 'success' });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al eliminar impresora: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};
export const usePingPrinterMutation = (): UseMutationResult<
  { status: string },
  ApiError,
  string
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<{ status: string }, ApiError, string>({
    mutationFn: (printerId: string) => printerService.pingPrinter(printerId),
    onSuccess: (data, _printerId) => {
      const message =
        data.status === 'online'
          ? `Impresora conectada (ping exitoso).`
          : `Impresora desconectada (ping fallido).`;
      const type = data.status === 'online' ? 'success' : 'warning';
      showSnackbar({ message, type });
    },
    onError: (error, _printerId) => {
      showSnackbar({
        message: `Error al hacer ping a la impresora: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};
export const useTestPrintDiscoveredPrinter = (): UseMutationResult<
  { success: boolean; message?: string },
  ApiError,
  DiscoveredPrinter
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<
    { success: boolean; message?: string },
    ApiError,
    DiscoveredPrinter
  >({
    mutationFn: (printer: DiscoveredPrinter) =>
      printerService.testPrintDiscoveredPrinter(printer),
    onSuccess: (data) => {
      showSnackbar({
        message: data.message || 'Ticket de prueba impreso correctamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al imprimir ticket de prueba: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};
export const useTestPrintPrinter = (): UseMutationResult<
  { success: boolean; message?: string },
  ApiError,
  string
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<{ success: boolean; message?: string }, ApiError, string>({
    mutationFn: (printerId: string) =>
      printerService.testPrintPrinter(printerId),
    onSuccess: (data) => {
      showSnackbar({
        message: data.message || 'Ticket de prueba impreso correctamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al imprimir ticket de prueba: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/printers/services/printerService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
  FindAllThermalPrintersDto,
} from '../types/printer.types';
import {
  PaginatedResponse,
  BaseListQueryDto,
} from '../../../app/types/api.types';
type PrinterFilterParams = Omit<
  FindAllThermalPrintersDto,
  keyof BaseListQueryDto
>;
const discoverPrinters = async (
  duration: number = 10000,
): Promise<DiscoveredPrinter[]> => {
  const response = await apiClient.get<DiscoveredPrinter[]>(
    API_PATHS.THERMAL_PRINTERS_DISCOVER,
    { params: { duration } },
  );
  return response.data;
};
const findAllPrinters = async (
  filters: PrinterFilterParams = {},
  pagination: BaseListQueryDto = { page: 1, limit: 10 },
): Promise<PaginatedResponse<ThermalPrinter>> => {
  const queryParams = Object.entries({ ...filters, ...pagination }).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) {
        if (key === 'isActive' && typeof value === 'boolean') {
          acc[key] = String(value);
        } else {
          acc[key] = value;
        }
      }
      return acc;
    },
    {} as Record<string, any>,
  );
  type FindAllPrintersApiResponse = {
    items: ThermalPrinter[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
  const response = await apiClient.get<FindAllPrintersApiResponse>(
    API_PATHS.THERMAL_PRINTERS,
    { params: queryParams },
  );
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};
const findOnePrinter = async (id: string): Promise<ThermalPrinter> => {
  const response = await apiClient.get<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
  );
  return response.data;
};
const createPrinter = async (
  data: CreateThermalPrinterDto,
): Promise<ThermalPrinter> => {
  const response = await apiClient.post<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS,
    data,
  );
  return response.data;
};
const updatePrinter = async (
  id: string,
  data: UpdateThermalPrinterDto,
): Promise<ThermalPrinter> => {
  const response = await apiClient.patch<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};
const deletePrinter = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id));
};
const pingPrinter = async (id: string): Promise<{ status: string }> => {
  const response = await apiClient.get<{ status: string }>(
    API_PATHS.THERMAL_PRINTERS_PING.replace(':id', id),
  );
  return response.data;
};
const testPrintDiscoveredPrinter = async (
  printer: DiscoveredPrinter,
): Promise<{ success: boolean; message?: string }> => {
  const response = await apiClient.post<{
    success: boolean;
    message?: string;
  }>(API_PATHS.THERMAL_PRINTERS_TEST_PRINT, {
    ip: printer.ip,
    port: printer.port,
    connectionType: 'NETWORK',
  });
  return response.data;
};
const testPrintPrinter = async (
  id: string,
): Promise<{ success: boolean; message?: string }> => {
  const printer = await findOnePrinter(id);
  const printerInfo: any = {
    connectionType: printer.connectionType,
  };
  if (printer.connectionType === 'NETWORK') {
    printerInfo.ip = printer.ipAddress;
    printerInfo.port = printer.port;
  } else {
    printerInfo.path = printer.path;
  }
  const response = await apiClient.post<{
    success: boolean;
    message?: string;
  }>(API_PATHS.THERMAL_PRINTERS_TEST_PRINT, printerInfo);
  return response.data;
};
export const printerService = {
  discoverPrinters,
  findAllPrinters,
  findOnePrinter,
  createPrinter,
  updatePrinter,
  deletePrinter,
  pingPrinter,
  testPrintDiscoveredPrinter,
  testPrintPrinter,
};

================
File: app/src/modules/receipts/components/ReceiptDetailsModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Surface,
  Text,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
} from 'react-native-paper';
import { Receipt } from '../types/receipt.types';
import { useAppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import OrderHistoryModal from '@/modules/shared/components/OrderHistoryModal';
interface ReceiptDetailsModalProps {
  visible: boolean;
  onDismiss: () => void;
  receipt: Receipt | null;
  isLoading?: boolean;
}
const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';
  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalf.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalf.HALF_2
            ? 'HALF_2'
            : 'FULL';
      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }
      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;
      if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationType.INGREDIENT
      ) {
        if (curr.action === CustomizationAction.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }
      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );
  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };
    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';
    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }
  return '';
};
export const ReceiptDetailsModal: React.FC<ReceiptDetailsModalProps> = ({
  visible,
  onDismiss,
  receipt,
  isLoading = false,
}) => {
  const theme = useAppTheme();
  const [showPrintHistory, setShowPrintHistory] = useState(false);
  const [showOrderHistory, setShowOrderHistory] = useState(false);
  if (!receipt && !isLoading) return null;
  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return '🍽️ Local';
      case 'TAKE_AWAY':
        return '🥡 Llevar';
      case 'DELIVERY':
        return '🚚 Envío';
      default:
        return type;
    }
  };
  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparación';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      case 'COMPLETED':
        return 'Completado';
      case 'CANCELLED':
        return 'Cancelado';
      default:
        return status;
    }
  };
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0';
      case 'COMPLETED':
        return '#10B981';
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceVariant;
    }
  };
  const getPaymentStatus = () => {
    if (receipt?.payments && receipt.payments.length > 0) {
      const totalPaid = receipt.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof receipt.total === 'string'
          ? parseFloat(receipt.total)
          : receipt.total || 0;
      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };
  if (isLoading || !receipt) {
    return (
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        title="Cargando..."
      >
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text
            style={[
              styles.loadingText,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Cargando detalles del recibo...
          </Text>
        </View>
      </ResponsiveModal>
    );
  }
  const paymentStatus = getPaymentStatus();
  const headerActions = (
    <IconButton
      icon="history"
      size={24}
      onPress={() => setShowOrderHistory(true)}
      style={styles.historyButton}
    />
  );
  const modalTitle = `Recibo #${receipt?.shiftOrderNumber || ''} · ${getOrderTypeLabel(receipt?.orderType || '')}`;
  const footerContent = (
    <View style={styles.footer}>
      <View style={styles.footerLeft}>
        <Text
          style={[styles.totalLabel, { color: theme.colors.onSurfaceVariant }]}
        >
          Total:
        </Text>
        <Text style={[styles.totalAmount, { color: theme.colors.primary }]}>
          $
          {receipt
            ? typeof receipt.total === 'string'
              ? parseFloat(receipt.total).toFixed(2)
              : (receipt.total || 0).toFixed(2)
            : '0.00'}
        </Text>
      </View>
      <View
        style={[styles.paymentBadge, { backgroundColor: paymentStatus.color }]}
      >
        <Text style={styles.paymentBadgeText}>💵 {paymentStatus.label}</Text>
      </View>
    </View>
  );
  const renderItem = (item: any) => {
    const quantity = item.quantity || 1;
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;
    return (
      <Surface
        key={`${item.id}`}
        style={[
          styles.itemCard,
          { backgroundColor: theme.colors.elevation.level1, marginBottom: 8 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>
          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}
            {item.productModifiers && item.productModifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.productModifiers.map((modifier: any) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      • {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}
            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📝 {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>
          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {item.quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total ×{item.quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };
  return (
    <>
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        title={modalTitle}
        headerActions={headerActions}
        maxHeightTablet="90%"
        scrollable={true}
        footer={footerContent}
        footerStyle={{ paddingTop: 0 }}
      >
        {}
        <View style={styles.headerInfo}>
          <View style={styles.chipsRow}>
            <View
              style={[
                styles.headerStatusChip,
                {
                  backgroundColor: getStatusColor(receipt.orderStatus),
                },
              ]}
            >
              <Text style={styles.headerStatusChipText}>
                {getOrderStatusLabel(receipt.orderStatus)}
              </Text>
            </View>
            {receipt.preparationScreens &&
              receipt.preparationScreens.map((screen, index) => (
                <Chip
                  key={index}
                  mode="outlined"
                  compact
                  style={styles.screenChip}
                  textStyle={styles.screenChipText}
                >
                  🍳 {screen}
                </Chip>
              ))}
          </View>
          <View style={styles.headerDatesRow}>
            <Text
              style={[
                styles.headerDate,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Creado:{' '}
              {receipt.createdAt
                ? format(new Date(receipt.createdAt), 'dd/MM/yyyy HH:mm', {
                    locale: es,
                  })
                : ''}
            </Text>
            {receipt.finalizedAt && (
              <Text
                style={[styles.headerDate, { color: theme.colors.primary }]}
              >
                Finalizado:{' '}
                {format(new Date(receipt.finalizedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            )}
          </View>
        </View>
        {}
        <View style={styles.infoSection}>
          {receipt.deliveryInfo?.recipientName && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                👤 Nombre del Cliente: {receipt.deliveryInfo.recipientName}
              </Text>
            </View>
          )}
          {receipt.deliveryInfo?.recipientPhone && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                📞 Teléfono: {receipt.deliveryInfo.recipientPhone}
              </Text>
            </View>
          )}
          {receipt.orderType === 'DELIVERY' &&
            receipt.deliveryInfo?.fullAddress && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.addressText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📦 Dirección de Entrega: {receipt.deliveryInfo.fullAddress}
                </Text>
              </View>
            )}
          {receipt.orderType === 'DINE_IN' && receipt.table && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.tableText, { color: theme.colors.onSurface }]}
              >
                🏛️ Mesa: {receipt.table.area?.name || 'Sin área'} -{' '}
                {receipt.table.number}
              </Text>
            </View>
          )}
          {receipt.scheduledAt && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.primary, fontWeight: '600' },
                ]}
              >
                ⏰ Hora de Entrega Programada:{' '}
                {format(new Date(receipt.scheduledAt), 'HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          )}
          {receipt.user && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                👨‍💼 Atendido por: {receipt.user.firstName}{' '}
                {receipt.user.lastName}
              </Text>
            </View>
          )}
          {receipt.notes && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.notesText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                📋 Notas: {receipt.notes}
              </Text>
            </View>
          )}
        </View>
        <Divider style={styles.divider} />
        {}
        <View style={styles.itemsList}>
          {receipt.orderItems?.map((item) => renderItem(item)) || []}
        </View>
        <Divider style={styles.divider} />
        {}
        {receipt.payments && receipt.payments.length > 0 && (
          <>
            <View style={styles.paymentsSection}>
              <View style={styles.paymentSummaryCompact}>
                <View style={styles.summaryCompactRow}>
                  <Text
                    style={[
                      styles.summaryCompactLabel,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    Total: $
                    {typeof receipt.total === 'string'
                      ? parseFloat(receipt.total).toFixed(2)
                      : (receipt.total || 0).toFixed(2)}
                  </Text>
                  <Text
                    style={[styles.summaryCompactLabel, { color: '#10B981' }]}
                  >
                    Pagado: $
                    {receipt.payments
                      .reduce((sum, p) => sum + p.amount, 0)
                      .toFixed(2)}
                  </Text>
                  {(() => {
                    const totalAmount =
                      typeof receipt.total === 'string'
                        ? parseFloat(receipt.total)
                        : receipt.total || 0;
                    const totalPaid = receipt.payments.reduce(
                      (sum, p) => sum + p.amount,
                      0,
                    );
                    const remaining = totalAmount - totalPaid;
                    if (remaining > 0) {
                      return (
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            {
                              color: theme.colors.error,
                              fontWeight: '600',
                            },
                          ]}
                        >
                          Resta: ${remaining.toFixed(2)}
                        </Text>
                      );
                    }
                    return null;
                  })()}
                </View>
              </View>
              {receipt.payments.map((payment, index) => {
                const getPaymentMethodLabel = (method: string) => {
                  switch (method) {
                    case 'CASH':
                    case 'cash':
                      return 'Efectivo';
                    case 'CREDIT_CARD':
                    case 'card':
                      return 'Tarjeta de Crédito';
                    case 'DEBIT_CARD':
                      return 'Tarjeta de Débito';
                    case 'TRANSFER':
                    case 'transfer':
                      return 'Transferencia';
                    case 'OTHER':
                      return 'Otro';
                    default:
                      return method;
                  }
                };
                const getPaymentStatusColor = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return '#10B981';
                    case 'PENDING':
                      return '#F59E0B';
                    case 'FAILED':
                      return theme.colors.error;
                    case 'REFUNDED':
                      return '#6B7280';
                    case 'CANCELLED':
                      return theme.colors.error;
                    default:
                      return theme.colors.onSurfaceVariant;
                  }
                };
                const getPaymentStatusLabel = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return 'Completado';
                    case 'PENDING':
                      return 'Pendiente';
                    case 'FAILED':
                      return 'Fallido';
                    case 'REFUNDED':
                      return 'Reembolsado';
                    case 'CANCELLED':
                      return 'Cancelado';
                    default:
                      return status;
                  }
                };
                return (
                  <View
                    key={payment.id || index}
                    style={styles.paymentRowCompact}
                  >
                    <Text
                      style={[
                        styles.paymentMethodCompact,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      💳 {getPaymentMethodLabel(payment.paymentMethod)}
                    </Text>
                    <Text
                      style={[
                        styles.paymentDateCompact,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {format(new Date(payment.createdAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                    <View
                      style={[
                        styles.paymentStatusBadgeCompact,
                        {
                          backgroundColor:
                            getPaymentStatusColor(payment.paymentStatus) + '20',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.paymentStatusTextCompact,
                          {
                            color: getPaymentStatusColor(payment.paymentStatus),
                          },
                        ]}
                      >
                        {getPaymentStatusLabel(payment.paymentStatus)}
                      </Text>
                    </View>
                    <Text
                      style={[
                        styles.paymentAmountCompact,
                        { color: theme.colors.primary },
                      ]}
                    >
                      ${payment.amount.toFixed(2)}
                    </Text>
                  </View>
                );
              })}
            </View>
            <Divider style={styles.divider} />
          </>
        )}
        {}
        {receipt.ticketImpressions && receipt.ticketImpressions.length > 0 && (
          <>
            <View style={styles.ticketImpressionsSection}>
              <TouchableOpacity
                style={styles.collapsibleHeader}
                onPress={() => setShowPrintHistory(!showPrintHistory)}
                activeOpacity={0.7}
              >
                <Text
                  style={[styles.sectionTitle, { color: theme.colors.primary }]}
                >
                  🖨️ Historial de Impresiones (
                  {receipt.ticketImpressions.length})
                </Text>
                <IconButton
                  icon={showPrintHistory ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  style={styles.collapseIcon}
                />
              </TouchableOpacity>
              {showPrintHistory && (
                <View style={styles.collapsibleContent}>
                  {receipt.ticketImpressions.map((impression, index) => {
                    const getTicketTypeLabel = (type: string) => {
                      switch (type) {
                        case 'KITCHEN':
                          return '🍳 Cocina';
                        case 'BAR':
                          return '🍺 Barra';
                        case 'BILLING':
                          return '💵 Cuenta';
                        case 'CUSTOMER_COPY':
                          return '📄 Copia Cliente';
                        case 'GENERAL':
                          return '📋 General';
                        default:
                          return type;
                      }
                    };
                    return (
                      <View
                        key={impression.id || index}
                        style={styles.impressionRow}
                      >
                        <View style={styles.impressionLeft}>
                          <Text
                            style={[
                              styles.impressionType,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            {getTicketTypeLabel(impression.ticketType)}
                          </Text>
                          <View style={styles.impressionDetails}>
                            {impression.user && (
                              <Text
                                style={[
                                  styles.impressionUser,
                                  {
                                    color: theme.colors.onSurfaceVariant,
                                  },
                                ]}
                              >
                                por {impression.user.firstName || ''}{' '}
                                {impression.user.lastName || ''}
                              </Text>
                            )}
                            {impression.printer && (
                              <Text
                                style={[
                                  styles.impressionPrinter,
                                  {
                                    color: theme.colors.onSurfaceVariant,
                                  },
                                ]}
                              >
                                🖨️ {impression.printer.name}
                              </Text>
                            )}
                          </View>
                        </View>
                        <Text
                          style={[
                            styles.impressionTime,
                            {
                              color: theme.colors.onSurfaceVariant,
                            },
                          ]}
                        >
                          {format(
                            new Date(impression.impressionTime),
                            'HH:mm:ss',
                            { locale: es },
                          )}
                        </Text>
                      </View>
                    );
                  })}
                </View>
              )}
            </View>
          </>
        )}
      </ResponsiveModal>
      {}
      {receipt && (
        <OrderHistoryModal
          visible={showOrderHistory}
          onDismiss={() => setShowOrderHistory(false)}
          orderId={receipt.id}
        />
      )}
    </>
  );
};
const styles = StyleSheet.create({
  loadingContainer: {
    minHeight: 200,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 14,
  },
  historyButton: {
    margin: -8,
  },
  headerInfo: {
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0,0,0,0.08)',
    marginBottom: 16,
  },
  chipsRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    flexWrap: 'wrap',
    marginBottom: 8,
  },
  headerStatusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  headerStatusChipText: {
    color: 'white',
    fontSize: 11,
    fontWeight: '600',
  },
  screenChip: {
    height: 20,
  },
  screenChipText: {
    fontSize: 10,
    marginVertical: -2,
  },
  headerDatesRow: {
    gap: 8,
  },
  headerDate: {
    fontSize: 11,
  },
  infoSection: {
    gap: 4,
    marginBottom: 16,
  },
  infoRow: {
    marginVertical: 2,
  },
  contactText: {
    fontSize: 12,
  },
  addressText: {
    fontSize: 12,
    lineHeight: 16,
  },
  tableText: {
    fontSize: 12,
  },
  divider: {
    marginVertical: 2,
  },
  itemsList: {
    marginBottom: 16,
  },
  itemCard: {
    borderRadius: 8,
    overflow: 'hidden',
  },
  itemContent: {
    padding: 10,
  },
  itemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  nameContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  itemQuantity: {
    fontSize: 14,
    fontWeight: '700',
    marginRight: 6,
  },
  itemName: {
    fontSize: 13,
    fontWeight: '600',
    flex: 1,
    lineHeight: 16,
  },
  statusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusChipText: {
    color: 'white',
    fontSize: 10,
    fontWeight: '600',
  },
  itemDetailsContainer: {
    marginBottom: 6,
  },
  customizationContainer: {
    marginBottom: 4,
  },
  pizzaCustomizationText: {
    fontSize: 11,
    fontStyle: 'italic',
    lineHeight: 14,
  },
  modifiersContainer: {
    marginTop: 2,
  },
  modifierRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 1,
  },
  modifierText: {
    fontSize: 11,
    flex: 1,
    lineHeight: 14,
  },
  modifierPrice: {
    fontSize: 11,
    fontWeight: '500',
    marginLeft: 4,
  },
  notesContainer: {
    marginTop: 4,
    paddingTop: 4,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  notesText: {
    fontSize: 11,
    fontStyle: 'italic',
    lineHeight: 14,
  },
  priceContainer: {
    marginTop: 6,
    paddingTop: 6,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  priceLabel: {
    fontSize: 11,
    opacity: 0.7,
  },
  priceValue: {
    fontSize: 12,
    fontWeight: '600',
  },
  totalPrice: {
    fontSize: 14,
    fontWeight: '700',
  },
  paymentsSection: {
    marginBottom: 16,
  },
  paymentSummaryCompact: {
    marginBottom: 8,
  },
  summaryCompactRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  summaryCompactLabel: {
    fontSize: 12,
    fontWeight: '500',
  },
  paymentRowCompact: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
    gap: 8,
  },
  paymentMethodCompact: {
    fontSize: 11,
    fontWeight: '500',
    flex: 1,
  },
  paymentDateCompact: {
    fontSize: 10,
  },
  paymentAmountCompact: {
    fontSize: 12,
    fontWeight: '600',
    minWidth: 50,
    textAlign: 'right',
  },
  paymentStatusBadgeCompact: {
    paddingHorizontal: 6,
    paddingVertical: 1,
    borderRadius: 10,
  },
  paymentStatusTextCompact: {
    fontSize: 9,
    fontWeight: '600',
  },
  ticketImpressionsSection: {
    marginBottom: 16,
  },
  collapsibleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingRight: 4,
  },
  collapseIcon: {
    margin: -8,
  },
  collapsibleContent: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 0,
  },
  impressionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
    paddingLeft: 8,
  },
  impressionLeft: {
    flex: 1,
    gap: 2,
  },
  impressionType: {
    fontSize: 12,
    fontWeight: '500',
  },
  impressionDetails: {
    gap: 2,
  },
  impressionUser: {
    fontSize: 11,
    opacity: 0.7,
  },
  impressionPrinter: {
    fontSize: 11,
    opacity: 0.7,
    fontStyle: 'italic',
  },
  impressionTime: {
    fontSize: 11,
    opacity: 0.7,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  footerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  totalLabel: {
    fontSize: 14,
    fontWeight: '600',
  },
  totalAmount: {
    fontSize: 16,
    fontWeight: '700',
  },
  paymentBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  paymentBadgeText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
});

================
File: app/src/modules/restaurantConfig/types/restaurantConfig.types.ts
================
export interface DeliveryCoveragePoint {
  lat: number;
  lng: number;
}
export interface BusinessHours {
  id: string;
  dayOfWeek: number;
  openingTime: string | null;
  closingTime: string | null;
  closesNextDay?: boolean;
  isClosed: boolean;
  restaurantConfigId: string;
  createdAt: string;
  updatedAt: string;
}
export interface RestaurantConfig {
  id: string;
  restaurantName: string;
  phoneMain: string | null;
  phoneSecondary: string | null;
  address: string | null;
  city: string | null;
  state: string | null;
  postalCode: string | null;
  country: string | null;
  acceptingOrders: boolean;
  estimatedPickupTime: number;
  estimatedDeliveryTime: number;
  estimatedDineInTime: number;
  openingGracePeriod: number;
  closingGracePeriod: number;
  timeZone: string;
  scheduledOrdersLeadTime: number;
  deliveryCoverageArea: DeliveryCoveragePoint[] | null;
  minimumOrderValueForDelivery: number | string;
  businessHours: BusinessHours[];
  createdAt: string;
  updatedAt: string;
}
export interface UpdateRestaurantConfigDto {
  restaurantName?: string;
  phoneMain?: string | null;
  phoneSecondary?: string | null;
  address?: string | null;
  city?: string | null;
  state?: string | null;
  postalCode?: string | null;
  country?: string | null;
  acceptingOrders?: boolean;
  estimatedPickupTime?: number;
  estimatedDeliveryTime?: number;
  estimatedDineInTime?: number;
  openingGracePeriod?: number;
  closingGracePeriod?: number;
  timeZone?: string;
  scheduledOrdersLeadTime?: number;
  deliveryCoverageArea?: DeliveryCoveragePoint[] | null;
  minimumOrderValueForDelivery?: number;
  businessHours?: CreateBusinessHoursDto[];
}
export interface CreateBusinessHoursDto {
  dayOfWeek: number;
  openingTime?: string | null;
  closingTime?: string | null;
  closesNextDay?: boolean;
  isClosed?: boolean;
  restaurantConfigId?: string;
}
export interface UpdateBusinessHoursDto {
  openingTime?: string | null;
  closingTime?: string | null;
  closesNextDay?: boolean;
  isClosed?: boolean;
}

================
File: app/src/modules/shiftAudit/components/OrderHistoryView.tsx
================
import React, { useMemo, useState } from 'react';
import {
  View,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
} from 'react-native';
import {
  Text,
  Divider,
  Chip,
  Button,
  Avatar,
  Surface,
  Appbar,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
interface HistoryItem {
  id: string | number;
  orderId: string;
  orderItemId?: string;
  operation: 'INSERT' | 'UPDATE' | 'DELETE' | 'BATCH';
  changedBy: string;
  changedAt: string;
  diff?: Record<string, any> | null;
  snapshot?: Record<string, any>;
  productId?: string;
  preparationStatus?: string;
  changedByUser?: {
    id?: string;
    firstName: string;
    lastName: string;
  };
  user?: {
    firstName: string;
    lastName: string;
  };
  itemDescription?: string;
  formattedChanges?: Record<string, any>;
  batchOperations?: any[];
  type: 'order' | 'item';
}
interface OrderHistoryViewProps {
  orderId: string | null;
  orderNumber?: number;
  onBack: () => void;
}
const getOperationIcon = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    return 'receipt';
  }
  switch (operation) {
    case 'INSERT':
      return 'plus-circle';
    case 'UPDATE':
      return 'pencil';
    case 'DELETE':
      return 'delete';
    case 'BATCH':
      return 'folder-multiple';
    default:
      return 'information';
  }
};
const getOperationLabel = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    const orderOperationMap: Record<string, string> = {
      INSERT: 'Orden creada',
      UPDATE: 'Orden modificada',
      DELETE: 'Orden eliminada',
    };
    return orderOperationMap[operation] || operation;
  }
  const operationMap: Record<string, string> = {
    INSERT: 'Item agregado',
    UPDATE: 'Item modificado',
    DELETE: 'Item eliminado',
    BATCH: 'Cambios múltiples',
  };
  return operationMap[operation] || operation;
};
const getStatusColor = (
  status: string,
  theme: ReturnType<typeof useAppTheme>,
) => {
  const statusColors: Record<string, string> = {
    PENDING: theme.colors.onSurfaceDisabled,
    IN_PROGRESS: theme.colors.warning || '#FFA500',
    READY: theme.colors.success || '#4CAF50',
    CANCELLED: theme.colors.error,
  };
  return statusColors[status] || theme.colors.onSurfaceDisabled;
};
const formatFieldName = (field: string): string => {
  const fieldMap: Record<string, string> = {
    orderStatus: 'Estado de la orden',
    orderType: 'Tipo de orden',
    tableId: 'Mesa',
    table: 'Mesa',
    notes: 'Notas',
    deliveryInfo: 'Información de entrega',
    customerName: 'Nombre del cliente',
    customerPhone: 'Teléfono del cliente',
    recipientName: 'Nombre del destinatario',
    recipientPhone: 'Teléfono del destinatario',
    deliveryAddress: 'Dirección de entrega',
    fullAddress: 'Dirección',
    estimatedDeliveryTime: 'Tiempo estimado de entrega',
    preparationStatus: 'Estado de preparación',
    preparationNotes: 'Notas de preparación',
    customerId: 'Cliente',
    scheduledAt: 'Fecha programada',
    total: 'Total',
    subtotal: 'Subtotal',
    finalizedAt: 'Finalizado',
  };
  return fieldMap[field] || field;
};
const formatValue = (field: string, value: any): string => {
  if (value === null || value === undefined) {
    return 'No especificado';
  }
  if (field === 'orderStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Progreso',
      COMPLETED: 'Completada',
      CANCELLED: 'Cancelada',
      DELIVERED: 'Entregada',
    };
    return statusMap[value] || value;
  }
  if (field === 'orderType') {
    const typeMap: Record<string, string> = {
      DINE_IN: 'Para Comer Aquí',
      TAKE_AWAY: 'Para Llevar',
      DELIVERY: 'Domicilio',
    };
    return typeMap[value] || value;
  }
  if (field === 'preparationStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Preparación',
      READY: 'Listo',
      CANCELLED: 'Cancelado',
    };
    return statusMap[value] || value;
  }
  if (field === 'tableId' && typeof value === 'object' && value.name) {
    return value.name;
  }
  if (
    field === 'estimatedDeliveryTime' ||
    field === 'scheduledAt' ||
    field === 'finalizedAt'
  ) {
    try {
      return format(new Date(value), 'dd/MM/yyyy HH:mm', { locale: es });
    } catch {
      return value;
    }
  }
  if (field === 'total' || field === 'subtotal') {
    return `$${parseFloat(value).toFixed(2)}`;
  }
  if (field === 'customerId') {
    return value || 'Sin cliente registrado';
  }
  if (field === 'scheduledAt') {
    return value
      ? format(new Date(value), 'dd/MM/yyyy HH:mm', { locale: es })
      : 'No programado';
  }
  return String(value);
};
const HistoryItemComponent: React.FC<{
  item: HistoryItem;
  theme: ReturnType<typeof useAppTheme>;
}> = ({ item, theme }) => {
  const [expanded, setExpanded] = useState(false);
  const styles = useMemo(() => createStyles(theme), [theme]);
  const renderChangeDetail = (change: any, fieldName?: string) => {
    if (
      change &&
      typeof change === 'object' &&
      change.anterior !== undefined &&
      change.nuevo !== undefined
    ) {
      if (
        (fieldName === 'Descripción del Item' || fieldName === 'Descripción') &&
        (String(change.anterior).length > 30 ||
          String(change.nuevo).length > 30)
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {String(change.anterior)}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Después:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {String(change.nuevo)}
              </Text>
            </View>
          </View>
        );
      }
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {String(change.anterior)}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {String(change.nuevo)}
            </Text>
          </View>
        </View>
      );
    } else if (Array.isArray(change) && change.length === 2) {
      const oldVal = formatValue(fieldName || '', change[0]);
      const newVal = formatValue(fieldName || '', change[1]);
      // Para campos largos o especiales, usar formato vertical
      if (
        fieldName &&
        ['notes', 'deliveryInfo', 'customerName', 'deliveryAddress'].includes(
          fieldName,
        )
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {oldVal}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Después:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {newVal}
              </Text>
            </View>
          </View>
        );
      }
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {oldVal}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {newVal}
            </Text>
          </View>
        </View>
      );
    }
    return null;
  };
  return (
    <Surface
      style={[
        styles.historyItem,
        { backgroundColor: theme.colors.surfaceVariant },
      ]}
      elevation={1}
    >
      <TouchableOpacity
        onPress={() => setExpanded(!expanded)}
        activeOpacity={0.7}
      >
        <View style={styles.historyHeader}>
          <View style={{ flex: 1, marginRight: 12 }}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginBottom: 4,
              }}
            >
              <Avatar.Icon
                size={24}
                icon={getOperationIcon(item.operation, item.type)}
                style={{
                  backgroundColor:
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary,
                  marginRight: 6,
                }}
              />
              <Text
                variant="bodySmall"
                style={{ fontWeight: '600', flex: 1 }}
                numberOfLines={1}
              >
                {item.changedByUser
                  ? `${item.changedByUser.firstName} ${item.changedByUser.lastName}`
                  : item.user
                    ? `${item.user.firstName} ${item.user.lastName}`
                    : 'Sistema'}
              </Text>
              <View
                style={{
                  width: 32,
                  height: 32,
                  borderRadius: 16,
                  backgroundColor: theme.colors.surfaceVariant,
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Icon
                  name={expanded ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                flexWrap: 'wrap',
                gap: 4,
              }}
            >
              <View
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor:
                    (item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary) + '15',
                  paddingHorizontal: 5,
                  paddingVertical: 1,
                  borderRadius: 10,
                }}
              >
                <Icon
                  name={getOperationIcon(item.operation, item.type)}
                  size={10}
                  color={
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary
                  }
                  style={{ marginRight: 3 }}
                />
                <Text
                  style={{
                    color:
                      item.type === 'order'
                        ? theme.colors.primary
                        : theme.colors.secondary,
                    fontSize: 9,
                    fontWeight: '600',
                  }}
                >
                  {getOperationLabel(item.operation, item.type)}
                </Text>
              </View>
              {item.preparationStatus && (
                <Chip
                  mode="flat"
                  textStyle={{ fontSize: 9 }}
                  style={{
                    backgroundColor:
                      getStatusColor(item.preparationStatus, theme) + '20',
                    transform: [{ scale: 0.8 }],
                    height: 20,
                  }}
                  compact
                >
                  {formatValue('preparationStatus', item.preparationStatus)}
                </Chip>
              )}
              <Text variant="labelSmall" style={{ opacity: 0.6, fontSize: 10 }}>
                {format(new Date(item.changedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          </View>
        </View>
      </TouchableOpacity>
      {expanded && (
        <View style={styles.expandedContent}>
          <Divider style={{ marginBottom: 8 }} />
          {}
          {item.type === 'order' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <>
                  {}
                  {item.diff && (item.diff.order || item.diff.items) ? (
                    <>
                      {item.diff.summary && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.primary,
                            fontWeight: '600',
                            marginBottom: 8,
                            fontStyle: 'italic',
                          }}
                        >
                          {item.diff.summary}
                        </Text>
                      )}
                      {}
                      {item.diff.order && (
                        <View
                          style={{
                            backgroundColor: theme.colors.surface,
                            padding: 8,
                            borderRadius: 6,
                            marginBottom: 8,
                          }}
                        >
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.primary,
                              fontWeight: '600',
                              marginBottom: 6,
                            }}
                          >
                            Detalles de la orden:
                          </Text>
                          {item.diff.order.fields?.orderType && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.diff.order.fields.orderType[1],
                              )}
                            </Text>
                          )}
                          {item.diff.order.fields?.tableId && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Mesa:</Text>{' '}
                              {item.snapshot?.table?.name ||
                                `Mesa ${item.diff.order.fields.tableId[1]}`}
                            </Text>
                          )}
                          {item.diff.order.fields?.notes && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Notas:</Text>{' '}
                              {item.diff.order.fields.notes[1]}
                            </Text>
                          )}
                          {}
                          {item.diff.order.deliveryInfo && (
                            <>
                              {item.diff.order.deliveryInfo.recipientName && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Cliente:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientName[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.recipientPhone && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Teléfono:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientPhone[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.fullAddress && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Dirección:
                                  </Text>{' '}
                                  {item.diff.order.deliveryInfo.fullAddress[1]}
                                </Text>
                              )}
                            </>
                          )}
                        </View>
                      )}
                      {}
                      {item.diff.items?.added &&
                        item.diff.items.added.length > 0 && (
                          <>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                marginTop: 8,
                              }}
                            >
                              Productos incluidos en la orden:
                            </Text>
                            {item.diff.items.added.map(
                              (addedItem: any, idx: number) => (
                                <View
                                  key={`added-${idx}`}
                                  style={{
                                    marginBottom: 8,
                                    paddingLeft: 8,
                                    borderLeftWidth: 2,
                                    borderLeftColor:
                                      theme.colors.primary + '50',
                                    backgroundColor: theme.colors.surface,
                                    padding: 8,
                                    marginLeft: 4,
                                    borderRadius: 4,
                                  }}
                                >
                                  <Text
                                    variant="bodySmall"
                                    style={{ fontWeight: '600' }}
                                  >
                                    {addedItem.productName}
                                    {addedItem.variantName
                                      ? ` - ${addedItem.variantName}`
                                      : ''}
                                  </Text>
                                  {addedItem.modifiers?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Modificadores:{' '}
                                      {addedItem.modifiers.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.customizations?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Personalizaciones:{' '}
                                      {addedItem.customizations.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.notes && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        fontStyle: 'italic',
                                      }}
                                    >
                                      Notas: {addedItem.notes}
                                    </Text>
                                  )}
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      marginTop: 4,
                                      color: theme.colors.primary,
                                      fontWeight: '600',
                                    }}
                                  >
                                    Precio: $
                                    {addedItem.finalPrice ||
                                      addedItem.basePrice}
                                  </Text>
                                </View>
                              ),
                            )}
                          </>
                        )}
                    </>
                  ) : item.formattedChanges ? (
                    Object.entries(item.formattedChanges).map(
                      ([section, changes]) => {
                        if (section === 'Resumen') {
                          return (
                            <Text
                              key={section}
                              variant="bodySmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                fontStyle: 'italic',
                              }}
                            >
                              {changes as string}
                            </Text>
                          );
                        }
                        return (
                          <View key={section} style={{ marginBottom: 12 }}>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 6,
                              }}
                            >
                              {section}:
                            </Text>
                            {typeof changes === 'object' &&
                              Object.entries(changes).map(([field, change]) => (
                                <View
                                  key={field}
                                  style={{ marginBottom: 4, marginLeft: 8 }}
                                >
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.onSurfaceVariant,
                                      marginBottom: 2,
                                    }}
                                  >
                                    {field}:
                                  </Text>
                                  {renderChangeDetail(change, field)}
                                </View>
                              ))}
                          </View>
                        );
                      },
                    )
                  ) : (
                    <Text
                      variant="bodySmall"
                      style={{ fontWeight: '600', marginBottom: 8 }}
                    >
                      Nueva orden creada
                      {item.snapshot?.orderType &&
                        ` - ${formatValue('orderType', item.snapshot.orderType)}`}
                    </Text>
                  )}
                </>
              )}
              {item.operation === 'UPDATE' &&
                (() => {
                  if (item.formattedChanges) {
                    return Object.entries(item.formattedChanges).map(
                      ([section, changes]) => {
                        if (section === 'Resumen') {
                          return (
                            <Text
                              key={section}
                              variant="bodySmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                fontStyle: 'italic',
                              }}
                            >
                              {changes as string}
                            </Text>
                          );
                        }
                        return (
                          <View key={section} style={{ marginBottom: 12 }}>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 6,
                              }}
                            >
                              {section}:
                            </Text>
                            {typeof changes === 'object' &&
                              Object.entries(changes).map(([field, change]) => (
                                <View
                                  key={field}
                                  style={{ marginBottom: 4, marginLeft: 8 }}
                                >
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.onSurfaceVariant,
                                      marginBottom: 2,
                                    }}
                                  >
                                    {field}:
                                  </Text>
                                  {renderChangeDetail(change, field)}
                                </View>
                              ))}
                          </View>
                        );
                      },
                    );
                  }
                  if (item.diff) {
                    return (
                      <>
                        {item.diff.summary && (
                          <Text
                            variant="bodySmall"
                            style={{
                              color: theme.colors.primary,
                              fontWeight: '600',
                              marginBottom: 8,
                              fontStyle: 'italic',
                            }}
                          >
                            {item.diff.summary}
                          </Text>
                        )}
                        {item.diff.order?.fields &&
                          Object.entries(item.diff.order.fields).map(
                            ([field, values]) => (
                              <View key={field} style={{ marginBottom: 8 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.onSurfaceVariant,
                                    fontWeight: '600',
                                    marginBottom: 4,
                                  }}
                                >
                                  {formatFieldName(field)}:
                                </Text>
                                {renderChangeDetail(values, field)}
                              </View>
                            ),
                          )}
                      </>
                    );
                  }
                  const relevantChanges = Object.entries(item.snapshot || {})
                    .filter(([field]) =>
                      [
                        'orderStatus',
                        'orderType',
                        'tableId',
                        'notes',
                        'deliveryInfo',
                        'estimatedDeliveryTime',
                        'scheduledAt',
                        'customerId',
                      ].includes(field),
                    )
                    .map(([field, value]) => ({ field, change: value }));
                  if (relevantChanges.length === 0) {
                    return (
                      <Text
                        variant="bodySmall"
                        style={{ color: theme.colors.onSurfaceVariant }}
                      >
                        Actualización de productos de la orden
                      </Text>
                    );
                  }
                  return (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en la orden:
                      </Text>
                      {relevantChanges.map(({ field, change }) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ))}
                    </>
                  );
                })()}
              {item.operation === 'DELETE' && (
                <Text variant="bodySmall" style={{ color: theme.colors.error }}>
                  La orden fue eliminada
                </Text>
              )}
            </View>
          )}
          {}
          {item.diff &&
            (item.diff.order || item.diff.items || item.diff.summary) && (
              <View style={styles.changesContainer}>
                {}
                {item.diff.summary && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                      fontStyle: 'italic',
                    }}
                  >
                    {item.diff.summary}
                  </Text>
                )}
                {}
                {item.diff.items && (
                  <>
                    {item.diff.items.added?.length > 0 && (
                      <>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.success,
                            fontWeight: '600',
                            marginBottom: 6,
                          }}
                        >
                          Productos agregados:
                        </Text>
                        {item.diff.items.added.map(
                          (addedItem: any, idx: number) => (
                            <View
                              key={`added-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.success + '50',
                                backgroundColor: theme.colors.surface,
                                padding: 8,
                                marginLeft: 4,
                                borderRadius: 4,
                              }}
                            >
                              <Text
                                variant="bodySmall"
                                style={{ fontWeight: '600' }}
                              >
                                {addedItem.productName}
                                {addedItem.variantName
                                  ? ` - ${addedItem.variantName}`
                                  : ''}
                              </Text>
                              {(addedItem.modifiers?.length > 0 ||
                                addedItem.customizations?.length > 0 ||
                                addedItem.notes) && (
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    marginTop: 2,
                                    color: theme.colors.onSurfaceVariant,
                                  }}
                                >
                                  {[
                                    addedItem.modifiers?.length > 0 &&
                                      `Modificadores: ${addedItem.modifiers.join(', ')}`,
                                    addedItem.customizations?.length > 0 &&
                                      `Personalizaciones: ${addedItem.customizations.join(', ')}`,
                                    addedItem.notes &&
                                      `Notas: ${addedItem.notes}`,
                                  ]
                                    .filter(Boolean)
                                    .join(' • ')}
                                </Text>
                              )}
                              <Text
                                variant="labelSmall"
                                style={{
                                  marginTop: 4,
                                  color: theme.colors.primary,
                                  fontWeight: '600',
                                }}
                              >
                                Precio: $
                                {addedItem.finalPrice || addedItem.basePrice}
                              </Text>
                            </View>
                          ),
                        )}
                      </>
                    )}
                    {item.diff.items.removed?.length > 0 && (
                      <>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.error,
                            fontWeight: '600',
                            marginBottom: 6,
                            marginTop: 8,
                          }}
                        >
                          Productos eliminados:
                        </Text>
                        {item.diff.items.removed.map(
                          (removedItem: any, idx: number) => (
                            <View
                              key={`removed-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.error + '50',
                                backgroundColor: theme.colors.surface,
                                padding: 8,
                                marginLeft: 4,
                                borderRadius: 4,
                              }}
                            >
                              <Text
                                variant="bodySmall"
                                style={{
                                  textDecorationLine: 'line-through',
                                  color: theme.colors.error,
                                }}
                              >
                                {removedItem.productName}
                                {removedItem.variantName
                                  ? ` - ${removedItem.variantName}`
                                  : ''}
                              </Text>
                            </View>
                          ),
                        )}
                      </>
                    )}
                    {item.diff.items.modified?.length > 0 && (
                      <>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.warning || theme.colors.primary,
                            fontWeight: '600',
                            marginBottom: 6,
                            marginTop: 8,
                          }}
                        >
                          Productos modificados:
                        </Text>
                        {item.diff.items.modified.map(
                          (modifiedItem: any, idx: number) => (
                            <View
                              key={`modified-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor:
                                  (theme.colors.warning ||
                                    theme.colors.primary) + '50',
                                backgroundColor: theme.colors.surface,
                                padding: 8,
                                marginLeft: 4,
                                borderRadius: 4,
                              }}
                            >
                              <Text
                                variant="bodySmall"
                                style={{ fontWeight: '600' }}
                              >
                                {modifiedItem.productName}
                                {modifiedItem.variantName
                                  ? ` - ${modifiedItem.variantName}`
                                  : ''}
                              </Text>
                              {modifiedItem.changes &&
                                Object.entries(modifiedItem.changes).map(
                                  ([field, change]: [string, any]) => (
                                    <View key={field} style={{ marginTop: 4 }}>
                                      <Text
                                        variant="labelSmall"
                                        style={{
                                          color: theme.colors.onSurfaceVariant,
                                        }}
                                      >
                                        {formatFieldName(field)}:
                                      </Text>
                                      {renderChangeDetail(change, field)}
                                    </View>
                                  ),
                                )}
                            </View>
                          ),
                        )}
                      </>
                    )}
                  </>
                )}
              </View>
            )}
          {/* Contenido para items individuales */}
          {item.type === 'item' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <Text
                  variant="bodySmall"
                  style={{ color: theme.colors.success, marginBottom: 8 }}
                >
                  Item agregado:
                </Text>
              )}
              {item.operation === 'UPDATE' && item.formattedChanges && (
                <>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                    }}
                  >
                    Cambios en el item:
                  </Text>
                  {Object.entries(item.formattedChanges).map(
                    ([field, change]) => (
                      <View key={field} style={{ marginBottom: 8 }}>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.onSurfaceVariant,
                            fontWeight: '600',
                            marginBottom: 4,
                          }}
                        >
                          {field}:
                        </Text>
                        {renderChangeDetail(change, field)}
                      </View>
                    ),
                  )}
                </>
              )}
              {item.operation === 'DELETE' && (
                <Text
                  variant="bodySmall"
                  style={{ color: theme.colors.error, marginBottom: 8 }}
                >
                  Item eliminado:
                </Text>
              )}
              {}
              {(item.operation === 'INSERT' || item.operation === 'DELETE') &&
                item.itemDescription && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.onSurface,
                      backgroundColor: theme.colors.surface,
                      padding: 8,
                      borderRadius: 6,
                    }}
                  >
                    {item.itemDescription}
                  </Text>
                )}
            </View>
          )}
          {}
          {item.operation === 'BATCH' && item.batchOperations && (
            <View style={styles.changesContainer}>
              <Text
                variant="bodySmall"
                style={{
                  color: theme.colors.primary,
                  fontWeight: '600',
                  marginBottom: 8,
                }}
              >
                Cambios realizados en una sola edición:
              </Text>
              {item.batchOperations.map((op: any, idx: number) => (
                <View
                  key={idx}
                  style={{
                    marginBottom:
                      idx < item.batchOperations!.length - 1 ? 12 : 0,
                    paddingLeft: 8,
                    borderLeftWidth: 2,
                    borderLeftColor: theme.colors.primary + '30',
                    marginLeft: 4,
                  }}
                >
                  <View
                    style={{
                      flexDirection: 'row',
                      alignItems: 'flex-start',
                      marginBottom: 4,
                    }}
                  >
                    <Icon
                      name={getOperationIcon(op.operation)}
                      size={14}
                      color={theme.colors.primary}
                      style={{ marginRight: 6, marginTop: 2 }}
                    />
                    <View style={{ flex: 1 }}>
                      <Text
                        variant="labelSmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '500',
                          marginBottom: 4,
                        }}
                      >
                        {getOperationLabel(op.operation)}
                      </Text>
                      {}
                      {(op.itemDescription || op.snapshot?.itemDescription) && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.onSurface,
                            backgroundColor: theme.colors.surface,
                            padding: 6,
                            borderRadius: 4,
                          }}
                        >
                          {op.itemDescription || op.snapshot?.itemDescription}
                        </Text>
                      )}
                      {}
                      {op.operation === 'UPDATE' && op.formattedChanges && (
                        <View style={{ marginTop: 4 }}>
                          {Object.entries(op.formattedChanges)
                            .filter(([fieldName]) => {
                              const allowedFields = [
                                'Descripción del Item',
                                'Descripción',
                                'Estado',
                                'Notas de preparación',
                                'Estado de preparación',
                              ];
                              return allowedFields.some((allowed) =>
                                fieldName.includes(allowed),
                              );
                            })
                            .map(([field, change]) => (
                              <View key={field} style={{ marginBottom: 4 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.onSurfaceVariant,
                                    fontSize: 11,
                                  }}
                                >
                                  {field}:
                                </Text>
                                {renderChangeDetail(change, field)}
                              </View>
                            ))}
                        </View>
                      )}
                    </View>
                  </View>
                </View>
              ))}
            </View>
          )}
        </View>
      )}
    </Surface>
  );
};
export const OrderHistoryView: React.FC<OrderHistoryViewProps> = ({
  orderId,
  orderNumber,
  onBack,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const {
    data: historyData,
    isError,
    refetch,
    isLoading,
  } = useQuery({
    queryKey: ['combinedHistory', orderId],
    queryFn: async () => {
      if (!orderId) throw new Error('No order ID');
      const orderHistoryResponse = await apiClient.get(
        API_PATHS.ORDERS_HISTORY.replace(':orderId', orderId),
        {
          page: 1,
          limit: 100,
        },
      );
      const orderHistory =
        orderHistoryResponse.ok && orderHistoryResponse.data?.data
          ? orderHistoryResponse.data.data.map((item: any) => ({
              ...item,
              type: 'order' as const,
            }))
          : [];
      return orderHistory;
    },
    enabled: !!orderId,
    staleTime: 30000,
  });
  const renderHistoryItem = ({ item }: { item: HistoryItem }) => {
    return <HistoryItemComponent item={item} theme={theme} />;
  };
  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Icon
        name="history"
        size={48}
        color={theme.colors.onSurfaceDisabled}
        style={{ opacity: 0.5 }}
      />
      <Text
        variant="bodyLarge"
        style={{
          color: theme.colors.onSurfaceDisabled,
          marginTop: theme.spacing.m,
        }}
      >
        No hay historial disponible
      </Text>
      <Text
        variant="bodySmall"
        style={{
          color: theme.colors.onSurfaceVariant,
          marginTop: theme.spacing.s,
          textAlign: 'center',
        }}
      >
        Los cambios realizados en esta orden aparecerán aquí
      </Text>
    </View>
  );
  return (
    <View style={styles.container}>
      <Appbar.Header style={styles.header}>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content
          title={`Historial de Orden #${orderNumber || ''}`}
          subtitle={`${historyData?.length || 0} cambios registrados`}
        />
      </Appbar.Header>
      <View style={styles.content}>
        {isError ? (
          <View style={styles.emptyContainer}>
            <Icon
              name="alert-circle"
              size={48}
              color={theme.colors.error}
              style={{ opacity: 0.7 }}
            />
            <Text
              variant="bodyLarge"
              style={{
                color: theme.colors.error,
                marginTop: theme.spacing.m,
                textAlign: 'center',
              }}
            >
              Error al cargar el historial
            </Text>
            <Button
              onPress={() => refetch()}
              mode="text"
              style={{ marginTop: 16 }}
            >
              Reintentar
            </Button>
          </View>
        ) : isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando historial...</Text>
          </View>
        ) : (
          <FlatList
            data={historyData || []}
            renderItem={renderHistoryItem}
            keyExtractor={(item) => item.id.toString()}
            contentContainerStyle={styles.listContent}
            ListEmptyComponent={renderEmpty}
            showsVerticalScrollIndicator={false}
          />
        )}
      </View>
    </View>
  );
};
const createStyles = (theme: ReturnType<typeof useAppTheme>) => {
  return StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    content: {
      flex: 1,
    },
    listContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2,
    },
    loadingContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    historyItem: {
      padding: theme.spacing.s,
      marginBottom: theme.spacing.s,
      marginHorizontal: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 2,
    },
    historyHeader: {
    },
    expandedContent: {
      marginTop: theme.spacing.s,
      paddingTop: theme.spacing.s,
    },
    changesContainer: {
      marginTop: theme.spacing.xs,
    },
    changeDetail: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 4,
      flexWrap: 'wrap',
    },
    emptyContainer: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      padding: theme.spacing.xl,
    },
  });
};

================
File: app/src/modules/shiftAudit/hooks/useShiftSalesSummary.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
export interface ProductSalesSummary {
  productId: string;
  productName: string;
  quantity: number;
  totalAmount: number;
  averagePrice: number;
}
export interface SubcategorySalesSummary {
  subcategoryId: string;
  subcategoryName: string;
  quantity: number;
  totalAmount: number;
  products: ProductSalesSummary[];
}
export interface CategorySalesSummary {
  categoryId: string;
  categoryName: string;
  quantity: number;
  totalAmount: number;
  percentage: number;
  subcategories: SubcategorySalesSummary[];
}
export interface ShiftSalesSummary {
  shiftId: string;
  shiftNumber: number;
  date: string;
  totalSales: number;
  totalQuantity: number;
  completedOrders: number;
  averageTicket: number;
  categories: CategorySalesSummary[];
  topProducts: ProductSalesSummary[];
  startTime: string;
  endTime: string | null;
}
export function useShiftSalesSummary(shiftId: string | null) {
  return useQuery({
    queryKey: ['shiftSalesSummary', shiftId],
    queryFn: async () => {
      if (!shiftId) return null;
      const response = await apiClient.get(
        API_PATHS.ORDERS_BY_SHIFT_SALES_SUMMARY.replace(':shiftId', shiftId),
      );
      if (!response.ok) {
        throw new Error(
          response.problem || 'Error al obtener resumen de ventas',
        );
      }
      return response.data as ShiftSalesSummary;
    },
    enabled: !!shiftId,
  });
}

================
File: app/src/modules/users/screens/UsersListScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, Chip, Text } from 'react-native-paper';
import { useDrawerStatus } from '@react-navigation/drawer';
import GenericList from '@/app/components/crud/GenericList';
import { UserFormModal } from '../components/UserFormModal';
import { UserDetailModal } from '../components/UserDetailModal';
import { useListState } from '@/app/hooks/useListState';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useGetUsers, useDeleteUser } from '../hooks';
import type { User, UsersQuery } from '../types';
import { RoleEnum } from '../types';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
export function UsersListScreen() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const drawerStatus = useDrawerStatus();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedFilter, setSelectedFilter] = useState('all');
  const [isRefreshing, setIsRefreshing] = useState(false);
  const deleteUserMutation = useDeleteUser();
  const {
    isFormModalVisible,
    isDetailModalVisible,
    selectedItem,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
  } = useCrudScreenLogic<User>({
    entityName: 'Usuario',
    queryKey: ['users'],
    deleteMutationFn: async (id) => {
      await deleteUserMutation.mutateAsync(id);
    },
  });
  const queryParams: UsersQuery = {
    page: 1,
    limit: 100,
    search: searchQuery || undefined,
    filters:
      selectedFilter === 'all'
        ? undefined
        : selectedFilter === 'active'
          ? { isActive: true }
          : selectedFilter === 'inactive'
            ? { isActive: false }
            : selectedFilter === 'admin'
              ? { roles: [{ id: RoleEnum.ADMIN }] }
              : selectedFilter === 'user'
                ? { roles: [{ id: RoleEnum.WAITER }] }
                : undefined,
    sortBy: 'createdAt',
    sortOrder: 'DESC',
  };
  const { data, isLoading, error, refetch } = useGetUsers(queryParams);
  useRefreshModuleOnFocus('users');
  const getStatusColor = (user: User) => {
    return user.isActive ? 'success' : 'error';
  };
  const getStatusText = (user: User) => {
    return user.isActive ? 'Activo' : 'Inactivo';
  };
  const getUserDescription = (user: User) => {
    const parts = [];
    parts.push(`@${user.username}`);
    if (user.email) {
      parts.push(`\n${user.email}`);
    }
    if (user.role?.id === 5 && user.preparationScreen) {
      parts.push(`\nPantalla: ${user.preparationScreen.name}`);
    }
    return parts.join('');
  };
  // Mapear los usuarios para agregar campos calculados
  const mappedUsers = React.useMemo(() => {
    const users = data?.data || [];
    return users.map((user) => {
      const displayName =
        `${user.firstName || ''} ${user.lastName || ''}`.trim() ||
        user.username;
      const displayInfo = getUserDescription(user);
      return {
        ...user,
        displayName,
        displayInfo,
        displayNameWithRole: { name: displayName, roleId: user.role?.id },
        statusText: getStatusText(user),
        statusColor: getStatusColor(user),
      };
    });
  }, [data]);
  const handleCreateUser = () => {
    handleOpenCreateModal();
  };
  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: error ? true : false,
    data: mappedUsers,
    emptyConfig: {
      title: 'No hay usuarios',
      message: 'No hay usuarios registrados en el sistema',
      icon: 'account-multiple-outline',
      actionLabel: 'Agregar usuario',
      onAction: handleCreateUser,
    },
    errorConfig: {
      title: 'Error al cargar usuarios',
      message: 'No se pudieron cargar los usuarios. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onAction: refetch,
    },
  });
  const filterOptions = [
    { label: 'Todos', value: 'all' },
    { label: 'Activos', value: 'active' },
    { label: 'Inactivos', value: 'inactive' },
    { label: 'Administradores', value: 'admin' },
    { label: 'Usuarios', value: 'user' },
  ];
  const handleEditUser = (user: User) => {
    handleOpenEditModal(user);
  };
  const handleViewUser = (user: User) => {
    handleOpenDetailModal(user);
  };
  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };
  const getRoleChipProps = (roleId: number | undefined) => {
    switch (roleId) {
      case 1:
        return {
          label: 'Admin',
          icon: 'shield-account',
          color: theme.colors.error,
        };
      case 2:
        return {
          label: 'Gerente',
          icon: 'account-tie',
          color: theme.colors.primary,
        };
      case 3:
        return {
          label: 'Cajero',
          icon: 'cash-register',
          color: theme.colors.tertiary,
        };
      case 4:
        return {
          label: 'Mesero',
          icon: 'room-service',
          color: theme.colors.secondary,
        };
      case 5:
        return { label: 'Cocina', icon: 'chef-hat', color: '#FF6B6B' };
      case 6:
        return { label: 'Repartidor', icon: 'moped', color: '#4ECDC4' };
      default:
        return {
          label: 'Usuario',
          icon: 'account',
          color: theme.colors.onSurfaceVariant,
        };
    }
  };
  const renderDescription = (user: User) => {
    const roleProps = getRoleChipProps(user.role?.id);
    return (
      <View style={styles.descriptionContainer}>
        <View style={styles.userInfoRow}>
          <Text style={styles.username}>@{user.username}</Text>
          <Chip
            mode="flat"
            icon={roleProps.icon}
            style={[
              styles.roleChipInDescription,
              { backgroundColor: roleProps.color + '20' },
            ]}
            textStyle={[styles.roleChipText, { color: roleProps.color }]}
            compact
          >
            {roleProps.label}
          </Chip>
        </View>
        {user.email && (
          <Text style={styles.email} numberOfLines={1}>
            {user.email}
          </Text>
        )}
        {user.role?.id === 5 && user.preparationScreen && (
          <Text style={styles.screenInfo}>
            Pantalla: {user.preparationScreen.name}
          </Text>
        )}
      </View>
    );
  };
  const renderTitle = (user: User) => {
    const firstName = user.firstName || '';
    const lastName = user.lastName || '';
    const fullName = `${firstName} ${lastName}`.trim();
    const displayName = fullName || user.username;
    return (
      <View style={styles.titleContainer}>
        <Text style={styles.title} numberOfLines={1} ellipsizeMode="tail">
          {displayName}
        </Text>
      </View>
    );
  };
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContainer: {
      flex: 1,
    },
    titleContainer: {
      flex: 1,
      paddingRight: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
    },
    title: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 16,
      lineHeight: responsive.isTablet ? 18 : 22,
    },
    descriptionContainer: {
      flex: 1,
      gap: responsive.isTablet ? 2 : theme.spacing.xs / 2,
      paddingTop: responsive.isTablet ? 2 : theme.spacing.xs / 2,
    },
    userInfoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
      flexWrap: 'wrap',
    },
    username: {
      fontSize: responsive.isTablet ? 12 : 14,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
    },
    email: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.8,
    },
    screenInfo: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    roleChipInDescription: {
      minHeight: responsive.isTablet ? 20 : 28,
      height: 'auto',
      borderRadius: theme.roundness * 2,
      paddingHorizontal: responsive.isTablet ? 6 : responsive.spacing.s,
      paddingVertical: responsive.isTablet ? 1 : 4,
    },
    roleChipText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '600',
      lineHeight: responsive.isTablet ? 12 : 16,
      marginVertical: 0,
      paddingVertical: 0,
    },
  });
  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        <GenericList
          items={mappedUsers}
          isLoading={isLoading}
          isRefreshing={isRefreshing}
          onRefresh={handleRefresh}
          onItemPress={handleViewUser}
          ListEmptyComponent={ListEmptyComponent}
          listItemStyle={
            responsive.isTablet
              ? {
                  marginVertical: 1,
                  marginHorizontal: responsive.spacing.xs,
                }
              : undefined
          }
          listItemContentStyle={
            responsive.isTablet
              ? {
                  paddingVertical: 2,
                  minHeight: 36,
                }
              : undefined
          }
          contentContainerStyle={
            responsive.isTablet
              ? {
                  paddingTop: 2,
                  paddingBottom: 80,
                }
              : undefined
          }
          renderConfig={{
            titleField: 'displayName' as any,
            descriptionField: 'displayInfo' as any,
            statusConfig: {
              field: 'isActive' as any,
              activeValue: true,
              activeLabel: 'Activo',
              inactiveLabel: 'Inactivo',
            },
            renderTitle: renderTitle,
            renderDescription: renderDescription,
          }}
          enableSearch={true}
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          searchPlaceholder="Buscar por nombre, email o usuario..."
          filterOptions={filterOptions}
          filterValue={selectedFilter}
          onFilterChange={(value) => setSelectedFilter(value as string)}
          showFab={true}
          onFabPress={handleCreateUser}
          fabIcon="account-plus"
          fabLabel="Nuevo Usuario"
          fabVisible={drawerStatus === 'closed'}
          showImagePlaceholder={false}
          isDrawerOpen={drawerStatus === 'open'}
        />
      </View>
      <Portal>
        {isFormModalVisible && (
          <UserFormModal
            visible={isFormModalVisible}
            onDismiss={handleCloseModals}
            user={editingItem}
          />
        )}
        {isDetailModalVisible && selectedItem && (
          <UserDetailModal
            visible={isDetailModalVisible}
            onDismiss={handleCloseModals}
            user={selectedItem}
            onEdit={handleEditUser}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
}

================
File: app/src/services/audioOrderService.ts
================
import apiClient from '../app/services/apiClient';
import * as FileSystem from 'expo-file-system';
import { API_PATHS } from '@/app/constants/apiPaths';
export interface AIOrderItem {
  productId: string;
  productName?: string;
  variantId?: string;
  variantName?: string;
  quantity: number;
  modifiers?: string[];
  pizzaCustomizations?: Array<{
    customizationId: string;
    customizationName?: string;
    half: 'FULL' | 'HALF_1' | 'HALF_2';
    action: 'ADD' | 'REMOVE';
  }>;
}
export interface DeliveryInfoData {
  fullAddress?: string;
  recipientName?: string;
  recipientPhone?: string;
}
export interface ScheduledDeliveryData {
  time?: string;
}
export interface AudioOrderResponse {
  success: boolean;
  data?: {
    orderItems?: AIOrderItem[];
    deliveryInfo?: DeliveryInfoData;
    scheduledDelivery?: ScheduledDeliveryData;
    orderType?: 'DELIVERY' | 'TAKE_AWAY' | 'DINE_IN';
    warnings?: string;
    processingTime: number;
  };
  error?: {
    code: string;
    message: string;
    type: string;
    timestamp: string;
    requestId: string;
  };
}
class AudioOrderService {
  constructor() {
  }
  async processAudioOrder(
    audioUri: string,
    transcription: string,
  ): Promise<AudioOrderResponse> {
    try {
      const audioBase64 = await FileSystem.readAsStringAsync(audioUri, {
        encoding: FileSystem.EncodingType.Base64,
      });
      const payload = {
        audioData: audioBase64,
        transcription: transcription,
        audioFormat: 'audio/mp4',
      };
      const response = await apiClient.post(
        API_PATHS.AUDIO_ORDERS_PROCESS,
        payload,
        { timeout: 60000 },
      );
      const responseData = response.data as any;
      if (responseData.success) {
        return {
          success: true,
          data: responseData.extractedData || {
            orderItems: [],
            deliveryInfo: {},
            scheduledDelivery: {},
            orderType: 'DELIVERY',
            warnings: undefined,
            processingTime: 0,
          },
        };
      } else {
        throw new Error(
          responseData.error?.message ||
            responseData.message ||
            'Error procesando audio',
        );
      }
    } catch (error: any) {
      return {
        success: false,
        error: {
          code: error.response?.data?.error?.code || 'PROCESSING_ERROR',
          message: this.getErrorMessage(error),
          type: 'error',
          timestamp: new Date().toISOString(),
          requestId: 'local-' + Date.now(),
        },
      };
    }
  }
  getErrorMessage(error: any): string {
    if (error.response?.data?.error) {
      const apiError = error.response.data.error;
      switch (apiError.code) {
        case 'BL015':
          return 'El archivo de audio es muy grande. Máximo 10MB.';
        case 'AUTH001':
          return 'Error de autenticación. Contacta al administrador.';
        case 'BL016':
          return 'No se pudo procesar el audio. Intenta de nuevo.';
        case 'BL002':
          return 'Faltan datos requeridos.';
        default:
          return apiError.message || 'Error desconocido';
      }
    }
    return error.message || 'Error al procesar la orden por voz';
  }
  validateBeforeSending(
    audioFileSize: number,
    transcription: string,
  ): string[] {
    const errors: string[] = [];
    if (audioFileSize > 50 * 1024 * 1024) {
      errors.push('El archivo de audio es muy grande (máximo 50MB)');
    }
    if (!transcription || transcription.trim().length < 5) {
      errors.push('La transcripción está vacía o es muy corta');
    }
    return errors;
  }
}
export const audioOrderService = new AudioOrderService();

================
File: backend/src/customers/customers.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus,
  HttpCode,
  UseGuards,
  NotFoundException,
} from '@nestjs/common';
import { CustomersService } from './customers.service';
import { AddressesService } from './addresses.service';
import { CreateCustomerDto } from './dto/create-customer.dto';
import { UpdateCustomerDto } from './dto/update-customer.dto';
import { FindAllCustomersDto } from './dto/find-all-customers.dto';
import { BanCustomerDto } from './dto/ban-customer.dto';
import { CreateAddressDto } from './dto/create-address.dto';
import { UpdateAddressDto } from './dto/update-address.dto';
import { FindAllAddressesDto } from './dto/find-all-addresses.dto';
import { Address } from './domain/address';
import {
  ApiBearerAuth,
  ApiOperation,
  ApiParam,
  ApiTags,
  ApiBody,
} from '@nestjs/swagger';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { Customer } from './domain/customer';
@ApiTags('Customers')
@Controller({ path: 'customers', version: '1' })
export class CustomersController {
  constructor(
    private readonly customersService: CustomersService,
    private readonly addressesService: AddressesService,
  ) {}
  @Post()
  @ApiOperation({ summary: 'Create a new customer' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createCustomerDto: CreateCustomerDto): Promise<Customer> {
    return this.customersService.create(createCustomerDto);
  }
  @Get()
  @ApiOperation({ summary: 'Find all customers' })
  @HttpCode(HttpStatus.OK)
  findAll(@Query() query: FindAllCustomersDto): Promise<Customer[]> {
    return this.customersService.findAll(query);
  }
  @Get(':id')
  @ApiOperation({ summary: 'Find one customer by ID' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @HttpCode(HttpStatus.OK)
  findOne(@Param('id') id: string): Promise<Customer> {
    return this.customersService.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({ summary: 'Update a customer' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  update(
    @Param('id') id: string,
    @Body() updateCustomerDto: UpdateCustomerDto,
  ): Promise<Customer> {
    return this.customersService.update(id, updateCustomerDto);
  }
  @Delete(':id')
  @ApiOperation({ summary: 'Remove a customer' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async remove(@Param('id') id: string): Promise<void> {
    await this.customersService.remove(id);
  }
  @Post(':id/chat-message')
  @ApiOperation({ summary: 'Append a message to customer chat history' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        role: { type: 'string', enum: ['user', 'assistant', 'system'] },
        content: { type: 'string' },
      },
      required: ['role', 'content'],
    },
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  appendChatMessage(
    @Param('id') id: string,
    @Body() message: { role: 'user' | 'assistant' | 'system'; content: string },
  ): Promise<Customer> {
    return this.customersService.appendToChatHistory(id, message);
  }
  @Patch(':id/relevant-chat-history')
  @ApiOperation({ summary: 'Update relevant chat history for a customer' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        relevantHistory: { type: 'array', items: { type: 'object' } },
      },
      required: ['relevantHistory'],
    },
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  updateRelevantHistory(
    @Param('id') id: string,
    @Body() body: { relevantHistory: any[] },
  ): Promise<Customer> {
    return this.customersService.updateRelevantChatHistory(
      id,
      body.relevantHistory,
    );
  }
  @Patch(':id/stats')
  @ApiOperation({ summary: 'Update customer statistics' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        totalOrders: { type: 'number' },
        totalSpent: { type: 'number' },
      },
    },
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  updateStats(
    @Param('id') id: string,
    @Body() stats: { totalOrders?: number; totalSpent?: number },
  ): Promise<Customer> {
    return this.customersService.updateCustomerStats(id, stats);
  }
  @Get('active/recent')
  @ApiOperation({ summary: 'Get active customers with recent interactions' })
  @ApiParam({
    name: 'daysAgo',
    required: false,
    description: 'Number of days to look back (default: 30)',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  getActiveWithRecentInteraction(
    @Query('daysAgo') daysAgo?: number,
  ): Promise<Customer[]> {
    const days = daysAgo ? Number(daysAgo) : 30;
    return this.customersService.getActiveCustomersWithRecentInteraction(days);
  }
  @Post(':id/ban')
  @ApiOperation({ summary: 'Ban a customer' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  banCustomer(
    @Param('id') id: string,
    @Body() banCustomerDto: BanCustomerDto,
  ): Promise<Customer> {
    return this.customersService.banCustomer(id, banCustomerDto.banReason);
  }
  @Post(':id/unban')
  @ApiOperation({ summary: 'Unban a customer' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  unbanCustomer(@Param('id') id: string): Promise<Customer> {
    return this.customersService.unbanCustomer(id);
  }
  @Get('banned/list')
  @ApiOperation({ summary: 'Get all banned customers' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  getBannedCustomers(): Promise<Customer[]> {
    return this.customersService.getBannedCustomers();
  }
  @Post(':id/addresses')
  @ApiOperation({ summary: 'Add an address to a customer' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.CREATED)
  async addAddress(
    @Param('id') customerId: string,
    @Body() createAddressDto: CreateAddressDto,
  ): Promise<Address> {
    const addressData = {
      ...createAddressDto,
      customerId,
    };
    return this.addressesService.create(addressData);
  }
  @Get(':id/addresses')
  @ApiOperation({ summary: 'Get all addresses for a customer' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @HttpCode(HttpStatus.OK)
  async getCustomerAddresses(
    @Param('id') customerId: string,
  ): Promise<Address[]> {
    await this.customersService.findOne(customerId);
    const filter: FindAllAddressesDto = { customerId };
    return this.addressesService.findAll(filter);
  }
  @Patch(':id/addresses/:addressId')
  @ApiOperation({ summary: 'Update a customer address' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiParam({ name: 'addressId', description: 'Address ID' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.OK)
  async updateAddress(
    @Param('id') customerId: string,
    @Param('addressId') addressId: string,
    @Body() updateAddressDto: UpdateAddressDto,
  ): Promise<Address> {
    const address = await this.addressesService.findOne(addressId);
    if (address.customerId !== customerId) {
      throw new NotFoundException('Address not found for this customer');
    }
    const updatedAddress = await this.addressesService.update(
      addressId,
      updateAddressDto,
    );
    if (!updatedAddress) {
      throw new NotFoundException('Address not found');
    }
    return updatedAddress;
  }
  @Delete(':id/addresses/:addressId')
  @ApiOperation({ summary: 'Delete a customer address' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiParam({ name: 'addressId', description: 'Address ID' })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  @HttpCode(HttpStatus.NO_CONTENT)
  async deleteAddress(
    @Param('id') customerId: string,
    @Param('addressId') addressId: string,
  ): Promise<void> {
    const address = await this.addressesService.findOne(addressId);
    if (address.customerId !== customerId) {
      throw new NotFoundException('Address not found for this customer');
    }
    await this.addressesService.remove(addressId);
  }
}

================
File: backend/src/kitchen/services/kitchen.service.ts
================
import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  BadRequestException,
  Inject,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';
import { OrderEntity } from '../../orders/infrastructure/persistence/relational/entities/order.entity';
import { OrderItemEntity } from '../../orders/infrastructure/persistence/relational/entities/order-item.entity';
import { UserEntity } from '../../users/infrastructure/persistence/relational/entities/user.entity';
import { KitchenOrderFilterDto } from '../dto/kitchen-order-filter.dto';
import {
  KitchenOrderOptimizedDto,
  KitchenOrderItemOptimizedDto,
  ScreenStatusOptimizedDto,
} from '../dto/kitchen-order-optimized.dto';
import { OrderStatus } from '../../orders/domain/enums/order-status.enum';
import { PreparationStatus } from '../../orders/domain/order-item';
import { OrderType } from '../../orders/domain/enums/order-type.enum';
import { ORDER_PREPARATION_SCREEN_STATUS_REPOSITORY } from '../../common/tokens';
import { OrderPreparationScreenStatusRepository } from '../../orders/infrastructure/persistence/order-preparation-screen-status.repository';
import { PreparationScreenStatus } from '../../orders/domain/order-preparation-screen-status';
@Injectable()
export class KitchenService {
  constructor(
    @InjectRepository(OrderEntity)
    private readonly orderRepository: Repository<OrderEntity>,
    @InjectRepository(OrderItemEntity)
    private readonly orderItemRepository: Repository<OrderItemEntity>,
    @InjectRepository(UserEntity)
    private readonly userRepository: Repository<UserEntity>,
    @Inject(ORDER_PREPARATION_SCREEN_STATUS_REPOSITORY)
    private readonly screenStatusRepository: OrderPreparationScreenStatusRepository,
  ) {}
  async getKitchenOrders(
    userId: string,
    filters: KitchenOrderFilterDto,
  ): Promise<KitchenOrderOptimizedDto[]> {
    let userScreenId: string | null = null;
    if (!filters.screenId) {
      const user = await this.userRepository.findOne({
        where: { id: userId },
        relations: ['preparationScreen'],
      });
      if (!user || !user.preparationScreen) {
        userScreenId = null;
      } else {
        userScreenId = user.preparationScreen.id;
      }
    } else {
      userScreenId = filters.screenId;
    }
    const queryBuilder = this.orderRepository
      .createQueryBuilder('o')
      .leftJoinAndSelect('o.orderItems', 'orderItem')
      .leftJoinAndSelect('orderItem.product', 'product')
      .leftJoinAndSelect('orderItem.productVariant', 'variant')
      .leftJoinAndSelect('orderItem.productModifiers', 'modifiers')
      .leftJoinAndSelect(
        'orderItem.selectedPizzaCustomizations',
        'pizzaCustomizations',
      )
      .leftJoinAndSelect(
        'pizzaCustomizations.pizzaCustomization',
        'customization',
      )
      .leftJoinAndSelect('orderItem.preparedBy', 'preparedBy')
      .leftJoinAndSelect('o.table', 'table')
      .leftJoinAndSelect('table.area', 'area')
      .leftJoinAndSelect('o.customer', 'customer')
      .leftJoinAndSelect('o.deliveryInfo', 'deliveryInfo')
      .where('1=1');
    if (filters.orderType) {
      queryBuilder.andWhere('o.orderType = :orderType', {
        orderType: filters.orderType,
      });
    }
    if (!filters.showAllProducts) {
      queryBuilder.andWhere(
        (qb) => {
          const subQuery = qb
            .subQuery()
            .select('oi.order_id')
            .from('order_item', 'oi')
            .innerJoin('product', 'p', 'oi.product_id = p.id')
            .where('p.preparation_screen_id = :screenId')
            .getQuery();
          return `o.id IN ${subQuery}`;
        },
        { screenId: userScreenId },
      );
    }
    queryBuilder.andWhere('o.orderStatus NOT IN (:...excludedStatuses)', {
      excludedStatuses: [OrderStatus.COMPLETED, OrderStatus.CANCELLED],
    });
    queryBuilder.orderBy('o.createdAt', 'ASC');
    const orders = await queryBuilder.getMany();
    const orderIds = orders.map((order) => order.id);
    const screenStatuses = await this.getScreenStatusesForOrders(orderIds);
    const filteredOrders = orders.filter((order) => {
      const screenStatus = screenStatuses.get(order.id)?.get(userScreenId!);
      if (filters.showPrepared) {
        return screenStatus?.status === PreparationScreenStatus.READY;
      } else {
        return (
          !screenStatus || screenStatus.status !== PreparationScreenStatus.READY
        );
      }
    });
    return filteredOrders.map((order) =>
      this.transformToKitchenOrderOptimized(
        order,
        userScreenId!,
        filters,
        screenStatuses.get(order.id) || new Map(),
      ),
    );
  }
  private async getScreenStatusesForOrders(
    orderIds: string[],
  ): Promise<Map<string, Map<string, any>>> {
    if (!orderIds.length) return new Map();
    const statusMap = new Map<string, Map<string, any>>();
    const allStatuses: any[] = [];
    for (const orderId of orderIds) {
      const statuses = await this.screenStatusRepository.findByOrderId(orderId);
      allStatuses.push(...statuses);
    }
    for (const orderId of orderIds) {
      const orderStatuses = allStatuses.filter((s) => s.orderId === orderId);
      const orderStatusMap = new Map<string, any>();
      orderStatuses.forEach((status) => {
        orderStatusMap.set(status.preparationScreenId, status);
      });
      statusMap.set(orderId, orderStatusMap);
    }
    return statusMap;
  }
  private transformToKitchenOrderOptimized(
    order: OrderEntity,
    userScreenId: string,
    filters: KitchenOrderFilterDto,
    screenStatuses: Map<string, any>,
  ): KitchenOrderOptimizedDto {
    const dto = new KitchenOrderOptimizedDto();
    dto.id = order.id;
    dto.shiftOrderNumber = order.shiftOrderNumber;
    dto.orderType = order.orderType;
    dto.orderStatus = order.orderStatus;
    dto.createdAt = order.createdAt;
    dto.orderNotes = order.notes || undefined;
    switch (order.orderType) {
      case OrderType.DELIVERY:
        if (order.deliveryInfo) {
          dto.deliveryAddress = order.deliveryInfo.fullAddress;
          dto.deliveryPhone = order.deliveryInfo.recipientPhone;
        }
        break;
      case OrderType.TAKE_AWAY:
        if (order.customer) {
          dto.receiptName =
            `${order.customer.firstName || ''} ${order.customer.lastName || ''}`.trim() ||
            'Cliente';
          dto.customerPhone = order.customer.whatsappPhoneNumber;
        }
        break;
      case OrderType.DINE_IN:
        dto.areaName = order.table?.area?.name;
        dto.tableName = order.table?.name;
        break;
    }
    const itemGroups = this.groupOrderItems(
      order.orderItems || [],
      filters.ungroupProducts || false,
    );
    dto.items = itemGroups
      .map((group) => {
        const item = group.items[0];
        if (!item.product) {
          return null;
        }
        const itemDto = new KitchenOrderItemOptimizedDto();
        itemDto.id = group.items.map((i) => i.id).join(',');
        itemDto.productName = item.product.name;
        itemDto.variantName = item.productVariant?.name;
        itemDto.modifiers = item.productModifiers?.map((m) => m.name) || [];
        if (item.selectedPizzaCustomizations?.length) {
          itemDto.pizzaCustomizations = item.selectedPizzaCustomizations.map(
            (pc) => ({
              customizationName: pc.pizzaCustomization.name,
              action: pc.action,
              half: pc.half,
            }),
          );
        }
        itemDto.preparationNotes = item.preparationNotes || undefined;
        itemDto.preparationStatus = item.preparationStatus;
        itemDto.preparedAt = item.preparedAt || undefined;
        if (item.preparedBy) {
          itemDto.preparedByUser = {
            firstName: item.preparedBy.firstName || '',
            lastName: item.preparedBy.lastName || '',
          };
        }
        itemDto.quantity = group.items.length;
        itemDto.belongsToMyScreen = userScreenId
          ? item.product.preparationScreenId === userScreenId
          : true;
        return itemDto;
      })
      .filter((item): item is KitchenOrderItemOptimizedDto => item !== null);
    // Filtrar items según configuración
    if (!filters.showAllProducts) {
      dto.items = dto.items.filter((item) => item.belongsToMyScreen);
    }
    dto.hasPendingItems = dto.items.some(
      (item) =>
        item.belongsToMyScreen &&
        item.preparationStatus !== PreparationStatus.READY,
    );
    // Agregar información optimizada de estados por pantalla
    dto.screenStatuses = [];
    for (const [, status] of screenStatuses) {
      if (status.preparationScreen) {
        const screenStatusDto = new ScreenStatusOptimizedDto();
        screenStatusDto.screenId = status.preparationScreenId;
        screenStatusDto.screenName = status.preparationScreen.name;
        screenStatusDto.status = status.status;
        dto.screenStatuses.push(screenStatusDto);
      }
    }
    // Agregar el estado de mi pantalla
    const myScreenStatus = screenStatuses.get(userScreenId);
    dto.myScreenStatus =
      myScreenStatus?.status || PreparationScreenStatus.PENDING;
    return dto;
  }
  private groupOrderItems(
    items: OrderItemEntity[],
    ungroup: boolean,
  ): { items: OrderItemEntity[] }[] {
    if (ungroup) {
      return items.map((item) => ({ items: [item] }));
    }
    const groups: Map<string, OrderItemEntity[]> = new Map();
    items.forEach((item) => {
      const key = this.getItemGroupKey(item);
      const group = groups.get(key) || [];
      group.push(item);
      groups.set(key, group);
    });
    return Array.from(groups.values()).map((items) => ({ items }));
  }
  private getItemGroupKey(item: OrderItemEntity): string {
    const parts = [
      item.productId,
      item.productVariantId || 'no-variant',
      item.preparationStatus,
      item.preparationNotes || 'no-notes',
      (item.productModifiers || [])
        .map((m) => m.id)
        .sort()
        .join(','),
      (item.selectedPizzaCustomizations || [])
        .map((pc) => `${pc.pizzaCustomizationId}-${pc.action}-${pc.half}`)
        .sort()
        .join(','),
    ];
    return parts.join('|');
  }
  async markItemPrepared(
    itemId: string,
    userId: string,
    isPrepared: boolean = true,
  ): Promise<void> {
    const itemIds = itemId.split(',');
    const items = await this.orderItemRepository.find({
      where: { id: In(itemIds) },
      relations: [
        'product',
        'order',
        'order.orderItems',
        'order.orderItems.product',
      ],
    });
    if (items.length === 0) {
      throw new NotFoundException('Order items not found');
    }
    const orderIds = [...new Set(items.map((item) => item.order.id))];
    if (orderIds.length > 1) {
      throw new BadRequestException(
        'Los items pertenecen a diferentes órdenes',
      );
    }
    const order = items[0].order;
    const screenId = items[0].product?.preparationScreenId;
    if (!screenId) {
      throw new BadRequestException(
        'El producto no tiene pantalla de preparación asignada',
      );
    }
    const screenStatus = await this.screenStatusRepository.findByOrderAndScreen(
      order.id,
      screenId,
    );
    if (
      !screenStatus ||
      screenStatus.status !== PreparationScreenStatus.IN_PREPARATION
    ) {
      throw new BadRequestException(
        'Solo se pueden modificar los items cuando la pantalla está en preparación',
      );
    }
    if (isPrepared) {
      const allItemsInProgress = items.every(
        (item) => item.preparationStatus === PreparationStatus.IN_PROGRESS,
      );
      if (!allItemsInProgress) {
        throw new BadRequestException(
          'Solo se pueden marcar como preparados los items que están en preparación (IN_PROGRESS)',
        );
      }
    }
    if (!isPrepared) {
      const allItemsReady = items.every(
        (item) => item.preparationStatus === PreparationStatus.READY,
      );
      if (!allItemsReady) {
        throw new BadRequestException(
          'Solo se pueden regresar a preparación los items que están listos (READY)',
        );
      }
    }
    const preparationScreenId = items[0].product.preparationScreenId;
    if (!preparationScreenId) {
      throw new ForbiddenException(
        'El producto no tiene pantalla de preparación asignada',
      );
    }
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['preparationScreen'],
    });
    if (
      !user ||
      !user.preparationScreen ||
      user.preparationScreen.id !== preparationScreenId
    ) {
      throw new ForbiddenException(
        'No tienes acceso a esta pantalla de preparación',
      );
    }
    const updates = items.map((item) => {
      item.preparationStatus = isPrepared
        ? PreparationStatus.READY
        : PreparationStatus.IN_PROGRESS;
      item.statusChangedAt = new Date();
      if (isPrepared) {
        item.preparedAt = new Date();
        item.preparedById = userId;
      } else {
        item.preparedAt = null;
        item.preparedById = null;
      }
      return item;
    });
    await this.orderItemRepository.save(updates);
  }
  async getUserDefaultScreen(userId: string): Promise<any> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['preparationScreen', 'role'],
    });
    return user?.preparationScreen || null;
  }
  async startPreparationForScreen(
    orderId: string,
    userId: string,
  ): Promise<void> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['preparationScreen'],
    });
    if (!user?.preparationScreen) {
      throw new ForbiddenException(
        'No tienes una pantalla de preparación asignada',
      );
    }
    const screenId = user.preparationScreen.id;
    await this.screenStatusRepository.createOrUpdate(orderId, screenId, {
      status: PreparationScreenStatus.IN_PREPARATION,
      startedAt: new Date(),
      startedById: userId,
    });
    await this.updateItemsForScreenStatus(
      orderId,
      screenId,
      PreparationStatus.IN_PROGRESS,
      userId,
    );
    await this.updateOrderStatusBasedOnScreens(orderId);
  }
  async completePreparationForScreen(
    orderId: string,
    userId: string,
  ): Promise<void> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['preparationScreen'],
    });
    if (!user?.preparationScreen) {
      throw new ForbiddenException(
        'No tienes una pantalla de preparación asignada',
      );
    }
    const screenId = user.preparationScreen.id;
    await this.screenStatusRepository.createOrUpdate(orderId, screenId, {
      status: PreparationScreenStatus.READY,
      completedAt: new Date(),
      completedById: userId,
    });
    await this.updateItemsForScreenStatus(
      orderId,
      screenId,
      PreparationStatus.READY,
      userId,
    );
    await this.updateOrderStatusBasedOnScreens(orderId);
  }
  async cancelPreparationForScreen(
    orderId: string,
    userId: string,
  ): Promise<void> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['preparationScreen'],
    });
    if (!user?.preparationScreen) {
      throw new ForbiddenException(
        'No tienes una pantalla de preparación asignada',
      );
    }
    const screenId = user.preparationScreen.id;
    const currentStatus =
      await this.screenStatusRepository.findByOrderAndScreen(orderId, screenId);
    if (currentStatus) {
      if (currentStatus.status === PreparationScreenStatus.IN_PREPARATION) {
        await this.screenStatusRepository.update(currentStatus.id, {
          status: PreparationScreenStatus.PENDING,
          startedAt: null,
          startedById: null,
        });
        await this.updateItemsForScreenStatus(
          orderId,
          screenId,
          PreparationStatus.PENDING,
          null,
        );
      } else if (currentStatus.status === PreparationScreenStatus.READY) {
        await this.screenStatusRepository.update(currentStatus.id, {
          status: PreparationScreenStatus.IN_PREPARATION,
          completedAt: null,
          completedById: null,
        });
        await this.updateItemsForScreenStatus(
          orderId,
          screenId,
          PreparationStatus.IN_PROGRESS,
          userId,
        );
      }
    }
    await this.updateOrderStatusBasedOnScreens(orderId);
  }
  private async updateItemsForScreenStatus(
    orderId: string,
    screenId: string,
    newStatus: PreparationStatus,
    userId: string | null,
  ): Promise<void> {
    const items = await this.orderItemRepository.find({
      where: {
        order: { id: orderId },
        product: { preparationScreenId: screenId },
      },
      relations: ['product'],
    });
    const updates = items.map((item) => {
      item.preparationStatus = newStatus;
      item.statusChangedAt = new Date();
      if (newStatus === PreparationStatus.READY) {
        item.preparedAt = new Date();
        item.preparedById = userId;
      } else if (newStatus === PreparationStatus.IN_PROGRESS) {
        item.preparedAt = null;
        item.preparedById = null;
      } else if (newStatus === PreparationStatus.PENDING) {
        item.preparedAt = null;
        item.preparedById = null;
      }
      return item;
    });
    if (updates.length > 0) {
      await this.orderItemRepository.save(updates);
    }
  }
  private async updateOrderStatusBasedOnScreens(
    orderId: string,
  ): Promise<void> {
    const screenStatuses =
      await this.screenStatusRepository.findByOrderId(orderId);
    const order = await this.orderRepository.findOne({
      where: { id: orderId },
      relations: ['orderItems', 'orderItems.product'],
    });
    if (!order) return;
    const screenIds = new Set<string>();
    order.orderItems?.forEach((item) => {
      if (item.product?.preparationScreenId) {
        screenIds.add(item.product.preparationScreenId);
      }
    });
    if (screenIds.size === 0) return;
    let allReady = true;
    let anyInPreparation = false;
    for (const screenId of screenIds) {
      const status = screenStatuses.find(
        (s) => s.preparationScreenId === screenId,
      );
      if (!status || status.status !== PreparationScreenStatus.READY) {
        allReady = false;
      }
      if (status?.status === PreparationScreenStatus.IN_PREPARATION) {
        anyInPreparation = true;
      }
    }
    let newOrderStatus = order.orderStatus;
    if (allReady) {
      newOrderStatus = OrderStatus.READY;
    } else if (anyInPreparation) {
      newOrderStatus = OrderStatus.IN_PREPARATION;
    } else if (
      order.orderStatus === OrderStatus.READY ||
      order.orderStatus === OrderStatus.IN_PREPARATION
    ) {
      newOrderStatus = OrderStatus.IN_PROGRESS;
    }
    if (newOrderStatus !== order.orderStatus) {
      await this.orderRepository.save({
        ...order,
        orderStatus: newOrderStatus,
      });
    }
  }
}

================
File: backend/src/orders/infrastructure/persistence/relational/mappers/ticket-impression.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { OrderEntity } from '../entities/order.entity';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { TicketImpression } from '../../../../domain/ticket-impression';
import { TicketImpressionEntity } from '../entities/ticket-impression.entity';
import { UserMapper } from '../../../../../users/infrastructure/persistence/relational/mappers/user.mapper';
import { BaseMapper } from '../../../../../common/mappers/base.mapper';
import { ThermalPrinterEntity } from '../../../../../thermal-printers/infrastructure/persistence/relational/entities/thermal-printer.entity';
@Injectable()
export class TicketImpressionMapper extends BaseMapper<
  TicketImpressionEntity,
  TicketImpression
> {
  constructor(private readonly userMapper: UserMapper) {
    super();
  }
  override toDomain(entity: TicketImpressionEntity): TicketImpression | null {
    if (!entity) return null;
    const domain = new TicketImpression();
    domain.id = entity.id;
    domain.orderId = entity.orderId;
    domain.userId = entity.userId;
    domain.printerId = entity.printerId;
    domain.ticketType = entity.ticketType;
    domain.impressionTime = entity.impressionTime;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    domain.user = entity.user ? this.userMapper.toDomain(entity.user) : null;
    domain.printer = entity.printer
      ? {
          id: entity.printer.id,
          name: entity.printer.name,
          ipAddress: entity.printer.ipAddress,
          port: entity.printer.port,
          connectionType: entity.printer.connectionType,
          isActive: entity.printer.isActive,
          isDefaultPrinter: entity.printer.isDefaultPrinter,
          paperWidth: entity.printer.paperWidth,
          feedLines: entity.printer.feedLines,
          cutPaper: entity.printer.cutPaper,
          autoPickupPrint: entity.printer.autoPickupPrint,
          autoDeliveryPrint: entity.printer.autoDeliveryPrint,
          path: entity.printer.path || null,
          macAddress: entity.printer.macAddress || null,
          charactersPerLine: entity.printer.charactersPerLine || 48,
          createdAt: entity.printer.createdAt,
          updatedAt: entity.printer.updatedAt,
          deletedAt: entity.printer.deletedAt,
        }
      : null;
    return domain;
  }
  override toEntity(domain: TicketImpression): TicketImpressionEntity | null {
    if (!domain) return null;
    const entity = new TicketImpressionEntity();
    if (domain.id) entity.id = domain.id;
    entity.order = { id: domain.orderId } as OrderEntity;
    entity.user = { id: domain.userId } as UserEntity;
    entity.printerId = domain.printerId;
    if (domain.printerId) {
      entity.printer = { id: domain.printerId } as ThermalPrinterEntity;
    }
    entity.ticketType = domain.ticketType;
    entity.impressionTime = domain.impressionTime;
    return entity;
  }
}

================
File: backend/src/restaurant-config/infrastructure/persistence/relational/mappers/restaurant-config.mapper.ts
================
import { Injectable } from '@nestjs/common';
import { RestaurantConfig } from '../../../../domain/restaurant-config';
import { RestaurantConfigEntity } from '../entities/restaurant-config.entity';
import { BusinessHoursMapper } from './business-hours.mapper';
import { mapArray } from '../../../../../common/mappers/base.mapper';
@Injectable()
export class RestaurantConfigMapper {
  constructor(private readonly businessHoursMapper: BusinessHoursMapper) {}
  toDomain(raw: RestaurantConfigEntity): RestaurantConfig {
    const domainEntity = new RestaurantConfig();
    domainEntity.id = raw.id;
    domainEntity.restaurantName = raw.restaurantName;
    domainEntity.phoneMain = raw.phoneMain;
    domainEntity.phoneSecondary = raw.phoneSecondary;
    domainEntity.address = raw.address;
    domainEntity.city = raw.city;
    domainEntity.state = raw.state;
    domainEntity.postalCode = raw.postalCode;
    domainEntity.country = raw.country;
    domainEntity.acceptingOrders = raw.acceptingOrders;
    domainEntity.estimatedPickupTime = raw.estimatedPickupTime;
    domainEntity.estimatedDeliveryTime = raw.estimatedDeliveryTime;
    domainEntity.estimatedDineInTime = raw.estimatedDineInTime;
    domainEntity.openingGracePeriod = raw.openingGracePeriod;
    domainEntity.closingGracePeriod = raw.closingGracePeriod;
    domainEntity.timeZone = raw.timeZone;
    domainEntity.scheduledOrdersLeadTime = raw.scheduledOrdersLeadTime;
    domainEntity.deliveryCoverageArea = raw.deliveryCoverageArea;
    domainEntity.minimumOrderValueForDelivery =
      raw.minimumOrderValueForDelivery;
    domainEntity.businessHours = mapArray(raw.businessHours, (hours) =>
      this.businessHoursMapper.toDomain(hours),
    );
    domainEntity.createdAt = raw.createdAt;
    domainEntity.updatedAt = raw.updatedAt;
    return domainEntity;
  }
  toPersistence(domainEntity: RestaurantConfig): RestaurantConfigEntity {
    const persistenceEntity = new RestaurantConfigEntity();
    if (domainEntity.id) {
      persistenceEntity.id = domainEntity.id;
    }
    persistenceEntity.restaurantName = domainEntity.restaurantName;
    persistenceEntity.phoneMain = domainEntity.phoneMain;
    persistenceEntity.phoneSecondary = domainEntity.phoneSecondary;
    persistenceEntity.address = domainEntity.address;
    persistenceEntity.city = domainEntity.city;
    persistenceEntity.state = domainEntity.state;
    persistenceEntity.postalCode = domainEntity.postalCode;
    persistenceEntity.country = domainEntity.country;
    persistenceEntity.acceptingOrders = domainEntity.acceptingOrders;
    persistenceEntity.estimatedPickupTime = domainEntity.estimatedPickupTime;
    persistenceEntity.estimatedDeliveryTime =
      domainEntity.estimatedDeliveryTime;
    persistenceEntity.estimatedDineInTime = domainEntity.estimatedDineInTime;
    persistenceEntity.openingGracePeriod = domainEntity.openingGracePeriod;
    persistenceEntity.closingGracePeriod = domainEntity.closingGracePeriod;
    persistenceEntity.timeZone = domainEntity.timeZone;
    persistenceEntity.scheduledOrdersLeadTime =
      domainEntity.scheduledOrdersLeadTime;
    persistenceEntity.deliveryCoverageArea = domainEntity.deliveryCoverageArea;
    persistenceEntity.minimumOrderValueForDelivery =
      domainEntity.minimumOrderValueForDelivery;
    persistenceEntity.createdAt = domainEntity.createdAt;
    persistenceEntity.updatedAt = domainEntity.updatedAt;
    return persistenceEntity;
  }
}

================
File: backend/src/shifts/shifts.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  UseGuards,
  HttpStatus,
  HttpCode,
  Query,
  ParseIntPipe,
  DefaultValuePipe,
  ParseUUIDPipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiQuery,
} from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { User } from '../users/domain/user';
import { ShiftsService } from './shifts.service';
import { OpenShiftDto } from './dto/open-shift.dto';
import { CloseShiftDto } from './dto/close-shift.dto';
import { ShiftSummaryDto } from './dto/shift-summary.dto';
import { Shift } from './domain/shift';
@ApiTags('shifts')
@Controller({ path: 'shifts', version: '1' })
@ApiBearerAuth()
@UseGuards(AuthGuard('jwt'), RolesGuard)
export class ShiftsController {
  constructor(private readonly shiftsService: ShiftsService) {}
  @Post('open')
  @ApiOperation({
    summary: 'Abrir un nuevo turno',
    description:
      'Abre un nuevo turno. Solo puede haber un turno abierto a la vez.',
  })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'Turno abierto exitosamente',
    type: ShiftSummaryDto,
  })
  @ApiResponse({
    status: HttpStatus.CONFLICT,
    description: 'Ya existe un turno abierto',
  })
  @Roles(RoleEnum.admin, RoleEnum.manager)
  @HttpCode(HttpStatus.CREATED)
  async openShift(
    @Body() dto: OpenShiftDto,
    @CurrentUser() user: User,
  ): Promise<ShiftSummaryDto> {
    const shift = await this.shiftsService.openShift(dto, user);
    return this.mapToSummaryDto(shift);
  }
  @Post('close')
  @ApiOperation({
    summary: 'Cerrar el turno actual',
    description:
      'Cierra el turno actual, registrando el efectivo final y calculando diferencias.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Turno cerrado exitosamente',
    type: ShiftSummaryDto,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'No hay un turno abierto',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Hay órdenes abiertas que deben ser completadas',
  })
  @Roles(RoleEnum.admin, RoleEnum.manager)
  async closeShift(
    @Body() dto: CloseShiftDto,
    @CurrentUser() user: User,
  ): Promise<ShiftSummaryDto> {
    const shift = await this.shiftsService.closeShift(dto, user);
    return this.mapToSummaryDto(shift);
  }
  @Get('current')
  @ApiOperation({
    summary: 'Obtener el turno actual',
    description:
      'Devuelve el turno actualmente abierto, o null si no hay ninguno.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Turno actual',
    type: ShiftSummaryDto,
  })
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  async getCurrentShift(): Promise<ShiftSummaryDto | null> {
    const currentShift = await this.shiftsService.getCurrentShift();
    if (!currentShift) {
      return null;
    }
    const summary = await this.shiftsService.getShiftSummary();
    const dto = this.mapToSummaryDto(summary);
    if (currentShift.isOpen()) {
      dto.expectedCash = await this.shiftsService.calculateExpectedCash();
    }
    return dto;
  }
  @Get('history')
  @ApiOperation({
    summary: 'Obtener historial de turnos',
    description:
      'Devuelve el historial de turnos cerrados, ordenados por fecha descendente.',
  })
  @ApiQuery({
    name: 'limit',
    required: false,
    type: Number,
    description: 'Número de registros a devolver',
    example: 30,
  })
  @ApiQuery({
    name: 'offset',
    required: false,
    type: Number,
    description: 'Número de registros a saltar',
    example: 0,
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Lista de turnos',
    type: [ShiftSummaryDto],
  })
  @Roles(RoleEnum.admin, RoleEnum.manager)
  async getHistory(
    @Query('limit', new DefaultValuePipe(30), ParseIntPipe) limit: number,
    @Query('offset', new DefaultValuePipe(0), ParseIntPipe) offset: number,
  ): Promise<ShiftSummaryDto[]> {
    const shifts = await this.shiftsService.getHistory(limit, offset);
    return shifts.map((shift) => this.mapToSummaryDto(shift));
  }
  @Get(':id')
  @ApiOperation({
    summary: 'Obtener un turno por ID',
    description: 'Devuelve los detalles de un turno específico.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Turno encontrado',
    type: ShiftSummaryDto,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Turno no encontrado',
  })
  @Roles(RoleEnum.admin, RoleEnum.manager)
  async getById(
    @Param('id', ParseUUIDPipe) id: string,
  ): Promise<ShiftSummaryDto> {
    const shift = await this.shiftsService.getShiftSummary(id);
    return this.mapToSummaryDto(shift);
  }
  private mapToSummaryDto(shift: Shift): ShiftSummaryDto {
    return {
      id: shift.id,
      date: shift.date,
      globalShiftNumber: shift.globalShiftNumber,
      shiftNumber: shift.shiftNumber,
      status: shift.status,
      openedAt: shift.openedAt,
      closedAt: shift.closedAt,
      openedBy: {
        id: shift.openedBy.id,
        firstName: shift.openedBy.firstName || '',
        lastName: shift.openedBy.lastName || '',
      },
      closedBy: shift.closedBy
        ? {
            id: shift.closedBy.id,
            firstName: shift.closedBy.firstName || '',
            lastName: shift.closedBy.lastName || '',
          }
        : null,
      initialCash: shift.initialCash,
      finalCash: shift.finalCash,
      totalSales: shift.totalSales,
      totalOrders: shift.totalOrders,
      cashDifference: shift.cashDifference,
      notes: shift.notes,
      closeNotes: shift.closeNotes,
    };
  }
}

================
File: backend/src/sync/controllers/sync.controller.ts
================
import { Controller, Post, Get, HttpStatus, Body, Query } from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
} from '@nestjs/swagger';
import { LocalSyncService } from '../services/local-sync.service';
import { PullChangesResponseDto } from '../dto/pull-changes-response.dto';
import { UpdateOrderStatusDto } from '../dto/update-order-status.dto';
import { UpdateOrderStatusResponseDto } from '../dto/update-order-status-response.dto';
import { SyncActivityEntity } from '../infrastructure/persistence/relational/entities/sync-activity.entity';
import { PullChangesRequestDto } from '../dto/pull-changes-request.dto';
@ApiTags('Sync')
@ApiBearerAuth()
@Controller({
  path: 'sync-local',
  version: '1',
})
export class SyncController {
  constructor(private readonly localSyncService: LocalSyncService) {}
  @Get('status')
  @ApiOperation({
    summary: 'Obtener información del servicio de sincronización',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Estado del servicio de sincronización',
    schema: {
      type: 'object',
      properties: {
        enabled: { type: 'boolean' },
        webSocketEnabled: { type: 'boolean' },
        remoteUrl: { type: 'string', nullable: true },
        mode: { type: 'string', example: 'pull' },
      },
    },
  })
  async getSyncStatus() {
    const syncConfig = this.localSyncService['syncConfig'];
    const webSocketStatus = this.localSyncService.getWebSocketStatus();
    return {
      enabled: syncConfig.enabled,
      webSocketEnabled: syncConfig.webSocketEnabled,
      webSocketConnected: webSocketStatus.connected,
      webSocketFailed: webSocketStatus.failed,
      remoteUrl: syncConfig.cloudApiUrl || null,
      mode: 'pull',
      intervalMinutes: syncConfig.intervalMinutes,
      stats: {
        pullCount: this.localSyncService['pullCount'],
        successfulPulls: this.localSyncService['successfulPulls'],
        failedPulls: this.localSyncService['failedPulls'],
        lastPullTime: this.localSyncService['lastPullTime'],
        nextPullTime: this.localSyncService['nextPullTime'],
      },
    };
  }
  @Post('pull-changes')
  @ApiOperation({
    summary: 'Obtener cambios pendientes y confirmar procesados',
    description:
      'Obtiene pedidos pendientes y clientes actualizados. Opcionalmente confirma IDs procesados exitosamente del pull anterior.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Cambios pendientes obtenidos exitosamente',
    type: PullChangesResponseDto,
  })
  async pullChanges(
    @Body() confirmDto: PullChangesRequestDto,
  ): Promise<PullChangesResponseDto> {
    return await this.localSyncService.pullChanges(confirmDto);
  }
  @Post('order-status')
  @ApiOperation({
    summary: 'Notificar cambio de estado de orden a la nube',
    description:
      'Notifica al backend en la nube cuando el restaurante acepta, rechaza o actualiza el estado de un pedido',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Estado actualizado exitosamente en la nube',
    type: UpdateOrderStatusResponseDto,
  })
  async updateOrderStatus(
    @Body() updateDto: UpdateOrderStatusDto,
  ): Promise<UpdateOrderStatusResponseDto> {
    return await this.localSyncService.updateOrderStatus(updateDto);
  }
  @Get('activity')
  @ApiOperation({
    summary: 'Obtener actividad reciente de sincronización',
    description:
      'Devuelve las últimas 20 actividades de sincronización ordenadas por fecha descendente',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Actividades de sincronización obtenidas exitosamente',
    schema: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string', format: 'uuid' },
          type: {
            type: 'string',
            enum: ['PULL_CHANGES', 'RESTAURANT_DATA', 'ORDER_STATUS'],
          },
          direction: { type: 'string', enum: ['IN', 'OUT'] },
          success: { type: 'boolean' },
          timestamp: { type: 'string', format: 'date-time' },
        },
      },
    },
  })
  async getSyncActivity(): Promise<SyncActivityEntity[]> {
    return await this.localSyncService.getRecentActivity();
  }
}

================
File: backend/src/thermal-printers/thermal-printers.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { ThermalPrintersController } from './thermal-printers.controller';
import { ThermalPrintersService } from './thermal-printers.service';
import { RelationalThermalPrinterPersistenceModule } from './infrastructure/persistence/relational/relational-persistence.module';
import { AuthModule } from '../auth/auth.module';
import { PrintingController } from './printing.controller';
import { PrintingService } from './printing.service';
import { OrdersModule } from '../orders/orders.module';
import { DiscoveryService } from './discovery.service';
import { AutomaticPrintingService } from './automatic-printing.service';
import { RestaurantConfigModule } from '../restaurant-config/restaurant-config.module';
const infrastructurePersistenceModule =
  RelationalThermalPrinterPersistenceModule;
@Module({
  imports: [
    infrastructurePersistenceModule,
    AuthModule,
    forwardRef(() => OrdersModule),
    forwardRef(() => RestaurantConfigModule),
  ],
  controllers: [ThermalPrintersController, PrintingController],
  providers: [
    ThermalPrintersService,
    PrintingService,
    DiscoveryService,
    AutomaticPrintingService,
  ],
  exports: [
    ThermalPrintersService,
    infrastructurePersistenceModule,
    AutomaticPrintingService,
  ],
})
export class ThermalPrintersModule {}

================
File: backend/src/thermal-printers/utils/ticket-formatter.ts
================
export class TicketFormatter {
  private readonly paperWidth: number;
  constructor(paperWidthMm: 58 | 80 = 80) {
    this.paperWidth = paperWidthMm;
  }
  getCharactersPerLine(
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
  ): number {
    if (this.paperWidth === 80) {
      switch (fontSize) {
        case 'compressed':
          return 64;
        case 'expanded':
          return 24;
        default:
          return 48;
      }
    } else {
      switch (fontSize) {
        case 'compressed':
          return 42;
        case 'expanded':
          return 16;
        default:
          return 32;
      }
    }
  }
  centerText(
    text: string,
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
  ): string {
    const maxChars = this.getCharactersPerLine(fontSize);
    const padding = Math.max(0, Math.floor((maxChars - text.length) / 2));
    return ' '.repeat(padding) + text;
  }
  formatLine(
    left: string,
    right: string,
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
  ): string {
    const maxChars = this.getCharactersPerLine(fontSize);
    const totalLength = left.length + right.length;
    const spaces = Math.max(1, maxChars - totalLength);
    return left + ' '.repeat(spaces) + right;
  }
  formatProductLine(
    productName: string,
    price: string,
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
  ): string {
    const maxChars = this.getCharactersPerLine(fontSize);
    const priceSpace = price.length + 2;
    const maxProductLength = maxChars - priceSpace;
    if (productName.length > maxProductLength) {
      productName = productName.substring(0, maxProductLength - 3) + '...';
    }
    const spaces = maxChars - productName.length - price.length;
    return productName + ' '.repeat(spaces) + price;
  }
  formatProductLines(
    productName: string,
    price: string,
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
  ): string[] {
    const maxChars = this.getCharactersPerLine(fontSize);
    const priceColumnWidth = Math.max(10, price.length + 1);
    const productColumnWidth = maxChars - priceColumnWidth - 1;
    const productLines = this.wrapTextInColumn(productName, productColumnWidth);
    const formattedLines: string[] = [];
    for (let i = 0; i < productLines.length; i++) {
      const isLastLine = i === productLines.length - 1;
      const productText = productLines[i];
      if (isLastLine) {
        const paddedProduct = productText.padEnd(productColumnWidth);
        const paddedPrice = price.padStart(priceColumnWidth);
        formattedLines.push(paddedProduct + ' ' + paddedPrice);
      } else {
        const paddedProduct = productText.padEnd(productColumnWidth);
        const emptyPriceColumn = ' '.repeat(priceColumnWidth + 1);
        formattedLines.push(paddedProduct + emptyPriceColumn);
      }
    }
    return formattedLines;
  }
  private wrapTextInColumn(text: string, columnWidth: number): string[] {
    const lines: string[] = [];
    const words = text.split(' ');
    let currentLine = '';
    for (const word of words) {
      const testLine = currentLine ? currentLine + ' ' + word : word;
      if (testLine.length <= columnWidth) {
        currentLine = testLine;
      } else {
        // Si la palabra actual no cabe, guardar la línea actual
        if (currentLine) {
          lines.push(currentLine);
        }
        // Si una sola palabra es más larga que el ancho de columna, cortarla
        if (word.length > columnWidth) {
          let remainingWord = word;
          while (remainingWord.length > columnWidth) {
            lines.push(remainingWord.substring(0, columnWidth - 1) + '-');
            remainingWord = remainingWord.substring(columnWidth - 1);
          }
          currentLine = remainingWord;
        } else {
          currentLine = word;
        }
      }
    }
    // Agregar la última línea si existe
    if (currentLine) {
      lines.push(currentLine);
    }
    return lines.length > 0 ? lines : [''];
  }
  /**
   * Divide texto largo en múltiples líneas
   */
  wrapText(
    text: string,
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
  ): string[] {
    const maxChars = this.getCharactersPerLine(fontSize);
    const words = text.split(' ');
    const lines: string[] = [];
    let currentLine = '';
    for (const word of words) {
      if ((currentLine + ' ' + word).trim().length <= maxChars) {
        currentLine = (currentLine + ' ' + word).trim();
      } else {
        if (currentLine) lines.push(currentLine);
        currentLine = word;
      }
    }
    if (currentLine) lines.push(currentLine);
    return lines;
  }
  /**
   * Crea una línea divisoria con caracteres
   */
  createDivider(
    char: string = '-',
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
  ): string {
    const maxChars = this.getCharactersPerLine(fontSize);
    return char.repeat(maxChars);
  }
  formatTable(
    rows: Array<{ col1: string; col2: string; col3?: string }>,
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
  ): string[] {
    const maxChars = this.getCharactersPerLine(fontSize);
    const lines: string[] = [];
    if (rows[0]?.col3 !== undefined) {
      const col1Width = Math.floor(maxChars * 0.5);
      const col2Width = Math.floor(maxChars * 0.25);
      const col3Width = maxChars - col1Width - col2Width;
      for (const row of rows) {
        const col1 = row.col1.substring(0, col1Width).padEnd(col1Width);
        const col2 = row.col2.substring(0, col2Width).padEnd(col2Width);
        const col3 = (row.col3 || '')
          .substring(0, col3Width)
          .padStart(col3Width);
        lines.push(col1 + col2 + col3);
      }
    } else {
      // Tabla de 2 columnas
      const col1Width = Math.floor(maxChars * 0.7);
      const col2Width = maxChars - col1Width;
      for (const row of rows) {
        const col1 = row.col1.substring(0, col1Width).padEnd(col1Width);
        const col2 = row.col2.substring(0, col2Width).padStart(col2Width);
        lines.push(col1 + col2);
      }
    }
    return lines;
  }
  /**
   * Formatea montos monetarios con alineación
   */
  formatMoney(amount: number): string {
    // Si el monto no tiene decimales significativos, mostrar sin decimales
    if (amount % 1 === 0) {
      return `$${amount.toFixed(0)}`;
    }
    // Si tiene decimales, mostrarlos
    return `$${amount.toFixed(2)}`;
  }
  /**
   * Formatea una línea de producto estilo tabla con columnas estrictas
   * Garantiza que el precio SIEMPRE esté en su columna sin invasión de texto
   * @param dynamicPriceWidth - Ancho opcional calculado dinámicamente para la columna de precios
   */
  formatProductTable(
    productName: string,
    price: string,
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
    dynamicPriceWidth?: number,
  ): string[] {
    const maxChars = this.getCharactersPerLine(fontSize);
    let productColumnWidth: number;
    let priceColumnWidth: number;
    const separatorWidth = 1;
    if (dynamicPriceWidth && dynamicPriceWidth > 0) {
      priceColumnWidth = dynamicPriceWidth;
      productColumnWidth = maxChars - priceColumnWidth - separatorWidth;
    } else {
      if (fontSize === 'expanded') {
        if (this.paperWidth === 80) {
          priceColumnWidth = 7;
          productColumnWidth = maxChars - priceColumnWidth - separatorWidth;
        } else {
          priceColumnWidth = 6;
          productColumnWidth = maxChars - priceColumnWidth - separatorWidth;
        }
      } else {
        if (this.paperWidth === 80) {
          priceColumnWidth = 8;
          productColumnWidth = maxChars - priceColumnWidth - separatorWidth;
        } else {
          priceColumnWidth = 7;
          productColumnWidth = maxChars - priceColumnWidth - separatorWidth;
        }
      }
    }
    const lines: string[] = [];
    let remainingText = productName;
    while (remainingText.length > 0) {
      if (remainingText.length <= productColumnWidth) {
        const productPart = remainingText.padEnd(productColumnWidth);
        const separator = ' '.repeat(separatorWidth);
        const pricePart = price.padStart(priceColumnWidth);
        lines.push(productPart + separator + pricePart);
        break;
      } else {
        let cutPoint = productColumnWidth;
        for (let i = productColumnWidth; i > 0; i--) {
          if (remainingText[i] === ' ') {
            cutPoint = i;
            break;
          }
        }
        if (
          cutPoint === productColumnWidth &&
          remainingText[cutPoint] !== ' '
        ) {
          for (
            let i = productColumnWidth;
            i < remainingText.length && i < productColumnWidth + 5;
            i++
          ) {
            if (remainingText[i] === ' ') {
              cutPoint = i;
              break;
            }
          }
          if (cutPoint === productColumnWidth) {
            cutPoint = productColumnWidth - 1;
            const productPart = remainingText.substring(0, cutPoint) + '-';
            const paddedProduct = productPart.padEnd(productColumnWidth);
            lines.push(
              paddedProduct + ' '.repeat(separatorWidth + priceColumnWidth),
            );
            remainingText = remainingText.substring(cutPoint);
            continue;
          }
        }
        const productPart = remainingText.substring(0, cutPoint).trim();
        const paddedProduct = productPart.padEnd(productColumnWidth);
        lines.push(
          paddedProduct + ' '.repeat(separatorWidth + priceColumnWidth),
        );
        remainingText = remainingText.substring(cutPoint).trim();
      }
    }
    if (lines.length === 0) {
      const productPart = ''.padEnd(productColumnWidth);
      const separator = ' '.repeat(separatorWidth);
      const pricePart = price.padStart(priceColumnWidth);
      lines.push(productPart + separator + pricePart);
    }
    return lines;
  }
  /**
   * Crea un recuadro alrededor del texto
   */
  createBox(
    text: string,
    fontSize: 'normal' | 'compressed' | 'expanded' = 'normal',
  ): string[] {
    const maxChars = this.getCharactersPerLine(fontSize);
    const lines: string[] = [];
    lines.push('┌' + '─'.repeat(maxChars - 2) + '┐');
    const wrappedText = this.wrapText(text, fontSize);
    for (const line of wrappedText) {
      const padding = maxChars - line.length - 2;
      lines.push('│' + line + ' '.repeat(padding) + '│');
    }
    lines.push('└' + '─'.repeat(maxChars - 2) + '┘');
    return lines;
  }
}

================
File: app/package.json
================
{
  "name": "cloudbite",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "test:ci": "jest",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
    "compile": "tsc --noEmit --skipLibCheck",
    "compile:check": "./compile-check.sh",
    "build:ios:sim": "eas build --platform ios --profile development --local",
    "build:android:sim": "eas build --platform android --profile development --local",
    "build:ios:dev": "eas build --platform ios --profile preview --local",
    "build:android:dev": "eas build --platform android --profile preview --local",
    "build:android:prod": "eas build --platform android --profile production --local",
    "build:android:prod-apk": "eas build --platform android --profile production-apk --local",
    "build:prod": "eas build --platform android --profile production",
    "submit:prod": "eas submit --platform android --profile production",
    "release:prod": "npm run build:prod && npm run submit:prod",
    "release:prod:auto": "eas build --platform android --profile production --auto-submit",
    "release:playstore": "./scripts/release-to-playstore.sh",
    "postinstall": "patch-package"
  },
  "dependencies": {
    "@expo/config-plugins": "~10.0.0",
    "@expo/metro-config": "~0.20.0",
    "@expo/metro-runtime": "~5.0.4",
    "@expo/prebuild-config": "~9.0.0",
    "@expo/vector-icons": "^14.0.4",
    "@react-native-community/datetimepicker": "^8.4.2",
    "@react-native-community/netinfo": "11.3.1",
    "@react-navigation/drawer": "^7.3.8",
    "@react-navigation/native": "^7.1.5",
    "@react-navigation/native-stack": "^7.3.9",
    "@shopify/flash-list": "1.7.6",
    "@tanstack/react-query": "^5.72.1",
    "@types/eventemitter3": "^1.2.0",
    "apisauce": "^3.1.1",
    "axios": "^1.8.4",
    "axios-retry": "^4.5.0",
    "babel-plugin-module-resolver": "^5.0.2",
    "date-fns": "^4.1.0",
    "eventemitter3": "^5.0.1",
    "expo": "^53.0.0",
    "expo-audio": "~0.4.7",
    "expo-build-properties": "^0.14.8",
    "expo-crypto": "~14.1.5",
    "expo-dev-client": "~5.2.4",
    "expo-file-system": "~18.1.10",
    "expo-image": "~2.3.0",
    "expo-image-picker": "~16.1.4",
    "expo-screen-orientation": "^8.1.7",
    "expo-secure-store": "~14.2.3",
    "expo-speech-recognition": "^0.3.2",
    "lodash.debounce": "^4.0.8",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-hook-form": "^7.55.0",
    "react-native": "0.79.4",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-paper": "^5.13.1",
    "react-native-paper-dates": "^0.22.46",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.11.1",
    "react-native-web": "^0.20.0",
    "react-native-webview": "^13.15.0",
    "zod": "^3.24.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/lodash": "^4.17.16",
    "@types/react": "~19.0.10",
    "@typescript-eslint/eslint-plugin": "^7.13.1",
    "@typescript-eslint/parser": "^7.13.1",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "eslint-plugin-react": "^7.34.3",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-native": "^4.1.0",
    "http-proxy-middleware": "^3.0.5",
    "patch-package": "^8.0.0",
    "typescript": "~5.8.3"
  },
  "private": true,
  "expo": {
    "doctor": {
      "reactNativeDirectoryCheck": {
        "exclude": [
          "@hookform/resolvers",
          "dotenv"
        ],
        "listUnknownPackages": false
      }
    }
  }
}

================
File: app/src/app/components/common/PhoneNumberInput.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import { TextInput, Menu, Button, HelperText } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
interface Country {
  code: string;
  name: string;
  prefix: string;
  flag: string;
}
const COUNTRIES: Country[] = [
  { code: 'DO', name: 'Rep. Dominicana', prefix: '+1809', flag: '🇩🇴' },
  { code: 'PR', name: 'Puerto Rico', prefix: '+1787', flag: '🇵🇷' },
  { code: 'EC', name: 'Ecuador', prefix: '+593', flag: '🇪🇨' },
  { code: 'BO', name: 'Bolivia', prefix: '+591', flag: '🇧🇴' },
  { code: 'PY', name: 'Paraguay', prefix: '+595', flag: '🇵🇾' },
  { code: 'UY', name: 'Uruguay', prefix: '+598', flag: '🇺🇾' },
  { code: 'GT', name: 'Guatemala', prefix: '+502', flag: '🇬🇹' },
  { code: 'SV', name: 'El Salvador', prefix: '+503', flag: '🇸🇻' },
  { code: 'HN', name: 'Honduras', prefix: '+504', flag: '🇭🇳' },
  { code: 'NI', name: 'Nicaragua', prefix: '+505', flag: '🇳🇮' },
  { code: 'CR', name: 'Costa Rica', prefix: '+506', flag: '🇨🇷' },
  { code: 'PA', name: 'Panamá', prefix: '+507', flag: '🇵🇦' },
  { code: 'MX', name: 'México', prefix: '+52', flag: '🇲🇽' },
  { code: 'AR', name: 'Argentina', prefix: '+54', flag: '🇦🇷' },
  { code: 'BR', name: 'Brasil', prefix: '+55', flag: '🇧🇷' },
  { code: 'CL', name: 'Chile', prefix: '+56', flag: '🇨🇱' },
  { code: 'CO', name: 'Colombia', prefix: '+57', flag: '🇨🇴' },
  { code: 'PE', name: 'Perú', prefix: '+51', flag: '🇵🇪' },
  { code: 'VE', name: 'Venezuela', prefix: '+58', flag: '🇻🇪' },
  { code: 'CU', name: 'Cuba', prefix: '+53', flag: '🇨🇺' },
  { code: 'ES', name: 'España', prefix: '+34', flag: '🇪🇸' },
  { code: 'US', name: 'Estados Unidos', prefix: '+1', flag: '🇺🇸' },
  { code: 'CA', name: 'Canadá', prefix: '+1', flag: '🇨🇦' },
];
interface PhoneNumberInputProps {
  value: string;
  onChange: (fullNumber: string) => void;
  error?: boolean;
  helperText?: string;
  placeholder?: string;
}
export default function PhoneNumberInput({
  value,
  onChange,
  error,
  helperText,
  placeholder = 'Teléfono',
}: PhoneNumberInputProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const [selectedCountry, setSelectedCountry] = useState<Country>(COUNTRIES[0]);
  const [phoneNumber, setPhoneNumber] = useState('');
  const [menuVisible, setMenuVisible] = useState(false);
  // Detectar país y número al recibir un valor completo
  useEffect(() => {
    if (value && value.startsWith('+')) {
      // Ordenar países por longitud de prefijo (más largos primero) para evitar coincidencias erróneas
      const sortedCountries = [...COUNTRIES].sort(
        (a, b) => b.prefix.length - a.prefix.length,
      );
      // Encontrar el país por el prefijo
      const country = sortedCountries.find((c) => value.startsWith(c.prefix));
      if (country) {
        setSelectedCountry(country);
        setPhoneNumber(value.substring(country.prefix.length));
      } else {
        // Si no encontramos el país, usar el default y mostrar todo el número
        setPhoneNumber(value);
      }
    } else {
      setPhoneNumber(value || '');
    }
  }, [value]);
  const handlePhoneChange = (text: string) => {
    // Solo permitir números y limitar a 15 dígitos (estándar internacional)
    const cleaned = text.replace(/[^\d]/g, '').slice(0, 15);
    setPhoneNumber(cleaned);
    // Actualizar el valor completo
    if (cleaned) {
      onChange(`${selectedCountry.prefix}${cleaned}`);
    } else {
      onChange('');
    }
  };
  const handleCountrySelect = (country: Country) => {
    setSelectedCountry(country);
    setMenuVisible(false);
    // Actualizar el valor completo con el nuevo país
    if (phoneNumber) {
      onChange(`${country.prefix}${phoneNumber}`);
    }
  };
  return (
    <View>
      <View style={styles.container}>
        <Menu
          visible={menuVisible}
          onDismiss={() => setMenuVisible(false)}
          anchor={
            <Button
              mode="outlined"
              onPress={() => setMenuVisible(true)}
              style={styles.countryButton}
              labelStyle={styles.countryButtonLabel}
            >
              {selectedCountry.flag} {selectedCountry.prefix}
            </Button>
          }
          contentStyle={styles.menuContent}
        >
          <ScrollView
            style={styles.menuScrollView}
            showsVerticalScrollIndicator={true}
            nestedScrollEnabled={true}
          >
            {COUNTRIES.map((country) => (
              <Menu.Item
                key={country.code}
                onPress={() => handleCountrySelect(country)}
                title={`${country.flag} ${country.name} (${country.prefix})`}
                titleStyle={styles.menuItem}
              />
            ))}
          </ScrollView>
        </Menu>
        <TextInput
          value={phoneNumber}
          onChangeText={handlePhoneChange}
          placeholder={placeholder}
          keyboardType="phone-pad"
          mode="outlined"
          error={error}
          style={styles.input}
          outlineStyle={styles.inputOutline}
          maxLength={15}
        />
      </View>
      {helperText && (
        <HelperText type="error" visible={error}>
          {helperText}
        </HelperText>
      )}
    </View>
  );
}
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    countryButton: {
      minWidth: responsive.isTablet ? 85 : 90,
      height: responsive.isTablet ? 48 : 56,
      justifyContent: 'center',
    },
    countryButtonLabel: {
      fontSize: responsive.fontSize(16),
    },
    menuContent: {
      maxHeight: responsive.isTablet ? 400 : 350,
      backgroundColor: theme.colors.surface,
    },
    menuScrollView: {
      maxHeight: responsive.isTablet ? 390 : 340,
    },
    menuItem: {
      fontSize: responsive.fontSize(14),
    },
    input: {
      flex: 1,
      height: responsive.isTablet ? 48 : 56,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
  });

================
File: app/src/app/components/crud/GenericFormModal.tsx
================
import React, {
  useEffect,
  useMemo,
  useState,
  useCallback,
  useRef,
} from 'react';
import {
  View,
  StyleSheet,
  Alert,
  ScrollView,
  StyleProp,
  ViewStyle,
} from 'react-native';
import {
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  ActivityIndicator,
} from 'react-native-paper';
import {
  useForm,
  Controller,
  SubmitHandler,
  FieldValues,
  Path,
  UseFormReturn,
  DeepPartial,
  DefaultValues,
  Control,
  FieldError,
} from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '../../styles/theme';
import CustomImagePicker, { FileObject } from '../common/CustomImagePicker';
import {
  ImageUploadService,
  EntityWithOptionalPhoto,
} from '../../lib/imageUploadService';
import { ResponsiveModal } from '../responsive/ResponsiveModal';
import { useResponsive } from '../../hooks/useResponsive';
type FieldType =
  | 'text'
  | 'textarea'
  | 'switch'
  | 'number'
  | 'email'
  | 'password';
export interface FormFieldConfig<TFormData extends FieldValues> {
  name: Path<TFormData>;
  label: string;
  type: FieldType;
  placeholder?: string;
  required?: boolean;
  defaultValue?: any;
  inputProps?: any;
  switchProps?: Partial<React.ComponentProps<typeof Switch>>;
  numberOfLines?: number;
  switchLabel?: string;
}
export interface ImagePickerConfig<TFormData extends FieldValues> {
  imageUriField: Path<TFormData>;
  onImageUpload: (file: FileObject) => Promise<{ id: string } | null>;
  determineFinalPhotoId?: (
    currentImageUri: string | null,
    editingItem: EntityWithOptionalPhoto | undefined,
  ) => string | null | undefined;
  imagePickerSize?: number;
  placeholderIcon?: string;
  placeholderText?: string;
}
interface GenericFormModalProps<
  TFormData extends FieldValues,
  TItem extends { id: string },
> {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: TFormData,
    photoId: string | null | undefined,
  ) => Promise<void>;
  formSchema: z.ZodType<TFormData>;
  formFields: FormFieldConfig<TFormData>[];
  imagePickerConfig?: ImagePickerConfig<TFormData>;
  initialValues?: DeepPartial<TFormData>;
  editingItem: (TItem & Partial<EntityWithOptionalPhoto>) | null;
  isSubmitting: boolean;
  modalTitle: (isEditing: boolean) => string;
  submitButtonLabel?: (isEditing: boolean) => string;
  cancelButtonLabel?: string;
  modalStyle?: StyleProp<ViewStyle>;
  formContainerStyle?: StyleProp<ViewStyle>;
  onFileSelected?: (file: FileObject | null) => void;
}
interface NumericInputProps {
  value: number | null | undefined;
  onChange: (value: number | null) => void;
  onBlur: () => void;
  label: string;
  placeholder?: string;
  keyboardType?: any;
  error?: boolean;
  disabled?: boolean;
  inputProps?: any;
}
const NumericInput: React.FC<NumericInputProps> = ({
  value,
  onChange,
  onBlur,
  label,
  placeholder,
  keyboardType = 'decimal-pad',
  error,
  disabled,
  inputProps,
}) => {
  const [inputValue, setInputValue] = useState<string>(
    value === null || value === undefined ? '' : String(value),
  );
  useEffect(() => {
    const stringValue =
      value === null || value === undefined ? '' : String(value);
    if (stringValue !== inputValue) {
      const numericValueFromInput = parseFloat(inputValue);
      if (
        !(inputValue.endsWith('.') && numericValueFromInput === value) &&
        !(inputValue === '.' && value === null)
      ) {
        setInputValue(stringValue);
      }
    }
  }, [value, inputValue]);
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  return (
    <TextInput
      label={label}
      value={inputValue}
      onChangeText={(text) => {
        const formattedText = text.replace(/,/g, '.');
        if (/^(\d*\.?\d*)$/.test(formattedText)) {
          setInputValue(formattedText);
          if (formattedText === '' || formattedText === '.') {
            if (value !== null) onChange(null);
          } else {
            const numericValue = parseFloat(formattedText);
            if (!isNaN(numericValue) && numericValue !== value) {
              onChange(numericValue);
            } else if (isNaN(numericValue) && value !== null) {
              onChange(null);
            }
          }
        }
      }}
      onBlur={onBlur}
      mode="outlined"
      style={styles.input}
      placeholder={placeholder}
      keyboardType={keyboardType}
      error={error}
      disabled={disabled}
      {...inputProps}
    />
  );
};
const getDefaultValueForType = (
  type: FieldType,
): string | number | boolean | null | undefined => {
  switch (type) {
    case 'text':
    case 'textarea':
    case 'email':
    case 'password':
      return '';
    case 'number':
      return null;
    case 'switch':
      return false;
    default:
      return undefined;
  }
};
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: responsive.spacing(20),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(40)
        : responsive.spacing(20),
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: responsive.isTablet ? '92%' : '90%',
      maxWidth: responsive.isTablet ? 600 : 500,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
    },
    input: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: responsive.spacing(theme.spacing.m),
      fontSize: responsive.isTablet ? 14 : 16,
      flexShrink: 1,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start',
      marginBottom: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    imagePickerContainer: {
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      minHeight: responsive.isTablet ? 70 : 80,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      flex: 1,
      maxWidth: 200,
      minWidth: responsive.isTablet ? 120 : 140,
    },
    cancelButton: {},
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      zIndex: 10,
    },
    helperText: {
      marginTop: -responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
  });
const GenericFormModal = <
  TFormData extends FieldValues,
  TItem extends { id: string },
>({
  visible,
  onDismiss,
  onSubmit,
  formSchema,
  formFields,
  imagePickerConfig,
  initialValues,
  editingItem,
  isSubmitting: isParentSubmitting,
  modalTitle,
  submitButtonLabel = (isEditing: boolean) => (isEditing ? 'Guardar' : 'Crear'),
  cancelButtonLabel = 'Cancelar',
  modalStyle,
  formContainerStyle,
  onFileSelected,
}: GenericFormModalProps<TFormData, TItem>) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const [isInternalImageUploading, setIsInternalImageUploading] =
    useState(false);
  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(
    null,
  );
  const prevVisibleRef = useRef(visible);
  const prevEditingItemIdRef = useRef(editingItem?.id);
  const isEditing = !!editingItem;
  const isActuallySubmitting = isParentSubmitting || isInternalImageUploading;
  const {
    control,
    handleSubmit,
    reset,
    setValue,
    watch,
    getValues: _getValues,
    formState: { errors },
  }: UseFormReturn<TFormData> = useForm<TFormData>({
    resolver: zodResolver(formSchema) as any,
    defaultValues: useMemo((): DefaultValues<TFormData> => {
      const defaults = formFields.reduce(
        (acc: DefaultValues<TFormData>, field) => {
          acc[field.name] =
            field.defaultValue ?? getDefaultValueForType(field.type);
          return acc;
        },
        {} as DefaultValues<TFormData>,
      );
      return { ...defaults, ...(initialValues as DefaultValues<TFormData>) };
    }, [formFields, initialValues]),
  });
  const watchedImageUri = imagePickerConfig
    ? watch(imagePickerConfig.imageUriField)
    : undefined;
  const currentImageUri =
    typeof watchedImageUri === 'string' ? watchedImageUri : null;
  useEffect(() => {
    const loadInitialData = async () => {
      const justOpened = visible && !prevVisibleRef.current;
      const itemChanged =
        visible && editingItem?.id !== prevEditingItemIdRef.current;
      if (visible) {
        const defaultFormValues = formFields.reduce(
          (acc: DefaultValues<TFormData>, field) => {
            acc[field.name] =
              field.defaultValue ?? getDefaultValueForType(field.type);
            return acc;
          },
          {} as DefaultValues<TFormData>,
        );
        const resetValues = {
          ...defaultFormValues,
          ...(initialValues as DefaultValues<TFormData>),
        };
        reset(resetValues, { keepDirtyValues: !justOpened && !itemChanged });
        if (justOpened || itemChanged) {
          setLocalSelectedFile(null);
          onFileSelected?.(null);
          setIsInternalImageUploading(false);
        }
      }
      prevVisibleRef.current = visible;
      prevEditingItemIdRef.current = editingItem?.id;
    };
    loadInitialData();
  }, [
    visible,
    editingItem?.id,
    reset,
    formFields,
    initialValues,
    onFileSelected,
    imagePickerConfig,
  ]);
  const handleImageSelected = useCallback(
    (uri: string, file: FileObject) => {
      if (imagePickerConfig) {
        const fieldName = imagePickerConfig.imageUriField;
        setValue(fieldName, uri as any, {
          shouldValidate: true,
          shouldDirty: true,
          shouldTouch: true,
        });
        setLocalSelectedFile(file);
        onFileSelected?.(file);
      }
    },
    [setValue, imagePickerConfig, onFileSelected],
  );
  const handleImageRemoved = useCallback(() => {
    if (imagePickerConfig) {
      setValue(imagePickerConfig.imageUriField, null as any, {
        shouldValidate: true,
      });
      setLocalSelectedFile(null);
      onFileSelected?.(null);
    }
  }, [setValue, imagePickerConfig, onFileSelected]);
  const processSubmit: SubmitHandler<TFormData> = async (formData) => {
    if (isActuallySubmitting) return;
    let finalPhotoId: string | null | undefined = undefined;
    if (imagePickerConfig) {
      const formImageUri = imagePickerConfig.imageUriField
        ? formData[imagePickerConfig.imageUriField]
        : null;
      const isNewLocalImage =
        typeof formImageUri === 'string' && formImageUri.startsWith('file://');
      if (isNewLocalImage && localSelectedFile) {
        setIsInternalImageUploading(true);
        try {
          const uploadResult =
            await imagePickerConfig.onImageUpload(localSelectedFile);
          if (uploadResult?.id) {
            finalPhotoId = uploadResult.id;
          } else {
            throw new Error('La subida de la imagen no devolvió un ID.');
          }
        } catch (error) {
          Alert.alert(
            'Error',
            `No se pudo subir la imagen: ${error instanceof Error ? error.message : 'Error desconocido'}`,
          );
          setIsInternalImageUploading(false);
          return;
        } finally {
          setIsInternalImageUploading(false);
        }
      } else {
        const determineFn =
          imagePickerConfig.determineFinalPhotoId ??
          ImageUploadService.determinePhotoId;
        const entityForPhotoCheck = editingItem ?? undefined;
        finalPhotoId = await determineFn(formImageUri, entityForPhotoCheck);
      }
    }
    await onSubmit(formData, finalPhotoId);
  };
  const renderFormField = (fieldConfig: FormFieldConfig<TFormData>) => {
    const fieldName = fieldConfig.name;
    const fieldError = errors[fieldName] as FieldError | undefined;
    const errorMessage = fieldError?.message;
    switch (fieldConfig.type) {
      case 'textarea':
      case 'text':
      case 'number':
      case 'email':
      case 'password':
        return (
          <View key={String(fieldName)}>
            {}
            <Controller
              name={fieldName}
              control={control as Control<FieldValues>}
              render={({ field: { onChange, onBlur, value } }) => {
                if (fieldConfig.type === 'number') {
                  return (
                    <NumericInput
                      value={value}
                      onChange={onChange}
                      onBlur={onBlur}
                      label={fieldConfig.label}
                      placeholder={fieldConfig.placeholder}
                      keyboardType={
                        fieldConfig.inputProps?.keyboardType ?? 'decimal-pad'
                      }
                      error={!!errorMessage}
                      disabled={isActuallySubmitting}
                      inputProps={fieldConfig.inputProps}
                    />
                  );
                } else {
                  return (
                    <TextInput
                      label={fieldConfig.label}
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      mode="outlined"
                      style={styles.input}
                      placeholder={fieldConfig.placeholder}
                      secureTextEntry={fieldConfig.type === 'password'}
                      keyboardType={
                        fieldConfig.type === 'email'
                          ? 'email-address'
                          : 'default'
                      }
                      multiline={fieldConfig.type === 'textarea'}
                      numberOfLines={
                        fieldConfig.numberOfLines ??
                        (fieldConfig.type === 'textarea' ? 3 : 1)
                      }
                      error={!!errorMessage}
                      disabled={isActuallySubmitting}
                      {...fieldConfig.inputProps}
                    />
                  );
                }
              }}
            />
            {errorMessage && (
              <HelperText
                type="error"
                visible={!!errorMessage}
                style={styles.helperText}
              >
                {errorMessage}
              </HelperText>
            )}
          </View>
        );
      case 'switch':
        return (
          <View key={String(fieldName)} style={styles.switchComponentContainer}>
            <Text variant="bodyLarge" style={styles.switchLabel}>
              {fieldConfig.switchLabel ?? fieldConfig.label}
            </Text>
            <Controller
              name={fieldName}
              control={control as Control<FieldValues>}
              render={({ field: { onChange, value } }) => (
                <Switch
                  value={value}
                  onValueChange={onChange}
                  disabled={isActuallySubmitting}
                  style={{ transform: [{ scaleX: 1.5 }, { scaleY: 1.5 }] }}
                  {...fieldConfig.switchProps}
                />
              )}
            />
            {errorMessage && (
              <HelperText
                type="error"
                visible={!!errorMessage}
                style={styles.helperText}
              >
                {errorMessage}
              </HelperText>
            )}
          </View>
        );
      default:
        return null;
    }
  };
  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title={modalTitle(isEditing)}
      dismissable={!isActuallySubmitting}
      scrollable={false}
      style={modalStyle}
      contentContainerStyle={styles.modalSurface}
      footer={
        <View style={styles.modalActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[styles.formButton, styles.cancelButton]}
            disabled={isActuallySubmitting}
          >
            {cancelButtonLabel}
          </Button>
          <Button
            mode="contained"
            onPress={() => {
              handleSubmit(processSubmit)();
            }}
            loading={isActuallySubmitting}
            disabled={isActuallySubmitting}
            style={styles.formButton}
          >
            {submitButtonLabel(isEditing)}
          </Button>
        </View>
      }
    >
      <View style={[styles.formContainer, formContainerStyle]}>
        <ScrollView
          contentContainerStyle={styles.scrollViewContent}
          showsVerticalScrollIndicator={false}
        >
          {imagePickerConfig && (
            <View style={styles.imagePickerContainer}>
              <CustomImagePicker
                value={currentImageUri}
                onImageSelected={handleImageSelected}
                onImageRemoved={handleImageRemoved}
                isLoading={isInternalImageUploading}
                disabled={isParentSubmitting}
                size={
                  imagePickerConfig.imagePickerSize ??
                  responsive.getResponsiveDimension(150, 200)
                }
                placeholderIcon={imagePickerConfig.placeholderIcon}
                placeholderText={imagePickerConfig.placeholderText}
              />
              {(
                errors[imagePickerConfig.imageUriField] as
                  | FieldError
                  | undefined
              )?.message && (
                <HelperText
                  type="error"
                  visible={!!errors[imagePickerConfig.imageUriField]}
                  style={styles.helperText}
                >
                  {
                    (
                      errors[imagePickerConfig.imageUriField] as
                        | FieldError
                        | undefined
                    )?.message
                  }
                </HelperText>
              )}
            </View>
          )}
          {formFields.map(renderFormField)}
        </ScrollView>
        {isActuallySubmitting && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator
              animating={true}
              size="large"
              color={theme.colors.primary}
            />
          </View>
        )}
      </View>
    </ResponsiveModal>
  );
};
export default GenericFormModal;

================
File: app/src/app/hooks/useServerConnection.ts
================
import { useState, useEffect, useCallback } from 'react';
import { serverConnectionService } from '@/services/serverConnectionService';
export interface ServerConnectionState {
  isSearching: boolean;
  isConnected: boolean;
  error: string | null;
  serverUrl: string | null;
  hasWifi: boolean;
  isHealthy: boolean;
  retry: () => void;
}
export function useServerConnection(): ServerConnectionState {
  const [state, setState] = useState(() => {
    const serviceState = serverConnectionService.getState();
    return {
      isSearching: serviceState.isSearching,
      isConnected: serviceState.isConnected,
      error: serviceState.error,
      serverUrl: serviceState.currentUrl,
      hasWifi: serviceState.hasWifi,
      isHealthy: serviceState.isHealthy,
      retry: () => {},
    };
  });
  useEffect(() => {
    const serviceState = serverConnectionService.getState();
    setState({
      isSearching: serviceState.isSearching,
      isConnected: serviceState.isConnected,
      error: serviceState.error,
      serverUrl: serviceState.currentUrl,
      hasWifi: serviceState.hasWifi,
      isHealthy: serviceState.isHealthy,
      retry: () => serverConnectionService.retry(),
    });
    const unsubscribe = serverConnectionService.subscribe((newState) => {
      setState({
        isSearching: newState.isSearching,
        isConnected: newState.isConnected,
        error: newState.error,
        serverUrl: newState.currentUrl,
        hasWifi: newState.hasWifi,
        isHealthy: newState.isHealthy,
        retry: () => serverConnectionService.retry(),
      });
    });
    return () => {
      unsubscribe();
    };
  }, []);
  const retry = useCallback(() => {
    serverConnectionService.retry();
  }, []);
  return state;
}

================
File: app/src/app/navigation/components/CustomDrawerContent.tsx
================
import React from 'react';
import { View, StyleSheet, Platform, TouchableOpacity } from 'react-native';
import { DrawerContentScrollView } from '@react-navigation/drawer';
import {
  Drawer as PaperDrawer,
  Text,
  Divider,
  Switch,
  TouchableRipple,
  Icon,
  Surface,
  IconButton,
} from 'react-native-paper';
import { useThemeStore } from '../../store/themeStore';
import { THEME_MODE } from '../../types/theme.types';
import { useAuthStore } from '../../store/authStore';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
import { clearImageCache } from '../../lib/imageCache';
import { useSnackbarStore } from '../../store/snackbarStore';
import {
  hasPermission,
  DRAWER_SECTIONS,
  DrawerSection,
} from '../../constants/rolePermissions';
import { generateNavigationAction } from '../helpers/navigationHelpers';
import { RoleEnum } from '@/modules/users/types/user.types';
import { useNavigation, DrawerActions } from '@react-navigation/native';
import type { DrawerContentComponentProps } from '@react-navigation/drawer';
const ROLE_TRANSLATIONS: Record<number, string> = {
  [RoleEnum.ADMIN]: 'Administrador',
  [RoleEnum.MANAGER]: 'Gerente',
  [RoleEnum.CASHIER]: 'Cajero',
  [RoleEnum.WAITER]: 'Mesero',
  [RoleEnum.KITCHEN]: 'Cocina',
  [RoleEnum.DELIVERY]: 'Repartidor',
};
const getRoleTranslation = (roleId?: number): string => {
  if (!roleId) return 'Desconocido';
  return ROLE_TRANSLATIONS[roleId] || 'Desconocido';
};
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    userInfoSection: {
      padding: responsive.spacing(theme.spacing.m),
    },
    title: {
      ...theme.fonts.titleMedium,
      fontSize: responsive.fontSize(theme.fonts.titleMedium.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(4),
    },
    caption: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(2),
    },
    drawerSection: {
      marginTop: responsive.spacing(theme.spacing.s),
    },
    bottomDrawerSection: {
      marginBottom: responsive.spacing(theme.spacing.m),
      marginTop: 'auto',
      borderTopColor: theme.colors.outlineVariant,
      borderTopWidth: StyleSheet.hairlineWidth,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    preference: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
    },
    drawerItemLabel: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
    },
    drawerItemContainer: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      flexDirection: 'row',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xxs),
    },
    drawerItemActive: {
      backgroundColor: theme.colors.primaryContainer,
    },
    drawerItemIconContainer: {
      marginRight: responsive.spacing(theme.spacing.l),
      width: responsive.isTablet ? 20 : theme.spacing.l,
      alignItems: 'center',
    },
    divider: {
      marginVertical: responsive.spacing(theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m),
    },
    configSubheader: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
      color: theme.colors.onSurfaceVariant,
      paddingLeft: responsive.spacing(theme.spacing.l),
      paddingRight: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xxs),
    },
  });
export function CustomDrawerContent(props: DrawerContentComponentProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const logout = useAuthStore((state) => state.logout);
  const setThemePreference = useThemeStore((state) => state.setThemePreference);
  const user = useAuthStore((state) => state.user);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const navigation = useNavigation<any>();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const getItemActive = (routeName: string) => {
    const currentRoute = props.state.routes[props.state.index];
    return currentRoute?.name === routeName;
  };
  const getItemColor = (routeName: string) => {
    return getItemActive(routeName)
      ? theme.colors.primary
      : theme.colors.onSurfaceVariant;
  };
  const renderDrawerItem = (
    routeName: string,
    label: string,
    iconName: string,
    navigateToScreen: () => void,
  ) => {
    if (!hasPermission(user?.role?.id, routeName as DrawerSection)) {
      return null;
    }
    const isActive = getItemActive(routeName);
    return (
      <TouchableRipple
        key={routeName}
        onPress={navigateToScreen}
        style={[
          styles.drawerItemContainer,
          isActive && styles.drawerItemActive,
        ]}
        rippleColor={`${theme.colors.primary}20`}
      >
        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
          <View style={styles.drawerItemIconContainer}>
            <Icon
              source={iconName}
              size={responsive.isTablet ? 20 : 24}
              color={getItemColor(routeName)}
            />
          </View>
          <Text
            style={[styles.drawerItemLabel, { color: getItemColor(routeName) }]}
          >
            {label}
          </Text>
        </View>
      </TouchableRipple>
    );
  };
  const renderDrawerItemSimple = (
    route: DrawerSection,
    label: string,
    icon: string,
  ) => {
    return renderDrawerItem(route, label, icon, () => {
      const isKitchenUser = user?.role?.id === 5;
      if (isKitchenUser && route === 'KitchenStack') {
        props.navigation.navigate('Kitchen');
      } else {
        const action = generateNavigationAction(route, user?.role?.id);
        if (action) {
          props.navigation.dispatch(action);
        }
      }
    });
  };
  const handleClearCache = async () => {
    try {
      await clearImageCache();
      showSnackbar({
        message: 'Caché de imágenes limpiado exitosamente',
        type: 'success',
      });
    } catch (error) {
      showSnackbar({
        message: 'Error al limpiar el caché',
        type: 'error',
      });
    }
  };
  return (
    <Surface
      style={{
        flex: 1,
        backgroundColor: theme.colors.surface,
      }}
      elevation={0}
    >
      <DrawerContentScrollView
        {...props}
        contentContainerStyle={{ paddingTop: 0 }}
      >
        <View style={styles.container}>
          <Surface style={styles.userInfoSection} elevation={0}>
            {user ? (
              <>
                <Text style={styles.title} numberOfLines={1}>
                  {`${user.firstName ?? ''} ${user.lastName ?? ''}`.trim() ||
                    user.username ||
                    'Usuario'}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  Rol: {getRoleTranslation(user.role?.id)}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  {user.email ?? ''}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  @{user.username ?? 'username'}
                </Text>
              </>
            ) : (
              <Text style={styles.title}>Invitado</Text>
            )}
          </Surface>
          <Divider style={styles.divider} />
          {}
          {DRAWER_SECTIONS.sales.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>
                {DRAWER_SECTIONS.sales.title}
              </Text>
              {DRAWER_SECTIONS.sales.items.map((item) =>
                renderDrawerItemSimple(
                  item.route as DrawerSection,
                  item.label,
                  item.icon,
                ),
              )}
            </PaperDrawer.Section>
          )}
          {}
          {hasPermission(user?.role?.id, 'KitchenStack') && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>Cocina</Text>
              {renderDrawerItemSimple(
                'KitchenStack',
                'Pantalla de Preparación',
                'chef-hat',
              )}
            </PaperDrawer.Section>
          )}
          {}
          {DRAWER_SECTIONS.configuration.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <>
              <Divider style={styles.divider} />
              <PaperDrawer.Section style={styles.drawerSection}>
                <Text style={styles.configSubheader}>
                  {DRAWER_SECTIONS.configuration.title}
                </Text>
                {DRAWER_SECTIONS.configuration.items.map((item) =>
                  renderDrawerItemSimple(
                    item.route as DrawerSection,
                    item.label,
                    item.icon,
                  ),
                )}
              </PaperDrawer.Section>
            </>
          )}
          {}
          {DRAWER_SECTIONS.administration.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <>
              <Divider style={styles.divider} />
              <PaperDrawer.Section style={styles.drawerSection}>
                <Text style={styles.configSubheader}>
                  {DRAWER_SECTIONS.administration.title}
                </Text>
                {DRAWER_SECTIONS.administration.items.map((item) =>
                  renderDrawerItemSimple(
                    item.route as DrawerSection,
                    item.label,
                    item.icon,
                  ),
                )}
              </PaperDrawer.Section>
            </>
          )}
        </View>
      </DrawerContentScrollView>
      <PaperDrawer.Section style={styles.bottomDrawerSection}>
        <TouchableRipple
          onPress={() => {
            const newPreference = theme.dark
              ? THEME_MODE.LIGHT
              : THEME_MODE.DARK;
            setThemePreference(newPreference);
          }}
          style={styles.preference}
        >
          <View
            style={{
              flexDirection: 'row',
              alignItems: 'center',
              justifyContent: 'space-between',
              width: '100%',
            }}
          >
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              <View style={styles.drawerItemIconContainer}>
                <Icon
                  source={theme.dark ? 'weather-night' : 'white-balance-sunny'}
                  size={responsive.isTablet ? 20 : 24}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
              <Text
                style={[
                  styles.drawerItemLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                Modo Oscuro
              </Text>
            </View>
            <View style={{ pointerEvents: 'none' }}>
              <Switch value={theme.dark} color={theme.colors.primary} />
            </View>
          </View>
        </TouchableRipple>
        <TouchableRipple
          onPress={handleClearCache}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="broom"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Limpiar Caché
            </Text>
          </View>
        </TouchableRipple>
        <TouchableRipple
          onPress={() => {
            props.navigation.navigate('ServerSettings');
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="server-network"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Configuración del Servidor
            </Text>
          </View>
        </TouchableRipple>
        <TouchableRipple
          onPress={() => {
            logout();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.error}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="logout"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.error}
              />
            </View>
            <Text
              style={[styles.drawerItemLabel, { color: theme.colors.error }]}
            >
              Cerrar Sesión
            </Text>
          </View>
        </TouchableRipple>
      </PaperDrawer.Section>
    </Surface>
  );
}

================
File: app/src/app/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps as NavigationDrawerScreenProps } from '@react-navigation/drawer';
import type { NavigatorScreenParams } from '@react-navigation/native';
import type { MenuStackParamList } from '../../modules/menu/navigation/types';
import type { PreparationScreensStackParamList } from '../../modules/preparationScreens/navigation/types';
import type { AreasTablesStackParamList } from '../../modules/areasTables/navigation/types';
import type { PrintersStackParamList } from '../../modules/printers/navigation/types';
import type { ReceiptsStackParamList } from '../../modules/receipts/navigation/types';
import type { AvailabilityStackParamList } from '../../modules/availability/navigation/types';
import type { OrderFinalizationStackParamList } from '../../modules/orderFinalization/navigation/types';
import type { RestaurantConfigStackParamList } from '../../modules/restaurantConfig/navigation/types';
import type { CustomersStackParamList } from '../../modules/customers/navigation/CustomersStackNavigator';
import type { PizzaCustomizationsStackParamList } from '../../modules/pizzaCustomizations/navigation/types';
import type { SyncStackParamList } from '../../modules/sync/navigation/SyncStackNavigator';
import type { UsersStackParamList } from '../../modules/users/navigation/UsersStackNavigator';
import type { KitchenStackParamList } from '../../modules/kitchen/navigation/KitchenNavigator';
import type { ShiftAuditStackParamList } from '../../modules/shiftAudit/navigation/types';
import type { SettingsStackParamList } from '../../modules/settings/navigation/types';
export type AuthStackParamList = {
  Login: undefined;
};
export type OrdersStackParamList = {
  Orders: undefined;
  CreateOrder: undefined;
  OpenOrders: undefined;
  AddProductsToOrder: {
    orderId: string;
    orderNumber: number;
    existingOrderItemsCount?: number;
    existingTempProducts?: import('../../modules/orders/stores/useCartStore').CartItem[];
    onProductsAdded?: (
      products: import('../../modules/orders/stores/useCartStore').CartItem[],
    ) => void;
  };
};
export type OrdersStackScreenProps<T extends keyof OrdersStackParamList> =
  NativeStackScreenProps<OrdersStackParamList, T>;
export type AuthStackScreenProps<T extends keyof AuthStackParamList> =
  NativeStackScreenProps<AuthStackParamList, T>;
export type ModifiersStackParamList = {
  ModifierGroupsScreen: undefined;
  ModifiersScreen: { groupId: string; groupName: string };
};
export type ModifiersStackScreenProps<T extends keyof ModifiersStackParamList> =
  NativeStackScreenProps<ModifiersStackParamList, T>;
export type AppDrawerParamList = {
  Welcome: undefined;
  MenuStack: NavigatorScreenParams<MenuStackParamList>;
  ModifiersStack: NavigatorScreenParams<ModifiersStackParamList>;
  PreparationScreensStack: NavigatorScreenParams<PreparationScreensStackParamList>;
  AreasTablesStack: NavigatorScreenParams<AreasTablesStackParamList>;
  OrdersStack: NavigatorScreenParams<OrdersStackParamList>;
  PrintersStack: NavigatorScreenParams<PrintersStackParamList>;
  ReceiptsStack: NavigatorScreenParams<ReceiptsStackParamList>;
  AvailabilityStack: NavigatorScreenParams<AvailabilityStackParamList>;
  OrderFinalizationStack: NavigatorScreenParams<OrderFinalizationStackParamList>;
  RestaurantConfigStack: NavigatorScreenParams<RestaurantConfigStackParamList>;
  PizzaCustomizationsStack: NavigatorScreenParams<PizzaCustomizationsStackParamList>;
  CustomersStack: NavigatorScreenParams<CustomersStackParamList>;
  SyncStack: NavigatorScreenParams<SyncStackParamList>;
  UsersStack: NavigatorScreenParams<UsersStackParamList>;
  KitchenStack: NavigatorScreenParams<KitchenStackParamList>;
  ShiftAuditStack: NavigatorScreenParams<ShiftAuditStackParamList>;
  SettingsStack: NavigatorScreenParams<SettingsStackParamList>;
  ServerSettings: undefined;
};
export type DrawerScreenProps<T extends keyof AppDrawerParamList> =
  NavigationDrawerScreenProps<AppDrawerParamList, T>;
export type DrawerNavigatorParamList = AppDrawerParamList;
declare global {
  namespace ReactNavigation {
    interface RootParamList
      extends AuthStackParamList,
        AppDrawerParamList,
        KitchenStackParamList,
        ModifiersStackParamList,
        PreparationScreensStackParamList,
        AreasTablesStackParamList,
        OrdersStackParamList,
        PrintersStackParamList,
        ReceiptsStackParamList,
        AvailabilityStackParamList,
        OrderFinalizationStackParamList,
        RestaurantConfigStackParamList,
        PizzaCustomizationsStackParamList,
        CustomersStackParamList,
        SyncStackParamList,
        UsersStackParamList,
        ShiftAuditStackParamList,
        SettingsStackParamList {}
  }
}

================
File: app/src/app/schemas/domain/order.schema.ts
================
import { z } from 'zod';
import { adjustmentSchema } from './adjustment.schema';
import { DeliveryInfoSchema } from './delivery-info.schema';
import { tableSchema } from './table.schema';
enum PizzaHalf {
  FULL = 'FULL',
  HALF_1 = 'HALF_1',
  HALF_2 = 'HALF_2',
}
enum CustomizationAction {
  ADD = 'ADD',
  REMOVE = 'REMOVE',
}
export const orderStatusSchema = z.enum([
  'PENDING',
  'IN_PROGRESS',
  'IN_PREPARATION',
  'READY',
  'DELIVERED',
  'COMPLETED',
  'CANCELLED',
]);
export type OrderStatus = z.infer<typeof orderStatusSchema>;
export const orderTypeSchema = z.enum(['DINE_IN', 'TAKE_AWAY', 'DELIVERY']);
export type OrderType = z.infer<typeof orderTypeSchema>;
export const orderItemModifierSchema = z.object({
  productModifierId: z.string(),
  modifierName: z.string(),
  price: z.number(),
});
export type OrderItemModifier = z.infer<typeof orderItemModifierSchema>;
export const selectedPizzaCustomizationSchema = z.object({
  pizzaCustomizationId: z.string(),
  pizzaCustomization: z
    .object({
      id: z.string(),
      name: z.string(),
      type: z.enum(['FLAVOR', 'INGREDIENT']),
      ingredients: z.string().nullable().optional(),
      toppingValue: z.number(),
      isActive: z.boolean(),
      sortOrder: z.number(),
    })
    .optional(),
  half: z.nativeEnum(PizzaHalf),
  action: z.nativeEnum(CustomizationAction),
});
export type SelectedPizzaCustomization = z.infer<
  typeof selectedPizzaCustomizationSchema
>;
export const orderItemSchema = z.object({
  id: z.string(),
  productId: z.string().uuid(),
  productName: z.string(),
  quantity: z.number().int().positive(),
  unitPrice: z.number(),
  totalPrice: z.number(),
  modifiers: z.array(orderItemModifierSchema),
  variantId: z.string().uuid().nullable().optional(),
  variantName: z.string().nullable().optional(),
  notes: z.string().nullable().optional(),
  selectedPizzaCustomizations: z
    .array(selectedPizzaCustomizationSchema)
    .optional(),
});
export type OrderItem = z.infer<typeof orderItemSchema>;
export const orderSchema = z.object({
  id: z.string().uuid(),
  orderNumber: z.string().optional(),
  shiftOrderNumber: z.number().int().positive(),
  orderItems: z.array(z.any()).optional(),
  total: z.union([z.string(), z.number()]).optional(),
  orderStatus: orderStatusSchema,
  orderType: orderTypeSchema,
  createdAt: z.union([z.string().datetime(), z.date()]),
  updatedAt: z.union([z.string().datetime(), z.date()]),
  finalizedAt: z.union([z.string().datetime(), z.date()]).nullable().optional(),
  userId: z.string().uuid().nullable().optional(),
  tableId: z.string().uuid().nullable().optional(),
  notes: z.string().nullable().optional(),
  scheduledAt: z.union([z.string().datetime(), z.date()]).nullable().optional(),
  deliveryInfo: DeliveryInfoSchema,
  user: z.any().optional(),
  table: tableSchema.optional(),
  payments: z.array(z.any()).optional(),
  deletedAt: z.string().nullable().optional(),
  adjustments: z.array(adjustmentSchema).optional(),
  subtotal: z.union([z.string(), z.number()]).optional(),
  isFromWhatsApp: z.boolean().optional().default(false),
  estimatedDeliveryTime: z
    .union([z.string().datetime(), z.date()])
    .nullable()
    .optional(),
});
export type Order = z.infer<typeof orderSchema>;

================
File: app/src/app/utils/roleUtils.ts
================
import type { User } from '@/modules/auth/schema/auth.schema';
export enum RoleEnum {
  ADMIN = 1,
  MANAGER = 2,
  CASHIER = 3,
  WAITER = 4,
  KITCHEN = 5,
}
export const hasRole = (user: User | null, roleId: RoleEnum): boolean => {
  return user?.role?.id === roleId;
};
export const hasAnyRole = (user: User | null, roleIds: RoleEnum[]): boolean => {
  if (!user?.role?.id) return false;
  return roleIds.includes(user.role.id);
};
export const isAdmin = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.ADMIN);
};
export const isManager = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.MANAGER);
};
export const isCashier = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.CASHIER);
};
export const isWaiter = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.WAITER);
};
export const isKitchen = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.KITCHEN);
};
export const canOpenShift = (user: User | null): boolean => {
  return hasAnyRole(user, [RoleEnum.ADMIN, RoleEnum.MANAGER]);
};
export const canRegisterPayments = (user: User | null): boolean => {
  return hasAnyRole(user, [RoleEnum.ADMIN, RoleEnum.MANAGER, RoleEnum.CASHIER]);
};
export const canManageOrders = (user: User | null): boolean => {
  return hasAnyRole(user, [
    RoleEnum.ADMIN,
    RoleEnum.MANAGER,
    RoleEnum.WAITER,
    RoleEnum.CASHIER,
  ]);
};
export const canAccessKitchen = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.KITCHEN);
};
export const getRoleName = (user: User | null): string => {
  if (!user?.role) return 'Sin rol';
  if (user.role.name) {
    return user.role.name;
  }
  switch (user.role.id) {
    case RoleEnum.ADMIN:
      return 'Administrador';
    case RoleEnum.MANAGER:
      return 'Gerente';
    case RoleEnum.CASHIER:
      return 'Cajero';
    case RoleEnum.WAITER:
      return 'Mesero';
    case RoleEnum.KITCHEN:
      return 'Cocina';
    default:
      return 'Usuario';
  }
};

================
File: app/src/modules/auth/components/LoginForm.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Text } from 'react-native';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import {
  TextInput,
  Button,
  HelperText,
  Checkbox,
  TouchableRipple,
} from 'react-native-paper';
import { useAppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { loginSchema, LoginFormInputs } from '../schema/auth.schema';
interface LoginFormProps {
  onSubmit: (data: LoginFormInputs, rememberMe: boolean) => void;
  isLoading: boolean;
  initialEmailOrUsername?: string;
  initialPassword?: string;
  initialRememberMe?: boolean;
}
const LoginForm: React.FC<LoginFormProps> = ({
  onSubmit,
  isLoading,
  initialEmailOrUsername = '',
  initialPassword = '',
  initialRememberMe = false,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const [secureTextEntry, setSecureTextEntry] = useState(true);
  const [rememberMe, setRememberMe] = useState(initialRememberMe);
  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<LoginFormInputs>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      emailOrUsername: initialEmailOrUsername,
      password: initialPassword,
    },
  });
  React.useEffect(() => {
    if (initialEmailOrUsername || initialPassword) {
      reset({
        emailOrUsername: initialEmailOrUsername || '',
        password: initialPassword || '',
      });
    }
  }, [initialEmailOrUsername, initialPassword, reset]);
  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };
  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        container: {
          width: '100%',
        },
        input: {
          marginBottom: 8,
          fontSize: responsive.fontSizePreset.m,
        },
        firstInput: {
          marginTop: responsive.spacingPreset.xs,
        },
        button: {
          marginTop: 16,
          paddingVertical: responsive.spacingPreset.xs,
        },
        helperText: {
          marginBottom: responsive.spacingPreset.xs,
          fontSize: responsive.fontSizePreset.s,
        },
        checkboxContainer: {
          flexDirection: 'row',
          alignItems: 'center',
          marginTop: 4,
          marginBottom: 8,
        },
        checkbox: {},
        checkboxLabel: {
          color: theme.colors.onSurface,
          marginLeft: responsive.spacingPreset.s,
          flex: 1,
          flexShrink: 1,
          fontSize: responsive.fontSizePreset.m,
        },
      }),
    [theme, responsive],
  );
  return (
    <View style={styles.container}>
      <Controller
        control={control}
        name="emailOrUsername"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Correo o Usuario"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              error={!!errors.emailOrUsername}
              style={[styles.input, styles.firstInput]}
              autoCapitalize="none"
              keyboardType="email-address"
              disabled={isLoading}
            />
            {errors.emailOrUsername && (
              <HelperText
                type="error"
                visible={!!errors.emailOrUsername}
                style={styles.helperText}
              >
                <Text>{errors.emailOrUsername?.message}</Text>
              </HelperText>
            )}
          </View>
        )}
      />
      <Controller
        control={control}
        name="password"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Contraseña"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              secureTextEntry={secureTextEntry}
              error={!!errors.password}
              style={styles.input}
              autoCapitalize="none"
              right={
                <TextInput.Icon
                  icon={secureTextEntry ? 'eye' : 'eye-off'}
                  onPress={toggleSecureEntry}
                  forceTextInputFocus={false}
                  color={errors.password ? theme.colors.error : undefined}
                />
              }
              disabled={isLoading}
            />
            {errors.password && (
              <HelperText
                type="error"
                visible={!!errors.password}
                style={styles.helperText}
              >
                <Text>{errors.password?.message}</Text>
              </HelperText>
            )}
          </View>
        )}
      />
      <TouchableRipple
        onPress={() => !isLoading && setRememberMe(!rememberMe)}
        style={styles.checkboxContainer}
        disabled={isLoading}
      >
        <>
          <Checkbox
            status={rememberMe ? 'checked' : 'unchecked'}
            onPress={() => setRememberMe(!rememberMe)}
            disabled={isLoading}
          />
          <Text
            style={styles.checkboxLabel}
            numberOfLines={1}
            adjustsFontSizeToFit
            minimumFontScale={0.8}
            disabled={isLoading}
          >
            Recordarme
          </Text>
        </>
      </TouchableRipple>
      <Button
        mode="contained"
        onPress={handleSubmit((data) => onSubmit(data, rememberMe))}
        loading={isLoading}
        disabled={isLoading}
        style={[
          styles.button,
          {
            backgroundColor: theme.colors.primary,
            borderRadius: 30,
          },
        ]}
        contentStyle={{
          height: 42,
          paddingHorizontal: responsive.spacingPreset.s,
        }}
        labelStyle={{
          fontSize: responsive.fontSizePreset.m,
          fontWeight: '600',
        }}
      >
        {isLoading ? 'Ingresando...' : 'Ingresar'}
      </Button>
    </View>
  );
};
export default LoginForm;

================
File: app/src/modules/availability/components/CategoryAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch, Divider, IconButton } from 'react-native-paper';
import { CategoryAvailability } from '../types/availability.types';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';
interface CategoryAvailabilityItemProps {
  category: CategoryAvailability;
  onRefresh?: () => void;
}
export const CategoryAvailabilityItem: React.FC<
  CategoryAvailabilityItemProps
> = ({ category, onRefresh: _onRefresh }) => {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();
  const handleCategoryToggle = (value: boolean) => {
    updateAvailability.mutate({
      type: 'category',
      id: category.id,
      isActive: value,
      cascade: true,
    });
  };
  const handleSubcategoryToggle = (subcategoryId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'subcategory',
      id: subcategoryId,
      isActive: value,
      cascade: true,
    });
  };
  const handleProductToggle = (productId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'product',
      id: productId,
      isActive: value,
    });
  };
  const totalProducts = category.subcategories.reduce(
    (acc, sub) => acc + sub.products.length,
    0,
  );
  const activeProducts = category.subcategories.reduce(
    (acc, sub) => acc + sub.products.filter((p) => p.isActive).length,
    0,
  );
  return (
    <AvailabilityListItem
      title={category.name}
      subtitle={`${activeProducts}/${totalProducts} productos activos`}
      icon="folder-outline"
      isActive={category.isActive}
      onToggle={handleCategoryToggle}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      {category.subcategories.map((subcategory, index) => (
        <View key={subcategory.id}>
          {index > 0 && <Divider style={styles.divider} />}
          <View
            style={[
              styles.subcategoryHeader,
              { opacity: subcategory.isActive ? 1 : 0.6 },
            ]}
          >
            <View style={styles.subcategoryLeft}>
              <IconButton
                icon="folder-open-outline"
                size={16}
                iconColor={
                  subcategory.isActive
                    ? theme.colors.primary
                    : theme.colors.outline
                }
                style={{ margin: 0, marginRight: 8 }}
              />
              <Text
                style={[
                  styles.subcategoryTitle,
                  { color: theme.colors.onSurface },
                ]}
              >
                {subcategory.name}
              </Text>
            </View>
            <Switch
              value={subcategory.isActive}
              onValueChange={(value) =>
                handleSubcategoryToggle(subcategory.id, value)
              }
              disabled={!category.isActive}
            />
          </View>
          <View style={styles.productsContainer}>
            {subcategory.products.map((product) => (
              <View
                key={product.id}
                style={[
                  styles.productItem,
                  { opacity: !product.isActive ? 0.5 : 1 },
                ]}
              >
                <Text
                  style={[
                    styles.productTitle,
                    !product.isActive && styles.strikethrough,
                    { color: theme.colors.onSurface },
                  ]}
                >
                  {product.name}
                </Text>
                <Switch
                  value={product.isActive}
                  onValueChange={(value) =>
                    handleProductToggle(product.id, value)
                  }
                  disabled={!category.isActive || !subcategory.isActive}
                />
              </View>
            ))}
          </View>
        </View>
      ))}
    </AvailabilityListItem>
  );
};
const styles = StyleSheet.create({
  divider: {
    marginVertical: 8,
  },
  subcategoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
  },
  subcategoryLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  subcategoryTitle: {
    fontSize: 14,
    fontWeight: '500',
  },
  productsContainer: {
    paddingLeft: 16,
  },
  productItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  productTitle: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
});

================
File: app/src/modules/availability/components/PizzaCustomizationAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch, Divider } from 'react-native-paper';
import { PizzaCustomizationGroupAvailability } from '../types/availability.types';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';
interface PizzaCustomizationAvailabilityItemProps {
  group: PizzaCustomizationGroupAvailability;
}
export function PizzaCustomizationAvailabilityItem({
  group,
}: PizzaCustomizationAvailabilityItemProps) {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();
  const handleToggle = (id: string, currentState: boolean) => {
    updateAvailability.mutate({
      type: 'pizzaCustomization',
      id,
      isActive: !currentState,
    });
  };
  const activeCount = group.items.filter((item) => item.isActive).length;
  const totalCount = group.items.length;
  const allActive = activeCount === totalCount;
  const someActive = activeCount > 0 && activeCount < totalCount;
  const getTypeIcon = () => {
    return group.type === 'FLAVOR' ? 'pizza' : 'cheese';
  };
  const getTypeLabel = () => {
    return group.type === 'FLAVOR' ? 'Sabores' : 'Ingredientes';
  };
  const getSubtitle = () => {
    if (allActive) return 'Todos disponibles';
    if (!allActive && !someActive) return 'Ninguno disponible';
    return `${activeCount} de ${totalCount} disponibles`;
  };
  return (
    <AvailabilityListItem
      title={getTypeLabel()}
      subtitle={getSubtitle()}
      icon={getTypeIcon()}
      isActive={allActive}
      onToggle={() => {}}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      {group.items.map((item, index) => (
        <React.Fragment key={item.id}>
          <View style={styles.item}>
            <Text
              style={[
                styles.itemName,
                !item.isActive && styles.strikethrough,
                { color: theme.colors.onSurface },
              ]}
            >
              {item.name}
            </Text>
            <Switch
              value={item.isActive}
              onValueChange={() => handleToggle(item.id, item.isActive)}
            />
          </View>
          {index < group.items.length - 1 && <Divider style={styles.divider} />}
        </React.Fragment>
      ))}
    </AvailabilityListItem>
  );
}
const styles = StyleSheet.create({
  item: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  itemName: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
  divider: {
    marginVertical: 8,
  },
});

================
File: app/src/modules/availability/screens/AvailabilityScreen.tsx
================
import React, { useState, useMemo, useCallback } from 'react';
import { View, StyleSheet, RefreshControl, FlatList } from 'react-native';
import {
  Searchbar,
  SegmentedButtons as _SegmentedButtons,
  ActivityIndicator,
  Surface,
  Text,
  Menu,
  IconButton,
  Badge as _Badge,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { CategoryAvailabilityItem } from '../components/CategoryAvailabilityItem';
import { ModifierGroupAvailabilityItem } from '../components/ModifierGroupAvailabilityItem';
import { PizzaCustomizationAvailabilityItem } from '../components/PizzaCustomizationAvailabilityItem';
import {
  useMenuAvailability,
  useModifierGroupsAvailability,
} from '../hooks/useAvailabilityQueries';
import { usePizzaCustomizationsAvailability } from '../hooks/usePizzaCustomizationsAvailability';
import EmptyState from '@/app/components/common/EmptyState';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
export const AvailabilityScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [searchQuery, setSearchQuery] = useState('');
  const [viewMode, setViewMode] = useState<
    'menu' | 'modifiers' | 'pizzaCustomizations'
  >('menu');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const {
    data: menuData,
    isLoading: isLoadingMenu,
    isError: isErrorMenu,
    refetch: refetchMenu,
  } = useMenuAvailability();
  const {
    data: modifiersData,
    isLoading: isLoadingModifiers,
    isError: isErrorModifiers,
    refetch: refetchModifiers,
  } = useModifierGroupsAvailability();
  const {
    data: pizzaCustomizationsData,
    isLoading: isLoadingPizzaCustomizations,
    isError: isErrorPizzaCustomizations,
    refetch: refetchPizzaCustomizations,
  } = usePizzaCustomizationsAvailability(searchQuery);
  useRefreshModuleOnFocus('availability');
  const handleRefresh = useCallback(() => {
    if (viewMode === 'menu') {
      refetchMenu();
    } else if (viewMode === 'modifiers') {
      refetchModifiers();
    } else {
      refetchPizzaCustomizations();
    }
  }, [viewMode, refetchMenu, refetchModifiers, refetchPizzaCustomizations]);
  const filteredMenuData = useMemo(() => {
    if (!menuData) return [];
    return menuData
      .map((category) => ({
        ...category,
        subcategories: category.subcategories
          .map((subcategory) => ({
            ...subcategory,
            products: subcategory.products.filter((product) => {
              const matchesSearch = product.name
                .toLowerCase()
                .includes(searchQuery.toLowerCase());
              return matchesSearch;
            }),
          }))
          .filter((subcategory) => subcategory.products.length > 0),
      }))
      .filter((category) => category.subcategories.length > 0);
  }, [menuData, searchQuery]);
  const filteredModifiersData = useMemo(() => {
    if (!modifiersData) return [];
    return modifiersData
      .map((group) => ({
        ...group,
        modifiers: group.modifiers.filter((modifier) => {
          const matchesSearch = modifier.name
            .toLowerCase()
            .includes(searchQuery.toLowerCase());
          return matchesSearch;
        }),
      }))
      .filter((group) => {
        const matchesSearch = group.name
          .toLowerCase()
          .includes(searchQuery.toLowerCase());
        return matchesSearch || group.modifiers.length > 0;
      });
  }, [modifiersData, searchQuery]);
  const isLoading =
    viewMode === 'menu'
      ? isLoadingMenu
      : viewMode === 'modifiers'
        ? isLoadingModifiers
        : isLoadingPizzaCustomizations;
  const isError =
    viewMode === 'menu'
      ? isErrorMenu
      : viewMode === 'modifiers'
        ? isErrorModifiers
        : isErrorPizzaCustomizations;
  const isEmpty =
    viewMode === 'menu'
      ? filteredMenuData.length === 0
      : viewMode === 'modifiers'
        ? filteredModifiersData.length === 0
        : !pizzaCustomizationsData || pizzaCustomizationsData.length === 0;
  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      edges={['top']}
    >
      <Surface style={styles.header} elevation={2}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder={`Buscar ${viewMode === 'menu' ? 'productos' : viewMode === 'modifiers' ? 'modificadores' : 'ingredientes y sabores'}...`}
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            icon="magnify"
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={
                    viewMode === 'menu'
                      ? 'food'
                      : viewMode === 'modifiers'
                        ? 'tune'
                        : 'cheese'
                  }
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setViewMode('menu');
                  setFilterMenuVisible(false);
                }}
                title="Menú"
                leadingIcon="food"
                trailingIcon={viewMode === 'menu' ? 'check' : undefined}
                titleStyle={
                  viewMode === 'menu'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setViewMode('modifiers');
                  setFilterMenuVisible(false);
                }}
                title="Modificadores"
                leadingIcon="tune"
                trailingIcon={viewMode === 'modifiers' ? 'check' : undefined}
                titleStyle={
                  viewMode === 'modifiers'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setViewMode('pizzaCustomizations');
                  setFilterMenuVisible(false);
                }}
                title="Ingredientes Pizza"
                leadingIcon="cheese"
                trailingIcon={
                  viewMode === 'pizzaCustomizations' ? 'check' : undefined
                }
                titleStyle={
                  viewMode === 'pizzaCustomizations'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
            </Menu>
          </View>
        </View>
      </Surface>
      <View style={styles.content}>
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text
              style={[
                styles.loadingText,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Cargando{' '}
              {viewMode === 'menu'
                ? 'categorías'
                : viewMode === 'modifiers'
                  ? 'modificadores'
                  : 'ingredientes'}
              ...
            </Text>
          </View>
        ) : isError ? (
          <EmptyState
            title="Error al cargar datos"
            message="No se pudieron cargar los datos. Verifica tu conexión."
            icon="alert-circle-outline"
            actionLabel="Reintentar"
            onAction={handleRefresh}
          />
        ) : isEmpty ? (
          <EmptyState
            title="No se encontraron resultados"
            message={
              searchQuery
                ? 'Intenta con otros términos de búsqueda'
                : 'No hay elementos para mostrar'
            }
            icon="magnify"
          />
        ) : viewMode === 'menu' ? (
          <FlatList
            data={filteredMenuData}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => (
              <CategoryAvailabilityItem
                category={item}
                onRefresh={handleRefresh}
              />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        ) : viewMode === 'modifiers' ? (
          <FlatList
            data={filteredModifiersData}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => (
              <ModifierGroupAvailabilityItem
                modifierGroup={item}
                onRefresh={handleRefresh}
              />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        ) : (
          <FlatList
            data={pizzaCustomizationsData || []}
            keyExtractor={(item) => item.type}
            renderItem={({ item }) => (
              <PizzaCustomizationAvailabilityItem group={item} />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        )}
      </View>
    </SafeAreaView>
  );
};
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
      borderBottomLeftRadius: 24,
      borderBottomRightRadius: 24,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    searchbar: {
      flex: 1,
      borderRadius: 12,
      height: responsive.isTablet ? 42 : 48,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
    },
    menuContent: {
      marginTop: responsive.spacing(4),
    },
    content: {
      flex: 1,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.spacing(theme.spacing.m),
      fontSize: responsive.fontSize(14),
    },
    listContent: {
      paddingVertical: responsive.spacing(theme.spacing.m),
    },
  });

================
File: app/src/modules/customers/screens/CustomersScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Portal, Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import debounce from 'lodash.debounce';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import {
  useCustomers,
  useCreateCustomer,
  useUpdateCustomer,
  useDeleteCustomer,
} from '../hooks/useCustomersQueries';
import { Customer } from '../types/customer.types';
import { CustomerFormInputs } from '../schema/customer.schema';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import GenericList, { FilterOption } from '@/app/components/crud/GenericList';
import GenericDetailModal from '@/app/components/crud/GenericDetailModal';
import CustomerFormModal from '../components/CustomerFormModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useListState } from '@/app/hooks/useListState';
import { formatCurrency } from '@/app/lib/formatters';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
function CustomersScreen(): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'active' | 'inactive' | 'banned'
  >('all');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(
    null,
  );
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [customerToDelete, setCustomerToDelete] = useState<string | null>(null);
  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );
  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };
  const handleFilterChange = (value: string | number) => {
    if (
      value === 'all' ||
      value === 'active' ||
      value === 'inactive' ||
      value === 'banned'
    ) {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };
  const queryFilters = useMemo(() => {
    const filters: any = {};
    if (debouncedSearchQuery) {
      filters.firstName = debouncedSearchQuery;
      filters.lastName = debouncedSearchQuery;
    }
    if (statusFilter === 'active') {
      filters.isActive = true;
    } else if (statusFilter === 'inactive') {
      filters.isActive = false;
    } else if (statusFilter === 'banned') {
      filters.isBanned = true;
    }
    return filters;
  }, [debouncedSearchQuery, statusFilter]);
  const {
    data: customers,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useCustomers(queryFilters);
  const createMutation = useCreateCustomer();
  const updateMutation = useUpdateCustomer();
  const { mutateAsync: deleteCustomer } = useDeleteCustomer();
  useRefreshModuleOnFocus('customers');
  const {
    isFormModalVisible,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal: originalHandleOpenEditModal,
    handleCloseModals: originalHandleCloseModals,
  } = useCrudScreenLogic<Customer>({
    entityName: 'Cliente',
    queryKey: ['customers', queryFilters],
    deleteMutationFn: deleteCustomer,
  });
  const handleOpenEditModal = useCallback(
    (item: any) => {
      setDetailModalVisible(false);
      const { fullName, ...originalCustomer } = item;
      originalHandleOpenEditModal(originalCustomer as Customer);
    },
    [originalHandleOpenEditModal],
  );
  const handleCloseModals = useCallback(() => {
    originalHandleCloseModals();
    setDetailModalVisible(false);
  }, [originalHandleCloseModals]);
  const handleItemPress = useCallback((item: Customer) => {
    setSelectedCustomer(item);
    setDetailModalVisible(true);
  }, []);
  const handleDelete = useCallback((id: string) => {
    setCustomerToDelete(id);
    setShowDeleteConfirmation(true);
  }, []);
  const handleConfirmDelete = useCallback(async () => {
    if (!customerToDelete) return;
    try {
      await deleteCustomer(customerToDelete);
      showSnackbar({
        message: 'Cliente eliminado con éxito',
        type: 'success',
      });
      setDetailModalVisible(false);
      setShowDeleteConfirmation(false);
      setCustomerToDelete(null);
    } catch (error) {
      showSnackbar({
        message: 'Error al eliminar el cliente',
        type: 'error',
      });
    }
  }, [deleteCustomer, showSnackbar, customerToDelete]);
  const filterOptions: FilterOption<
    'all' | 'active' | 'inactive' | 'banned'
  >[] = [
    { label: 'Todos', value: 'all' },
    { label: 'Activos', value: 'active' },
    { label: 'Inactivos', value: 'inactive' },
    { label: 'Baneados', value: 'banned' },
  ];
  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: !!error,
    data: customers,
    emptyConfig: {
      title: 'No hay clientes',
      message:
        statusFilter !== 'all'
          ? `No hay clientes ${
              statusFilter === 'active'
                ? 'activos'
                : statusFilter === 'inactive'
                  ? 'inactivos'
                  : 'baneados'
            }.`
          : 'No hay clientes registrados. Presiona el botón + para crear el primero.',
      icon: 'account-group-outline',
    },
    errorConfig: {
      title: 'Error al cargar clientes',
      message: 'No se pudieron cargar los clientes. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });
  const mappedCustomers = useMemo(() => {
    return (
      customers?.map((customer) => ({
        ...customer,
        fullName: `${customer.firstName} ${customer.lastName}`.trim(),
        displayTitle:
          `${customer.firstName} ${customer.lastName} - ${customer.whatsappPhoneNumber}`.trim(),
        displayStatus: customer.isActive ? 'active' : 'inactive',
        whatsappInfo:
          customer.whatsappMessageCount > 0
            ? `💬 ${customer.whatsappMessageCount}`
            : null,
      })) || []
    );
  }, [customers]);
  const handleSubmit = useCallback(
    async (data: CustomerFormInputs) => {
      try {
        if (editingItem) {
          await updateMutation.mutateAsync({
            id: editingItem.id,
            data,
          });
          showSnackbar({
            message: 'Cliente actualizado con éxito',
            type: 'success',
          });
        } else {
          await createMutation.mutateAsync(data);
          showSnackbar({
            message: 'Cliente creado con éxito',
            type: 'success',
          });
        }
        handleCloseModals();
      } catch (error) {
        showSnackbar({
          message: 'Error al guardar el cliente',
          type: 'error',
        });
      }
    },
    [
      editingItem,
      createMutation,
      updateMutation,
      handleCloseModals,
      showSnackbar,
    ],
  );
  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        <GenericList
          items={mappedCustomers}
          isLoading={isLoading}
          isRefreshing={isFetching}
          onRefresh={refetch}
          onItemPress={handleItemPress}
          renderConfig={{
            titleField: 'displayTitle' as keyof Customer,
            statusConfig: {
              field: 'displayStatus' as keyof Customer,
              activeValue: 'active',
              activeLabel: 'Activo',
              inactiveLabel: 'Inactivo',
            },
            renderDescription: (item: any) => (
              <View>
                {item.email && (
                  <Text variant="bodySmall" style={{ opacity: 0.7 }}>
                    {item.email}
                  </Text>
                )}
                <View style={{ flexDirection: 'row', gap: 8, marginTop: 2 }}>
                  <Text variant="bodySmall" style={{ opacity: 0.7 }}>
                    {item.isBanned ? '⛔ Baneado' : '✅ No baneado'}
                  </Text>
                  <Text variant="bodySmall" style={{ opacity: 0.7 }}>
                    • 📍 {item.addresses?.length || 0} direcciones
                  </Text>
                </View>
              </View>
            ),
          }}
          searchQuery={searchQuery}
          onSearchChange={handleSearchChange}
          searchPlaceholder="Buscar por nombre..."
          filterOptions={filterOptions}
          filterValue={statusFilter}
          onFilterChange={handleFilterChange}
          showFab={true}
          onFabPress={handleOpenCreateModal}
          ListEmptyComponent={ListEmptyComponent}
          isDrawerOpen={isDrawerOpen}
          enableSearch={true}
          showImagePlaceholder={false}
          placeholderIcon="account-group-outline"
        />
      </View>
      <Portal>
        <CustomerFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSubmit={handleSubmit}
          editingItem={editingItem}
          isSubmitting={createMutation.isPending || updateMutation.isPending}
        />
        <GenericDetailModal
          visible={detailModalVisible}
          onDismiss={() => setDetailModalVisible(false)}
          item={
            selectedCustomer
              ? {
                  ...selectedCustomer,
                  fullName:
                    `${selectedCustomer.firstName} ${selectedCustomer.lastName}`.trim(),
                }
              : null
          }
          titleField="fullName"
          descriptionField="email"
          statusConfig={{
            field: 'isActive' as keyof Customer,
            activeValue: true,
            activeLabel: 'Activo',
            inactiveLabel: 'Inactivo',
          }}
          onEdit={handleOpenEditModal}
          onDelete={handleDelete}
          isDeleting={false}
          showImage={false}
          fieldsToDisplay={[
            {
              field: 'isBanned' as keyof Customer,
              label: 'Estado de baneo',
              render: (value) => (value ? '⛔ Baneado' : '✅ No baneado'),
            },
            {
              field: 'whatsappPhoneNumber' as keyof Customer,
              label: 'WhatsApp',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'stripeCustomerId' as keyof Customer,
              label: 'Stripe Customer ID',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'email' as keyof Customer,
              label: 'Correo',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'birthDate' as keyof Customer,
              label: 'Fecha de nacimiento',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleDateString()
                  : 'No registrada',
            },
            {
              field: 'addresses' as keyof Customer,
              label: 'Direcciones',
              render: (value) => {
                const addresses = value as any[];
                const count = addresses?.length || 0;
                if (count === 0) return '❌ Sin direcciones';
                if (count === 1) return '📍 1 dirección';
                return `📍 ${count} direcciones ${count > 3 ? '✨' : ''}`;
              },
            },
            {
              field: 'totalOrders' as keyof Customer,
              label: 'Total de pedidos',
              render: (value) => value?.toString() || '0',
            },
            {
              field: 'totalSpent' as keyof Customer,
              label: 'Total gastado',
              render: (value) => formatCurrency((value as number) || 0),
            },
            {
              field: 'lastInteraction' as keyof Customer,
              label: 'Última interacción',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleString()
                  : 'Sin interacciones',
            },
            {
              field: 'whatsappMessageCount' as keyof Customer,
              label: 'Mensajes de WhatsApp',
              render: (value) => `${value || 0} mensajes`,
            },
            {
              field: 'lastWhatsappMessageTime' as keyof Customer,
              label: 'Último mensaje WhatsApp',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleString()
                  : 'Sin mensajes',
            },
          ]}
        />
        <ConfirmationModal
          visible={showDeleteConfirmation}
          title="Confirmar Eliminación"
          message="¿Estás seguro de que quieres eliminar este cliente? Esta acción no se puede deshacer."
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
          onConfirm={handleConfirmDelete}
          onCancel={() => {
            setShowDeleteConfirmation(false);
            setCustomerToDelete(null);
          }}
          onDismiss={() => {
            setShowDeleteConfirmation(false);
            setCustomerToDelete(null);
          }}
        />
      </Portal>
    </SafeAreaView>
  );
}
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    rightContent: {
      flexDirection: 'column',
      alignItems: 'flex-end',
      gap: theme.spacing.xs,
    },
    activeChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    inactiveChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    statsChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
  });
export default CustomersScreen;

================
File: app/src/modules/kitchen/hooks/useKitchenOrders.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { kitchenService } from '../services/kitchenService';
import { KitchenFilters } from '../types/kitchen.types';
import { useKitchenSnackbar } from './useKitchenSnackbar';
export const KITCHEN_ORDERS_KEY = 'kitchen-orders';
export function useKitchenOrders(filters: Partial<KitchenFilters> = {}) {
  return useQuery({
    queryKey: [KITCHEN_ORDERS_KEY, filters],
    queryFn: () => kitchenService.getKitchenOrders(filters),
    refetchInterval: 30000,
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 25000,
    gcTime: 5 * 60 * 1000,
    keepPreviousData: true,
    notifyOnChangeProps: ['data', 'error'],
  });
}
export function useUpdateKitchenItem() {
  const queryClient = useQueryClient();
  const { showError } = useKitchenSnackbar();
  const updateAllQueriesForItem = (itemId: string, isPrepared: boolean) => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    const previousData: any[] = [];
    queries.forEach((query) => {
      const queryKey = query.queryKey;
      if (Array.isArray(queryKey) && queryKey[0] === KITCHEN_ORDERS_KEY) {
        const oldData = query.state.data;
        if (oldData) {
          previousData.push([queryKey, oldData]);
          queryClient.setQueryData(queryKey, (old: any) => {
            if (!old || !Array.isArray(old)) return old;
            return old.map((order: any) => ({
              ...order,
              items: order.items?.map((item: any) =>
                item.id === itemId
                  ? {
                      ...item,
                      preparationStatus: isPrepared ? 'READY' : 'IN_PROGRESS',
                      preparedAt: isPrepared ? new Date().toISOString() : null,
                    }
                  : item,
              ),
            }));
          });
        }
      }
    });
    return previousData;
  };
  const rollbackAllQueries = (previousData: any[]) => {
    previousData.forEach(([queryKey, data]) => {
      queryClient.setQueryData(queryKey, data);
    });
  };
  return useMutation({
    mutationFn: ({
      itemId,
      isPrepared,
    }: {
      itemId: string;
      isPrepared: boolean;
    }) => kitchenService.markItemPrepared(itemId, isPrepared),
    onMutate: async ({ itemId, isPrepared }) => {
      await queryClient.cancelQueries({ queryKey: [KITCHEN_ORDERS_KEY] });
      const previousData = updateAllQueriesForItem(itemId, isPrepared);
      return { previousData };
    },
    onError: (error: any, variables, context) => {
      if (context?.previousData) {
        rollbackAllQueries(context.previousData);
      }
      showError(error.response?.data?.message || 'Error al actualizar el item');
    },
    onSettled: () => {
      setTimeout(() => {
        queryClient.invalidateQueries({
          queryKey: [KITCHEN_ORDERS_KEY],
          refetchType: 'none',
        });
      }, 2000);
    },
  });
}
export function useUpdateKitchenOrderStatus() {
  const queryClient = useQueryClient();
  const { showError } = useKitchenSnackbar();
  const updateAllQueriesForOrder = (
    orderId: string,
    status: string,
    extraUpdates?: any,
  ) => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    const previousData: any[] = [];
    queries.forEach((query) => {
      const queryKey = query.queryKey;
      if (Array.isArray(queryKey) && queryKey[0] === KITCHEN_ORDERS_KEY) {
        const oldData = query.state.data;
        if (oldData) {
          previousData.push([queryKey, oldData]);
          queryClient.setQueryData(queryKey, (old: any) => {
            if (!old || !Array.isArray(old)) return old;
            return old.map((order: any) =>
              order.id === orderId
                ? {
                    ...order,
                    myScreenStatus: status,
                    preparationStartedAt:
                      status === 'IN_PREPARATION'
                        ? new Date().toISOString()
                        : order.preparationStartedAt,
                    preparationCompletedAt:
                      status === 'READY'
                        ? new Date().toISOString()
                        : order.preparationCompletedAt,
                    items:
                      status === 'PENDING'
                        ? order.items?.map((item: any) => ({
                            ...item,
                            preparationStatus: item.belongsToMyScreen
                              ? 'IN_PROGRESS'
                              : item.preparationStatus,
                            preparedAt: item.belongsToMyScreen
                              ? null
                              : item.preparedAt,
                          }))
                        : order.items,
                    ...extraUpdates,
                  }
                : order,
            );
          });
        }
      }
    });
    return previousData;
  };
  const rollbackAllQueries = (previousData: any[]) => {
    previousData.forEach(([queryKey, data]) => {
      queryClient.setQueryData(queryKey, data);
    });
  };
  return {
    updateStatus: useMutation({
      mutationFn: ({
        orderId,
        status,
        serverAction,
      }: {
        orderId: string;
        status: string;
        serverAction: () => Promise<any>;
      }) => serverAction(),
      onMutate: async ({ orderId, status }) => {
        await queryClient.cancelQueries({ queryKey: [KITCHEN_ORDERS_KEY] });
        const previousData = updateAllQueriesForOrder(orderId, status);
        return { previousData };
      },
      onError: (error: any, variables, context) => {
        if (context?.previousData) {
          rollbackAllQueries(context.previousData);
        }
        showError(error.response?.data?.message || 'Error al actualizar orden');
      },
      onSettled: () => {
        setTimeout(() => {
          queryClient.invalidateQueries({
            queryKey: [KITCHEN_ORDERS_KEY],
            refetchType: 'none',
          });
        }, 2000);
      },
    }),
    startPreparation: (orderId: string) => ({
      orderId,
      status: 'IN_PREPARATION',
      serverAction: () => kitchenService.startOrderPreparation(orderId),
    }),
    cancelPreparation: (orderId: string) => ({
      orderId,
      status: 'PENDING',
      serverAction: () => kitchenService.cancelOrderPreparation(orderId),
    }),
    completePreparation: (orderId: string) => ({
      orderId,
      status: 'READY',
      serverAction: () => kitchenService.completeOrderPreparation(orderId),
    }),
  };
}
export function useStartOrderPreparation() {
  const { updateStatus, startPreparation } = useUpdateKitchenOrderStatus();
  return useMutation({
    mutationFn: (orderId: string) => {
      const params = startPreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}
export function useCancelOrderPreparation() {
  const { updateStatus, cancelPreparation } = useUpdateKitchenOrderStatus();
  return useMutation({
    mutationFn: (orderId: string) => {
      const params = cancelPreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}
export function useCompleteOrderPreparation() {
  const { updateStatus, completePreparation } = useUpdateKitchenOrderStatus();
  return useMutation({
    mutationFn: (orderId: string) => {
      const params = completePreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}
export function useMarkItemPrepared() {
  const updateItem = useUpdateKitchenItem();
  return useMutation({
    mutationFn: ({
      itemId,
      isPrepared,
    }: {
      itemId: string;
      isPrepared: boolean;
    }) => {
      return updateItem.mutateAsync({ itemId, isPrepared });
    },
  });
}

================
File: app/src/modules/kitchen/store/kitchenStore.ts
================
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import EncryptedStorage from '@/app/services/secureStorageService';
import { KitchenFilters } from '../types/kitchen.types';
const KITCHEN_FILTERS_STORAGE_KEY = 'kitchen_filters_preferences';
interface KitchenStore {
  filters: KitchenFilters;
  setFilters: (filters: KitchenFilters) => void;
  resetFilters: () => void;
}
const defaultFilters: KitchenFilters = {
  orderType: undefined,
  showPrepared: true,
  showAllProducts: true,
  ungroupProducts: false,
};
export const useKitchenStore = create<KitchenStore>()(
  persist(
    (set) => ({
      filters: defaultFilters,
      setFilters: (filters) => set({ filters }),
      resetFilters: () => set({ filters: defaultFilters }),
    }),
    {
      name: KITCHEN_FILTERS_STORAGE_KEY,
      storage: createJSONStorage(() => EncryptedStorage),
      partialize: (state) => ({ filters: state.filters }),
      onRehydrateStorage: () => {
        return (state, error) => {
          if (error) {
            return;
          }
          if (!state) {
            return;
          }
        };
      },
    },
  ),
);

================
File: app/src/modules/menu/screens/ProductsScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { StyleSheet } from 'react-native';
import { Portal } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRoute, RouteProp, useNavigation } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import debounce from 'lodash.debounce';
import { useQueryClient } from '@tanstack/react-query';
import {
  useProductsQuery,
  useCreateProductMutation,
  useUpdateProductMutation,
  useDeleteProductMutation,
} from '../hooks/useProductsQueries';
import { Product, ProductFormInputs } from '../schema/products.schema';
import { MenuStackParamList } from '@/modules/menu/navigation/types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import GenericList, { FilterOption } from '@/app/components/crud/GenericList';
import ProductFormModal from '../components/ProductFormModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { FileObject } from '@/app/components/common/CustomImagePicker';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
type ProductsScreenRouteProp = RouteProp<MenuStackParamList, 'Products'>;
function ProductsScreen(): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);
  const navigation = useNavigation();
  const route = useRoute<ProductsScreenRouteProp>();
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const { subcategoryId, subCategoryName } = route.params;
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'active' | 'inactive'
  >('all');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );
  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };
  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };
  const queryFilters = useMemo(
    () => ({
      subcategoryId: subcategoryId,
      search: debouncedSearchQuery || undefined,
      limit: 20,
      page: 1,
      isActive: statusFilter === 'all' ? undefined : statusFilter === 'active',
    }),
    [subcategoryId, debouncedSearchQuery, statusFilter],
  );
  const {
    data: productsResponse,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useProductsQuery(queryFilters, {});
  useRefreshModuleOnFocus('products');
  const createMutation = useCreateProductMutation();
  const updateMutation = useUpdateProductMutation();
  const { mutateAsync: deleteProduct } = useDeleteProductMutation();
  const {
    isFormModalVisible,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleCloseModals,
  } = useCrudScreenLogic<Product>({
    entityName: 'Producto',
    queryKey: ['products', queryFilters],
    deleteMutationFn: deleteProduct,
  });
  const products = useMemo(() => {
    return (productsResponse?.data ?? []).map((p: Product) => ({
      ...p,
      displayDescription: p.hasVariants
        ? `${p.variants?.length || 0} variante(s)`
        : !isNaN(parseFloat(String(p.price)))
          ? `$${parseFloat(String(p.price)).toFixed(2)}`
          : 'Precio no definido',
    }));
  }, [productsResponse]);
  const handleFormSubmit = useCallback(
    async (
      formData: ProductFormInputs,
      photoId: string | null | undefined,
      _file?: FileObject | null,
    ) => {
      const isEditing = !!editingItem;
      const { imageUri, ...dataToSend } = formData;
      const mutationData = {
        ...dataToSend,
        modifierGroupIds: dataToSend.modifierGroupIds ?? [],
        ...(photoId !== undefined && { photoId }),
      };
      try {
        let productResult: Product;
        if (isEditing && editingItem) {
          productResult = await updateMutation.mutateAsync({
            id: editingItem.id,
            data: mutationData,
          });
        } else {
          productResult = await createMutation.mutateAsync(mutationData);
        }
        const message = isEditing
          ? 'Producto actualizado con éxito'
          : 'Producto creado con éxito';
        showSnackbar({ message, type: 'success' });
        handleCloseModals();
        queryClient.invalidateQueries({
          queryKey: ['products', queryFilters],
        });
        if (productResult?.id) {
          queryClient.invalidateQueries({
            queryKey: ['product', productResult.id],
          });
        }
      } catch (err) {
        const errorMessage = getApiErrorMessage(err);
        showSnackbar({
          message: `Error al ${isEditing ? 'actualizar' : 'crear'} producto: ${errorMessage}`,
          type: 'error',
        });
      }
    },
    [
      editingItem,
      updateMutation,
      createMutation,
      showSnackbar,
      handleCloseModals,
      queryClient,
      queryFilters,
    ],
  );
  const listRenderConfig = {
    titleField: 'name' as keyof Product,
    descriptionField: 'displayDescription' as keyof (Product & {
      displayDescription: string;
    }),
    imageField: 'photo' as keyof Product,
    sortOrderField: 'sortOrder' as keyof Product,
    statusConfig: {
      field: 'isActive' as keyof Product,
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
  };
  const filterOptions: FilterOption<'all' | 'active' | 'inactive'>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];
  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: !!error,
    data: products,
    emptyConfig: {
      title: debouncedSearchQuery
        ? `No se encontraron productos`
        : 'No hay productos',
      message: debouncedSearchQuery
        ? `No se encontraron productos para "${debouncedSearchQuery}"`
        : `No hay productos en "${subCategoryName}". Presiona el botón + para crear el primero.`,
      icon: 'package-variant',
    },
    errorConfig: {
      title: 'Error al cargar productos',
      message: 'No se pudieron cargar los productos. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });
  React.useLayoutEffect(() => {
    navigation.setOptions({
      title: subCategoryName ? `Productos de ${subCategoryName}` : 'Productos',
    });
  }, [navigation, subCategoryName]);
  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Product & { displayDescription: string }>
        items={products}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenEditModal}
        onRefresh={refetch}
        isRefreshing={isFetching && !isLoading}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading && !isFetching}
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar productos..."
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible}
        enableSort={false}
        contentContainerStyle={styles.contentContainer}
        showImagePlaceholder={true}
        placeholderIcon="food-outline"
        isDrawerOpen={isDrawerOpen}
      />
      <Portal>
        {isFormModalVisible && (
          <ProductFormModal
            visible={isFormModalVisible}
            onDismiss={handleCloseModals}
            onSubmit={handleFormSubmit}
            initialData={editingItem}
            isSubmitting={createMutation.isPending || updateMutation.isPending}
            productId={editingItem?.id}
            subcategoryId={subcategoryId}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
}
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    errorText: {
      color: theme.colors.error,
      textAlign: 'center',
    },
    contentContainer: {
      paddingBottom: 80,
    },
  });
export default ProductsScreen;

================
File: app/src/modules/modifiers/screens/ModifierGroupsScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { StyleSheet } from 'react-native';
import { Text, IconButton } from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import { modifierGroupService } from '../services/modifierGroupService';
import { ModifierGroup } from '../schema/modifierGroup.schema';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import debounce from 'lodash.debounce';
import ModifierGroupFormModal from '../components/ModifierGroupFormModal';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '@/app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '@/app/components/crud/GenericDetailModal';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { PaginatedResponse } from '@/app/types/api.types';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
type NavigationProps = {
  navigate: (screen: string, params?: any) => void;
};
type StatusFilter = 'all' | 'active' | 'inactive';
const QUERY_KEY = ['modifierGroups'];
const ModifierGroupsScreen = () => {
  const theme = useAppTheme();
  const navigation = useNavigation<NavigationProps>();
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );
  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };
  const queryParams = useMemo(() => {
    const params: Parameters<typeof modifierGroupService.findAll>[0] = {};
    if (statusFilter !== 'all') {
      params.isActive = statusFilter === 'active';
    }
    if (debouncedSearchQuery) {
      params.search = debouncedSearchQuery;
    }
    return params;
  }, [statusFilter, debouncedSearchQuery]);
  const {
    data: paginatedData,
    isLoading,
    isError,
    error: _error,
    refetch,
    isRefetching,
  } = useQuery<PaginatedResponse<ModifierGroup>, Error>({
    queryKey: [QUERY_KEY[0], queryParams],
    queryFn: () => modifierGroupService.findAll(queryParams),
  });
  useRefreshModuleOnFocus('modifierGroups');
  const modifierGroups = paginatedData?.data || [];
  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<ModifierGroup>({
    entityName: 'Grupo de Modificadores',
    queryKey: [QUERY_KEY[0], queryParams],
    deleteMutationFn: modifierGroupService.remove,
  });
  const handleNavigateToModifiers = (groupId: string, groupName: string) => {
    navigation.navigate('ModifiersScreen', { groupId, groupName });
  };
  const handleFormSaveSuccess = () => {
    handleCloseModals();
  };
  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value as StatusFilter);
    } else {
      setStatusFilter('all');
    }
  };
  const handleRefresh = () => {
    refetch();
  };
  const listRenderConfig: RenderItemConfig<ModifierGroup> = {
    titleField: 'name',
    descriptionField: 'description',
    sortOrderField: 'sortOrder',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
    renderDescription: (item) => {
      const parts = [];
      if (item.sortOrder !== undefined && item.sortOrder !== null) {
        parts.push(`Orden: ${item.sortOrder}`);
      }
      parts.push(`Requerido: ${item.isRequired ? 'Sí' : 'No'}`);
      parts.push(`Múltiples: ${item.allowMultipleSelections ? 'Sí' : 'No'}`);
      if (item.description) {
        parts.push(item.description);
      }
      return (
        <Text style={{ color: theme.colors.onSurfaceVariant, fontSize: 12 }}>
          {parts.join(' • ')}
        </Text>
      );
    },
  };
  const detailFields: DisplayFieldConfig<ModifierGroup>[] = [
    { field: 'sortOrder', label: 'Orden de Visualización' },
    { field: 'minSelections', label: 'Mín. Selecciones' },
    { field: 'maxSelections', label: 'Máx. Selecciones' },
    {
      field: 'isRequired',
      label: 'Requerido',
      render: (value) => (
        <Text style={{ color: theme.colors.onSurface }}>
          {value ? 'Sí' : 'No'}
        </Text>
      ),
    },
    {
      field: 'allowMultipleSelections',
      label: 'Permite Múltiples',
      render: (value) => (
        <Text style={{ color: theme.colors.onSurface }}>
          {value ? 'Sí' : 'No'}
        </Text>
      ),
    },
  ];
  const styles = useMemo(() => createStyles(theme), [theme]);
  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];
  const { ListEmptyComponent } = useListState({
    isLoading: isLoading && !isRefetching,
    isError,
    data: modifierGroups,
    emptyConfig: {
      title: searchQuery
        ? 'No se encontraron grupos'
        : 'No hay grupos de modificadores',
      message: searchQuery
        ? `No se encontraron grupos para "${searchQuery}"`
        : statusFilter !== 'all'
          ? `No hay grupos de modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'}.`
          : 'No hay grupos de modificadores registrados. Presiona el botón + para crear el primero.',
      icon: 'folder-multiple-outline',
    },
    errorConfig: {
      title: 'Error al cargar grupos',
      message:
        'No se pudieron cargar los grupos de modificadores. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });
  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<ModifierGroup>
        items={modifierGroups}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar grupos..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
        renderItemActions={(item) => (
          <IconButton
            icon="format-list-bulleted"
            size={24}
            onPress={(e) => {
              e.stopPropagation();
              handleNavigateToModifiers(item.id, item.name);
            }}
          />
        )}
      />
      <ModifierGroupFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSaveSuccess={handleFormSaveSuccess}
        initialData={editingItem}
      />
      <GenericDetailModal<ModifierGroup>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        descriptionField="description"
        statusConfig={listRenderConfig.statusConfig}
        fieldsToDisplay={detailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        editButtonLabel="Editar"
        deleteButtonLabel="Eliminar"
        showImage={false}
      ></GenericDetailModal>
    </SafeAreaView>
  );
};
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 20,
    },
    emptyText: {
      textAlign: 'center',
      fontSize: 18,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 8,
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: 10,
      textAlign: 'center',
    },
    detailActionButton: {
      marginTop: theme.spacing.m,
      alignSelf: 'stretch',
      borderRadius: theme.roundness,
    },
  });
export default ModifierGroupsScreen;

================
File: app/src/modules/modifiers/screens/ModifiersScreen.tsx
================
import React, { useLayoutEffect, useCallback, useMemo, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Portal, Button } from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import { modifierService } from '../services/modifierService';
import { Modifier } from '../schema/modifier.schema';
import { useAppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import debounce from 'lodash.debounce';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import ModifierFormModal from '@/modules/modifiers/components/ModifierFormModal';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '@/app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '@/app/components/crud/GenericDetailModal';
import { useListState } from '@/app/hooks/useListState';
type StatusFilter = 'all' | 'active' | 'inactive';
type ModifiersScreenRouteParams = {
  groupId: string;
  groupName: string;
};
type ModifiersScreenRouteProp = RouteProp<
  { params: ModifiersScreenRouteParams },
  'params'
>;
type NavigationProps = {
  goBack: () => void;
  setOptions: (options: object) => void;
};
const ModifiersScreen = () => {
  const theme = useAppTheme();
  const navigation = useNavigation<NavigationProps>();
  const route = useRoute<ModifiersScreenRouteProp>();
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const { groupId, groupName } = route.params ?? {};
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
  const QUERY_KEY = ['modifiers', groupId];
  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );
  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };
  useLayoutEffect(() => {
    if (groupName) {
      navigation.setOptions({
        headerTitle: `Modificadores: ${groupName}`,
      });
    }
  }, [navigation, groupName]);
  const queryParams = useMemo(() => {
    const params: Parameters<typeof modifierService.findByGroupId>[1] = {};
    if (statusFilter !== 'all') {
      params.isActive = statusFilter === 'active';
    }
    if (debouncedSearchQuery) {
      params.search = debouncedSearchQuery;
    }
    return params;
  }, [statusFilter, debouncedSearchQuery]);
  const {
    data: modifiers = [],
    isLoading,
    isError,
    error: _error,
    refetch,
    isRefetching,
  } = useQuery<Modifier[], Error>({
    queryKey: [QUERY_KEY[0], groupId, queryParams],
    queryFn: () => modifierService.findByGroupId(groupId, queryParams),
    enabled: !!groupId,
  });
  useRefreshModuleOnFocus('modifiers');
  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Modifier>({
    entityName: 'Modificador',
    queryKey: QUERY_KEY,
    deleteMutationFn: modifierService.remove,
  });
  const handleFormModalSave = () => {
    handleCloseModals();
  };
  const handleEditFromDetails = (modifier: Modifier) => {
    handleOpenEditModal(modifier);
  };
  const handleFilterChange = (value: StatusFilter) => {
    setStatusFilter(value);
  };
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: modifiers,
    emptyConfig: {
      title: searchQuery
        ? 'No se encontraron modificadores'
        : 'No hay modificadores',
      message: searchQuery
        ? `No se encontraron modificadores para "${searchQuery}"`
        : statusFilter !== 'all'
          ? `No hay modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'} en este grupo.`
          : `No hay modificadores en "${groupName}". Presiona el botón + para crear el primero.`,
      icon: 'format-list-bulleted',
    },
    errorConfig: {
      title: 'Error al cargar modificadores',
      message: 'No se pudieron cargar los modificadores. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });
  if (!groupId) {
    return (
      <View style={styles.centered}>
        <Text style={styles.errorText}>
          Error: No se proporcionó ID del grupo.
        </Text>
        <Button onPress={() => navigation.goBack()}>Volver</Button>
      </View>
    );
  }
  const listRenderConfig: RenderItemConfig<Modifier> = {
    titleField: 'name',
    priceField: 'price',
    sortOrderField: 'sortOrder',
    isDefaultField: 'isDefault',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
  };
  const detailFields: DisplayFieldConfig<Modifier>[] = [
    {
      field: 'price',
      label: 'Precio Adicional',
      render: (value) => (
        <Text style={styles.fieldValue}>
          {value !== null ? `$${Number(value).toFixed(2)}` : 'N/A'}
        </Text>
      ),
    },
    {
      field: 'sortOrder',
      label: 'Orden',
    },
    {
      field: 'isDefault',
      label: 'Por Defecto',
    },
  ];
  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];
  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Modifier>
        items={modifiers}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={refetch}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading && !isRefetching}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar modificadores..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        fabLabel="Añadir Modificador"
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
      />
      <Portal>
        <ModifierFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSaveSuccess={handleFormModalSave}
          initialData={editingItem}
          groupId={groupId}
        />
        <GenericDetailModal<Modifier>
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          item={selectedItem}
          titleField="name"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={detailFields}
          onEdit={handleEditFromDetails}
          deleteConfirmation={deleteConfirmation}
          isDeleting={isDeleting}
          showImage={false}
        />
      </Portal>
    </SafeAreaView>
  );
};
const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 20,
    },
    emptyText: {
      textAlign: 'center',
      fontSize: 18,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 8,
    },
    emptySubText: {
      textAlign: 'center',
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: 10,
      textAlign: 'center',
    },
    fieldValue: {
      flexShrink: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
    },
  });
export default ModifiersScreen;

================
File: app/src/modules/orders/components/CartButton.tsx
================
import React, { useRef, useCallback, useMemo } from 'react';
import { StyleSheet, View, Animated } from 'react-native';
import { IconButton, Badge, useTheme, MD3Theme } from 'react-native-paper';
interface CartButtonProps {
  itemCount: number;
  onPress: () => void;
}
const createStyles = (theme: MD3Theme) =>
  StyleSheet.create({
    cartButton: {
      margin: 0,
      backgroundColor: theme.colors.surfaceVariant,
      zIndex: 999,
    },
    cartBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: theme.colors.error,
      zIndex: 1000,
    },
    touchableArea: {
      padding: 5,
    },
    animatedContainer: {
    },
    badgeContainer: {
      position: 'absolute',
      top: 0,
      right: 0,
      pointerEvents: 'none',
    },
  });
const CartButton = React.forwardRef(
  ({ itemCount, onPress }: CartButtonProps, ref) => {
    const theme = useTheme();
    const cartBadgeScale = useRef(new Animated.Value(1)).current;
    const cartBounceAnimation = useRef(new Animated.Value(1)).current;
    const isPressedRef = useRef(false);
    const styles = useMemo(() => createStyles(theme), [theme]);
    const animateCartButton = () => {
      Animated.sequence([
        Animated.timing(cartBounceAnimation, {
          toValue: 1.3,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(cartBounceAnimation, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
      Animated.sequence([
        Animated.timing(cartBadgeScale, {
          toValue: 1.6,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(cartBadgeScale, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    };
    React.useImperativeHandle(ref, () => ({
      animate: animateCartButton,
    }));
    const handlePress = useCallback(() => {
      if (isPressedRef.current) return;
      isPressedRef.current = true;
      onPress();
      setTimeout(() => {
        isPressedRef.current = false;
      }, 150);
    }, [onPress]);
    return (
      <View style={styles.touchableArea}>
        <Animated.View
          style={[
            styles.animatedContainer,
            { transform: [{ scale: cartBounceAnimation }] },
          ]}
        >
          <IconButton
            icon="cart-outline"
            iconColor={theme.colors.primary}
            size={30}
            onPress={handlePress}
            style={styles.cartButton}
            rippleColor={theme.colors.primary + '20'}
          />
        </Animated.View>
        {itemCount > 0 && (
          <Animated.View
            style={[
              styles.badgeContainer,
              { transform: [{ scale: cartBadgeScale }] },
            ]}
          >
            <Badge style={styles.cartBadge} size={22}>
              {itemCount}
            </Badge>
          </Animated.View>
        )}
      </View>
    );
  },
);
export default CartButton;

================
File: app/src/modules/orders/components/ShiftStatusModal.tsx
================
import React from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Surface,
  Divider,
  Card,
  Chip,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { type Shift } from '@/services/shifts';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
interface ShiftStatusModalProps {
  visible: boolean;
  onDismiss: () => void;
  shift: Shift | null;
  onOpenShift: () => void;
  onCloseShift?: () => void;
  canOpenShift: boolean;
  loading: boolean;
}
export const ShiftStatusModal: React.FC<ShiftStatusModalProps> = ({
  visible,
  onDismiss,
  shift,
  onOpenShift,
  onCloseShift,
  canOpenShift,
  loading: _loading,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const isShiftOpen = shift && shift.status === 'OPEN';
  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });
  const handleOpenShift = () => {
    onDismiss();
    onOpenShift();
  };
  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency: 'MXN',
    }).format(amount);
  };
  const formatTime = (dateString: string) => {
    return format(new Date(dateString), 'HH:mm', { locale: es });
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <ScrollView showsVerticalScrollIndicator={false}>
          <Surface style={styles.modal} elevation={3}>
            {}
            <View style={styles.header}>
              <View style={styles.iconContainer}>
                <MaterialCommunityIcons
                  name={isShiftOpen ? 'store-check' : 'store-alert'}
                  size={48}
                  color={isShiftOpen ? '#4CAF50' : '#FF9800'}
                />
              </View>
              <Text variant="headlineMedium" style={styles.title}>
                {isShiftOpen ? 'Turno Abierto' : 'Turno Cerrado'}
              </Text>
              <Text variant="bodyLarge" style={styles.date}>
                {todayFormatted}
              </Text>
              <Chip
                mode="outlined"
                style={[
                  styles.statusChip,
                  { borderColor: isShiftOpen ? '#4CAF50' : '#FF9800' },
                ]}
                textStyle={{ color: isShiftOpen ? '#4CAF50' : '#FF9800' }}
              >
                {isShiftOpen ? 'ABIERTO' : 'CERRADO'}
              </Chip>
            </View>
            <Divider style={styles.divider} />
            {}
            <View style={styles.content}>
              {isShiftOpen && shift ? (
                <>
                  {}
                  <Card style={styles.infoCard}>
                    <Card.Content>
                      <Text variant="titleMedium" style={styles.sectionTitle}>
                        Información del Turno
                      </Text>
                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Turno #:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {shift.globalShiftNumber}
                        </Text>
                      </View>
                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto a las:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatTime(shift.openedAt)}
                        </Text>
                      </View>
                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto por:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {shift.openedBy.firstName} {shift.openedBy.lastName}
                        </Text>
                      </View>
                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Efectivo inicial:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatCurrency(shift.initialCash)}
                        </Text>
                      </View>
                      {shift.totalSales !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Ventas del turno:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.totalSales)}
                          </Text>
                        </View>
                      )}
                      {shift.totalOrders !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Órdenes:
                          </Text>
                          <Text variant="bodyMedium" style={styles.value}>
                            {shift.totalOrders}
                          </Text>
                        </View>
                      )}
                      {shift.expectedCash !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Efectivo esperado:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.expectedCash)}
                          </Text>
                        </View>
                      )}
                      {shift.notes && (
                        <View style={styles.notesSection}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Notas:
                          </Text>
                          <Text variant="bodySmall" style={styles.notes}>
                            {shift.notes}
                          </Text>
                        </View>
                      )}
                    </Card.Content>
                  </Card>
                </>
              ) : (
                <>
                  {}
                  <View style={styles.closedInfo}>
                    <MaterialCommunityIcons
                      name="information"
                      size={20}
                      color={theme.colors.primary}
                    />
                    <Text variant="bodyMedium" style={styles.closedText}>
                      {canOpenShift
                        ? 'El turno está cerrado. Para comenzar las operaciones, abre el turno.'
                        : 'El turno está cerrado. Contacta a un administrador para abrirlo.'}
                    </Text>
                  </View>
                </>
              )}
            </View>
            {}
            <View style={styles.footer}>
              <Button
                mode="text"
                onPress={onDismiss}
                style={styles.cancelButton}
                labelStyle={styles.cancelButtonText}
              >
                Cerrar
              </Button>
              {!isShiftOpen && canOpenShift && (
                <Button
                  mode="contained"
                  onPress={handleOpenShift}
                  style={styles.actionButton}
                  contentStyle={styles.actionButtonContent}
                  labelStyle={styles.actionButtonText}
                  icon="play-circle"
                >
                  Abrir Turno
                </Button>
              )}
              {isShiftOpen && canOpenShift && onCloseShift && (
                <Button
                  mode="contained"
                  onPress={() => {
                    onDismiss();
                    onCloseShift();
                  }}
                  style={styles.closeShiftButton}
                  contentStyle={styles.actionButtonContent}
                  labelStyle={styles.closeShiftButtonText}
                  icon="stop-circle"
                >
                  Cerrar Turno
                </Button>
              )}
            </View>
          </Surface>
        </ScrollView>
      </Modal>
    </Portal>
  );
};
const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.m,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 8,
      },
      shadowOpacity: 0.25,
      shadowRadius: 16,
      elevation: 8,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surfaceVariant,
    },
    iconContainer: {
      width: 90,
      height: 90,
      borderRadius: 45,
      backgroundColor: theme.colors.surface,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      borderWidth: 3,
      borderColor: theme.colors.primary,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 4,
      },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 4,
    },
    title: {
      color: theme.colors.onSurfaceVariant,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
      marginBottom: theme.spacing.m,
    },
    statusChip: {
      backgroundColor: theme.colors.surface,
      borderWidth: 2,
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    infoCard: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    value: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
    },
    highlight: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    notesSection: {
      marginTop: theme.spacing.m,
      paddingTop: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outline,
    },
    notes: {
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      fontStyle: 'italic',
    },
    closedInfo: {
      flexDirection: 'row',
      backgroundColor: theme.colors.primaryContainer,
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.primary,
      gap: theme.spacing.s,
    },
    closedText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
      lineHeight: 20,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      borderBottomLeftRadius: theme.roundness * 3,
      borderBottomRightRadius: theme.roundness * 3,
    },
    cancelButton: {
      flex: 1,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    cancelButtonText: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    actionButton: {
      flex: 1,
      backgroundColor: theme.colors.primary,
      borderWidth: 2,
      borderColor: theme.colors.primary,
      borderRadius: theme.roundness * 2,
    },
    actionButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    actionButtonText: {
      color: theme.colors.onPrimary,
      fontWeight: '600',
    },
    closeShiftButton: {
      flex: 1,
      backgroundColor: '#FF5722',
      borderWidth: 2,
      borderColor: '#FF5722',
      borderRadius: theme.roundness * 2,
    },
    closeShiftButtonText: {
      color: '#FFFFFF',
      fontWeight: '600',
    },
  });

================
File: app/src/modules/orders/screens/AddProductsToOrderScreen.tsx
================
import React, {
  useState,
  useMemo,
  useRef,
  useCallback,
  useEffect,
} from 'react';
import { StyleSheet, View, FlatList } from 'react-native';
import {
  Text,
  Portal,
  ActivityIndicator,
  Card,
  Title,
  Appbar,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation, useRoute } from '@react-navigation/native';
import { useGetOrderMenu } from '../hooks/useMenuQueries';
import { Product, Category, SubCategory } from '../types/orders.types';
import { AutoImage } from '@/app/components/common/AutoImage';
import ProductCustomizationModal from '../components/ProductCustomizationModal';
import SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';
import CartButton from '../components/CartButton';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import type { OrdersStackScreenProps } from '@/app/navigation/types';
import { CartItem, CartItemModifier } from '../stores/useCartStore';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
type AddProductsRouteProps = {
  orderId: string;
  orderNumber: number;
  existingOrderItemsCount?: number;
  existingTempProducts?: CartItem[];
  onProductsAdded?: (products: CartItem[]) => void;
};
interface CartButtonHandle {
  animate: () => void;
}
const AddProductsToOrderScreen = () => {
  const theme = useAppTheme();
  const { colors, fonts } = theme;
  const responsive = useResponsive();
  const navigation = useNavigation();
  const route =
    useRoute<OrdersStackScreenProps<'AddProductsToOrder'>['route']>();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const cartButtonRef = useRef<CartButtonHandle>(null);
  const {
    orderId: _orderId,
    orderNumber,
    existingTempProducts,
    existingOrderItemsCount,
    onProductsAdded,
  } = route.params as AddProductsRouteProps;
  const [navigationLevel, setNavigationLevel] = useState<
    'categories' | 'subcategories' | 'products'
  >('categories');
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null,
  );
  const [selectedSubcategoryId, setSelectedSubcategoryId] = useState<
    string | null
  >(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [selectedProductForDescription, setSelectedProductForDescription] =
    useState<Product | null>(null);
  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =
    useState(false);
  const [selectedProducts, setSelectedProducts] = useState<CartItem[]>(
    existingTempProducts || [],
  );
  const { data: menu, isLoading } = useGetOrderMenu();
  const totalItemsCount = useMemo(() => {
    const newItemsCount = selectedProducts.reduce(
      (sum, item) => sum + item.quantity,
      0,
    );
    const existingItemsCount = existingOrderItemsCount || 0;
    return newItemsCount + existingItemsCount;
  }, [selectedProducts, existingOrderItemsCount]);
  useEffect(() => {
    if (existingTempProducts && existingTempProducts.length > 0) {
      const totalItems = existingTempProducts.reduce(
        (sum, item) => sum + item.quantity,
        0,
      );
      showSnackbar({
        message: `${totalItems} producto${totalItems > 1 ? 's' : ''} recuperado${totalItems > 1 ? 's' : ''}`,
        type: 'info',
      });
    }
  }, []);
  const handleCategorySelect = useCallback((categoryId: string) => {
    setSelectedCategoryId(categoryId);
    setSelectedSubcategoryId(null);
    setNavigationLevel('subcategories');
  }, []);
  const handleSubCategorySelect = useCallback((subcategoryId: string) => {
    setSelectedSubcategoryId(subcategoryId);
    setNavigationLevel('products');
  }, []);
  const productNeedsCustomization = useCallback((product: Product): boolean => {
    if (!product) return false;
    const hasVariants =
      product.hasVariants &&
      product.variants &&
      Array.isArray(product.variants) &&
      product.variants.length > 0;
    const hasModifiers =
      product.modifierGroups &&
      Array.isArray(product.modifierGroups) &&
      product.modifierGroups.length > 0;
    return hasVariants || hasModifiers;
  }, []);
  const handleProductSelect = useCallback(
    (product: Product) => {
      if (productNeedsCustomization(product)) {
        setSelectedProduct(product);
      } else {
        addItemToSelection(product, 1);
      }
    },
    [productNeedsCustomization, addItemToSelection],
  );
  const addItemToSelection = (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    const selectedVariant = product.variants?.find(
      (v) => v.id === selectedVariantId,
    );
    const variantPrice = selectedVariant?.price || product.price;
    const modifiersPrice =
      selectedModifiers?.reduce((sum, mod) => sum + (mod.price || 0), 0) || 0;
    const pizzaCost = pizzaExtraCost || 0;
    const unitPrice = variantPrice + modifiersPrice + pizzaCost;
    const existingIndex = selectedProducts.findIndex((item) => {
      if (item.productId !== product.id) return false;
      if (item.variantId !== selectedVariantId) return false;
      if (item.preparationNotes !== preparationNotes) return false;
      const itemModifierIds = item.modifiers
        .map((m) => m.id)
        .sort()
        .join(',');
      const newModifierIds = (selectedModifiers || [])
        .map((m) => m.id)
        .sort()
        .join(',');
      if (itemModifierIds !== newModifierIds) return false;
      const existingCustomizations = item.selectedPizzaCustomizations || [];
      const newCustomizations = selectedPizzaCustomizations || [];
      if (existingCustomizations.length !== newCustomizations.length)
        return false;
      const sortedExistingCustomizations = [...existingCustomizations].sort(
        (a, b) =>
          `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
            `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
          ),
      );
      const sortedNewCustomizations = [...newCustomizations].sort((a, b) =>
        `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
          `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
        ),
      );
      for (let i = 0; i < sortedExistingCustomizations.length; i++) {
        if (
          sortedExistingCustomizations[i].pizzaCustomizationId !==
            sortedNewCustomizations[i].pizzaCustomizationId ||
          sortedExistingCustomizations[i].half !==
            sortedNewCustomizations[i].half ||
          sortedExistingCustomizations[i].action !==
            sortedNewCustomizations[i].action
        ) {
          return false;
        }
      }
      return true;
    });
    if (existingIndex !== -1) {
      setSelectedProducts((prev) => {
        const updated = [...prev];
        const existingItem = updated[existingIndex];
        const newQuantity = existingItem.quantity + quantity;
        const modifiersTotal = existingItem.modifiers.reduce(
          (sum, mod) => sum + Number(mod.price || 0),
          0,
        );
        const pizzaCostTotal = existingItem.pizzaExtraCost || 0;
        const unitPriceWithModifiers =
          Number(existingItem.unitPrice || 0) + modifiersTotal + pizzaCostTotal;
        updated[existingIndex] = {
          ...existingItem,
          quantity: newQuantity,
          totalPrice: unitPriceWithModifiers * newQuantity,
        };
        return updated;
      });
    } else {
      const newItem: CartItem = {
        id: `temp-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
        productId: product.id,
        productName: product.name,
        quantity,
        unitPrice: variantPrice,
        totalPrice: unitPrice * quantity,
        modifiers: selectedModifiers || [],
        variantId: selectedVariantId,
        variantName: selectedVariant?.name,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      };
      setSelectedProducts((prev) => [...prev, newItem]);
    }
    cartButtonRef.current?.animate();
    showSnackbar({
      message: `${product.name} añadido`,
      type: 'success',
    });
  };
  const updateItemInSelection = (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    setSelectedProducts((prev) =>
      prev.map((item) => {
        if (item.id === itemId) {
          const modifiersPrice = modifiers.reduce(
            (sum, mod) => sum + Number(mod.price || 0),
            0,
          );
          const pizzaCost = pizzaExtraCost || 0;
          const finalUnitPrice =
            unitPrice !== undefined ? unitPrice : item.unitPrice;
          const newTotalPrice =
            (finalUnitPrice + modifiersPrice + pizzaCost) * quantity;
          return {
            ...item,
            quantity,
            modifiers,
            preparationNotes:
              preparationNotes !== undefined
                ? preparationNotes
                : item.preparationNotes,
            variantId: variantId !== undefined ? variantId : item.variantId,
            variantName:
              variantName !== undefined ? variantName : item.variantName,
            unitPrice: finalUnitPrice,
            totalPrice: newTotalPrice,
            selectedPizzaCustomizations:
              selectedPizzaCustomizations !== undefined
                ? selectedPizzaCustomizations
                : item.selectedPizzaCustomizations,
            pizzaExtraCost,
          };
        }
        return item;
      }),
    );
  };
  const handleAddToCart = (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    if (editingItem) {
      updateItemInSelection(
        editingItem.id,
        quantity,
        selectedModifiers || [],
        preparationNotes,
        selectedVariantId,
        product.variants?.find((v) => v.id === selectedVariantId)?.name,
        selectedVariantId
          ? product.variants?.find((v) => v.id === selectedVariantId)?.price
          : product.price,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      );
      setEditingItem(null);
    } else {
      addItemToSelection(
        product,
        quantity,
        selectedVariantId,
        selectedModifiers,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      );
    }
    setSelectedProduct(null);
  };
  const handleCloseProductModal = useCallback(() => {
    setSelectedProduct(null);
    setEditingItem(null);
  }, []);
  const handleConfirmSelection = () => {
    if (onProductsAdded) {
      onProductsAdded(selectedProducts);
    }
    navigation.goBack();
  };
  const handleBack = () => {
    if (selectedProduct) {
      setSelectedProduct(null);
    } else if (navigationLevel === 'products') {
      setNavigationLevel('subcategories');
      setSelectedSubcategoryId(null);
    } else if (navigationLevel === 'subcategories') {
      setNavigationLevel('categories');
      setSelectedCategoryId(null);
    } else {
      if (onProductsAdded) {
        onProductsAdded(selectedProducts);
      }
      navigation.goBack();
    }
  };
  const getCategories = () => {
    if (!menu || !Array.isArray(menu)) return [];
    return menu;
  };
  const getSubcategories = () => {
    if (!selectedCategory || !Array.isArray(selectedCategory.subcategories))
      return [];
    return selectedCategory.subcategories;
  };
  const getProducts = () => {
    if (!selectedSubCategory || !Array.isArray(selectedSubCategory.products))
      return [];
    return selectedSubCategory.products;
  };
  const selectedCategory = menu?.find(
    (cat: Category) => cat.id === selectedCategoryId,
  );
  const selectedSubCategory = selectedCategory?.subcategories?.find(
    (sub: SubCategory) => sub.id === selectedSubcategoryId,
  );
  const getNavTitle = useCallback(() => {
    if (selectedProduct) {
      return selectedProduct.name;
    }
    switch (navigationLevel) {
      case 'categories':
        return `Añadir a Orden #${orderNumber}`;
      case 'subcategories':
        return selectedCategory?.name || 'Subcategorías';
      case 'products':
        return selectedSubCategory?.name || 'Productos';
      default:
        return 'Categorías';
    }
  }, [
    navigationLevel,
    selectedCategory,
    selectedSubCategory,
    selectedProduct,
    orderNumber,
  ]);
  const handleShowProductDescription = (product: Product) => {
    setSelectedProductForDescription(product);
    setIsDescriptionModalVisible(true);
  };
  const handleCloseDescriptionModal = () => {
    setIsDescriptionModalVisible(false);
    setSelectedProductForDescription(null);
  };
  const numColumns = useMemo(() => {
    if (responsive.width >= 600) {
      if (responsive.width >= 1200) return 6;
      if (responsive.width >= 900) return 5;
      if (responsive.width >= 768) return 4;
      return 3;
    }
    if (responsive.width >= 480) return 3;
    if (responsive.width >= 360) return 2;
    return 2;
  }, [responsive.width]);
  const itemWidth = useMemo(() => {
    const padding = responsive.spacing(theme.spacing.m);
    const totalPadding = padding * 2;
    const gap = responsive.spacing(8);
    const totalGaps = gap * (numColumns - 1);
    const availableWidth = responsive.width - totalPadding - totalGaps;
    return Math.floor(availableWidth / numColumns);
  }, [responsive.width, numColumns, theme.spacing.m]);
  const styles = useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: colors.background,
        },
        container: {
          flex: 1,
        },
        content: {
          flex: 1,
        },
        gridContainer: {
          padding: responsive.spacing(theme.spacing.m),
          paddingBottom: 60,
        },
        row: {
          justifyContent: 'flex-start',
          paddingHorizontal: 0,
          marginBottom: responsive.spacing(8),
          gap: responsive.spacing(8),
        },
        cardItem: {
          width: itemWidth,
          marginHorizontal: 0,
          marginVertical: 0,
          overflow: 'hidden',
          borderRadius: theme.roundness * 2,
          elevation: 2,
          backgroundColor: colors.surface,
          aspectRatio: 0.85,
        },
        cardItemInactive: {
          opacity: 0.5,
        },
        itemImage: {
          width: '100%',
          height: itemWidth * 0.65,
        },
        imageInactive: {
          opacity: 0.6,
        },
        cardContent: {
          paddingHorizontal: responsive.spacing(theme.spacing.s),
          paddingVertical: responsive.spacing(theme.spacing.xs),
          height: itemWidth * 0.35,
          justifyContent: 'center',
        },
        cardTitle: {
          fontSize: responsive.fontSize(responsive.width >= 600 ? 16 : 15),
          fontWeight: '600',
          lineHeight:
            responsive.fontSize(responsive.width >= 600 ? 16 : 15) * 1.2,
          marginBottom: responsive.spacing(2),
        },
        cardHeader: {
          flexDirection: 'row',
          justifyContent: 'space-between',
          alignItems: 'flex-start',
        },
        infoButton: {
          margin: -8,
          marginTop: -12,
          marginRight: -12,
        },
        priceText: {
          color: theme.colors.primary,
          fontWeight: '600',
          fontSize: responsive.fontSize(responsive.width >= 600 ? 14 : 13),
          marginTop: 2,
        },
        noItemsText: {
          textAlign: 'center',
          marginTop: 40,
          fontSize: 16,
          color: '#666',
        },
        loadingContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
        },
        appBar: {
          backgroundColor: colors.elevation.level2,
          alignItems: 'center',
        },
        appBarTitle: {
          ...fonts.titleMedium,
          color: colors.onSurface,
          fontWeight: 'bold',
          textAlign: 'center',
        },
        appBarContent: {},
        spacer: {
          width: 48,
        },
        inactiveBadge: {
          position: 'absolute',
          top: 8,
          right: 8,
          backgroundColor: colors.errorContainer,
          paddingHorizontal: 8,
          paddingVertical: 4,
          borderRadius: 4,
        },
        inactiveBadgeText: {
          fontSize: 12,
          color: colors.onErrorContainer,
          fontWeight: '600',
        },
      }),
    [colors, fonts, theme, responsive, itemWidth],
  );
  const blurhash =
    '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';
  const renderItem = useCallback(
    ({ item }: { item: Category | SubCategory | Product }) => {
      const imageSource = (() => {
        const photoPath = item.photo?.path || item.photo;
        return photoPath || null;
      })();
      const isActive = item.isActive !== false;
      const isProductWithoutScreen =
        navigationLevel === 'products' &&
        'preparationScreenId' in item &&
        !item.preparationScreenId;
      const handlePress = () => {
        if (!isActive || isProductWithoutScreen) return;
        if (navigationLevel === 'categories') {
          handleCategorySelect(item.id);
        } else if (navigationLevel === 'subcategories') {
          handleSubCategorySelect(item.id);
        } else if ('price' in item) {
          handleProductSelect(item as Product);
        }
      };
      const handleLongPress = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          isActive &&
          'description' in item &&
          (item as Product).description &&
          (item as Product).description.trim() !== ''
        ) {
          handleShowProductDescription(item as Product);
        }
      };
      const renderPrice = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          'hasVariants' in item
        ) {
          const productItem = item as Product;
          if (
            !productItem.hasVariants &&
            productItem.price !== null &&
            productItem.price !== undefined
          ) {
            return (
              <Text style={styles.priceText}>
                ${Number(productItem.price).toFixed(2)}
              </Text>
            );
          }
        }
        return null;
      };
      return (
        <Card
          style={[
            styles.cardItem,
            (!isActive || isProductWithoutScreen) && styles.cardItemInactive,
          ]}
          onPress={handlePress}
          onLongPress={handleLongPress}
          disabled={!isActive || isProductWithoutScreen}
        >
          <AutoImage
            source={imageSource}
            style={[
              styles.itemImage,
              (!isActive || isProductWithoutScreen) && styles.imageInactive,
            ]}
            contentFit="cover"
            placeholder={blurhash}
            transition={300}
            placeholderIcon="image-outline"
          />
          <Card.Content style={styles.cardContent}>
            {navigationLevel === 'products' &&
            'price' in item &&
            (item as Product).description ? (
              <View style={styles.cardHeader}>
                <Title
                  style={[styles.cardTitle, { flex: 1 }]}
                  numberOfLines={2}
                  ellipsizeMode="tail"
                >
                  {item.name}
                </Title>
                <IconButton
                  icon="information-outline"
                  size={20}
                  onPress={() => handleShowProductDescription(item as Product)}
                  style={styles.infoButton}
                />
              </View>
            ) : (
              <Title
                style={styles.cardTitle}
                numberOfLines={2}
                ellipsizeMode="tail"
              >
                {item.name}
              </Title>
            )}
            {renderPrice()}
          </Card.Content>
          {!isActive && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>No disponible</Text>
            </View>
          )}
          {isProductWithoutScreen && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>SIN PANTALLA</Text>
            </View>
          )}
        </Card>
      );
    },
    [
      navigationLevel,
      handleCategorySelect,
      handleSubCategorySelect,
      handleProductSelect,
      handleShowProductDescription,
      styles,
      blurhash,
    ],
  );
  if (isLoading) {
    return (
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
        </View>
      </SafeAreaView>
    );
  }
  const currentData =
    navigationLevel === 'categories'
      ? getCategories()
      : navigationLevel === 'subcategories'
        ? getSubcategories()
        : getProducts();
  return (
    <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
      <View style={styles.container}>
        <Appbar.Header style={styles.appBar}>
          <Appbar.BackAction onPress={handleBack} />
          <Appbar.Content
            title={getNavTitle()}
            titleStyle={styles.appBarTitle}
            style={styles.appBarContent}
          />
          <CartButton
            ref={cartButtonRef}
            itemCount={totalItemsCount}
            onPress={handleConfirmSelection}
          />
        </Appbar.Header>
        <View style={styles.content}>
          {currentData.length === 0 ? (
            <Text style={styles.noItemsText}>
              {navigationLevel === 'categories'
                ? 'No hay categorías disponibles'
                : navigationLevel === 'subcategories'
                  ? 'No hay subcategorías disponibles'
                  : 'No hay productos disponibles'}
            </Text>
          ) : (
            <FlatList
              data={currentData}
              renderItem={renderItem}
              keyExtractor={(item) => item.id}
              numColumns={numColumns}
              key={numColumns}
              contentContainerStyle={styles.gridContainer}
              columnWrapperStyle={numColumns > 1 ? styles.row : undefined}
              showsVerticalScrollIndicator={false}
            />
          )}
        </View>
        {}
        <Portal>
          {selectedProduct && (
            <ProductCustomizationModal
              visible={true}
              product={selectedProduct}
              editingItem={editingItem}
              onDismiss={handleCloseProductModal}
              onAddToCart={handleAddToCart}
              onUpdateItem={(
                itemId,
                quantity,
                modifiers,
                notes,
                variantId,
                variantName,
                unitPrice,
                selectedPizzaCustomizations,
                pizzaExtraCost,
              ) => {
                updateItemInSelection(
                  itemId,
                  quantity,
                  modifiers,
                  notes,
                  variantId,
                  variantName,
                  unitPrice,
                  selectedPizzaCustomizations,
                  pizzaExtraCost,
                );
                setEditingItem(null);
                setSelectedProduct(null);
              }}
            />
          )}
          {}
          {selectedProductForDescription && (
            <SimpleProductDescriptionModal
              visible={isDescriptionModalVisible}
              product={selectedProductForDescription}
              onDismiss={handleCloseDescriptionModal}
            />
          )}
        </Portal>
      </View>
    </SafeAreaView>
  );
};
export default AddProductsToOrderScreen;

================
File: app/src/modules/orders/types/orders.types.ts
================
import type { Photo } from '@/app/schemas/domain/photo.schema';
import type { Modifier } from '@/app/schemas/domain/modifier.schema';
import type { ModifierGroup } from '@/app/schemas/domain/modifier-group.schema';
import type { ProductVariant } from '@/app/schemas/domain/product-variant.schema';
import type { Product } from '@/app/schemas/domain/product.schema';
import type { SubCategory } from '@/app/schemas/domain/subcategory.schema';
import type { Category } from '@/app/schemas/domain/category.schema';
import {
  orderStatusSchema,
  orderTypeSchema,
} from '@/app/schemas/domain/order.schema';
import type {
  OrderItemModifier,
  OrderItem,
  OrderStatus,
  OrderType,
  Order,
} from '@/app/schemas/domain/order.schema';
export type {
  Photo,
  Modifier,
  ModifierGroup,
  ProductVariant,
  Product,
  SubCategory,
  Category,
  OrderItemModifier,
  OrderItem,
  OrderStatus,
  OrderType,
  Order,
};
export const OrderStatusEnum = orderStatusSchema.enum;
export const OrderTypeEnum = orderTypeSchema.enum;
export interface FullMenuModifierGroup extends ModifierGroup {
  productModifiers?: Modifier[];
}
export interface FullMenuProduct extends Product {
  variants?: ProductVariant[];
  modifierGroups?: FullMenuModifierGroup[];
}
export interface FullMenuSubCategory extends SubCategory {
  products?: FullMenuProduct[];
}
export interface FullMenuCategory extends Category {
  subcategories?: FullMenuSubCategory[];
}
export interface FindAllOrdersDto {
  userId?: string;
  tableId?: string;
  orderStatus?: OrderStatus | OrderStatus[];
  orderType?: OrderType;
  startDate?: string;
  endDate?: string;
  page?: number;
  limit?: number;
}
export interface OrderOpenList
  extends Omit<
    Order,
    'orderItems' | 'payments' | 'adjustments' | 'user' | 'customer'
  > {
  table?: {
    id: string;
    number: number;
    name: string;
    isTemporary: boolean;
    area?: {
      name: string;
    };
  } | null;
  deliveryInfo?: {
    recipientName: string;
    recipientPhone: string | null;
    fullAddress: string;
  } | null;
  paymentsSummary?: {
    totalPaid: number;
  };
  preparationScreens?: string[];
  preparationScreenStatuses?: Array<{
    name: string;
    status: 'PENDING' | 'IN_PROGRESS' | 'READY';
  }>;
  ticketImpressionCount?: number;
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaConfigurationModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  IconButton,
  HelperText,
  Divider,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Controller, useForm } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { pizzaConfigurationsService } from '../services/pizzaConfigurationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { Product } from '@/modules/menu/schema/products.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
interface PizzaConfigurationModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product | null;
}
const configurationSchema = z.object({
  includedToppings: z.number().int().min(0),
  extraToppingCost: z.number().min(0),
});
type ConfigurationFormData = z.infer<typeof configurationSchema>;
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: responsive.spacing(theme.spacing.l),
      borderRadius: theme.roundness * 2,
      maxHeight: responsive.isTablet ? '85%' : '80%',
      maxWidth: responsive.isTablet ? 650 : 500,
      width: responsive.isTablet ? '85%' : '100%',
      alignSelf: 'center',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: responsive.spacing(theme.spacing.m),
      paddingBottom: 0,
    },
    title: {
      fontSize: responsive.fontSize(20),
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    closeButton: {
      margin: 0,
    },
    content: {
      padding: responsive.spacing(theme.spacing.m),
    },
    productInfo: {
      backgroundColor: theme.colors.surfaceVariant,
      padding: responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness,
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    productName: {
      fontWeight: '600',
      marginBottom: responsive.spacing(theme.spacing.xs),
      fontSize: responsive.fontSize(16),
    },
    section: {
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    sectionTitle: {
      marginBottom: responsive.spacing(theme.spacing.m),
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.fontSize(16),
    },
    input: {
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surface,
    },
    helperText: {
      marginTop: -responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.m),
      fontSize: responsive.fontSize(12),
    },
    infoBox: {
      backgroundColor: theme.colors.primaryContainer,
      padding: responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness,
      marginBottom: responsive.spacing(theme.spacing.m),
    },
    infoText: {
      color: theme.colors.onPrimaryContainer,
      fontSize: responsive.fontSize(12),
    },
    example: {
      marginTop: responsive.spacing(theme.spacing.m),
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    exampleTitle: {
      fontWeight: '600',
      marginBottom: responsive.spacing(theme.spacing.xs),
      fontSize: responsive.fontSize(14),
    },
    exampleText: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      gap: responsive.spacing(theme.spacing.m),
    },
    actionButton: {
      flex: 1,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      maxWidth: responsive.isTablet ? 180 : 160,
    },
    cancelButton: {
      borderColor: theme.colors.outlineVariant,
    },
    saveButton: {
      borderWidth: 0,
    },
    buttonLabel: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
    },
  });
export function PizzaConfigurationModal({
  visible,
  onDismiss,
  product,
}: PizzaConfigurationModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [extraCostText, setExtraCostText] = useState('20.00');
  const { data: configuration, isLoading: _isLoading } = useQuery({
    queryKey: ['pizza-configuration', product?.id],
    queryFn: async () => {
      if (!product?.id) return null;
      try {
        return await pizzaConfigurationsService.findByProductId(product.id);
      } catch (error) {
        return null;
      }
    },
    enabled: !!product?.id && visible,
  });
  const {
    control,
    handleSubmit,
    formState: { errors, isDirty },
    reset,
    setValue,
    getValues: _getValues,
  } = useForm<ConfigurationFormData>({
    resolver: zodResolver(configurationSchema),
    defaultValues: {
      includedToppings: 4,
      extraToppingCost: 20,
    },
  });
  useEffect(() => {
    if (visible && product) {
      if (
        configuration &&
        configuration.extraToppingCost !== undefined &&
        configuration.extraToppingCost !== null
      ) {
        const cost = Number(configuration.extraToppingCost);
        const toppings = Number(configuration.includedToppings) || 4;
        reset({
          includedToppings: toppings,
          extraToppingCost: cost,
        });
        setExtraCostText(cost.toFixed(2));
        setValue('extraToppingCost', cost, { shouldValidate: false });
      } else {
        const defaultCost = 20;
        const defaultToppings = 4;
        reset({
          includedToppings: defaultToppings,
          extraToppingCost: defaultCost,
        });
        setExtraCostText(defaultCost.toFixed(2));
        setValue('extraToppingCost', defaultCost, { shouldValidate: false });
      }
    }
  }, [configuration, reset, visible, product, setValue]);
  const saveMutation = useMutation({
    mutationFn: async (data: ConfigurationFormData) => {
      if (!product) throw new Error('No product selected');
      if (configuration) {
        return await pizzaConfigurationsService.update(configuration.id, data);
      } else {
        return await pizzaConfigurationsService.create({
          ...data,
          productId: product.id,
        });
      }
    },
    onSuccess: () => {
      showSnackbar({
        message: 'Configuración guardada exitosamente',
        type: 'success',
      });
      queryClient.invalidateQueries({
        queryKey: ['pizza-configuration', product?.id],
      });
      queryClient.invalidateQueries({ queryKey: ['pizza-configurations'] });
      onDismiss();
    },
    onError: (error) => {
      showSnackbar({
        message: error instanceof Error ? error.message : 'Error al guardar',
        type: 'error',
      });
    },
  });
  const onSubmit = (data: ConfigurationFormData) => {
    saveMutation.mutate(data);
  };
  if (!product) return null;
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (isDirty) {
            setShowConfirmation(true);
          } else {
            onDismiss();
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={true}
      >
        <View style={styles.header}>
          <Text style={styles.title}>Configuración de Pizza</Text>
          <IconButton
            icon="close"
            size={24}
            onPress={() => {
              if (isDirty) {
                setShowConfirmation(true);
              } else {
                onDismiss();
              }
            }}
            style={styles.closeButton}
          />
        </View>
        <Divider />
        <ScrollView style={styles.content}>
          <View style={styles.productInfo}>
            <Text variant="titleMedium" style={styles.productName}>
              {product.name}
            </Text>
            <Text variant="bodySmall">
              {product.variants?.length || 0} variantes disponibles
            </Text>
          </View>
          <View style={styles.section}>
            <View style={styles.infoBox}>
              <Text style={styles.infoText}>
                ℹ️ Esta configuración determina cuántos toppings están incluidos
                en el precio base y cuánto se cobra por cada topping adicional.
              </Text>
            </View>
            <Controller
              control={control}
              name="includedToppings"
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Toppings incluidos en el precio base *"
                  value={value?.toString() || ''}
                  onChangeText={(text) => {
                    // Solo permitir números enteros
                    const cleanText = text.replace(/[^0-9]/g, '');
                    if (cleanText === '') {
                      onChange(0);
                    } else {
                      const num = parseInt(cleanText, 10);
                      onChange(isNaN(num) ? 0 : num);
                    }
                  }}
                  onBlur={onBlur}
                  mode="outlined"
                  style={styles.input}
                  keyboardType="number-pad"
                  error={!!errors.includedToppings}
                />
              )}
            />
            {errors.includedToppings && (
              <HelperText type="error" visible style={styles.helperText}>
                Debe ser un número entero mayor o igual a 0
              </HelperText>
            )}
            <HelperText type="info" visible style={styles.helperText}>
              Cantidad de toppings que el cliente puede elegir sin costo
              adicional
            </HelperText>
            <Controller
              control={control}
              name="extraToppingCost"
              render={({ field: { onChange, onBlur } }) => (
                <TextInput
                  label="Costo por topping adicional *"
                  value={extraCostText}
                  onChangeText={(text) => {
                    // Permitir números y punto decimal
                    let cleanText = text.replace(/[^0-9.]/g, '');
                    // Evitar múltiples puntos decimales
                    const parts = cleanText.split('.');
                    if (parts.length > 2) {
                      cleanText = parts[0] + '.' + parts.slice(1).join('');
                    }
                    // Limitar a 2 decimales
                    if (parts.length === 2 && parts[1].length > 2) {
                      cleanText = parts[0] + '.' + parts[1].substring(0, 2);
                    }
                    // Actualizar el texto mostrado
                    setExtraCostText(cleanText);
                    // Convertir a número y actualizar el formulario
                    const numValue = parseFloat(cleanText);
                    if (!isNaN(numValue)) {
                      onChange(numValue);
                      setValue('extraToppingCost', numValue, {
                        shouldValidate: true,
                      });
                    } else if (cleanText === '' || cleanText === '.') {
                      onChange(0);
                      setValue('extraToppingCost', 0, { shouldValidate: true });
                    }
                  }}
                  onBlur={() => {
                    onBlur();
                    const numValue = parseFloat(extraCostText);
                    if (!isNaN(numValue)) {
                      setExtraCostText(numValue.toFixed(2));
                      setValue('extraToppingCost', numValue, {
                        shouldValidate: true,
                      });
                    } else {
                      setExtraCostText('0.00');
                      setValue('extraToppingCost', 0, { shouldValidate: true });
                    }
                  }}
                  mode="outlined"
                  style={styles.input}
                  keyboardType="decimal-pad"
                  error={!!errors.extraToppingCost}
                  left={<TextInput.Affix text="$" />}
                />
              )}
            />
            {errors.extraToppingCost && (
              <HelperText type="error" visible style={styles.helperText}>
                {errors.extraToppingCost.message ||
                  'Debe ser un número mayor o igual a 0'}
              </HelperText>
            )}
            <HelperText type="info" visible style={styles.helperText}>
              Precio que se cobra por cada topping después de los incluidos
            </HelperText>
            <View style={styles.example}>
              <Text variant="labelLarge" style={styles.exampleTitle}>
                Ejemplo de cálculo:
              </Text>
              <Text style={styles.exampleText}>
                Si configuras 4 toppings incluidos y $20 por extra:{'\n'}•
                Cliente elige 4 toppings: Sin costo adicional{'\n'}• Cliente
                elige 6 toppings: +$40 (2 extras × $20)
              </Text>
            </View>
          </View>
        </ScrollView>
        <Divider />
        <View style={styles.actions}>
          <Button
            mode="outlined"
            onPress={() => {
              if (isDirty) {
                setShowConfirmation(true);
              } else {
                onDismiss();
              }
            }}
            style={[styles.actionButton, styles.cancelButton]}
            contentStyle={{ paddingVertical: responsive.isTablet ? 4 : 6 }}
            labelStyle={styles.buttonLabel}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSubmit(onSubmit)}
            loading={saveMutation.isPending}
            style={[styles.actionButton, styles.saveButton]}
            contentStyle={{ paddingVertical: responsive.isTablet ? 4 : 6 }}
            labelStyle={styles.buttonLabel}
          >
            Guardar
          </Button>
        </View>
      </Modal>
      <ConfirmationModal
        visible={showConfirmation}
        title="¿Salir sin guardar?"
        message="Los cambios se perderán"
        confirmText="Salir"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={() => {
          setShowConfirmation(false);
          reset();
          setExtraCostText('20.00');
          onDismiss();
        }}
        onCancel={() => setShowConfirmation(false)}
        onDismiss={() => setShowConfirmation(false)}
      />
    </Portal>
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationFormModal.tsx
================
import React, { useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Pressable,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  Switch,
  SegmentedButtons,
  HelperText,
  ActivityIndicator,
  IconButton,
  Surface,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  pizzaCustomizationFormSchema,
  PizzaCustomizationFormInputs,
} from '../schema/pizzaCustomization.schema';
import {
  usePizzaCustomization,
  useCreatePizzaCustomization,
  useUpdatePizzaCustomization,
} from '../hooks/usePizzaCustomizationsQueries';
import { CustomizationType } from '../types/pizzaCustomization.types';
interface PizzaCustomizationFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  customizationId?: string;
  onSuccess?: () => void;
}
const createStyles = (theme: any, responsive: any) => {
  const isTablet = responsive.isTablet;
  return StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    backdrop: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
      backgroundColor: theme.colors.surface,
      borderRadius: 28,
      maxHeight: isTablet ? '90%' : '85%',
      minHeight: isTablet ? 600 : undefined,
      maxWidth: isTablet ? 650 : 500,
      width: '100%',
      alignSelf: 'center',
      overflow: 'hidden',
      elevation: 24,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 12,
      },
      shadowOpacity: 0.58,
      shadowRadius: 16.0,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.l),
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    headerTitle: {
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    closeButton: {
      margin: -responsive.spacing(theme.spacing.xs),
    },
    scrollContent: {
      padding: responsive.spacing(theme.spacing.l),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    formGroup: {
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    label: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(theme.spacing.xs),
      marginLeft: responsive.spacing(theme.spacing.xs),
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    segmentedButtons: {
      marginBottom: responsive.spacing(theme.spacing.xs),
      borderRadius: 16,
    },
    row: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    halfWidth: {
      flex: 1,
    },
    switchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.l),
      backgroundColor: theme.colors.secondaryContainer,
      borderRadius: 16,
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    switchLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSecondaryContainer,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.spacing(theme.spacing.l),
      paddingTop: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.elevation.level1,
    },
    button: {
      borderRadius: 24,
      flex: 1,
      maxWidth: isTablet ? 180 : 160,
    },
    buttonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    loadingContainer: {
      padding: responsive.spacing(theme.spacing.xl * 2),
      alignItems: 'center',
    },
    inputStyle: {
      backgroundColor: theme.colors.elevation.level1,
    },
  });
};
export function PizzaCustomizationFormModal({
  visible,
  onDismiss,
  customizationId,
  onSuccess,
}: PizzaCustomizationFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const isEditMode = !!customizationId;
  const styles = createStyles(theme, responsive);
  const { data: customization, isLoading: isLoadingCustomization } =
    usePizzaCustomization(customizationId || '');
  const createMutation = useCreatePizzaCustomization();
  const updateMutation = useUpdatePizzaCustomization();
  const {
    control,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
    setValue,
  } = useForm<PizzaCustomizationFormInputs>({
    resolver: zodResolver(pizzaCustomizationFormSchema),
    defaultValues: {
      name: '',
      type: CustomizationType.INGREDIENT,
      ingredients: '',
      toppingValue: 1,
      isActive: true,
      sortOrder: 100,
    },
  });
  const watchType = watch('type');
  useEffect(() => {
    if (customization && isEditMode) {
      reset({
        name: customization.name,
        type: customization.type,
        ingredients: customization.ingredients || '',
        toppingValue: customization.toppingValue,
        isActive: customization.isActive,
        sortOrder: customization.sortOrder,
      });
    } else if (!visible) {
      reset({
        name: '',
        type: CustomizationType.INGREDIENT,
        ingredients: '',
        toppingValue: 1,
        isActive: true,
        sortOrder: 100,
      });
    }
  }, [customization, isEditMode, reset, visible]);
  // Limpiar ingredientes cuando se cambie de FLAVOR a INGREDIENT
  useEffect(() => {
    if (watchType === CustomizationType.INGREDIENT) {
      setValue('ingredients', '');
    }
  }, [watchType, setValue]);
  const onSubmit = async (data: PizzaCustomizationFormInputs) => {
    try {
      // Asegurar que los ingredientes estén vacíos para tipo INGREDIENT
      const submissionData = {
        ...data,
        ingredients:
          data.type === CustomizationType.INGREDIENT ? '' : data.ingredients,
      };
      if (isEditMode && customizationId) {
        await updateMutation.mutateAsync({
          id: customizationId,
          data: submissionData,
        });
      } else {
        await createMutation.mutateAsync(submissionData);
      }
      onSuccess?.();
      onDismiss();
    } catch (error) {
      // El error ya se maneja en los hooks con snackbar
    }
  };
  if (isLoadingCustomization && isEditMode) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.container}
        >
          <Pressable style={styles.backdrop} onPress={onDismiss} />
          <Surface style={styles.modalContent} elevation={5}>
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
              <Text
                variant="bodyLarge"
                style={{
                  marginTop: responsive.spacing(theme.spacing.m),
                  color: theme.colors.onSurfaceVariant,
                }}
              >
                Cargando personalización...
              </Text>
            </View>
          </Surface>
        </Modal>
      </Portal>
    );
  }
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.container}
      >
        <Pressable style={styles.backdrop} onPress={onDismiss} />
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ width: '100%' }}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View style={styles.header}>
              <Text style={styles.headerTitle}>
                {isEditMode ? 'Editar' : 'Nueva'} personalización
              </Text>
              <IconButton
                icon="close"
                size={20}
                onPress={onDismiss}
                iconColor={theme.colors.onSurfaceVariant}
                style={styles.closeButton}
              />
            </View>
            <ScrollView
              contentContainerStyle={styles.scrollContent}
              showsVerticalScrollIndicator={false}
            >
              <View style={styles.formGroup}>
                <Text style={styles.label}>Nombre del producto</Text>
                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      placeholder="Ej: Pepperoni, Hawaiana"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.name}
                      mode="outlined"
                      outlineColor={theme.colors.outline}
                      activeOutlineColor={theme.colors.primary}
                      style={styles.inputStyle}
                      outlineStyle={{ borderRadius: 12 }}
                    />
                  )}
                />
                {errors.name && (
                  <HelperText type="error" visible={!!errors.name}>
                    {errors.name.message}
                  </HelperText>
                )}
              </View>
              <View style={styles.formGroup}>
                <Text style={styles.label}>Tipo de personalización</Text>
                <Controller
                  control={control}
                  name="type"
                  render={({ field: { onChange, value } }) => (
                    <SegmentedButtons
                      value={value}
                      onValueChange={onChange}
                      buttons={[
                        {
                          value: CustomizationType.FLAVOR,
                          label: 'Sabor',
                          icon: 'pizza',
                          style: {
                            backgroundColor:
                              value === CustomizationType.FLAVOR
                                ? theme.colors.primaryContainer
                                : 'transparent',
                          },
                        },
                        {
                          value: CustomizationType.INGREDIENT,
                          label: 'Ingrediente',
                          icon: 'cheese',
                          style: {
                            backgroundColor:
                              value === CustomizationType.INGREDIENT
                                ? theme.colors.primaryContainer
                                : 'transparent',
                          },
                        },
                      ]}
                      style={styles.segmentedButtons}
                    />
                  )}
                />
              </View>
              {watchType === CustomizationType.FLAVOR && (
                <View style={styles.formGroup}>
                  <Text style={styles.label}>Ingredientes del sabor</Text>
                  <Controller
                    control={control}
                    name="ingredients"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="Ej: Jamón, Piña, Queso"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.ingredients}
                        mode="outlined"
                        multiline
                        numberOfLines={2}
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={{ borderRadius: 12 }}
                      />
                    )}
                  />
                  {errors.ingredients && (
                    <HelperText type="error" visible={!!errors.ingredients}>
                      {errors.ingredients.message}
                    </HelperText>
                  )}
                </View>
              )}
              <View style={styles.row}>
                <View style={styles.halfWidth}>
                  <Text style={styles.label}>Valor del topping</Text>
                  <Controller
                    control={control}
                    name="toppingValue"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="0"
                        value={value?.toString() || ''}
                        onChangeText={(text) => {
                          const num = parseInt(text, 10);
                          onChange(isNaN(num) ? 0 : num);
                        }}
                        onBlur={onBlur}
                        error={!!errors.toppingValue}
                        mode="outlined"
                        keyboardType="numeric"
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={{ borderRadius: 12 }}
                      />
                    )}
                  />
                  {errors.toppingValue && (
                    <HelperText type="error" visible={!!errors.toppingValue}>
                      {errors.toppingValue.message}
                    </HelperText>
                  )}
                </View>
                <View style={styles.halfWidth}>
                  <Text style={styles.label}>Orden de aparición</Text>
                  <Controller
                    control={control}
                    name="sortOrder"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="100"
                        value={value?.toString() || ''}
                        onChangeText={(text) => {
                          const num = parseInt(text, 10);
                          onChange(isNaN(num) ? 0 : num);
                        }}
                        onBlur={onBlur}
                        error={!!errors.sortOrder}
                        mode="outlined"
                        keyboardType="numeric"
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={{ borderRadius: 12 }}
                      />
                    )}
                  />
                  {errors.sortOrder && (
                    <HelperText type="error" visible={!!errors.sortOrder}>
                      {errors.sortOrder.message}
                    </HelperText>
                  )}
                </View>
              </View>
              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.switchRow}>
                    <Text style={styles.switchLabel}>Activo</Text>
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      color={theme.colors.primary}
                    />
                  </View>
                )}
              />
            </ScrollView>
            <View style={styles.footer}>
              <Button
                mode="contained-tonal"
                onPress={onDismiss}
                disabled={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                style={styles.button}
                contentStyle={styles.buttonContent}
                labelStyle={{
                  fontSize: responsive.fontSize(16),
                  fontWeight: '600',
                }}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleSubmit(onSubmit)}
                loading={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                disabled={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                style={[
                  styles.button,
                  { backgroundColor: theme.colors.primary },
                ]}
                contentStyle={styles.buttonContent}
                labelStyle={{
                  fontSize: responsive.fontSize(16),
                  fontWeight: '600',
                }}
                icon={isEditMode ? 'check' : 'plus'}
              >
                {isEditMode ? 'Guardar' : 'Crear'}
              </Button>
            </View>
          </Surface>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
}

================
File: app/src/modules/preparationScreens/components/PreparationScreenFormModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  List,
  Divider,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { User, RoleEnum } from '@/modules/users/types/user.types';
import { useGetUsers } from '@/modules/users/hooks/useUsers';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  CreatePreparationScreenSchema,
  UpdatePreparationScreenSchema,
} from '../schema/preparationScreen.schema';
import {
  useCreatePreparationScreen,
  useUpdatePreparationScreen,
  useGetPreparationScreens,
} from '../hooks/usePreparationScreensQueries';
interface PreparationScreenFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  editingItem: PreparationScreen | null;
  onSubmitSuccess?: () => void;
}
type FormData = CreatePreparationScreenDto | UpdatePreparationScreenDto;
const PreparationScreenFormModal: React.FC<PreparationScreenFormModalProps> = ({
  visible,
  onDismiss,
  editingItem,
  onSubmitSuccess,
}) => {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  const isEditing = !!editingItem;
  const [showUserDropdown, setShowUserDropdown] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const { data: usersData, isLoading: isLoadingUsers } = useGetUsers({
    filters: {
      isActive: true,
    },
  });
  const { data: screensData } = useGetPreparationScreens(
    {},
    { page: 1, limit: 100 },
  );
  const userAssignments = React.useMemo(() => {
    if (!screensData?.data) return new Map<string, string>();
    const assignments = new Map<string, string>();
    screensData.data.forEach((screen) => {
      if (editingItem && screen.id === editingItem.id) return;
      if (screen.users && screen.users.length > 0) {
        screen.users.forEach((user) => {
          assignments.set(user.id, screen.name);
        });
      }
    });
    return assignments;
  }, [screensData, editingItem]);
  const allUsers = React.useMemo(() => {
    if (!usersData?.data) return [];
    return usersData.data.sort((a, b) => {
      const aAssigned = userAssignments.has(a.id);
      const bAssigned = userAssignments.has(b.id);
      if (!aAssigned && bAssigned) return -1;
      if (aAssigned && !bAssigned) return 1;
      const aIsKitchen = a.role?.id === RoleEnum.KITCHEN;
      const bIsKitchen = b.role?.id === RoleEnum.KITCHEN;
      if (aIsKitchen && !bIsKitchen) return -1;
      if (!aIsKitchen && bIsKitchen) return 1;
      return 0;
    });
  }, [usersData, userAssignments]);
  const createScreen = useCreatePreparationScreen();
  const updateScreen = useUpdatePreparationScreen();
  const formSchema = isEditing
    ? UpdatePreparationScreenSchema
    : CreatePreparationScreenSchema;
  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
  } = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      description: undefined,
      isActive: true,
      userId: '',
    },
  });
  // Efecto para cargar datos al editar
  useEffect(() => {
    if (editingItem) {
      reset({
        name: editingItem.name,
        description: editingItem.description ?? undefined,
        isActive: editingItem.isActive,
        userId:
          editingItem.users && editingItem.users.length > 0
            ? editingItem.users[0].id
            : '', // Siempre string vacío para activar validación
      });
      setSelectedUser(
        editingItem.users && editingItem.users.length > 0
          ? (editingItem.users[0] as User)
          : null,
      );
    } else {
      reset({
        name: '',
        description: undefined,
        isActive: true,
        userId: '',
      });
      setSelectedUser(null);
    }
  }, [editingItem, reset]);
  // Manejo del envío del formulario
  const onSubmit = async (data: FormData) => {
    try {
      if (isEditing && editingItem) {
        await updateScreen.mutateAsync({
          id: editingItem.id,
          data: data as UpdatePreparationScreenDto,
        });
      } else {
        await createScreen.mutateAsync(data as CreatePreparationScreenDto);
      }
      onSubmitSuccess?.();
      onDismiss();
    } catch (error: any) {
      // No mostrar snackbar aquí porque el hook ya lo hace
      // Solo hacer log para debugging
    }
  };
  // Manejo de selección de usuario
  const handleUserSelect = (user: User) => {
    setSelectedUser(user);
    setValue('userId', user.id);
    setShowUserDropdown(false);
  };
  const handleClearUser = () => {
    setSelectedUser(null);
    setValue('userId', '');
  };
  const isSubmitting = createScreen.isPending || updateScreen.isPending;
  // Funciones auxiliares para roles
  const getRoleLabel = (roleId?: number) => {
    switch (roleId) {
      case RoleEnum.ADMIN:
        return 'Administrador';
      case RoleEnum.MANAGER:
        return 'Gerente';
      case RoleEnum.CASHIER:
        return 'Cajero';
      case RoleEnum.WAITER:
        return 'Mesero';
      case RoleEnum.KITCHEN:
        return 'Cocina';
      case RoleEnum.DELIVERY:
        return 'Repartidor';
      default:
        return 'Sin rol';
    }
  };
  const getIconForRole = (roleId?: number) => {
    switch (roleId) {
      case RoleEnum.ADMIN:
        return 'shield-account';
      case RoleEnum.MANAGER:
        return 'account-tie';
      case RoleEnum.CASHIER:
        return 'cash-register';
      case RoleEnum.WAITER:
        return 'room-service';
      case RoleEnum.KITCHEN:
        return 'chef-hat';
      case RoleEnum.DELIVERY:
        return 'moped';
      default:
        return 'account';
    }
  };
  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContent}
        >
          <ScrollView>
            <Surface style={styles.surface}>
              <Text variant="headlineSmall" style={styles.title}>
                {isEditing
                  ? 'Editar Pantalla de Preparación'
                  : 'Crear Nueva Pantalla'}
              </Text>
              <View style={styles.form}>
                {}
                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.field}>
                      <TextInput
                        label="Nombre de la Pantalla *"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.name}
                        disabled={isSubmitting}
                        placeholder="Ej: Cocina Principal, Barra Fría"
                        mode="outlined"
                      />
                      {errors.name && (
                        <HelperText type="error" visible={!!errors.name}>
                          {errors.name.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
                {}
                <Controller
                  control={control}
                  name="description"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.field}>
                      <TextInput
                        label="Descripción (Opcional)"
                        value={value || ''}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.description}
                        disabled={isSubmitting}
                        placeholder="Ej: Pantalla para órdenes de cocina caliente"
                        mode="outlined"
                        multiline
                        numberOfLines={3}
                      />
                      {errors.description && (
                        <HelperText type="error" visible={!!errors.description}>
                          {errors.description.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
                {/* Campo Usuario */}
                <Controller
                  control={control}
                  name="userId"
                  render={() => (
                    <View style={styles.field}>
                      <TextInput
                        label="Usuario de Cocina *"
                        value={
                          selectedUser
                            ? `${selectedUser.firstName || ''} ${selectedUser.lastName || ''}`.trim() ||
                              selectedUser.username
                            : ''
                        }
                        mode="outlined"
                        error={!!errors.userId}
                        disabled={isSubmitting || isLoadingUsers}
                        onPressOut={() => {
                          if (
                            !isSubmitting &&
                            !isLoadingUsers &&
                            allUsers.length > 0
                          ) {
                            setShowUserDropdown(true);
                          }
                        }}
                        showSoftInputOnFocus={false}
                        editable={false}
                        right={
                          selectedUser ? (
                            <TextInput.Icon
                              icon="close"
                              onPress={() => {
                                handleClearUser();
                              }}
                              disabled={isSubmitting}
                            />
                          ) : (
                            <TextInput.Icon
                              icon={isLoadingUsers ? 'loading' : 'chevron-down'}
                              disabled={isSubmitting || isLoadingUsers}
                              onPress={() => {
                                if (!isSubmitting && !isLoadingUsers) {
                                  setShowUserDropdown(true);
                                }
                              }}
                            />
                          )
                        }
                      />
                      {errors.userId && (
                        <HelperText type="error" visible={!!errors.userId}>
                          {errors.userId.message}
                        </HelperText>
                      )}
                      {!errors.userId && (
                        <HelperText type="info" visible={true}>
                          Nota: Un usuario solo puede estar asignado a una
                          pantalla a la vez
                        </HelperText>
                      )}
                    </View>
                  )}
                />
                {}
                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.switchField}>
                      <Text variant="bodyLarge">¿Está activa?</Text>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        disabled={isSubmitting}
                        color={theme.colors.primary}
                      />
                    </View>
                  )}
                />
              </View>
              <View style={styles.actions}>
                <Button mode="text" onPress={onDismiss} disabled={isSubmitting}>
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleSubmit(onSubmit)}
                  loading={isSubmitting}
                  disabled={isSubmitting}
                >
                  {isEditing ? 'Actualizar' : 'Crear'}
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </Modal>
      </Portal>
      {}
      <Portal>
        <Modal
          visible={showUserDropdown}
          onDismiss={() => setShowUserDropdown(false)}
          contentContainerStyle={[styles.dropdownModal, { maxHeight: 300 }]}
        >
          <Surface style={styles.dropdownContent}>
            <View style={styles.dropdownHeader}>
              <Text variant="titleMedium" style={styles.dropdownTitle}>
                Seleccionar Usuario de Cocina
              </Text>
              <Text variant="bodySmall" style={styles.dropdownSubtitle}>
                Solo los usuarios con rol de cocina pueden ser seleccionados
              </Text>
            </View>
            <Divider />
            <ScrollView>
              {isLoadingUsers ? (
                <View style={styles.loadingContainer}>
                  <Text>Cargando usuarios...</Text>
                </View>
              ) : allUsers.length === 0 ? (
                <View style={styles.emptyContainer}>
                  <Text>No hay usuarios disponibles</Text>
                </View>
              ) : (
                allUsers.map((user) => {
                  const displayName =
                    `${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username;
                  const isKitchenUser = user.role?.id === RoleEnum.KITCHEN;
                  const roleLabel = getRoleLabel(user.role?.id);
                  const assignedScreen = userAssignments.get(user.id);
                  const isAssigned = !!assignedScreen;
                  const isSelectable = isKitchenUser && !isAssigned;
                  return (
                    <List.Item
                      key={user.id}
                      title={displayName}
                      description={
                        isAssigned
                          ? `Asignado a: ${assignedScreen}`
                          : `${user.username !== displayName ? user.username + ' • ' : ''}${roleLabel}`
                      }
                      onPress={
                        isSelectable ? () => handleUserSelect(user) : undefined
                      }
                      left={(props) => (
                        <List.Icon
                          {...props}
                          icon={getIconForRole(user.role?.id)}
                          color={
                            isAssigned ? theme.colors.outline : props.color
                          }
                        />
                      )}
                      style={[
                        styles.dropdownItem,
                        !isSelectable && styles.disabledDropdownItem,
                      ]}
                      disabled={!isSelectable}
                      titleStyle={!isSelectable && styles.disabledText}
                      descriptionStyle={[
                        !isSelectable && styles.disabledText,
                        isAssigned && { color: theme.colors.error },
                      ]}
                    />
                  );
                })
              )}
            </ScrollView>
          </Surface>
        </Modal>
      </Portal>
    </>
  );
};
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      margin: 20,
    },
    surface: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    title: {
      padding: 24,
      paddingBottom: 16,
      color: theme.colors.onSurface,
    },
    form: {
      paddingHorizontal: 24,
    },
    field: {
      marginBottom: 16,
    },
    switchField: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 16,
      paddingVertical: 8,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      padding: 16,
      paddingTop: 8,
      gap: 8,
      borderTopWidth: 1,
      borderTopColor: theme.colors.surfaceVariant,
    },
    dropdownModal: {
      margin: 20,
      marginTop: '30%',
    },
    dropdownContent: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    dropdownHeader: {
      padding: 16,
      paddingBottom: 12,
    },
    dropdownTitle: {
      marginBottom: 4,
    },
    dropdownSubtitle: {
      color: theme.colors.onSurfaceVariant,
    },
    dropdownItem: {
      paddingHorizontal: 16,
    },
    disabledDropdownItem: {
      opacity: 0.5,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    disabledText: {
      color: theme.colors.onSurfaceDisabled,
    },
    loadingContainer: {
      padding: 20,
      alignItems: 'center',
    },
    emptyContainer: {
      padding: 20,
      alignItems: 'center',
    },
  });
export default PreparationScreenFormModal;

================
File: app/src/modules/receipts/types/receipt.types.ts
================
import type {
  OrderType,
  OrderStatus,
} from '@/modules/orders/types/orders.types';
export interface ReceiptList {
  id: string;
  shiftOrderNumber: number;
  orderType: OrderType;
  orderStatus: OrderStatus;
  total: number;
  createdAt: string;
  scheduledAt?: string;
  finalizedAt: string;
  notes?: string;
  paymentsSummary?: {
    totalPaid: number;
  };
  table?: {
    id: string;
    number: string;
    name: string;
    isTemporary: boolean;
    area?: {
      name: string;
    };
  };
  deliveryInfo?: {
    recipientName?: string;
    recipientPhone?: string;
    fullAddress?: string;
  };
  preparationScreenStatuses?: Array<{
    name: string;
    status: 'PENDING' | 'IN_PROGRESS' | 'READY';
  }>;
  ticketImpressionCount?: number;
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
  isFromWhatsApp?: boolean;
}
export interface Receipt {
  id: string;
  shiftOrderNumber: number;
  orderType: OrderType;
  orderStatus: OrderStatus;
  total: number;
  subtotal: number;
  createdAt: string;
  updatedAt: string;
  finalizedAt?: string;
  scheduledAt?: string;
  notes?: string;
  userId?: string;
  tableId?: string;
  customerId?: string;
  isFromWhatsApp?: boolean;
  estimatedDeliveryTime?: string;
  user?: {
    id: string;
    firstName?: string;
    lastName?: string;
    username?: string;
  };
  table?: {
    id: string;
    number: string;
    name: string;
    isTemporary: boolean;
    area?: {
      id: string;
      name: string;
    };
  };
  customer?: {
    id: string;
    name: string;
    phone?: string;
    email?: string;
  };
  deliveryInfo?: {
    id: string;
    recipientName?: string;
    recipientPhone?: string;
    deliveryInstructions?: string;
    fullAddress?: string;
    street?: string;
    number?: string;
    interiorNumber?: string;
    neighborhood?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    country?: string;
    latitude?: number;
    longitude?: number;
  };
  preparationScreens?: string[];
  orderItems: Array<{
    id: string;
    quantity?: number;
    basePrice: number;
    finalPrice: number;
    preparationNotes?: string;
    preparationStatus?: string;
    product: {
      id: string;
      name: string;
      description?: string;
      price: number;
    };
    productVariant?: {
      id: string;
      name: string;
      price: number;
    };
    productModifiers?: Array<{
      id: string;
      name: string;
      price: number;
    }>;
    selectedPizzaCustomizations?: Array<any>;
  }>;
  payments?: Array<{
    id: string;
    amount: number;
    paymentMethod: string;
    paymentStatus: string;
    createdAt: string;
    updatedAt: string;
  }>;
  adjustments?: Array<{
    id: string;
    type: string;
    amount: number;
    reason?: string;
    createdAt: string;
  }>;
  ticketImpressions?: Array<{
    id: string;
    ticketType: string;
    impressionTime: string;
    user?: {
      id: string;
      firstName?: string;
      lastName?: string;
    };
    printer?: {
      id: string;
      name: string;
    };
  }>;
}
export type ReceiptsListResponse = ReceiptList[];
export interface ReceiptFilters {
  startDate?: string;
  endDate?: string;
  orderType?: OrderType;
}

================
File: app/src/modules/shiftAudit/hooks/useShifts.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService, type Shift } from '@/services/shifts';
export const useShifts = (params?: {
  startDate?: string;
  endDate?: string;
}) => {
  return useQuery<Shift[], Error>({
    queryKey: ['shifts', 'history', params],
    queryFn: () => shiftsService.getHistory(params),
    staleTime: 0,
    gcTime: 0,
    refetchOnWindowFocus: false,
    refetchOnMount: true,
  });
};
export const useCurrentShift = () => {
  return useQuery<Shift | null, Error>({
    queryKey: ['shifts', 'current'],
    queryFn: () => shiftsService.getCurrentShift(),
    staleTime: 30000,
    refetchInterval: 60000,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
  });
};
export const useShiftDetail = (shiftId: string | undefined) => {
  return useQuery<Shift, Error>({
    queryKey: ['shifts', shiftId],
    queryFn: () => shiftsService.getById(shiftId!),
    enabled: !!shiftId,
    staleTime: 300000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });
};

================
File: app/src/modules/sync/services/syncService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { SyncStatus, SyncActivity } from '../types/sync.types';
class SyncService {
  async getSyncStatus(): Promise<SyncStatus> {
    const response = await apiClient.get<SyncStatus>(API_PATHS.SYNC_STATUS);
    if (!response.data) {
      throw new Error('No se pudo obtener el estado de sincronización');
    }
    return response.data;
  }
  async getSyncActivity(limit: number = 20): Promise<SyncActivity[]> {
    const response = await apiClient.get<SyncActivity[]>(
      API_PATHS.SYNC_ACTIVITY,
      { params: { limit } },
    );
    if (!response.data) {
      throw new Error('No se pudo obtener la actividad de sincronización');
    }
    return response.data;
  }
  async checkSyncAvailability(): Promise<boolean> {
    try {
      const status = await this.getSyncStatus();
      return status.enabled;
    } catch (error) {
      console.error(
        'Error verificando disponibilidad de sincronización:',
        error,
      );
      return false;
    }
  }
}
export const syncService = new SyncService();

================
File: app/src/modules/users/components/UserDetailModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  Surface,
  IconButton,
  Chip,
  Button,
  Dialog,
  TextInput,
  Icon,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useResetPassword, useDeleteUser } from '../hooks';
import type { User } from '../types';
interface UserDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  user: User;
  onEdit: (user: User) => void;
}
export function UserDetailModal({
  visible,
  onDismiss,
  user,
  onEdit,
}: UserDetailModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showPasswordDialog, setShowPasswordDialog] = useState(false);
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const resetPasswordMutation = useResetPassword();
  const deleteUserMutation = useDeleteUser();
  const handleResetPassword = async () => {
    if (newPassword !== confirmPassword) {
      return;
    }
    if (newPassword.length < 6) {
      return;
    }
    try {
      await resetPasswordMutation.mutateAsync({
        id: user.id,
        password: newPassword,
      });
      setShowPasswordDialog(false);
      setNewPassword('');
      setConfirmPassword('');
    } catch (error) {
      // Error handled in mutation
    }
  };
  const handleDeleteUser = async () => {
    try {
      await deleteUserMutation.mutateAsync(user.id);
      onDismiss();
    } catch (error) {
      // Error handled in mutation
    }
  };
  const getGenderLabel = (gender?: string | null) => {
    switch (gender) {
      case 'male':
        return 'Masculino';
      case 'female':
        return 'Femenino';
      case 'other':
        return 'Otro';
      default:
        return 'No especificado';
    }
  };
  const getRoleInfo = (roleId?: number) => {
    switch (roleId) {
      case 1:
        return {
          label: 'Administrador',
          icon: 'shield-account',
          color: theme.colors.error,
        };
      case 2:
        return {
          label: 'Gerente',
          icon: 'account-tie',
          color: theme.colors.primary,
        };
      case 3:
        return {
          label: 'Cajero',
          icon: 'cash-register',
          color: theme.colors.tertiary,
        };
      case 4:
        return {
          label: 'Mesero',
          icon: 'room-service',
          color: theme.colors.secondary,
        };
      case 5:
        return { label: 'Cocina', icon: 'chef-hat', color: '#FF6B6B' };
      case 6:
        return { label: 'Repartidor', icon: 'moped', color: '#4ECDC4' };
      default:
        return {
          label: 'Sin rol',
          icon: 'account',
          color: theme.colors.onSurfaceVariant,
        };
    }
  };
  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={3}>
            {}
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.elevation.level2 },
              ]}
            >
              <View style={styles.headerContent}>
                <View style={styles.headerNameRow}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onSurface },
                    ]}
                    variant="titleMedium"
                  >
                    {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                      user.username}
                  </Text>
                  <Chip
                    mode="flat"
                    icon={getRoleInfo(user.role?.id).icon}
                    style={[
                      styles.headerRoleChip,
                      { backgroundColor: theme.colors.surface },
                    ]}
                    textStyle={[
                      styles.headerRoleChipText,
                      { color: getRoleInfo(user.role?.id).color },
                    ]}
                    compact
                  >
                    {getRoleInfo(user.role?.id).label}
                  </Chip>
                </View>
                <Text
                  style={[
                    styles.modalSubtitle,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                  variant="bodySmall"
                >
                  {user.username}
                </Text>
              </View>
              <IconButton
                icon="close"
                size={20}
                onPress={onDismiss}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>
            <ScrollView
              style={styles.contentContainer}
              showsVerticalScrollIndicator={false}
            >
              {}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="contacts"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información de Contacto
                  </Text>
                </View>
                <View style={styles.compactRow}>
                  <Icon source="email" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Email
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.email || 'No especificado'}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon source="phone" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Teléfono
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.phoneNumber || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>
              {}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="account-details"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información Personal
                  </Text>
                </View>
                <View style={styles.compactRow}>
                  <Icon
                    source="account"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Nombre completo
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {`${user.firstName || 'No especificado'} ${user.lastName || 'No especificado'}`}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon
                    source="gender-transgender"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Género
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {getGenderLabel(user.gender)}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon
                    source="cake-variant"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Fecha de nacimiento
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.birthDate
                        ? new Date(user.birthDate).toLocaleDateString('es-MX', {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                          })
                        : 'No especificado'}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon
                    source={
                      user.isActive
                        ? 'check-circle-outline'
                        : 'close-circle-outline'
                    }
                    size={18}
                    color={
                      user.isActive ? theme.colors.primary : theme.colors.error
                    }
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Estado de la cuenta
                    </Text>
                    <Text
                      style={[
                        styles.compactValue,
                        {
                          color: user.isActive
                            ? theme.colors.primary
                            : theme.colors.error,
                        },
                      ]}
                      variant="bodySmall"
                    >
                      {user.isActive ? 'Activa' : 'Inactiva'}
                    </Text>
                  </View>
                </View>
                {}
                {user.role?.id === 5 && (
                  <View style={styles.compactRow}>
                    <Icon
                      source="monitor"
                      size={18}
                      color={theme.colors.primary}
                    />
                    <View style={styles.compactContent}>
                      <Text style={styles.compactLabel} variant="labelSmall">
                        Pantalla de Preparación
                      </Text>
                      <Text style={styles.compactValue} variant="bodySmall">
                        {user.preparationScreen?.name || 'No asignada'}
                      </Text>
                    </View>
                  </View>
                )}
              </View>
              {}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="map-marker"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Dirección
                  </Text>
                </View>
                <View style={styles.compactRow}>
                  <Icon source="home" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Dirección
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.address || 'No especificado'}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon source="city" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Ciudad
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.city || 'No especificado'}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon source="map" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Estado/Provincia
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.state || 'No especificado'}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon source="earth" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      País
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.country || 'No especificado'}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon
                    source="mailbox"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Código Postal
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.zipCode || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>
              {}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="alert-circle"
                    size={20}
                    color={theme.colors.error}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Contacto de Emergencia
                  </Text>
                </View>
                <View style={styles.compactRow}>
                  <Icon
                    source="account-alert"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Nombre
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.name || 'No especificado'}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon
                    source="phone-alert"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Teléfono
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.phone || 'No especificado'}
                    </Text>
                  </View>
                </View>
                <View style={styles.compactRow}>
                  <Icon
                    source="account-multiple"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Relación
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.relationship || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>
              {}
              <View style={styles.actionsContainer}>
                <Button
                  mode="contained-tonal"
                  onPress={() => onEdit(user)}
                  icon="pencil"
                  style={styles.actionButton}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  compact
                >
                  Editar Usuario
                </Button>
                <Button
                  mode="contained-tonal"
                  onPress={() => setShowPasswordDialog(true)}
                  icon="lock-reset"
                  style={styles.actionButton}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  buttonColor={theme.colors.secondaryContainer}
                  compact
                >
                  Cambiar Contraseña
                </Button>
                <Button
                  mode="outlined"
                  onPress={() => setShowDeleteDialog(true)}
                  icon="delete"
                  style={[styles.actionButton, styles.deleteButton]}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  textColor={theme.colors.error}
                  compact
                >
                  Eliminar Usuario
                </Button>
              </View>
            </ScrollView>
          </Surface>
        </Modal>
      </Portal>
      {}
      <Portal>
        <Dialog
          visible={showPasswordDialog}
          onDismiss={() => {
            setShowPasswordDialog(false);
            setNewPassword('');
            setConfirmPassword('');
            setShowPassword(false);
          }}
          style={styles.passwordDialog}
        >
          <View
            style={[
              styles.passwordDialogContainer,
              { borderColor: theme.colors.primary },
            ]}
          >
            <View style={styles.passwordDialogHeader}>
              <Icon
                source="lock-reset"
                size={40}
                color={theme.colors.primary}
              />
              <Dialog.Title style={styles.passwordDialogTitle}>
                Cambiar Contraseña
              </Dialog.Title>
              <View style={styles.passwordDialogUserInfo}>
                <Text
                  variant="bodyMedium"
                  style={styles.passwordDialogUserName}
                >
                  {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username}
                </Text>
                <Text
                  variant="bodySmall"
                  style={styles.passwordDialogUserDetail}
                >
                  {user.email}
                </Text>
                <Text
                  variant="labelSmall"
                  style={styles.passwordDialogUserDetail}
                >
                  @{user.username}
                </Text>
              </View>
            </View>
            <Dialog.Content style={styles.passwordDialogContent}>
              <TextInput
                label="Nueva contraseña"
                value={newPassword}
                onChangeText={setNewPassword}
                mode="flat"
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                autoCorrect={false}
                autoComplete="new-password"
                style={styles.passwordInput}
                contentStyle={styles.passwordInputContent}
                underlineColor={theme.colors.surfaceVariant}
                activeUnderlineColor={theme.colors.primary}
                right={
                  <TextInput.Icon
                    icon={showPassword ? 'eye-off' : 'eye'}
                    onPress={() => setShowPassword(!showPassword)}
                    size={20}
                    style={styles.passwordInputIcon}
                  />
                }
              />
              <TextInput
                label="Confirmar contraseña"
                value={confirmPassword}
                onChangeText={setConfirmPassword}
                mode="flat"
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                autoCorrect={false}
                autoComplete="new-password"
                style={styles.passwordInput}
                contentStyle={styles.passwordInputContent}
                underlineColor={theme.colors.surfaceVariant}
                activeUnderlineColor={theme.colors.primary}
              />
              {(newPassword.length > 0 || confirmPassword.length > 0) && (
                <View style={styles.passwordValidation}>
                  <View style={styles.validationItem}>
                    <Icon
                      source={
                        newPassword.length >= 6
                          ? 'check-circle'
                          : 'circle-outline'
                      }
                      size={16}
                      color={
                        newPassword.length >= 6
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.validationText,
                        {
                          color:
                            newPassword.length >= 6
                              ? theme.colors.primary
                              : theme.colors.onSurfaceVariant,
                        },
                      ]}
                    >
                      Mínimo 6 caracteres
                    </Text>
                  </View>
                  <View style={styles.validationItem}>
                    <Icon
                      source={
                        newPassword === confirmPassword &&
                        newPassword.length > 0
                          ? 'check-circle'
                          : 'circle-outline'
                      }
                      size={16}
                      color={
                        newPassword === confirmPassword &&
                        newPassword.length > 0
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.validationText,
                        {
                          color:
                            newPassword === confirmPassword &&
                            newPassword.length > 0
                              ? theme.colors.primary
                              : theme.colors.onSurfaceVariant,
                        },
                      ]}
                    >
                      Las contraseñas coinciden
                    </Text>
                  </View>
                </View>
              )}
            </Dialog.Content>
            <Dialog.Actions style={styles.passwordDialogActions}>
              <Button
                mode="text"
                onPress={() => {
                  setShowPasswordDialog(false);
                  setNewPassword('');
                  setConfirmPassword('');
                  setShowPassword(false);
                }}
                style={[
                  styles.passwordDialogButton,
                  styles.passwordDialogCancelButton,
                ]}
                labelStyle={styles.passwordDialogButtonLabel}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleResetPassword}
                loading={resetPasswordMutation.isPending}
                disabled={
                  resetPasswordMutation.isPending ||
                  newPassword.length < 6 ||
                  newPassword !== confirmPassword
                }
                style={[
                  styles.passwordDialogButton,
                  styles.passwordDialogPrimaryButton,
                ]}
                labelStyle={styles.passwordDialogButtonLabel}
              >
                Cambiar
              </Button>
            </Dialog.Actions>
          </View>
        </Dialog>
      </Portal>
      {/* Delete Confirmation Dialog */}
      <Portal>
        <Dialog
          visible={showDeleteDialog}
          onDismiss={() => setShowDeleteDialog(false)}
        >
          <Dialog.Icon icon="alert" color={theme.colors.error} />
          <Dialog.Title style={{ textAlign: 'center' }}>
            Eliminar Usuario
          </Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium" style={{ textAlign: 'center' }}>
              ¿Estás seguro de que deseas eliminar al usuario{' '}
              <Text style={{ fontWeight: 'bold' }}>{user.username}</Text>?
            </Text>
            <Text
              variant="bodySmall"
              style={{
                textAlign: 'center',
                marginTop: theme.spacing.s,
                color: theme.colors.error,
              }}
            >
              Esta acción no se puede deshacer
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowDeleteDialog(false)}>Cancelar</Button>
            <Button
              onPress={handleDeleteUser}
              loading={deleteUserMutation.isPending}
              disabled={deleteUserMutation.isPending}
              textColor={theme.colors.error}
            >
              Eliminar
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </>
  );
}
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    passwordDialog: {
      backgroundColor: 'transparent',
    },
    passwordDialogContainer: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 4,
      borderWidth: 2,
      overflow: 'hidden',
    },
    passwordDialogHeader: {
      alignItems: 'center',
      paddingTop: theme.spacing.l,
      paddingBottom: theme.spacing.s,
      backgroundColor: theme.colors.elevation.level1,
    },
    passwordDialogTitle: {
      textAlign: 'center',
      fontSize: 20,
      fontWeight: '600',
      marginTop: theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    passwordDialogUserInfo: {
      alignItems: 'center',
      paddingHorizontal: theme.spacing.l,
      marginBottom: theme.spacing.xs,
    },
    passwordDialogUserName: {
      textAlign: 'center',
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.xs,
    },
    passwordDialogUserDetail: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    passwordDialogContent: {
      paddingTop: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    passwordInput: {
      backgroundColor: 'transparent',
      marginBottom: theme.spacing.m,
    },
    passwordInputContent: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 2,
      paddingHorizontal: theme.spacing.m,
      paddingRight: theme.spacing.m,
    },
    passwordInputIcon: {
      marginRight: -theme.spacing.xs,
    },
    passwordValidation: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.m,
      gap: theme.spacing.s,
    },
    validationItem: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    validationText: {
      fontSize: 12,
    },
    passwordDialogActions: {
      justifyContent: 'center',
      paddingBottom: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      gap: theme.spacing.s,
    },
    passwordDialogButton: {
      minWidth: 100,
      borderRadius: theme.roundness * 3,
    },
    passwordDialogCancelButton: {
      marginRight: theme.spacing.s,
    },
    passwordDialogPrimaryButton: {
      elevation: 0,
    },
    passwordDialogButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
      letterSpacing: 0.1,
    },
    modalContainer: {
      margin: responsive.isTablet ? theme.spacing.xl : theme.spacing.m,
      maxWidth: responsive.isTablet ? 700 : 420,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '92%',
      paddingHorizontal: 0,
      height: responsive.isTablet ? '80%' : '80%',
      maxHeight: responsive.isTablet ? '85%' : '92%',
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      height: '100%',
      flex: 1,
      overflow: 'hidden',
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingVertical: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'column',
      justifyContent: 'center',
    },
    headerNameRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    modalTitle: {
      fontWeight: '600',
      marginRight: theme.spacing.xs,
      fontSize: responsive.isTablet ? 15 : 16,
    },
    modalSubtitle: {
      marginTop: 2,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    headerRoleChip: {
      minHeight: responsive.isTablet ? 32 : 28,
      height: 'auto',
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      paddingHorizontal: theme.spacing.s,
      paddingVertical: 3,
      alignItems: 'center',
      justifyContent: 'center',
    },
    headerRoleChipText: {
      fontSize: 12,
      fontWeight: '600',
      lineHeight: 16,
      marginVertical: 0,
      paddingVertical: 0,
      includeFontPadding: false,
    },
    contentContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.m,
    },
    infoSection: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      marginBottom: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      backgroundColor: theme.colors.elevation.level1,
      borderWidth: 0,
      elevation: 0,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : theme.spacing.xs,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 14,
    },
    listItemTitle: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontSize: 14,
    },
    listItemDescription: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    actionsContainer: {
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      marginBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.m,
      marginTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingHorizontal: 0,
    },
    actionButton: {
      borderRadius: theme.roundness * 2,
      elevation: 0,
      height: responsive.isTablet ? 36 : 40,
    },
    buttonContent: {
      height: responsive.isTablet ? 36 : 40,
      paddingTop: 0,
      paddingBottom: 0,
    },
    buttonLabel: {
      fontSize: responsive.isTablet ? 13 : 14,
      lineHeight: responsive.isTablet ? 18 : 20,
      marginVertical: responsive.isTablet ? 6 : 8,
      includeFontPadding: false,
    },
    deleteButton: {
      borderColor: theme.colors.error,
      marginTop: theme.spacing.xs,
    },
    compactRow: {
      flexDirection: 'row',
      alignItems: 'flex-start',
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.s,
      paddingVertical: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    compactContent: {
      flex: 1,
    },
    compactLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 11,
      lineHeight: responsive.isTablet ? 14 : 14,
    },
    compactValue: {
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 13,
      fontWeight: '500',
      lineHeight: responsive.isTablet ? 16 : 16,
    },
  });

================
File: app/src/services/appConfig.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
export interface AppConfig {
  maps: {
    apiKey: string;
  };
}
class AppConfigService {
  private config: AppConfig | null = null;
  async getConfig(): Promise<AppConfig> {
    if (this.config) {
      return this.config;
    }
    try {
      const response = await apiClient.get<AppConfig>(API_PATHS.APP_CONFIG);
      this.config = response.data;
      return this.config;
    } catch (error) {
      const defaultConfig: AppConfig = {
        maps: {
          apiKey: '',
        },
      };
      this.config = defaultConfig;
      return defaultConfig;
    }
  }
  async getMapsApiKey(): Promise<string> {
    const config = await this.getConfig();
    return config.maps.apiKey;
  }
  clearCache() {
    this.config = null;
  }
}
export const appConfigService = new AppConfigService();

================
File: backend/package.json
================
{
  "name": "nestjs-boilerplate",
  "version": "1.2.0",
  "description": "",
  "author": "",
  "private": true,
  "license": "MIT",
  "scripts": {
    "typeorm": "env-cmd ts-node --project tsconfig.cli.json -r tsconfig-paths/register node_modules/typeorm/cli.js",
    "migration:generate": "npm run typeorm -- --dataSource=src/database/data-source.ts migration:generate",
    "postmigration:generate": "npm run lint -- --fix",
    "migration:create": "npm run typeorm -- migration:create",
    "migration:run": "npm run typeorm -- --dataSource=src/database/data-source.ts migration:run",
    "migration:revert": "npm run typeorm -- --dataSource=src/database/data-source.ts migration:revert",
    "schema:drop": "npm run typeorm -- --dataSource=src/database/data-source.ts schema:drop",
    "db:reset": "env-cmd ts-node -r tsconfig-paths/register ./scripts/reset-database.ts",
    "db:clear-migrations": "env-cmd ts-node -r tsconfig-paths/register ./scripts/clear-migrations.ts",
    "db:fresh": "npm run db:reset && npm run migration:run && npm run seed:run:relational",
    "seed:create:relational": "hygen seeds create-relational",
    "generate:resource:relational": "hygen generate relational-resource",
    "postgenerate:resource:relational": "npm run lint -- --fix",
    "add:property:to-relational": "hygen property add-to-relational",
    "postadd:property:to-relational": "npm run lint -- --fix",
    "seed:run:relational": "ts-node -r tsconfig-paths/register ./src/database/seeds/relational/run-seed.ts",
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "fix:linebreaks": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\" --end-of-line lf",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:swc": "nest start -b swc -w",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "start:tz": "TZ=UTC nest start",
    "start:dev:tz": "TZ=UTC nest start --watch",
    "start:swc:tz": "TZ=UTC nest start -b swc -w",
    "start:debug:tz": "TZ=UTC nest start --debug --watch",
    "start:prod:tz": "TZ=UTC node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\"",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "env-cmd jest --config ./test/jest-e2e.json",
    "test:e2e:relational:docker": "docker compose -f docker-compose.relational.test.yaml --env-file env-example-relational -p tests up -d --build && docker compose -f docker-compose.relational.test.yaml -p tests exec api /opt/wait-for-it.sh -t 0 localhost:3000 -- npm run test:e2e -- --watchAll --runInBand && docker compose -f docker-compose.relational.test.yaml -p tests down && docker compose -p tests rm -svf",
    "release": "release-it",
    "setup:cloudflare-tunnel": "node scripts/setup-cloudflare-tunnel.js"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "3.744.0",
    "@aws-sdk/s3-request-presigner": "3.744.0",
    "@nestjs/axios": "^4.0.0",
    "@nestjs/common": "11.0.9",
    "@nestjs/config": "4.0.0",
    "@nestjs/core": "11.0.9",
    "@nestjs/jwt": "11.0.0",
    "@nestjs/passport": "11.0.5",
    "@nestjs/platform-express": "11.0.9",
    "@nestjs/schedule": "^6.0.0",
    "@nestjs/swagger": "11.0.3",
    "@nestjs/typeorm": "11.0.0",
    "@types/form-data": "^2.2.1",
    "@types/multer-s3": "3.0.3",
    "bcryptjs": "3.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "0.14.1",
    "date-fns-tz": "^3.2.0",
    "dotenv": "16.4.7",
    "express": "^5.1.0",
    "form-data": "^4.0.3",
    "handlebars": "4.7.8",
    "jsondiffpatch": "^0.7.3",
    "ms": "2.1.3",
    "multer": "1.4.5-lts.1",
    "multer-s3": "3.0.1",
    "node-thermal-printer": "^4.4.5",
    "nodemailer": "6.10.0",
    "p-limit": "^6.2.0",
    "passport": "0.7.0",
    "passport-anonymous": "1.0.1",
    "passport-jwt": "4.0.1",
    "pg": "8.13.3",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.1",
    "socket.io-client": "^4.8.1",
    "typeorm": "^0.3.20"
  },
  "devDependencies": {
    "@commitlint/cli": "19.7.1",
    "@commitlint/config-conventional": "19.7.1",
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.20.0",
    "@nestjs/cli": "11.0.2",
    "@nestjs/schematics": "11.0.0",
    "@nestjs/testing": "11.0.9",
    "@release-it/conventional-changelog": "10.0.0",
    "@swc/cli": "0.6.0",
    "@swc/core": "1.10.16",
    "@types/bcryptjs": "2.4.6",
    "@types/express": "^5.0.0",
    "@types/jest": "29.5.14",
    "@types/ms": "2.1.0",
    "@types/multer": "1.4.12",
    "@types/node": "22.13.4",
    "@types/passport-anonymous": "1.0.5",
    "@types/passport-jwt": "4.0.1",
    "@types/supertest": "6.0.2",
    "@typescript-eslint/eslint-plugin": "8.24.0",
    "@typescript-eslint/parser": "8.24.0",
    "env-cmd": "10.1.0",
    "eslint": "9.20.1",
    "eslint-config-prettier": "10.0.1",
    "eslint-plugin-prettier": "5.2.3",
    "globals": "^15.15.0",
    "hygen": "6.2.11",
    "is-ci": "4.1.0",
    "jest": "29.7.0",
    "prettier": "3.5.1",
    "prompts": "2.4.2",
    "release-it": "18.1.2",
    "supertest": "7.0.0",
    "ts-jest": "29.2.5",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "tslib": "2.8.1",
    "typescript": "^5.3.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  },
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  },
  "release-it": {
    "git": {
      "commitMessage": "chore: release v${version}"
    },
    "github": {
      "release": true
    },
    "npm": {
      "publish": false
    },
    "plugins": {
      "@release-it/conventional-changelog": {
        "infile": "CHANGELOG.md",
        "preset": {
          "name": "conventionalcommits",
          "types": [
            {
              "type": "chore(deps)",
              "section": "Dependency Upgrades"
            },
            {
              "type": "fix(deps)",
              "section": "Dependency Upgrades"
            },
            {
              "type": "feat",
              "section": "Features"
            },
            {
              "type": "fix",
              "section": "Bug Fixes"
            },
            {
              "type": "perf",
              "section": "Performance Improvements"
            },
            {
              "type": "revert",
              "section": "Reverts"
            },
            {
              "type": "docs",
              "section": "Documentation"
            },
            {
              "type": "refactor",
              "section": "Code Refactoring"
            },
            {
              "type": "test",
              "section": "Tests"
            },
            {
              "type": "ci",
              "section": "Continuous Integration"
            }
          ]
        }
      }
    }
  }
}

================
File: backend/src/orders/domain/order.ts
================
import { User } from '../../users/domain/user';
import { Table } from '../../tables/domain/table';
import { Customer } from '../../customers/domain/customer';
import { OrderStatus } from './enums/order-status.enum';
import { OrderType } from './enums/order-type.enum';
import { Payment } from '../../payments/domain/payment';
import { OrderItem } from './order-item';
import { Adjustment } from '../../adjustments/domain/adjustment';
import { DeliveryInfo } from './delivery-info';
import { OrderPreparationScreenStatus } from './order-preparation-screen-status';
import { TicketImpression } from './ticket-impression';
export class Order {
  id: string;
  userId: string | null;
  tableId: string | null;
  shiftOrderNumber: number;
  shiftId: string;
  scheduledAt: Date | null;
  orderStatus: OrderStatus;
  orderType: OrderType;
  subtotal: number;
  total: number;
  user: User | null;
  table: Table | null;
  orderItems: OrderItem[];
  payments: Payment[] | null;
  adjustments?: Adjustment[];
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
  finalizedAt: Date | null;
  notes?: string;
  customerId?: string | null;
  customer?: Customer | null;
  isFromWhatsApp?: boolean;
  deliveryInfo: DeliveryInfo | null;
  estimatedDeliveryTime?: Date | null;
  preparationScreenStatusesFull?: OrderPreparationScreenStatus[];
  ticketImpressions?: TicketImpression[];
  paymentsSummary?: {
    totalPaid: number;
  };
  preparationScreenStatuses?: Array<{
    name: string;
    status: string;
  }>;
  ticketImpressionCount?: number;
}

================
File: backend/src/orders/dto/receipt-detail.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { OrderStatus } from '../domain/enums/order-status.enum';
import { OrderType } from '../domain/enums/order-type.enum';
class UserDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  firstName?: string;
  @ApiProperty()
  lastName?: string;
  @ApiProperty()
  username: string;
}
class AreaDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
}
class TableDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  number: string;
  @ApiProperty()
  name: string;
  @ApiProperty()
  isTemporary: boolean;
  @ApiProperty({ type: () => AreaDto, required: false })
  area?: AreaDto;
}
class DeliveryInfoDto {
  @ApiProperty()
  id: string;
  @ApiProperty({ required: false })
  recipientName?: string;
  @ApiProperty({ required: false })
  recipientPhone?: string;
  @ApiProperty({ required: false })
  deliveryInstructions?: string;
  @ApiProperty({ required: false })
  fullAddress?: string;
  @ApiProperty({ required: false })
  street?: string;
  @ApiProperty({ required: false })
  number?: string;
  @ApiProperty({ required: false })
  interiorNumber?: string;
  @ApiProperty({ required: false })
  neighborhood?: string;
  @ApiProperty({ required: false })
  city?: string;
  @ApiProperty({ required: false })
  state?: string;
  @ApiProperty({ required: false })
  zipCode?: string;
  @ApiProperty({ required: false })
  country?: string;
  @ApiProperty({ required: false })
  latitude?: number;
  @ApiProperty({ required: false })
  longitude?: number;
}
class ProductDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
  @ApiProperty({ required: false })
  description?: string;
  @ApiProperty()
  price: number;
}
class ProductVariantDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
  @ApiProperty()
  price: number;
}
class ModifierDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
  @ApiProperty()
  price: number;
}
class PizzaCustomizationDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
  @ApiProperty()
  type: string;
}
class SelectedPizzaCustomizationDto {
  @ApiProperty()
  pizzaCustomizationId: string;
  @ApiProperty()
  half: string;
  @ApiProperty()
  action: string;
  @ApiProperty({ type: () => PizzaCustomizationDto, required: false })
  pizzaCustomization?: PizzaCustomizationDto;
}
class OrderItemDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  quantity: number;
  @ApiProperty()
  basePrice: number;
  @ApiProperty()
  finalPrice: number;
  @ApiProperty({ required: false })
  preparationNotes?: string;
  @ApiProperty({ required: false })
  preparationStatus?: string;
  @ApiProperty({ type: () => ProductDto })
  product: ProductDto;
  @ApiProperty({ type: () => ProductVariantDto, required: false })
  productVariant?: ProductVariantDto;
  @ApiProperty({ type: () => [ModifierDto], required: false })
  productModifiers?: ModifierDto[];
  @ApiProperty({ type: () => [SelectedPizzaCustomizationDto], required: false })
  selectedPizzaCustomizations?: SelectedPizzaCustomizationDto[];
}
class PaymentDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  amount: number;
  @ApiProperty()
  paymentMethod: string;
  @ApiProperty()
  paymentStatus: string;
  @ApiProperty()
  createdAt: Date;
  @ApiProperty()
  updatedAt: Date;
}
class PrinterDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  name: string;
}
class TicketImpressionDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  ticketType: string;
  @ApiProperty()
  impressionTime: Date;
  @ApiProperty({ type: () => UserDto, required: false })
  user?: UserDto;
  @ApiProperty({ type: () => PrinterDto, required: false })
  printer?: PrinterDto;
}
export class ReceiptDetailDto {
  @ApiProperty()
  id: string;
  @ApiProperty()
  shiftOrderNumber: number;
  @ApiProperty({ enum: OrderType })
  orderType: OrderType;
  @ApiProperty({ enum: OrderStatus })
  orderStatus: OrderStatus;
  @ApiProperty()
  total: number;
  @ApiProperty()
  subtotal: number;
  @ApiProperty()
  createdAt: Date;
  @ApiProperty()
  updatedAt: Date;
  @ApiProperty({ required: false })
  finalizedAt?: Date;
  @ApiProperty({ required: false })
  scheduledAt?: Date;
  @ApiProperty({ required: false })
  notes?: string;
  @ApiProperty({ type: () => UserDto, required: false })
  user?: UserDto;
  @ApiProperty({ type: () => TableDto, required: false })
  table?: TableDto;
  @ApiProperty({ type: () => DeliveryInfoDto, required: false })
  deliveryInfo?: DeliveryInfoDto;
  @ApiProperty({ type: [String], required: false })
  preparationScreens?: string[];
  @ApiProperty({ type: () => [OrderItemDto] })
  orderItems: OrderItemDto[];
  @ApiProperty({ type: () => [PaymentDto], required: false })
  payments?: PaymentDto[];
  @ApiProperty({ type: () => [TicketImpressionDto], required: false })
  ticketImpressions?: TicketImpressionDto[];
  @ApiProperty({
    required: false,
    description: 'Indica si la orden proviene de WhatsApp',
    example: true,
  })
  isFromWhatsApp?: boolean;
}

================
File: app/android/app/src/main/res/xml/network_security_config.xml
================
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>
    <domain-config cleartextTrafficPermitted="true">
        <domain>10.0.0.0/8</domain>
        <domain>172.16.0.0/12</domain>
        <domain>192.168.0.0/16</domain>
        <domain>localhost</domain>
        <domain>127.0.0.1</domain>
        <domain>10.0.2.2</domain>
        <domain includeSubdomains="false">192.168.1.*</domain>
        <domain includeSubdomains="false">192.168.0.*</domain>
        <domain includeSubdomains="false">10.0.0.*</domain>
        <domain includeSubdomains="false">172.16.*.*</domain>
    </domain-config>
    <domain-config>
        <domain includeSubdomains="true">tu-dominio.com</domain>
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </domain-config>
    <debug-overrides>
        <trust-anchors>
            <certificates src="system" />
            <certificates src="user" />
        </trust-anchors>
    </debug-overrides>
</network-security-config>

================
File: app/src/app/components/common/AdaptiveModal.tsx
================
import React, { ReactNode, useMemo } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Dimensions,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Modal, Portal } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
interface AdaptiveModalProps {
  visible: boolean;
  onDismiss: () => void;
  children: ReactNode;
  contentContainerStyle?: any;
  maxWidth?: number | string;
  minHeight?: number;
  maxHeight?: string | number;
  dismissable?: boolean;
  dismissableBackButton?: boolean;
  scrollable?: boolean;
  footer?: ReactNode;
  stickyFooter?: boolean;
}
export const AdaptiveModal: React.FC<AdaptiveModalProps> = ({
  visible,
  onDismiss,
  children,
  contentContainerStyle,
  maxWidth,
  minHeight = 200,
  maxHeight = '90%',
  dismissable = true,
  dismissableBackButton = true,
  scrollable = true,
  footer,
  stickyFooter = true,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const screenHeight = Dimensions.get('window').height;
  const maxHeightPixels = useMemo(() => {
    if (typeof maxHeight === 'string' && maxHeight.endsWith('%')) {
      const percentage = parseInt(maxHeight) / 100;
      return screenHeight * percentage;
    }
    return typeof maxHeight === 'number' ? maxHeight : screenHeight * 0.9;
  }, [maxHeight, screenHeight]);
  const styles = useMemo(
    () =>
      StyleSheet.create({
        modalContainer: {
          backgroundColor: theme.colors.surface,
          borderRadius: theme.roundness * 2,
          width: '90%',
          maxWidth: maxWidth || (responsive.isTablet ? 600 : 500),
          minHeight: minHeight,
          maxHeight: maxHeightPixels,
          alignSelf: 'center',
          overflow: 'hidden',
          elevation: 24,
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 12 },
          shadowOpacity: 0.58,
          shadowRadius: 16.0,
        },
        scrollView: {
          maxHeight: maxHeightPixels - (footer ? 100 : 20),
        },
        scrollContent: {
          padding: responsive.isTablet
            ? responsive.spacing.l
            : responsive.spacing.m,
        },
        contentPadding: {
          padding: responsive.isTablet
            ? responsive.spacing.l
            : responsive.spacing.m,
          flex: 1,
        },
        footer: {
          borderTopWidth: 1,
          borderTopColor: theme.colors.surfaceVariant,
          padding: responsive.spacing.m,
          backgroundColor: theme.colors.surface,
        },
      }),
    [theme, responsive, minHeight, maxHeightPixels, maxWidth, footer],
  );
  const modalContent = (
    <View style={styles.modalContainer}>
      {scrollable ? (
        <>
          <ScrollView
            style={styles.scrollView}
            contentContainerStyle={[
              styles.scrollContent,
              contentContainerStyle,
            ]}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            {children}
          </ScrollView>
          {stickyFooter && footer && (
            <View style={styles.footer}>{footer}</View>
          )}
        </>
      ) : (
        <>
          <View style={[styles.contentPadding, contentContainerStyle]}>
            {children}
          </View>
          {footer && <View style={styles.footer}>{footer}</View>}
        </>
      )}
    </View>
  );
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        dismissable={dismissable}
        dismissableBackButton={dismissableBackButton}
        contentContainerStyle={{
          justifyContent: 'center',
          alignItems: 'center',
          flex: 1,
        }}
      >
        {Platform.OS === 'ios' ? (
          <KeyboardAvoidingView behavior="position" keyboardVerticalOffset={20}>
            {modalContent}
          </KeyboardAvoidingView>
        ) : (
          modalContent
        )}
      </Modal>
    </Portal>
  );
};
export default AdaptiveModal;

================
File: app/src/app/navigation/AppNavigator.tsx
================
import React, { useEffect } from 'react';
import {
  NavigationContainer,
  Theme as NavigationTheme,
} from '@react-navigation/native';
import { useAuthStore } from '../store/authStore';
import { AuthStack } from './AuthStack';
import { ConditionalAppNavigator } from './ConditionalAppNavigator';
import { useAppTheme } from '../styles/theme';
import { initImageCache } from '../lib/imageCache';
import { reconnectionSnackbarService } from '@/services/reconnectionSnackbarService';
import { serverConnectionService } from '@/services/serverConnectionService';
export function AppNavigator() {
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const paperTheme = useAppTheme();
  useEffect(() => {
    initImageCache();
    return () => {
      serverConnectionService.destroy();
    };
  }, []);
  useEffect(() => {
    if (isAuthenticated) {
      reconnectionSnackbarService.start();
    } else {
      reconnectionSnackbarService.stop();
    }
    return () => {
      reconnectionSnackbarService.stop();
    };
  }, [isAuthenticated]);
  const navigationTheme: NavigationTheme = {
    dark: paperTheme.dark,
    colors: {
      primary: paperTheme.colors.primary,
      background: paperTheme.colors.background,
      card: paperTheme.colors.surface,
      text: paperTheme.colors.onBackground,
      border: paperTheme.colors.outline,
      notification: paperTheme.colors.error,
    },
    fonts: {
      regular: {
        ...paperTheme.fonts.bodyMedium,
        fontWeight: paperTheme.fonts.bodyMedium.fontWeight ?? 'normal',
      },
      medium: {
        ...paperTheme.fonts.titleMedium,
        fontWeight: paperTheme.fonts.titleMedium.fontWeight ?? 'normal',
      },
      bold: {
        ...paperTheme.fonts.titleLarge,
        fontWeight: paperTheme.fonts.titleLarge.fontWeight ?? 'bold',
      },
      heavy: {
        ...paperTheme.fonts.titleLarge,
        fontWeight: paperTheme.fonts.titleLarge.fontWeight ?? '900',
      },
    },
  };
  return (
    <NavigationContainer theme={navigationTheme}>
      {isAuthenticated ? <ConditionalAppNavigator /> : <AuthStack />}
    </NavigationContainer>
  );
}

================
File: app/src/app/navigation/KitchenOnlyNavigator.tsx
================
import React, { useEffect } from 'react';
import {
  BackHandler,
  TouchableOpacity,
  StatusBar,
  StyleSheet,
  View,
  Text,
  Platform,
} from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import KitchenNavigator from '../../modules/kitchen/navigation/KitchenNavigator';
import { CustomDrawerContent } from './components/CustomDrawerContent';
import { ServerSettingsScreen } from '../../modules/settings/screens/ServerSettingsScreen';
import { useAppTheme } from '../styles/theme';
import { Icon, Surface, Checkbox } from 'react-native-paper';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { RefreshButton } from '../../modules/kitchen/components/RefreshButton';
import { useAuthStore } from '../store/authStore';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderType } from '../../modules/kitchen/types/kitchen.types';
import { KitchenProvider } from '../../modules/kitchen/context/KitchenContext';
const Drawer = createDrawerNavigator();
function KitchenOnlyNavigatorContent() {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const screenName = user?.preparationScreen?.name || 'Pantalla de Preparación';
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderType.DINE_IN:
        return ' • Mesa';
      case OrderType.TAKE_AWAY:
        return ' • Llevar';
      case OrderType.DELIVERY:
        return ' • Domicilio';
      default:
        return '';
    }
  };
  // Prevenir navegación hacia atrás en Android (no aplicar en web)
  useEffect(() => {
    if (Platform.OS !== 'web') {
      const backHandler = BackHandler.addEventListener(
        'hardwareBackPress',
        () => {
          return true;
        },
      );
      return () => backHandler.remove();
    }
  }, []);
  const responsive = useResponsive();
  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        drawerButtonContainer: {
          width: 56,
          height: 56,
          justifyContent: 'center',
          alignItems: 'center',
          marginLeft: 0,
          borderRadius: 28,
        },
        headerStyle: {
          backgroundColor: theme.colors.primary,
          height: responsive.isWeb ? 80 : responsive.dimensions.headerHeight,
          elevation: 2,
        },
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
          color: theme.colors.onPrimary,
          fontWeight: 'bold',
          fontSize: responsive.isWeb ? 26 : responsive.isTablet ? 20 : 22,
        },
        drawerStyle: {
          backgroundColor: theme.colors.surface,
          width: responsive.isWeb ? 320 : responsive.dimensions.drawerWidth,
          borderTopRightRadius: responsive.isWeb ? 0 : theme.roundness * 2,
          borderBottomRightRadius: responsive.isWeb ? 0 : theme.roundness * 2,
          borderRightWidth: 0,
          borderRightColor: theme.colors.outlineVariant,
          elevation: 2,
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 0 },
          shadowOpacity: 0,
          shadowRadius: 0,
        },
        titleContainer: {
          flexDirection: 'row',
          alignItems: 'center',
        },
        filterIndicator: {
          ...theme.fonts.titleMedium,
          fontWeight: '500',
          opacity: 0.9,
        },
      }),
    [theme, responsive],
  );
  return (
    <>
      <StatusBar
        backgroundColor={theme.colors.primary}
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
      />
      <Drawer.Navigator
        initialRouteName="Kitchen"
        drawerContent={(props) => <CustomDrawerContent {...props} />}
        defaultStatus="closed"
        screenOptions={({ navigation }) => ({
          headerStyle: styles.headerStyle,
          headerTintColor: theme.colors.onPrimary,
          headerTitleStyle: styles.headerTitleStyle,
          drawerStyle: styles.drawerStyle,
          drawerActiveTintColor: theme.colors.primary,
          drawerInactiveTintColor: theme.colors.onSurfaceVariant,
          drawerLabelStyle: {
            ...theme.fonts.labelLarge,
            fontSize: responsive.fontSize.m,
          },
          drawerItemStyle: {
            marginVertical: responsive.spacing.xxs,
            borderRadius: theme.roundness * 2,
            paddingVertical: responsive.spacing.xxs,
            paddingHorizontal: responsive.spacing.xs,
          },
          headerShown: true,
          drawerType: 'slide',
          drawerPosition: 'left',
          headerShadowVisible: false,
          swipeEdgeWidth: 0,
          swipeEnabled: false,
          drawerHideStatusBarOnOpen: false,
          headerLeft: () => (
            <TouchableOpacity
              style={styles.drawerButtonContainer}
              onPress={() => navigation.openDrawer()}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Icon
                source="menu"
                size={responsive.isWeb ? 36 : 32}
                color={theme.colors.onPrimary}
              />
            </TouchableOpacity>
          ),
          headerTitle: () => (
            <Surface
              elevation={0}
              style={{
                backgroundColor: 'transparent',
              }}
            >
              <View style={styles.titleContainer}>
                <Text style={styles.headerTitleStyle}>{screenName}</Text>
                {filters.orderType && (
                  <Text
                    style={[
                      styles.filterIndicator,
                      { color: theme.colors.onPrimary },
                    ]}
                  >
                    {getFilterText()}
                  </Text>
                )}
              </View>
            </Surface>
          ),
          headerRight: () => (
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              {}
              <TouchableOpacity
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  paddingHorizontal: 12,
                  paddingVertical: 8,
                  marginRight: 8,
                  backgroundColor: filters.showPrepared
                    ? 'rgba(255,255,255,0.2)'
                    : 'transparent',
                  borderRadius: 20,
                }}
                onPress={() =>
                  setFilters({
                    ...filters,
                    showPrepared: !filters.showPrepared,
                  })
                }
              >
                <Checkbox
                  status={filters.showPrepared ? 'checked' : 'unchecked'}
                  onPress={() =>
                    setFilters({
                      ...filters,
                      showPrepared: !filters.showPrepared,
                    })
                  }
                  color={theme.colors.onPrimary}
                  uncheckedColor={theme.colors.onPrimary}
                />
                <Text
                  style={{
                    color: theme.colors.onPrimary,
                    fontSize: responsive.isWeb ? 16 : 14,
                    marginLeft: 4,
                    fontWeight: filters.showPrepared ? 'bold' : 'normal',
                  }}
                >
                  Mostrar Listas
                </Text>
              </TouchableOpacity>
              <KitchenFilterButton />
              {}
              <RefreshButton />
              <ConnectionIndicator />
            </View>
          ),
        })}
      >
        <Drawer.Screen
          name="Kitchen"
          options={{
            title: screenName,
            drawerIcon: ({ color, size }) => (
              <Icon source="chef-hat" color={color} size={size} />
            ),
          }}
        >
          {() => <KitchenNavigator />}
        </Drawer.Screen>
        <Drawer.Screen
          name="ServerSettings"
          component={ServerSettingsScreen}
          options={{
            title: 'Configuración del Servidor',
            drawerIcon: ({ color, size }) => (
              <Icon source="server-network" color={color} size={size} />
            ),
            headerShown: true,
            headerStyle: styles.headerStyle,
            headerTintColor: theme.colors.onPrimary,
            headerTitleStyle: styles.headerTitleStyle,
          }}
        />
      </Drawer.Navigator>
    </>
  );
}
export function KitchenOnlyNavigator() {
  if (Platform.OS === 'web') {
    const { KitchenWebNavigator } = require('./KitchenWebNavigator');
    return <KitchenWebNavigator />;
  }
  return (
    <KitchenProvider>
      <KitchenOnlyNavigatorContent />
    </KitchenProvider>
  );
}

================
File: app/src/modules/menu/screens/SubcategoriesScreen.tsx
================
import React, { useCallback, useMemo, useEffect, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Portal, IconButton } from 'react-native-paper';
import {
  useFocusEffect,
  useRoute,
  RouteProp,
  useNavigation,
} from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import GenericList from '../../../app/components/crud/GenericList';
import GenericDetailModal from '../../../app/components/crud/GenericDetailModal';
import GenericFormModal, {
  FormFieldConfig,
  ImagePickerConfig,
} from '../../../app/components/crud/GenericFormModal';
import { FilterOption } from '../../../app/components/crud/GenericList';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';
import {
  ImageUploadService,
  FileObject,
} from '../../../app/lib/imageUploadService';
import {
  useFindAllSubcategories,
  useCreateSubcategory,
  useUpdateSubcategory,
  useRemoveSubcategory,
} from '../hooks/useSubcategoriesQueries';
import {
  SubCategory,
  createSubCategoryDtoSchema,
  updateSubCategoryDtoSchema,
  SubCategoryFormInputs,
  UpdateSubCategoryFormInputs,
  findAllSubcategoriesDtoSchema,
} from '../schema/subcategories.schema';
import { z } from 'zod';
import { MenuStackParamList } from '@/modules/menu/navigation/types';
type SubcategoriesScreenRouteProp = RouteProp<
  MenuStackParamList,
  'SubcategoriesScreen'
>;
type SubcategoriesScreenNavigationProp = NativeStackNavigationProp<
  MenuStackParamList,
  'SubcategoriesScreen'
>;
type StatusFilter = 'all' | 'active' | 'inactive';
type FindAllSubcategoriesDto = z.infer<typeof findAllSubcategoriesDtoSchema>;
const SubcategoriesScreen: React.FC = () => {
  const theme = useAppTheme();
  const route = useRoute<SubcategoriesScreenRouteProp>();
  const navigation = useNavigation<SubcategoriesScreenNavigationProp>();
  const { categoryId, categoryName } = route.params;
  const styles = useMemo(() => createStyles(theme), [theme]);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const [statusFilter, setStatusFilter] = React.useState<StatusFilter>('all');
  const [formInitialValues, setFormInitialValues] = useState<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  >({
    name: '',
    description: '',
    isActive: true,
    categoryId: categoryId,
    sortOrder: 0,
    imageUri: null,
  });
  const queryParams = useMemo((): FindAllSubcategoriesDto => {
    let isActive: boolean | undefined;
    if (statusFilter === 'active') isActive = true;
    if (statusFilter === 'inactive') isActive = false;
    const params: FindAllSubcategoriesDto = { categoryId, page: 1, limit: 100 };
    if (isActive !== undefined) {
      params.isActive = isActive;
    }
    return params;
  }, [statusFilter, categoryId]);
  const {
    data: subcategoriesData,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: listError,
  } = useFindAllSubcategories(queryParams);
  const createMutation = useCreateSubcategory();
  const updateMutation = useUpdateSubcategory();
  const { mutateAsync: removeSubcategory } = useRemoveSubcategory();
  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<SubCategory>({
    entityName: 'Subcategoría',
    queryKey: ['subcategories', queryParams],
    deleteMutationFn: removeSubcategory,
  });
  const handleRefresh = useCallback(() => {
    refetchList();
  }, [refetchList]);
  useEffect(() => {
    const loadFormData = async () => {
      if (editingItem) {
        let imageUrl = null;
        if (editingItem.photo?.path) {
          try {
            const { getImageUrl } = await import('@/app/lib/imageUtils');
            imageUrl = await getImageUrl(editingItem.photo.path);
          } catch (error) {
            imageUrl = editingItem.photo.path;
          }
        }
        setFormInitialValues({
          name: editingItem.name,
          description: editingItem.description ?? '',
          isActive: editingItem.isActive,
          categoryId: editingItem.categoryId,
          sortOrder: editingItem.sortOrder ?? 0,
          imageUri: imageUrl,
        });
      } else {
        setFormInitialValues({
          name: '',
          description: '',
          isActive: true,
          categoryId: categoryId,
          sortOrder: 0,
          imageUri: null,
        });
      }
    };
    loadFormData();
  }, [editingItem, categoryId]);
  useFocusEffect(
    useCallback(() => {
      refetchList();
    }, [refetchList]),
  );
  const handleFormSubmit = async (
    formData: SubCategoryFormInputs | UpdateSubCategoryFormInputs,
    photoId: string | null | undefined,
  ) => {
    const { imageUri, ...dataToSubmit } = formData;
    const finalData = {
      ...dataToSubmit,
      ...(photoId !== undefined && { photoId }),
    };
    if (finalData.photoId === undefined && !editingItem) {
      delete (finalData as any).photoId;
    }
    try {
      if (editingItem) {
        await updateMutation.mutateAsync({
          id: editingItem.id,
          data: finalData as UpdateSubCategoryFormInputs,
        });
      } else {
        await createMutation.mutateAsync(finalData as SubCategoryFormInputs);
      }
      handleCloseModals();
    } catch (error) {}
  };
  const listRenderConfig = {
    titleField: 'name' as keyof SubCategory,
    descriptionField: 'description' as keyof SubCategory,
    imageField: 'photo' as keyof SubCategory,
    sortOrderField: 'sortOrder' as keyof SubCategory,
    statusConfig: {
      field: 'isActive' as keyof SubCategory,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };
  const formatDate = (value: string | Date) => {
    if (!value) return 'N/A';
    const date = new Date(value);
    return date.toLocaleDateString('es-ES', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };
  const detailFieldsToDisplay: Array<{
    field: keyof SubCategory;
    label: string;
    render?: (value: any) => string;
  }> = [
    {
      field: 'sortOrder',
      label: 'Orden de visualización',
      render: (value) => value ?? '0',
    },
    {
      field: 'createdAt',
      label: 'Fecha de creación',
      render: formatDate,
    },
    {
      field: 'updatedAt',
      label: 'Última actualización',
      render: formatDate,
    },
  ];
  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todas' },
    { value: 'active', label: 'Activas' },
    { value: 'inactive', label: 'Inactivas' },
  ];
  const formFields: FormFieldConfig<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  >[] = [
    { name: 'name', label: 'Nombre *', type: 'text', required: true },
    {
      name: 'description',
      label: 'Descripción',
      type: 'textarea',
      numberOfLines: 3,
    },
    {
      name: 'sortOrder',
      label: 'Orden de visualización',
      type: 'number',
      placeholder: '0',
    },
    {
      name: 'isActive',
      label: 'Activo',
      type: 'switch',
      switchLabel: 'Activo',
      defaultValue: true,
    },
  ];
  const imagePickerConfig: ImagePickerConfig<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  > = {
    imageUriField: 'imageUri',
    onImageUpload: async (file: FileObject) => {
      const result = await ImageUploadService.uploadImage(file);
      if (result.success && result.photoId) {
        return { id: result.photoId };
      }
      throw new Error(result.error || 'Error desconocido al subir imagen');
    },
    determineFinalPhotoId: ImageUploadService.determinePhotoId,
    imagePickerSize: 150,
    placeholderIcon: 'folder-open-outline',
    placeholderText: 'Imagen de subcategoría',
  };
  const renderSubcategoryActions = (item: SubCategory) => (
    <IconButton
      icon="chevron-right"
      size={28}
      onPress={() =>
        navigation.navigate('Products', {
          subcategoryId: item.id,
          subCategoryName: item.name,
        })
      }
      style={{ margin: 0 }}
    />
  );
  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!listError,
    data: subcategoriesData?.data,
    emptyConfig: {
      title: 'No hay subcategorías',
      message: `No hay subcategorías registradas para ${categoryName}. Presiona el botón + para crear la primera.`,
      icon: 'folder-outline',
    },
    errorConfig: {
      title: 'Error al cargar subcategorías',
      message: 'No se pudieron cargar las subcategorías. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchList,
    },
  });
  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };
  return (
    <View style={styles.container}>
      <GenericList<SubCategory>
        items={subcategoriesData?.data ?? []}
        enableSort={true}
        enableSearch={true}
        searchPlaceholder="Buscar subcategorías..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoadingList}
        contentContainerStyle={styles.listContentContainer}
        renderItemActions={renderSubcategoryActions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isDetailModalVisible || isFormModalVisible}
        showImagePlaceholder={true}
        placeholderIcon="folder-open-outline"
        isDrawerOpen={isDrawerOpen}
      />
      <Portal>
        <GenericDetailModal<SubCategory>
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          item={selectedItem}
          titleField="name"
          imageField="photo"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={detailFieldsToDisplay}
          onEdit={() => {
            if (selectedItem) {
              handleOpenEditModal(selectedItem);
            }
          }}
          deleteConfirmation={deleteConfirmation}
          isDeleting={isDeleting}
          showImage={true}
        />
        <GenericFormModal<
          SubCategoryFormInputs | UpdateSubCategoryFormInputs,
          SubCategory
        >
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSubmit={handleFormSubmit}
          formSchema={
            editingItem
              ? updateSubCategoryDtoSchema
              : createSubCategoryDtoSchema
          }
          formFields={formFields}
          imagePickerConfig={imagePickerConfig}
          initialValues={formInitialValues}
          editingItem={editingItem}
          isSubmitting={createMutation.isPending || updateMutation.isPending}
          modalTitle={(editing) =>
            editing ? 'Editar Subcategoría' : 'Crear Subcategoría'
          }
        />
      </Portal>
    </View>
  );
};
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContentContainer: {
      paddingBottom: 80,
    },
  });
export default SubcategoriesScreen;

================
File: app/src/modules/orders/components/OrderDetailModal.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  IconButton,
  Divider,
  Card,
  Chip,
  Surface,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { OrderStatusEnum } from '../types/orders.types';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
interface OrderDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId: string | null;
  orderNumber?: number;
  orderData?: any;
}
const getStatusColor = (status: string, theme: any) => {
  switch (status) {
    case OrderStatusEnum.PENDING:
      return '#FFA000';
    case OrderStatusEnum.IN_PROGRESS:
      return theme.colors.primary;
    case OrderStatusEnum.IN_PREPARATION:
      return '#FF6B35';
    case OrderStatusEnum.READY:
      return '#4CAF50';
    case OrderStatusEnum.DELIVERED:
      return theme.colors.tertiary;
    case OrderStatusEnum.COMPLETED:
      return '#9E9E9E';
    case OrderStatusEnum.CANCELLED:
      return theme.colors.error;
    default:
      return theme.colors.onSurfaceVariant;
  }
};
const getStatusLabel = (status: string) => {
  const statusMap: Record<string, string> = {
    [OrderStatusEnum.PENDING]: 'Pendiente',
    [OrderStatusEnum.IN_PROGRESS]: 'En Progreso',
    [OrderStatusEnum.IN_PREPARATION]: 'En Preparación',
    [OrderStatusEnum.READY]: 'Lista',
    [OrderStatusEnum.DELIVERED]: 'Entregada',
    [OrderStatusEnum.COMPLETED]: 'Completada',
    [OrderStatusEnum.CANCELLED]: 'Cancelada',
  };
  return statusMap[status] || status;
};
const getPreparationStatusLabel = (status: string) => {
  const statusMap: Record<string, string> = {
    PENDING: 'Pendiente',
    IN_PROGRESS: 'En Preparación',
    READY: 'Listo',
    DELIVERED: 'Entregado',
    CANCELLED: 'Cancelado',
  };
  return statusMap[status] || status;
};
const getPreparationStatusColor = (status: string, theme: any) => {
  switch (status) {
    case 'PENDING':
      return theme.colors.error;
    case 'IN_PROGRESS':
      return '#FFA000';
    case 'READY':
      return '#4CAF50';
    case 'DELIVERED':
      return theme.colors.tertiary;
    case 'CANCELLED':
      return theme.colors.onSurfaceDisabled;
    default:
      return theme.colors.onSurfaceVariant;
  }
};
export const OrderDetailContent: React.FC<{
  orderId: string | null;
  orderNumber?: number;
  orderData?: any;
}> = ({ orderId: _orderId, orderNumber: _orderNumber, orderData }) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  return (
    <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
      {!orderData ? (
        <View style={styles.errorContainer}>
          <Icon
            name="alert-circle-outline"
            size={48}
            color={theme.colors.error}
          />
          <Text style={styles.errorText}>
            No hay datos de la orden disponibles
          </Text>
        </View>
      ) : (
        <>
          {}
          <View style={styles.infoHeader}>
            <View style={styles.infoHeaderRow}>
              <Text style={styles.infoHeaderLabel}>Hora de creación:</Text>
              <Text style={styles.infoHeaderValue}>
                {format(new Date(orderData.createdAt), 'HH:mm', { locale: es })}
              </Text>
            </View>
          </View>
          {}
          <Card style={styles.itemsCard}>
            <Card.Content style={styles.cardContentCompact}>
              <Text style={styles.sectionTitle}>
                Artículos ({orderData.orderItems?.length || 0})
              </Text>
              {orderData.orderItems?.map((item: any, index: number) => (
                <View key={item.id || index} style={styles.itemRow}>
                  <View style={styles.itemCompactRow}>
                    <View style={styles.itemMainInfo}>
                      <View style={styles.itemTitleRow}>
                        <Text style={styles.itemName}>
                          {item.product?.name || 'Producto desconocido'}
                          {item.productVariant &&
                            ` - ${item.productVariant.name}`}
                        </Text>
                        <Chip
                          mode="flat"
                          compact
                          style={[
                            styles.preparationChip,
                            {
                              backgroundColor:
                                getPreparationStatusColor(
                                  item.preparationStatus,
                                  theme,
                                ) + '20',
                            },
                          ]}
                          textStyle={[
                            styles.preparationChipText,
                            {
                              color: getPreparationStatusColor(
                                item.preparationStatus,
                                theme,
                              ),
                            },
                          ]}
                        >
                          {getPreparationStatusLabel(item.preparationStatus)}
                        </Chip>
                      </View>
                      {item.preparationNotes && (
                        <Text style={styles.itemNotes}>
                          📝 {item.preparationNotes}
                        </Text>
                      )}
                    </View>
                    {item.preparedAt && (
                      <Text style={styles.preparedTime}>
                        {format(new Date(item.preparedAt), 'HH:mm')}
                      </Text>
                    )}
                  </View>
                  {index < orderData.orderItems.length - 1 && (
                    <Divider style={styles.itemDivider} />
                  )}
                </View>
              ))}
            </Card.Content>
          </Card>
        </>
      )}
    </ScrollView>
  );
};
export const OrderDetailModal: React.FC<OrderDetailModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderNumber,
  orderData,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  if (!visible) return null;
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.surface} elevation={2}>
          {}
          <View style={styles.header}>
            <View style={styles.headerContent}>
              <Text style={styles.title}>
                {orderNumber ? `Orden #${orderNumber}` : 'Detalles de la Orden'}
              </Text>
              {orderData && (
                <Chip
                  mode="flat"
                  style={[
                    styles.statusChip,
                    {
                      backgroundColor: getStatusColor(
                        orderData.orderStatus,
                        theme,
                      ),
                    },
                  ]}
                  textStyle={styles.statusChipText}
                >
                  {getStatusLabel(orderData.orderStatus)}
                </Chip>
              )}
            </View>
            <IconButton
              icon="close-circle"
              size={32}
              onPress={onDismiss}
              style={styles.closeButton}
              iconColor={theme.colors.error}
            />
          </View>
          <Divider />
          {}
          <OrderDetailContent
            orderId={orderId}
            orderNumber={orderNumber}
            orderData={order}
          />
        </Surface>
      </Modal>
    </Portal>
  );
};
const createStyles = (theme: any) =>
  StyleSheet.create({
    modalContainer: {
      padding: 12,
      maxWidth: 600,
      width: '95%',
      alignSelf: 'center',
      maxHeight: '92%',
    },
    surface: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 12,
      paddingVertical: 8,
      minHeight: 56,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: 12,
      marginRight: 8,
    },
    title: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    statusChip: {
      minHeight: 28,
      height: 'auto',
      paddingVertical: 4,
    },
    statusChipText: {
      fontSize: 13,
      fontWeight: '600',
      color: 'white',
      lineHeight: 18,
      includeFontPadding: false,
      textAlignVertical: 'center',
    },
    closeButton: {
      margin: -4,
      backgroundColor: theme.colors.errorContainer,
      borderRadius: 20,
    },
    content: {
      maxHeight: 600,
    },
    loadingContainer: {
      padding: 40,
      alignItems: 'center',
    },
    loadingText: {
      marginTop: 16,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      padding: 40,
      alignItems: 'center',
    },
    errorText: {
      marginTop: 16,
      color: theme.colors.error,
    },
    infoHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingHorizontal: 12,
      paddingVertical: 8,
      backgroundColor: theme.colors.surfaceVariant,
      marginBottom: 4,
    },
    infoHeaderRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    infoHeaderLabel: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginRight: 8,
    },
    infoHeaderValue: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    infoCard: {
      margin: 8,
      marginBottom: 4,
    },
    itemsCard: {
      marginHorizontal: 8,
      marginTop: 4,
      marginBottom: 8,
      flex: 1,
    },
    itemRow: {
      paddingVertical: 3,
    },
    itemCompactRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      gap: 8,
    },
    itemMainInfo: {
      flex: 1,
    },
    itemTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      flexWrap: 'nowrap',
    },
    itemStatusInfo: {
      alignItems: 'flex-end',
      gap: 2,
    },
    itemContent: {
      flex: 1,
    },
    itemHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    itemFooter: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginTop: 8,
    },
    itemDivider: {
      marginTop: 2,
      marginBottom: 1,
      backgroundColor: theme.colors.outlineVariant,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: 12,
    },
    itemName: {
      fontWeight: '600',
      fontSize: 13,
      color: theme.colors.onSurface,
      flex: 1,
      flexShrink: 1,
    },
    itemVariant: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    itemNotes: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: 0,
    },
    preparationChip: {
      minHeight: 26,
      height: 'auto',
      paddingHorizontal: 10,
      paddingVertical: 4,
    },
    preparationChipText: {
      fontSize: 12,
      fontWeight: '600',
      lineHeight: 16,
      includeFontPadding: false,
      textAlignVertical: 'center',
    },
    preparedTime: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '600',
      minWidth: 40,
      textAlign: 'right',
      alignSelf: 'center',
      lineHeight: 16,
    },
    itemTimesContainer: {
      flex: 1,
      alignItems: 'flex-end',
    },
    itemCreatedTime: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
    },
    preparedByText: {
      fontSize: 11,
      color: theme.colors.primary,
      fontWeight: '500',
      marginTop: 2,
    },
    notPrepared: {
      fontSize: 12,
      color: theme.colors.onSurfaceDisabled,
    },
    cardContentCompact: {
      paddingVertical: 6,
      paddingHorizontal: 10,
    },
  });
export default OrderDetailModal;

================
File: app/src/modules/orders/components/PaymentModal.tsx
================
import React, { useState, useEffect, useMemo, useRef } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Keyboard,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  RadioButton,
  TextInput,
  HelperText,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
  Surface,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  PaymentMethodEnum,
  PaymentStatusEnum,
  type PaymentMethod,
} from '../types/payment.types';
import {
  useGetPaymentsByOrderIdQuery,
  useCreatePaymentMutation,
  useUpdatePaymentMutation as _useUpdatePaymentMutation,
  useDeletePaymentMutation,
} from '../hooks/usePaymentQueries';
import { useCompleteOrderMutation } from '../hooks/useOrdersQueries';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import ChangeCalculatorModal from './ChangeCalculatorModal';
import { prepaymentService } from '@/modules/payments/services/prepaymentService';
interface PaymentModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId?: string;
  orderTotal: number;
  orderNumber?: number;
  orderStatus?: string;
  onOrderCompleted?: () => void;
  mode?: 'payment' | 'prepayment';
  onPrepaymentCreated?: (
    prepaymentId: string,
    amount: number,
    method: PaymentMethod,
  ) => void;
  existingPrepaymentId?: string;
  onPrepaymentDeleted?: () => void;
}
const PAYMENT_METHOD_LABELS: Record<PaymentMethod, string> = {
  CASH: '💵 Efectivo',
  CARD: '💳 Tarjeta',
  TRANSFER: '📱 Transferencia',
};
const PAYMENT_METHOD_ICONS: Record<PaymentMethod, string> = {
  CASH: 'cash',
  CARD: 'credit-card',
  TRANSFER: 'bank-transfer',
};
const DISABLED_METHODS: PaymentMethod[] = ['CARD', 'TRANSFER'];
const formatOrderStatus = (status: string): string => {
  switch (status) {
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En Progreso';
    case 'IN_PREPARATION':
      return 'En Preparación';
    case 'READY':
      return 'Lista';
    case 'DELIVERED':
      return 'Entregada';
    case 'COMPLETED':
      return 'Completada';
    case 'CANCELLED':
      return 'Cancelada';
    default:
      return status;
  }
};
export const PaymentModal: React.FC<PaymentModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderTotal,
  orderNumber,
  orderStatus,
  onOrderCompleted,
  mode = 'payment',
  onPrepaymentCreated,
  existingPrepaymentId,
  onPrepaymentDeleted,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const scrollViewRef = useRef<ScrollView>(null);
  const amountInputRef = useRef<View>(null);
  const [selectedMethod, setSelectedMethod] = useState<PaymentMethod>(
    PaymentMethodEnum.CASH,
  );
  const [amount, setAmount] = useState('');
  const [showChangeCalculator, setShowChangeCalculator] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [paymentToDelete, setPaymentToDelete] = useState<string | null>(null);
  const [keyboardVisible, setKeyboardVisible] = useState(false);
  const [showFinalizeConfirm, setShowFinalizeConfirm] = useState(false);
  const [isCreatingPrepayment, setIsCreatingPrepayment] = useState(false);
  const [showDeletePrepaymentConfirm, setShowDeletePrepaymentConfirm] =
    useState(false);
  // Queries y mutations (solo para modo payment)
  const { data: payments = [], isLoading: isLoadingPayments } =
    useGetPaymentsByOrderIdQuery(orderId || '', {
      enabled: mode === 'payment' && !!orderId,
    });
  const createPaymentMutation = useCreatePaymentMutation();
  const deletePaymentMutation = useDeletePaymentMutation();
  const completeOrderMutation = useCompleteOrderMutation();
  const totalPaid = useMemo(() => {
    if (mode === 'prepayment') {
      return 0;
    }
    return (payments || [])
      .filter((p) => p.paymentStatus === PaymentStatusEnum.COMPLETED)
      .reduce((sum, payment) => sum + (Number(payment.amount) || 0), 0);
  }, [payments, mode]);
  const pendingAmount = orderTotal - totalPaid;
  const isFullyPaid = pendingAmount <= 0;
  useEffect(() => {
    if (visible) {
      if (mode === 'prepayment') {
        setAmount(orderTotal.toFixed(2));
      } else {
        setAmount(pendingAmount > 0 ? pendingAmount.toFixed(2) : '');
      }
      setShowChangeCalculator(false);
      setSelectedMethod(PaymentMethodEnum.CASH);
    }
  }, [visible, pendingAmount, orderTotal, mode]);
  // Manejar el teclado
  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setKeyboardVisible(true);
        setTimeout(() => {
          if (amountInputRef.current && scrollViewRef.current) {
            amountInputRef.current.measureLayout(
              scrollViewRef.current as any,
              (x, y) => {
                scrollViewRef.current?.scrollTo({ y: y - 50, animated: true });
              },
              () => {},
            );
          }
        }, 100);
      },
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardVisible(false);
      },
    );
    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);
  const handleSubmit = async () => {
    const parsedAmount = parseFloat(amount);
    if (isNaN(parsedAmount) || parsedAmount <= 0) {
      return;
    }
    if (selectedMethod === PaymentMethodEnum.CASH) {
      setShowChangeCalculator(true);
      return;
    }
    await processPayment();
  };
  const processPayment = async () => {
    const parsedAmount = parseFloat(amount);
    try {
      if (mode === 'prepayment') {
        setIsCreatingPrepayment(true);
        const prepayment = await prepaymentService.createPrepayment({
          paymentMethod: selectedMethod,
          amount: parsedAmount,
        });
        onPrepaymentCreated?.(prepayment.id, parsedAmount, selectedMethod);
        onDismiss();
      } else {
        await createPaymentMutation.mutateAsync({
          orderId: orderId!,
          paymentMethod: selectedMethod,
          amount: parsedAmount,
        });
        setAmount('');
        setShowChangeCalculator(false);
        // Si ya está totalmente pagado, cerrar el modal
        if (pendingAmount - parsedAmount <= 0) {
          onDismiss();
        }
      }
    } catch (error) {
      // Error ya manejado por el mutation hook
    } finally {
      setIsCreatingPrepayment(false);
    }
  };
  const handleDeletePayment = async () => {
    if (!paymentToDelete) return;
    try {
      await deletePaymentMutation.mutateAsync(paymentToDelete);
      setShowDeleteConfirm(false);
      setPaymentToDelete(null);
    } catch (error) {}
  };
  const handleFinalizeOrder = async () => {
    try {
      await completeOrderMutation.mutateAsync(orderId);
      setShowFinalizeConfirm(false);
      // Llamar al callback si existe
      if (onOrderCompleted) {
        onOrderCompleted();
      } else {
        // Si no hay callback, solo cerrar el modal
        onDismiss();
      }
    } catch (error) {}
  };
  const getStatusColor = (status: string) => {
    switch (status) {
      case PaymentStatusEnum.COMPLETED:
        return '#4CAF50';
      case PaymentStatusEnum.PENDING:
        return theme.colors.primary;
      case PaymentStatusEnum.CANCELLED:
        return theme.colors.error;
      case PaymentStatusEnum.FAILED:
        return theme.colors.error;
      case PaymentStatusEnum.REFUNDED:
        return '#FF9800';
      default:
        return theme.colors.onSurfaceVariant;
    }
  };
  const getStatusText = (status: string) => {
    switch (status) {
      case PaymentStatusEnum.COMPLETED:
        return 'Completado';
      case PaymentStatusEnum.PENDING:
        return 'Pendiente';
      case PaymentStatusEnum.CANCELLED:
        return 'Cancelado';
      case PaymentStatusEnum.FAILED:
        return 'Fallido';
      case PaymentStatusEnum.REFUNDED:
        return 'Reembolsado';
      default:
        return status;
    }
  };
  const handleDeletePrepayment = async () => {
    if (!existingPrepaymentId) return;
    try {
      setIsCreatingPrepayment(true);
      await prepaymentService.deletePrepayment(existingPrepaymentId);
      onPrepaymentDeleted?.();
      setShowDeletePrepaymentConfirm(false);
      onDismiss();
    } catch (error) {
    } finally {
      setIsCreatingPrepayment(false);
    }
  };
  return (
    <Portal>
      <Modal
        visible={visible && !showChangeCalculator}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <View style={styles.modalWrapper}>
          <Surface style={styles.modalContent} elevation={3}>
            {}
            <View style={styles.header}>
              <View style={styles.headerTextContainer}>
                <Text style={styles.title}>
                  {mode === 'prepayment' ? 'Registrar Pago' : 'Pagos'}
                </Text>
                {orderNumber && mode !== 'prepayment' && (
                  <Text style={styles.orderNumber}>Orden #{orderNumber}</Text>
                )}
                {mode === 'prepayment' && (
                  <Text style={styles.orderNumber}>Pago anticipado</Text>
                )}
              </View>
              <IconButton icon="close" size={24} onPress={onDismiss} />
            </View>
            <Divider />
            <ScrollView
              ref={scrollViewRef}
              style={[
                styles.scrollView,
                keyboardVisible && styles.scrollViewWithKeyboard,
              ]}
              contentContainerStyle={styles.scrollViewContent}
              showsVerticalScrollIndicator={true}
              keyboardShouldPersistTaps="handled"
              bounces={true}
              nestedScrollEnabled={true}
            >
              {}
              <View style={styles.summaryContainer}>
                <View style={styles.summaryItem}>
                  <Text style={styles.summaryLabel}>Total</Text>
                  <Text style={styles.summaryAmount}>
                    ${orderTotal.toFixed(2)}
                  </Text>
                </View>
                {mode !== 'prepayment' && (
                  <>
                    <View style={styles.summaryDividerVertical} />
                    <View style={styles.summaryItem}>
                      <Text style={styles.summaryLabel}>Pagado</Text>
                      <Text
                        style={[styles.summaryAmount, { color: '#4CAF50' }]}
                      >
                        ${totalPaid.toFixed(2)}
                      </Text>
                    </View>
                    <View style={styles.summaryDividerVertical} />
                    <View style={styles.summaryItem}>
                      <Text
                        style={[styles.summaryLabel, { fontWeight: 'bold' }]}
                      >
                        Pendiente
                      </Text>
                      <Text
                        style={[
                          styles.summaryAmount,
                          {
                            fontWeight: 'bold',
                            color:
                              pendingAmount > 0
                                ? theme.colors.error
                                : '#4CAF50',
                          },
                        ]}
                      >
                        ${pendingAmount.toFixed(2)}
                      </Text>
                    </View>
                  </>
                )}
              </View>
              {}
              {mode === 'payment' && (
                <>
                  {isLoadingPayments ? (
                    <ActivityIndicator style={styles.loader} />
                  ) : (payments || []).length > 0 ? (
                    <View style={styles.paymentsSection}>
                      <Text style={styles.sectionTitle}>Pagos registrados</Text>
                      {(payments || []).map((payment) => (
                        <View key={payment.id} style={styles.paymentItem}>
                          <View style={styles.paymentLeftInfo}>
                            <View style={styles.paymentMethodRow}>
                              <Text style={styles.paymentMethodCompact}>
                                {PAYMENT_METHOD_LABELS[payment.paymentMethod]}
                              </Text>
                            </View>
                            <Text style={styles.paymentDateCompact}>
                              {new Date(payment.createdAt).toLocaleTimeString(
                                'es-MX',
                                {
                                  hour: '2-digit',
                                  minute: '2-digit',
                                },
                              )}
                            </Text>
                          </View>
                          <View style={styles.paymentRightInfo}>
                            <Text style={styles.paymentAmountCompact}>
                              ${(Number(payment.amount) || 0).toFixed(2)}
                            </Text>
                            <Chip
                              mode="flat"
                              style={[
                                styles.statusChipCompact,
                                {
                                  backgroundColor: getStatusColor(
                                    payment.paymentStatus,
                                  ),
                                },
                              ]}
                              textStyle={styles.statusChipTextCompact}
                            >
                              {getStatusText(payment.paymentStatus)}
                            </Chip>
                            <IconButton
                              icon="delete"
                              size={20}
                              iconColor={theme.colors.error}
                              onPress={() => {
                                setPaymentToDelete(payment.id);
                                setShowDeleteConfirm(true);
                              }}
                              disabled={deletePaymentMutation.isPending}
                              style={styles.deleteIconButton}
                            />
                          </View>
                        </View>
                      ))}
                    </View>
                  ) : null}
                </>
              )}
              {}
              {(mode === 'prepayment' || !isFullyPaid) && (
                <View style={styles.formSection}>
                  <Text style={styles.sectionTitle}>
                    {mode === 'prepayment'
                      ? 'Configurar pago'
                      : 'Registrar nuevo pago'}
                  </Text>
                  {}
                  <View style={styles.methodsContainer}>
                    {Object.entries(PaymentMethodEnum).map(([key, value]) => {
                      const isDisabled = DISABLED_METHODS.includes(
                        value as PaymentMethod,
                      );
                      return (
                        <TouchableOpacity
                          key={key}
                          style={[
                            styles.methodCard,
                            selectedMethod === value &&
                              styles.methodCardSelected,
                            isDisabled && styles.methodCardDisabled,
                          ]}
                          onPress={() =>
                            !isDisabled && setSelectedMethod(value)
                          }
                          disabled={isDisabled}
                        >
                          <RadioButton
                            value={value}
                            status={
                              selectedMethod === value ? 'checked' : 'unchecked'
                            }
                            onPress={() =>
                              !isDisabled && setSelectedMethod(value)
                            }
                            disabled={isDisabled}
                          />
                          <View style={styles.methodLabelContainer}>
                            <Text
                              style={[
                                styles.methodText,
                                selectedMethod === value &&
                                  styles.methodTextSelected,
                                isDisabled && styles.methodTextDisabled,
                              ]}
                            >
                              {PAYMENT_METHOD_LABELS[value]}
                            </Text>
                            {isDisabled && (
                              <Text style={styles.comingSoonText}>
                                Próximamente
                              </Text>
                            )}
                          </View>
                        </TouchableOpacity>
                      );
                    })}
                  </View>
                  {}
                  <View style={styles.amountContainer} ref={amountInputRef}>
                    <View style={styles.amountRow}>
                      <TextInput
                        label="Monto a pagar"
                        value={amount}
                        onChangeText={setAmount}
                        keyboardType="decimal-pad"
                        mode="outlined"
                        left={<TextInput.Affix text="$" />}
                        style={styles.amountInput}
                        error={
                          amount !== '' &&
                          (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)
                        }
                      />
                      <Button
                        mode="outlined"
                        onPress={() => setAmount(pendingAmount.toFixed(2))}
                        style={styles.totalPendingButton}
                        labelStyle={styles.totalPendingButtonLabel}
                        contentStyle={styles.totalPendingButtonContent}
                        compact
                      >
                        Total a pagar
                      </Button>
                    </View>
                    <HelperText
                      type="error"
                      visible={
                        amount !== '' &&
                        (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)
                      }
                    >
                      Ingrese un monto válido
                    </HelperText>
                  </View>
                </View>
              )}
            </ScrollView>
            {/* Botones de acción */}
            <View style={styles.footer}>
              <Button
                mode="outlined"
                onPress={onDismiss}
                style={[styles.footerButton, styles.cancelButton]}
                contentStyle={styles.footerButtonContent}
              >
                Cerrar
              </Button>
              {mode === 'prepayment' && existingPrepaymentId && (
                <Button
                  mode="outlined"
                  onPress={() => setShowDeletePrepaymentConfirm(true)}
                  style={[
                    styles.footerButton,
                    { borderColor: theme.colors.error },
                  ]}
                  contentStyle={styles.footerButtonContent}
                  textColor={theme.colors.error}
                  icon="delete"
                >
                  Eliminar
                </Button>
              )}
              {(mode === 'prepayment' || !isFullyPaid) && (
                <Button
                  mode="contained"
                  onPress={handleSubmit}
                  disabled={
                    !amount ||
                    isNaN(parseFloat(amount)) ||
                    parseFloat(amount) <= 0 ||
                    createPaymentMutation.isPending ||
                    isCreatingPrepayment
                  }
                  loading={
                    createPaymentMutation.isPending || isCreatingPrepayment
                  }
                  style={styles.footerButton}
                  contentStyle={styles.footerButtonContent}
                >
                  {mode === 'prepayment'
                    ? 'Registrar Pre-pago'
                    : 'Registrar Pago'}
                </Button>
              )}
              {isFullyPaid && mode !== 'prepayment' && (
                <Button
                  mode="contained"
                  onPress={() => setShowFinalizeConfirm(true)}
                  disabled={completeOrderMutation.isPending}
                  loading={completeOrderMutation.isPending}
                  style={[styles.footerButton, { backgroundColor: '#10B981' }]}
                  contentStyle={styles.footerButtonContent}
                  icon="check-circle"
                >
                  Finalizar Orden
                </Button>
              )}
            </View>
          </Surface>
        </View>
      </Modal>
      {}
      <ConfirmationModal
        visible={showDeleteConfirm}
        onDismiss={() => {
          setShowDeleteConfirm(false);
          setPaymentToDelete(null);
        }}
        onCancel={() => {
          setShowDeleteConfirm(false);
          setPaymentToDelete(null);
        }}
        onConfirm={handleDeletePayment}
        title="Eliminar pago"
        message="¿Está seguro de que desea eliminar este pago? Esta acción no se puede deshacer."
        confirmText="Sí, eliminar"
        cancelText="No, cancelar"
        confirmButtonColor={theme.colors.error}
      />
      {}
      <ChangeCalculatorModal
        visible={showChangeCalculator}
        onDismiss={() => {
          setShowChangeCalculator(false);
        }}
        onConfirm={() => {
          setShowChangeCalculator(false);
          processPayment();
        }}
        amountToPay={parseFloat(amount) || 0}
      />
      {}
      <ConfirmationModal
        visible={showFinalizeConfirm}
        onDismiss={() => setShowFinalizeConfirm(false)}
        onCancel={() => setShowFinalizeConfirm(false)}
        onConfirm={handleFinalizeOrder}
        title="Finalizar orden"
        message={
          orderStatus && orderStatus !== 'READY'
            ? `⚠️ ADVERTENCIA: Esta orden está en estado "${formatOrderStatus(orderStatus)}" y no "Lista".\n\n¿Está seguro de que desea finalizar la orden #${orderNumber}? La orden se marcará como completada.`
            : `¿Está seguro de que desea finalizar la orden #${orderNumber}? La orden se marcará como completada.`
        }
        confirmText={
          orderStatus && orderStatus !== 'READY'
            ? 'Finalizar igual'
            : 'Sí, finalizar'
        }
        cancelText="No, cancelar"
        confirmButtonColor={
          orderStatus && orderStatus !== 'READY'
            ? theme.colors.error
            : '#10B981'
        }
      />
      {}
      <ConfirmationModal
        visible={showDeletePrepaymentConfirm}
        onDismiss={() => setShowDeletePrepaymentConfirm(false)}
        onCancel={() => setShowDeletePrepaymentConfirm(false)}
        onConfirm={handleDeletePrepayment}
        title="Eliminar pago"
        message="¿Está seguro de que desea eliminar este pago registrado? Esta acción no se puede deshacer."
        confirmText="Sí, eliminar"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
      />
    </Portal>
  );
};
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m, theme.spacing.s),
    },
    modalWrapper: {
      width: '100%',
      maxWidth: responsive.isTablet ? 700 : 600,
      maxHeight: responsive.isTablet ? '90%' : '85%',
    },
    modalContent: {
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      width: '100%',
      maxHeight: '100%',
      minHeight: responsive.isTablet ? 550 : undefined,
      overflow: 'hidden',
      borderWidth: 2,
      borderColor: theme.colors.outline,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingVertical: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    headerTextContainer: {
      flex: 1,
    },
    title: {
      ...theme.fonts.headlineSmall,
      fontSize: responsive.fontSize(theme.fonts.headlineSmall.fontSize),
      color: theme.colors.onSurface,
      fontWeight: 'bold',
    },
    orderNumber: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      color: theme.colors.onSurfaceVariant,
    },
    scrollView: {
      maxHeight: responsive.isTablet ? 600 : 500,
    },
    scrollViewContent: {
      paddingBottom: responsive.spacing(theme.spacing.m, theme.spacing.s),
    },
    scrollViewWithKeyboard: {
      maxHeight: responsive.isTablet ? 350 : 250,
    },
    summaryContainer: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      alignItems: 'center',
      backgroundColor: theme.colors.primaryContainer,
      paddingVertical: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      marginTop: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      marginBottom: responsive.spacing(theme.spacing.m, theme.spacing.s),
      borderRadius: theme.roundness,
    },
    summaryItem: {
      flex: 1,
      alignItems: 'center',
    },
    summaryLabel: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onPrimaryContainer,
      opacity: 0.8,
      marginBottom: 2,
    },
    summaryAmount: {
      ...theme.fonts.titleSmall,
      fontSize: responsive.fontSize(theme.fonts.titleSmall.fontSize),
      fontWeight: 'bold',
      color: theme.colors.onPrimaryContainer,
    },
    summaryDividerVertical: {
      width: 1,
      height: '80%',
      backgroundColor: theme.colors.onPrimaryContainer,
      opacity: 0.2,
      marginHorizontal: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    loader: {
      marginVertical: responsive.spacing(theme.spacing.xl, theme.spacing.l),
    },
    paymentsSection: {
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    sectionTitle: {
      ...theme.fonts.titleSmall,
      fontSize: responsive.fontSize(theme.fonts.titleSmall.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      fontWeight: '600',
    },
    paymentItem: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
      padding: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      marginBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    paymentLeftInfo: {
      flex: 1,
    },
    paymentRightInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    paymentMethodRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    paymentMethodCompact: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    paymentAmountCompact: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      fontWeight: 'bold',
      color: theme.colors.primary,
      minWidth: responsive.isTablet ? 60 : 70,
      textAlign: 'right',
    },
    paymentDateCompact: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    statusChipCompact: {
      height: responsive.isTablet ? 24 : 26,
      minWidth: responsive.isTablet ? 80 : 90,
    },
    statusChipTextCompact: {
      fontSize: responsive.fontSize(11),
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 12 : 14,
    },
    deleteIconButton: {
      margin: 0,
      width: responsive.isTablet ? 32 : 36,
      height: responsive.isTablet ? 32 : 36,
    },
    formSection: {
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    methodsContainer: {
      marginBottom: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    methodCard: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      paddingHorizontal: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      marginBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      borderRadius: theme.roundness,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      backgroundColor: theme.colors.surface,
    },
    methodCardSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    methodText: {
      ...theme.fonts.bodyLarge,
      fontSize: responsive.fontSize(theme.fonts.bodyLarge.fontSize),
      color: theme.colors.onSurface,
      marginLeft: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    methodTextSelected: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '500',
    },
    methodCardDisabled: {
      opacity: 0.5,
      borderColor: theme.colors.outlineVariant,
    },
    methodLabelContainer: {
      flex: 1,
      marginLeft: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    methodTextDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    comingSoonText: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: 2,
    },
    amountContainer: {
      marginTop: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    amountRow: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      alignItems: 'flex-start',
    },
    amountInput: {
      backgroundColor: theme.colors.surface,
      flex: 1,
    },
    totalPendingButton: {
      marginTop: 4,
      height: responsive.isTablet ? 48 : 56,
      borderColor: theme.colors.primary,
      justifyContent: 'center',
    },
    totalPendingButtonContent: {
      height: '100%',
      paddingVertical: 0,
      paddingHorizontal: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    totalPendingButtonLabel: {
      fontSize: responsive.fontSize(13),
      lineHeight: responsive.isTablet ? 18 : 20,
      textAlignVertical: 'center',
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingVertical: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingTop: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      backgroundColor: theme.colors.surface,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    footerButton: {
      minWidth: responsive.isTablet ? 110 : 120,
    },
    footerButtonContent: {
      height: responsive.isTablet ? 36 : 40,
    },
    cancelButton: {
      borderColor: theme.colors.outline,
    },
  });
export default PaymentModal;

================
File: app/src/modules/restaurantConfig/components/WebViewDeliveryCoverageMap.tsx
================
import React, { useRef, useEffect, useState } from 'react';
import { View, StyleSheet, Alert, useWindowDimensions } from 'react-native';
import { WebView } from 'react-native-webview';
import {
  Surface,
  IconButton,
  ActivityIndicator,
  Text,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { DeliveryCoveragePoint } from '../types/restaurantConfig.types';
import { useGoogleMapsConfig } from '@/hooks/useGoogleMapsConfig';
interface DeliveryCoverageMapProps {
  initialPolygon?: DeliveryCoveragePoint[] | null;
  isEditing: boolean;
  onChange?: (polygon: DeliveryCoveragePoint[]) => void;
  restaurantLocation?: {
    latitude: number;
    longitude: number;
  };
}
export const WebViewDeliveryCoverageMap: React.FC<DeliveryCoverageMapProps> = ({
  initialPolygon,
  isEditing,
  onChange,
  restaurantLocation,
}) => {
  const theme = useAppTheme();
  const { width, height } = useWindowDimensions();
  const webViewRef = useRef<WebView>(null);
  const { config: mapsConfig, loading: isLoadingApiKey } =
    useGoogleMapsConfig();
  const apiKey = mapsConfig?.apiKey;
  const styles = React.useMemo(
    () => createStyles(theme, width, height),
    [theme, width, height],
  );
  const [mapReady, setMapReady] = useState(false);
  const [isDrawing, setIsDrawing] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [currentPolygon, setCurrentPolygon] = useState<DeliveryCoveragePoint[]>(
    () => {
      return initialPolygon || [];
    },
  );
  const mapHtml = apiKey
    ? `
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
    #map {
      height: 100%;
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    let map;
    let polygon;
    let markers = [];
    let isEditing = false;
    let polygonPath = [];
    function initMap() {
      // Inicializar el mapa
      const initialLocation = ${
        restaurantLocation
          ? `{ lat: ${restaurantLocation.latitude}, lng: ${restaurantLocation.longitude} }`
          : '{ lat: 20.5425, lng: -102.7935 }'
      };
      map = new google.maps.Map(document.getElementById('map'), {
        center: initialLocation,
        zoom: 14,
        disableDefaultUI: true,
        zoomControl: true,
        mapTypeControl: false,
        scaleControl: false,
        streetViewControl: false,
        rotateControl: false,
        fullscreenControl: false
      });
      // Escuchar mensajes desde React Native
      window.addEventListener('message', handleMessage);
      // Notificar que el mapa está listo
      sendMessage('mapReady', {});
    }
    function handleMessage(event) {
      try {
        const data = JSON.parse(event.data);
        switch(data.type) {
          case 'setPolygon':
            setPolygon(data.coordinates);
            break;
          case 'setEditMode':
            setEditMode(data.isEditing);
            break;
          case 'centerOnPolygon':
            centerOnPolygon();
            break;
          case 'clearPolygon':
            clearPolygon();
            break;
        }
      } catch (e) {
        // Error handling message
      }
    }
    function setPolygon(coordinates) {
      // Limpiar polígono anterior
      if (polygon) {
        polygon.setMap(null);
      }
      // Limpiar marcadores
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      // Convertir coordenadas
      polygonPath = coordinates.map(coord => ({
        lat: coord.lat || coord.latitude,
        lng: coord.lng || coord.longitude
      }));
      if (polygonPath.length >= 3) {
        // Crear polígono
        polygon = new google.maps.Polygon({
          paths: polygonPath,
          strokeColor: '#FF0000',
          strokeOpacity: 0.8,
          strokeWeight: 3,
          fillColor: '#FF0000',
          fillOpacity: 0.35,
          editable: false,
          draggable: false
        });
        polygon.setMap(map);
        // Centrar en el polígono
        setTimeout(() => {
          centerOnPolygon();
          // Notificar que el polígono se ha dibujado
          sendMessage('polygonSet', {});
        }, 100);
      }
    }
    function setEditMode(editing) {
      isEditing = editing;
      if (isEditing) {
        // Habilitar clicks en el mapa
        google.maps.event.clearListeners(map, 'click');
        map.addListener('click', function(event) {
          addPoint(event.latLng);
        });
        // Mostrar marcadores inmediatamente
        updateMarkers();
      } else {
        // Deshabilitar clicks
        google.maps.event.clearListeners(map, 'click');
        // Ocultar marcadores
        markers.forEach(marker => marker.setMap(null));
        markers = [];
      }
    }
    function addPoint(latLng) {
      if (!isEditing) return;
      polygonPath.push({
        lat: latLng.lat(),
        lng: latLng.lng()
      });
      updatePolygon();
      updateMarkers();
      // Enviar actualización a React Native
      sendMessage('polygonUpdated', {
        coordinates: polygonPath
      });
    }
    function updatePolygon() {
      if (polygon) {
        polygon.setPath(polygonPath);
      } else if (polygonPath.length >= 3) {
        polygon = new google.maps.Polygon({
          paths: polygonPath,
          strokeColor: '#FF0000',
          strokeOpacity: 0.8,
          strokeWeight: 3,
          fillColor: '#FF0000',
          fillOpacity: 0.35
        });
        polygon.setMap(map);
      }
    }
    function updateMarkers() {
      // Limpiar marcadores anteriores
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      if (!isEditing) return;
      // Crear nuevos marcadores
      polygonPath.forEach((point, index) => {
        const marker = new google.maps.Marker({
          position: point,
          map: map,
          draggable: true,
          label: {
            text: (index + 1).toString(),
            color: 'white',
            fontSize: '12px',
            fontWeight: 'bold'
          },
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 20,
            fillColor: '#2563eb',
            fillOpacity: 1,
            strokeColor: 'white',
            strokeWeight: 2
          }
        });
        // Permitir arrastrar
        marker.addListener('dragend', function() {
          polygonPath[index] = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          updatePolygon();
          sendMessage('polygonUpdated', {
            coordinates: polygonPath
          });
        });
        // Click para eliminar
        marker.addListener('click', function() {
          polygonPath.splice(index, 1);
          updatePolygon();
          updateMarkers();
          sendMessage('polygonUpdated', {
            coordinates: polygonPath
          });
        });
        markers.push(marker);
      });
    }
    function centerOnPolygon() {
      if (polygonPath.length > 0) {
        const bounds = new google.maps.LatLngBounds();
        polygonPath.forEach(point => {
          bounds.extend(point);
        });
        map.fitBounds(bounds);
        // Ajustar el zoom si es necesario
        const listener = google.maps.event.addListener(map, 'idle', function() {
          if (map.getZoom() > 18) {
            map.setZoom(18);
          }
          google.maps.event.removeListener(listener);
        });
      }
    }
    function clearPolygon() {
      polygonPath = [];
      if (polygon) {
        polygon.setMap(null);
        polygon = null;
      }
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      sendMessage('polygonUpdated', {
        coordinates: []
      });
    }
    function sendMessage(type, data) {
      try {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: type,
            ...data
          }));
        }
      } catch (e) {
        // Error sending message
      }
    }
  </script>
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap">
  </script>
</body>
</html>
  `
    : '';
  // Manejar mensajes del WebView
  const handleWebViewMessage = (event: any) => {
    try {
      const data = JSON.parse(event.nativeEvent.data);
      switch (data.type) {
        case 'mapReady':
          setMapReady(true);
          if (initialPolygon && initialPolygon.length > 0) {
            setTimeout(() => {
              sendMessageToWebView('setPolygon', {
                coordinates: initialPolygon,
              });
            }, 1000);
          } else {
            setIsLoading(false);
          }
          break;
        case 'polygonSet':
          setIsLoading(false);
          break;
        case 'polygonUpdated': {
          const newPolygon = data.coordinates;
          setCurrentPolygon(newPolygon);
          if (onChange) {
            onChange(newPolygon);
          }
          break;
        }
      }
    } catch (e) {}
  };
  const sendMessageToWebView = (type: string, data: any) => {
    if (webViewRef.current) {
      const message = JSON.stringify({ type, ...data });
      webViewRef.current.postMessage(message);
    }
  };
  useEffect(() => {
    if (mapReady) {
      sendMessageToWebView('setEditMode', {
        isEditing: isEditing && isDrawing,
      });
    }
  }, [isEditing, isDrawing, mapReady]);
  useEffect(() => {
    if (mapReady && initialPolygon && initialPolygon.length > 0) {
      setCurrentPolygon(initialPolygon);
      sendMessageToWebView('setPolygon', { coordinates: initialPolygon });
    }
  }, [initialPolygon, mapReady]);
  useEffect(() => {
    setIsLoading(true);
    setMapReady(false);
  }, []);
  const toggleDrawing = () => {
    if (isDrawing && currentPolygon.length < 3) {
      Alert.alert(
        'Área incompleta',
        'Necesitas al menos 3 puntos para crear un área de cobertura.',
      );
      return;
    }
    const newDrawingState = !isDrawing;
    setIsDrawing(newDrawingState);
    if (webViewRef.current) {
      const jsCode = `
        if (typeof setEditMode === 'function') {
          setEditMode(${newDrawingState});
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }
  };
  const clearPolygon = () => {
    sendMessageToWebView('clearPolygon', {});
    if (webViewRef.current) {
      const jsCode = `
        if (typeof clearPolygon === 'function') {
          clearPolygon();
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }
    setCurrentPolygon([]);
    setIsDrawing(false);
    if (onChange) {
      onChange([]);
    }
  };
  const centerOnPolygon = () => {
    sendMessageToWebView('centerOnPolygon', {});
    if (webViewRef.current) {
      const jsCode = `
        if (typeof centerOnPolygon === 'function') {
          centerOnPolygon();
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }
  };
  if (isLoadingApiKey || !mapHtml) {
    return (
      <View style={[styles.container, styles.loadingContainer]}>
        <Surface style={styles.loadingCard} elevation={3}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>
            Cargando configuración del mapa...
          </Text>
        </Surface>
      </View>
    );
  }
  return (
    <View style={styles.container}>
      <WebView
        ref={webViewRef}
        source={{ html: mapHtml }}
        style={styles.map}
        onMessage={handleWebViewMessage}
        onLoad={() => {
          if (
            webViewRef.current &&
            initialPolygon &&
            initialPolygon.length > 0
          ) {
            const jsCode = `
              setTimeout(() => {
                if (typeof setPolygon === 'function') {
                  setPolygon(${JSON.stringify(initialPolygon)});
                }
              }, 1500);
              true;
            `;
            webViewRef.current.injectJavaScript(jsCode);
          }
        }}
        onError={(_error) => {}}
        javaScriptEnabled={true}
        domStorageEnabled={true}
        startInLoadingState={true}
        mixedContentMode="compatibility"
        allowsInlineMediaPlayback={true}
        originWhitelist={['*']}
      />
      {}
      {isLoading && (
        <View style={styles.loadingContainer}>
          <Surface style={styles.loadingCard} elevation={3}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando mapa...</Text>
          </Surface>
        </View>
      )}
      {}
      {isEditing && (
        <View style={styles.controls}>
          <Surface style={styles.controlsCard} elevation={2}>
            <View style={styles.controlsRow}>
              <IconButton
                icon={isDrawing ? 'check' : 'draw'}
                mode="contained"
                containerColor={
                  isDrawing ? theme.colors.primary : theme.colors.secondary
                }
                iconColor={
                  isDrawing ? theme.colors.onPrimary : theme.colors.onSecondary
                }
                size={24}
                onPress={toggleDrawing}
              />
              <IconButton
                icon="crosshairs-gps"
                mode="contained"
                containerColor={theme.colors.tertiaryContainer}
                iconColor={theme.colors.onTertiaryContainer}
                size={24}
                onPress={centerOnPolygon}
                disabled={currentPolygon.length === 0}
              />
              <IconButton
                icon="delete"
                mode="contained"
                containerColor={theme.colors.errorContainer}
                iconColor={theme.colors.onErrorContainer}
                size={24}
                onPress={clearPolygon}
                disabled={currentPolygon.length === 0}
              />
            </View>
          </Surface>
        </View>
      )}
      {}
      {!isEditing && currentPolygon.length > 0 && (
        <View style={styles.centerButtonContainer}>
          <IconButton
            icon="crosshairs-gps"
            mode="contained"
            containerColor={theme.colors.primaryContainer}
            iconColor={theme.colors.onPrimaryContainer}
            size={24}
            onPress={centerOnPolygon}
            style={styles.floatingCenterButton}
          />
        </View>
      )}
    </View>
  );
};
const createStyles = (theme: AppTheme, width: number, height: number) =>
  StyleSheet.create({
    container: {
      height: Math.min(height * 0.6, 500),
      width: '100%',
      borderRadius: 16,
      overflow: 'hidden',
      backgroundColor: theme.colors.surfaceVariant,
    },
    map: {
      ...StyleSheet.absoluteFillObject,
    },
    controls: {
      position: 'absolute',
      top: theme.spacing.m,
      right: theme.spacing.m,
    },
    controlsCard: {
      borderRadius: 12,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    controlsRow: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
    },
    statusText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
    },
    centerButtonContainer: {
      position: 'absolute',
      bottom: theme.spacing.m,
      right: theme.spacing.m,
    },
    floatingCenterButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    loadingContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
    },
    loadingCard: {
      padding: theme.spacing.xl,
      borderRadius: 16,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
    },
    loadingText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
  });
export default WebViewDeliveryCoverageMap;

================
File: app/src/modules/shiftAudit/components/ShiftOrdersModal.tsx
================
import React, { useState, useMemo } from 'react';
import {
  Modal,
  View,
  StyleSheet,
  TouchableOpacity,
  RefreshControl,
  FlatList,
} from 'react-native';
import {
  Portal,
  Appbar,
  Searchbar,
  Text,
  ActivityIndicator,
} from 'react-native-paper';
import OrderSummaryCard from '@/modules/shared/components/OrderSummaryCard';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useShiftOrders } from '../hooks/useShiftOrders';
import EmptyState from '@/app/components/common/EmptyState';
import type { Order } from '@/app/schemas/domain/order.schema';
import { OrderTypeEnum } from '@/modules/orders/types/orders.types';
import {
  formatOrderTypeShort,
  getPaymentStatus,
} from '@/app/utils/orderFormatters';
import { receiptService } from '@/modules/receipts/services/receiptService';
import type { Receipt } from '@/modules/receipts/types/receipt.types';
import { OrderDetailsView } from './OrderDetailsView';
import { OrderHistoryView } from './OrderHistoryView';
interface ShiftOrdersModalProps {
  visible: boolean;
  onClose: () => void;
  shiftId: string;
}
export function ShiftOrdersModal({
  visible,
  onClose,
  shiftId,
}: ShiftOrdersModalProps) {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedReceipt, setSelectedReceipt] = useState<Receipt | null>(null);
  const [showReceiptDetails, setShowReceiptDetails] = useState(false);
  const [showOrderHistory, setShowOrderHistory] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const {
    data: orders,
    isLoading,
    error,
    refetch,
    isRefetching,
  } = useShiftOrders(shiftId);
  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };
  const handleReceiptPress = async (order: Order) => {
    try {
      const fullOrder = await receiptService.getReceiptById(order.id);
      setSelectedReceipt(fullOrder);
      setShowReceiptDetails(true);
    } catch (error) {
      // Error al cargar detalles del recibo
    }
  };
  // Filtrar órdenes basado en búsqueda
  const filteredOrders = useMemo(() => {
    if (!orders) return [];
    if (!searchQuery.trim()) return orders;
    const search = searchQuery.toLowerCase().trim();
    return orders.filter((order) => {
      // Buscar por número de orden
      if (order.shiftOrderNumber?.toString().includes(search)) return true;
      if (order.orderNumber?.toString().includes(search)) return true;
      // Buscar en información de entrega
      if (order.deliveryInfo) {
        // Campos principales
        if (order.deliveryInfo.customerName?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.customerPhone?.includes(search)) return true;
        if (order.deliveryInfo.address?.toLowerCase().includes(search))
          return true;
        // Campos alternativos que pueden venir del backend
        if (order.deliveryInfo.recipientName?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.recipientPhone?.includes(search)) return true;
        if (order.deliveryInfo.fullAddress?.toLowerCase().includes(search))
          return true;
        // Campos adicionales de dirección
        if (order.deliveryInfo.street?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.neighborhood?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.city?.toLowerCase().includes(search))
          return true;
      }
      // Buscar en mesa/área para órdenes locales
      if (order.table) {
        if (order.table.name?.toLowerCase().includes(search)) return true;
        if (order.table.number?.toString().includes(search)) return true;
        if (order.table.area?.name?.toLowerCase().includes(search)) return true;
      }
      // Buscar en área directa
      if (order.area?.name?.toLowerCase().includes(search)) return true;
      // Buscar en notas
      if (order.notes?.toLowerCase().includes(search)) return true;
      // Buscar en nombre del usuario creador
      if (order.createdBy) {
        if (order.createdBy.firstName?.toLowerCase().includes(search))
          return true;
        if (order.createdBy.lastName?.toLowerCase().includes(search))
          return true;
        if (order.createdBy.username?.toLowerCase().includes(search))
          return true;
      }
      // Buscar en user (campo alternativo)
      if (order.user) {
        if (order.user.firstName?.toLowerCase().includes(search)) return true;
        if (order.user.lastName?.toLowerCase().includes(search)) return true;
      }
      return false;
    });
  }, [orders, searchQuery]);
  // Función específica para el color de estado en recibos
  const getReceiptStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return theme.colors.primary;
      case 'CANCELLED':
        return theme.colors.error;
      case 'DELIVERED':
        return '#9333EA';
      default:
        return theme.colors.onSurfaceDisabled;
    }
  };
  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      case 'DELIVERED':
        return 'Entregada';
      default:
        return status;
    }
  };
  const renderReceiptItem = ({ item }: { item: Order }) => (
    <OrderSummaryCard
      item={item}
      onPress={() => handleReceiptPress(item)}
      getStatusColor={getReceiptStatusColor}
      getStatusLabel={getStatusLabel}
    />
  );
  const renderEmptyComponent = () => {
    if (isLoading) {
      return (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }
    return (
      <EmptyState
        icon="receipt"
        title="No hay órdenes"
        message={
          searchQuery
            ? 'No se encontraron órdenes con los criterios de búsqueda'
            : 'Este turno no tiene órdenes registradas'
        }
      />
    );
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onRequestClose={onClose}
        animationType="slide"
        presentationStyle="formSheet"
      >
        <View style={styles.container}>
          {showOrderHistory && selectedReceipt ? (
            <OrderHistoryView
              orderId={selectedReceipt.id}
              orderNumber={
                selectedReceipt.shiftOrderNumber || selectedReceipt.orderNumber
              }
              onBack={() => {
                setShowOrderHistory(false);
                setShowReceiptDetails(true);
              }}
            />
          ) : showReceiptDetails && selectedReceipt ? (
            <OrderDetailsView
              order={selectedReceipt}
              onBack={() => {
                setShowReceiptDetails(false);
                setSelectedReceipt(null);
              }}
              onShowHistory={() => {
                setShowReceiptDetails(false);
                setShowOrderHistory(true);
              }}
            />
          ) : (
            <>
              <Appbar.Header style={styles.header}>
                <Appbar.BackAction onPress={onClose} />
                <Appbar.Content title="Órdenes del Turno" />
                <Appbar.Action
                  icon="refresh"
                  onPress={handleRefresh}
                  disabled={isLoading || isRefreshing}
                />
              </Appbar.Header>
              {}
              <View style={styles.searchContainer}>
                <Searchbar
                  placeholder="Buscar por nombre, teléfono o dirección..."
                  onChangeText={setSearchQuery}
                  value={searchQuery}
                  style={styles.searchbar}
                  elevation={0}
                />
              </View>
              {}
              {error ? (
                <EmptyState
                  icon="alert-circle"
                  title="Error al cargar"
                  message={error.message || 'No se pudieron cargar las órdenes'}
                  actionLabel="Reintentar"
                  onAction={refetch}
                />
              ) : (
                <FlatList
                  data={filteredOrders}
                  renderItem={renderReceiptItem}
                  keyExtractor={(item) => item.id}
                  contentContainerStyle={styles.listContent}
                  refreshControl={
                    <RefreshControl
                      refreshing={isRefetching}
                      onRefresh={refetch}
                      colors={[theme.colors.primary]}
                    />
                  }
                  ListEmptyComponent={renderEmptyComponent}
                />
              )}
            </>
          )}
        </View>
      </Modal>
    </Portal>
  );
}
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    searchContainer: {
      paddingHorizontal: 16,
      paddingVertical: 12,
      backgroundColor: theme.colors.surface,
    },
    searchbar: {
      backgroundColor: theme.colors.background,
      elevation: 0,
    },
    listContent: {
      padding: theme.spacing.s,
      paddingBottom: theme.spacing.l * 2,
    },
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 12,
      flexShrink: 1,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: 120,
      gap: 8,
      flexShrink: 0,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 15,
      fontWeight: '700',
    },
    orderTime: {
      fontSize: 16,
      fontWeight: '600',
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 32,
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    createdByText: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
      textAlign: 'right',
    },
  });

================
File: app/src/modules/shiftAudit/screens/ShiftsListScreen.tsx
================
import React, { useState, useMemo } from 'react';
import {
  View,
  StyleSheet,
  RefreshControl,
  TouchableOpacity,
  Modal,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import {
  Text,
  Chip,
  Card,
  Divider,
  Button,
  Menu,
  Avatar,
  ActivityIndicator,
  IconButton,
  Surface,
} from 'react-native-paper';
import { FlashList } from '@shopify/flash-list';
import { format, parseISO, subDays, startOfDay, endOfDay } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useShifts } from '../hooks/useShifts';
import { formatCurrency } from '@/app/lib/formatters';
import type { Shift } from '../types';
import { ShiftOrdersModal, ShiftSalesSummaryView } from '../components';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import DateTimePicker from '@react-native-community/datetimepicker';
export function ShiftsListScreen() {
  const theme = useAppTheme();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [dateFilter, setDateFilter] = useState<
    'today' | 'yesterday' | 'last7' | 'custom'
  >('last7');
  const [showDateMenu, setShowDateMenu] = useState(false);
  const [showDateRangePicker, setShowDateRangePicker] = useState(false);
  const [customDateRange, setCustomDateRange] = useState<{
    start: Date;
    end: Date;
  }>({
    start: subDays(new Date(), 7),
    end: new Date(),
  });
  const [datePickerMode, setDatePickerMode] = useState<'start' | 'end'>(
    'start',
  );
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [selectedShiftId, setSelectedShiftId] = useState<string | null>(null);
  const [selectedShiftNumber, setSelectedShiftNumber] = useState<
    number | undefined
  >();
  const [showOrdersModal, setShowOrdersModal] = useState(false);
  const [showSalesSummaryView, setShowSalesSummaryView] = useState(false);
  const dateParams = useMemo(() => {
    const now = new Date();
    switch (dateFilter) {
      case 'today':
        return {
          startDate: format(startOfDay(now), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
      case 'yesterday': {
        const yesterday = subDays(now, 1);
        return {
          startDate: format(startOfDay(yesterday), 'yyyy-MM-dd'),
          endDate: format(endOfDay(yesterday), 'yyyy-MM-dd'),
        };
      }
      case 'last7':
        return {
          startDate: format(startOfDay(subDays(now, 7)), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
      case 'custom':
        return {
          startDate: format(startOfDay(customDateRange.start), 'yyyy-MM-dd'),
          endDate: format(endOfDay(customDateRange.end), 'yyyy-MM-dd'),
        };
      default:
        return {
          startDate: format(startOfDay(subDays(now, 7)), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
    }
  }, [dateFilter, customDateRange]);
  const {
    data: shifts,
    isLoading,
    error,
    refetch,
    isRefetching,
  } = useShifts(dateParams);
  useRefreshModuleOnFocus('shifts');
  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };
  const filteredShifts = useMemo(() => {
    if (!shifts || !Array.isArray(shifts)) {
      return [];
    }
    return shifts.filter((shift) => {
      if (!shift.openedAt) return false;
      try {
        const shiftDate = parseISO(shift.openedAt);
        const shiftDateOnly = format(shiftDate, 'yyyy-MM-dd');
        switch (dateFilter) {
          case 'today':
            return shiftDateOnly === format(new Date(), 'yyyy-MM-dd');
          case 'yesterday':
            return (
              shiftDateOnly === format(subDays(new Date(), 1), 'yyyy-MM-dd')
            );
          case 'last7': {
            const sevenDaysAgo = format(subDays(new Date(), 7), 'yyyy-MM-dd');
            const today = format(new Date(), 'yyyy-MM-dd');
            return shiftDateOnly >= sevenDaysAgo && shiftDateOnly <= today;
          }
          case 'custom': {
            const customStart = format(customDateRange.start, 'yyyy-MM-dd');
            const customEnd = format(customDateRange.end, 'yyyy-MM-dd');
            return shiftDateOnly >= customStart && shiftDateOnly <= customEnd;
          }
          default:
            return true;
        }
      } catch (e) {
        return false;
      }
    });
  }, [shifts, dateFilter, customDateRange]);
  const getDateFilterLabel = () => {
    switch (dateFilter) {
      case 'today':
        return 'Hoy';
      case 'yesterday':
        return 'Ayer';
      case 'last7':
        return 'Últimos 7 días';
      case 'custom':
        return `${format(customDateRange.start, 'dd/MM')} - ${format(customDateRange.end, 'dd/MM')}`;
      default:
        return 'Últimos 7 días';
    }
  };
  const handleDateChange = (event: any, selectedDate?: Date) => {
    setShowDatePicker(false);
    if (selectedDate) {
      if (datePickerMode === 'start') {
        setCustomDateRange({ ...customDateRange, start: selectedDate });
      } else {
        setCustomDateRange({ ...customDateRange, end: selectedDate });
      }
    }
  };
  const handleCustomDateRange = () => {
    setDateFilter('custom');
    setShowDateMenu(false);
    setShowDateRangePicker(true);
  };
  const handleViewOrders = (shift: Shift) => {
    setSelectedShiftId(String(shift.id));
    setSelectedShiftNumber(shift.globalShiftNumber || shift.shiftNumber);
    setShowOrdersModal(true);
  };
  const handleViewSalesSummary = (shift: Shift) => {
    setSelectedShiftId(String(shift.id));
    setSelectedShiftNumber(shift.globalShiftNumber || shift.shiftNumber);
    setShowSalesSummaryView(true);
  };
  const formatShiftDate = (dateString: string) => {
    try {
      const date = parseISO(dateString);
      return format(date, "d 'de' MMMM, yyyy", { locale: es });
    } catch {
      return dateString;
    }
  };
  const formatShiftTime = (dateString: string) => {
    try {
      const date = parseISO(dateString);
      return format(date, 'HH:mm', { locale: es });
    } catch {
      return dateString;
    }
  };
  const getShiftDuration = (openedAt: string, closedAt: string | null) => {
    if (!closedAt) return 'En curso';
    try {
      const start = parseISO(openedAt);
      const end = parseISO(closedAt);
      const diffInMinutes = Math.round(
        (end.getTime() - start.getTime()) / (1000 * 60),
      );
      const hours = Math.floor(diffInMinutes / 60);
      const minutes = diffInMinutes % 60;
      return `${hours}h ${minutes}m`;
    } catch {
      return 'N/A';
    }
  };
  const renderShiftItem = ({ item: shift }: { item: Shift }) => {
    const isOpen = shift.status === 'open';
    return (
      <Card
        style={[styles.shiftCard, isOpen && styles.openShiftCard]}
        mode="contained"
      >
        <Card.Content>
          <View style={styles.shiftHeader}>
            <View style={styles.shiftTitleRow}>
              <Text style={styles.shiftNumber}>
                Turno #{shift.globalShiftNumber || shift.shiftNumber || 'N/A'}
              </Text>
              <Chip
                mode="flat"
                icon={isOpen ? 'lock-open' : 'lock'}
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: isOpen
                      ? theme.colors.primaryContainer
                      : theme.colors.surfaceVariant,
                  },
                ]}
                textStyle={[
                  styles.statusChipText,
                  {
                    color: isOpen
                      ? theme.colors.onPrimaryContainer
                      : theme.colors.onSurfaceVariant,
                  },
                ]}
                compact
              >
                {isOpen ? 'Abierto' : 'Cerrado'}
              </Chip>
            </View>
            <Text style={styles.shiftDate}>
              {shift.openedAt
                ? formatShiftDate(shift.openedAt)
                : 'Fecha no disponible'}
            </Text>
          </View>
          <Divider style={styles.divider} />
          <View style={styles.shiftDetails}>
            {}
            <View style={styles.timeSection}>
              <View style={{ flex: 1 }}>
                <Text style={styles.timeText}>
                  {shift.openedAt ? formatShiftTime(shift.openedAt) : 'N/A'} -{' '}
                  {shift.closedAt
                    ? formatShiftTime(shift.closedAt)
                    : 'En curso'}
                </Text>
                <Text style={styles.durationText}>
                  {shift.openedAt
                    ? getShiftDuration(shift.openedAt, shift.closedAt)
                    : 'N/A'}
                </Text>
              </View>
            </View>
            {}
            <View style={styles.statsSection}>
              <Surface style={styles.statCard} elevation={0}>
                <Text style={styles.statLabel}>VENTAS</Text>
                <Text style={styles.statValue}>
                  {formatCurrency(shift.totalSales)}
                </Text>
              </Surface>
              <Surface style={styles.statCard} elevation={0}>
                <Text style={styles.statLabel}>ÓRDENES</Text>
                <Text style={styles.statValue}>{shift.totalOrders || 0}</Text>
              </Surface>
            </View>
            {}
            <View style={styles.cashSection}>
              <View style={styles.cashRow}>
                <Text style={styles.cashLabel}>Inicial</Text>
                <Text style={styles.cashValue}>
                  {formatCurrency(shift.initialCash)}
                </Text>
              </View>
              {shift.finalCash !== null && (
                <>
                  <View style={styles.cashRow}>
                    <Text style={styles.cashLabel}>Final</Text>
                    <Text style={styles.cashValue}>
                      {formatCurrency(shift.finalCash)}
                    </Text>
                  </View>
                  <View style={styles.cashRow}>
                    <Text style={[styles.cashLabel, styles.differenceLabel]}>
                      Diferencia
                    </Text>
                    <Text
                      style={[
                        styles.cashValue,
                        styles.differenceValue,
                        {
                          color:
                            shift.finalCash - shift.initialCash >= 0
                              ? theme.colors.tertiary
                              : theme.colors.error,
                        },
                      ]}
                    >
                      {formatCurrency(shift.finalCash - shift.initialCash)}
                    </Text>
                  </View>
                </>
              )}
            </View>
            {}
            <View style={styles.userSection}>
              <Text style={styles.userText}>
                👤 {shift.openedBy?.firstName || 'N/A'}{' '}
                {shift.openedBy?.lastName || ''}
              </Text>
              {shift.closedBy && (
                <Text style={styles.userText}>
                  🔒 {shift.closedBy.firstName || 'N/A'}{' '}
                  {shift.closedBy.lastName || ''}
                </Text>
              )}
            </View>
            {/* Botones de acciones */}
            <View style={styles.actionButtonsContainer}>
              <Button
                mode="contained-tonal"
                onPress={() => handleViewOrders(shift)}
                icon="receipt"
                style={[styles.actionButton, styles.ordersButton]}
                labelStyle={styles.actionButtonLabel}
                contentStyle={styles.actionButtonContent}
                compact
              >
                Órdenes ({shift.totalOrders || 0})
              </Button>
              <Button
                mode="contained-tonal"
                onPress={() => handleViewSalesSummary(shift)}
                icon="chart-bar"
                style={[styles.actionButton, styles.summaryButton]}
                labelStyle={styles.actionButtonLabel}
                contentStyle={styles.actionButtonContent}
                compact
              >
                Resumen
              </Button>
            </View>
          </View>
        </Card.Content>
      </Card>
    );
  };
  const renderFilters = () => (
    <Surface style={styles.filterContainer} elevation={1}>
      <View style={styles.filterContent}>
        <Menu
          visible={showDateMenu}
          onDismiss={() => setShowDateMenu(false)}
          anchor={
            <TouchableOpacity
              style={styles.filterButton}
              onPress={() => setShowDateMenu(true)}
              activeOpacity={0.8}
            >
              <Avatar.Icon
                icon="calendar-range"
                size={32}
                style={styles.filterIcon}
                color={theme.colors.primary}
              />
              <View style={styles.filterTextContainer}>
                <Text style={styles.filterLabel}>Filtrar por fecha</Text>
                <Text style={styles.filterValue}>{getDateFilterLabel()}</Text>
              </View>
              <Avatar.Icon
                icon="chevron-down"
                size={24}
                style={styles.filterArrow}
                color={theme.colors.onSurfaceVariant}
              />
            </TouchableOpacity>
          }
          contentStyle={styles.menuContent}
        >
          <Menu.Item
            onPress={() => {
              setDateFilter('today');
              setShowDateMenu(false);
            }}
            title="Hoy"
            leadingIcon="calendar-today"
            style={dateFilter === 'today' && styles.selectedMenuItem}
          />
          <Menu.Item
            onPress={() => {
              setDateFilter('yesterday');
              setShowDateMenu(false);
            }}
            title="Ayer"
            leadingIcon="calendar-minus"
            style={dateFilter === 'yesterday' && styles.selectedMenuItem}
          />
          <Menu.Item
            onPress={() => {
              setDateFilter('last7');
              setShowDateMenu(false);
            }}
            title="Últimos 7 días"
            leadingIcon="calendar-week"
            style={dateFilter === 'last7' && styles.selectedMenuItem}
          />
          <Divider />
          <Menu.Item
            onPress={handleCustomDateRange}
            title="Rango personalizado"
            leadingIcon="calendar-range"
            style={dateFilter === 'custom' && styles.selectedMenuItem}
          />
        </Menu>
      </View>
      {}
      <Modal
        visible={showDateRangePicker}
        transparent
        animationType="fade"
        onRequestClose={() => setShowDateRangePicker(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            {}
            <View style={styles.modalHeader}>
              <Avatar.Icon
                icon="calendar-range"
                size={48}
                style={styles.modalIcon}
                color={theme.colors.primary}
              />
              <Text style={styles.modalTitle}>Seleccionar rango</Text>
              <IconButton
                icon="close"
                onPress={() => setShowDateRangePicker(false)}
                size={20}
                style={styles.modalCloseButton}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>
            {}
            <View style={styles.dateRangeContainer}>
              <TouchableOpacity
                style={styles.dateButton}
                onPress={() => {
                  setDatePickerMode('start');
                  setShowDatePicker(true);
                }}
                activeOpacity={0.8}
              >
                <View style={styles.dateButtonContent}>
                  <Avatar.Icon
                    icon="calendar-start"
                    size={36}
                    style={styles.dateButtonIcon}
                    color={theme.colors.primary}
                  />
                  <View style={styles.dateButtonTextContainer}>
                    <Text style={styles.dateButtonLabel}>DESDE</Text>
                    <Text style={styles.dateButtonValue}>
                      {format(customDateRange.start, 'd MMM yyyy', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>
              <View style={styles.dateArrowContainer}>
                <Avatar.Icon
                  icon="arrow-right"
                  size={20}
                  style={styles.dateArrow}
                  color={theme.colors.primary}
                />
              </View>
              <TouchableOpacity
                style={styles.dateButton}
                onPress={() => {
                  setDatePickerMode('end');
                  setShowDatePicker(true);
                }}
                activeOpacity={0.8}
              >
                <View style={styles.dateButtonContent}>
                  <Avatar.Icon
                    icon="calendar-end"
                    size={36}
                    style={styles.dateButtonIcon}
                    color={theme.colors.primary}
                  />
                  <View style={styles.dateButtonTextContainer}>
                    <Text style={styles.dateButtonLabel}>HASTA</Text>
                    <Text style={styles.dateButtonValue}>
                      {format(customDateRange.end, 'd MMM yyyy', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>
            </View>
            {}
            <View style={styles.modalActions}>
              <Button
                mode="outlined"
                onPress={() => setShowDateRangePicker(false)}
                style={styles.modalButton}
                labelStyle={styles.modalButtonLabel}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={() => {
                  setDateFilter('custom');
                  setShowDateRangePicker(false);
                }}
                style={[styles.modalButton, styles.modalButtonPrimary]}
                labelStyle={styles.modalButtonLabel}
              >
                Aplicar filtro
              </Button>
            </View>
          </View>
        </View>
      </Modal>
      {showDatePicker && (
        <DateTimePicker
          value={
            datePickerMode === 'start'
              ? customDateRange.start
              : customDateRange.end
          }
          mode="date"
          display="default"
          onChange={handleDateChange}
          maximumDate={new Date()}
        />
      )}
    </Surface>
  );
  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Avatar.Icon
        icon="history"
        size={80}
        style={{ backgroundColor: theme.colors.surfaceVariant }}
        color={theme.colors.onSurfaceVariant}
      />
      <Text style={styles.emptyTitle}>No se encontraron turnos</Text>
      <Text style={styles.emptyMessage}>
        {dateFilter === 'custom'
          ? 'No hay turnos en el rango seleccionado'
          : 'Prueba seleccionando otro rango de fechas'}
      </Text>
    </View>
  );
  const renderError = () => (
    <View style={styles.errorContainer}>
      <Avatar.Icon
        icon="alert-circle-outline"
        size={80}
        style={{ backgroundColor: theme.colors.errorContainer }}
        color={theme.colors.error}
      />
      <Text style={styles.errorTitle}>Error al cargar turnos</Text>
      <Text style={styles.errorMessage}>
        {error?.message || 'No se pudieron cargar los turnos'}
      </Text>
      <Button mode="contained" onPress={refetch} style={styles.retryButton}>
        Reintentar
      </Button>
    </View>
  );
  const renderLoading = () => (
    <View style={styles.loadingContainer}>
      <ActivityIndicator size="large" />
      <Text style={styles.loadingText}>Cargando turnos...</Text>
    </View>
  );
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    filterContainer: {
      backgroundColor: theme.colors.surface,
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      elevation: 1,
    },
    filterContent: {
      padding: theme.spacing.s,
    },
    filterButton: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
    },
    filterIcon: {
      backgroundColor: theme.colors.primaryContainer,
      marginRight: theme.spacing.m,
    },
    filterTextContainer: {
      flex: 1,
    },
    filterLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    filterValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    filterArrow: {
      backgroundColor: 'transparent',
    },
    menuContent: {
      backgroundColor: theme.colors.surface,
      marginTop: 40,
      minWidth: 200,
    },
    selectedMenuItem: {
      backgroundColor: theme.colors.primaryContainer,
    },
    modalOverlay: {
      flex: 1,
      backgroundColor: 'rgba(0, 0, 0, 0.4)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    modalContent: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 4,
      marginHorizontal: theme.spacing.xl,
      width: '90%',
      maxWidth: 380,
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 12,
      borderWidth: 2,
      borderColor: theme.colors.outline,
    },
    modalHeader: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.m,
      position: 'relative',
    },
    modalIcon: {
      backgroundColor: theme.colors.primaryContainer,
      marginBottom: theme.spacing.m,
    },
    modalTitle: {
      fontSize: 22,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
    },
    modalCloseButton: {
      position: 'absolute',
      top: theme.spacing.s,
      right: theme.spacing.s,
    },
    dateRangeContainer: {
      paddingHorizontal: theme.spacing.l,
      paddingVertical: theme.spacing.l,
      flexDirection: 'column',
      gap: theme.spacing.m,
    },
    dateButton: {
      backgroundColor: theme.colors.background,
      borderRadius: theme.roundness * 2,
      borderWidth: 1.5,
      borderColor: theme.colors.outline,
      overflow: 'hidden',
      elevation: 1,
    },
    dateButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.m,
      gap: theme.spacing.m,
    },
    dateButtonIcon: {
      backgroundColor: theme.colors.primaryContainer,
    },
    dateButtonTextContainer: {
      flex: 1,
    },
    dateButtonLabel: {
      fontSize: 10,
      fontWeight: '700',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 1,
      marginBottom: 2,
    },
    dateButtonValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    dateArrowContainer: {
      alignSelf: 'center',
      paddingVertical: theme.spacing.xs,
    },
    dateArrow: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    modalActions: {
      flexDirection: 'row',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.m,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    modalButton: {
      flex: 1,
      borderRadius: theme.roundness * 2,
    },
    modalButtonPrimary: {
      elevation: 0,
    },
    modalButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
      paddingVertical: 4,
    },
    listContent: {
      paddingBottom: theme.spacing.m,
    },
    shiftCard: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.surface,
    },
    openShiftCard: {
      backgroundColor: theme.colors.primaryContainer,
    },
    shiftHeader: {
      marginBottom: theme.spacing.s,
    },
    shiftTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      marginBottom: 2,
    },
    shiftNumber: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    shiftDate: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    statusChip: {
      marginLeft: 'auto',
    },
    statusChipText: {
      fontWeight: '600',
      fontSize: 11,
    },
    divider: {
      marginVertical: theme.spacing.s,
    },
    shiftDetails: {
      gap: theme.spacing.s,
    },
    timeSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    label: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
      textTransform: 'uppercase',
    },
    timeText: {
      fontSize: 14,
      color: theme.colors.onSurface,
    },
    durationText: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    statsSection: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    statCard: {
      flex: 1,
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
      gap: 2,
    },
    statLabel: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      textTransform: 'uppercase',
      letterSpacing: 0.3,
    },
    statValue: {
      fontSize: 15,
      fontWeight: '700',
      color: theme.colors.onSurface,
    },
    cashSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    cashRow: {
      alignItems: 'center',
    },
    cashLabel: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
    },
    cashValue: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginTop: 2,
    },
    differenceLabel: {
      fontWeight: '600',
    },
    differenceValue: {
      fontWeight: '700',
    },
    userSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginTop: theme.spacing.xs,
    },
    userText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    actionButtonsContainer: {
      flexDirection: 'row',
      marginTop: theme.spacing.s,
      gap: theme.spacing.s,
    },
    actionButton: {
      flex: 1,
      borderRadius: theme.roundness,
    },
    ordersButton: {
    },
    summaryButton: {
    },
    actionButtonLabel: {
      fontSize: 12,
      fontWeight: '600',
    },
    actionButtonContent: {
      paddingHorizontal: theme.spacing.xs,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
      gap: theme.spacing.l,
    },
    emptyTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
    },
    emptyMessage: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
      gap: theme.spacing.l,
    },
    errorTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.error,
      textAlign: 'center',
    },
    errorMessage: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    retryButton: {
      marginTop: theme.spacing.m,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    loadingText: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
    },
  });
  if ((isLoading || isRefetching) && !shifts) {
    return (
      <SafeAreaView style={styles.container} edges={['bottom']}>
        {renderLoading()}
      </SafeAreaView>
    );
  }
  if (error && !shifts) {
    return (
      <SafeAreaView style={styles.container} edges={['bottom']}>
        {renderError()}
      </SafeAreaView>
    );
  }
  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        {}
        {renderFilters()}
        {}
        {filteredShifts.length === 0 ? (
          renderEmpty()
        ) : (
          <FlashList
            data={filteredShifts}
            renderItem={renderShiftItem}
            keyExtractor={(item) => item.id}
            estimatedItemSize={200}
            contentContainerStyle={styles.listContent}
            refreshControl={
              <RefreshControl
                refreshing={isRefreshing}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
          />
        )}
        {}
        {selectedShiftId && !showSalesSummaryView && (
          <ShiftOrdersModal
            visible={showOrdersModal}
            onClose={() => {
              setShowOrdersModal(false);
              setSelectedShiftId(null);
              setSelectedShiftNumber(undefined);
            }}
            shiftId={selectedShiftId}
          />
        )}
        {}
        {showSalesSummaryView && selectedShiftId && (
          <Modal
            visible={showSalesSummaryView}
            animationType="slide"
            presentationStyle="fullScreen"
          >
            <ShiftSalesSummaryView
              shiftId={selectedShiftId}
              shiftNumber={selectedShiftNumber}
              onBack={() => {
                setShowSalesSummaryView(false);
                setSelectedShiftId(null);
                setSelectedShiftNumber(undefined);
              }}
            />
          </Modal>
        )}
      </View>
    </SafeAreaView>
  );
}

================
File: app/src/modules/users/components/UserFormModal.tsx
================
import React, { useEffect, useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useCreateUser, useUpdateUser } from '../hooks';
import type { User } from '../types';
const createUserSchema = z.object({
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .max(20, 'El nombre de usuario no puede exceder 20 caracteres')
    .regex(/^[a-zA-Z0-9_]+$/, 'Solo se permiten letras, números y guión bajo'),
  email: z
    .union([z.string().email('Email inválido'), z.literal('')])
    .optional(),
  password: z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
  firstName: z
    .string()
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres'),
  lastName: z
    .string()
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(50, 'El apellido no puede exceder 50 caracteres'),
  phoneNumber: z
    .union([
      z.string().regex(/^\+?[0-9\s-]+$/, 'Número de teléfono inválido'),
      z.literal(''),
    ])
    .optional(),
  gender: z.enum(['male', 'female', 'other']).nullable().optional(),
  address: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  country: z.string().optional(),
  zipCode: z.string().optional(),
  role: z.number(),
  isActive: z.boolean(),
});
const updateUserSchema = createUserSchema.omit({ password: true }).extend({
  password: z
    .union([
      z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
      z.literal(''),
    ])
    .optional(),
});
type CreateUserFormInputs = z.infer<typeof createUserSchema>;
type UpdateUserFormInputs = z.infer<typeof updateUserSchema>;
type UserFormInputs = CreateUserFormInputs | UpdateUserFormInputs;
interface UserFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  user?: User | null;
}
export function UserFormModal({
  visible,
  onDismiss,
  user,
}: UserFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showPassword, setShowPassword] = useState(false);
  const createUserMutation = useCreateUser();
  const updateUserMutation = useUpdateUser();
  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<UserFormInputs>({
    resolver: zodResolver(user ? updateUserSchema : createUserSchema) as any,
    defaultValues: {
      username: '',
      email: '',
      password: '',
      firstName: '',
      lastName: '',
      phoneNumber: '',
      gender: undefined,
      address: '',
      city: '',
      state: '',
      country: '',
      zipCode: '',
      role: 2, // Default to MANAGER role
      isActive: true,
    },
  });
  useEffect(() => {
    if (user) {
      reset({
        username: user.username,
        email: user.email || '',
        password: '', // Never pre-fill password
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        phoneNumber: user.phoneNumber || '',
        gender: user.gender || undefined, // Convert null to undefined
        address: user.address || '',
        city: user.city || '',
        state: user.state || '',
        country: user.country || '',
        zipCode: user.zipCode || '',
        role: user.role?.id || 2,
        isActive: user.isActive,
      });
    } else {
      reset({
        username: '',
        email: '',
        password: '',
        firstName: '',
        lastName: '',
        phoneNumber: '',
        gender: undefined,
        address: '',
        city: '',
        state: '',
        country: '',
        zipCode: '',
        role: 2,
        isActive: true,
      });
    }
  }, [user, reset]);
  const onSubmit = async (data: UserFormInputs) => {
    try {
      // Clean empty strings to undefined
      const cleanData = {
        username: data.username,
        email: data.email || undefined,
        password: data.password || undefined,
        firstName: data.firstName,
        lastName: data.lastName,
        phoneNumber: data.phoneNumber || undefined,
        gender: data.gender || undefined,
        address: data.address || undefined,
        city: data.city || undefined,
        state: data.state || undefined,
        country: data.country || undefined,
        zipCode: data.zipCode || undefined,
        role: { id: data.role },
        isActive: data.isActive,
      };
      if (user) {
        // For update, remove password if empty and remove username (can't be changed)
        const { username, password, ...updateData } = cleanData;
        const finalUpdateData = password
          ? { ...updateData, password }
          : updateData;
        await updateUserMutation.mutateAsync({
          id: user.id,
          data: finalUpdateData as any,
        });
      } else {
        if (!data.password) {
          return;
        }
        await createUserMutation.mutateAsync(cleanData as any);
      }
      onDismiss();
    } catch (error) {
    }
  };
  const isSubmitting =
    createUserMutation.isPending || updateUserMutation.isPending;
  const genderOptions = [
    {
      value: 'male',
      label: 'Masculino',
      icon: 'gender-male',
      color: '#3498db',
    },
    {
      value: 'female',
      label: 'Femenino',
      icon: 'gender-female',
      color: '#e74c3c',
    },
    {
      value: 'other',
      label: 'Otro',
      icon: 'gender-transgender',
      color: '#9b59b6',
    },
  ];
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.modalContent} elevation={5}>
          <View
            style={[
              styles.headerContainer,
              { backgroundColor: theme.colors.primary },
            ]}
          >
            <View style={styles.headerLeft}>
              <Avatar.Icon
                size={32}
                icon={user ? 'account-edit' : 'account-plus'}
                style={[
                  styles.headerIcon,
                  { backgroundColor: theme.colors.onPrimary + '20' },
                ]}
                color={theme.colors.onPrimary}
              />
              <View style={styles.headerTextContainer}>
                <Text
                  style={[styles.modalTitle, { color: theme.colors.onPrimary }]}
                  variant="titleMedium"
                >
                  {user ? 'Editar Usuario' : 'Nuevo Usuario'}
                </Text>
              </View>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={onDismiss}
              disabled={isSubmitting}
              iconColor={theme.colors.onPrimary}
            />
          </View>
          <ScrollView
            style={styles.formContainer}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            {}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-key"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información de Cuenta
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>
              <Controller
                control={control}
                name="username"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre de usuario"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.username}
                      mode="outlined"
                      placeholder="usuario123"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                      disabled={!!user}
                    />
                    {errors.username && (
                      <HelperText type="error" visible={!!errors.username}>
                        {errors.username.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="email"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Email (opcional)"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.email}
                      mode="outlined"
                      placeholder="usuario@ejemplo.com"
                      keyboardType="email-address"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="email" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.email && (
                      <HelperText type="error" visible={!!errors.email}>
                        {errors.email.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="password"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label={
                        user
                          ? 'Nueva contraseña (dejar vacío para no cambiar)'
                          : 'Contraseña'
                      }
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.password}
                      mode="outlined"
                      placeholder="••••••"
                      secureTextEntry={!showPassword}
                      left={<TextInput.Icon icon="lock" />}
                      right={
                        <TextInput.Icon
                          icon={showPassword ? 'eye-off' : 'eye'}
                          onPress={() => setShowPassword(!showPassword)}
                        />
                      }
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.password && (
                      <HelperText type="error" visible={!!errors.password}>
                        {errors.password.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="role"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="badge-account"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Rol del usuario
                      </Text>
                    </View>
                    <ScrollView
                      horizontal
                      showsHorizontalScrollIndicator={false}
                      style={{ marginTop: theme.spacing.s }}
                    >
                      <View style={styles.rolesContainer}>
                        {[
                          {
                            value: 1,
                            label: 'Admin',
                            icon: 'shield-account',
                            description: 'Acceso completo',
                          },
                          {
                            value: 2,
                            label: 'Gerente',
                            icon: 'account-tie',
                            description: 'Gestión general',
                          },
                          {
                            value: 3,
                            label: 'Cajero',
                            icon: 'cash-register',
                            description: 'Ventas',
                          },
                          {
                            value: 4,
                            label: 'Mesero',
                            icon: 'room-service',
                            description: 'Órdenes',
                          },
                          {
                            value: 5,
                            label: 'Cocina',
                            icon: 'chef-hat',
                            description: 'Preparación',
                          },
                          {
                            value: 6,
                            label: 'Repartidor',
                            icon: 'moped',
                            description: 'Entregas',
                          },
                        ].map((role) => (
                          <Surface
                            key={role.value}
                            style={[
                              styles.roleCard,
                              value === role.value && styles.roleCardActive,
                            ]}
                            elevation={value === role.value ? 2 : 0}
                          >
                            <TouchableOpacity
                              onPress={() => onChange(role.value)}
                              style={styles.roleCardContent}
                            >
                              <Icon
                                source={role.icon}
                                size={24}
                                color={
                                  value === role.value
                                    ? theme.colors.primary
                                    : theme.colors.onSurfaceVariant
                                }
                              />
                              <Text
                                style={[
                                  styles.roleLabel,
                                  value === role.value &&
                                    styles.roleLabelActive,
                                ]}
                                variant="labelMedium"
                              >
                                {role.label}
                              </Text>
                              <Text
                                style={styles.roleDescription}
                                variant="bodySmall"
                                numberOfLines={1}
                              >
                                {role.description}
                              </Text>
                            </TouchableOpacity>
                          </Surface>
                        ))}
                      </View>
                    </ScrollView>
                  </View>
                )}
              />
            </View>
            <Divider style={styles.divider} />
            {}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-circle"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información Personal
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>
              <Controller
                control={control}
                name="firstName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.firstName}
                      mode="outlined"
                      placeholder="Juan"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.firstName && (
                      <HelperText type="error" visible={!!errors.firstName}>
                        {errors.firstName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="lastName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Apellido"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.lastName}
                      mode="outlined"
                      placeholder="Pérez"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.lastName && (
                      <HelperText type="error" visible={!!errors.lastName}>
                        {errors.lastName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="gender"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="gender-transgender"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Género
                      </Text>
                    </View>
                    <View
                      style={[
                        styles.genderContainer,
                        { marginTop: theme.spacing.s },
                      ]}
                    >
                      {genderOptions.map((option) => (
                        <TouchableOpacity
                          key={option.value}
                          onPress={() => onChange(option.value)}
                          activeOpacity={0.7}
                        >
                          <Surface
                            style={[
                              styles.genderOption,
                              value === option.value &&
                                styles.genderOptionActive,
                            ]}
                            elevation={value === option.value ? 3 : 1}
                          >
                            <View
                              style={[
                                styles.genderIconContainer,
                                value === option.value && {
                                  backgroundColor: option.color + '20',
                                },
                              ]}
                            >
                              <Icon
                                source={option.icon}
                                size={20}
                                color={
                                  value === option.value
                                    ? option.color
                                    : theme.colors.onSurfaceVariant
                                }
                              />
                            </View>
                            <Text
                              style={[
                                styles.genderLabel,
                                value === option.value &&
                                  styles.genderLabelActive,
                              ]}
                              variant="labelMedium"
                            >
                              {option.label}
                            </Text>
                          </Surface>
                        </TouchableOpacity>
                      ))}
                    </View>
                  </View>
                )}
              />
            </View>
            <Divider style={styles.divider} />
            {}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="phone-in-talk"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Información de Contacto
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="information"
                  style={styles.optionalChip}
                  textStyle={styles.optionalChipText}
                >
                  Opcional
                </Chip>
              </View>
              <Controller
                control={control}
                name="phoneNumber"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Teléfono"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.phoneNumber}
                      mode="outlined"
                      placeholder="+52 55 1234 5678"
                      keyboardType="phone-pad"
                      left={<TextInput.Icon icon="phone" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.phoneNumber && (
                      <HelperText type="error" visible={!!errors.phoneNumber}>
                        {errors.phoneNumber.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
              <Controller
                control={control}
                name="address"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Dirección"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      mode="outlined"
                      placeholder="Calle Principal #123"
                      left={<TextInput.Icon icon="map-marker" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                  </View>
                )}
              />
              <View style={styles.rowContainer}>
                <Controller
                  control={control}
                  name="city"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Ciudad"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Ciudad"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
                <Controller
                  control={control}
                  name="state"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Estado"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Estado"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
              </View>
              <View style={styles.rowContainer}>
                <Controller
                  control={control}
                  name="country"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="País"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="México"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
                <Controller
                  control={control}
                  name="zipCode"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Código Postal"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="12345"
                        keyboardType="number-pad"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
              </View>
            </View>
            <Divider style={styles.divider} />
            {}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="shield-check"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Estado de la cuenta
                </Text>
              </View>
              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <Surface style={styles.switchContainer} elevation={1}>
                    <View style={styles.switchContent}>
                      <View style={styles.switchTextContainer}>
                        <Text style={styles.switchLabel} variant="bodyLarge">
                          Usuario activo
                        </Text>
                        <Text
                          style={styles.switchDescription}
                          variant="bodySmall"
                        >
                          Los usuarios inactivos no pueden iniciar sesión
                        </Text>
                      </View>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                )}
              />
            </View>
            {}
            <View style={{ height: 10 }} />
          </ScrollView>
          <Surface style={styles.buttonContainer} elevation={2}>
            <Button
              onPress={onDismiss}
              disabled={isSubmitting}
              style={[styles.button, styles.cancelButton]}
              textColor={theme.colors.onSecondaryContainer}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit as any)}
              disabled={isSubmitting}
              loading={isSubmitting}
              style={[styles.button, styles.confirmButton]}
              buttonColor={theme.colors.primary}
            >
              {user ? 'Guardar' : 'Crear'}
            </Button>
          </Surface>
        </Surface>
      </Modal>
    </Portal>
  );
}
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? theme.spacing.xl : theme.spacing.m,
      maxWidth: responsive.isTablet ? 700 : 420,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '92%',
      paddingHorizontal: 0,
      height: responsive.isTablet ? '85%' : '80%',
      maxHeight: responsive.isTablet ? '90%' : '85%',
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      height: '100%',
      flex: 1,
      overflow: 'hidden',
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingVertical: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.s,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
      gap: theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 14,
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.primary + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '40',
    },
    requiredChipText: {
      color: theme.colors.primary,
      fontSize: 11,
      fontWeight: '600',
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    inputContainer: {
      marginBottom: theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
    },
    input: {
      fontSize: 14,
      backgroundColor: theme.colors.surface,
      height: 48,
    },
    inputContent: {
      paddingVertical: 4,
      fontSize: 14,
      fontFamily: 'System',
    },
    fieldLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.xs,
      fontWeight: '600',
      fontSize: 12,
      letterSpacing: 0.4,
      textTransform: 'uppercase',
      fontFamily: 'System',
    },
    fieldLabelContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    segmentedButtons: {
      marginTop: theme.spacing.xs,
    },
    genderContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      flexWrap: 'wrap',
    },
    genderOption: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
      minWidth: 85,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
    },
    genderOptionActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    genderIconContainer: {
      width: 36,
      height: 36,
      borderRadius: 18,
      alignItems: 'center',
      justifyContent: 'center',
      marginBottom: theme.spacing.xs,
    },
    genderLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
      textAlign: 'center',
    },
    genderLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '600',
    },
    rowContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    halfInput: {
      flex: 1,
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '30',
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    divider: {
      marginVertical: theme.spacing.s,
      marginHorizontal: -theme.spacing.m,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.s,
    },
    button: {
      flex: 1,
      maxWidth: responsive.isTablet ? 180 : 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    rolesContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      paddingVertical: theme.spacing.xs,
    },
    roleCard: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      marginRight: theme.spacing.xs,
      minWidth: 90,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
      elevation: 1,
    },
    roleCardActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
      elevation: 3,
    },
    roleCardContent: {
      alignItems: 'center',
    },
    roleLabel: {
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      fontWeight: '500',
    },
    roleLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '700',
    },
    roleDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: 10,
      textAlign: 'center',
    },
  });

================
File: app/src/services/healthMonitoringService.ts
================
import axios from 'axios';
import { discoveryService } from '@/app/services/discoveryService';
import EventEmitter from 'eventemitter3';
import { NETWORK_CONFIG } from '@/app/constants/network';
import { API_PATHS } from '@/app/constants/apiPaths';
export type HealthStatus = 'ok' | 'error' | 'checking';
export interface HealthState {
  status: HealthStatus;
  isAvailable: boolean;
  message?: string;
}
class HealthMonitoringService extends EventEmitter {
  private state: HealthState = {
    status: 'checking',
    isAvailable: false,
  };
  private checkInterval: NodeJS.Timeout | null = null;
  private retryTimeout: NodeJS.Timeout | null = null;
  private isChecking = false;
  private retryCount = 0;
  constructor() {
    super();
  }
  getState(): HealthState {
    return { ...this.state };
  }
  isMonitoring(): boolean {
    return this.checkInterval !== null;
  }
  startMonitoring() {
    this.stopMonitoring();
    this.retryCount = 0;
    this.checkHealth();
    this.checkInterval = setInterval(() => {
      this.checkHealth();
    }, NETWORK_CONFIG.HEALTH_CHECK_INTERVAL);
  }
  stopMonitoring() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    if (this.retryTimeout) {
      clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }
  async checkHealth(): Promise<boolean> {
    if (this.isChecking) {
      return this.state.isAvailable;
    }
    this.isChecking = true;
    try {
      let apiUrl: string;
      try {
        const lastKnownUrl = await discoveryService.getLastKnownUrl();
        if (!lastKnownUrl) {
          throw new Error('No hay servidor configurado');
        }
        apiUrl = lastKnownUrl;
      } catch (error) {
        this.updateState({
          status: 'error',
          isAvailable: false,
          message: 'Servidor no configurado',
        });
        this.isChecking = false;
        return false;
      }
      const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
      const healthUrl = `${baseUrl}${API_PATHS.HEALTH}`;
      const response = await axios.get(healthUrl, {
        timeout: NETWORK_CONFIG.HEALTH_CHECK_TIMEOUT,
      });
      if (response.data.status === 'ok') {
        const wasUnavailable = !this.state.isAvailable;
        this.updateState({
          status: 'ok',
          isAvailable: true,
          message: 'Conectado al servidor',
        });
        if (wasUnavailable) {
          setTimeout(() => {
            this.emit('recovered');
          }, 100);
        }
        this.retryCount = 0;
        if (this.retryTimeout) {
          clearTimeout(this.retryTimeout);
          this.retryTimeout = null;
        }
        this.isChecking = false;
        return true;
      } else {
        throw new Error('Backend returned unhealthy status');
      }
    } catch (error: any) {
      const isTemporaryError = this.isTemporaryError(error);
      this.updateState({
        status: 'error',
        isAvailable: false,
        message: this.getErrorMessage(error),
      });
      if (isTemporaryError && this.retryCount < 3) {
        this.scheduleRetry();
      }
      this.isChecking = false;
      return false;
    }
  }
  private scheduleRetry() {
    if (this.retryTimeout) {
      clearTimeout(this.retryTimeout);
    }
    const retryInterval =
      NETWORK_CONFIG.HEALTH_RETRY_INTERVALS[
        Math.min(
          this.retryCount,
          NETWORK_CONFIG.HEALTH_RETRY_INTERVALS.length - 1,
        )
      ];
    this.retryTimeout = setTimeout(() => {
      this.retryCount++;
      this.checkHealth();
    }, retryInterval);
  }
  private updateState(newState: HealthState) {
    this.state = newState;
    this.emit('stateChange', this.state);
  }
  private isTemporaryError(error: any): boolean {
    return (
      error.code === 'ECONNABORTED' ||
      error.code === 'ETIMEDOUT' ||
      error.message?.includes('timeout') ||
      error.code === 'ECONNRESET'
    );
  }
  private getErrorMessage(error: any): string {
    if (error.code === 'ECONNABORTED' || error.message?.includes('timeout')) {
      return 'Tiempo de espera agotado';
    }
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      return 'No se puede conectar al servidor';
    }
    if (error.message?.includes('No API URL')) {
      return 'Servidor no encontrado';
    }
    if (error.message?.includes('Servidor no configurado')) {
      return 'Servidor no configurado';
    }
    return 'Error de conexión';
  }
  subscribe(callback: (state: HealthState) => void): () => void {
    this.on('stateChange', callback);
    callback(this.state);
    return () => {
      this.off('stateChange', callback);
    };
  }
  async checkHealthWithUrl(apiUrl: string): Promise<boolean> {
    try {
      const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
      const healthUrl = `${baseUrl}${API_PATHS.HEALTH}`;
      const response = await axios.get(healthUrl, {
        timeout: NETWORK_CONFIG.HEALTH_CHECK_TIMEOUT,
      });
      return response.data.status === 'ok';
    } catch (error) {
      return false;
    }
  }
  async forceCheck(): Promise<boolean> {
    this.retryCount = 0;
    const result = await this.checkHealth();
    this.emit('stateChange', this.state);
    return result;
  }
}
export const healthMonitoringService = new HealthMonitoringService();

================
File: backend/src/orders/dto/order-for-finalization.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { OrderType } from '../domain/enums/order-type.enum';
import { OrderStatus } from '../domain/enums/order-status.enum';
export class OrderItemModifierForFinalizationDto {
  @ApiProperty({ description: 'ID del modificador' })
  id: string;
  @ApiProperty({ description: 'Nombre del modificador' })
  name: string;
  @ApiProperty({ description: 'Precio del modificador' })
  price: number;
}
export class OrderItemForFinalizationDto {
  @ApiProperty({ description: 'ID del producto' })
  productId: string;
  @ApiProperty({ description: 'ID de la variante (si aplica)' })
  productVariantId?: string;
  @ApiProperty({ description: 'Cantidad de este item' })
  quantity: number;
  @ApiProperty({ description: 'Precio base unitario' })
  basePrice: number;
  @ApiProperty({ description: 'Precio final unitario (incluye modificadores)' })
  finalPrice: number;
  @ApiProperty({ description: 'Notas de preparación', required: false })
  preparationNotes?: string;
  @ApiProperty({
    description: 'Estado de preparación',
    enum: ['PENDING', 'IN_PROGRESS', 'READY', 'DELIVERED', 'CANCELLED'],
  })
  preparationStatus: string;
  @ApiProperty({ description: 'Información del producto' })
  product: {
    id: string;
    name: string;
    description?: string;
  };
  @ApiProperty({ description: 'Información de la variante', required: false })
  productVariant?: {
    id: string;
    name: string;
  };
  @ApiProperty({
    description: 'Modificadores aplicados',
    type: [OrderItemModifierForFinalizationDto],
  })
  modifiers: OrderItemModifierForFinalizationDto[];
  @ApiProperty({
    description: 'Personalizaciones de pizza seleccionadas',
    required: false,
  })
  selectedPizzaCustomizations?: any[];
}
export class OrderForFinalizationDto {
  @ApiProperty({ description: 'ID de la orden' })
  id: string;
  @ApiProperty({ description: 'Número de orden en el turno' })
  shiftOrderNumber: number;
  @ApiProperty({
    description: 'Tipo de orden',
    enum: OrderType,
  })
  orderType: OrderType;
  @ApiProperty({
    description: 'Estado de la orden',
    enum: OrderStatus,
  })
  orderStatus: OrderStatus;
  @ApiProperty({ description: 'Total de la orden' })
  total: number;
  @ApiProperty({
    description: 'Items de la orden agrupados por igualdad',
    type: [OrderItemForFinalizationDto],
  })
  orderItems: OrderItemForFinalizationDto[];
  @ApiProperty({ description: 'Fecha de creación' })
  createdAt: Date;
  @ApiProperty({ description: 'Fecha de actualización' })
  updatedAt: Date;
  @ApiProperty({ description: 'Fecha de finalización', required: false })
  finalizedAt?: Date;
  @ApiProperty({
    description: 'Fecha y hora de entrega programada',
    required: false,
  })
  scheduledAt?: Date;
  @ApiProperty({ description: 'ID de la mesa', required: false })
  tableId?: string;
  @ApiProperty({ description: 'Información del usuario', required: false })
  user?: {
    id: string;
    firstName?: string;
    lastName?: string;
  };
  @ApiProperty({ description: 'Información de la mesa', required: false })
  table?: {
    id: string;
    number: string;
    area?: {
      name: string;
    };
  };
  @ApiProperty({ description: 'Información de entrega', required: false })
  deliveryInfo?: any;
  @ApiProperty({
    description: 'Indica si la orden viene de WhatsApp',
    required: false,
  })
  isFromWhatsApp?: boolean;
  @ApiProperty({
    description:
      'Pantallas de preparación únicas de todos los items de la orden',
    required: false,
    type: [String],
  })
  preparationScreens?: string[];
  @ApiProperty({
    description: 'Pagos asociados a la orden',
    required: false,
  })
  payments?: any[];
  @ApiProperty({
    description: 'Estados de las pantallas de preparación para la orden',
    required: false,
  })
  preparationScreenStatuses?: {
    id: string;
    preparationScreenId: string;
    preparationScreenName: string;
    status: string;
    startedAt?: Date | null;
    completedAt?: Date | null;
  }[];
  @ApiProperty({
    description: 'Historial de impresiones de tickets para la orden',
    required: false,
  })
  ticketImpressions?: {
    id: string;
    ticketType: string;
    impressionTime: Date;
    user?: {
      id: string;
      firstName?: string;
      lastName?: string;
    };
    printer?: {
      id: string;
      name: string;
    };
  }[];
}

================
File: backend/src/orders/dto/order-open-list.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { OrderStatus } from '../domain/enums/order-status.enum';
import { OrderType } from '../domain/enums/order-type.enum';
import { Expose, Type } from 'class-transformer';
class PaymentsSummaryDto {
  @ApiProperty()
  @Expose()
  totalPaid: number;
}
class TableSummaryDto {
  @ApiProperty()
  @Expose()
  id: string;
  @ApiProperty()
  @Expose()
  number: string;
  @ApiProperty()
  @Expose()
  name: string;
  @ApiProperty()
  @Expose()
  isTemporary: boolean;
  @ApiProperty({ required: false })
  @Expose()
  area?: {
    name: string;
  };
}
class DeliveryInfoSummaryDto {
  @ApiProperty({ required: false })
  @Expose()
  recipientName?: string;
  @ApiProperty({ required: false })
  @Expose()
  recipientPhone?: string;
  @ApiProperty({ required: false })
  @Expose()
  fullAddress?: string;
}
export class OrderOpenListDto {
  @ApiProperty()
  @Expose()
  id: string;
  @ApiProperty()
  @Expose()
  shiftOrderNumber: number;
  @ApiProperty({ enum: OrderType })
  @Expose()
  orderType: OrderType;
  @ApiProperty({ enum: OrderStatus })
  @Expose()
  orderStatus: OrderStatus;
  @ApiProperty()
  @Expose()
  total: number;
  @ApiProperty()
  @Expose()
  createdAt: Date;
  @ApiProperty({ required: false })
  @Expose()
  scheduledAt?: Date;
  @ApiProperty({ required: false })
  @Expose()
  notes?: string;
  @ApiProperty({ type: PaymentsSummaryDto, required: false })
  @Type(() => PaymentsSummaryDto)
  @Expose()
  paymentsSummary?: PaymentsSummaryDto;
  @ApiProperty({ type: TableSummaryDto, required: false })
  @Type(() => TableSummaryDto)
  @Expose()
  table?: TableSummaryDto;
  @ApiProperty({ type: DeliveryInfoSummaryDto, required: false })
  @Type(() => DeliveryInfoSummaryDto)
  @Expose()
  deliveryInfo?: DeliveryInfoSummaryDto;
  @ApiProperty({ type: [String], required: false })
  @Expose()
  preparationScreens?: string[];
  @ApiProperty({
    type: 'array',
    items: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        status: { type: 'string', enum: ['PENDING', 'IN_PROGRESS', 'READY'] },
      },
    },
    required: false,
  })
  @Expose()
  preparationScreenStatuses?: Array<{ name: string; status: string }>;
  @ApiProperty({ required: false })
  @Expose()
  ticketImpressionCount?: number;
  @ApiProperty({
    required: false,
    description: 'Indica si la orden proviene de WhatsApp',
    example: true,
  })
  @Expose()
  isFromWhatsApp?: boolean;
  @ApiProperty({
    required: false,
    description: 'Usuario que creó la orden',
    example: {
      username: 'john.doe',
      firstName: 'John',
      lastName: 'Doe',
    },
  })
  @Expose()
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
}

================
File: backend/src/orders/dto/receipt-list.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { OrderType } from '../domain/enums/order-type.enum';
import { OrderStatus } from '../domain/enums/order-status.enum';
import { Expose, Type } from 'class-transformer';
class PaymentsSummaryDto {
  @ApiProperty()
  @Expose()
  totalPaid: number;
}
class TableSummaryDto {
  @ApiProperty()
  @Expose()
  id: string;
  @ApiProperty()
  @Expose()
  number: string;
  @ApiProperty()
  @Expose()
  name: string;
  @ApiProperty()
  @Expose()
  isTemporary: boolean;
  @ApiProperty({ required: false })
  @Expose()
  area?: {
    name: string;
  };
}
class DeliveryInfoSummaryDto {
  @ApiProperty({ required: false })
  @Expose()
  recipientName?: string;
  @ApiProperty({ required: false })
  @Expose()
  recipientPhone?: string;
  @ApiProperty({ required: false })
  @Expose()
  fullAddress?: string;
}
export class ReceiptListDto {
  @ApiProperty()
  @Expose()
  id: string;
  @ApiProperty()
  @Expose()
  shiftOrderNumber: number;
  @ApiProperty({ enum: OrderType })
  @Expose()
  orderType: OrderType;
  @ApiProperty({ enum: OrderStatus })
  @Expose()
  orderStatus: OrderStatus;
  @ApiProperty()
  @Expose()
  total: number;
  @ApiProperty()
  @Expose()
  createdAt: Date;
  @ApiProperty({ required: false })
  @Expose()
  scheduledAt?: Date;
  @ApiProperty()
  @Expose()
  finalizedAt: Date;
  @ApiProperty({ required: false })
  @Expose()
  notes?: string;
  @ApiProperty({ type: PaymentsSummaryDto, required: false })
  @Type(() => PaymentsSummaryDto)
  @Expose()
  paymentsSummary?: PaymentsSummaryDto;
  @ApiProperty({ type: TableSummaryDto, required: false })
  @Type(() => TableSummaryDto)
  @Expose()
  table?: TableSummaryDto;
  @ApiProperty({ type: DeliveryInfoSummaryDto, required: false })
  @Type(() => DeliveryInfoSummaryDto)
  @Expose()
  deliveryInfo?: DeliveryInfoSummaryDto;
  @ApiProperty({
    type: 'array',
    items: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        status: { type: 'string', enum: ['PENDING', 'IN_PROGRESS', 'READY'] },
      },
    },
    required: false,
    description: 'Estados de las pantallas de preparación',
  })
  @Expose()
  preparationScreenStatuses?: Array<{ name: string; status: string }>;
  @ApiProperty({
    description: 'Cantidad de tickets impresos para esta orden',
    required: false,
  })
  @Expose()
  ticketImpressionCount?: number;
  @ApiProperty({
    required: false,
    description: 'Usuario que creó la orden',
    example: {
      username: 'john.doe',
      firstName: 'John',
      lastName: 'Doe',
    },
  })
  @Expose()
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
  @ApiProperty({
    required: false,
    description: 'Indica si la orden proviene de WhatsApp',
    example: true,
  })
  @Expose()
  isFromWhatsApp?: boolean;
}

================
File: backend/src/orders/infrastructure/persistence/order.repository.ts
================
import { DeepPartial } from '../../../utils/types/deep-partial.type';
import { NullableType } from '../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../utils/types/pagination-options';
import { Order } from '../../domain/order';
import { FindAllOrdersDto } from '../../dto/find-all-orders.dto';
import { DeliveryInfo } from '../../domain/delivery-info';
export abstract class OrderRepository {
  abstract create(data: {
    userId: string | null;
    tableId: string | null;
    shiftId?: string | null;
    scheduledAt?: Date | null;
    orderStatus: string;
    orderType: string;
    subtotal: number;
    total: number;
    notes?: string;
    customerId?: string | null;
    isFromWhatsApp?: boolean;
    deliveryInfo: DeliveryInfo | null;
    estimatedDeliveryTime?: Date | null;
  }): Promise<Order>;
  abstract findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: FindAllOrdersDto | null;
    paginationOptions: IPaginationOptions;
  }): Promise<[Order[], number]>;
  abstract findById(id: Order['id']): Promise<NullableType<Order>>;
  abstract findByUserId(userId: Order['userId']): Promise<Order[]>;
  abstract findByTableId(tableId: Order['tableId']): Promise<Order[]>;
  abstract findByShiftId(shiftId: Order['shiftId']): Promise<Order[]>;
  abstract findByShiftIdForSummary(shiftId: Order['shiftId']): Promise<Order[]>;
  abstract findOpenOrdersByDate(date: Date): Promise<Order[]>;
  abstract findOrderForFinalizationById(id: string): Promise<Order | null>;
  abstract findByDateRange(startDate: Date, endDate: Date): Promise<Order[]>;
  abstract findOpenOrdersOptimized(
    startDate: Date,
    endDate: Date,
  ): Promise<Order[]>;
  abstract findByStatus(statuses: string[]): Promise<Order[]>;
  abstract update(
    id: Order['id'],
    payload: DeepPartial<Order>,
  ): Promise<Order | null>;
  abstract remove(id: Order['id']): Promise<void>;
}

================
File: backend/src/orders/infrastructure/persistence/relational/mappers/order.mapper.ts
================
import { forwardRef, Inject, Injectable } from '@nestjs/common';
import { Order } from '../../../../domain/order';
import { OrderEntity } from '../entities/order.entity';
import { UserMapper } from '../../../../../users/infrastructure/persistence/relational/mappers/user.mapper';
import { TableMapper } from '../../../../../tables/infrastructure/persistence/relational/mappers/table.mapper';
import { OrderItemMapper } from './order-item.mapper';
import { PaymentMapper } from '../../../../../payments/infrastructure/persistence/relational/mappers/payment.mapper';
import { AdjustmentMapper } from '../../../../../adjustments/infrastructure/persistence/relational/mappers/adjustment.mapper';
import { DeliveryInfoMapper } from './delivery-info.mapper';
import { OrderPreparationScreenStatusMapper } from './order-preparation-screen-status.mapper';
import { TicketImpressionMapper } from './ticket-impression.mapper';
import { UserEntity } from '../../../../../users/infrastructure/persistence/relational/entities/user.entity';
import { TableEntity } from '../../../../../tables/infrastructure/persistence/relational/entities/table.entity';
import { ShiftEntity } from '../../../../../shifts/infrastructure/persistence/relational/entities/shift.entity';
import {
  BaseMapper,
  mapArray,
} from '../../../../../common/mappers/base.mapper';
@Injectable()
export class OrderMapper extends BaseMapper<OrderEntity, Order> {
  constructor(
    private readonly userMapper: UserMapper,
    private readonly tableMapper: TableMapper,
    private readonly orderItemMapper: OrderItemMapper,
    @Inject(forwardRef(() => PaymentMapper))
    private readonly paymentMapper: PaymentMapper,
    @Inject(forwardRef(() => AdjustmentMapper))
    private readonly adjustmentMapper: AdjustmentMapper,
    private readonly deliveryInfoMapper: DeliveryInfoMapper,
    private readonly orderPreparationScreenStatusMapper: OrderPreparationScreenStatusMapper,
    private readonly ticketImpressionMapper: TicketImpressionMapper,
  ) {
    super();
  }
  override toDomain(entity: OrderEntity): Order | null {
    if (!entity) return null;
    const domain = new Order();
    domain.id = entity.id;
    domain.shiftOrderNumber = entity.shiftOrderNumber;
    domain.shiftId = entity.shiftId;
    domain.userId = entity.userId;
    domain.tableId = entity.tableId;
    domain.orderStatus = entity.orderStatus;
    domain.orderType = entity.orderType;
    domain.subtotal = entity.subtotal;
    domain.total = entity.total;
    domain.notes = entity.notes || undefined;
    domain.customerId = entity.customerId;
    domain.isFromWhatsApp = entity.isFromWhatsApp;
    domain.scheduledAt = entity.scheduledAt;
    domain.createdAt = entity.createdAt;
    domain.updatedAt = entity.updatedAt;
    domain.deletedAt = entity.deletedAt;
    domain.finalizedAt = entity.finalizedAt;
    domain.user = entity.user ? this.userMapper.toDomain(entity.user) : null;
    domain.table = entity.table
      ? this.tableMapper.toDomain(entity.table)
      : null;
    domain.orderItems = mapArray(entity.orderItems, (item) =>
      this.orderItemMapper.toDomain(item),
    );
    domain.payments = mapArray(entity.payments, (payment) =>
      this.paymentMapper.toDomain(payment),
    );
    domain.adjustments = mapArray(entity.adjustments, (adjustment) =>
      this.adjustmentMapper.toDomain(adjustment),
    );
    domain.deliveryInfo = entity.deliveryInfo
      ? this.deliveryInfoMapper.toDomain(entity.deliveryInfo)
      : null;
    domain.estimatedDeliveryTime = entity.estimatedDeliveryTime;
    domain.preparationScreenStatusesFull = mapArray(
      entity.preparationScreenStatuses,
      (status) => this.orderPreparationScreenStatusMapper.toDomain(status),
    );
    domain.ticketImpressions = mapArray(
      entity.ticketImpressions,
      (impression) => this.ticketImpressionMapper.toDomain(impression),
    );
    return domain;
  }
  override toEntity(domain: Order): OrderEntity | null {
    if (!domain) return null;
    const entity = new OrderEntity();
    if (domain.id) entity.id = domain.id;
    entity.shiftOrderNumber = domain.shiftOrderNumber;
    entity.shiftId = domain.shiftId;
    entity.shift = {
      id: domain.shiftId,
    } as ShiftEntity;
    entity.userId = domain.userId;
    entity.user = domain.userId ? ({ id: domain.userId } as UserEntity) : null;
    entity.tableId = domain.tableId || null;
    entity.table = domain.tableId
      ? ({ id: domain.tableId } as TableEntity)
      : null;
    entity.orderStatus = domain.orderStatus;
    entity.orderType = domain.orderType;
    entity.subtotal = domain.subtotal;
    entity.total = domain.total;
    entity.notes = domain.notes || null;
    entity.customerId = domain.customerId || null;
    entity.isFromWhatsApp = domain.isFromWhatsApp || false;
    entity.scheduledAt = domain.scheduledAt || null;
    entity.estimatedDeliveryTime = domain.estimatedDeliveryTime || null;
    entity.finalizedAt = domain.finalizedAt || null;
    if (domain.deliveryInfo) {
      entity.deliveryInfo = this.deliveryInfoMapper.toEntity(
        domain.deliveryInfo,
      );
    } else {
      entity.deliveryInfo = null;
    }
    return entity;
  }
}

================
File: backend/src/thermal-printers/automatic-printing.service.ts
================
import { Injectable, Inject, Logger, forwardRef } from '@nestjs/common';
import { OrdersService } from '../orders/orders.service';
import { ThermalPrintersService } from './thermal-printers.service';
import { PrinterTypes, ThermalPrinter } from 'node-thermal-printer';
import {
  PrinterConnectionType,
  ThermalPrinter as ThermalPrinterEntity,
} from './domain/thermal-printer';
import { Order } from '../orders/domain/order';
import { OrderType } from '../orders/domain/enums/order-type.enum';
import { TicketType } from '../orders/domain/enums/ticket-type.enum';
import { TicketFormatter } from './utils/ticket-formatter';
import { CustomizationType } from '../pizza-customizations/domain/enums/customization-type.enum';
import { PizzaHalf } from '../selected-pizza-customizations/domain/enums/pizza-half.enum';
import { CustomizationAction } from '../selected-pizza-customizations/domain/enums/customization-action.enum';
import { RestaurantConfigService } from '../restaurant-config/restaurant-config.service';
interface GroupedOrderItem {
  productId: string;
  productName: string;
  variantId?: string;
  variantName?: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  modifiers: Array<{
    id: string;
    name: string;
    price: number;
  }>;
  preparationNotes?: string;
  selectedPizzaCustomizations?: Array<{
    pizzaCustomizationId: string;
    half: PizzaHalf;
    action: CustomizationAction;
    pizzaCustomization?: {
      name: string;
      type: CustomizationType;
    };
  }>;
  preparationStatus?: string;
}
interface PizzaCustomizationGroup {
  flavors: string[];
  addedIngredients: string[];
  removedIngredients: string[];
}
@Injectable()
export class AutomaticPrintingService {
  private readonly logger = new Logger(AutomaticPrintingService.name);
  constructor(
    @Inject(forwardRef(() => OrdersService))
    private readonly ordersService: OrdersService,
    @Inject(ThermalPrintersService)
    private readonly thermalPrintersService: ThermalPrintersService,
    @Inject(forwardRef(() => RestaurantConfigService))
    private readonly restaurantConfigService: RestaurantConfigService,
  ) {}
  private formatPizzaCustomizations(customizations: any[]): string {
    if (!customizations || customizations.length === 0) return '';
    // Agrupar por mitad y tipo
    const groupedByHalf = customizations.reduce(
      (acc, curr) => {
        const half =
          curr.half === PizzaHalf.HALF_1
            ? 'HALF_1'
            : curr.half === PizzaHalf.HALF_2
              ? 'HALF_2'
              : 'FULL';
        if (!acc[half]) {
          acc[half] = {
            flavors: [],
            addedIngredients: [],
            removedIngredients: [],
          };
        }
        let name = '';
        let type = null;
        if (curr.pizzaCustomization) {
          // Si viene la información completa del backend
          name = curr.pizzaCustomization.name;
          type = curr.pizzaCustomization.type;
        } else {
          // Si no viene la información, usar el ID como fallback
          name = curr.pizzaCustomizationId;
        }
        if (type === CustomizationType.FLAVOR) {
          acc[half].flavors.push(name);
        } else if (type === CustomizationType.INGREDIENT) {
          if (curr.action === CustomizationAction.ADD) {
            acc[half].addedIngredients.push(name);
          } else {
            acc[half].removedIngredients.push(name);
          }
        }
        return acc;
      },
      {} as Record<string, PizzaCustomizationGroup>,
    );
    // Formatear según el tipo de pizza
    if (groupedByHalf.FULL) {
      // Pizza completa
      const parts: string[] = [];
      if (groupedByHalf.FULL.flavors.length > 0) {
        parts.push(groupedByHalf.FULL.flavors.join(', '));
      }
      if (groupedByHalf.FULL.addedIngredients.length > 0) {
        parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
      }
      if (groupedByHalf.FULL.removedIngredients.length > 0) {
        parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
      // Pizza mitad y mitad
      const formatHalf = (halfData: PizzaCustomizationGroup) => {
        const parts: string[] = [];
        if (halfData.flavors.length > 0) {
          parts.push(halfData.flavors.join(', '));
        }
        if (halfData.addedIngredients.length > 0) {
          parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
        }
        if (halfData.removedIngredients.length > 0) {
          parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
        }
        return parts.join(' - ');
      };
      const half1 = groupedByHalf.HALF_1
        ? formatHalf(groupedByHalf.HALF_1)
        : '';
      const half2 = groupedByHalf.HALF_2
        ? formatHalf(groupedByHalf.HALF_2)
        : '';
      return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
    }
    return '';
  }
  /**
   * Función para agrupar items idénticos igual que en OrderCartDetail.tsx
   */
  private groupIdenticalItems(items: any[]): GroupedOrderItem[] {
    const groupedMap = new Map<string, GroupedOrderItem>();
    items.forEach((item) => {
      // Crear una clave única basada en todas las propiedades que deben ser idénticas
      const modifierIds = (item.productModifiers || [])
        .map((mod) => mod.id)
        .sort()
        .join(',');
      // Incluir personalizaciones de pizza en la clave
      const pizzaCustomizationIds = (item.selectedPizzaCustomizations || [])
        .map((pc) => `${pc.pizzaCustomizationId}-${pc.half}-${pc.action}`)
        .sort()
        .join(',');
      const groupKey = `${item.productId}-${item.productVariantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;
      const existingItem = groupedMap.get(groupKey);
      if (existingItem) {
        // Si ya existe un item idéntico, incrementar la cantidad
        existingItem.quantity += 1;
        existingItem.totalPrice += Number(item.finalPrice);
      } else {
        // Si es nuevo, agregarlo al mapa
        const groupedItem: GroupedOrderItem = {
          productId: item.productId,
          productName: item.product?.name || 'Producto',
          variantId: item.productVariantId || undefined,
          variantName: item.productVariant?.name || undefined,
          quantity: 1,
          unitPrice: Number(item.basePrice),
          totalPrice: Number(item.finalPrice),
          modifiers: (item.productModifiers || []).map((mod) => ({
            id: mod.id,
            name: mod.name,
            price: Number(mod.price) || 0,
          })),
          preparationNotes: item.preparationNotes || undefined,
          selectedPizzaCustomizations:
            item.selectedPizzaCustomizations || undefined,
          preparationStatus: item.preparationStatus || 'PENDING',
        };
        groupedMap.set(groupKey, groupedItem);
      }
    });
    return Array.from(groupedMap.values());
  }
  /**
   * Función para crear el título del producto igual que en OrderCartDetail.tsx
   */
  private createProductTitle(item: GroupedOrderItem): string {
    // Usar variantName si existe, sino productName
    const displayName = item.variantName || item.productName;
    return `${item.quantity}x ${displayName}`;
  }
  /**
   * Imprime automáticamente las órdenes de delivery y pickup si hay una impresora configurada
   */
  async printOrderAutomatically(
    orderId: string,
    orderType: OrderType,
    userId: string | null,
    isReprint: boolean = false,
  ): Promise<void> {
    try {
      // Solo procesar órdenes de DELIVERY o TAKE_AWAY
      if (
        orderType !== OrderType.DELIVERY &&
        orderType !== OrderType.TAKE_AWAY
      ) {
        this.logger.log(
          `Orden ${orderId} es de tipo ${orderType}, no requiere impresión automática.`,
        );
        return;
      }
      // Buscar impresoras activas
      const [printers] = await this.thermalPrintersService.findAll(
        {
          isActive: true,
        },
        {
          page: 1,
          limit: 100,
        },
      );
      // Si no hay impresoras, salir
      if (!printers || printers.length === 0) {
        this.logger.log('No hay impresoras activas configuradas.');
        return;
      }
      // Filtrar impresoras según el tipo de orden
      const eligiblePrinters = printers.filter((printer) => {
        if (orderType === OrderType.DELIVERY && printer.autoDeliveryPrint) {
          return true;
        }
        if (orderType === OrderType.TAKE_AWAY && printer.autoPickupPrint) {
          return true;
        }
        return false;
      });
      if (eligiblePrinters.length === 0) {
        this.logger.log(
          `No hay impresoras configuradas para impresión automática de ${orderType}.`,
        );
        return;
      }
      // Usar la primera impresora elegible o la marcada como predeterminada
      const defaultPrinter = eligiblePrinters.find((p) => p.isDefaultPrinter);
      const printerToUse = defaultPrinter || eligiblePrinters[0];
      this.logger.log(
        `Imprimiendo automáticamente orden ${orderId} (${orderType}) en impresora ${printerToUse.name}`,
      );
      // Imprimir el ticket
      await this.printDeliveryPickupTicket(
        orderId,
        printerToUse,
        userId,
        isReprint,
      );
    } catch (error) {
      // No lanzar error para no interrumpir la creación de la orden
      this.logger.error(
        `Error en impresión automática de orden ${orderId}: ${error.message}`,
        error.stack,
      );
    }
  }
  /**
   * Imprime un ticket de delivery/pickup con formato específico
   */
  async printDeliveryPickupTicket(
    orderId: string,
    printerDetails: ThermalPrinterEntity,
    userId: string | null,
    isReprint: boolean = false,
  ): Promise<void> {
    const order = await this.ordersService.findOne(orderId);
    const restaurantConfig = await this.restaurantConfigService.getConfig();
    if (
      printerDetails.connectionType !== PrinterConnectionType.NETWORK ||
      !printerDetails.ipAddress ||
      !printerDetails.port
    ) {
      throw new Error(
        `La impresora ${printerDetails.id} no es una impresora de red válida.`,
      );
    }
    const printer = new ThermalPrinter({
      type: PrinterTypes.EPSON,
      interface: `tcp:
      removeSpecialCharacters: false,
      lineCharacter: '=',
    });
    try {
      const isConnected = await printer.isPrinterConnected();
      if (!isConnected) {
        throw new Error(
          `No se pudo conectar a la impresora ${printerDetails.name}`,
        );
      }
      const formatter = new TicketFormatter(
        printerDetails.paperWidth as 58 | 80,
      );
      printer.alignCenter();
      printer.setTextSize(1, 2);
      printer.bold(true);
      let orderTitle = `#${order.shiftOrderNumber} - `;
      if (order.orderType === OrderType.DELIVERY) {
        orderTitle += 'DOMICILIO';
      } else {
        orderTitle += 'PARA LLEVAR';
      }
      if (order.scheduledAt) {
        orderTitle += ' (P)';
      }
      if (isReprint) {
        orderTitle += ' *';
      }
      printer.println(orderTitle);
      printer.bold(false);
      printer.setTextNormal();
      printer.drawLine();
      printer.alignCenter();
      printer.setTextSize(1, 1);
      printer.bold(true);
      printer.println(restaurantConfig.restaurantName || 'Restaurant');
      printer.bold(false);
      printer.setTextNormal();
      if (restaurantConfig.address) {
        printer.println(restaurantConfig.address);
        if (
          restaurantConfig.city ||
          restaurantConfig.state ||
          restaurantConfig.postalCode
        ) {
          const cityStateParts = [
            restaurantConfig.city,
            restaurantConfig.state,
            restaurantConfig.postalCode,
          ]
            .filter(Boolean)
            .join(', ');
          printer.println(cityStateParts);
        }
      }
      if (restaurantConfig.phoneMain || restaurantConfig.phoneSecondary) {
        const phones: string[] = [];
        if (restaurantConfig.phoneMain)
          phones.push(`Tel: ${restaurantConfig.phoneMain}`);
        if (restaurantConfig.phoneSecondary)
          phones.push(`Tel 2: ${restaurantConfig.phoneSecondary}`);
        printer.println(phones.join(' - '));
      }
      printer.drawLine();
      printer.alignLeft();
      printer.println(
        `Fecha: ${new Date(order.createdAt).toLocaleString('es-MX', {
          timeZone: 'America/Mexico_City',
        })}`,
      );
      if (
        order.updatedAt &&
        new Date(order.updatedAt).getTime() !==
          new Date(order.createdAt).getTime()
      ) {
        printer.println(
          `Actualizada: ${new Date(order.updatedAt).toLocaleString('es-MX', {
            timeZone: 'America/Mexico_City',
          })}`,
        );
      }
      if (order.user?.firstName || order.user?.lastName) {
        const userName = [order.user.firstName, order.user.lastName]
          .filter(Boolean)
          .join(' ');
        printer.println(`Atendido por: ${userName}`);
      }
      if ((order.notes || order.scheduledAt) && !order.deliveryInfo) {
        if (order.notes) {
          printer.setTextSize(0, 1);
          printer.println(`Notas de orden: ${order.notes}`);
          printer.setTextNormal();
        }
        if (order.scheduledAt) {
          printer.setTextSize(0, 1);
          printer.println(
            `Hora programada: ${new Date(order.scheduledAt).toLocaleTimeString(
              'es-MX',
              {
                timeZone: 'America/Mexico_City',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true,
              },
            )}`,
          );
          printer.setTextNormal();
        }
      }
      if (order.orderType === OrderType.DELIVERY && order.deliveryInfo) {
        printer.drawLine();
        printer.bold(true);
        printer.println('INFORMACION DE ENTREGA:');
        printer.bold(false);
        printer.setTextSize(1, 1);
        if (order.deliveryInfo.recipientName) {
          printer.println(`Cliente: ${order.deliveryInfo.recipientName}`);
        }
        if (order.deliveryInfo.fullAddress) {
          printer.println(`Direccion: ${order.deliveryInfo.fullAddress}`);
        } else if (order.deliveryInfo.street) {
          const addressParts = [
            order.deliveryInfo.street,
            order.deliveryInfo.number,
            order.deliveryInfo.interiorNumber
              ? `Int. ${order.deliveryInfo.interiorNumber}`
              : '',
            order.deliveryInfo.neighborhood,
            order.deliveryInfo.city,
          ]
            .filter(Boolean)
            .join(', ');
          printer.println(`Direccion: ${addressParts}`);
        }
        if (order.deliveryInfo.deliveryInstructions) {
          printer.println(
            `Instrucciones: ${order.deliveryInfo.deliveryInstructions}`,
          );
        }
        // Combinar teléfono, notas y hora programada en líneas optimizadas
        printer.setTextSize(0, 1); // Fuente intermedia
        const phone = order.deliveryInfo.recipientPhone
          ? `Tel: ${order.deliveryInfo.recipientPhone}`
          : null;
        const notes = order.notes ? `Notas: ${order.notes}` : null;
        const scheduledTime = order.scheduledAt
          ? `Hora programada: ${new Date(order.scheduledAt).toLocaleTimeString(
              'es-MX',
              {
                timeZone: 'America/Mexico_City',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true,
              },
            )}`
          : null;
        // Combinar campos disponibles
        const fields: string[] = [phone, notes, scheduledTime].filter(
          (field): field is string => field !== null,
        );
        if (fields.length === 3) {
          // Si hay 3 campos, imprimir teléfono solo, y notas + hora juntas
          printer.println(fields[0]); // Teléfono
          printer.println(`${fields[1]} | ${fields[2]}`); // Notas | Hora
        } else if (fields.length === 2) {
          // Si hay 2 campos, combinarlos en una línea
          printer.println(`${fields[0]} | ${fields[1]}`);
        } else if (fields.length === 1) {
          // Si hay solo 1 campo, imprimirlo solo
          printer.println(fields[0]);
        }
        printer.setTextSize(1, 1); // Volver a fuente de información de entrega
        // Volver a fuente normal
        printer.setTextNormal();
      }
      // Para pedidos pickup, mostrar información de recolección de deliveryInfo
      if (order.orderType === OrderType.TAKE_AWAY && order.deliveryInfo) {
        printer.drawLine();
        printer.bold(true);
        printer.println('RECOLECCION:');
        printer.bold(false);
        // Usar fuente más grande para información de recolección
        printer.setTextSize(1, 1);
        if (order.deliveryInfo.recipientName) {
          printer.println(`Nombre: ${order.deliveryInfo.recipientName}`);
        }
        if (order.deliveryInfo.deliveryInstructions) {
          printer.println(`Notas: ${order.deliveryInfo.deliveryInstructions}`);
        }
        // Combinar teléfono, notas y hora programada en líneas optimizadas
        printer.setTextSize(0, 1); // Fuente intermedia
        const phone = order.deliveryInfo.recipientPhone
          ? `Tel: ${order.deliveryInfo.recipientPhone}`
          : null;
        const notes = order.notes ? `Notas: ${order.notes}` : null;
        const scheduledTime = order.scheduledAt
          ? `Hora programada: ${new Date(order.scheduledAt).toLocaleTimeString(
              'es-MX',
              {
                timeZone: 'America/Mexico_City',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true,
              },
            )}`
          : null;
        // Combinar campos disponibles
        const fields: string[] = [phone, notes, scheduledTime].filter(
          (field): field is string => field !== null,
        );
        if (fields.length === 3) {
          // Si hay 3 campos, imprimir teléfono solo, y notas + hora juntas
          printer.println(fields[0]); // Teléfono
          printer.println(`${fields[1]} | ${fields[2]}`); // Notas | Hora
        } else if (fields.length === 2) {
          // Si hay 2 campos, combinarlos en una línea
          printer.println(`${fields[0]} | ${fields[1]}`);
        } else if (fields.length === 1) {
          // Si hay solo 1 campo, imprimirlo solo
          printer.println(fields[0]);
        }
        printer.setTextSize(1, 1); // Volver a fuente de información de recolección
        // Volver a fuente normal
        printer.setTextNormal();
      }
      // Items de la orden
      printer.drawLine();
      printer.bold(true);
      printer.println('PRODUCTOS:');
      printer.bold(false);
      // Agrupar items idénticos
      const groupedItems = this.groupIdenticalItems(order.orderItems || []);
      // Calcular el ancho máximo necesario para los precios
      let maxPriceWidth = 0;
      for (const item of groupedItems) {
        const priceStr = formatter.formatMoney(item.totalPrice);
        maxPriceWidth = Math.max(maxPriceWidth, priceStr.length);
      }
      // Añadir 2 caracteres de margen
      const dynamicPriceColumnWidth = maxPriceWidth + 2;
      // Usar fuente más grande para los productos
      printer.setTextSize(1, 1); // Fuente ligeramente más grande
      for (const item of groupedItems) {
        // Crear título del producto igual que en OrderCartDetail.tsx
        const productTitle = this.createProductTitle(item);
        // Imprimir producto principal con formato de tabla estricto
        // IMPORTANTE: Usar 'expanded' porque estamos usando setTextSize(1,1)
        const productLines = formatter.formatProductTable(
          productTitle,
          formatter.formatMoney(item.totalPrice),
          'expanded', // Cambiado a expanded para coincidir con el tamaño de fuente
          dynamicPriceColumnWidth, // Pasar el ancho de columna calculado dinámicamente
        );
        // Imprimir todas las líneas del producto
        for (const line of productLines) {
          printer.println(line);
        }
        // Personalizaciones de pizza (fuente intermedia)
        if (
          item.selectedPizzaCustomizations &&
          item.selectedPizzaCustomizations.length > 0
        ) {
          const pizzaCustomizations = this.formatPizzaCustomizations(
            item.selectedPizzaCustomizations,
          );
          if (pizzaCustomizations) {
            printer.setTextSize(0, 1); // Fuente intermedia para personalizaciones
            printer.println(`  ${pizzaCustomizations}`);
            printer.setTextSize(1, 1); // Regresar a fuente grande para productos
          }
        }
        // Modificadores (fuente intermedia)
        if (item.modifiers && item.modifiers.length > 0) {
          printer.setTextSize(0, 1); // Fuente intermedia para modificadores
          for (const modifier of item.modifiers) {
            let modifierText: string;
            if (modifier.price > 0) {
              // Si hay múltiples unidades, indicar que el precio es por c/u
              if (item.quantity > 1) {
                modifierText = `• ${modifier.name} (+${formatter.formatMoney(modifier.price)} c/u)`;
              } else {
                modifierText = `• ${modifier.name} (+${formatter.formatMoney(modifier.price)})`;
              }
            } else {
              modifierText = `• ${modifier.name}`;
            }
            printer.println(`  ${modifierText}`);
          }
          printer.setTextSize(1, 1); // Regresar a fuente grande para productos
        }
        // Notas de preparación con wrap (fuente intermedia)
        if (item.preparationNotes) {
          printer.setTextSize(0, 1); // Fuente intermedia para notas
          const wrappedNotes = formatter.wrapText(
            `  Notas: ${item.preparationNotes}`,
            'normal',
          );
          for (const line of wrappedNotes) {
            printer.println(line);
          }
          printer.setTextSize(1, 1); // Regresar a fuente grande para productos
        }
      }
      // Volver a fuente normal después de los productos
      printer.setTextNormal();
      // Total
      printer.drawLine();
      printer.alignLeft();
      // Calcular el ancho máximo necesario para los totales
      const subtotalStr = formatter.formatMoney(Number(order.subtotal));
      const totalStr = formatter.formatMoney(Number(order.total));
      const maxTotalWidth = Math.max(subtotalStr.length, totalStr.length) + 2;
      // Subtotal
      const subtotalLines = formatter.formatProductTable(
        'Subtotal:',
        subtotalStr,
        'normal',
        maxTotalWidth,
      );
      for (const line of subtotalLines) {
        printer.println(line);
      }
      // Total con fuente grande
      const totalLines = formatter.formatProductTable(
        'TOTAL:',
        totalStr,
        'expanded', // Usamos expanded porque vamos a usar fuente grande
        maxTotalWidth,
      );
      printer.setTextSize(1, 2);
      printer.bold(true);
      for (const line of totalLines) {
        printer.println(line);
      }
      printer.setTextNormal();
      printer.bold(false);
      // Notas adicionales (solo si no se mostraron en información de entrega)
      if (order.notes && !order.deliveryInfo) {
        printer.alignLeft();
        printer.drawLine();
        printer.bold(true);
        printer.println('NOTAS:');
        printer.bold(false);
        printer.println(order.notes);
      }
      // Pie del ticket
      printer.drawLine();
      printer.alignCenter();
      printer.println('¡Gracias por su preferencia!');
      // Añadir líneas de avance según configuración
      for (let i = 0; i < printerDetails.feedLines; i++) {
        printer.newLine();
      }
      // Cortar papel si está habilitado
      if (printerDetails.cutPaper) {
        printer.cut();
      }
      await printer.execute();
      // Registrar la impresión
      const ticketType =
        order.orderType === OrderType.DELIVERY
          ? TicketType.GENERAL
          : TicketType.GENERAL;
      // Solo registrar impresión si hay un userId válido
      if (userId) {
        await this.ordersService.registerTicketImpression(
          orderId,
          userId,
          ticketType,
          printerDetails.id,
        );
      }
      this.logger.log(
        `Ticket de ${order.orderType} para orden ${orderId} impreso exitosamente en ${printerDetails.name}.`,
      );
    } catch (error) {
      this.logger.error(
        `Error al imprimir ticket de ${order.orderType}: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }
}

================
File: app/src/app/components/crud/GenericList.tsx
================
import React, { useCallback, useMemo, useState } from 'react';
import { useIsFocused } from '@react-navigation/native';
import {
  StyleSheet,
  RefreshControl,
  ViewStyle,
  StyleProp,
  View,
  TextStyle,
} from 'react-native';
import { FlashList } from '@shopify/flash-list';
import {
  List,
  Chip,
  Text,
  Surface,
  Searchbar,
  FAB,
  Portal,
  Menu,
  IconButton,
  Badge,
} from 'react-native-paper';
import AutoImage from '../common/AutoImage';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
export interface FilterOption<TValue> {
  value: TValue;
  label: string;
  icon?: string;
  disabled?: boolean;
}
interface StatusConfig<TItem> {
  field: keyof TItem;
  activeValue: TItem[keyof TItem];
  activeLabel: string;
  inactiveLabel: string;
}
export interface RenderItemConfig<TItem> {
  titleField: keyof TItem;
  descriptionField?: keyof TItem;
  descriptionFormatter?: (value: any) => string | undefined;
  descriptionMaxLength?: number;
  priceField?: keyof TItem;
  sortOrderField?: keyof TItem;
  imageField?: keyof TItem;
  isDefaultField?: keyof TItem;
  statusConfig?: StatusConfig<TItem>;
  renderTitle?: (item: TItem) => React.ReactNode;
  renderDescription?: (item: TItem) => React.ReactNode;
}
interface GenericListProps<TItem extends { id: string }> {
  items: TItem[];
  renderConfig: RenderItemConfig<TItem>;
  onItemPress: (item: TItem) => void;
  onRefresh: () => void;
  isRefreshing: boolean;
  ListEmptyComponent: React.ComponentType<any> | React.ReactElement | null;
  isLoading?: boolean;
  listItemStyle?: StyleProp<ViewStyle>;
  listItemContentStyle?: StyleProp<ViewStyle>;
  contentContainerStyle?: StyleProp<ViewStyle>;
  imageStyle?: StyleProp<ViewStyle>;
  itemActionsContainerStyle?: StyleProp<ViewStyle>;
  renderItemActions?: (item: TItem) => React.ReactNode;
  renderItem?: ({ item }: { item: TItem }) => React.ReactElement;
  enableSearch?: boolean;
  searchPlaceholder?: string;
  searchQuery?: string;
  onSearchChange?: (query: string) => void;
  enableSort?: boolean;
  filterValue?: string | number;
  onFilterChange?: (value: string | number) => void;
  filterOptions?: FilterOption<string | number>[];
  showFab?: boolean;
  onFabPress?: () => void;
  fabIcon?: string;
  fabLabel?: string;
  fabVisible?: boolean;
  showImagePlaceholder?: boolean;
  placeholderIcon?: string;
  isModalOpen?: boolean;
  isDrawerOpen?: boolean;
  enableGrid?: boolean;
  gridColumns?: number;
  gridColumnsTablet?: number;
  minItemWidth?: number;
  itemSpacing?: number;
}
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) => {
  const listItemHorizontalMargin = responsive.spacing(theme.spacing.m);
  return StyleSheet.create({
    listContainer: {
      flex: 1,
    },
    searchbarContainer: {
      paddingHorizontal:
        listItemHorizontalMargin - responsive.spacing(theme.spacing.xs),
      paddingTop: responsive.spacing(theme.spacing.xs),
      paddingBottom: responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.background,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    searchbarWithFilter: {
      flex: 1,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: responsive.spacing(theme.spacing.xs),
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      marginVertical: responsive.isTablet
        ? responsive.spacing(3)
        : responsive.spacing(4),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness * 1.5,
      elevation: 1,
      overflow: 'hidden',
    },
    gridListItem: {
      backgroundColor: theme.colors.surface,
      flex: 1,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
      elevation: 2,
      overflow: 'hidden',
    },
    listItemContent: {
      paddingVertical: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      minHeight: responsive.isTablet ? 40 : 56,
      flexWrap: 'wrap',
      alignItems: 'flex-start',
    },
    listItemImage: {
      width: responsive.isTablet ? 36 : 40,
      height: responsive.isTablet ? 36 : 40,
      borderRadius: theme.roundness,
      marginLeft: responsive.spacing(theme.spacing.xs),
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.surfaceDisabled,
    },
    gridItemImage: {
      width: responsive.scaleWidth(64),
      height: responsive.scaleWidth(64),
      borderRadius: theme.roundness,
      marginLeft: responsive.spacing(theme.spacing.s),
      marginRight: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceDisabled,
    },
    statusChip: {
      borderRadius: theme.roundness * 1.5,
      height: responsive.isTablet ? 32 : 28,
      alignSelf: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    title: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 15 : 14,
      lineHeight: responsive.isTablet ? 20 : 18,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 13 : 12,
      lineHeight: responsive.isTablet ? 18 : 16,
    },
    emptyListContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
    defaultContentContainer: {
      paddingBottom: 80,
      paddingTop: responsive.spacing(theme.spacing.xs),
    },
    itemActionsContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      paddingLeft: responsive.spacing(theme.spacing.xs),
    },
    filtersOuterContainer: {
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      backgroundColor: theme.colors.background,
    },
    segmentedButtons: {
      backgroundColor: 'transparent',
      borderRadius: theme.roundness,
      minHeight: 40,
    },
    filterButton: {
      borderWidth: 0,
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    filterButtonLabel: {
      fontSize: 15,
      letterSpacing: 0.15,
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    fab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 0,
    },
  });
};
const GenericList = <TItem extends { id: string }>({
  items,
  renderConfig,
  onItemPress,
  onRefresh,
  isRefreshing,
  ListEmptyComponent,
  listItemStyle,
  listItemContentStyle,
  contentContainerStyle,
  imageStyle,
  renderItemActions,
  itemActionsContainerStyle,
  enableSearch = false,
  searchPlaceholder = 'Buscar...',
  enableSort = false,
  filterValue,
  onFilterChange,
  filterOptions,
  searchQuery: externalSearchQuery,
  onSearchChange,
  showFab = false,
  onFabPress,
  fabIcon = 'plus',
  fabLabel,
  fabVisible = true,
  showImagePlaceholder = true,
  placeholderIcon = 'image-outline',
  isModalOpen = false,
  isDrawerOpen = false,
  renderItem,
  enableGrid = false,
  gridColumns = 1,
  gridColumnsTablet,
  minItemWidth,
  itemSpacing,
}: GenericListProps<TItem>) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const [internalSearchTerm, setInternalSearchTerm] = useState('');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const isSearchControlled =
    externalSearchQuery !== undefined && onSearchChange !== undefined;
  const currentSearchTerm = isSearchControlled
    ? externalSearchQuery
    : internalSearchTerm;
  const isFocused = useIsFocused();
  const processedItems = useMemo(() => {
    let processed = [...items];
    if (enableSort && renderConfig.titleField) {
      processed.sort((a, b) => {
        const titleA = String(a[renderConfig.titleField] ?? '').toLowerCase();
        const titleB = String(b[renderConfig.titleField] ?? '').toLowerCase();
        return titleA.localeCompare(titleB);
      });
    }
    if (enableSearch && !isSearchControlled && currentSearchTerm.trim()) {
      const lowerCaseSearchTerm = currentSearchTerm.toLowerCase();
      processed = processed.filter((item) => {
        const title = String(item[renderConfig.titleField] ?? '').toLowerCase();
        if (title.includes(lowerCaseSearchTerm)) {
          return true;
        }
        if (renderConfig.descriptionField) {
          const description = String(
            item[renderConfig.descriptionField] ?? '',
          ).toLowerCase();
          if (description.includes(lowerCaseSearchTerm)) {
            return true;
          }
        }
        return false;
      });
    }
    return processed;
  }, [
    items,
    enableSort,
    enableSearch,
    isSearchControlled,
    currentSearchTerm,
    renderConfig,
  ]);
  const numColumns = useMemo(() => {
    if (!enableGrid) return 1;
    if (minItemWidth) {
      const gap = itemSpacing || responsive.spacing(theme.spacing.m);
      const padding = responsive.spacing(theme.spacing.m);
      return responsive.getGridColumns(minItemWidth, gap, padding);
    }
    if (responsive.isTablet && gridColumnsTablet) {
      return gridColumnsTablet;
    }
    return gridColumns;
  }, [
    enableGrid,
    minItemWidth,
    itemSpacing,
    responsive,
    gridColumns,
    gridColumnsTablet,
  ]);
  const renderGenericItem = useCallback(
    ({ item }: { item: TItem }) => {
      const title = String(item[renderConfig.titleField] ?? '');
      let description = '';
      if (
        renderConfig.descriptionField &&
        item.hasOwnProperty(renderConfig.descriptionField)
      ) {
        const fieldValue = item[renderConfig.descriptionField];
        if (renderConfig.descriptionFormatter) {
          const formattedDescription =
            renderConfig.descriptionFormatter(fieldValue);
          if (formattedDescription) {
            description = formattedDescription;
          }
        } else {
          const rawDescription = String(fieldValue || '');
          if (rawDescription && rawDescription.toLowerCase() !== 'null') {
            description = rawDescription;
          }
        }
      }
      let sortOrderString: string | null = null;
      if (
        renderConfig.sortOrderField &&
        item.hasOwnProperty(renderConfig.sortOrderField)
      ) {
        const sortOrderValue = item[renderConfig.sortOrderField];
        if (sortOrderValue !== null && sortOrderValue !== undefined) {
          sortOrderString = `Posicion: ${String(sortOrderValue)}`;
        }
      }
      let priceString: string | null = null;
      if (
        renderConfig.priceField &&
        item.hasOwnProperty(renderConfig.priceField)
      ) {
        const priceValue = item[renderConfig.priceField];
        if (priceValue !== null && priceValue !== undefined) {
          const numericPrice = Number(priceValue);
          if (!isNaN(numericPrice)) {
            priceString = `$${numericPrice.toFixed(2)}`;
          } else if (
            typeof priceValue === 'string' &&
            priceValue.trim() !== ''
          ) {
            priceString = String(priceValue);
          }
        }
      }
      let imageSource: string | undefined = undefined;
      if (
        renderConfig.imageField &&
        item.hasOwnProperty(renderConfig.imageField)
      ) {
        const imageFieldValue = item[renderConfig.imageField];
        if (
          typeof imageFieldValue === 'object' &&
          imageFieldValue !== null &&
          'path' in imageFieldValue &&
          typeof imageFieldValue.path === 'string'
        ) {
          imageSource = imageFieldValue.path;
        } else if (typeof imageFieldValue === 'string') {
          imageSource = imageFieldValue;
        }
      }
      let statusChip = null;
      if (
        renderConfig.statusConfig &&
        item.hasOwnProperty(renderConfig.statusConfig.field)
      ) {
        const { field, activeValue, activeLabel, inactiveLabel } =
          renderConfig.statusConfig;
        const isActive = item[field] === activeValue;
        const chipLabel = isActive ? activeLabel : inactiveLabel;
        statusChip = (props: {
          color: string;
          style?: StyleProp<TextStyle>;
        }) => (
          <Chip
            {...props}
            mode="flat"
            selectedColor={
              isActive ? theme.colors.success : theme.colors.onSurfaceVariant
            }
            style={[
              styles.statusChip,
              {
                backgroundColor: isActive
                  ? theme.colors.successContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
            textStyle={{
              fontSize: responsive.isTablet ? 12 : 11,
              marginVertical: 0,
            }}
            compact
          >
            {chipLabel}
          </Chip>
        );
      }
      const isGrid = enableGrid && numColumns > 1;
      return (
        <Surface
          style={[
            isGrid ? styles.gridListItem : styles.listItem,
            listItemStyle,
          ]}
          elevation={1}
        >
          <List.Item
            title={() =>
              renderConfig.renderTitle ? (
                renderConfig.renderTitle(item)
              ) : (
                <Text variant="bodyLarge" style={styles.title}>
                  {title}
                </Text>
              )
            }
            description={() => {
              if (renderConfig.renderDescription) {
                return renderConfig.renderDescription(item);
              }
              const parts = [];
              if (
                renderConfig.isDefaultField &&
                item.hasOwnProperty(renderConfig.isDefaultField) &&
                item[renderConfig.isDefaultField] === true
              ) {
                parts.push('✓ Por defecto');
              }
              if (sortOrderString) {
                parts.push(sortOrderString);
              }
              if (description) {
                parts.push(description);
              }
              if (priceString) {
                parts.push(priceString);
              }
              const combinedText = parts.join(' - ');
              if (combinedText.trim()) {
                return (
                  <Text variant="bodySmall" style={styles.description}>
                    {combinedText}
                  </Text>
                );
              }
              return null;
            }}
            left={() => {
              if (imageSource || showImagePlaceholder) {
                return (
                  <AutoImage
                    source={imageSource}
                    placeholderIcon={placeholderIcon}
                    style={[
                      isGrid ? styles.gridItemImage : styles.listItemImage,
                      imageStyle,
                    ]}
                    contentFit="cover"
                    transition={300}
                  />
                );
              } else {
                return null;
              }
            }}
            right={() => (
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {statusChip && statusChip({ color: theme.colors.onSurface })}
                {renderItemActions && (
                  <View
                    style={[
                      styles.itemActionsContainer,
                      itemActionsContainerStyle,
                    ]}
                  >
                    {renderItemActions(item)}
                  </View>
                )}
              </View>
            )}
            onPress={() => onItemPress(item)}
            style={[styles.listItemContent, listItemContentStyle]}
          />
        </Surface>
      );
    },
    [
      theme,
      renderConfig,
      onItemPress,
      styles,
      listItemStyle,
      listItemContentStyle,
      imageStyle,
      renderItemActions,
      itemActionsContainerStyle,
      enableGrid,
      numColumns,
      showImagePlaceholder,
      placeholderIcon,
      responsive,
    ],
  );
  const finalContentContainerStyle = useMemo(() => {
    return StyleSheet.flatten([
      styles.defaultContentContainer,
      contentContainerStyle,
    ]);
  }, [styles.defaultContentContainer, contentContainerStyle]);
  const hasActiveFilter = filterValue !== 'all' && filterValue !== undefined;
  return (
    <View style={styles.listContainer}>
      {(enableSearch ||
        (filterOptions && filterValue !== undefined && onFilterChange)) && (
        <View style={styles.searchbarContainer}>
          <View style={styles.searchRow}>
            {enableSearch && (
              <Searchbar
                placeholder={searchPlaceholder}
                onChangeText={
                  isSearchControlled ? onSearchChange : setInternalSearchTerm
                }
                value={currentSearchTerm}
                style={[
                  styles.searchbar,
                  filterOptions ? styles.searchbarWithFilter : {},
                ]}
                inputStyle={{
                  color: theme.colors.onSurface,
                  fontSize: 14,
                  minHeight: 40,
                }}
                placeholderTextColor={theme.colors.onSurfaceVariant}
                iconColor={theme.colors.onSurfaceVariant}
                clearIcon={
                  currentSearchTerm
                    ? () => <List.Icon icon="close-circle" />
                    : undefined
                }
                onClearIconPress={() =>
                  isSearchControlled
                    ? onSearchChange('')
                    : setInternalSearchTerm('')
                }
              />
            )}
            {filterOptions && filterValue !== undefined && onFilterChange && (
              <View style={styles.filterButtonContainer}>
                <Menu
                  visible={filterMenuVisible}
                  onDismiss={() => setFilterMenuVisible(false)}
                  anchor={
                    <IconButton
                      icon={hasActiveFilter ? 'filter-check' : 'filter-variant'}
                      mode="contained-tonal"
                      size={24}
                      onPress={() => setFilterMenuVisible(true)}
                      style={styles.filterIconButton}
                      iconColor={
                        hasActiveFilter
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                  }
                  anchorPosition="bottom"
                  contentStyle={styles.menuContent}
                >
                  {filterOptions.map((option) => (
                    <Menu.Item
                      key={String(option.value)}
                      onPress={() => {
                        onFilterChange(option.value);
                        setFilterMenuVisible(false);
                      }}
                      title={option.label}
                      leadingIcon={option.icon}
                      trailingIcon={
                        filterValue === option.value ? 'check' : undefined
                      }
                      disabled={option.disabled}
                      titleStyle={
                        filterValue === option.value
                          ? { color: theme.colors.primary, fontWeight: '600' }
                          : undefined
                      }
                    />
                  ))}
                </Menu>
                {hasActiveFilter && (
                  <Badge style={styles.filterBadge} size={8} />
                )}
              </View>
            )}
          </View>
        </View>
      )}
      <FlashList
        data={processedItems}
        renderItem={renderItem || renderGenericItem}
        keyExtractor={(item) => item.id}
        estimatedItemSize={enableGrid && numColumns > 1 ? 150 : 80}
        numColumns={numColumns}
        contentContainerStyle={finalContentContainerStyle}
        ListEmptyComponent={
          processedItems.length === 0 ? ListEmptyComponent || null : null
        }
        ItemSeparatorComponent={
          enableGrid && numColumns > 1
            ? () => (
                <View
                  style={{
                    height: itemSpacing || responsive.spacing(theme.spacing.m),
                  }}
                />
              )
            : undefined
        }
        refreshControl={
          <RefreshControl
            refreshing={isRefreshing}
            onRefresh={() => {
              if (isSearchControlled) {
                onSearchChange('');
              } else {
                setInternalSearchTerm('');
              }
              onRefresh();
            }}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        keyboardShouldPersistTaps="handled"
      />
      {showFab && onFabPress && (
        <Portal>
          <FAB
            icon={fabIcon}
            style={styles.fab}
            onPress={onFabPress}
            visible={
              isFocused &&
              showFab &&
              fabVisible &&
              !isModalOpen &&
              !isDrawerOpen
            }
            label={fabLabel}
            color={theme.colors.onPrimary}
            theme={{ colors: { primaryContainer: theme.colors.primary } }}
          />
        </Portal>
      )}
    </View>
  );
};
export default GenericList;

================
File: app/src/app/components/ShiftIndicator.tsx
================
import React, { useState } from 'react';
import { TouchableOpacity, StyleSheet, Text } from 'react-native';
import { Icon, Badge } from 'react-native-paper';
import { useAppTheme } from '../styles/theme';
import { useAuthStore } from '../store/authStore';
import { canOpenShift } from '../utils/roleUtils';
import { OpenShiftModal } from '@/modules/orders/components/OpenShiftModal';
import { ShiftStatusModal } from '@/modules/orders/components/ShiftStatusModal';
import { CloseShiftModal } from '@/modules/orders/components/CloseShiftModal';
import { useGlobalShift } from '../hooks/useGlobalShift';
import { useQueryClient } from '@tanstack/react-query';
export const ShiftIndicator: React.FC = () => {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const queryClient = useQueryClient();
  const { data: shift, isLoading: loading, refetch } = useGlobalShift();
  const [statusModalVisible, setStatusModalVisible] = useState(false);
  const [openShiftModalVisible, setOpenShiftModalVisible] = useState(false);
  const [closeShiftModalVisible, setCloseShiftModalVisible] = useState(false);
  const userCanOpenShift = canOpenShift(user);
  const isShiftOpen = shift && shift.status === 'OPEN';
  const handlePress = () => {
    setStatusModalVisible(true);
  };
  const handleOpenShift = () => {
    setStatusModalVisible(false);
    setOpenShiftModalVisible(true);
  };
  const handleCloseShift = () => {
    setStatusModalVisible(false);
    setCloseShiftModalVisible(true);
  };
  const getIconColor = () => {
    if (loading) return theme.colors.onPrimary;
    return '#FFFFFF';
  };
  const getIconName = () => {
    if (loading) return 'clock-outline';
    if (isShiftOpen) return 'store-check';
    return 'store-alert';
  };
  return (
    <>
      <TouchableOpacity
        style={[
          styles.container,
          {
            backgroundColor: loading
              ? 'rgba(255, 255, 255, 0.2)'
              : isShiftOpen
                ? '#2E7D32'
                : '#F57C00',
            borderWidth: 2,
            borderColor: loading
              ? 'rgba(255, 255, 255, 0.3)'
              : isShiftOpen
                ? '#4CAF50'
                : '#FF9800',
          },
        ]}
        onPress={handlePress}
        disabled={loading}
        hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
      >
        <Icon source={getIconName()} size={22} color={getIconColor()} />
        <Text style={[styles.statusText, { color: getIconColor() }]}>
          {loading ? 'Cargando' : isShiftOpen ? 'ABIERTO' : 'CERRADO'}
        </Text>
        {!isShiftOpen && !loading && (
          <Badge
            style={[styles.badge, { backgroundColor: '#FF1744' }]}
            size={8}
          />
        )}
      </TouchableOpacity>
      <ShiftStatusModal
        visible={statusModalVisible}
        onDismiss={() => setStatusModalVisible(false)}
        shift={shift}
        onOpenShift={handleOpenShift}
        onCloseShift={handleCloseShift}
        canOpenShift={userCanOpenShift}
        loading={loading}
      />
      <OpenShiftModal
        visible={openShiftModalVisible}
        onDismiss={() => setOpenShiftModalVisible(false)}
        onShiftOpened={() => {
          queryClient.invalidateQueries(['global', 'shift', 'current']);
          setOpenShiftModalVisible(false);
        }}
      />
      <CloseShiftModal
        visible={closeShiftModalVisible}
        onDismiss={() => setCloseShiftModalVisible(false)}
        onShiftClosed={() => {
          queryClient.invalidateQueries(['global', 'shift', 'current']);
          setCloseShiftModalVisible(false);
        }}
        shift={shift}
      />
    </>
  );
};
const styles = StyleSheet.create({
  container: {
    position: 'relative',
    flexDirection: 'row',
    paddingHorizontal: 14,
    paddingVertical: 8,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
    borderRadius: 24,
    gap: 6,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  statusText: {
    fontSize: 14,
    fontWeight: '700',
    letterSpacing: 0.5,
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
  },
});

================
File: app/src/app/lib/imageCache.ts
================
import * as FileSystem from 'expo-file-system';
import * as Crypto from 'expo-crypto';
import { Platform } from 'react-native';
import { API_PATHS } from '@/app/constants/apiPaths';
const CACHE_DIR = `${FileSystem.cacheDirectory}image-cache/`;
const MAX_CACHE_SIZE_MB = 500;
const MAX_CACHE_AGE_DAYS = 7;
const MAX_RETRIES = 3;
const BASE_RETRY_DELAY = 1000;
const logCacheOperation = (operation: string, details: any) => {
  if (
    operation.includes('ERROR') ||
    operation.includes('FAILED') ||
    operation === 'CACHE_CLEANED'
  ) {
  }
};
async function downloadWithRetry(
  remoteUrl: string,
  localUri: string,
  maxRetries: number = MAX_RETRIES,
  baseDelay: number = BASE_RETRY_DELAY,
): Promise<string | null> {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const { uri: downloadedUri } = await FileSystem.downloadAsync(
        remoteUrl,
        localUri,
      );
      return downloadedUri;
    } catch (error) {
      if (attempt === maxRetries) {
        logCacheOperation('DOWNLOAD_FAILED_ALL_RETRIES', {
          url: remoteUrl,
          totalAttempts: maxRetries + 1,
          error: error.message,
        });
        break;
      }
      const delay = baseDelay * Math.pow(2, attempt);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
  return null;
}
async function ensureCacheDirExists() {
  if (Platform.OS === 'web') {
    return;
  }
  const dirInfo = await FileSystem.getInfoAsync(CACHE_DIR);
  if (!dirInfo.exists) {
    await FileSystem.makeDirectoryAsync(CACHE_DIR, { intermediates: true });
  }
}
async function getCacheFilename(remoteUrl: string): Promise<string> {
  let urlToHash = remoteUrl;
  if (remoteUrl.includes(API_PATHS.FILES_CHECK)) {
    try {
      const parsedUrl = new URL(remoteUrl);
      urlToHash = `${parsedUrl.host}${parsedUrl.pathname}`;
    } catch (e) {
      urlToHash = remoteUrl;
    }
  }
  const digest = await Crypto.digestStringAsync(
    Crypto.CryptoDigestAlgorithm.SHA256,
    urlToHash,
    { encoding: Crypto.CryptoEncoding.HEX },
  );
  const extensionMatch = remoteUrl.match(/\.([a-zA-Z0-9]+)(?:[?#]|$)/);
  const extension = extensionMatch ? extensionMatch[1] : 'jpg';
  return `${digest}.${extension}`;
}
interface ExistingFileInfo {
  uri: string;
  size: number;
  modificationTime: number;
  exists: true;
}
async function cleanCache() {
  await ensureCacheDirExists();
  try {
    const files = await FileSystem.readDirectoryAsync(CACHE_DIR);
    if (files.length === 0) {
      return;
    }
    const fileInfosPromises = files.map(
      async (
        file,
      ): Promise<ExistingFileInfo | { exists: false; uri: string }> => {
        const info = await FileSystem.getInfoAsync(`${CACHE_DIR}${file}`, {
          size: true,
        });
        if (info.exists) {
          return {
            uri: info.uri,
            size: info.size,
            modificationTime: info.modificationTime,
            exists: true,
          };
        } else {
          return {
            exists: false,
            uri: info.uri,
          };
        }
      },
    );
    const allFileInfos = await Promise.all(fileInfosPromises);
    const existingFileInfos: ExistingFileInfo[] = allFileInfos.filter(
      (f): f is ExistingFileInfo => f.exists,
    );
    let totalSize = existingFileInfos.reduce((sum, file) => sum + file.size, 0);
    const originalTotalSize = totalSize;
    const now = Date.now();
    const maxAgeMillis = MAX_CACHE_AGE_DAYS * 24 * 60 * 60 * 1000;
    const maxSizeInBytes = MAX_CACHE_SIZE_MB * 1024 * 1024;
    let filesDeletedCount = 0;
    let sizeDeleted = 0;
    const filesToDeleteByAge = existingFileInfos.filter((file) => {
      const fileAgeMillis = now - Math.floor(file.modificationTime) * 1000;
      return fileAgeMillis > maxAgeMillis;
    });
    for (const file of filesToDeleteByAge) {
      try {
        await FileSystem.deleteAsync(file.uri, { idempotent: true });
        totalSize -= file.size;
        sizeDeleted += file.size;
        filesDeletedCount++;
      } catch (delError) {
      }
    }
    if (totalSize > maxSizeInBytes) {
      const remainingFiles = existingFileInfos
        .filter((file) => {
          const fileAgeMillis = now - Math.floor(file.modificationTime) * 1000;
          return fileAgeMillis <= maxAgeMillis;
        })
        .sort((a, b) => {
          return a.modificationTime < b.modificationTime
            ? -1
            : a.modificationTime > b.modificationTime
              ? 1
              : 0;
        });
      const targetSize = maxSizeInBytes * 0.9;
      for (const file of remainingFiles) {
        if (totalSize <= targetSize) break;
        try {
          await FileSystem.deleteAsync(file.uri, { idempotent: true });
          totalSize -= file.size;
          sizeDeleted += file.size;
          filesDeletedCount++;
        } catch (delError) {
        }
      }
    }
    if (filesDeletedCount > 0) {
      logCacheOperation('CACHE_CLEANED', {
        filesDeleted: filesDeletedCount,
        sizeCleaned: `${(sizeDeleted / 1024 / 1024).toFixed(2)}MB`,
        totalFilesRemaining: files.length - filesDeletedCount,
        totalSizeRemaining: `${(totalSize / 1024 / 1024).toFixed(2)}MB`,
        originalSize: `${(originalTotalSize / 1024 / 1024).toFixed(2)}MB`,
        spaceFreed: `${(sizeDeleted / 1024 / 1024).toFixed(2)}MB`,
        cacheUtilization: `${((totalSize / maxSizeInBytes) * 100).toFixed(1)}%`,
      });
    }
  } catch (error) {
    logCacheOperation('CACHE_CLEAN_ERROR', { error: error.message });
  }
}
export async function getCachedImageUri(
  remoteUrl: string,
): Promise<string | null> {
  if (
    !remoteUrl ||
    typeof remoteUrl !== 'string' ||
    (!remoteUrl.startsWith('http://') && !remoteUrl.startsWith('https://'))
  ) {
    return remoteUrl;
  }
  if (Platform.OS === 'web') {
    return remoteUrl;
  }
  await ensureCacheDirExists();
  const filename = await getCacheFilename(remoteUrl);
  const localUri = `${CACHE_DIR}${filename}`;
  const fileInfo = await FileSystem.getInfoAsync(localUri);
  if (fileInfo.exists) {
    return localUri;
  } else {
    const downloadedUri = await downloadWithRetry(remoteUrl, localUri);
    if (downloadedUri) {
      return downloadedUri;
    } else {
      const partialFileInfo = await FileSystem.getInfoAsync(localUri);
      if (partialFileInfo.exists) {
        await FileSystem.deleteAsync(localUri, { idempotent: true });
      }
      logCacheOperation('CACHE_MISS_FAILED', {
        url: remoteUrl,
        filename,
        error: 'Download failed after all retries',
      });
      return null;
    }
  }
}
export async function initImageCache() {
  if (Platform.OS === 'web') {
    return;
  }
  await ensureCacheDirExists();
  cleanCache().catch((error) => {
    logCacheOperation('CACHE_CLEAN_ERROR', { error: error.message });
  });
}
export async function removeImageFromCache(remoteUrl: string) {
  if (!remoteUrl || typeof remoteUrl !== 'string') return;
  if (Platform.OS === 'web') {
    return;
  }
  try {
    const filename = await getCacheFilename(remoteUrl);
    const localUri = `${CACHE_DIR}${filename}`;
    await FileSystem.deleteAsync(localUri, { idempotent: true });
  } catch (error) {
    logCacheOperation('CACHE_ITEM_REMOVE_FAILED', {
      url: remoteUrl,
      error: error.message,
    });
  }
}
export async function clearImageCache() {
  try {
    await FileSystem.deleteAsync(CACHE_DIR, { idempotent: true });
    await ensureCacheDirExists();
  } catch (error) {
    logCacheOperation('CACHE_CLEAR_FAILED', {
      error: error.message,
    });
  }
}
export async function prefetchImages(
  imagePaths: string[],
  options: {
    maxConcurrent?: number;
    skipExisting?: boolean;
    onProgress?: (completed: number, total: number) => void;
  } = {},
) {
  const { maxConcurrent = 5, skipExisting = true, onProgress } = options;
  if (!imagePaths || imagePaths.length === 0) {
    return;
  }
  let completed = 0;
  let failed = 0;
  const processSingleImage = async (imagePath: string) => {
    try {
      const { getImageUrl } = await import('./imageUtils');
      const fullUrl = await getImageUrl(imagePath);
      if (!fullUrl) {
        failed++;
        return;
      }
      if (skipExisting) {
        const filename = await getCacheFilename(fullUrl);
        const localUri = `${CACHE_DIR}${filename}`;
        const fileInfo = await FileSystem.getInfoAsync(localUri);
        if (fileInfo.exists) {
          return;
        }
      }
      const result = await getCachedImageUri(fullUrl);
      if (!result) {
        failed++;
      }
    } catch (error) {
      failed++;
    } finally {
      completed++;
      onProgress?.(completed, imagePaths.length);
    }
  };
  const batches = [];
  for (let i = 0; i < imagePaths.length; i += maxConcurrent) {
    const batch = imagePaths.slice(i, i + maxConcurrent);
    batches.push(batch);
  }
  for (const batch of batches) {
    await Promise.all(batch.map(processSingleImage));
  }
  if (failed > 0) {
    logCacheOperation('PREFETCH_FAILED', {
      totalImages: imagePaths.length,
      failed,
      successRate: `${((1 - failed / imagePaths.length) * 100).toFixed(1)}%`,
    });
  }
}
export async function prefetchMenuImages(
  menuData: any[],
  options?: {
    maxConcurrent?: number;
    onProgress?: (completed: number, total: number) => void;
  },
) {
  const imagePaths: string[] = [];
  menuData.forEach((category) => {
    if (category.photo?.path) {
      imagePaths.push(category.photo.path);
    }
    if (category.subcategories) {
      category.subcategories.forEach((subcategory) => {
        if (subcategory.photo?.path) {
          imagePaths.push(subcategory.photo.path);
        }
        if (subcategory.products) {
          subcategory.products.forEach((product) => {
            if (product.photo?.path) {
              imagePaths.push(product.photo.path);
            }
          });
        }
      });
    }
  });
  if (imagePaths.length > 0) {
    await prefetchImages(imagePaths, {
      ...options,
      skipExisting: true,
    });
  }
}

================
File: app/src/app/store/authStore.ts
================
import { create } from 'zustand';
import EncryptedStorage from '@/app/services/secureStorageService';
import type { User } from '../../modules/auth/schema/auth.schema';
import * as ScreenOrientation from 'expo-screen-orientation';
const AUTH_TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';
const USER_INFO_KEY = 'user_info';
export interface AuthState {
  isAuthenticated: boolean;
  accessToken: string | null;
  refreshToken: string | null;
  user: User | null;
  setTokens: (
    accessToken: string,
    refreshToken: string,
    user: User | null,
  ) => Promise<void>;
  setAccessToken: (accessToken: string) => Promise<void>;
  setRefreshToken: (refreshToken: string) => Promise<void>;
  setUser: (user: User | null) => Promise<void>;
  logout: () => Promise<void>;
}
export const useAuthStore = create<AuthState>((set) => ({
  isAuthenticated: false,
  accessToken: null,
  refreshToken: null,
  user: null,
  setTokens: async (
    accessToken: string,
    refreshToken: string,
    user: User | null,
  ) => {
    if (user && 'isActive' in user && !user.isActive) {
      throw new Error('Usuario inactivo');
    }
    await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);
    await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
    if (user) {
      await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
    } else {
      await EncryptedStorage.removeItem(USER_INFO_KEY);
    }
    set({
      accessToken,
      refreshToken,
      user: user ?? null,
      isAuthenticated: true,
    });
  },
  setAccessToken: async (accessToken: string) => {
    try {
      await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);
      set({ accessToken, isAuthenticated: true });
    } catch (error) {
    }
  },
  setRefreshToken: async (refreshToken: string) => {
    try {
      await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
      set({ refreshToken });
    } catch (error) {
    }
  },
  setUser: async (user: User | null) => {
    try {
      if (user) {
        if ('isActive' in user && !user.isActive) {
          await useAuthStore.getState().logout();
          return;
        }
        await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
      } else {
        await EncryptedStorage.removeItem(USER_INFO_KEY);
      }
      set({ user });
    } catch (error) {
    }
  },
  logout: async () => {
    const ORIENTATION_DELAYS = {
      UNLOCK: 100,
      LOCK: 200,
    };
    const clearAuthData = async () => {
      await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
      await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
      await EncryptedStorage.removeItem(USER_INFO_KEY);
      set({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });
    };
    try {
      await ScreenOrientation.unlockAsync();
      await new Promise((resolve) =>
        setTimeout(resolve, ORIENTATION_DELAYS.UNLOCK),
      );
      await ScreenOrientation.lockAsync(
        ScreenOrientation.OrientationLock.PORTRAIT_UP,
      );
      await new Promise((resolve) =>
        setTimeout(resolve, ORIENTATION_DELAYS.LOCK),
      );
      await clearAuthData();
    } catch (error) {
      try {
        await clearAuthData();
      } catch (fallbackError) {
      }
    }
  },
}));
export const initializeAuthStore = async () => {
  try {
    const accessToken = await EncryptedStorage.getItem(AUTH_TOKEN_KEY);
    const refreshToken = await EncryptedStorage.getItem(REFRESH_TOKEN_KEY);
    const userInfoString = await EncryptedStorage.getItem(USER_INFO_KEY);
    let user: User | null = null;
    if (userInfoString) {
      try {
        user = JSON.parse(userInfoString);
      } catch (parseError) {
        await EncryptedStorage.removeItem(USER_INFO_KEY);
      }
    }
    if (accessToken && refreshToken) {
      if (user && 'isActive' in user && !user.isActive) {
        await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
        await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
        await EncryptedStorage.removeItem(USER_INFO_KEY);
        useAuthStore.setState({
          accessToken: null,
          refreshToken: null,
          user: null,
          isAuthenticated: false,
        });
        return;
      }
      useAuthStore.setState({
        accessToken,
        refreshToken,
        user,
        isAuthenticated: true,
      });
    } else {
      useAuthStore.setState({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });
    }
  } catch (error) {
    useAuthStore.setState({
      accessToken: null,
      refreshToken: null,
      user: null,
      isAuthenticated: false,
    });
  }
};

================
File: app/src/components/AudioOrderModal.tsx
================
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  ActivityIndicator,
  Dimensions,
  TouchableOpacity,
  Animated,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Divider,
  Surface,
  IconButton,
} from 'react-native-paper';
import { MaterialIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { useGetOrderMenu } from '@/modules/orders/hooks/useMenuQueries';
import type {
  AIOrderItem,
  DeliveryInfoData,
  ScheduledDeliveryData,
} from '@/services/audioOrderService';
import ProductCustomizationModal from '@/modules/orders/components/ProductCustomizationModal';
import type { FullMenuProduct as Product } from '@/modules/orders/types/orders.types';
import type {
  CartItem,
  CartItemModifier,
} from '@/modules/orders/stores/useCartStore';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import {
  Swipeable,
  type Animated as GestureAnimated,
} from 'react-native-gesture-handler';
import {
  OrderTypeEnum,
  type OrderType,
} from '@/modules/orders/types/orders.types';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import { useGetAreas } from '@/modules/areasTables/services/areaService';
import { useGetTablesByArea } from '@/modules/areasTables/services/tableService';
import type {
  Area,
  Table,
} from '@/modules/areasTables/types/areasTables.types';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import { Menu, Checkbox, HelperText } from 'react-native-paper';
import type { DeliveryInfo } from '@/app/schemas/domain/delivery-info.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
interface AudioOrderModalProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: (
    items: AIOrderItem[],
    deliveryInfo?: DeliveryInfoData,
    scheduledDelivery?: ScheduledDeliveryData,
    orderType?: OrderType,
  ) => void;
  isProcessing: boolean;
  orderData?: {
    orderItems?: AIOrderItem[];
    deliveryInfo?: DeliveryInfoData;
    scheduledDelivery?: ScheduledDeliveryData;
    orderType?: OrderType;
    warnings?: string;
    processingTime?: number;
  };
  error?: string;
}
const { width: screenWidth, height: screenHeight } = Dimensions.get('window');
const modalWidth = Math.min(screenWidth * 0.95, 500);
export const AudioOrderModal: React.FC<AudioOrderModalProps> = ({
  visible,
  onDismiss,
  onConfirm,
  isProcessing,
  orderData,
  error,
}) => {
  const theme = useAppTheme();
  const { colors } = theme;
  const [editableDeliveryInfo, setEditableDeliveryInfo] =
    useState<DeliveryInfo>({});
  const [editableItems, setEditableItems] = useState<AIOrderItem[]>([]);
  const [editableOrderType, setEditableOrderType] = useState<OrderType>(
    OrderTypeEnum.DINE_IN,
  );
  const [editableSelectedAreaId, setEditableSelectedAreaId] = useState<
    string | null
  >(null);
  const [editableSelectedTableId, setEditableSelectedTableId] = useState<
    string | null
  >(null);
  const [editableIsTemporaryTable, setEditableIsTemporaryTable] =
    useState<boolean>(false);
  const [editableTemporaryTableName, setEditableTemporaryTableName] =
    useState<string>('');
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [editingProduct, setEditingProduct] = useState<Product | null>(null);
  const [showCustomizationModal, setShowCustomizationModal] = useState(false);
  // Estados para validación de productos
  const [itemsWithErrors, setItemsWithErrors] = useState<Set<number>>(
    new Set(),
  );
  const [itemValidationErrors, setItemValidationErrors] = useState<
    Record<number, string[]>
  >({});
  // Estados de error
  const [areaError, setAreaError] = useState<string | null>(null);
  const [tableError, setTableError] = useState<string | null>(null);
  const [recipientNameError, setRecipientNameError] = useState<string | null>(
    null,
  );
  const [recipientPhoneError, setRecipientPhoneError] = useState<string | null>(
    null,
  );
  const [addressError, setAddressError] = useState<string | null>(null);
  // Estado para modal de confirmación de salida
  const [showExitConfirmationModal, setShowExitConfirmationModal] =
    useState(false);
  // Estados de menús
  const [areaMenuVisible, setAreaMenuVisible] = useState(false);
  const [tableMenuVisible, setTableMenuVisible] = useState(false);
  const { data: menu } = useGetOrderMenu();
  // Queries para áreas y mesas
  const {
    data: areasData,
    isLoading: isLoadingAreas,
    error: errorAreas,
  } = useGetAreas();
  const {
    data: tablesData,
    isLoading: isLoadingTables,
    error: errorTables,
  } = useGetTablesByArea(editableSelectedAreaId);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  // Nombres computed para área y mesa
  const selectedAreaName = useMemo(
    () => areasData?.find((a: Area) => a.id === editableSelectedAreaId)?.name,
    [areasData, editableSelectedAreaId],
  );
  const selectedTableName = useMemo(() => {
    return tablesData?.find((t) => t.id === editableSelectedTableId)?.name;
  }, [tablesData, editableSelectedTableId]);
  // Función para validar un producto según las reglas del ProductCustomizationModal
  const validateProductItem = useCallback(
    (item: AIOrderItem, product?: Product) => {
      if (!menu || !product) return [];
      const errors: string[] = [];
      // 1. Validar variante requerida
      if (
        product.hasVariants &&
        product.variants &&
        product.variants.length > 0
      ) {
        if (!item.variantId) {
          errors.push('Variante requerida');
        }
      }
      if (product.modifierGroups && product.modifierGroups.length > 0) {
        for (const group of product.modifierGroups) {
          const selectedModifiersInGroup = (item.modifiers || []).filter(
            (modName) => {
              return group.productModifiers?.some((pm) => pm.name === modName);
            },
          );
          const selectedCount = selectedModifiersInGroup.length;
          const minRequired = Math.max(
            group.minSelections || 0,
            group.isRequired ? 1 : 0,
          );
          if (selectedCount < minRequired) {
            if (group.isRequired && minRequired === 1) {
              errors.push(`${group.name}: Requerido`);
            } else {
              errors.push(`${group.name}: Mínimo ${minRequired}`);
            }
          }
          if (group.maxSelections && selectedCount > group.maxSelections) {
            errors.push(`${group.name}: Máximo ${group.maxSelections}`);
          }
        }
      }
      if (
        product.category?.name?.toLowerCase().includes('pizza') &&
        item.pizzaCustomizations
      ) {
        const validCustomizations = item.pizzaCustomizations.filter(
          (custom) => custom.customizationId && custom.action,
        );
        if (validCustomizations.length === 0) {
          errors.push('Pizza requiere personalizaciones');
        }
      }
      return errors;
    },
    [menu],
  );
  const findProductInMenu = useCallback(
    (productId: string): Product | undefined => {
      if (!menu) return undefined;
      for (const category of menu) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            if (product.id === productId) {
              return product;
            }
          }
        }
      }
      return undefined;
    },
    [menu],
  );
  useEffect(() => {
    if (!editableItems || editableItems.length === 0) {
      setItemsWithErrors(new Set());
      setItemValidationErrors({});
      return;
    }
    const newItemsWithErrors = new Set<number>();
    const newValidationErrors: Record<number, string[]> = {};
    editableItems.forEach((item, index) => {
      const product = findProductInMenu(item.productId);
      const errors = validateProductItem(item, product);
      if (errors.length > 0) {
        newItemsWithErrors.add(index);
        newValidationErrors[index] = errors;
      }
    });
    setItemsWithErrors(newItemsWithErrors);
    setItemValidationErrors(newValidationErrors);
  }, [editableItems, findProductInMenu, validateProductItem]);
  const hasValidationErrors = useMemo(() => {
    return itemsWithErrors.size > 0;
  }, [itemsWithErrors]);
  const hasUnsavedChanges = useMemo(() => {
    return (
      editableItems.length > 0 ||
      editableDeliveryInfo.recipientName?.trim() ||
      editableDeliveryInfo.recipientPhone?.trim() ||
      editableDeliveryInfo.fullAddress?.trim() ||
      editableSelectedAreaId ||
      editableSelectedTableId ||
      editableTemporaryTableName?.trim()
    );
  }, [
    editableItems.length,
    editableDeliveryInfo.recipientName,
    editableDeliveryInfo.recipientPhone,
    editableDeliveryInfo.fullAddress,
    editableSelectedAreaId,
    editableSelectedTableId,
    editableTemporaryTableName,
  ]);
  useEffect(() => {
    if (orderData?.deliveryInfo) {
      setEditableDeliveryInfo(orderData.deliveryInfo as DeliveryInfo);
    }
    if (orderData?.orderItems) {
      setEditableItems(orderData.orderItems);
    }
    if (orderData?.orderType !== undefined) {
      setEditableOrderType(orderData.orderType);
    } else if (orderData) {
      setEditableOrderType(OrderTypeEnum.DELIVERY);
    }
  }, [orderData?.deliveryInfo, orderData?.orderItems, orderData?.orderType]);
  useEffect(() => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
  }, [editableOrderType]);
  const handleConfirm = () => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
    if (editableItems && editableItems.length > 0) {
      if (hasValidationErrors) {
        showSnackbar({
          message:
            'Hay productos con errores que deben corregirse antes de continuar',
          type: 'error',
        });
        return;
      }
      const adaptedDeliveryInfo: DeliveryInfoData = {
        recipientName: editableDeliveryInfo.recipientName,
        recipientPhone: editableDeliveryInfo.recipientPhone,
        fullAddress: editableDeliveryInfo.fullAddress,
      };
      onConfirm(
        editableItems,
        adaptedDeliveryInfo,
        orderData?.scheduledDelivery,
        editableOrderType,
      );
    }
  };
  const updateItemQuantity = useCallback(
    (itemId: string, index: number, newQuantity: number) => {
      if (newQuantity < 1) {
        return;
      }
      setEditableItems((prev) =>
        prev.map((item, i) => {
          if (i === index) {
            return { ...item, quantity: newQuantity };
          }
          return item;
        }),
      );
    },
    [],
  );
  const removeItem = useCallback(
    (index: number) => {
      setEditableItems((prev) => prev.filter((_, i) => i !== index));
      showSnackbar({
        message: 'Producto eliminado',
        type: 'info',
      });
    },
    [showSnackbar],
  );
  const handleEditItem = useCallback(
    (item: AIOrderItem, index: number) => {
      if (!menu) {
        showSnackbar({
          message: 'El menú no está disponible',
          type: 'error',
        });
        return;
      }
      let foundProduct: Product | null = null;
      outer: for (const category of menu) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            if (product.id === item.productId) {
              foundProduct = product;
              break outer;
            }
          }
        }
      }
      if (!foundProduct) {
        showSnackbar({
          message: 'Producto no encontrado en el menú',
          type: 'error',
        });
        return;
      }
      const cartItem: CartItem = {
        id: `${item.productId}-${index}`,
        productId: item.productId,
        productName: foundProduct.name,
        quantity: item.quantity,
        unitPrice:
          foundProduct.variants?.find((v) => v.id === item.variantId)?.price ||
          foundProduct.price ||
          0,
        totalPrice: 0,
        modifiers:
          item.modifiers?.map((modName) => {
            for (const modGroup of foundProduct.modifierGroups || []) {
              const modifier = modGroup.productModifiers?.find(
                (m) => m.name === modName,
              );
              if (modifier) {
                return {
                  id: modifier.id,
                  modifierGroupId: modGroup.id,
                  name: modifier.name,
                  price: modifier.price || 0,
                };
              }
            }
            return {
              id: modName,
              modifierGroupId: '',
              name: modName,
              price: 0,
            };
          }) || [],
        variantId: item.variantId,
        variantName: foundProduct.variants?.find((v) => v.id === item.variantId)
          ?.name,
        selectedPizzaCustomizations: item.pizzaCustomizations?.map((pc) => ({
          pizzaCustomizationId: pc.customizationId,
          half: pc.half as any,
          action: pc.action as any,
        })),
      };
      setEditingItem(cartItem);
      setEditingProduct(foundProduct);
      setShowCustomizationModal(true);
    },
    [menu, showSnackbar],
  );
  // Función para manejar la actualización desde el modal
  const handleUpdateEditedItem = useCallback(
    (
      itemId: string,
      quantity: number,
      modifiers: CartItemModifier[],
      preparationNotes?: string,
      variantId?: string,
      variantName?: string,
      unitPrice?: number,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    ) => {
      const index = parseInt(itemId.split('-').pop() || '0');
      setEditableItems((prev) =>
        prev.map((item, i) => {
          if (i === index) {
            return {
              ...item,
              quantity,
              variantId,
              modifiers: modifiers.map((m) => m.name),
              pizzaCustomizations: selectedPizzaCustomizations?.map((pc) => ({
                customizationId: pc.pizzaCustomizationId,
                half: pc.half,
                action: pc.action,
              })),
            };
          }
          return item;
        }),
      );
      setShowCustomizationModal(false);
      setEditingItem(null);
      setEditingProduct(null);
      showSnackbar({
        message: 'Producto actualizado',
        type: 'success',
      });
    },
    [showSnackbar],
  );
  const handleAttemptExit = useCallback(() => {
    if (!hasUnsavedChanges) {
      onDismiss();
    } else {
      setShowExitConfirmationModal(true);
    }
  }, [hasUnsavedChanges, onDismiss]);
  const handleConfirmExit = useCallback(() => {
    setShowExitConfirmationModal(false);
    onDismiss();
  }, [onDismiss]);
  const handleCancelExit = useCallback(() => {
    setShowExitConfirmationModal(false);
  }, []);
  const getProductDetails = (productId: string, variantId?: string) => {
    if (!menu)
      return {
        productName: `Producto ${productId.slice(-4)}`,
        variantName: undefined,
      };
    for (const category of menu) {
      for (const subcategory of category.subcategories || []) {
        for (const product of subcategory.products || []) {
          if (product.id === productId) {
            const variant = variantId
              ? product.variants?.find((v) => v.id === variantId)
              : undefined;
            return {
              productName: product.name,
              variantName: variant?.name,
            };
          }
        }
      }
    }
    return {
      productName: `Producto ${productId.slice(-4)}`,
      variantName: undefined,
    };
  };
  const formatPizzaCustomizations = (
    customizations?: AIOrderItem['pizzaCustomizations'],
  ) => {
    if (!customizations || customizations.length === 0) return '';
    const groupedByHalf = customizations.reduce(
      (acc, curr) => {
        const half = curr.half || 'FULL';
        if (!acc[half]) {
          acc[half] = { ingredients: [] };
        }
        let name = curr.customizationName;
        if (!name && menu) {
          outer: for (const category of menu) {
            for (const subcategory of category.subcategories || []) {
              for (const product of subcategory.products || []) {
                if (product.pizzaCustomizations) {
                  const customization = product.pizzaCustomizations.find(
                    (pc) => pc.id === curr.customizationId,
                  );
                  if (customization) {
                    name = customization.name;
                    break outer;
                  }
                }
              }
            }
          }
        }
        if (!name) {
          name = curr.customizationId.slice(-4);
        }
        const prefix = curr.action === 'ADD' ? '+ ' : '- ';
        acc[half].ingredients.push(prefix + name);
        return acc;
      },
      {} as Record<string, { ingredients: string[] }>,
    );
    if (groupedByHalf.FULL) {
      return groupedByHalf.FULL.ingredients.join(', ');
    } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
      const half1 = groupedByHalf.HALF_1
        ? `Mitad 1: ${groupedByHalf.HALF_1.ingredients.join(', ')}`
        : '';
      const half2 = groupedByHalf.HALF_2
        ? `Mitad 2: ${groupedByHalf.HALF_2.ingredients.join(', ')}`
        : '';
      return [half1, half2].filter(Boolean).join(' / ');
    }
    return '';
  };
  const renderProcessingState = () => (
    <View style={styles.processingContainer}>
      <View style={styles.processingContent}>
        <MaterialIcons
          name="mic"
          size={80}
          color={colors.primary}
          style={styles.processingIcon}
        />
        <ActivityIndicator
          size="large"
          color={colors.primary}
          style={styles.processingSpinner}
        />
        <Text style={[styles.processingTitle, { color: colors.onSurface }]}>
          Analizando tu solicitud
        </Text>
        <Text
          style={[styles.processingSubtext, { color: colors.onSurfaceVariant }]}
        >
          Extrayendo productos y detalles de tu pedido por voz...
        </Text>
        <View style={styles.processingSteps}>
          <View style={styles.processingStep}>
            <MaterialIcons name="hearing" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Transcribiendo audio
            </Text>
          </View>
          <View style={styles.processingStep}>
            <MaterialIcons name="psychology" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Analizando productos
            </Text>
          </View>
          <View style={styles.processingStep}>
            <MaterialIcons name="list-alt" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Generando orden
            </Text>
          </View>
        </View>
        <Text
          style={[styles.processingFooter, { color: colors.onSurfaceVariant }]}
        >
          ⏱️ Esto puede tomar unos segundos
        </Text>
      </View>
    </View>
  );
  const renderErrorState = () => (
    <View style={styles.errorContainer}>
      <View style={styles.errorContent}>
        <MaterialIcons name="error-outline" size={80} color={colors.error} />
        <Text style={[styles.errorTitle, { color: colors.error }]}>
          No se pudo procesar tu solicitud
        </Text>
        <Text style={[styles.errorMessage, { color: colors.onSurfaceVariant }]}>
          {error}
        </Text>
        <View style={styles.errorActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={styles.errorButton}
            icon="refresh"
          >
            Intentar de nuevo
          </Button>
          <Button
            mode="contained"
            onPress={handleAttemptExit}
            style={styles.errorButton}
            icon="close"
          >
            Cerrar
          </Button>
        </View>
        <Text style={[styles.errorFooter, { color: colors.onSurfaceVariant }]}>
          💡 Asegúrate de hablar claramente y mencionar los productos que deseas
        </Text>
      </View>
    </View>
  );
  const renderOrderSummary = () => {
    if (!orderData) return null;
    const { scheduledDelivery, warnings } = orderData;
    return (
      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
      >
        {/* Header con tiempo de procesamiento - REMOVIDO */}
        {/* Tipo de Orden - Always visible at top */}
        <View style={styles.orderTypeSection}>
          <View style={styles.compactSectionHeader}>
            <MaterialIcons name="restaurant" size={20} color={colors.primary} />
            <Text
              style={[styles.compactSectionTitle, { color: colors.onSurface }]}
            >
              Tipo de Orden
            </Text>
          </View>
          <View style={styles.orderTypeButtons}>
            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.DINE_IN &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.DINE_IN
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.DINE_IN)}
            >
              <MaterialIcons
                name="restaurant"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.DINE_IN
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.DINE_IN
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Comer aquí
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.TAKE_AWAY &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.TAKE_AWAY
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.TAKE_AWAY)}
            >
              <MaterialIcons
                name="shopping-bag"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.TAKE_AWAY
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.TAKE_AWAY
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Para llevar
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.DELIVERY &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.DELIVERY
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.DELIVERY)}
            >
              <MaterialIcons
                name="moped"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.DELIVERY
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.DELIVERY
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Domicilio
              </Text>
            </TouchableOpacity>
          </View>
        </View>
        {/* Renderizado condicional según tipo de orden - EXACTAMENTE como OrderCartDetail */}
        {editableOrderType === OrderTypeEnum.DINE_IN && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons
                name="restaurant"
                size={20}
                color={colors.primary}
              />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Mesa y Área
              </Text>
            </View>
            <View style={styles.compactDeliveryContainer}>
              {/* Área y Mesa en la misma fila */}
              <View style={styles.dineInSelectorsRow}>
                {/* Área */}
                <View style={styles.dineInSelectorContainer}>
                  <Menu
                    visible={areaMenuVisible}
                    onDismiss={() => setAreaMenuVisible(false)}
                    anchor={
                      <AnimatedLabelSelector
                        label="Área *"
                        value={selectedAreaName}
                        onPress={() => setAreaMenuVisible(true)}
                        isLoading={isLoadingAreas}
                        error={!!areaError || !!errorAreas}
                        disabled={isLoadingAreas}
                      />
                    }
                  >
                    {areasData?.map((area: Area) => (
                      <Menu.Item
                        key={area.id}
                        onPress={() => {
                          setEditableSelectedAreaId(area.id);
                          setEditableSelectedTableId(null);
                          setAreaMenuVisible(false);
                          setAreaError(null);
                        }}
                        title={area.name}
                      />
                    ))}
                    {errorAreas && (
                      <Menu.Item title="Error al cargar áreas" disabled />
                    )}
                  </Menu>
                  {areaError && !errorAreas && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {areaError}
                    </HelperText>
                  )}
                  {errorAreas && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      Error al cargar áreas
                    </HelperText>
                  )}
                </View>
                {/* Mesa */}
                <View style={styles.dineInSelectorContainer}>
                  <Menu
                    visible={tableMenuVisible}
                    onDismiss={() => setTableMenuVisible(false)}
                    anchor={
                      <AnimatedLabelSelector
                        label="Mesa *"
                        value={selectedTableName}
                        onPress={() => setTableMenuVisible(true)}
                        isLoading={isLoadingTables}
                        error={!!tableError || !!errorTables}
                        disabled={
                          !editableSelectedAreaId ||
                          isLoadingTables ||
                          isLoadingAreas ||
                          editableIsTemporaryTable
                        }
                      />
                    }
                  >
                    {tablesData?.map((table: Table) => (
                      <Menu.Item
                        key={table.id}
                        onPress={() => {
                          if (table.isAvailable) {
                            setEditableSelectedTableId(table.id);
                            setTableMenuVisible(false);
                            setTableError(null);
                          }
                        }}
                        title={`${table.name}${!table.isAvailable ? ' (Ocupada)' : ''}`}
                        disabled={!table.isAvailable}
                        titleStyle={
                          !table.isAvailable
                            ? { color: colors.error }
                            : undefined
                        }
                      />
                    ))}
                    {editableSelectedAreaId &&
                      tablesData?.length === 0 &&
                      !isLoadingTables &&
                      !errorTables && (
                        <Menu.Item title="No hay mesas" disabled />
                      )}
                    {errorTables && (
                      <Menu.Item title="Error al cargar mesas" disabled />
                    )}
                  </Menu>
                  {tableError && !errorTables && !editableIsTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                  {errorTables && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      Error al cargar mesas
                    </HelperText>
                  )}
                </View>
              </View>
              {/* Opción de mesa temporal */}
              <TouchableOpacity
                onPress={() => {
                  setEditableIsTemporaryTable(!editableIsTemporaryTable);
                  if (!editableIsTemporaryTable) {
                    setEditableSelectedTableId(null);
                    setTableError(null);
                  } else {
                    setEditableTemporaryTableName('');
                  }
                }}
                style={styles.checkboxContainer}
              >
                <Checkbox.Android
                  status={editableIsTemporaryTable ? 'checked' : 'unchecked'}
                  onPress={() => {
                    setEditableIsTemporaryTable(!editableIsTemporaryTable);
                    if (!editableIsTemporaryTable) {
                      setEditableSelectedTableId(null);
                      setTableError(null);
                    } else {
                      setEditableTemporaryTableName('');
                    }
                  }}
                  color={colors.primary}
                />
                <Text style={styles.checkboxLabel}>Crear mesa temporal</Text>
              </TouchableOpacity>
              {/* Campo para nombre de mesa temporal */}
              {editableIsTemporaryTable && (
                <View style={styles.temporaryTableInputContainer}>
                  <SpeechRecognitionInput
                    label="Nombre de la Mesa Temporal *"
                    value={editableTemporaryTableName}
                    onChangeText={(text) => {
                      setEditableTemporaryTableName(text);
                      if (tableError) setTableError(null);
                    }}
                    error={!!tableError && editableIsTemporaryTable}
                    speechLang="es-MX"
                    autoCapitalize="words"
                    autoCorrect={false}
                    placeholder="Ej: Mesa Terraza 1"
                    style={styles.compactTextInput}
                    dense
                  />
                  {tableError && editableIsTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                </View>
              )}
            </View>
          </View>
        )}
        {/* Para llevar - Solo nombre del cliente */}
        {editableOrderType === OrderTypeEnum.TAKE_AWAY && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons name="person" size={20} color={colors.primary} />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Información del Cliente
              </Text>
            </View>
            <View style={styles.compactDeliveryContainer}>
              <SpeechRecognitionInput
                label="Nombre del Cliente *"
                value={editableDeliveryInfo.recipientName || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientName: text,
                  }));
                  if (recipientNameError) setRecipientNameError(null);
                }}
                error={!!recipientNameError}
                speechLang="es-MX"
                autoCapitalize="words"
                autoCorrect={false}
                style={styles.compactTextInput}
                dense
              />
              {recipientNameError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientNameError}
                </HelperText>
              )}
              <SpeechRecognitionInput
                label="Teléfono (Opcional)"
                value={editableDeliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientPhone: text,
                  }));
                  if (recipientPhoneError) setRecipientPhoneError(null);
                }}
                error={!!recipientPhoneError}
                speechLang="es-MX"
                keyboardType="phone-pad"
                style={styles.compactTextInput}
                dense
              />
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>
          </View>
        )}
        {/* Domicilio - Solo dirección y teléfono */}
        {editableOrderType === OrderTypeEnum.DELIVERY && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons
                name="local-shipping"
                size={20}
                color={colors.primary}
              />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Información de Entrega
              </Text>
            </View>
            <View style={styles.compactDeliveryContainer}>
              <SpeechRecognitionInput
                label="Dirección completa *"
                value={editableDeliveryInfo.fullAddress || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    fullAddress: text,
                  }));
                  if (addressError) setAddressError(null);
                }}
                error={!!addressError}
                speechLang="es-MX"
                multiline
                numberOfLines={2}
                style={styles.compactTextInput}
                dense
              />
              {addressError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {addressError}
                </HelperText>
              )}
              <SpeechRecognitionInput
                label="Teléfono *"
                value={editableDeliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientPhone: text,
                  }));
                  if (recipientPhoneError) setRecipientPhoneError(null);
                }}
                error={!!recipientPhoneError}
                speechLang="es-MX"
                keyboardType="phone-pad"
                style={styles.compactTextInput}
                dense
              />
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>
          </View>
        )}
        {/* Advertencias */}
        {warnings && (
          <Surface
            style={[
              styles.warningContainer,
              { backgroundColor: colors.tertiaryContainer },
            ]}
          >
            <MaterialIcons name="warning" size={20} color={colors.tertiary} />
            <Text
              style={[
                styles.warningText,
                { color: colors.onTertiaryContainer },
              ]}
            >
              {warnings}
            </Text>
          </Surface>
        )}
        {/* Items de la orden - Versión compacta */}
        <View
          style={[
            styles.compactSectionContainer,
            { borderTopWidth: 1, borderTopColor: colors.primary + '40' },
          ]}
        >
          <View style={styles.compactSectionHeader}>
            <MaterialIcons
              name="restaurant-menu"
              size={20}
              color={colors.primary}
            />
            <Text
              style={[styles.compactSectionTitle, { color: colors.onSurface }]}
            >
              Productos ({editableItems.length})
            </Text>
          </View>
          {editableItems.length === 0 ? (
            <View style={styles.emptyContainerCompact}>
              <MaterialIcons
                name="mic-off"
                size={32}
                color={colors.onSurfaceVariant}
              />
              <Text
                style={[
                  styles.emptyTextCompact,
                  { color: colors.onSurfaceVariant },
                ]}
              >
                No se detectaron productos
              </Text>
            </View>
          ) : (
            <View style={styles.compactItemsList}>
              {editableItems.map((item, index) => {
                const itemKey = `${item.productId}-${index}`;
                const { productName, variantName } = getProductDetails(
                  item.productId,
                  item.variantId,
                );
                const pizzaCustomizationsText = formatPizzaCustomizations(
                  item.pizzaCustomizations,
                );
                const renderRightActions = (
                  _progress: Animated.AnimatedAddition,
                  dragX: Animated.AnimatedAddition,
                ) => {
                  const translateX = dragX.interpolate({
                    inputRange: [-100, 0],
                    outputRange: [0, 100],
                    extrapolate: 'clamp',
                  });
                  const scale = dragX.interpolate({
                    inputRange: [-100, -50, 0],
                    outputRange: [1, 0.8, 0.5],
                    extrapolate: 'clamp',
                  });
                  const opacity = dragX.interpolate({
                    inputRange: [-100, -20, 0],
                    outputRange: [1, 0.5, 0],
                    extrapolate: 'clamp',
                  });
                  return (
                    <Animated.View
                      style={[
                        styles.deleteActionContainer,
                        {
                          opacity,
                          transform: [{ translateX }],
                        },
                      ]}
                    >
                      <Animated.View
                        style={[
                          styles.deleteAction,
                          {
                            backgroundColor: colors.error,
                            transform: [{ scale }],
                          },
                        ]}
                      >
                        <View style={styles.deleteIconContainer}>
                          <IconButton
                            icon="delete-sweep"
                            size={28}
                            iconColor="white"
                            style={styles.deleteIcon}
                          />
                        </View>
                        <Text style={styles.deleteActionText}>ELIMINAR</Text>
                      </Animated.View>
                    </Animated.View>
                  );
                };
                return (
                  <View key={itemKey}>
                    <Swipeable
                      renderRightActions={renderRightActions}
                      overshootRight={false}
                      friction={2}
                      rightThreshold={90}
                      leftThreshold={100}
                      onSwipeableOpen={(direction) => {
                        if (direction === 'right') {
                          setTimeout(() => {
                            removeItem(index);
                          }, 150);
                        }
                      }}
                    >
                      <TouchableOpacity
                        onPress={() => handleEditItem(item, index)}
                        activeOpacity={0.7}
                        style={[
                          styles.compactItemContainer,
                          itemsWithErrors.has(index) && {
                            borderWidth: 1,
                            borderColor: colors.error,
                            backgroundColor: colors.errorContainer + '20',
                          },
                        ]}
                      >
                        <View style={styles.compactItemContent}>
                          <View style={styles.compactItemLeft}>
                            <Text
                              style={[
                                styles.compactItemTitle,
                                { color: colors.onSurface },
                              ]}
                            >
                              {`${item.quantity}x ${variantName || productName}`}
                            </Text>
                            {}
                            {itemValidationErrors[index] && (
                              <View style={styles.validationErrorsContainer}>
                                {itemValidationErrors[index].map(
                                  (error, errorIdx) => (
                                    <Text
                                      key={errorIdx}
                                      style={[
                                        styles.validationErrorText,
                                        { color: colors.error },
                                      ]}
                                    >
                                      ⚠️ {error}
                                    </Text>
                                  ),
                                )}
                              </View>
                            )}
                            {}
                            {pizzaCustomizationsText && (
                              <Text
                                style={[
                                  styles.compactItemSubtitle,
                                  { color: colors.onSurfaceVariant },
                                ]}
                              >
                                {pizzaCustomizationsText}
                              </Text>
                            )}
                            {}
                            {item.modifiers &&
                              item.modifiers.length > 0 &&
                              item.modifiers.map((mod, idx) => (
                                <Text
                                  key={idx}
                                  style={[
                                    styles.compactItemSubtitle,
                                    { color: colors.onSurfaceVariant },
                                  ]}
                                >
                                  • {mod}
                                </Text>
                              ))}
                          </View>
                          <View style={styles.compactItemRight}>
                            <View style={styles.compactQuantityActions}>
                              <IconButton
                                icon="minus-circle-outline"
                                size={18}
                                onPress={() =>
                                  updateItemQuantity(
                                    item.productId,
                                    index,
                                    item.quantity - 1,
                                  )
                                }
                                style={styles.compactQuantityButton}
                                disabled={item.quantity <= 1}
                              />
                              <Text
                                style={[
                                  styles.compactQuantityText,
                                  { color: colors.onSurface },
                                ]}
                              >
                                {item.quantity}
                              </Text>
                              <IconButton
                                icon="plus-circle-outline"
                                size={18}
                                onPress={() =>
                                  updateItemQuantity(
                                    item.productId,
                                    index,
                                    item.quantity + 1,
                                  )
                                }
                                style={styles.compactQuantityButton}
                              />
                            </View>
                            <IconButton
                              icon="pencil"
                              size={16}
                              onPress={() => handleEditItem(item, index)}
                              style={styles.compactEditButton}
                            />
                          </View>
                        </View>
                      </TouchableOpacity>
                    </Swipeable>
                    {index < editableItems.length - 1 && (
                      <Divider style={styles.compactItemDivider} />
                    )}
                  </View>
                );
              })}
            </View>
          )}
        </View>
        {}
        {scheduledDelivery?.time && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons name="schedule" size={20} color={colors.primary} />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Entrega Programada
              </Text>
            </View>
            <Text
              style={[styles.compactScheduledTime, { color: colors.onSurface }]}
            >
              {scheduledDelivery.time}
            </Text>
          </View>
        )}
      </ScrollView>
    );
  };
  return (
    <>
      {visible && (
        <Portal>
          <Modal
            visible={visible}
            onDismiss={onDismiss}
            contentContainerStyle={[
              styles.modalContainer,
              {
                width: modalWidth,
                backgroundColor: colors.surface,
                maxHeight: screenHeight * 0.9,
                height: screenHeight * 0.85,
                borderWidth: 6,
                borderColor: colors.primary,
                shadowColor: colors.primary,
                shadowOffset: { width: 0, height: 6 },
                shadowOpacity: 0.6,
                shadowRadius: 16,
                elevation: 20,
              },
            ]}
          >
            {}
            <View style={styles.header}>
              <Text style={[styles.title, { color: colors.onSurface }]}>
                {isProcessing && '🎤 Procesando orden por voz...'}
                {error && '⚠️ Error en el procesamiento'}
                {!isProcessing &&
                  !error &&
                  hasValidationErrors &&
                  '⚠️ Revisa los productos'}
                {!isProcessing &&
                  !error &&
                  !hasValidationErrors &&
                  'Agregar a tu orden 🛒'}
              </Text>
              <IconButton
                icon="close"
                size={24}
                onPress={handleAttemptExit}
                style={styles.closeButton}
              />
            </View>
            {}
            {!isProcessing && !error && (
              <Divider style={{ backgroundColor: colors.outlineVariant }} />
            )}
            {isProcessing && renderProcessingState()}
            {error && renderErrorState()}
            {!isProcessing && !error && orderData && renderOrderSummary()}
            {!isProcessing && !error && orderData && (
              <>
                <Divider style={{ backgroundColor: colors.outlineVariant }} />
                <View style={styles.footer}>
                  {editableItems && editableItems.length > 0 ? (
                    <>
                      <Button
                        mode="outlined"
                        onPress={handleAttemptExit}
                        style={styles.footerButton}
                      >
                        Cancelar
                      </Button>
                      <Button
                        mode="contained"
                        onPress={handleConfirm}
                        style={[
                          styles.footerButton,
                          hasValidationErrors && {
                            backgroundColor: colors.error,
                          },
                        ]}
                        icon={hasValidationErrors ? 'alert-circle' : 'plus'}
                        buttonColor={
                          hasValidationErrors ? colors.error : undefined
                        }
                      >
                        {hasValidationErrors ? 'Hay errores' : 'Agregar'}
                      </Button>
                    </>
                  ) : (
                    <Button
                      mode="contained"
                      onPress={handleAttemptExit}
                      style={[styles.footerButton, { flex: 1 }]}
                    >
                      Cerrar
                    </Button>
                  )}
                </View>
              </>
            )}
          </Modal>
          {}
          {showCustomizationModal && editingProduct && editingItem && (
            <ProductCustomizationModal
              visible={showCustomizationModal}
              product={editingProduct}
              editingItem={editingItem}
              onDismiss={() => {
                setShowCustomizationModal(false);
                setEditingItem(null);
                setEditingProduct(null);
              }}
              onAddToCart={() => {}}
              onUpdateItem={handleUpdateEditedItem}
            />
          )}
        </Portal>
      )}
      {}
      <ConfirmationModal
        visible={showExitConfirmationModal}
        title="¿Descartar datos?"
        message="Tienes datos sin guardar. Si sales, se perderán los productos y la información que has modificado. ¿Estás seguro?"
        confirmText="Salir y Descartar"
        cancelText="Cancelar"
        onConfirm={handleConfirmExit}
        onCancel={handleCancelExit}
        onDismiss={handleCancelExit}
        confirmButtonColor={colors.error}
      />
    </>
  );
};
const styles = StyleSheet.create({
  modalContainer: {
    borderRadius: 16,
    alignSelf: 'center',
    flex: 1,
    marginVertical: 16,
    marginHorizontal: 12,
    shadowColor: '#000000',
    shadowOffset: {
      width: 0,
      height: 8,
    },
    shadowOpacity: 0.3,
    shadowRadius: 20,
    elevation: 24,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  closeButton: {
    margin: 0,
  },
  scrollView: {
    flex: 1,
  },
  processingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingVertical: 40,
  },
  processingContent: {
    alignItems: 'center',
    maxWidth: 400,
    width: '100%',
  },
  processingIcon: {
    marginBottom: 16,
    opacity: 0.8,
  },
  processingSpinner: {
    marginBottom: 24,
  },
  processingTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: 12,
    textAlign: 'center',
  },
  processingSubtext: {
    fontSize: 16,
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 22,
  },
  processingSteps: {
    width: '100%',
    marginBottom: 32,
    gap: 16,
  },
  processingStep: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    paddingHorizontal: 16,
  },
  stepText: {
    fontSize: 14,
    flex: 1,
  },
  processingFooter: {
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingVertical: 40,
  },
  errorContent: {
    alignItems: 'center',
    maxWidth: 400,
    width: '100%',
  },
  errorTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginTop: 16,
    marginBottom: 12,
    textAlign: 'center',
  },
  errorMessage: {
    fontSize: 16,
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 22,
  },
  errorActions: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 24,
    width: '100%',
  },
  errorButton: {
    flex: 1,
  },
  errorFooter: {
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
    lineHeight: 20,
  },
  warningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    margin: 16,
    borderRadius: 8,
    gap: 8,
  },
  warningText: {
    flex: 1,
    fontSize: 14,
  },
  sectionCard: {
    margin: 16,
    marginBottom: 8,
  },
  emptyText: {
    textAlign: 'center',
    paddingVertical: 16,
  },
  itemRightContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  expandedContent: {
    paddingLeft: 16,
    paddingRight: 16,
    paddingBottom: 12,
  },
  sectionLabel: {
    fontSize: 12,
    fontWeight: '600',
    marginBottom: 4,
  },
  modifiersContainer: {
    marginTop: 8,
  },
  modifierText: {
    fontSize: 14,
    marginLeft: 8,
    marginVertical: 2,
  },
  pizzaContainer: {
    marginTop: 8,
  },
  customizationRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginVertical: 4,
  },
  customizationChip: {
    height: 24,
  },
  halfText: {
    fontSize: 12,
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    marginVertical: 6,
  },
  infoText: {
    fontSize: 14,
    flex: 1,
  },
  scheduledTime: {
    fontSize: 18,
    fontWeight: '600',
    textAlign: 'center',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 16,
    gap: 12,
  },
  footerButton: {
    flex: 1,
  },
  itemTextContainer: {
    flex: 1,
    paddingRight: 8,
  },
  itemTitleText: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
  },
  itemDescription: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  listItem: {
    paddingVertical: 12,
    paddingHorizontal: 0,
  },
  itemDivider: {
    marginVertical: 8,
  },
  itemActionsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  quantityBadge: {
    backgroundColor: '#E0E0E0',
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
    minWidth: 28,
    alignItems: 'center',
  },
  quantityBadgeText: {
    fontSize: 14,
    fontWeight: '600',
  },
  expandButton: {
    margin: 0,
  },
  deliveryInfoContainer: {
    gap: 12,
  },
  textInput: {
    backgroundColor: 'transparent',
  },
  quantityActions: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  quantityButton: {
    margin: 0,
  },
  quantityTextContainer: {
    minWidth: 24,
    alignItems: 'center',
    justifyContent: 'center',
  },
  quantityText: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
  },
  editButton: {
    margin: 0,
    marginLeft: 8,
  },
  deleteActionContainer: {
    position: 'absolute',
    right: 0,
    top: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
  deleteAction: {
    borderRadius: 8,
    paddingHorizontal: 20,
    paddingVertical: 8,
    marginRight: 16,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  deleteIconContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  deleteIcon: {
    margin: 0,
  },
  deleteActionText: {
    color: 'white',
    fontWeight: '600',
    fontSize: 14,
  },
  emptyContainer: {
    alignItems: 'center',
    paddingVertical: 32,
    gap: 16,
  },
  emptyAddButton: {
    marginTop: 8,
  },
  emptySubtext: {
    fontSize: 14,
    marginTop: 4,
  },
  orderTypeContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    paddingVertical: 8,
  },
  orderTypeChip: {
    paddingHorizontal: 16,
  },
  compactSectionContainer: {
    margin: 16,
    marginBottom: 8,
  },
  compactSectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingBottom: 12,
    gap: 8,
  },
  compactSectionTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  emptyContainerCompact: {
    alignItems: 'center',
    paddingVertical: 24,
    gap: 12,
  },
  emptyTextCompact: {
    fontSize: 14,
    textAlign: 'center',
  },
  compactItemsList: {
    gap: 2,
  },
  compactItemContainer: {
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  compactItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  compactItemLeft: {
    flex: 1,
    paddingRight: 8,
  },
  compactItemTitle: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 2,
  },
  compactItemSubtitle: {
    fontSize: 12,
    marginTop: 1,
    lineHeight: 16,
  },
  compactItemRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  compactQuantityActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  compactQuantityButton: {
    margin: 0,
    width: 32,
    height: 32,
  },
  compactQuantityText: {
    fontSize: 13,
    fontWeight: '600',
    minWidth: 20,
    textAlign: 'center',
  },
  compactEditButton: {
    margin: 0,
    width: 28,
    height: 28,
    marginLeft: 4,
  },
  compactItemDivider: {
    marginVertical: 4,
    marginHorizontal: 12,
  },
  compactDeliveryContainer: {
    gap: 8,
  },
  compactTextInput: {
    backgroundColor: 'transparent',
  },
  compactScheduledTime: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
    paddingVertical: 8,
  },
  compactOrderTypeContainer: {
    alignItems: 'flex-start',
    paddingVertical: 4,
  },
  compactOrderTypeChip: {
    paddingHorizontal: 12,
    height: 28,
  },
  orderTypeSection: {
    margin: 16,
    marginBottom: 8,
  },
  orderTypeButtons: {
    flexDirection: 'row',
    gap: 4,
  },
  orderTypeButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 8,
    gap: 6,
    elevation: 1,
  },
  orderTypeButtonActive: {
    elevation: 2,
  },
  orderTypeButtonText: {
    fontSize: 12,
    fontWeight: '500',
  },
  errorText: {
    fontSize: 12,
    marginTop: 4,
    marginLeft: 4,
  },
  compactInputContainer: {
    marginBottom: 8,
  },
  helperTextFix: {
    marginTop: 4,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 8,
  },
  checkboxLabel: {
    marginLeft: 8,
    fontSize: 14,
  },
  temporaryTableInputContainer: {
    marginTop: 8,
  },
  dineInSelectorsRow: {
    flexDirection: 'row',
    gap: 8,
    marginBottom: 8,
  },
  dineInSelectorContainer: {
    flex: 1,
  },
  validationErrorsContainer: {
    marginTop: 4,
    gap: 2,
  },
  validationErrorText: {
    fontSize: 11,
    fontWeight: '500',
  },
});

================
File: app/src/components/AudioRecorderWidget.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import {
  View,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Easing,
  Text,
  Platform,
} from 'react-native';
import { MaterialIcons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from 'react-native-paper';
import { useAudioRecorder } from '@/hooks/useAudioRecorder';
import {
  audioServiceHealth,
  type AudioServiceHealthStatus,
} from '@/services/audioServiceHealth';
import { serverConnectionService } from '@/services/serverConnectionService';
interface AudioRecorderWidgetProps {
  onRecordingComplete: (audioUri: string, transcription: string) => void;
  onError: (error: string) => void;
}
export const AudioRecorderWidget: React.FC<AudioRecorderWidgetProps> = ({
  onRecordingComplete,
  onError,
}) => {
  const theme = useTheme();
  const {
    isRecording,
    isPreparing,
    isProcessing,
    audioUri,
    transcription,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  } = useAudioRecorder();
  const [recordingTime, setRecordingTime] = useState(0);
  const recordingInterval = useRef<NodeJS.Timeout | null>(null);
  const [serviceHealth, setServiceHealth] = useState<AudioServiceHealthStatus>(
    audioServiceHealth.getStatus(),
  );
  const [isServiceAvailable, setIsServiceAvailable] = useState(false);
  const [isServerReady, setIsServerReady] = useState(false);
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const waveAnim1 = useRef(new Animated.Value(0.8)).current;
  const waveAnim2 = useRef(new Animated.Value(0.8)).current;
  const waveAnim3 = useRef(new Animated.Value(0.8)).current;
  const bounceAnim = useRef(new Animated.Value(0)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    const checkServerConnection = () => {
      const connectionState = serverConnectionService.getState();
      const ready = connectionState.isConnected && !!connectionState.currentUrl;
      setIsServerReady(ready);
    };
    checkServerConnection();
    const unsubscribeServer = serverConnectionService.subscribe(
      checkServerConnection,
    );
    return unsubscribeServer;
  }, []);
  useEffect(() => {
    if (!isServerReady) return;
    const unsubscribe = audioServiceHealth.subscribe((status) => {
      setServiceHealth(status);
      setIsServiceAvailable(status.isAvailable);
    });
    audioServiceHealth.startPeriodicCheck();
    return () => {
      unsubscribe();
      audioServiceHealth.stopPeriodicCheck();
    };
  }, [isServerReady]);
  useEffect(() => {
    Animated.spring(bounceAnim, {
      toValue: 1,
      friction: 4,
      tension: 40,
      useNativeDriver: true,
    }).start();
  }, []);
  useEffect(() => {
    if (isRecording) {
      recordingInterval.current = setInterval(() => {
        setRecordingTime((prev) => prev + 1);
      }, 1000);
      const wave1 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim1, {
            toValue: 1.5,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim1, {
            toValue: 0.8,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );
      const wave2 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim2, {
            toValue: 1.8,
            duration: 2500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim2, {
            toValue: 0.8,
            duration: 2500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );
      const wave3 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim3, {
            toValue: 2.1,
            duration: 3000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim3, {
            toValue: 0.8,
            duration: 3000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );
      const glow = Animated.loop(
        Animated.sequence([
          Animated.timing(glowAnim, {
            toValue: 1,
            duration: 1500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(glowAnim, {
            toValue: 0,
            duration: 1500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );
      wave1.start();
      wave2.start();
      wave3.start();
      glow.start();
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();
      return () => {
        wave1.stop();
        wave2.stop();
        wave3.stop();
        glow.stop();
        if (recordingInterval.current) {
          clearInterval(recordingInterval.current);
        }
        setRecordingTime(0);
      };
    } else {
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }).start();
      waveAnim1.setValue(0.8);
      waveAnim2.setValue(0.8);
      waveAnim3.setValue(0.8);
      glowAnim.setValue(0);
    }
  }, [isRecording]);
  useEffect(() => {
    if (isProcessing || isPreparing) {
      const spin = Animated.loop(
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 1500,
          easing: Easing.bezier(0.645, 0.045, 0.355, 1),
          useNativeDriver: true,
        }),
      );
      spin.start();
      return () => {
        spin.stop();
        rotateAnim.setValue(0);
      };
    }
  }, [isProcessing, isPreparing]);
  const hasCompletedRef = useRef(false);
  useEffect(() => {
    if (
      audioUri &&
      transcription &&
      !isProcessing &&
      !hasCompletedRef.current
    ) {
      hasCompletedRef.current = true;
      resetRecording();
      onRecordingComplete(audioUri, transcription);
      setTimeout(() => {
        hasCompletedRef.current = false;
      }, 1000);
    }
  }, [
    audioUri,
    transcription,
    isProcessing,
    onRecordingComplete,
    resetRecording,
  ]);
  useEffect(() => {
    if (error) {
      onError(error);
    }
  }, [error, onError]);
  const handlePress = async () => {
    if (!isServiceAvailable) {
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 0.9,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();
      onError(serviceHealth.message || 'Servicio de voz no disponible');
      return;
    }
    if (isProcessing || isPreparing) {
      return;
    }
    Animated.sequence([
      Animated.spring(scaleAnim, {
        toValue: 0.85,
        friction: 3,
        tension: 40,
        useNativeDriver: true,
      }),
      Animated.spring(scaleAnim, {
        toValue: 1,
        friction: 3,
        tension: 40,
        useNativeDriver: true,
      }),
    ]).start();
    try {
      if (isRecording) {
        await stopRecording();
      } else {
        await startRecording();
      }
    } catch (err) {}
  };
  const rotateInterpolate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  };
  const getIcon = () => {
    if (isRecording) {
      return <MaterialIcons name="stop" size={30} color="white" />;
    }
    return <MaterialIcons name="mic" size={30} color="white" />;
  };
  const getBackgroundColor = () => {
    if (!isServiceAvailable) return '#B0B0B0';
    if (isProcessing || isPreparing) return theme.colors.secondary;
    if (isRecording) return '#FF3B30';
    return theme.colors.primary;
  };
  return (
    <Animated.View
      style={[
        styles.container,
        {
          transform: [
            {
              translateY: bounceAnim.interpolate({
                inputRange: [0, 1],
                outputRange: [100, 0],
              }),
            },
            { scale: bounceAnim },
          ],
          opacity: bounceAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [0, isServiceAvailable ? 1 : 0.8],
          }),
        },
      ]}
    >
      {}
      {isRecording && (
        <View style={styles.wavesContainer}>
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim1 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.1],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim2 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.15],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim3 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.2],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
        </View>
      )}
      {}
      {isRecording && (
        <Animated.View
          style={[
            styles.timerContainer,
            {
              opacity: fadeAnim,
              transform: [
                {
                  translateY: fadeAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [-10, 0],
                  }),
                },
              ],
            },
          ]}
        >
          <View style={[styles.timerBadge, { backgroundColor: '#FF3B30' }]}>
            <View style={styles.recordingDot} />
            <Text style={styles.timerText}>{formatTime(recordingTime)}</Text>
          </View>
        </Animated.View>
      )}
      {}
      {!isServiceAvailable && (
        <View
          style={[
            styles.disabledIndicator,
            { backgroundColor: theme.colors.error },
          ]}
        >
          <MaterialIcons name="cloud-off" size={14} color="white" />
        </View>
      )}
      <TouchableOpacity
        onPress={handlePress}
        disabled={isProcessing || isPreparing || !isServiceAvailable}
        activeOpacity={0.9}
      >
        <Animated.View
          style={[
            styles.buttonContainer,
            {
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          {}
          {isRecording && (
            <Animated.View
              style={[
                styles.glowEffect,
                {
                  backgroundColor: '#FF3B30',
                  opacity: glowAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.3, 0.6],
                  }),
                  transform: [
                    {
                      scale: glowAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [1, 1.2],
                      }),
                    },
                  ],
                },
              ]}
            />
          )}
          <View
            style={[
              styles.button,
              {
                backgroundColor: getBackgroundColor(),
                ...Platform.select({
                  web: {
                    boxShadow: !isServiceAvailable
                      ? 'none'
                      : isRecording
                        ? '0px 2px 8px rgba(255, 59, 48, 0.4)'
                        : `0px 2px 8px ${theme.colors.primary}40`,
                  },
                  default: {
                    shadowColor: !isServiceAvailable
                      ? 'transparent'
                      : isRecording
                        ? '#FF3B30'
                        : theme.colors.primary,
                    shadowOpacity: !isServiceAvailable
                      ? 0
                      : isRecording
                        ? 0.4
                        : 0.25,
                  },
                }),
              },
            ]}
          >
            {isProcessing || isPreparing ? (
              <Animated.View
                style={{
                  transform: [{ rotate: rotateInterpolate }],
                }}
              >
                <MaterialCommunityIcons name="brain" size={30} color="white" />
              </Animated.View>
            ) : (
              getIcon()
            )}
          </View>
        </Animated.View>
      </TouchableOpacity>
    </Animated.View>
  );
};
const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    bottom: 30,
    right: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  wavesContainer: {
    position: 'absolute',
    alignItems: 'center',
    justifyContent: 'center',
  },
  wave: {
    position: 'absolute',
    width: 120,
    height: 120,
    borderRadius: 60,
  },
  buttonContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  button: {
    width: 72,
    height: 72,
    borderRadius: 36,
    alignItems: 'center',
    justifyContent: 'center',
    elevation: 8,
    ...Platform.select({
      web: {
        boxShadow: '0px 2px 8px rgba(0, 0, 0, 0.25)',
      },
      default: {
        shadowOffset: { width: 0, height: 2 },
        shadowRadius: 8,
      },
    }),
    zIndex: 10,
  },
  glowEffect: {
    position: 'absolute',
    width: 80,
    height: 80,
    borderRadius: 40,
    zIndex: 5,
  },
  timerContainer: {
    position: 'absolute',
    top: -45,
    alignItems: 'center',
  },
  timerBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    gap: 6,
  },
  recordingDot: {
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: 'white',
    opacity: 0.9,
  },
  timerText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  disabledIndicator: {
    position: 'absolute',
    top: 0,
    right: 0,
    width: 26,
    height: 26,
    borderRadius: 13,
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 20,
    elevation: 12,
    borderWidth: 2,
    borderColor: 'white',
  },
});

================
File: app/src/modules/customers/components/CustomerFormModal.tsx
================
import React, { useEffect, useState } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Customer, Address } from '../types/customer.types';
import {
  CustomerFormInputs,
  customerFormSchema,
} from '../schema/customer.schema';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import { DateTimePickerSafe } from '@/app/components/DateTimePickerSafe';
import PhoneNumberInput from '@/app/components/common/PhoneNumberInput';
import { useGetAddressesByCustomer } from '../hooks/useCustomersQueries';
import AddressFormModal from './AddressFormModal';
import { addressesService } from '../services/addressesService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
interface CustomerFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: CustomerFormInputs) => Promise<void>;
  editingItem: Customer | null;
  isSubmitting: boolean;
}
export default function CustomerFormModal({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}: CustomerFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showAddressModal, setShowAddressModal] = useState(false);
  const [editingAddress, setEditingAddress] = useState<Address | null>(null);
  const [isSubmittingAddress, setIsSubmittingAddress] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [tempDate, setTempDate] = useState<Date>(new Date());
  const [dateOnChange, setDateOnChange] = useState<
    ((value: string) => void) | null
  >(null);
  const { showSnackbar } = useSnackbarStore();
  const { data: addresses = [], refetch: refetchAddresses } =
    useGetAddressesByCustomer(editingItem?.id || '', {
      enabled: !!editingItem?.id,
    });
  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    watch,
  } = useForm<CustomerFormInputs>({
    resolver: zodResolver(customerFormSchema),
    defaultValues: {
      firstName: '',
      lastName: '',
      whatsappPhoneNumber: '',
      email: '',
      birthDate: '',
      isActive: true,
      isBanned: false,
      banReason: '',
    },
  });
  useEffect(() => {
    if (editingItem) {
      reset({
        firstName: editingItem.firstName,
        lastName: editingItem.lastName,
        whatsappPhoneNumber: editingItem.whatsappPhoneNumber || '',
        email: editingItem.email || '',
        birthDate: editingItem.birthDate
          ? new Date(editingItem.birthDate).toISOString().split('T')[0]
          : '',
        isActive: editingItem.isActive,
        isBanned: editingItem.isBanned || false,
        banReason: editingItem.banReason || '',
      });
    } else {
      reset({
        firstName: '',
        lastName: '',
        whatsappPhoneNumber: '',
        email: '',
        birthDate: '',
        isActive: true,
        isBanned: false,
        banReason: '',
      });
    }
  }, [editingItem, reset]);
  const isBanned = watch('isBanned');
  const handleAddressSubmit = async (data: any) => {
    try {
      setIsSubmittingAddress(true);
      if (editingAddress) {
        await addressesService.update(editingAddress.id, data);
        showSnackbar({ message: 'Dirección actualizada', type: 'success' });
      } else if (editingItem) {
        await addressesService.create(editingItem.id, data);
        showSnackbar({ message: 'Dirección agregada', type: 'success' });
      }
      await refetchAddresses();
      setShowAddressModal(false);
      setEditingAddress(null);
    } catch (error) {
      showSnackbar({ message: 'Error al guardar la dirección', type: 'error' });
    } finally {
      setIsSubmittingAddress(false);
    }
  };
  const handleFormSubmit = async (data: CustomerFormInputs) => {
    const cleanedData = {
      ...data,
      email: data.email || undefined,
      birthDate: data.birthDate || undefined,
      banReason: data.banReason || undefined,
    };
    await onSubmit(cleanedData);
  };
  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.primary },
              ]}
            >
              <View style={styles.headerLeft}>
                <Avatar.Icon
                  size={32}
                  icon={editingItem ? 'account-edit' : 'account-plus'}
                  style={[
                    styles.headerIcon,
                    { backgroundColor: theme.colors.onPrimary + '20' },
                  ]}
                  color={theme.colors.onPrimary}
                />
                <View style={styles.headerTextContainer}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onPrimary },
                    ]}
                    variant="titleMedium"
                  >
                    {editingItem ? 'Editar Cliente' : 'Nuevo Cliente'}
                  </Text>
                </View>
              </View>
              <IconButton
                icon="close"
                size={24}
                onPress={onDismiss}
                disabled={isSubmitting}
                iconColor={theme.colors.onPrimary}
              />
            </View>
            <ScrollView
              style={styles.formContainer}
              showsVerticalScrollIndicator={false}
              keyboardShouldPersistTaps="handled"
            >
              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información Personal
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.requiredChip}
                    textStyle={styles.requiredChipText}
                  >
                    Requerido
                  </Chip>
                </View>
                <Controller
                  control={control}
                  name="firstName"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Nombre"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.firstName}
                        mode="outlined"
                        placeholder="Ej: Juan"
                        left={<TextInput.Icon icon="account" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.firstName && (
                        <HelperText type="error" visible={!!errors.firstName}>
                          {errors.firstName.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
                <Controller
                  control={control}
                  name="lastName"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Apellido"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.lastName}
                        mode="outlined"
                        placeholder="Ej: Pérez"
                        left={<TextInput.Icon icon="account" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.lastName && (
                        <HelperText type="error" visible={!!errors.lastName}>
                          {errors.lastName.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>
              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información de Contacto
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.optionalChip}
                    textStyle={styles.optionalChipText}
                  >
                    Opcional
                  </Chip>
                </View>
                <Controller
                  control={control}
                  name="whatsappPhoneNumber"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.inputContainer}>
                      <PhoneNumberInput
                        value={value || ''}
                        onChange={onChange}
                        error={!!errors.whatsappPhoneNumber}
                        helperText={errors.whatsappPhoneNumber?.message}
                        placeholder="Teléfono"
                      />
                    </View>
                  )}
                />
                <Controller
                  control={control}
                  name="email"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Correo electrónico"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.email}
                        mode="outlined"
                        placeholder="juan@example.com"
                        keyboardType="email-address"
                        autoCapitalize="none"
                        left={<TextInput.Icon icon="email" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.email && (
                        <HelperText type="error" visible={!!errors.email}>
                          {errors.email.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
                <Controller
                  control={control}
                  name="birthDate"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.inputContainer}>
                      <AnimatedLabelSelector
                        label="Fecha de nacimiento"
                        value={
                          value
                            ? format(new Date(value), "d 'de' MMMM 'de' yyyy", {
                                locale: es,
                              })
                            : ''
                        }
                        onPress={() => {
                          setTempDate(value ? new Date(value) : new Date());
                          setDateOnChange(() => onChange);
                          setShowDatePicker(true);
                        }}
                        error={!!errors.birthDate}
                      />
                      {errors.birthDate && (
                        <HelperText type="error" visible={!!errors.birthDate}>
                          {errors.birthDate.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>
              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Estado
                  </Text>
                </View>
                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <Surface style={styles.switchContainer} elevation={1}>
                      <View style={styles.switchContent}>
                        <View style={styles.switchTextContainer}>
                          <Text style={styles.switchLabel} variant="bodyLarge">
                            Cliente activo
                          </Text>
                        </View>
                        <Switch
                          value={value}
                          onValueChange={onChange}
                          color={theme.colors.primary}
                        />
                      </View>
                    </Surface>
                  )}
                />
                <Controller
                  control={control}
                  name="isBanned"
                  render={({ field: { onChange, value } }) => (
                    <Surface
                      style={[styles.switchContainer, styles.bannedContainer]}
                      elevation={1}
                    >
                      <View style={styles.switchContent}>
                        <View style={styles.switchTextContainer}>
                          <Text style={styles.switchLabel} variant="bodyLarge">
                            Cliente baneado
                          </Text>
                          <Text
                            style={styles.switchDescription}
                            variant="bodySmall"
                          >
                            Los clientes baneados no pueden realizar pedidos
                          </Text>
                        </View>
                        <Switch
                          value={value}
                          onValueChange={onChange}
                          color={theme.colors.error}
                        />
                      </View>
                    </Surface>
                  )}
                />
                {isBanned && (
                  <>
                    <Controller
                      control={control}
                      name="banReason"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View
                          style={[
                            styles.inputContainer,
                            styles.banReasonContainer,
                          ]}
                        >
                          <TextInput
                            label="Razón del baneo"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            mode="outlined"
                            placeholder="Ej: Comportamiento inapropiado"
                            multiline
                            numberOfLines={2}
                            left={<TextInput.Icon icon="alert-circle" />}
                            outlineStyle={styles.inputOutline}
                            outlineColor={theme.colors.error}
                            activeOutlineColor={theme.colors.error}
                          />
                        </View>
                      )}
                    />
                    {editingItem?.bannedAt && (
                      <Surface style={styles.infoCard} elevation={1}>
                        <View style={styles.infoCardContent}>
                          <IconButton
                            icon="calendar-clock"
                            size={20}
                            iconColor={theme.colors.error}
                          />
                          <View style={styles.infoText}>
                            <Text
                              variant="labelMedium"
                              style={styles.infoLabel}
                            >
                              Fecha de baneo
                            </Text>
                            <Text variant="bodyMedium" style={styles.infoValue}>
                              {new Date(editingItem.bannedAt).toLocaleString()}
                            </Text>
                          </View>
                        </View>
                      </Surface>
                    )}
                  </>
                )}
              </View>
              {/* Sección de WhatsApp - Solo en modo edición */}
              {editingItem && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Información de WhatsApp
                    </Text>
                  </View>
                  <Surface style={styles.whatsappCard} elevation={1}>
                    <View style={styles.whatsappRow}>
                      <View style={styles.whatsappStat}>
                        <Icon
                          source="message-text"
                          size={20}
                          color={theme.colors.primary}
                        />
                        <View style={styles.whatsappStatContent}>
                          <Text
                            variant="bodySmall"
                            style={styles.whatsappLabel}
                          >
                            Mensajes totales
                          </Text>
                          <Text
                            variant="titleMedium"
                            style={styles.whatsappValue}
                          >
                            {editingItem.whatsappMessageCount || 0}
                          </Text>
                        </View>
                      </View>
                      <View style={styles.whatsappDivider} />
                      <View style={styles.whatsappStat}>
                        <Icon
                          source="clock-outline"
                          size={20}
                          color={theme.colors.primary}
                        />
                        <View style={styles.whatsappStatContent}>
                          <Text
                            variant="bodySmall"
                            style={styles.whatsappLabel}
                          >
                            Último mensaje
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={styles.whatsappValue}
                          >
                            {editingItem.lastWhatsappMessageTime
                              ? new Date(
                                  editingItem.lastWhatsappMessageTime,
                                ).toLocaleDateString()
                              : 'Sin mensajes'}
                          </Text>
                        </View>
                      </View>
                    </View>
                  </Surface>
                </View>
              )}
              {}
              {editingItem?.stripeCustomerId && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Información de Pago
                    </Text>
                  </View>
                  <Surface style={styles.stripeCard} elevation={1}>
                    <View style={styles.stripeContent}>
                      <Icon
                        source="credit-card"
                        size={24}
                        color={theme.colors.primary}
                      />
                      <View style={styles.stripeInfo}>
                        <Text variant="bodySmall" style={styles.stripeLabel}>
                          Stripe Customer ID
                        </Text>
                        <Text
                          variant="bodyMedium"
                          style={styles.stripeValue}
                          selectable
                        >
                          {editingItem.stripeCustomerId}
                        </Text>
                      </View>
                    </View>
                  </Surface>
                </View>
              )}
              {}
              {editingItem && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Direcciones
                    </Text>
                    <Button
                      mode="text"
                      onPress={() => {
                        setEditingAddress(null);
                        setShowAddressModal(true);
                      }}
                      icon="plus"
                      compact
                    >
                      Agregar
                    </Button>
                  </View>
                  {addresses.length === 0 ? (
                    <Surface style={styles.emptyAddressContainer} elevation={0}>
                      <Text
                        style={styles.emptyAddressText}
                        variant="bodyMedium"
                      >
                        No hay direcciones registradas
                      </Text>
                    </Surface>
                  ) : (
                    <View style={styles.addressList}>
                      {addresses.map((address: Address) => (
                        <Surface
                          key={address.id}
                          style={styles.addressCard}
                          elevation={1}
                        >
                          <View style={styles.addressContent}>
                            <View style={styles.addressHeader}>
                              <IconButton
                                icon="map-marker"
                                size={20}
                                iconColor={theme.colors.primary}
                              />
                              <View style={styles.addressInfo}>
                                <Text
                                  style={styles.addressName}
                                  variant="titleSmall"
                                >
                                  {address.name}
                                </Text>
                                <Text
                                  style={styles.addressStreet}
                                  variant="bodyMedium"
                                >
                                  {address.street} {address.number}
                                  {address.interiorNumber &&
                                    `, ${address.interiorNumber}`}
                                </Text>
                                <Text
                                  style={styles.addressDetails}
                                  variant="bodySmall"
                                >
                                  {address.neighborhood}, {address.city},{' '}
                                  {address.state}
                                </Text>
                                {address.isDefault && (
                                  <Chip
                                    mode="flat"
                                    compact
                                    style={styles.defaultChip}
                                    textStyle={styles.defaultChipText}
                                  >
                                    Predeterminada
                                  </Chip>
                                )}
                              </View>
                            </View>
                            <View style={styles.addressActions}>
                              <IconButton
                                icon="pencil"
                                size={20}
                                onPress={() => {
                                  setEditingAddress(address);
                                  setShowAddressModal(true);
                                }}
                              />
                              <IconButton
                                icon="delete"
                                size={20}
                                iconColor={theme.colors.error}
                                onPress={async () => {
                                  try {
                                    await addressesService.remove(address.id);
                                    await refetchAddresses();
                                    showSnackbar({
                                      message: 'Dirección eliminada',
                                      type: 'success',
                                    });
                                  } catch (error) {
                                    showSnackbar({
                                      message: 'Error al eliminar la dirección',
                                      type: 'error',
                                    });
                                  }
                                }}
                              />
                            </View>
                          </View>
                        </Surface>
                      ))}
                    </View>
                  )}
                </View>
              )}
              {}
              <View style={{ height: 10 }} />
            </ScrollView>
            <Surface style={styles.buttonContainer} elevation={2}>
              <Button
                onPress={onDismiss}
                disabled={isSubmitting}
                style={[styles.button, styles.cancelButton]}
                textColor={theme.colors.onSecondaryContainer}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleSubmit(handleFormSubmit)}
                disabled={isSubmitting}
                loading={isSubmitting}
                style={[styles.button, styles.confirmButton]}
                buttonColor={theme.colors.primary}
              >
                {editingItem ? 'Guardar' : 'Crear'}
              </Button>
            </Surface>
          </Surface>
        </Modal>
      </Portal>
      {}
      {editingItem && (
        <AddressFormModal
          visible={showAddressModal}
          onDismiss={() => {
            setShowAddressModal(false);
            setEditingAddress(null);
          }}
          onSubmit={handleAddressSubmit}
          editingItem={editingAddress}
          isSubmitting={isSubmittingAddress}
          customerId={editingItem.id}
        />
      )}
      {}
      <DateTimePickerSafe
        visible={showDatePicker}
        mode="date"
        value={tempDate}
        onConfirm={(date) => {
          if (dateOnChange) {
            dateOnChange(date.toISOString().split('T')[0]);
          }
          setShowDatePicker(false);
        }}
        onCancel={() => setShowDatePicker(false)}
        title="Fecha de nacimiento"
        maximumDate={new Date()}
      />
    </>
  );
}
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? 20 : 10,
      justifyContent: 'center',
      alignItems: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      maxHeight: '95%',
      minHeight: responsive.isTablet ? 600 : '80%',
      width: responsive.isTablet ? '85%' : '100%',
      maxWidth: responsive.isTablet ? 800 : undefined,
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
      paddingVertical: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: responsive.isTablet
        ? theme.spacing.s * 0.7
        : theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
      fontSize: responsive.isTablet ? 16 : 18,
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
      paddingTop: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.s * 0.7
        : theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    requiredChipText: {
      color: theme.colors.onErrorContainer,
      fontSize: responsive.isTablet ? 10 : 11,
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 10 : 11,
    },
    inputContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.xs * 0.7 : theme.spacing.xs,
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 14 : 16,
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    bannedContainer: {
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    banReasonContainer: {
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    infoCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      backgroundColor: theme.colors.errorContainer,
    },
    infoCardContent: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    infoText: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    infoLabel: {
      color: theme.colors.onErrorContainer,
      opacity: 0.8,
      fontSize: responsive.isTablet ? 11 : 12,
    },
    infoValue: {
      color: theme.colors.onErrorContainer,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    whatsappCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      backgroundColor: theme.colors.primaryContainer + '20',
    },
    whatsappRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    whatsappStat: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    whatsappStatContent: {
      flex: 1,
    },
    whatsappLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 12,
    },
    whatsappValue: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginTop: 2,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    whatsappDivider: {
      width: 1,
      height: responsive.isTablet ? 35 : 40,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
    },
    stripeCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
    },
    stripeContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
    },
    stripeInfo: {
      flex: 1,
    },
    stripeLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 12,
      marginBottom: responsive.isTablet ? 3 : 4,
    },
    stripeValue: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontFamily: 'monospace',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      borderBottomLeftRadius: theme.roundness * 2,
      borderBottomRightRadius: theme.roundness * 2,
    },
    button: {
      flex: 1,
      maxWidth: 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    addressList: {
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    addressCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
    },
    addressContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    addressHeader: {
      flexDirection: 'row',
      flex: 1,
    },
    addressInfo: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    addressName: {
      fontWeight: '600',
      color: theme.colors.primary,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    addressStreet: {
      fontWeight: '500',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    addressDetails: {
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
      fontSize: responsive.isTablet ? 12 : 13,
    },
    addressActions: {
      flexDirection: 'row',
    },
    defaultChip: {
      marginTop: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
      backgroundColor: theme.colors.primaryContainer,
    },
    defaultChipText: {
      color: theme.colors.onPrimaryContainer,
      fontSize: responsive.isTablet ? 9 : 10,
    },
    emptyAddressContainer: {
      padding: responsive.isTablet ? theme.spacing.l * 0.7 : theme.spacing.l,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
    },
    emptyAddressText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 13 : 14,
    },
  });

================
File: app/src/modules/menu/components/ProductFormModal.tsx
================
import React, { useEffect, useMemo, useState, useCallback } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Button,
  TextInput,
  Text,
  ActivityIndicator,
  Switch,
  HelperText,
  Divider,
  IconButton,
  Card,
  Checkbox,
  TouchableRipple,
} from 'react-native-paper';
import {
  useForm,
  Controller,
  useFieldArray,
  SubmitHandler,
} from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  ProductFormInputs,
  productSchema,
  updateProductSchema,
  ProductVariant,
  Product,
} from '../schema/products.schema';
import { ModifierGroup } from '../../modifiers/schema/modifierGroup.schema';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import VariantFormModal from './VariantFormModal';
import CustomImagePicker, {
  FileObject,
} from '@/app/components/common/CustomImagePicker';
import { ImageUploadService } from '@/app/lib/imageUploadService';
import { getImageUrl } from '@/app/lib/imageUtils';
import { useModifierGroupsQuery } from '../../modifiers/hooks/useModifierGroupsQuery';
import { modifierService } from '../../modifiers/services/modifierService';
import { useGetPreparationScreens } from '../../preparationScreens/hooks/usePreparationScreensQueries';
import { Menu } from 'react-native-paper';
interface ProductFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: ProductFormInputs,
    photoId: string | null | undefined,
    file?: FileObject | null,
  ) => Promise<void>;
  initialData?: Product | null;
  isSubmitting: boolean;
  productId?: string | null;
  subcategoryId: string;
}
function ProductFormModal({
  visible,
  onDismiss,
  onSubmit,
  initialData,
  isSubmitting,
  productId,
  subcategoryId,
}: ProductFormModalProps): React.ReactElement {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const isEditing = !!productId && !!initialData;
  const [isVariantModalVisible, setIsVariantModalVisible] = useState(false);
  const [editingVariantIndex, setEditingVariantIndex] = useState<number | null>(
    null,
  );
  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(
    null,
  );
  const [isInternalImageUploading, setIsInternalImageUploading] =
    useState(false);
  const [groupModifiers, setGroupModifiers] = useState<Record<string, any[]>>(
    {},
  );
  const [priceInputValue, setPriceInputValue] = useState<string>('');
  const [preparationScreenMenuVisible, setPreparationScreenMenuVisible] =
    useState(false);
  const defaultValues = useMemo(
    (): ProductFormInputs => ({
      name: '',
      description: null,
      price: null,
      hasVariants: false,
      isActive: true,
      isPizza: false,
      subcategoryId: subcategoryId,
      photoId: null,
      estimatedPrepTime: 10,
      preparationScreenId: null,
      sortOrder: 0,
      variants: [],
      variantsToDelete: [],
      imageUri: null,
      modifierGroupIds: [],
    }),
    [subcategoryId],
  );
  const {
    control,
    handleSubmit,
    reset,
    watch,
    setValue,
    formState: { errors },
  } = useForm<ProductFormInputs>({
    resolver: zodResolver(initialData ? updateProductSchema : productSchema),
    defaultValues: defaultValues,
  });
  const {
    fields: variantFields,
    append: appendVariant,
    remove: removeVariant,
    update: updateVariant,
  } = useFieldArray({
    control,
    name: 'variants',
  });
  useEffect(() => {
    const loadInitialData = async () => {
      if (visible) {
        if (isEditing && initialData) {
          const initialPrice = initialData.price;
          const parsedPrice =
            initialPrice !== null &&
            initialPrice !== undefined &&
            !isNaN(parseFloat(String(initialPrice)))
              ? parseFloat(String(initialPrice))
              : null;
          let imageUrl = null;
          if (initialData.photo?.path) {
            try {
              imageUrl = await getImageUrl(initialData.photo.path);
            } catch (error) {
              imageUrl = initialData.photo.path;
            }
          }
          reset({
            name: initialData.name,
            description: initialData.description || null,
            price: parsedPrice,
            hasVariants: initialData.hasVariants,
            isActive: initialData.isActive,
            isPizza: initialData.isPizza ?? false,
            subcategoryId: initialData.subcategoryId,
            photoId: initialData.photo?.id ?? null,
            estimatedPrepTime: initialData.estimatedPrepTime,
            preparationScreenId: initialData.preparationScreenId || null,
            sortOrder: initialData.sortOrder ?? 0,
            variants: initialData.variants || [],
            variantsToDelete: [],
            imageUri: imageUrl,
            modifierGroupIds: [],
          });
          setLocalSelectedFile(null);
        } else {
          reset(defaultValues);
          setLocalSelectedFile(null);
        }
      }
    };
    loadInitialData();
  }, [visible, isEditing, initialData, reset, defaultValues, subcategoryId]);
  const hasVariants = watch('hasVariants');
  const currentImageUri = watch('imageUri');
  const priceValue = watch('price');
  useEffect(() => {
    setPriceInputValue(
      priceValue !== null && priceValue !== undefined
        ? priceValue.toString()
        : '',
    );
  }, [priceValue]);
  const { data: modifierGroupsResponse, isLoading: isLoadingGroups } =
    useModifierGroupsQuery({ isActive: true });
  const { data: preparationScreensResponse } = useGetPreparationScreens(
    {},
    { page: 1, limit: 50 },
  );
  const preparationScreens = preparationScreensResponse?.data || [];
  const allModifierGroups = modifierGroupsResponse?.data || [];
  useEffect(() => {
    const loadModifiers = async () => {
      const modifiersMap: Record<string, any[]> = {};
      for (const group of allModifierGroups) {
        try {
          const modifiers = await modifierService.findByGroupId(group.id);
          modifiersMap[group.id] = modifiers.filter((mod) => mod.isActive);
        } catch (error) {
          modifiersMap[group.id] = [];
        }
      }
      setGroupModifiers(modifiersMap);
    };
    if (allModifierGroups.length > 0) {
      loadModifiers();
    }
  }, [allModifierGroups]);
  useEffect(() => {
    if (visible) {
      if (isEditing && initialData?.modifierGroups) {
        if (Array.isArray(initialData.modifierGroups)) {
          const assignedIds = initialData.modifierGroups.map(
            (group: ModifierGroup) => group.id,
          );
          setValue('modifierGroupIds', assignedIds);
        } else {
          setValue('modifierGroupIds', []);
        }
      } else if (!isEditing) {
        setValue('modifierGroupIds', []);
      } else if (isEditing && !initialData?.modifierGroups) {
        setValue('modifierGroupIds', []);
      }
    }
  }, [visible, isEditing, initialData, setValue, reset, defaultValues]);
  const handleImageSelected = useCallback(
    (uri: string, file: FileObject) => {
      setValue('imageUri', uri, { shouldValidate: true, shouldDirty: true });
      setLocalSelectedFile(file);
    },
    [setValue],
  );
  const handleImageRemoved = useCallback(() => {
    setValue('imageUri', null, { shouldValidate: true, shouldDirty: true });
    setLocalSelectedFile(null);
  }, [setValue]);
  const processSubmit: SubmitHandler<ProductFormInputs> = async (formData) => {
    if (isSubmitting || isInternalImageUploading) return;
    let finalPhotoId: string | null | undefined = undefined;
    if (localSelectedFile) {
      setIsInternalImageUploading(true);
      try {
        const uploadResult =
          await ImageUploadService.uploadImage(localSelectedFile);
        if (uploadResult.success && uploadResult.photoId) {
          finalPhotoId = uploadResult.photoId;
        } else {
          throw new Error(
            uploadResult.error || 'La subida de la imagen falló.',
          );
        }
      } catch (error) {
        showSnackbar({
          message: `Error al subir imagen: ${getApiErrorMessage(error)}`,
          type: 'error',
        });
        setIsInternalImageUploading(false);
        return;
      } finally {
        setIsInternalImageUploading(false);
      }
    } else {
      finalPhotoId = await ImageUploadService.determinePhotoId(
        currentImageUri,
        initialData ?? undefined,
      );
    }
    const finalData = {
      ...formData,
      price: hasVariants ? null : formData.price,
      variants: hasVariants ? formData.variants : [],
    };
    await onSubmit(finalData, finalPhotoId, localSelectedFile);
    setLocalSelectedFile(null);
  };
  const showVariantModal = (index: number | null = null) => {
    setEditingVariantIndex(index);
    setIsVariantModalVisible(true);
  };
  const handleVariantSubmit = (variantData: ProductVariant) => {
    if (editingVariantIndex !== null) {
      const originalVariantId =
        initialData?.variants?.[editingVariantIndex]?.id;
      const priceAsNumber = Number(variantData.price);
      const dataToUpdate = {
        ...variantData,
        price: isNaN(priceAsNumber) ? 0 : priceAsNumber,
        ...(originalVariantId && { id: originalVariantId }),
      };
      const finalDataToUpdate =
        !originalVariantId && 'id' in dataToUpdate
          ? (({ id, ...rest }) => rest)(dataToUpdate)
          : dataToUpdate;
      updateVariant(editingVariantIndex, finalDataToUpdate as ProductVariant);
    } else {
      const { id, price, ...restNewVariantData } = variantData;
      const newPriceAsNumber = Number(price);
      const newVariantData = {
        ...restNewVariantData,
        price: isNaN(newPriceAsNumber) ? 0 : newPriceAsNumber,
      };
      appendVariant(newVariantData as ProductVariant);
    }
    setIsVariantModalVisible(false);
    setEditingVariantIndex(null);
  };
  const handleRemoveVariant = (index: number) => {
    const variantToRemove = variantFields[index];
    if (variantToRemove.id) {
      const currentToDelete = watch('variantsToDelete') || [];
      setValue('variantsToDelete', [...currentToDelete, variantToRemove.id]);
    }
    removeVariant(index);
  };
  const variantInitialData =
    editingVariantIndex !== null
      ? (variantFields[editingVariantIndex] as ProductVariant)
      : undefined;
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting && !isInternalImageUploading}
      >
        <View style={styles.modalHeader}>
          <Text variant="titleLarge" style={styles.modalTitle}>
            {isEditing ? 'Editar Producto' : 'Nuevo Producto'}
          </Text>
        </View>
        <ScrollView contentContainerStyle={styles.scrollContent}>
          <Card style={styles.card}>
            <Card.Content>
              <View style={styles.imagePickerContainer}>
                <CustomImagePicker
                  value={currentImageUri}
                  onImageSelected={handleImageSelected}
                  onImageRemoved={handleImageRemoved}
                  isLoading={isInternalImageUploading}
                  disabled={isSubmitting}
                  size={150}
                  placeholderIcon="food-outline"
                  placeholderText="Imagen del producto"
                />
                {errors.imageUri && (
                  <HelperText type="error">
                    {errors.imageUri.message}
                  </HelperText>
                )}
              </View>
              <Controller
                control={control}
                name="name"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Nombre del Producto *"
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.name}
                    style={styles.input}
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.name && (
                <HelperText type="error" visible={!!errors.name}>
                  {errors.name.message}
                </HelperText>
              )}
              <Controller
                control={control}
                name="description"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Descripción"
                    value={value || ''}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.description}
                    style={styles.input}
                    disabled={isSubmitting}
                    multiline
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && (
                <HelperText type="error" visible={!!errors.description}>
                  {errors.description.message}
                </HelperText>
              )}
              <View style={styles.switchContainer}>
                <Text style={styles.label}>¿Tiene Variantes?</Text>
                <Controller
                  control={control}
                  name="hasVariants"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={(newValue) => {
                        onChange(newValue);
                        if (newValue) {
                          setValue('price', null, { shouldValidate: true });
                        }
                      }}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>
              {hasVariants && errors.price && (
                <HelperText type="error" visible={!!errors.price}>
                  {errors.price.message}
                </HelperText>
              )}
              {!hasVariants && (
                <>
                  <Controller
                    control={control}
                    name="price"
                    render={({ field }) => (
                      <TextInput
                        mode="outlined"
                        label="Precio *"
                        keyboardType="decimal-pad"
                        value={priceInputValue}
                        onChangeText={(text) => {
                          const formattedText = text.replace(/,/g, '.');
                          if (/^(\d*\.?\d*)$/.test(formattedText)) {
                            setPriceInputValue(formattedText);
                            if (formattedText === '') {
                              field.onChange(null);
                            } else if (formattedText !== '.') {
                              field.onChange(parseFloat(formattedText));
                            }
                          }
                        }}
                        error={!!errors.price}
                        disabled={isSubmitting || hasVariants}
                        style={styles.input}
                      />
                    )}
                  />
                  {errors.price && (
                    <HelperText type="error" visible={!!errors.price}>
                      {errors.price?.message || 'Precio inválido'}
                    </HelperText>
                  )}
                </>
              )}
              {hasVariants && (
                <View style={styles.variantsSection}>
                  <Divider style={styles.divider} />
                  <View style={styles.variantsHeader}>
                    <Text variant="titleMedium">Variantes</Text>
                    <Button
                      mode="contained-tonal"
                      icon="plus"
                      onPress={() => showVariantModal()}
                      disabled={isSubmitting}
                    >
                      Añadir
                    </Button>
                  </View>
                  {variantFields.length === 0 && (
                    <Text style={styles.noVariantsText}>
                      Aún no hay variantes añadidas.
                    </Text>
                  )}
                  {variantFields.map((field, index) => (
                    <Card
                      key={field.id || `new-${index}`}
                      style={[
                        styles.variantCard,
                        field.isActive === false && styles.variantCardInactive,
                      ]}
                    >
                      <View style={styles.variantContent}>
                        <View style={styles.variantInfo}>
                          <View style={styles.variantHeader}>
                            <Text
                              style={[
                                styles.variantName,
                                field.isActive === false &&
                                  styles.variantNameInactive,
                              ]}
                              numberOfLines={1}
                              ellipsizeMode="tail"
                            >
                              {field.name || 'Nueva Variante'}
                            </Text>
                            {field.isActive === false && (
                              <View style={styles.inactiveBadge}>
                                <Text style={styles.inactiveBadgeText}>
                                  Inactiva
                                </Text>
                              </View>
                            )}
                          </View>
                          <Text style={styles.variantPrice}>
                            $
                            {!isNaN(Number(field.price))
                              ? Number(field.price).toFixed(2)
                              : '0.00'}
                          </Text>
                        </View>
                        <View style={styles.variantActions}>
                          <IconButton
                            icon="pencil"
                            size={24}
                            onPress={() => showVariantModal(index)}
                            disabled={isSubmitting}
                            style={styles.variantActionButton}
                          />
                          <IconButton
                            icon="delete"
                            size={24}
                            onPress={() => handleRemoveVariant(index)}
                            iconColor={theme.colors.error}
                            disabled={isSubmitting}
                            style={styles.variantActionButton}
                          />
                        </View>
                      </View>
                    </Card>
                  ))}
                  {}
                  {errors.variants?.message && (
                    <HelperText
                      type="error"
                      visible={!!errors.variants.message}
                    >
                      {errors.variants.message as string}
                    </HelperText>
                  )}
                  {}
                  {errors.variants?.root?.message && (
                    <HelperText
                      type="error"
                      visible={!!errors.variants.root.message}
                    >
                      {errors.variants.root.message as string}
                    </HelperText>
                  )}
                </View>
              )}
              <Divider style={styles.divider} />
              <Controller
                control={control}
                name="estimatedPrepTime"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Tiempo Prep. Estimado (min)"
                    value={
                      value !== null && value !== undefined ? String(value) : ''
                    }
                    onChangeText={(text) =>
                      onChange(text ? parseInt(text, 10) : 0)
                    }
                    onBlur={onBlur}
                    error={!!errors.estimatedPrepTime}
                    style={styles.input}
                    keyboardType="numeric"
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.estimatedPrepTime && (
                <HelperText type="error" visible={!!errors.estimatedPrepTime}>
                  {errors.estimatedPrepTime.message}
                </HelperText>
              )}
              {/* Campo de Pantalla de Preparación */}
              <Controller
                control={control}
                name="preparationScreenId"
                render={({ field: { onChange, value } }) => (
                  <View>
                    <Menu
                      visible={preparationScreenMenuVisible}
                      onDismiss={() => setPreparationScreenMenuVisible(false)}
                      anchor={
                        <TextInput
                          label="Pantalla de Preparación"
                          value={
                            preparationScreens.find(
                              (screen) => screen.id === value,
                            )?.name || ''
                          }
                          onPress={() => setPreparationScreenMenuVisible(true)}
                          right={
                            value ? (
                              <TextInput.Icon
                                icon="close"
                                onPress={() => {
                                  onChange(null);
                                }}
                              />
                            ) : (
                              <TextInput.Icon
                                icon="chevron-down"
                                onPress={() =>
                                  setPreparationScreenMenuVisible(true)
                                }
                              />
                            )
                          }
                          editable={false}
                          error={!!errors.preparationScreenId}
                          style={styles.input}
                          disabled={isSubmitting}
                        />
                      }
                    >
                      {preparationScreens.map((screen) => (
                        <Menu.Item
                          key={screen.id}
                          onPress={() => {
                            onChange(screen.id);
                            setPreparationScreenMenuVisible(false);
                          }}
                          title={screen.name}
                        />
                      ))}
                    </Menu>
                  </View>
                )}
              />
              {errors.preparationScreenId && (
                <HelperText type="error" visible={!!errors.preparationScreenId}>
                  {errors.preparationScreenId.message}
                </HelperText>
              )}
              <Controller
                control={control}
                name="sortOrder"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Orden de visualización"
                    value={
                      value !== null && value !== undefined ? String(value) : ''
                    }
                    onChangeText={(text) =>
                      onChange(text ? parseInt(text, 10) : 0)
                    }
                    onBlur={onBlur}
                    error={!!errors.sortOrder}
                    style={styles.input}
                    keyboardType="numeric"
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.sortOrder && (
                <HelperText type="error" visible={!!errors.sortOrder}>
                  {errors.sortOrder.message}
                </HelperText>
              )}
              <View style={styles.switchContainer}>
                <Text style={styles.label}>Activo</Text>
                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>
              <View style={styles.switchContainer}>
                <Text style={styles.label}>Es Pizza</Text>
                <Controller
                  control={control}
                  name="isPizza"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>
              <Divider style={styles.divider} />
              <View style={styles.modifierGroupSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>
                  Grupos de Modificadores
                </Text>
                {isLoadingGroups ? (
                  <ActivityIndicator
                    animating={true}
                    style={{
                      marginVertical: responsive.spacing(theme.spacing.m),
                    }}
                  />
                ) : allModifierGroups.length === 0 ? (
                  <Text style={styles.noItemsText}>
                    No hay grupos de modificadores disponibles.
                  </Text>
                ) : (
                  <Controller
                    control={control}
                    name="modifierGroupIds"
                    render={({ field: { onChange, value } }) => {
                      const currentIds = Array.isArray(value) ? value : []; // Asegurar que sea array
                      const availableGroups = allModifierGroups; // Ya es un array de ModifierGroup
                      return (
                        <>
                          {availableGroups.map((group: ModifierGroup) => {
                            const isSelected = currentIds.includes(group.id);
                            const modifiers = groupModifiers[group.id] || [];
                            return (
                              <TouchableRipple
                                key={group.id}
                                onPress={() => {
                                  const newIds = isSelected
                                    ? currentIds.filter((id) => id !== group.id)
                                    : [...currentIds, group.id];
                                  onChange(newIds);
                                }}
                                disabled={isSubmitting}
                                style={styles.modifierGroupTouchable}
                              >
                                <View style={styles.modifierGroupContent}>
                                  <Checkbox
                                    status={
                                      isSelected ? 'checked' : 'unchecked'
                                    }
                                    disabled={isSubmitting}
                                  />
                                  <View
                                    style={styles.modifierGroupTextContainer}
                                  >
                                    <Text style={styles.modifierGroupName}>
                                      {group.name}
                                    </Text>
                                    {modifiers.length > 0 && (
                                      <View
                                        style={styles.modifiersListContainer}
                                      >
                                        {modifiers.map((modifier, index) => (
                                          <Text
                                            key={modifier.id}
                                            style={styles.modifierItem}
                                          >
                                            {modifier.isDefault && '✓ '}
                                            {modifier.name}
                                            {index < modifiers.length - 1 &&
                                              ', '}
                                          </Text>
                                        ))}
                                      </View>
                                    )}
                                    {modifiers.length === 0 && (
                                      <Text style={styles.noModifiersText}>
                                        Sin modificadores activos
                                      </Text>
                                    )}
                                  </View>
                                </View>
                              </TouchableRipple>
                            );
                          })}
                        </>
                      );
                    }}
                  />
                )}
                {errors.modifierGroupIds && (
                  <HelperText type="error" visible={!!errors.modifierGroupIds}>
                    {errors.modifierGroupIds.message as string}
                  </HelperText>
                )}
              </View>
            </Card.Content>
          </Card>
        </ScrollView>
        {(isSubmitting || isInternalImageUploading) && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator
              animating={true}
              size="large"
              color={theme.colors.primary}
            />
          </View>
        )}
        <View style={styles.modalActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[styles.formButton, styles.cancelButton]}
            disabled={isSubmitting || isInternalImageUploading}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSubmit(processSubmit)}
            loading={isSubmitting || isInternalImageUploading}
            disabled={isSubmitting || isInternalImageUploading}
            style={styles.formButton}
          >
            {isEditing ? 'Guardar' : 'Crear'}
          </Button>
        </View>
      </Modal>
      <VariantFormModal
        visible={isVariantModalVisible}
        onDismiss={() => setIsVariantModalVisible(false)}
        onSubmit={handleVariantSubmit}
        initialData={variantInitialData}
      />
    </Portal>
  );
}
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: responsive.spacing(20),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(40)
        : responsive.spacing(20),
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: responsive.isTablet ? '92%' : '90%',
      minHeight: responsive.isTablet ? 650 : undefined,
      maxWidth: responsive.isTablet ? 700 : 500,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopLeftRadius: theme.roundness * 2,
      borderTopRightRadius: theme.roundness * 2,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: 'bold',
      textAlign: 'center',
      fontSize: responsive.isTablet ? 20 : 22,
    },
    scrollContent: {
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
    },
    card: {
      backgroundColor: theme.colors.surface,
      elevation: 1,
    },
    input: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
    },
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 16,
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    divider: {
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantsSection: {
      marginTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantsHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantCard: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.elevation.level1,
      paddingVertical: responsive.isTablet
        ? 6
        : responsive.spacing(theme.spacing.xs),
      paddingLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingRight: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.xs),
    },
    variantCardInactive: {
      opacity: 0.7,
      backgroundColor: theme.colors.surfaceVariant,
    },
    variantContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    variantInfo: {
      flex: 1,
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.isTablet ? 1 : 2,
    },
    variantName: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '500',
      color: theme.colors.onSurface,
      flex: 1,
    },
    variantNameInactive: {
      color: theme.colors.onSurfaceVariant,
    },
    variantPrice: {
      fontSize: responsive.isTablet ? 12 : 14,
      color: theme.colors.primary,
      fontWeight: '600',
    },
    inactiveBadge: {
      backgroundColor: theme.colors.errorContainer,
      paddingHorizontal: responsive.isTablet
        ? 6
        : responsive.spacing(theme.spacing.xs),
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: 4,
      marginLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.xs),
    },
    inactiveBadgeText: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onErrorContainer,
      fontWeight: '600',
    },
    variantActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? 4 : 8,
    },
    variantActionButton: {
      margin: 0,
    },
    noVariantsText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    imagePickerContainer: {
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
    },
    modifierGroupSection: {
      marginTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    sectionTitle: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      marginLeft: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.xs),
      fontSize: responsive.isTablet ? 16 : 18,
    },
    noItemsText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    modifierGroupTouchable: {
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      marginHorizontal: responsive.isTablet
        ? -responsive.spacing(theme.spacing.s)
        : -responsive.spacing(theme.spacing.m),
    },
    modifierGroupContent: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    modifierGroupTextContainer: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    modifierGroupName: {
      fontSize: responsive.isTablet ? 13 : 15,
      color: theme.colors.onSurface,
    },
    modifiersList: {
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: responsive.isTablet ? 1 : 2,
    },
    modifiersListContainer: {
      marginTop: responsive.isTablet ? 2 : 4,
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: responsive.isTablet ? 2 : 4,
    },
    modifierItem: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      lineHeight: responsive.isTablet ? 15 : 18,
    },
    noModifiersText: {
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: responsive.isTablet ? 2 : 4,
      opacity: 0.7,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    formButton: {
      borderRadius: theme.roundness * 2,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      minWidth: responsive.isTablet ? 100 : 120,
    },
    cancelButton: {
      marginRight: 0,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 10,
      borderRadius: theme.roundness * 2,
    },
  });
export default ProductFormModal;

================
File: app/src/modules/orderFinalization/services/orderFinalizationService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  OrderForFinalization,
  OrderForFinalizationList,
  FinalizeOrdersPayload,
} from '../types/orderFinalization.types';
export const orderFinalizationService = {
  async getOrdersForFinalizationList(): Promise<OrderForFinalizationList[]> {
    const response = await apiClient.get(
      API_PATHS.ORDERS_FOR_FINALIZATION_LIST,
    );
    return response.data;
  },
  async getOrderForFinalizationDetail(
    orderId: string,
  ): Promise<OrderForFinalization> {
    const response = await apiClient.get(
      API_PATHS.ORDERS_FOR_FINALIZATION_DETAIL.replace(':id', orderId),
    );
    return response.data;
  },
  async finalizeOrders(payload: FinalizeOrdersPayload): Promise<void> {
    await apiClient.patch(API_PATHS.ORDERS_FINALIZE_MULTIPLE, payload);
  },
  async quickFinalizeMultipleOrders(
    orderIds: string[],
  ): Promise<{ message: string; ordersWithWarnings: string[] }> {
    const response = await apiClient.post(
      API_PATHS.ORDERS_QUICK_FINALIZE_MULTIPLE,
      { orderIds },
    );
    return response.data;
  },
  async printTicket(
    orderId: string,
    params: { printerId: string; ticketType: 'GENERAL' | 'BILLING' },
  ): Promise<void> {
    await apiClient.post(
      API_PATHS.ORDERS_PRINT_TICKET.replace(':orderId', orderId),
      params,
    );
  },
};

================
File: app/src/modules/orders/screens/OrdersScreen.tsx
================
import React from 'react';
import { StyleSheet, View, ScrollView, RefreshControl } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Button, ActivityIndicator, Text } from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useAppTheme } from '@/app/styles/theme';
import type { OrdersStackParamList } from '@/app/navigation/types';
import { useGlobalShift } from '@/app/hooks/useGlobalShift';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';
function OrdersScreen() {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const navigation =
    useNavigation<NativeStackNavigationProp<OrdersStackParamList>>();
  const { data: shift, isLoading, isFetching, refetch } = useGlobalShift();
  const [isManualRefreshing, setIsManualRefreshing] = React.useState(false);
  const handleRefresh = React.useCallback(async () => {
    setIsManualRefreshing(true);
    await refetch();
    setIsManualRefreshing(false);
  }, [refetch]);
  const handleOpenOrders = () => {
    if (shift && shift.status === 'OPEN') {
      navigation.navigate(NAVIGATION_PATHS.OPEN_ORDERS);
    }
  };
  const handleCreateOrder = () => {
    if (shift && shift.status === 'OPEN') {
      navigation.navigate(NAVIGATION_PATHS.CREATE_ORDER);
    }
  };
  const isShiftOpen = shift && shift.status === 'OPEN';
  return (
    <SafeAreaView style={styles.container}>
      <ScrollView
        style={styles.scrollView}
        refreshControl={
          <RefreshControl
            refreshing={isManualRefreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={styles.scrollContent}
      >
        <View style={styles.content}>
          {}
          {(isLoading || (isFetching && !isManualRefreshing)) && (
            <View style={styles.loadingIndicator}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text variant="bodySmall" style={styles.loadingText}>
                Actualizando estado del turno...
              </Text>
            </View>
          )}
          {}
          <Button
            mode="contained"
            onPress={handleCreateOrder}
            style={[styles.button, !isShiftOpen && styles.buttonDisabled]}
            contentStyle={styles.buttonContent}
            icon="plus-circle-outline"
            disabled={!isShiftOpen}
          >
            Crear Orden
          </Button>
          {}
          <Button
            mode="contained"
            onPress={handleOpenOrders}
            style={[styles.button, !isShiftOpen && styles.buttonDisabled]}
            contentStyle={styles.buttonContent}
            icon="folder-open-outline"
            disabled={!isShiftOpen}
          >
            Órdenes Abiertas
          </Button>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}
const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
    },
    scrollContent: {
      flexGrow: 1,
    },
    content: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    loadingIndicator: {
      position: 'absolute',
      top: theme.spacing.m,
      alignSelf: 'center',
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.surfaceVariant,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      gap: theme.spacing.s,
    },
    loadingText: {
      color: theme.colors.onSurfaceVariant,
    },
    title: {
      marginBottom: theme.spacing.l,
      color: theme.colors.onBackground,
    },
    button: {
      width: '90%',
      marginVertical: theme.spacing.l,
    },
    buttonDisabled: {
      opacity: 0.6,
    },
    buttonContent: {
      paddingVertical: theme.spacing.m,
    },
  });
export default OrdersScreen;

================
File: app/src/modules/orders/services/orderService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { FindAllOrdersDto, OrderOpenList } from '../types/orders.types';
import type { PaginatedResponse } from '../../../app/types/api.types';
import type { OrderDetailsForBackend } from '../components/OrderCartDetail';
import type { UpdateOrderPayload } from '../types/update-order.types';
const createOrder = async (
  orderData: OrderDetailsForBackend,
): Promise<Order> => {
  const response = await apiClient.post<Order>(API_PATHS.ORDERS, orderData);
  return response.data;
};
export const orderService = {
  createOrder,
  getOrders: async (
    filters: FindAllOrdersDto = {},
  ): Promise<PaginatedResponse<Order>> => {
    const queryParams: Record<string, any> = {};
    for (const [key, value] of Object.entries(filters)) {
      if (value !== undefined) {
        if (key !== 'page' && key !== 'limit') {
          queryParams[key] = value;
        }
      }
    }
    const page = filters.page ?? 1;
    const limit = filters.limit ?? 10;
    queryParams.page = page;
    queryParams.limit = limit;
    const response = await apiClient.get<[Order[], number]>(API_PATHS.ORDERS, {
      params: queryParams,
    });
    const [data, total] = response.data;
    const totalPages = limit > 0 ? Math.ceil(total / limit) : 1;
    return {
      data,
      total,
      page,
      limit,
      totalPages,
    };
  },
  getOpenOrdersCurrentShift: async (): Promise<Order[]> => {
    const response = await apiClient.get<Order[]>(
      API_PATHS.ORDERS_OPEN_CURRENT_SHIFT,
    );
    return response.data;
  },
  getOpenOrdersList: async (): Promise<OrderOpenList[]> => {
    const response = await apiClient.get<OrderOpenList[]>(
      API_PATHS.ORDERS_OPEN_ORDERS_LIST,
    );
    return response.data;
  },
  printOrderTicket: async (
    orderId: string,
    printerId: string,
  ): Promise<void> => {
    const url = API_PATHS.PRINT_ORDER_TICKET;
    const body = { orderId, printerId };
    await apiClient.post<any>(url, body);
  },
  getOrderById: async (orderId: string): Promise<Order> => {
    const response = await apiClient.get<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
    );
    return response.data;
  },
  updateOrder: async (
    orderId: string,
    payload: UpdateOrderPayload,
  ): Promise<Order> => {
    const response = await apiClient.patch<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
      payload,
    );
    return response.data;
  },
  cancelOrder: async (orderId: string): Promise<Order> => {
    const payload: UpdateOrderPayload = {
      orderStatus: 'CANCELLED',
    };
    const response = await apiClient.patch<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
      payload,
    );
    return response.data;
  },
};

================
File: app/src/modules/preparationScreens/screens/PreparationScreensScreen.tsx
================
import React, { useCallback, useMemo, useState } from 'react';
import { StyleSheet } from 'react-native';
import { IconButton, Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import { discoveryService } from '@/app/services/discoveryService';
import GenericList, {
  FilterOption,
} from '../../../app/components/crud/GenericList';
import PreparationScreenDetailModalSimple from '../components/PreparationScreenDetailModalSimple';
import PreparationScreenListItem from '../components/PreparationScreenListItem';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import PreparationScreenFormModal from '../components/PreparationScreenFormModal';
import { ProductSelectionModal } from '../components/ProductSelectionModal';
import {
  useGetPreparationScreens,
  useGetPreparationScreenById,
  useDeletePreparationScreen,
  useGetMenuWithAssociations,
  useAssociateProducts,
} from '../hooks/usePreparationScreensQueries';
import {
  PreparationScreen,
  FindAllPreparationScreensDto as FindAllPreparationScreensFilter,
} from '../schema/preparationScreen.schema';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { BaseListQuery } from '../../../app/types/query.types';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
  });
const PreparationScreensScreen = () => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const [filters, setFilters] = useState<FindAllPreparationScreensFilter>({});
  const [pagination, setPagination] = useState<BaseListQuery>({
    page: 1,
    limit: 15,
  });
  const [searchTerm, setSearchTerm] = useState('');
  const [isProductModalVisible, setIsProductModalVisible] = useState(false);
  const [productModalScreenId, setProductModalScreenId] = useState<
    string | null
  >(null);
  const {
    data: screensData,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: errorList,
  } = useGetPreparationScreens(filters, pagination);
  const { mutate: deleteScreenMutate } = useDeletePreparationScreen();
  const associateProductsMutation = useAssociateProducts();
  const deleteScreenWrapper = useCallback(
    async (id: string): Promise<void> => {
      return new Promise((resolve, reject) => {
        deleteScreenMutate(id, {
          onSuccess: () => resolve(),
          onError: (error) => reject(error),
        });
      });
    },
    [deleteScreenMutate],
  );
  // Hooks para el modal de productos
  const { data: menuData, isLoading: isLoadingMenu } =
    useGetMenuWithAssociations(productModalScreenId, {
      enabled: !!productModalScreenId && isProductModalVisible,
    });
  // Recargar automáticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('preparation-screens');
  const enrichedMenuData = React.useMemo(() => {
    if (!menuData || !screensData?.data) return menuData;
    const screenAssignments: Record<string, string> = {};
    screensData.data.forEach((screen) => {
      if (screen.products) {
        screen.products.forEach((product) => {
          screenAssignments[product.id] = screen.name;
        });
      }
    });
    return {
      ...menuData,
      screenAssignments,
    };
  }, [menuData, screensData]);
  const handleOpenProductModal = useCallback((screen: PreparationScreen) => {
    setProductModalScreenId(screen.id);
    setIsProductModalVisible(true);
  }, []);
  const handleCloseProductModal = useCallback(() => {
    setIsProductModalVisible(false);
    setProductModalScreenId(null);
  }, []);
  const handleSaveProducts = useCallback(
    (productIds: string[]) => {
      if (productModalScreenId) {
        associateProductsMutation.mutate(
          { id: productModalScreenId, productIds },
          {
            onSuccess: () => {
              handleCloseProductModal();
              refetchList();
            },
          },
        );
      }
    },
    [
      productModalScreenId,
      associateProductsMutation,
      handleCloseProductModal,
      refetchList,
    ],
  );
  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<PreparationScreen>({
    entityName: 'Pantalla de Preparación',
    queryKey: ['preparationScreens', filters, pagination],
    deleteMutationFn: deleteScreenWrapper,
  });
  const selectedScreenId = selectedItem?.id ?? null;
  const { data: selectedScreenData } = useGetPreparationScreenById(
    selectedScreenId,
    {
      enabled: !!selectedScreenId && isDetailModalVisible,
    },
  );
  const handleRefresh = useCallback(async () => {
    if (
      errorList &&
      (errorList.message?.includes('conexión') ||
        errorList.message?.includes('network'))
    ) {
      try {
        await discoveryService.forceRediscovery();
        await new Promise((resolve) => setTimeout(resolve, 500));
      } catch (error) {
      }
    }
    refetchList();
  }, [refetchList, errorList]);
  const handleSearchChange = useCallback((query: string) => {
    setSearchTerm(query);
    const timerId = setTimeout(() => {
      setFilters((prev: FindAllPreparationScreensFilter) => ({
        ...prev,
        name: query || undefined,
      }));
      setPagination((prev) => ({ ...prev, page: 1 }));
    }, 500);
    return () => clearTimeout(timerId);
  }, []);
  const handleFilterChange = useCallback((value: string | number) => {
    const strValue = String(value);
    let newIsActive: boolean | undefined;
    if (strValue === 'true') newIsActive = true;
    else if (strValue === 'false') newIsActive = false;
    else newIsActive = undefined;
    setFilters((prev: FindAllPreparationScreensFilter) => ({
      ...prev,
      isActive: newIsActive,
    }));
    setPagination((prev) => ({ ...prev, page: 1 }));
  }, []);
  const listRenderConfig = {
    titleField: 'name' as keyof PreparationScreen,
    descriptionField: 'description' as keyof PreparationScreen,
    statusConfig: {
      field: 'isActive' as keyof PreparationScreen,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
    renderDescription: (item: PreparationScreen) => {
      const parts: string[] = [];
      if (item.description) {
        parts.push(item.description);
      }
      if (item.users && item.users.length > 0) {
        const userNames = item.users
          .map((user) => {
            const fullName =
              `${user.firstName || ''} ${user.lastName || ''}`.trim();
            return fullName || user.username;
          })
          .join(', ');
        parts.push(`Usuarios: ${userNames}`);
      }
      const text = parts.join(' • ');
      if (!text) return null;
      return (
        <Text variant="bodyMedium" numberOfLines={2} ellipsizeMode="tail">
          {text}
        </Text>
      );
    },
  };
  const filterOptions: FilterOption<string>[] = [
    { value: '', label: 'Todas' },
    { value: 'true', label: 'Activas' },
    { value: 'false', label: 'Inactivas' },
  ];
  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!errorList,
    data: screensData?.data,
    emptyConfig: {
      title: searchTerm
        ? 'No se encontraron pantallas'
        : 'No hay pantallas de preparación',
      message: searchTerm
        ? `No se encontraron pantallas para "${searchTerm}"`
        : 'No hay pantallas de preparación creadas. Presiona el botón + para crear la primera.',
      icon: 'monitor-dashboard',
    },
    errorConfig: {
      title: 'Error al cargar pantallas',
      message: errorList?.message?.includes('encontrar el servidor')
        ? 'No se pudo encontrar el servidor. Verifica que el servidor esté encendido y en la misma red.'
        : 'No se pudieron cargar las pantallas de preparación. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      actionText: 'Reintentar',
      onAction: handleRefresh,
    },
  });
  const renderItem = useCallback(
    ({ item }: { item: PreparationScreen }) => (
      <PreparationScreenListItem
        item={item}
        onPress={handleOpenDetailModal}
        onManageProducts={handleOpenProductModal}
      />
    ),
    [handleOpenDetailModal, handleOpenProductModal],
  );
  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<PreparationScreen>
        showImagePlaceholder={false}
        items={screensData?.data ?? []}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchTerm}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar por nombre..."
        filterOptions={filterOptions}
        filterValue={
          filters.isActive === true
            ? 'true'
            : filters.isActive === false
              ? 'false'
              : ''
        }
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={
          isDetailModalVisible || isFormModalVisible || isProductModalVisible
        }
        isDrawerOpen={isDrawerOpen}
        renderItemActions={(item) => (
          <IconButton
            icon="link"
            size={20}
            onPress={() => handleOpenProductModal(item)}
          />
        )}
        renderItem={renderItem}
      />
      <PreparationScreenDetailModalSimple
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedScreenData ?? selectedItem ?? null}
        onEdit={() => {
          const itemToEdit = selectedScreenData ?? selectedItem;
          if (itemToEdit) {
            handleOpenEditModal(itemToEdit);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        onManageProducts={handleOpenProductModal}
        isDeleting={isDeleting}
      />
      <PreparationScreenFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        editingItem={editingItem}
        onSubmitSuccess={() => {}}
      />
      <ProductSelectionModal
        visible={isProductModalVisible}
        onDismiss={handleCloseProductModal}
        onSave={handleSaveProducts}
        screenId={productModalScreenId || ''}
        menuData={enrichedMenuData}
        loading={isLoadingMenu}
      />
    </SafeAreaView>
  );
};
export default PreparationScreensScreen;

================
File: app/src/modules/printers/screens/PrintersScreen.tsx
================
import React, { useState, useMemo, useCallback } from 'react';
import { View, StyleSheet, FlatList } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, ActivityIndicator, IconButton, FAB } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import PrinterDiscoveryModal from '../components/PrinterDiscoveryModal';
import PrinterFormModal from '../components/PrinterFormModal';
import PrinterListItem from '../components/PrinterListItem';
import PrinterDetailModal from '../components/PrinterDetailModal';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
} from '../types/printer.types';
import { useListState } from '../../../app/hooks/useListState';
import {
  usePrintersQuery,
  useDeletePrinterMutation,
  usePingPrinterMutation,
  useTestPrintPrinter,
} from '../hooks/usePrintersQueries';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useDrawerStatus } from '@react-navigation/drawer';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';
const PrintersScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const [isDiscoveryModalVisible, setIsDiscoveryModalVisible] = useState(false);
  const [discoveredPrinterData, setDiscoveredPrinterData] =
    useState<Partial<CreateThermalPrinterDto> | null>(null);
  const [pingingPrinterId, setPingingPrinterId] = useState<string | null>(null);
  const [testPrintingPrinterId, setTestPrintingPrinterId] = useState<
    string | null
  >(null);
  const [fabOpen, setFabOpen] = useState(false);
  const queryParams = useMemo(
    () => ({
      isActive: undefined,
      page: 1,
      limit: 50,
    }),
    [],
  );
  const {
    data: printersResponse,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: listError,
  } = usePrintersQuery(queryParams);
  const { mutateAsync: deletePrinter } = useDeletePrinterMutation();
  const pingPrinterMutation = usePingPrinterMutation();
  const testPrintMutation = useTestPrintPrinter();
  useRefreshModuleOnFocus('thermalPrinters');
  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<ThermalPrinter>({
    entityName: 'Impresora',
    queryKey: ['thermalPrinters', queryParams],
    deleteMutationFn: deletePrinter,
  });
  const handleTestPrint = useCallback(
    async (printerId: string) => {
      setTestPrintingPrinterId(printerId);
      try {
        await testPrintMutation.mutateAsync(printerId);
      } catch (error) {
      } finally {
        setTestPrintingPrinterId(null);
      }
    },
    [testPrintMutation],
  );
  const handleOpenAddModal = () => {
    setDiscoveredPrinterData(null);
    handleOpenCreateModal();
  };
  const handleOpenDiscoveryModal = () => {
    setIsDiscoveryModalVisible(true);
  };
  const handleDismissDiscoveryModal = () => {
    setIsDiscoveryModalVisible(false);
  };
  const handlePrinterSelectedFromDiscovery = (printer: DiscoveredPrinter) => {
    setDiscoveredPrinterData({
      name: printer.name || `Impresora ${printer.ip}`,
      connectionType: 'NETWORK',
      ipAddress: printer.ip,
      port: printer.port,
      macAddress: printer.mac || undefined,
    });
    setIsDiscoveryModalVisible(false);
    handleOpenCreateModal();
  };
  const renderPrinter = useCallback(
    ({ item }: { item: ThermalPrinter }) => {
      const isPingingThis = pingingPrinterId === item.id;
      const canPing = item.connectionType === 'NETWORK';
      return (
        <PrinterListItem
          printer={item}
          onPress={() => handleOpenDetailModal(item)}
          renderActions={
            <View style={styles.itemActionsContainer}>
              {isPingingThis ? (
                <ActivityIndicator size={32} style={styles.pingIndicator} />
              ) : (
                <IconButton
                  icon="radar"
                  size={32}
                  onPress={() => handlePingPrinter(item.id)}
                  disabled={!canPing || pingPrinterMutation.isPending}
                  iconColor={
                    canPing
                      ? theme.colors.primary
                      : theme.colors.onSurfaceDisabled
                  }
                  style={styles.actionButton}
                />
              )}
            </View>
          }
        />
      );
    },
    [
      pingingPrinterId,
      pingPrinterMutation.isPending,
      handlePingPrinter,
      handleOpenDetailModal,
      theme.colors,
      styles,
    ],
  );
  const filteredData = useMemo(() => {
    if (!printersResponse?.data) return [];
    return printersResponse.data;
  }, [printersResponse?.data]);
  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!listError,
    data: printersResponse?.data,
    emptyConfig: {
      title: 'No hay impresoras',
      message:
        'No hay impresoras configuradas. Presiona el botón + para agregar una nueva o descubrir impresoras en la red.',
      icon: 'printer-outline',
    },
    errorConfig: {
      title: 'Error al cargar impresoras',
      message: 'No se pudieron cargar las impresoras. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchList,
    },
  });
  const handlePingPrinter = useCallback(
    async (printerId: string) => {
      setPingingPrinterId(printerId);
      try {
        await pingPrinterMutation.mutateAsync(printerId);
      } catch (error) {
      } finally {
        setPingingPrinterId(null);
      }
    },
    [pingPrinterMutation],
  );
  const renderEmptyList = () => {
    if (isLoadingList) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }
    return ListEmptyComponent;
  };
  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      {}
      <FlatList
        data={filteredData}
        renderItem={renderPrinter}
        keyExtractor={(item) => item.id}
        onRefresh={refetchList}
        refreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={renderEmptyList()}
        contentContainerStyle={[
          styles.listPadding,
          filteredData.length === 0 && styles.emptyListContainer,
        ]}
      />
      <Portal>
        {}
        <PrinterDiscoveryModal
          visible={isDiscoveryModalVisible}
          onDismiss={handleDismissDiscoveryModal}
          onPrinterSelect={handlePrinterSelectedFromDiscovery}
        />
        {}
        <PrinterFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          editingItem={editingItem}
          initialDataFromDiscovery={
            !editingItem ? (discoveredPrinterData ?? undefined) : undefined
          }
        />
        {}
        <PrinterDetailModal
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          printer={selectedItem}
          onEdit={() => selectedItem && handleOpenEditModal(selectedItem)}
          deleteConfirmation={deleteConfirmation}
          onTestPrint={() => selectedItem && handleTestPrint(selectedItem.id)}
          isDeleting={isDeleting}
          isTestPrinting={testPrintingPrinterId === selectedItem?.id}
        />
        {}
        <FAB.Group
          open={fabOpen}
          visible={
            !isFormModalVisible &&
            !isDetailModalVisible &&
            !isDiscoveryModalVisible &&
            !isDrawerOpen
          }
          icon={fabOpen ? 'close' : 'plus'}
          actions={[
            {
              icon: 'magnify-scan',
              label: 'Descubrir en Red',
              onPress: handleOpenDiscoveryModal,
              style: { backgroundColor: theme.colors.tertiaryContainer },
              color: theme.colors.onTertiaryContainer,
              labelTextColor: theme.colors.onTertiaryContainer,
              size: 'small',
            },
            {
              icon: 'plus',
              label: 'Añadir Manual',
              onPress: handleOpenAddModal,
              style: { backgroundColor: theme.colors.secondaryContainer },
              color: theme.colors.onSecondaryContainer,
              labelTextColor: theme.colors.onSecondaryContainer,
              size: 'small',
            },
          ]}
          onStateChange={({ open }) => setFabOpen(open)}
          onPress={() => {
            if (fabOpen) {
            }
          }}
          fabStyle={{ backgroundColor: theme.colors.primary }}
          color={theme.colors.onPrimary}
        />
      </Portal>
    </SafeAreaView>
  );
};
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listPadding: {
      paddingBottom: 80,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    emptyListContainer: {
      flex: 1,
      minHeight: responsive.isTablet ? 350 : 400,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.xl),
    },
    itemActionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
    },
    actionButton: {
      margin: 0,
      padding: 0,
      width: responsive.isTablet ? 44 : 52,
      height: responsive.isTablet ? 44 : 52,
      borderRadius: responsive.isTablet ? 22 : 26,
      backgroundColor: theme.colors.surfaceVariant,
      elevation: 2,
    },
    pingIndicator: {
      width: responsive.isTablet ? 44 : 52,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: responsive.isTablet ? 22 : 26,
      backgroundColor: theme.colors.primaryContainer,
      elevation: 2,
    },
    errorText: {
      color: theme.colors.error,
      textAlign: 'center',
      fontSize: responsive.fontSize(14),
    },
  });
export default PrintersScreen;

================
File: app/src/modules/receipts/services/receiptService.ts
================
import apiClient from '@/app/services/apiClient';
import type { QueryOptions } from '@tanstack/react-query';
import { API_PATHS } from '@/app/constants/apiPaths';
import { ApiError } from '@/app/lib/errors';
import type {
  Receipt,
  ReceiptsListResponse,
  ReceiptFilters,
} from '../types/receipt.types';
import type { Order } from '@/modules/orders/types/orders.types';
export const receiptService = {
  getReceiptsList: async (
    params: ReceiptFilters = {},
  ): Promise<ReceiptsListResponse> => {
    const { startDate, endDate, orderType } = params;
    const queryParams: Record<string, any> = {};
    if (startDate) {
      queryParams.startDate = startDate;
    }
    if (endDate) {
      queryParams.endDate = endDate;
    }
    if (orderType) {
      queryParams.orderType = orderType;
    }
    const response = await apiClient.get<ReceiptsListResponse>(
      API_PATHS.ORDERS_RECEIPTS_LIST,
      queryParams,
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
  getReceiptById: async (id: string): Promise<Receipt> => {
    const response = await apiClient.get<Receipt>(
      API_PATHS.ORDERS_RECEIPTS_BY_ID.replace(':id', id),
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
  recoverOrder: async (id: string): Promise<Order> => {
    const response = await apiClient.post<Order>(
      API_PATHS.ORDERS_RECOVER.replace(':id', id),
      {},
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
};
export const receiptQueryOptions = {
  receipts: (
    params: ReceiptFilters = {},
  ): QueryOptions<ReceiptsListResponse, Error> => ({
    queryKey: ['receipts', params],
    queryFn: () => receiptService.getReceiptsList(params),
    refetchOnWindowFocus: true,
    refetchOnMount: true,
  }),
  receipt: (id: string): QueryOptions<Receipt, Error> => ({
    queryKey: ['receipt', id],
    queryFn: () => receiptService.getReceiptById(id),
  }),
};

================
File: app/src/services/autoReconnectService.ts
================
import EventEmitter from 'eventemitter3';
import { healthMonitoringService } from './healthMonitoringService';
import { discoveryService } from '@/app/services/discoveryService';
import NetInfo from '@react-native-community/netinfo';
import { NETWORK_CONFIG } from '@/app/constants/network';
export type ReconnectStatus =
  | 'idle'
  | 'checking-network'
  | 'checking-health'
  | 'running-discovery'
  | 'connected'
  | 'no-wifi'
  | 'failed';
export interface ReconnectState {
  status: ReconnectStatus;
  isReconnecting: boolean;
  attempts: number;
  lastError: string | null;
  logs: string[];
}
class AutoReconnectService extends EventEmitter {
  private state: ReconnectState = {
    status: 'idle',
    isReconnecting: false,
    attempts: 0,
    lastError: null,
    logs: [],
  };
  private reconnectTimer: NodeJS.Timeout | null = null;
  private isRunning = false;
  private readonly MAX_LOGS = 50;
  constructor() {
    super();
  }
  getState(): ReconnectState {
    return { ...this.state };
  }
  private addLog(message: string, type: 'info' | 'error' | 'success' = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
    const newLogs = [logEntry, ...this.state.logs].slice(0, this.MAX_LOGS);
    this.state.logs = newLogs;
    this.emit('stateChange', { ...this.state, logs: [...newLogs] });
  }
  private updateState(updates: Partial<ReconnectState>) {
    this.state = { ...this.state, ...updates };
    this.emit('stateChange', this.state);
  }
  async startAutoReconnect() {
    if (this.isRunning) {
      return;
    }
    this.isRunning = true;
    this.updateState({
      isReconnecting: true,
      attempts: 0,
      logs: [],
      lastError: null,
      status: 'idle',
    });
    this.addLog('Iniciando proceso de reconexión automática', 'info');
    await this.delay(100);
    await this.reconnectCycle();
  }
  stopAutoReconnect() {
    if (!this.isRunning) return;
    this.addLog('Deteniendo proceso de reconexión', 'info');
    this.isRunning = false;
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    this.updateState({
      isReconnecting: false,
      status: 'idle',
    });
  }
  private async reconnectCycle() {
    while (this.isRunning) {
      this.updateState({ attempts: this.state.attempts + 1 });
      this.addLog(`CICLO DE RECONEXIÓN #${this.state.attempts}`, 'info');
      const hasNetwork = await this.checkNetwork();
      if (!hasNetwork) {
        this.addLog('❌ Sin conexión WiFi. Esperando...', 'error');
        this.updateState({
          status: 'no-wifi',
          lastError: 'No hay conexión WiFi activa',
        });
        await this.delay(NETWORK_CONFIG.RECONNECT_CYCLE_DELAY);
        continue;
      }
      this.addLog('✅ WiFi conectado', 'success');
      this.addLog('Verificando servidor con health checks...', 'info');
      const healthOk = await this.tryHealthChecks();
      if (healthOk) {
        this.addLog('🎉 ¡SERVIDOR CONECTADO!', 'success');
        this.updateState({
          status: 'connected',
          isReconnecting: false,
          lastError: null,
        });
        this.isRunning = false;
        setTimeout(() => {
          this.emit('reconnected');
        }, 100);
        break;
      }
      this.addLog(
        'Health checks fallaron. Buscando servidor en red...',
        'info',
      );
      const discoveryOk = await this.tryDiscovery();
      if (discoveryOk) {
        this.addLog('📍 Servidor encontrado. Verificando...', 'info');
        const postDiscoveryHealth = await this.tryHealthChecks(1);
        if (postDiscoveryHealth) {
          this.addLog('🎉 ¡RECONEXIÓN EXITOSA!', 'success');
          this.updateState({
            status: 'connected',
            isReconnecting: false,
            lastError: null,
          });
          this.isRunning = false;
          setTimeout(() => {
            this.emit('reconnected');
          }, 100);
          break;
        } else {
          this.addLog('❌ Servidor encontrado pero no responde', 'error');
        }
      }
      this.addLog(
        `❌ Ciclo fallido. Esperando ${NETWORK_CONFIG.RECONNECT_CYCLE_DELAY / 1000}s...`,
        'error',
      );
      this.updateState({
        status: 'failed',
        lastError: 'No se pudo establecer conexión con el servidor',
      });
      await this.delay(NETWORK_CONFIG.RECONNECT_CYCLE_DELAY);
    }
  }
  private async checkNetwork(): Promise<boolean> {
    this.updateState({ status: 'checking-network' });
    try {
      const netInfo = await NetInfo.fetch();
      const hasWifi =
        !!netInfo.isConnected &&
        (netInfo.type === 'wifi' || netInfo.type === 'ethernet');
      return hasWifi;
    } catch (error) {
      this.addLog('Error al verificar estado de red', 'error');
      return false;
    }
  }
  private async tryHealthChecks(
    maxAttempts = NETWORK_CONFIG.HEALTH_CHECK_ATTEMPTS,
  ): Promise<boolean> {
    this.updateState({ status: 'checking-health' });
    for (let i = 1; i <= maxAttempts; i++) {
      this.addLog(`  → Health check ${i}/${maxAttempts}...`, 'info');
      try {
        const isHealthy = await healthMonitoringService.forceCheck();
        if (isHealthy) {
          this.addLog('  ✓ Health check exitoso', 'success');
          return true;
        } else {
          this.addLog('  ✗ Health check falló', 'error');
        }
      } catch (error: unknown) {
        this.addLog('  ✗ Health check falló', 'error');
      }
      if (i < maxAttempts) {
        this.addLog(`  ⏳ Esperando 2s...`, 'info');
        await this.delay(2000);
      }
    }
    this.addLog('  ❌ Todos los health checks fallaron', 'error');
    return false;
  }
  private async tryDiscovery(): Promise<boolean> {
    this.updateState({ status: 'running-discovery' });
    discoveryService.setLogCallback((message: string) => {
      this.addLog(`  ${message}`, 'info');
    });
    try {
      this.addLog('  → Iniciando escaneo de red...', 'info');
      this.addLog('  → Buscando servidor en puerto 3737...', 'info');
      const url = await discoveryService.forceRediscovery();
      if (url) {
        this.addLog(`  ✓ ¡Servidor encontrado!`, 'success');
        this.addLog(`  📍 URL: ${url}`, 'success');
        return true;
      } else {
        this.addLog('  ✗ No se encontró servidor en la red', 'error');
        return false;
      }
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Error al buscar servidor';
      this.addLog(`  ✗ Error: ${errorMessage}`, 'error');
      return false;
    } finally {
      discoveryService.setLogCallback(null);
    }
  }
  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => {
      this.reconnectTimer = setTimeout(resolve, ms);
    });
  }
  subscribe(callback: (state: ReconnectState) => void): () => void {
    this.on('stateChange', callback);
    callback(this.state);
    return () => {
      this.off('stateChange', callback);
    };
  }
}
export const autoReconnectService = new AutoReconnectService();

================
File: app/src/modules/areasTables/screens/AreasScreen.tsx
================
import React, { useMemo, useCallback } from 'react';
import { StyleSheet } from 'react-native';
import { IconButton } from 'react-native-paper';
import { useDrawerStatus } from '@react-navigation/drawer';
import { SafeAreaView } from 'react-native-safe-area-context';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '../../../app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '../../../app/components/crud/GenericDetailModal';
import AreaFormModal from '../components/AreaFormModal';
import {
  useGetAreas,
  useCreateArea,
  useUpdateArea,
  useDeleteArea,
} from '../hooks/useAreasQueries';
import { Area, CreateAreaDto, UpdateAreaDto } from '../schema/area.schema';
import { AreasListScreenProps } from '../navigation/types';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';
const AreasScreen: React.FC<AreasListScreenProps> = ({ navigation }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const [searchQuery, setSearchQuery] = React.useState('');
  const [filterStatus, setFilterStatus] = React.useState<string>('all');
  const {
    data: areasData = [],
    isLoading: isLoadingAreas,
    isError: isErrorAreas,
    refetch: refetchAreas,
    isRefetching,
  } = useGetAreas(
    {
      name: searchQuery || undefined,
      isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
    },
    { page: 1, limit: 100 },
  );
  const createAreaMutation = useCreateArea();
  const updateAreaMutation = useUpdateArea();
  const { mutateAsync: deleteArea } = useDeleteArea();
  useRefreshModuleOnFocus('areas');
  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Area>({
    entityName: 'Área',
    queryKey: [
      'areas',
      {
        name: searchQuery || undefined,
        isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
      },
    ],
    deleteMutationFn: deleteArea,
  });
  const isSubmitting =
    createAreaMutation.isPending || updateAreaMutation.isPending;
  const handleFormSubmit = async (data: CreateAreaDto | UpdateAreaDto) => {
    try {
      if (editingItem) {
        await updateAreaMutation.mutateAsync({
          id: editingItem.id,
          data: data as UpdateAreaDto,
        });
      } else {
        await createAreaMutation.mutateAsync(data as CreateAreaDto);
      }
      handleCloseModals();
    } catch (error) {}
  };
  const handleNavigateToTables = (area: Area) => {
    navigation.navigate(NAVIGATION_PATHS.TABLES_LIST, {
      areaId: area.id,
      areaName: area.name,
    });
  };
  const listRenderConfig: RenderItemConfig<Area> = {
    titleField: 'name',
    descriptionField: 'description',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };
  const areaDetailFields: DisplayFieldConfig<Area>[] = [
    { field: 'description', label: 'Descripción' },
  ];
  const areaDetailStatusConfig = listRenderConfig.statusConfig;
  const filterOptions: FilterOption<string>[] = useMemo(
    () => [
      { label: 'Todas', value: 'all' },
      { label: 'Activas', value: 'true' },
      { label: 'Inactivas', value: 'false' },
    ],
    [],
  );
  const handleFilterChange = (value: string | number) => {
    setFilterStatus(String(value));
  };
  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
  };
  const handleRefresh = useCallback(() => {
    setSearchQuery('');
    setFilterStatus('all');
    refetchAreas();
  }, [refetchAreas]);
  const renderItemActions = (item: Area) => (
    <IconButton
      icon="format-list-bulleted"
      size={responsive.isTablet ? 24 : 28}
      onPress={() => handleNavigateToTables(item)}
      iconColor={theme.colors.primary}
    />
  );
  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingAreas,
    isError: isErrorAreas,
    data: areasData,
    emptyConfig: {
      title: 'No hay áreas',
      message:
        'No hay áreas registradas. Presiona el botón + para crear la primera.',
      icon: 'map-marker-outline',
    },
    errorConfig: {
      title: 'Error al cargar áreas',
      message: 'No se pudieron cargar las áreas. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchAreas,
    },
  });
  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Area>
        items={areasData}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        filterOptions={filterOptions}
        filterValue={filterStatus}
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        renderItemActions={renderItemActions}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        isDrawerOpen={isDrawerOpen}
        showImagePlaceholder={false}
      />
      <AreaFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSubmit={handleFormSubmit}
        editingItem={editingItem}
        isSubmitting={isSubmitting}
      />
      <GenericDetailModal<Area>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        statusConfig={areaDetailStatusConfig}
        fieldsToDisplay={areaDetailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        showImage={false}
      />
    </SafeAreaView>
  );
};
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
  });
export default AreasScreen;

================
File: app/src/modules/areasTables/screens/TablesScreen.tsx
================
import React, { useMemo, useCallback } from 'react';
import { StyleSheet } from 'react-native';
import { Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '../../../app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '../../../app/components/crud/GenericDetailModal';
import TableFormModal from '../components/TableFormModal';
import {
  useGetTablesByAreaId,
  useCreateTable,
  useUpdateTable,
  useDeleteTable,
} from '../hooks/useTablesQueries';
import { Table, CreateTableDto, UpdateTableDto } from '../schema/table.schema';
import { TablesListScreenProps } from '../navigation/types';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
const TablesScreen: React.FC<TablesListScreenProps> = ({ route }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const { areaId, areaName } = route.params;
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const [searchQuery, setSearchQuery] = React.useState('');
  const [filterStatus, setFilterStatus] = React.useState<string>('all');
  const {
    data: tablesData = [],
    isLoading: isLoadingTables,
    isError: isErrorTables,
    refetch: refetchTables,
    isRefetching,
  } = useGetTablesByAreaId(areaId, { enabled: !!areaId });
  useRefreshModuleOnFocus('tables');
  const createTableMutation = useCreateTable();
  const updateTableMutation = useUpdateTable();
  const { mutateAsync: deleteTable } = useDeleteTable();
  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Table>({
    entityName: 'Mesa',
    queryKey: ['tables', areaId],
    deleteMutationFn: deleteTable,
  });
  const isSubmitting =
    createTableMutation.isPending || updateTableMutation.isPending;
  const handleFormSubmit = async (data: CreateTableDto | UpdateTableDto) => {
    try {
      const dataWithAreaId = { ...data, areaId: areaId };
      if (editingItem) {
        await updateTableMutation.mutateAsync({
          id: editingItem.id,
          data: dataWithAreaId as UpdateTableDto,
        });
      } else {
        await createTableMutation.mutateAsync(dataWithAreaId as CreateTableDto);
      }
      handleCloseModals();
    } catch (error) {}
  };
  const listRenderConfig: RenderItemConfig<Table> = useMemo(
    () => ({
      titleField: 'name',
      descriptionField: 'capacity',
      descriptionFormatter: (capacity) =>
        capacity
          ? `Capacidad: ${capacity} ${capacity === 1 ? 'persona' : 'personas'}`
          : undefined,
      descriptionMaxLength: 30,
      statusConfig: {
        field: 'isActive',
        activeValue: true,
        activeLabel: 'Activa',
        inactiveLabel: 'Inactiva',
      },
    }),
    [],
  );
  const tableDetailFields: DisplayFieldConfig<Table>[] = useMemo(
    () => [
      {
        field: 'capacity',
        label: 'Capacidad',
        render: (value) => (
          <Text style={styles.fieldValueText}>
            {value !== null && value !== undefined
              ? String(value)
              : 'No especificada'}
          </Text>
        ),
      },
    ],
    [styles.fieldValueText],
  );
  const tableDetailStatusConfig = listRenderConfig.statusConfig;
  const filterOptions: FilterOption<string>[] = useMemo(
    () => [
      { label: 'Todas', value: 'all' },
      { label: 'Activas', value: 'true' },
      { label: 'Inactivas', value: 'false' },
    ],
    [],
  );
  const handleFilterChange = (value: string | number) => {
    setFilterStatus(String(value));
  };
  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
  };
  const handleRefresh = useCallback(() => {
    setSearchQuery('');
    setFilterStatus('all');
    refetchTables();
  }, [refetchTables]);
  const filteredAndSearchedTables = useMemo(() => {
    let processed = [...tablesData];
    const isActiveFilter =
      filterStatus === 'all' ? undefined : filterStatus === 'true';
    if (isActiveFilter !== undefined) {
      processed = processed.filter(
        (table) => table.isActive === isActiveFilter,
      );
    }
    if (searchQuery.trim()) {
      const lowerCaseQuery = searchQuery.toLowerCase();
      processed = processed.filter((table) =>
        table.name.toLowerCase().includes(lowerCaseQuery),
      );
    }
    return processed;
  }, [tablesData, filterStatus, searchQuery]);
  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingTables,
    isError: isErrorTables,
    data: filteredAndSearchedTables,
    emptyConfig: {
      title: 'No hay mesas',
      message: `No hay mesas registradas en ${areaName}. Presiona el botón + para crear la primera.`,
      icon: 'table-furniture',
    },
    errorConfig: {
      title: 'Error al cargar mesas',
      message: 'No se pudieron cargar las mesas. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchTables,
    },
  });
  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Table>
        items={filteredAndSearchedTables}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        filterOptions={filterOptions}
        filterValue={filterStatus}
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
      />
      <TableFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSubmit={handleFormSubmit}
        editingItem={editingItem}
        isSubmitting={isSubmitting}
      />
      <GenericDetailModal<Table>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        statusConfig={tableDetailStatusConfig}
        fieldsToDisplay={tableDetailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        showImage={false}
      />
    </SafeAreaView>
  );
};
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
    fieldValueText: {
      flexShrink: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
      fontSize: responsive.fontSize(14),
    },
  });
export default TablesScreen;

================
File: app/src/modules/menu/screens/CategoriesScreen.tsx
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { StyleSheet } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useDrawerStatus } from '@react-navigation/drawer';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, IconButton } from 'react-native-paper';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useAppTheme } from '../../../app/styles/theme';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
import { useListState } from '../../../app/hooks/useListState';
import GenericList from '../../../app/components/crud/GenericList';
import { FilterOption } from '../../../app/components/crud/GenericList';
import GenericDetailModal from '../../../app/components/crud/GenericDetailModal';
import GenericFormModal, {
  FormFieldConfig,
  ImagePickerConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  ImageUploadService,
  FileObject,
} from '../../../app/lib/imageUploadService';
import categoryService from '../services/categoryService';
import {
  Category,
  CategoryFormData,
  CreateCategoryDto,
  UpdateCategoryDto,
  categoryFormSchema,
} from '../schema/category.schema';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';
type RootStackParamList = {
  Categories: undefined;
  SubcategoriesScreen: { categoryId: string; categoryName?: string };
};
type CategoriesScreenNavigationProp = NativeStackNavigationProp<
  RootStackParamList,
  'Categories'
>;
const CategoriesScreen: React.FC = () => {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const navigation = useNavigation<CategoriesScreenNavigationProp>();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';
  const [modalVisible, setModalVisible] = useState(false);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(
    null,
  );
  const [activeFilter, setActiveFilter] = useState<string | number>('all');
  const [isUploadingImage, setIsUploadingImage] = useState(false);
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [categoryToDelete, setCategoryToDelete] = useState<string | null>(null);
  const {
    data: categoriesResponse,
    isLoading: isLoadingCategories,
    isError: isErrorCategories,
    refetch: refetchCategories,
    isFetching: isFetchingCategories,
  } = useQuery({
    queryKey: ['categories', { filter: activeFilter }],
    queryFn: () =>
      categoryService.getCategories({
        isActive:
          activeFilter === 'all' ? undefined : activeFilter === 'active',
      }),
  });
  useRefreshModuleOnFocus('categories');
  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingCategories,
    isError: isErrorCategories,
    data: categoriesResponse?.data,
    emptyConfig: {
      title: 'No hay categorías',
      message:
        activeFilter !== 'all'
          ? `No hay categorías ${activeFilter === 'active' ? 'activas' : 'inactivas'} registradas.`
          : 'No hay categorías registradas. Presiona el botón + para crear la primera.',
      icon: 'folder-outline',
    },
    errorConfig: {
      title: 'Error al cargar categorías',
      message: 'No se pudieron cargar las categorías. Verifica tu conexión.',
      icon: 'alert-circle-outline',
      onRetry: refetchCategories,
    },
  });
  const commonMutationOptions = {
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['categories'] });
      closeModals();
    },
    onError: (error: unknown) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      setIsUploadingImage(false);
    },
  };
  const createCategoryMutation = useMutation({
    mutationFn: (data: CreateCategoryDto) =>
      categoryService.createCategory(data),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({
        message: 'Categoría creada exitosamente',
        type: 'success',
      });
    },
  });
  const updateCategoryMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateCategoryDto }) =>
      categoryService.updateCategory(id, data),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({
        message: 'Categoría actualizada exitosamente',
        type: 'success',
      });
    },
  });
  const deleteCategoryMutation = useMutation({
    mutationFn: (id: string) => categoryService.deleteCategory(id),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({ message: 'Categoría eliminada', type: 'success' });
    },
  });
  const openAddModal = useCallback(() => {
    setEditingCategory(null);
    setModalVisible(true);
  }, []);
  const openEditModal = useCallback((category: Category) => {
    setEditingCategory(category);
    setDetailModalVisible(false);
    setModalVisible(true);
  }, []);
  const openDetailModal = useCallback((category: Category) => {
    setSelectedCategory(category);
    setDetailModalVisible(true);
  }, []);
  const closeModals = useCallback(() => {
    setModalVisible(false);
    setDetailModalVisible(false);
    setEditingCategory(null);
    setSelectedCategory(null);
    setIsUploadingImage(false);
  }, []);
  const handleFilterChange = (value: string | number) => {
    setActiveFilter(value);
  };
  const handleFormSubmit = async (
    formData: CategoryFormData,
    photoId: string | null | undefined,
  ) => {
    const { imageUri, ...dataToSubmit } = formData;
    const finalData: any = {
      ...dataToSubmit,
    };
    if (photoId !== undefined) {
      finalData.photoId = photoId;
    }
    if (editingCategory) {
      updateCategoryMutation.mutate({
        id: editingCategory.id,
        data: finalData as UpdateCategoryDto,
      });
    } else {
      createCategoryMutation.mutate(finalData as CreateCategoryDto);
    }
  };
  const handleDelete = (id: string) => {
    setCategoryToDelete(id);
    setShowDeleteConfirmation(true);
  };
  const handleConfirmDelete = () => {
    if (categoryToDelete) {
      deleteCategoryMutation.mutate(categoryToDelete);
      setShowDeleteConfirmation(false);
      setCategoryToDelete(null);
    }
  };
  const categories = useMemo(() => {
    return categoriesResponse?.data ?? [];
  }, [categoriesResponse?.data]);
  const styles = useMemo(
    () =>
      StyleSheet.create({
        container: { flex: 1, backgroundColor: theme.colors.background },
      }),
    [theme],
  );
  const [formInitialValues, setFormInitialValues] = useState<CategoryFormData>({
    name: '',
    description: null,
    isActive: true,
    sortOrder: 0,
    imageUri: null,
  });
  useEffect(() => {
    const loadFormData = async () => {
      if (editingCategory) {
        let imageUrl = null;
        if (editingCategory.photo?.path) {
          try {
            const { getImageUrl } = await import('@/app/lib/imageUtils');
            imageUrl = await getImageUrl(editingCategory.photo.path);
          } catch (error) {
            imageUrl = editingCategory.photo.path;
          }
        }
        setFormInitialValues({
          name: editingCategory.name,
          description: editingCategory.description ?? null,
          isActive: editingCategory.isActive,
          sortOrder: editingCategory.sortOrder ?? 0,
          imageUri: imageUrl,
        });
      } else {
        setFormInitialValues({
          name: '',
          description: null,
          isActive: true,
          sortOrder: 0,
          imageUri: null,
        });
      }
    };
    loadFormData();
  }, [editingCategory]);
  const selectedCategoryMapped = useMemo(() => {
    if (!selectedCategory) return null;
    return selectedCategory;
  }, [selectedCategory]);
  const filterOptions: FilterOption<string | number>[] = [
    { value: 'all', label: 'Todas' },
    { value: 'active', label: 'Activas' },
    { value: 'inactive', label: 'Inactivas' },
  ];
  const listRenderConfig = {
    titleField: 'name' as keyof Category,
    descriptionField: 'description' as keyof Category,
    descriptionMaxLength: 60,
    imageField: 'photo' as keyof Category,
    sortOrderField: 'sortOrder' as keyof Category,
    statusConfig: {
      field: 'isActive' as keyof Category,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };
  const formFieldsConfig: FormFieldConfig<CategoryFormData>[] = [
    { name: 'name', label: 'Nombre', type: 'text', required: true },
    {
      name: 'description',
      label: 'Descripción',
      type: 'textarea',
      numberOfLines: 3,
    },
    {
      name: 'sortOrder',
      label: 'Orden de visualización',
      type: 'number',
      placeholder: '0',
    },
    {
      name: 'isActive',
      label: 'Estado',
      type: 'switch',
      switchLabel: 'Activa',
    },
  ];
  const imagePickerConfig: ImagePickerConfig<CategoryFormData> = {
    imageUriField: 'imageUri',
    onImageUpload: async (file: FileObject) => {
      setIsUploadingImage(true);
      try {
        const result = await ImageUploadService.uploadImage(file);
        if (result.success && result.photoId) {
          return { id: result.photoId };
        }
        throw new Error(result.error || 'Error desconocido al subir imagen');
      } finally {
        setIsUploadingImage(false);
      }
    },
    determineFinalPhotoId: ImageUploadService.determinePhotoId,
    imagePickerSize: 150,
    placeholderIcon: 'folder-outline',
    placeholderText: 'Imagen de categoría',
  };
  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList
        items={categories}
        enableSort={true}
        enableSearch={true}
        searchPlaceholder="Buscar categorías..."
        filterValue={activeFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        renderItemActions={(item: Category) => (
          <IconButton
            icon="format-list-bulleted"
            size={28}
            onPress={() =>
              navigation.navigate('SubcategoriesScreen', {
                categoryId: item.id,
                categoryName: item.name,
              })
            }
            style={{ margin: 0 }}
          />
        )}
        renderConfig={listRenderConfig}
        onItemPress={openDetailModal}
        onRefresh={refetchCategories}
        isRefreshing={isFetchingCategories && !isLoadingCategories}
        ListEmptyComponent={ListEmptyComponent}
        showFab={true}
        onFabPress={openAddModal}
        isModalOpen={modalVisible || detailModalVisible}
        showImagePlaceholder={true}
        placeholderIcon="folder-outline"
        isDrawerOpen={isDrawerOpen}
      />
      <Portal>
        <GenericFormModal
          visible={modalVisible}
          onDismiss={closeModals}
          onSubmit={handleFormSubmit}
          formSchema={categoryFormSchema}
          formFields={formFieldsConfig}
          imagePickerConfig={imagePickerConfig}
          initialValues={formInitialValues}
          editingItem={editingCategory}
          isSubmitting={
            createCategoryMutation.isPending ||
            updateCategoryMutation.isPending ||
            isUploadingImage
          }
          modalTitle={(isEditing) =>
            isEditing ? 'Editar Categoría' : 'Nueva Categoría'
          }
          submitButtonLabel={(isEditing) => (isEditing ? 'Guardar' : 'Crear')}
        />
        <GenericDetailModal
          visible={detailModalVisible}
          onDismiss={closeModals}
          item={selectedCategoryMapped}
          titleField="name"
          imageField="photo"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={[
            {
              field: 'sortOrder',
              label: 'Orden de visualización',
              render: (value) => value ?? '0',
            },
            {
              field: 'createdAt',
              label: 'Fecha de creación',
              render: (value) => {
                if (!value) return 'N/A';
                const date = new Date(value as string);
                return date.toLocaleDateString('es-ES', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                });
              },
            },
            {
              field: 'updatedAt',
              label: 'Última actualización',
              render: (value) => {
                if (!value) return 'N/A';
                const date = new Date(value as string);
                return date.toLocaleDateString('es-ES', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                });
              },
            },
          ]}
          onEdit={openEditModal as (item: any) => void}
          onDelete={handleDelete}
          isDeleting={deleteCategoryMutation.isPending}
          showImage={true}
        />
        <ConfirmationModal
          visible={showDeleteConfirmation}
          title="Confirmar Eliminación"
          message="¿Estás seguro de que quieres eliminar esta categoría? Esta acción no se puede deshacer."
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
          onConfirm={handleConfirmDelete}
          onCancel={() => {
            setShowDeleteConfirmation(false);
            setCategoryToDelete(null);
          }}
          onDismiss={() => {
            setShowDeleteConfirmation(false);
            setCategoryToDelete(null);
          }}
        />
      </Portal>
    </SafeAreaView>
  );
};
export default CategoriesScreen;

================
File: app/src/modules/orders/hooks/useOrdersQueries.ts
================
import { useMemo } from 'react';
import {
  useMutation,
  useQuery,
  useQueryClient,
  UseQueryResult,
} from '@tanstack/react-query';
import { orderService } from '../services/orderService';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { OrderDetailsForBackend } from '../components/OrderCartDetail';
import type { FindAllOrdersDto, OrderOpenList } from '../types/orders.types';
import { ApiError } from '@/app/lib/errors';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import type { UpdateOrderPayload } from '../types/update-order.types';
const orderKeys = {
  all: ['orders'] as const,
  lists: () => [...orderKeys.all, 'list'] as const,
  list: (filters: FindAllOrdersDto) => [...orderKeys.lists(), filters] as const,
  openOrdersList: () => [...orderKeys.all, 'list', 'open-orders-list'] as const,
  details: () => [...orderKeys.all, 'detail'] as const,
  detail: (id: string) => [...orderKeys.details(), id] as const,
};
export const useCreateOrderMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<Order, ApiError, OrderDetailsForBackend>({
    mutationFn: orderService.createOrder,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: ['tables'] });
    },
    onError: (_error) => {
    },
  });
};
export const useUpdateOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  type UpdateVariables = { orderId: string; payload: UpdateOrderPayload };
  return useMutation<Order, ApiError, UpdateVariables>({
    mutationFn: ({ orderId, payload }) =>
      orderService.updateOrder(orderId, payload),
    onSuccess: (updatedOrder, variables) => {
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), variables.orderId],
      });
      queryClient.invalidateQueries({ queryKey: ['tables'] });
      showSnackbar({
        message: `Orden #${updatedOrder.shiftOrderNumber} actualizada`,
        type: 'success',
      });
    },
    onError: (error, variables) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al actualizar orden #${variables.orderId}: ${message}`,
        type: 'error',
      });
    },
  });
};
export const useCancelOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<Order, ApiError, string>({
    mutationFn: (orderId) => orderService.cancelOrder(orderId),
    onSuccess: (cancelledOrder, orderId) => {
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), orderId],
      });
      queryClient.invalidateQueries({ queryKey: ['tables'] });
      showSnackbar({
        message: `Orden #${cancelledOrder.shiftOrderNumber} cancelada`,
        type: 'info',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al cancelar orden: ${message}`,
        type: 'error',
      });
    },
  });
};
export const useCompleteOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  return useMutation<Order, ApiError, string>({
    mutationFn: (orderId) =>
      orderService.updateOrder(orderId, { orderStatus: 'COMPLETED' }),
    onSuccess: (completedOrder, orderId) => {
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), orderId],
      });
      showSnackbar({
        message: `Orden #${completedOrder.shiftOrderNumber} finalizada exitosamente`,
        type: 'success',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al finalizar orden: ${message}`,
        type: 'error',
      });
    },
  });
};
export const useGetOpenOrdersListQuery = (options?: {
  enabled?: boolean;
}): UseQueryResult<OrderOpenList[], ApiError> => {
  const queryKey = orderKeys.openOrdersList();
  return useQuery<OrderOpenList[], ApiError>({
    queryKey: queryKey,
    queryFn: () => orderService.getOpenOrdersList(),
    enabled: options?.enabled ?? true,
    refetchInterval: 10000,
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000,
    gcTime: 10 * 60 * 1000,
    placeholderData: (previousData) => previousData,
  });
};
export const useGetOrderByIdQuery = (
  orderId: string | null | undefined,
  options?: { enabled?: boolean },
): UseQueryResult<Order, ApiError> => {
  const detailQueryKey = useMemo(
    () =>
      orderId ? [...orderKeys.details(), orderId] : [...orderKeys.details()],
    [orderId],
  );
  return useQuery<Order, ApiError>({
    queryKey: detailQueryKey,
    queryFn: async () => {
      if (!orderId) {
        return Promise.reject(new Error('Order ID no proporcionado'));
      }
      const order = await orderService.getOrderById(orderId);
      return order;
    },
    enabled: !!orderId && (options?.enabled ?? true),
    staleTime: 0,
    gcTime: 0,
    refetchOnMount: 'always',
    refetchOnWindowFocus: true,
  });
};

================
File: app/src/services/shifts.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { ShiftSummary, ShiftOrder } from '@/modules/shiftAudit/types';
import type { Order } from '@/app/schemas/domain/order.schema';
export interface ShiftStatus {
  OPEN: 'OPEN';
  CLOSED: 'CLOSED';
}
export interface Shift {
  id: string;
  date: string;
  globalShiftNumber: number;
  shiftNumber: number;
  status: keyof ShiftStatus;
  openedAt: string;
  closedAt: string | null;
  openedBy: {
    id: string;
    firstName: string;
    lastName: string;
  };
  closedBy: {
    id: string;
    firstName: string;
    lastName: string;
  } | null;
  initialCash: number;
  finalCash: number | null;
  totalSales: number | null;
  totalOrders: number | null;
  cashDifference: number | null;
  expectedCash?: number | null;
  notes: string | null;
  closeNotes: string | null;
}
export interface OpenShiftDto {
  initialCash: number;
  notes?: string;
  date?: string;
}
export interface CloseShiftDto {
  finalCash: number;
  closeNotes?: string;
}
class ShiftsService {
  async getCurrentShift(): Promise<Shift | null> {
    try {
      const response = await apiClient.get(API_PATHS.SHIFTS_CURRENT);
      return response.data;
    } catch (error: any) {
      if (error.response?.status === 404) {
        return null;
      }
      throw error;
    }
  }
  async openShift(data: OpenShiftDto): Promise<Shift> {
    const response = await apiClient.post(API_PATHS.SHIFTS_OPEN, data);
    return response.data;
  }
  async closeShift(data: CloseShiftDto): Promise<Shift> {
    const response = await apiClient.post(API_PATHS.SHIFTS_CLOSE, data);
    return response.data;
  }
  async getHistory(params?: {
    startDate?: string;
    endDate?: string;
  }): Promise<Shift[]> {
    const queryParams = new URLSearchParams();
    if (params?.startDate) {
      queryParams.append('startDate', params.startDate);
    }
    if (params?.endDate) {
      queryParams.append('endDate', params.endDate);
    }
    const url = queryParams.toString()
      ? `${API_PATHS.SHIFTS_HISTORY}?${queryParams.toString()}`
      : API_PATHS.SHIFTS_HISTORY;
    const response = await apiClient.get(url);
    return response.data;
  }
  async getById(id: string): Promise<Shift> {
    const response = await apiClient.get(
      API_PATHS.SHIFTS_DETAIL.replace(':id', id),
    );
    return response.data;
  }
  async isShiftOpen(): Promise<boolean> {
    const currentShift = await this.getCurrentShift();
    return currentShift !== null && currentShift.status === 'OPEN';
  }
  async getOrdersByShift(shiftId: string): Promise<Order[]> {
    const url = API_PATHS.ORDERS_BY_SHIFT.replace(':shiftId', shiftId);
    const response = await apiClient.get<Order[]>(url);
    return Array.isArray(response.data) ? response.data : [];
  }
  calculateShiftSummary(shift: Shift, orders: Order[]): ShiftSummary {
    const normalizedShift = {
      ...shift,
      status: shift.status === 'OPEN' ? ('open' as const) : ('closed' as const),
    };
    const paymentMethodsSummary = new Map<
      string,
      { count: number; total: number }
    >();
    const productsSummary = new Map<
      string,
      { quantity: number; total: number }
    >();
    if (!Array.isArray(orders)) {
      return {
        shift,
        ordersCount: 0,
        totalSales: 0,
        paymentMethodsSummary: [],
        productsSummary: [],
      };
    }
    orders.forEach((order) => {
      const orderTotal =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;
      let paymentMethod = 'Sin pagar';
      if (order.payments && order.payments.length > 0) {
        paymentMethod = order.payments[0].paymentMethod || 'Efectivo';
      }
      const current = paymentMethodsSummary.get(paymentMethod) || {
        count: 0,
        total: 0,
      };
      paymentMethodsSummary.set(paymentMethod, {
        count: current.count + 1,
        total: current.total + orderTotal,
      });
      order.orderItems?.forEach((item: any) => {
        const productName =
          item.product?.name || item.productName || 'Producto';
        const itemTotal = item.total || item.quantity * item.unitPrice || 0;
        const current = productsSummary.get(productName) || {
          quantity: 0,
          total: 0,
        };
        productsSummary.set(productName, {
          quantity: current.quantity + (item.quantity || 1),
          total: current.total + itemTotal,
        });
      });
    });
    const totalSales = orders.reduce((sum, order) => {
      const orderTotal =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;
      return sum + orderTotal;
    }, 0);
    return {
      shift: normalizedShift,
      ordersCount: orders.length,
      totalSales: totalSales,
      paymentMethodsSummary: Array.from(paymentMethodsSummary.entries()).map(
        ([method, data]) => ({
          method,
          count: data.count,
          total: data.total,
        }),
      ),
      productsSummary: Array.from(productsSummary.entries())
        .map(([productName, data]) => ({
          productName,
          quantity: data.quantity,
          total: data.total,
        }))
        .sort((a, b) => b.total - a.total)
        .slice(0, 10),
    };
  }
  formatOrdersForDetail(orders: Order[]): ShiftOrder[] {
    if (!Array.isArray(orders)) {
      return [];
    }
    return orders.map((order) => {
      const total =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;
      let paymentMethod = 'Sin pagar';
      if (order.payments && order.payments.length > 0) {
        paymentMethod = order.payments[0].paymentMethod || 'Efectivo';
      }
      return {
        id: order.id,
        orderNumber:
          order.orderNumber || `#${order.shiftOrderNumber || order.id}`,
        total: total,
        status: order.orderStatus || 'COMPLETED',
        paymentMethod: paymentMethod,
        customerName: (order.deliveryInfo as any)?.customerName || null,
        createdAt:
          typeof order.createdAt === 'string'
            ? order.createdAt
            : order.createdAt.toISOString(),
        items:
          order.orderItems?.map((item: any) => ({
            id: item.id || String(Math.random()),
            productName: item.product?.name || item.productName || 'Producto',
            quantity: item.quantity || 1,
            unitPrice: item.unitPrice || 0,
            total: item.total || item.quantity * item.unitPrice || 0,
            modifiers:
              item.productModifiers?.map(
                (mod: any) => mod.modifierName || mod.name,
              ) || [],
          })) || [],
      };
    });
  }
}
export const shiftsService = new ShiftsService();

================
File: backend/src/shifts/shifts.service.ts
================
import {
  Injectable,
  BadRequestException,
  NotFoundException,
  ConflictException,
  Inject,
  forwardRef,
} from '@nestjs/common';
import { ShiftRepository } from './infrastructure/persistence/shift.repository';
import { Shift, ShiftStatus } from './domain/shift';
import { OpenShiftDto } from './dto/open-shift.dto';
import { CloseShiftDto } from './dto/close-shift.dto';
import { User } from '../users/domain/user';
import { RestaurantConfigService } from '../restaurant-config/restaurant-config.service';
import { OrderRepository } from '../orders/infrastructure/persistence/order.repository';
import { PaymentRepository } from '../payments/infrastructure/persistence/payment.repository';
import { toZonedTime, format } from 'date-fns-tz';
import { startOfDay } from 'date-fns';
import { v4 as uuidv4 } from 'uuid';
import { ORDER_REPOSITORY, PAYMENT_REPOSITORY } from '../common/tokens';
import { PaymentStatus } from '../payments/domain/payment';
import { OrderStatus } from '../orders/domain/enums/order-status.enum';
@Injectable()
export class ShiftsService {
  constructor(
    private readonly shiftRepository: ShiftRepository,
    @Inject(forwardRef(() => RestaurantConfigService))
    private readonly restaurantConfigService: RestaurantConfigService,
    @Inject(ORDER_REPOSITORY)
    private readonly orderRepository: OrderRepository,
    @Inject(PAYMENT_REPOSITORY)
    private readonly paymentRepository: PaymentRepository,
  ) {}
  async openShift(dto: OpenShiftDto, user: User): Promise<Shift> {
    const currentOpen = await this.shiftRepository.findCurrent();
    if (currentOpen) {
      throw new ConflictException(
        `Ya existe un turno abierto (${format(
          currentOpen.date,
          'dd/MM/yyyy',
        )} - Turno ${currentOpen.shiftNumber}). Debe cerrarlo antes de abrir uno nuevo.`,
      );
    }
    const config = await this.restaurantConfigService.getConfig();
    const timeZone = config.timeZone || 'America/Mexico_City';
    let operationalDate: Date;
    if (dto.date) {
      operationalDate = new Date(dto.date);
    } else {
      const now = new Date();
      const localNow = toZonedTime(now, timeZone);
      operationalDate = startOfDay(localNow);
    }
    const shiftsForDate =
      await this.shiftRepository.findAllByDate(operationalDate);
    const shiftNumber = shiftsForDate.length + 1;
    const globalShiftNumber =
      await this.shiftRepository.getNextGlobalShiftNumber();
    const shift = new Shift();
    shift.id = uuidv4();
    shift.date = operationalDate;
    shift.globalShiftNumber = globalShiftNumber;
    shift.shiftNumber = shiftNumber;
    shift.openedAt = new Date();
    shift.openedBy = user;
    shift.initialCash = dto.initialCash;
    shift.status = ShiftStatus.OPEN;
    shift.notes = dto.notes || null;
    shift.closedAt = null;
    shift.closedBy = null;
    shift.finalCash = null;
    shift.totalSales = null;
    shift.totalOrders = null;
    shift.cashDifference = null;
    shift.closeNotes = null;
    shift.createdAt = new Date();
    shift.updatedAt = new Date();
    shift.deletedAt = null;
    const createdShift = await this.shiftRepository.create(shift);
    await this.restaurantConfigService.updateConfig({
      acceptingOrders: true,
    });
    return createdShift;
  }
  async closeShift(dto: CloseShiftDto, user: User): Promise<Shift> {
    const currentShift = await this.shiftRepository.findCurrent();
    if (!currentShift) {
      throw new NotFoundException('No hay un turno abierto');
    }
    const openOrders = await this.orderRepository.findByStatus([
      OrderStatus.IN_PROGRESS,
      OrderStatus.IN_PREPARATION,
      OrderStatus.READY,
      OrderStatus.DELIVERED,
    ]);
    if (openOrders.length > 0) {
      throw new BadRequestException(
        `No se puede cerrar el turno. Hay ${openOrders.length} órdenes abiertas que deben ser completadas o canceladas.`,
      );
    }
    const shiftStart = currentShift.openedAt;
    const shiftEnd = new Date();
    const orders = await this.orderRepository.findByShiftId(currentShift.id);
    const completedOrders = orders.filter(
      (order) =>
        order.orderStatus === OrderStatus.COMPLETED ||
        order.orderStatus === OrderStatus.DELIVERED,
    );
    const totalSales = completedOrders.reduce(
      (sum, order) => sum + Number(order.total),
      0,
    );
    const cashPayments = await this.paymentRepository.findByDateRange(
      shiftStart,
      shiftEnd,
    );
    const cashSales = cashPayments
      .filter(
        (payment) =>
          payment.paymentStatus === PaymentStatus.COMPLETED &&
          payment.paymentMethod === 'CASH',
      )
      .reduce((sum, payment) => sum + Number(payment.amount), 0);
    const expectedCash = currentShift.initialCash + cashSales;
    const cashDifference = dto.finalCash - expectedCash;
    const updatedShift = await this.shiftRepository.update(currentShift.id, {
      closedAt: shiftEnd,
      closedBy: user,
      finalCash: dto.finalCash,
      totalSales: totalSales,
      totalOrders: orders.length,
      cashDifference: cashDifference,
      status: ShiftStatus.CLOSED,
      closeNotes: dto.closeNotes || null,
      updatedAt: new Date(),
    });
    if (!updatedShift) {
      throw new Error('Error al actualizar el turno');
    }
    await this.restaurantConfigService.updateConfig({
      acceptingOrders: false,
    });
    return updatedShift;
  }
  async getCurrentShift(): Promise<Shift | null> {
    return this.shiftRepository.findCurrent();
  }
  async isShiftOpen(): Promise<boolean> {
    const currentShift = await this.getCurrentShift();
    return currentShift !== null && currentShift.isOpen();
  }
  async getShiftSummary(id?: string): Promise<Shift> {
    let shift: Shift | null;
    if (id) {
      shift = await this.shiftRepository.findById(id);
    } else {
      shift = await this.shiftRepository.findCurrent();
    }
    if (!shift) {
      throw new NotFoundException('Turno no encontrado');
    }
    if (shift.isClosed()) {
      return shift;
    }
    const orders = await this.orderRepository.findByShiftId(shift.id);
    const completedOrders = orders.filter(
      (order) =>
        order.orderStatus === OrderStatus.COMPLETED ||
        order.orderStatus === OrderStatus.DELIVERED,
    );
    shift.totalSales = completedOrders.reduce(
      (sum, order) => sum + Number(order.total),
      0,
    );
    shift.totalOrders = orders.length;
    return shift;
  }
  async getHistory(limit: number = 30, offset: number = 0): Promise<Shift[]> {
    const openShifts = await this.shiftRepository.findByStatus(
      ShiftStatus.OPEN,
    );
    const closedShifts = await this.shiftRepository.findByStatus(
      ShiftStatus.CLOSED,
    );
    const openShiftsWithStats = await Promise.all(
      openShifts.map(async (shift) => {
        const shiftStart = shift.openedAt;
        const shiftEnd = new Date();
        const orders = await this.orderRepository.findByShiftId(shift.id);
        const completedOrders = orders.filter(
          (order) =>
            order.orderStatus === OrderStatus.COMPLETED ||
            order.orderStatus === OrderStatus.DELIVERED,
        );
        shift.totalSales = completedOrders.reduce(
          (sum, order) => sum + Number(order.total),
          0,
        );
        shift.totalOrders = orders.length;
        return shift;
      }),
    );
    const allShifts = [...openShiftsWithStats, ...closedShifts].sort(
      (a, b) => b.openedAt.getTime() - a.openedAt.getTime(),
    );
    return allShifts.slice(offset, offset + limit);
  }
  async calculateExpectedCash(): Promise<number> {
    const currentShift = await this.getCurrentShift();
    if (!currentShift) {
      throw new NotFoundException('No hay un turno abierto');
    }
    const shiftStart = currentShift.openedAt;
    const shiftEnd = new Date();
    const cashPayments = await this.paymentRepository.findByDateRange(
      shiftStart,
      shiftEnd,
    );
    const cashSales = cashPayments
      .filter(
        (payment) =>
          payment.paymentStatus === PaymentStatus.COMPLETED &&
          payment.paymentMethod === 'CASH',
      )
      .reduce((sum, payment) => sum + Number(payment.amount), 0);
    return currentShift.initialCash + cashSales;
  }
}

================
File: app/src/app/components/ConnectionErrorModal.tsx
================
import React, { useEffect, useState, useRef } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Dimensions,
  Platform,
} from 'react-native';
import {
  Text,
  Modal,
  Portal,
  Surface,
  Icon,
  IconButton,
  useTheme,
  ProgressBar,
  Button,
} from 'react-native-paper';
import { ServerConfigModal } from './ServerConfigModal';
import {
  autoReconnectService,
  ReconnectState,
} from '@/services/autoReconnectService';
import { useServerConnection } from '../hooks/useServerConnection';
import { useAuthStore } from '../store/authStore';
import { serverConnectionService } from '@/services/serverConnectionService';
const { width: screenWidth, height: screenHeight } = Dimensions.get('window');
export function ConnectionErrorModal() {
  const theme = useTheme();
  const { isConnected } = useServerConnection();
  const isLoggedIn = useAuthStore((state) => !!state.user);
  const [visible, setVisible] = useState(false);
  const [reconnectState, setReconnectState] = useState<ReconnectState>(
    autoReconnectService.getState(),
  );
  const [isPaused, setIsPaused] = useState(false);
  const [pausedLogs, setPausedLogs] = useState<string[]>([]);
  const scrollViewRef = useRef<ScrollView>(null);
  const [showConfigModal, setShowConfigModal] = useState(false);
  useEffect(() => {
    if (Platform.OS === 'web' && !isConnected && !isLoggedIn) {
      setVisible(true);
      return;
    }
    const unsubscribe = autoReconnectService.subscribe((state) => {
      setReconnectState(state);
      if (!isLoggedIn && state.isReconnecting) {
        setVisible(true);
      }
      if (state.status === 'connected') {
        setVisible(false);
      }
    });
    return () => {
      unsubscribe();
    };
  }, [isLoggedIn, isConnected]);
  useEffect(() => {
    if (Platform.OS === 'web' && isConnected && visible) {
      setVisible(false);
      setShowConfigModal(false);
    }
  }, [isConnected, visible]);
  useEffect(() => {
    if (isPaused && pausedLogs.length === 0) {
      setPausedLogs([...reconnectState.logs]);
    } else if (!isPaused) {
      setPausedLogs([]);
    }
  }, [isPaused, reconnectState.logs]);
  useEffect(() => {
    if (Platform.OS === 'web') {
      return;
    }
    if (!isConnected && !autoReconnectService.getState().isReconnecting) {
      setTimeout(() => {
        if (!isConnected) {
          autoReconnectService.startAutoReconnect();
        }
      }, 500);
    }
  }, [isConnected]);
  const getStatusInfo = () => {
    switch (reconnectState.status) {
      case 'checking-network':
        return {
          icon: 'wifi',
          title: 'Verificando red...',
          color: theme.colors.primary,
        };
      case 'checking-health':
        return {
          icon: 'server-network',
          title: 'Verificando servidor...',
          color: theme.colors.primary,
        };
      case 'running-discovery':
        return {
          icon: 'magnify-scan',
          title: 'Buscando servidor en la red...',
          color: theme.colors.tertiary,
        };
      case 'no-wifi':
        return {
          icon: 'wifi-off',
          title: 'Sin conexión WiFi',
          color: theme.colors.error,
        };
      case 'failed':
        return {
          icon: 'server-off',
          title: 'No se puede conectar',
          color: theme.colors.error,
        };
      case 'connected':
        return {
          icon: 'check-circle',
          title: '¡Conexión establecida!',
          color: theme.colors.primary,
        };
      default:
        return {
          icon: 'alert-circle',
          title: 'Conectando...',
          color: theme.colors.tertiary,
        };
    }
  };
  const statusInfo = getStatusInfo();
  const styles = StyleSheet.create({
    modal: {
      justifyContent: 'center',
      alignItems: 'center',
      margin: 20,
    },
    container: {
      width: screenWidth - 40,
      minHeight: 400,
      maxHeight: screenHeight * 0.85,
      backgroundColor: theme.colors.surface,
      borderRadius: 24,
      overflow: 'hidden',
      elevation: 8,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 20,
      paddingVertical: 16,
      backgroundColor: theme.colors.elevation.level2,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    headerTitle: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
      marginLeft: 12,
    },
    statusSection: {
      paddingTop: 12,
      paddingBottom: 8,
      paddingHorizontal: 16,
      alignItems: 'center',
    },
    title: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
      marginBottom: 6,
    },
    subtitle: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    attemptBadge: {
      backgroundColor: theme.colors.primaryContainer,
      paddingHorizontal: 12,
      paddingVertical: 6,
      borderRadius: 16,
      marginTop: 8,
    },
    attemptText: {
      fontSize: 13,
      fontWeight: '500',
      color: theme.colors.onPrimaryContainer,
    },
    logsContainer: {
      backgroundColor: theme.colors.surfaceVariant,
      marginHorizontal: 16,
      marginBottom: 16,
      borderRadius: 16,
      overflow: 'hidden',
      minHeight: 200,
      maxHeight: 350,
    },
    logsHeader: {
      backgroundColor: theme.colors.elevation.level1,
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    logsTitle: {
      fontSize: 12,
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 1,
      textTransform: 'uppercase',
    },
    logsList: {
      padding: 16,
    },
    logEntry: {
      fontSize: 13,
      lineHeight: 20,
      color: theme.colors.onSurface,
      marginBottom: 6,
      fontFamily: 'monospace',
    },
    logInfo: {
      color: theme.colors.onSurface,
    },
    logError: {
      color: theme.colors.error,
      fontWeight: '600',
    },
    logSuccess: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    progressContainer: {
      paddingHorizontal: 24,
      paddingBottom: 12,
    },
    actionContainer: {
      paddingHorizontal: 16,
      paddingBottom: 16,
      paddingTop: 8,
    },
    actionButton: {
      marginTop: 8,
    },
  });
  if (!visible) return null;
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (
            Platform.OS === 'web' ||
            reconnectState.status === 'connected' ||
            reconnectState.status === 'no-wifi'
          ) {
            setVisible(false);
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={
          Platform.OS === 'web' ||
          reconnectState.status === 'connected' ||
          reconnectState.status === 'no-wifi'
        }
      >
        <Surface style={styles.container}>
          <View style={styles.header}>
            <Icon source="wifi-sync" size={24} color={theme.colors.primary} />
            <Text style={styles.headerTitle}>Estado de Conexión</Text>
            {(Platform.OS === 'web' ||
              reconnectState.status === 'connected' ||
              reconnectState.status === 'no-wifi') && (
              <IconButton
                icon="close"
                size={24}
                onPress={() => setVisible(false)}
                iconColor={theme.colors.onSurfaceVariant}
              />
            )}
          </View>
          <View style={styles.statusSection}>
            {Platform.OS === 'web' ? (
              <>
                <Icon
                  source="server-network"
                  size={64}
                  color={theme.colors.tertiary}
                  style={{ marginBottom: 16 }}
                />
                <Text style={styles.title}>Configuración Requerida</Text>
                <Text style={styles.subtitle}>
                  En la versión web, debes configurar manualmente la URL del
                  servidor
                </Text>
              </>
            ) : (
              <>
                <Text style={styles.title}>{statusInfo.title}</Text>
                {reconnectState.lastError &&
                  reconnectState.status !== 'connected' && (
                    <Text style={styles.subtitle}>
                      {reconnectState.lastError}
                    </Text>
                  )}
              </>
            )}
            {reconnectState.attempts > 0 &&
              reconnectState.status !== 'connected' &&
              Platform.OS !== 'web' && (
                <View style={styles.attemptBadge}>
                  <Text style={styles.attemptText}>
                    Intento #{reconnectState.attempts}
                  </Text>
                </View>
              )}
          </View>
          {reconnectState.isReconnecting &&
            reconnectState.status !== 'connected' &&
            Platform.OS !== 'web' && (
              <View style={styles.progressContainer}>
                <ProgressBar
                  indeterminate
                  color={statusInfo.color}
                  style={{ height: 4, borderRadius: 2 }}
                />
              </View>
            )}
          {reconnectState.logs.length > 0 && Platform.OS !== 'web' && (
            <View style={styles.logsContainer}>
              <View style={styles.logsHeader}>
                <View
                  style={{
                    flexDirection: 'row',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                  }}
                >
                  <Text style={styles.logsTitle}>
                    DETALLES DEL PROCESO {isPaused ? '(PAUSADO)' : ''}
                  </Text>
                  <IconButton
                    icon={isPaused ? 'play' : 'pause'}
                    size={32}
                    onPress={() => setIsPaused(!isPaused)}
                    iconColor={theme.colors.primary}
                    style={{ margin: -4 }}
                  />
                </View>
              </View>
              <ScrollView
                ref={scrollViewRef}
                style={styles.logsList}
                showsVerticalScrollIndicator={true}
                nestedScrollEnabled={true}
              >
                {(isPaused ? pausedLogs : reconnectState.logs).map(
                  (log, index) => {
                    let logStyle = [styles.logEntry, styles.logInfo];
                    if (
                      log.includes('ERROR:') ||
                      log.includes('❌') ||
                      log.includes('✗')
                    ) {
                      logStyle = [styles.logEntry, styles.logError];
                    } else if (
                      log.includes('SUCCESS:') ||
                      log.includes('✅') ||
                      log.includes('✓') ||
                      log.includes('🎉')
                    ) {
                      logStyle = [styles.logEntry, styles.logSuccess];
                    }
                    return (
                      <Text key={index} style={logStyle}>
                        {log}
                      </Text>
                    );
                  },
                )}
                <View style={{ height: 10 }} />
              </ScrollView>
            </View>
          )}
          {Platform.OS === 'web' ||
          reconnectState.status === 'failed' ||
          reconnectState.status === 'no-wifi' ||
          (reconnectState.attempts > 2 &&
            reconnectState.status !== 'connected') ? (
            <View style={styles.actionContainer}>
              <Button
                mode="contained"
                onPress={() => {
                  setShowConfigModal(true);
                }}
                icon="server-network"
                style={styles.actionButton}
              >
                Configurar Servidor Manualmente
              </Button>
            </View>
          ) : null}
        </Surface>
      </Modal>
      <ServerConfigModal
        visible={showConfigModal}
        onDismiss={() => setShowConfigModal(false)}
        onSuccess={() => {
          setShowConfigModal(false);
          if (Platform.OS === 'web') {
            setVisible(false);
          } else {
            setTimeout(() => {
              autoReconnectService.startAutoReconnect();
            }, 1000);
          }
        }}
      />
    </Portal>
  );
}

================
File: app/src/app/components/crud/GenericDetailModal.tsx
================
import React, { useMemo } from 'react';
import {
  View,
  StyleSheet,
  StyleProp,
  ViewStyle,
  TextStyle,
} from 'react-native';
import {
  Text,
  Button,
  Chip,
  ActivityIndicator,
  IconButton,
} from 'react-native-paper';
import AutoImage from '../common/AutoImage';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { ResponsiveModal } from '../responsive/ResponsiveModal';
import { useResponsive } from '../../hooks/useResponsive';
import ConfirmationModal from '../common/ConfirmationModal';
export interface DisplayFieldConfig<TItem> {
  field: keyof TItem;
  label: string;
  render?: (value: TItem[keyof TItem], item: TItem) => React.ReactNode;
}
interface StatusConfig<TItem> {
  field: keyof TItem;
  activeValue: TItem[keyof TItem];
  activeLabel: string;
  inactiveLabel: string;
}
interface DeleteConfirmation {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel: () => void;
  show: (id: string) => void;
}
interface GenericDetailModalProps<TItem extends { id: string }> {
  visible: boolean;
  onDismiss: () => void;
  item: TItem | null;
  titleField: keyof TItem;
  imageField?: keyof TItem;
  descriptionField?: keyof TItem;
  statusConfig?: StatusConfig<TItem>;
  fieldsToDisplay?: DisplayFieldConfig<TItem>[];
  onEdit?: (item: TItem) => void;
  onDelete?: (id: string) => void;
  deleteConfirmation?: DeleteConfirmation;
  isDeleting?: boolean;
  editButtonLabel?: string;
  deleteButtonLabel?: string;
  closeButtonLabel?: string;
  modalStyle?: StyleProp<ViewStyle>;
  titleStyle?: StyleProp<TextStyle>;
  imageStyle?: StyleProp<ViewStyle>;
  descriptionStyle?: StyleProp<TextStyle>;
  fieldLabelStyle?: StyleProp<TextStyle>;
  fieldValueStyle?: StyleProp<TextStyle>;
  actionsContainerStyle?: StyleProp<ViewStyle>;
  showImage?: boolean;
  children?: React.ReactNode;
}
const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) => {
  return StyleSheet.create({
    modalSurface: {
      backgroundColor: theme.colors.elevation.level2,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      shadowColor: theme.colors.shadow,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    modalTitle: {
      marginTop: responsive.spacing(theme.spacing.l),
      marginBottom: responsive.spacing(theme.spacing.m),
      textAlign: 'center',
      fontWeight: '700',
      fontSize: responsive.isTablet ? 22 : 20,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    detailContent: {
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.m),
      width: '100%',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    detailImage: {
      width: responsive.isTablet
        ? responsive.getResponsiveDimension(120, 150)
        : responsive.getResponsiveDimension(150, 180),
      height: responsive.isTablet
        ? responsive.getResponsiveDimension(120, 150)
        : responsive.getResponsiveDimension(150, 180),
      borderRadius: theme.roundness * 2,
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceDisabled,
      elevation: 2,
    },
    detailDescription: {
      marginBottom: responsive.spacing(theme.spacing.m),
      textAlign: 'center',
      lineHeight: responsive.isTablet ? 20 : 18,
      fontSize: responsive.isTablet ? 14 : 13,
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      flexWrap: 'wrap',
      width: '100%',
    },
    statusChipContainer: {
      marginBottom: responsive.spacing(theme.spacing.s),
      marginTop: responsive.spacing(theme.spacing.s),
    },
    statusChip: {
      paddingHorizontal: responsive.spacing(theme.spacing.s),
      height: responsive.isTablet ? 36 : 32,
    },
    fieldsContainer: {
      width: '100%',
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 1.5,
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      marginHorizontal: responsive.spacing(theme.spacing.m),
      alignSelf: 'center',
      maxWidth: '90%',
    },
    fieldRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xxs)
        : responsive.spacing(theme.spacing.xs),
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      flexWrap: 'wrap',
    },
    lastFieldRow: {
      marginBottom: 0,
      borderBottomWidth: 0,
    },
    fieldLabel: {
      fontWeight: '600',
      marginRight: responsive.spacing(theme.spacing.s),
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 13,
      flexBasis: '35%',
      minWidth: 100,
    },
    fieldValue: {
      flex: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 13,
      flexWrap: 'wrap',
      maxWidth: '65%',
    },
    detailActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.m),
      width: '100%',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    closeButton: {
      alignSelf: 'center',
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      minWidth: responsive.isTablet ? 150 : 100,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    loadingContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: 300,
      flex: 1,
    },
    actionButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.s),
      flex: 1,
      maxWidth: responsive.isTablet ? 180 : '48%',
      minHeight: responsive.isTablet ? 48 : 40,
      minWidth: 100,
    },
    buttonContainer: {
      backgroundColor: theme.colors.surface,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.l),
    },
    closeIconButton: {
      position: 'absolute',
      top: responsive.spacing(theme.spacing.xs),
      right: responsive.spacing(theme.spacing.xs),
      zIndex: 1,
    },
  });
};
function GenericDetailModal<TItem extends { id: string }>({
  visible,
  onDismiss,
  item,
  titleField,
  imageField,
  descriptionField,
  statusConfig,
  fieldsToDisplay = [],
  onEdit,
  onDelete,
  deleteConfirmation,
  isDeleting = false,
  editButtonLabel = 'Editar',
  deleteButtonLabel = 'Eliminar',
  closeButtonLabel = 'Cerrar',
  modalStyle,
  titleStyle,
  imageStyle,
  descriptionStyle,
  fieldLabelStyle,
  fieldValueStyle,
  actionsContainerStyle,
  showImage = false,
  children,
}: GenericDetailModalProps<TItem>) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const imageSource = useMemo(() => {
    if (item && imageField && item.hasOwnProperty(imageField)) {
      const imageFieldValue = item[imageField];
      if (
        typeof imageFieldValue === 'object' &&
        imageFieldValue !== null &&
        'path' in imageFieldValue &&
        typeof imageFieldValue.path === 'string'
      ) {
        return imageFieldValue.path;
      } else if (typeof imageFieldValue === 'string') {
        return imageFieldValue;
      }
    }
    return null;
  }, [item, imageField]);
  const handleEdit = () => {
    if (onEdit && item) {
      onEdit(item);
    }
  };
  const handleDelete = () => {
    if (item) {
      if (deleteConfirmation) {
        deleteConfirmation.show(item.id);
      } else if (onDelete) {
        onDelete(item.id);
      }
    }
  };
  const renderContent = () => {
    if (!item) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator animating={true} size="large" />
        </View>
      );
    }
    const title = String(item[titleField] ?? 'Detalle');
    const description =
      descriptionField && item.hasOwnProperty(descriptionField)
        ? String(item[descriptionField] ?? '')
        : null;
    let statusChip = null;
    if (statusConfig && item.hasOwnProperty(statusConfig.field)) {
      const { field, activeValue, activeLabel, inactiveLabel } = statusConfig;
      const isActive = item[field] === activeValue;
      statusChip = (
        <View style={styles.statusChipContainer}>
          <Chip
            mode="flat"
            selectedColor={
              isActive ? theme.colors.success : theme.colors.onSurfaceVariant
            }
            style={[
              styles.statusChip,
              {
                backgroundColor: isActive
                  ? theme.colors.successContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
          >
            {isActive ? activeLabel : inactiveLabel}
          </Chip>
        </View>
      );
    }
    return (
      <>
        <IconButton
          icon="close"
          size={24}
          style={styles.closeIconButton}
          onPress={onDismiss}
          mode="contained-tonal"
        />
        <Text variant="headlineSmall" style={[styles.modalTitle, titleStyle]}>
          {title}
        </Text>
        <View style={styles.detailContent}>
          {showImage && (
            <AutoImage
              source={imageSource}
              placeholderIcon="image-outline"
              style={[styles.detailImage, imageStyle]}
              contentFit="contain"
              transition={300}
            />
          )}
          {statusChip}
          {description && (
            <Text
              style={[styles.detailDescription, descriptionStyle]}
              numberOfLines={4}
              ellipsizeMode="tail"
            >
              {description}
            </Text>
          )}
        </View>
        {fieldsToDisplay.length > 0 && (
          <View style={styles.fieldsContainer}>
            {fieldsToDisplay.map(({ field, label, render }, index) => {
              if (!item || !item.hasOwnProperty(field)) return null;
              const value = item[field];
              const isLastItem = index === fieldsToDisplay.length - 1;
              return (
                <View
                  key={String(field)}
                  style={[styles.fieldRow, isLastItem && styles.lastFieldRow]}
                >
                  <Text style={[styles.fieldLabel, fieldLabelStyle]}>
                    {label}
                  </Text>
                  {render ? (
                    <View
                      style={{
                        flex: 1,
                        flexDirection: 'row',
                        justifyContent: 'flex-end',
                      }}
                    >
                      {(() => {
                        const rendered = render(value, item);
                        if (
                          typeof rendered === 'string' ||
                          typeof rendered === 'number'
                        ) {
                          return (
                            <Text
                              style={[styles.fieldValue, fieldValueStyle]}
                              numberOfLines={3}
                              ellipsizeMode="tail"
                            >
                              {rendered}
                            </Text>
                          );
                        }
                        return rendered;
                      })()}
                    </View>
                  ) : (
                    <Text
                      style={[styles.fieldValue, fieldValueStyle]}
                      numberOfLines={3}
                      ellipsizeMode="tail"
                    >
                      {typeof value === 'boolean'
                        ? value
                          ? 'Sí'
                          : 'No'
                        : String(value ?? 'N/A')}
                    </Text>
                  )}
                </View>
              );
            })}
          </View>
        )}
        {children}
      </>
    );
  };
  const renderFooter = () => {
    if (!item) return null;
    return (
      <>
        {(onEdit || onDelete) && (
          <View style={[styles.detailActions, actionsContainerStyle]}>
            {onEdit && (
              <Button
                icon="pencil"
                mode="contained-tonal"
                onPress={handleEdit}
                disabled={isDeleting}
                style={styles.actionButton}
                buttonColor={theme.colors.secondaryContainer}
                textColor={theme.colors.onSecondaryContainer}
                contentStyle={{ flexDirection: 'row' }}
                labelStyle={{ fontSize: responsive.isTablet ? 13 : 12 }}
                compact={!responsive.isTablet}
              >
                {editButtonLabel}
              </Button>
            )}
            {onDelete && (
              <Button
                icon="delete"
                mode="contained-tonal"
                buttonColor={theme.colors.errorContainer}
                textColor={theme.colors.error}
                onPress={handleDelete}
                loading={isDeleting}
                disabled={isDeleting}
                style={styles.actionButton}
                contentStyle={{ flexDirection: 'row' }}
                labelStyle={{ fontSize: responsive.isTablet ? 13 : 12 }}
                compact={!responsive.isTablet}
              >
                {deleteButtonLabel}
              </Button>
            )}
          </View>
        )}
        <Button
          mode="contained-tonal"
          onPress={onDismiss}
          style={styles.closeButton}
          disabled={isDeleting}
          buttonColor={theme.colors.surfaceVariant}
          textColor={theme.colors.onSurfaceVariant}
          labelStyle={{ fontSize: responsive.isTablet ? 14 : 13 }}
          contentStyle={{
            paddingHorizontal: responsive.spacing(theme.spacing.s),
          }}
        >
          {closeButtonLabel}
        </Button>
      </>
    );
  };
  return (
    <>
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        dismissable={!isDeleting}
        dismissableBackButton={!isDeleting}
        scrollable={true}
        maxWidth={responsive.isTablet ? 480 : 400}
        maxHeight={'85%'}
        footer={renderFooter()}
        stickyFooter={true}
        contentContainerStyle={[styles.modalSurface, modalStyle]}
      >
        {renderContent()}
      </ResponsiveModal>
      {deleteConfirmation && (
        <ConfirmationModal
          visible={deleteConfirmation.visible}
          title={deleteConfirmation.title}
          message={deleteConfirmation.message}
          onConfirm={deleteConfirmation.onConfirm}
          onCancel={deleteConfirmation.onCancel}
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
        />
      )}
    </>
  );
}
export default GenericDetailModal;

================
File: app/src/app/constants/apiPaths.ts
================
export const API_PATHS = {
  SUBCATEGORIES: '/api/v1/subcategories',
  SUBCATEGORIES_BY_ID: '/api/v1/subcategories/:id',
  PRODUCTS: '/api/v1/products',
  PRODUCTS_BY_ID: '/api/v1/products/:id',
  PRODUCTS_MODIFIER_GROUPS: '/api/v1/products/:productId/modifier-groups',
  PRODUCTS_PIZZA_CUSTOMIZATIONS:
    '/api/v1/products/:productId/pizza-customizations',
  PRODUCTS_PIZZAS_CUSTOMIZATIONS_BULK:
    '/api/v1/products/pizzas/customizations/bulk',
  CATEGORIES: '/api/v1/categories',
  CATEGORIES_BY_ID: '/api/v1/categories/:id',
  CATEGORIES_ORDER_MENU: '/api/v1/categories/order-menu',
  FILES_UPLOAD: '/api/v1/files/upload',
  PREPARATION_SCREENS: '/api/v1/preparation-screens',
  PREPARATION_SCREENS_BY_ID: '/api/v1/preparation-screens/:id',
  PREPARATION_SCREENS_PRODUCTS: '/api/v1/preparation-screens/:id/products',
  PREPARATION_SCREENS_MENU_WITH_ASSOCIATIONS:
    '/api/v1/preparation-screens/:id/menu-with-associations',
  AUTH_EMAIL_LOGIN: '/api/v1/auth/email/login',
  AUTH_EMAIL_REGISTER: '/api/v1/auth/email/register',
  AUTH_ME: '/api/v1/auth/me',
  AUTH_REFRESH: '/api/v1/auth/refresh',
  AREAS: '/api/v1/areas',
  AREAS_BY_ID: '/api/v1/areas/:id',
  TABLES: '/api/v1/tables',
  TABLES_BY_ID: '/api/v1/tables/:id',
  TABLES_BY_AREA: '/api/v1/tables/area/:areaId',
  MODIFIERS: '/api/v1/product-modifiers',
  MODIFIERS_BY_ID: '/api/v1/product-modifiers/:id',
  MODIFIERS_BY_GROUP: '/api/v1/product-modifiers/by-group/:modifierGroupId',
  MODIFIER_GROUPS: '/api/v1/modifier-groups',
  MODIFIER_GROUPS_BY_ID: '/api/v1/modifier-groups/:id',
  ORDERS: '/api/v1/orders',
  ORDERS_BY_ID: '/api/v1/orders/:orderId',
  ORDERS_OPEN_CURRENT_SHIFT: '/api/v1/orders/open-current-shift',
  ORDERS_OPEN_ORDERS_LIST: '/api/v1/orders/open-orders-list',
  ORDERS_FOR_FINALIZATION_LIST: '/api/v1/orders/for-finalization/list',
  ORDERS_FOR_FINALIZATION_DETAIL: '/api/v1/orders/for-finalization/:id',
  ORDERS_FINALIZE_MULTIPLE: '/api/v1/orders/finalize-multiple',
  ORDERS_DETAIL: '/api/v1/orders/:orderId/detail',
  ORDERS_RECEIPTS_LIST: '/api/v1/orders/receipts-list',
  ORDERS_RECEIPTS_BY_ID: '/api/v1/orders/receipts/:id',
  ORDERS_RECOVER: '/api/v1/orders/:id/recover',
  PRINT_ORDER_TICKET: '/api/v1/print/order',
  THERMAL_PRINTERS: '/api/v1/thermal-printers',
  THERMAL_PRINTERS_BY_ID: '/api/v1/thermal-printers/:id',
  THERMAL_PRINTERS_DISCOVER: '/api/v1/thermal-printers/discover',
  THERMAL_PRINTERS_PING: '/api/v1/thermal-printers/:id/ping',
  THERMAL_PRINTERS_TEST_PRINT: '/api/v1/thermal-printers/test-print',
  ADJUSTMENTS: '/api/v1/adjustments',
  ADJUSTMENTS_BY_ID: '/api/v1/adjustments/:id',
  RESTAURANT_CONFIG: '/api/v1/restaurant-config',
  AVAILABILITY_MENU: '/api/v1/availability/menu',
  AVAILABILITY_MODIFIER_GROUPS: '/api/v1/availability/modifier-groups',
  AVAILABILITY_PIZZA_CUSTOMIZATIONS:
    '/api/v1/availability/pizza-customizations',
  AVAILABILITY_UPDATE: '/api/v1/availability/update',
  AVAILABILITY_BULK_UPDATE: '/api/v1/availability/bulk-update',
  PAYMENTS: '/api/v1/payments',
  PAYMENTS_BY_ID: '/api/v1/payments/:paymentId',
  PAYMENTS_BY_ORDER: '/api/v1/payments/order/:orderId',
  PAYMENTS_PREPAYMENT: '/api/v1/payments/prepayment',
  PAYMENTS_ASSOCIATE: '/api/v1/payments/:paymentId/associate/:orderId',
  PIZZA_CUSTOMIZATIONS: '/api/v1/pizza-customizations',
  PIZZA_CUSTOMIZATIONS_BY_ID: '/api/v1/pizza-customizations/:id',
  PIZZA_CUSTOMIZATIONS_SORT_ORDER: '/api/v1/pizza-customizations/sort-order',
  PIZZA_CONFIGURATIONS: '/api/v1/pizza-configurations',
  PIZZA_CONFIGURATIONS_BY_ID: '/api/v1/pizza-configurations/:id',
  PRODUCTS_PIZZAS: '/api/v1/products/pizzas/all',
  CUSTOMERS: '/api/v1/customers',
  CUSTOMERS_BY_ID: '/api/v1/customers/:id',
  CUSTOMERS_CHAT_MESSAGE: '/api/v1/customers/:customerId/chat-message',
  CUSTOMERS_CHAT_HISTORY: '/api/v1/customers/:customerId/relevant-chat-history',
  CUSTOMERS_STATS: '/api/v1/customers/:customerId/stats',
  CUSTOMERS_ACTIVE_RECENT: '/api/v1/customers/active/recent',
  ADDRESSES: '/api/v1/addresses',
  ADDRESSES_BY_ID: '/api/v1/addresses/:id',
  ADDRESSES_BY_CUSTOMER: '/api/v1/customers/:customerId/addresses',
  KITCHEN_ORDERS: '/api/v1/kitchen/orders',
  KITCHEN_ORDERS_START_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/start-preparation',
  KITCHEN_ORDERS_CANCEL_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/cancel-preparation',
  KITCHEN_ORDERS_COMPLETE_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/complete-preparation',
  KITCHEN_MARK_PREPARED: '/api/v1/kitchen/order-items/:itemId/prepare',
  KITCHEN_MARK_UNPREPARED: '/api/v1/kitchen/order-items/:itemId/unprepare',
  KITCHEN_MY_SCREEN: '/api/v1/kitchen/my-screen',
  SHIFTS: '/api/v1/shifts',
  SHIFTS_OPEN: '/api/v1/shifts/open',
  SHIFTS_CLOSE: '/api/v1/shifts/close',
  SHIFTS_CURRENT: '/api/v1/shifts/current',
  SHIFTS_HISTORY: '/api/v1/shifts/history',
  SHIFTS_DETAIL: '/api/v1/shifts/:id',
  ORDERS_BY_SHIFT: '/api/v1/orders/shift/:shiftId',
  ORDERS_BY_SHIFT_SALES_SUMMARY: '/api/v1/orders/shift/:shiftId/sales-summary',
  USERS: '/api/v1/users',
  USERS_BY_ID: '/api/v1/users/:id',
  APP_CONFIG: '/api/v1/app-config',
  SYNC_STATUS: '/api/v1/sync-local/status',
  SYNC_ACTIVITY: '/api/v1/sync-local/activity',
  ORDERS_HISTORY: '/api/v1/orders/:orderId/history',
  ORDERS_QUICK_FINALIZE_MULTIPLE: '/api/v1/orders/quick-finalize-multiple',
  ORDERS_PRINT_TICKET: '/api/v1/orders/:orderId/print-ticket',
  FILES_CHECK: '/api/v1/files/',
  AUDIO_ORDERS_PROCESS: '/api/v1/audio-orders/process',
  AUDIO_ORDERS_HEALTH: '/api/v1/audio-orders/health',
  HEALTH: '/api/v1/health',
  DISCOVERY: '/api/v1/discovery',
} as const;

================
File: app/src/modules/auth/screens/LoginScreen.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleSheet,
  View,
  ActivityIndicator,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Text, IconButton, Surface, TouchableRipple } from 'react-native-paper';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import EncryptedStorage from '@/app/services/secureStorageService';
import { STORAGE_KEYS } from '../../../app/constants/storageKeys';
import { useAppTheme } from '../../../app/styles/theme';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
import { useThemeStore } from '../../../app/store/themeStore';
import { useAuthStore } from '../../../app/store/authStore';
import { LoginFormInputs, LoginResponseDto } from '../schema/auth.schema';
import { authService } from '../services/authService';
import LoginForm from '../components/LoginForm';
import { ConnectionIndicator } from '../../../app/components/ConnectionIndicator';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { ConnectionErrorModal } from '../../../app/components/ConnectionErrorModal';
import { useServerConnection } from '../../../app/hooks/useServerConnection';
import { RegisterModal } from '../components/RegisterForm';
import { OrientationTransition } from '../../../app/components/OrientationTransition';
import * as ScreenOrientation from 'expo-screen-orientation';
const LoginScreen = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const queryClient = useQueryClient();
  const { showSnackbar } = useSnackbarStore();
  const { setThemePreference } = useThemeStore();
  const setTokens = useAuthStore((state) => state.setTokens);
  const { isConnected, serverUrl } = useServerConnection();
  const [initialEmailOrUsername, setInitialEmailOrUsername] = useState<
    string | undefined
  >(undefined);
  const [initialPassword, setInitialPassword] = useState<string | undefined>(
    undefined,
  );
  const [initialRememberMe, setInitialRememberMe] = useState(false);
  const [isLoadingCredentials, setIsLoadingCredentials] = useState(true);
  const [showRegisterModal, setShowRegisterModal] = useState(false);
  type LoginMutationVariables = LoginFormInputs & { rememberMe: boolean };
  const loginMutation = useMutation<
    LoginResponseDto,
    Error,
    LoginMutationVariables
  >({
    mutationFn: (variables) =>
      authService.login({
        emailOrUsername: variables.emailOrUsername,
        password: variables.password,
      }),
    onSuccess: async (data, variables) => {
      try {
        if (data.user && !data.user.isActive) {
          showSnackbar({
            message: 'Tu cuenta está inactiva. Contacta al administrador.',
            type: 'error',
          });
          return;
        }
        await setTokens(data.token, data.refreshToken, data.user ?? null);
        const { emailOrUsername, password, rememberMe } = variables;
        if (rememberMe) {
          const credentialsToSave = JSON.stringify({
            emailOrUsername,
            password,
          });
          await EncryptedStorage.setItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
            credentialsToSave,
          );
          await EncryptedStorage.setItem(
            STORAGE_KEYS.REMEMBER_ME_ENABLED,
            'true',
          );
        } else {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        }
        showSnackbar({
          message: `¡Bienvenido!`,
          type: 'success',
        });
        queryClient.invalidateQueries({ queryKey: ['user', 'me'] });
      } catch (error: any) {
        if (error.message === 'Usuario inactivo') {
          showSnackbar({
            message: 'Tu cuenta está inactiva. Contacta al administrador.',
            type: 'error',
          });
        }
        try {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        } catch (cleanupError) {}
        showSnackbar({
          message: 'Error procesando el inicio de sesión.',
          type: 'error',
        });
      }
    },
    onError: (error: any) => {
      const errorMessage = getApiErrorMessage(error);
      if (
        errorMessage.includes('credenciales') ||
        errorMessage.includes('contraseña') ||
        errorMessage.includes('usuario') ||
        error.response?.status === 401
      ) {
        showSnackbar({
          message: errorMessage,
          type: 'error',
          duration: 5000,
        });
      }
    },
  });
  const handleLoginSubmit = (data: LoginFormInputs, rememberMe: boolean) => {
    loginMutation.mutate({ ...data, rememberMe });
  };
  useEffect(() => {
    const loadCredentials = async () => {
      setIsLoadingCredentials(true);
      try {
        const rememberEnabled = await EncryptedStorage.getItem(
          STORAGE_KEYS.REMEMBER_ME_ENABLED,
        );
        if (rememberEnabled === 'true') {
          const storedCredentialsJson = await EncryptedStorage.getItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          if (storedCredentialsJson) {
            const storedCredentials = JSON.parse(storedCredentialsJson);
            setInitialEmailOrUsername(storedCredentials.emailOrUsername);
            setInitialPassword(storedCredentials.password);
            setInitialRememberMe(true);
          } else {
            setInitialRememberMe(false);
            setInitialEmailOrUsername('');
            setInitialPassword('');
            await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
          }
        } else {
          setInitialRememberMe(false);
          setInitialEmailOrUsername('');
          setInitialPassword('');
        }
      } catch (error) {
        setInitialRememberMe(false);
        setInitialEmailOrUsername('');
        setInitialPassword('');
        try {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        } catch (cleanupError) {}
      } finally {
        setIsLoadingCredentials(false);
      }
    };
    loadCredentials();
  }, []);
  const toggleTheme = () => {
    setThemePreference(theme.dark ? 'light' : 'dark');
  };
  const handleRegisterSuccess = (username: string, password: string) => {
    setInitialEmailOrUsername(username);
    setInitialPassword(password);
    setInitialRememberMe(false);
  };
  const isWeb = Platform.OS === 'web';
  const isDesktop = isWeb && responsive.dimensions.width >= 1024;
  const isTablet =
    isWeb &&
    responsive.dimensions.width >= 768 &&
    responsive.dimensions.width < 1024;
  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: theme.colors.background,
        },
        scrollView: {
          flexGrow: 1,
        },
        webContainer: {
          flex: 1,
          flexDirection: isDesktop ? 'row' : 'column',
          minHeight: '100vh',
          width: '100%',
        },
        webLeftPanel: {
          flex: isDesktop ? 1 : undefined,
          backgroundColor: theme.dark
            ? theme.colors.primaryContainer
            : theme.colors.primary,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacingPreset.xl,
          ...(isTablet && {
            paddingVertical: responsive.spacingPreset.xxl,
          }),
        },
        webRightPanel: {
          flex: isDesktop ? 1 : undefined,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacingPreset.xl,
          backgroundColor: theme.colors.background,
          minHeight: isDesktop ? '100vh' : undefined,
          width: '100%',
        },
        webBrandingContainer: {
          alignItems: 'center',
          marginBottom: responsive.spacingPreset.xl,
        },
        webBrandingLogo: {
          width: isDesktop ? 200 : 150,
          height: isDesktop ? 200 : 150,
          marginBottom: responsive.spacingPreset.l,
          borderRadius: isDesktop ? 100 : 75,
          backgroundColor: theme.colors.surface,
          overflow: 'hidden',
          borderWidth: theme.dark ? 2 : 0,
          borderColor: theme.dark ? theme.colors.outline : 'transparent',
        },
        webBrandingTitle: {
          fontSize: isDesktop ? 48 : 36,
          fontWeight: 'bold',
          color: theme.dark
            ? theme.colors.onPrimaryContainer
            : theme.colors.onPrimary,
          marginBottom: responsive.spacingPreset.m,
          textAlign: 'center',
        },
        webBrandingSubtitle: {
          fontSize: isDesktop ? 20 : 18,
          color: theme.dark
            ? theme.colors.onPrimaryContainer
            : theme.colors.onPrimary,
          opacity: theme.dark ? 0.8 : 0.9,
          textAlign: 'center',
          maxWidth: 400,
          lineHeight: 28,
        },
        webFormWrapper: {
          width: '100%',
          maxWidth: isDesktop ? 450 : 400,
          alignItems: 'center',
        },
        container: {
          flex: 1,
          padding: responsive.spacingPreset.l,
          justifyContent: 'space-between',
        },
        logoContainer: {
          alignItems: 'center',
          marginTop: responsive.spacingPreset.xl,
          marginBottom: responsive.spacingPreset.m,
        },
        logo: {
          width: 160,
          height: 160,
          marginBottom: 16,
          borderRadius: 80,
          backgroundColor: 'transparent',
          overflow: 'hidden',
        },
        title: {
          fontSize: 32,
          fontWeight: 'bold',
          color: theme.colors.primary,
          marginBottom: 8,
          textAlign: 'center',
        },
        subtitle: {
          fontSize: responsive.fontSizePreset.m,
          color: theme.colors.onSurfaceVariant,
          marginBottom: responsive.spacingPreset.xl,
          textAlign: 'center',
          paddingHorizontal: responsive.spacingPreset.l,
        },
        formContainer: {
          backgroundColor: theme.colors.surface,
          borderRadius: 16,
          padding: responsive.spacingPreset.m,
          elevation: 2,
          marginBottom: responsive.spacingPreset.m,
          paddingVertical: responsive.spacingPreset.l,
          ...(isWeb && {
            width: '100%',
            shadowColor: theme.dark
              ? 'rgba(255,255,255,0.1)'
              : 'rgba(0,0,0,0.1)',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 1,
            shadowRadius: 8,
            borderWidth: theme.dark ? 1 : 0,
            borderColor: theme.dark
              ? theme.colors.surfaceVariant
              : 'transparent',
          }),
        },
        registerContainer: {
          flexDirection: 'row',
          justifyContent: 'center',
          alignItems: 'center',
          marginTop: responsive.spacingPreset.xl,
        },
        registerText: {
          color: theme.colors.onSurfaceVariant,
          marginRight: 8,
        },
        registerLink: {
          color: theme.colors.primary,
          fontWeight: 'bold',
        },
        bottomThemeToggleContainer: {
          alignItems: 'center',
          marginTop: 20,
          marginBottom: 16,
        },
        webThemeToggle: {
          position: 'absolute',
          top: responsive.spacingPreset.l,
          right: responsive.spacingPreset.l,
          zIndex: 10,
        },
      }),
    [theme, isDesktop, isTablet],
  );
  if (isLoadingCredentials) {
    return (
      <SafeAreaView
        style={[
          styles.safeArea,
          { justifyContent: 'center', alignItems: 'center' },
        ]}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </SafeAreaView>
    );
  }
  const webContent = (
    <View
      style={{
        flex: 1,
        height: '100vh',
        backgroundColor: theme.colors.background,
      }}
    >
      <ConnectionErrorModal />
      <RegisterModal
        visible={showRegisterModal}
        onDismiss={() => setShowRegisterModal(false)}
        onRegisterSuccess={handleRegisterSuccess}
      />
      {}
      <View style={{ position: 'absolute', top: 20, right: 20, zIndex: 10 }}>
        <IconButton
          icon={theme.dark ? 'weather-night' : 'weather-sunny'}
          size={30}
          onPress={toggleTheme}
          iconColor={theme.colors.onSurfaceVariant}
        />
      </View>
      <ScrollView
        contentContainerStyle={{
          flexGrow: 1,
          justifyContent: 'center',
          alignItems: 'center',
          padding: 20,
        }}
      >
        <View
          style={{
            width: '100%',
            maxWidth: 380,
            alignItems: 'center',
          }}
        >
          {}
          <Image
            source={require('../../../../assets/icon.png')}
            style={{
              width: 200,
              height: 200,
              borderRadius: 100,
              marginBottom: 30,
            }}
            resizeMode="cover"
          />
          {}
          <View
            style={{
              width: '100%',
              backgroundColor: theme.colors.surface,
              borderRadius: 16,
              padding: 24,
              shadowColor: theme.dark
                ? 'rgba(255,255,255,0.1)'
                : 'rgba(0,0,0,0.1)',
              shadowOffset: { width: 0, height: 4 },
              shadowOpacity: 1,
              shadowRadius: 12,
              elevation: 4,
              borderWidth: theme.dark ? 1 : 0,
              borderColor: theme.dark ? 'rgba(255,255,255,0.1)' : 'transparent',
            }}
          >
            <Text
              style={{
                fontSize: 24,
                fontWeight: 'bold',
                color: theme.colors.onSurface,
                marginBottom: 8,
                textAlign: 'center',
              }}
            >
              Iniciar Sesión
            </Text>
            <Text
              style={{
                fontSize: 14,
                color: theme.colors.onSurfaceVariant,
                marginBottom: 20,
                textAlign: 'center',
              }}
            >
              Ingresa tus credenciales para continuar
            </Text>
            <LoginForm
              onSubmit={handleLoginSubmit}
              isLoading={loginMutation.isPending}
              initialEmailOrUsername={initialEmailOrUsername}
              initialPassword={initialPassword}
              initialRememberMe={initialRememberMe}
            />
            <View
              style={{
                flexDirection: 'row',
                justifyContent: 'center',
                alignItems: 'center',
                marginTop: 16,
              }}
            >
              <Text
                style={{
                  color: theme.colors.onSurfaceVariant,
                  fontSize: 14,
                }}
              >
                ¿No tienes una cuenta?
              </Text>
              <TouchableRipple
                onPress={() => setShowRegisterModal(true)}
                style={{ marginLeft: 5 }}
              >
                <Text
                  style={{
                    color: theme.colors.primary,
                    fontWeight: 'bold',
                    fontSize: 14,
                  }}
                >
                  Regístrate
                </Text>
              </TouchableRipple>
            </View>
          </View>
        </View>
      </ScrollView>
    </View>
  );
  const mobileContent = (
    <SafeAreaView style={styles.safeArea}>
      <ConnectionErrorModal />
      <RegisterModal
        visible={showRegisterModal}
        onDismiss={() => setShowRegisterModal(false)}
        onRegisterSuccess={handleRegisterSuccess}
      />
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        <ScrollView
          contentContainerStyle={styles.scrollView}
          keyboardShouldPersistTaps="handled"
        >
          <View style={styles.container}>
            <View>
              <View
                style={{
                  position: 'absolute',
                  top: -responsive.spacing.s,
                  right: -responsive.spacing.s,
                  zIndex: 1,
                }}
              >
                <ConnectionIndicator />
              </View>
              <View style={styles.logoContainer}>
                <Image
                  source={require('../../../../assets/icon.png')}
                  style={styles.logo}
                  resizeMode="cover"
                />
                <Text style={styles.title}>¡Bienvenido!</Text>
                <Text style={styles.subtitle}>
                  Inicia sesión para gestionar tus pedidos
                </Text>
              </View>
              <Surface style={styles.formContainer}>
                <LoginForm
                  onSubmit={handleLoginSubmit}
                  isLoading={loginMutation.isPending}
                  initialEmailOrUsername={initialEmailOrUsername}
                  initialPassword={initialPassword}
                  initialRememberMe={initialRememberMe}
                />
              </Surface>
            </View>
            <View>
              <View style={styles.registerContainer}>
                <Text style={styles.registerText}>¿No tienes una cuenta?</Text>
                <TouchableRipple onPress={() => setShowRegisterModal(true)}>
                  <Text style={styles.registerLink}>Regístrate</Text>
                </TouchableRipple>
              </View>
              <View style={styles.bottomThemeToggleContainer}>
                <IconButton
                  icon={theme.dark ? 'weather-night' : 'weather-sunny'}
                  size={responsive.dimensions.iconSize.large}
                  onPress={toggleTheme}
                  iconColor={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
  const content = isWeb ? webContent : mobileContent;
  return Platform.OS === 'web' ? (
    content
  ) : (
    <OrientationTransition
      targetOrientation={ScreenOrientation.OrientationLock.PORTRAIT_UP}
    >
      {content}
    </OrientationTransition>
  );
};
export default LoginScreen;

================
File: app/src/modules/kitchen/screens/KitchenOrdersScreen.tsx
================
import React, {
  useEffect,
  useRef,
  useState,
  useMemo,
  useCallback,
} from 'react';
import { View, StyleSheet, ScrollView, Animated, Platform } from 'react-native';
import { Text, ActivityIndicator, Surface } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import {
  useKitchenOrders,
  useStartOrderPreparation,
  useCancelOrderPreparation,
  useCompleteOrderPreparation,
} from '../hooks/useKitchenOrders';
import { useKitchenStore } from '../store/kitchenStore';
import { OrderCard } from '../components/OrderCard';
import * as ScreenOrientation from 'expo-screen-orientation';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useKitchenContext } from '../context/KitchenContext';
import { OrderType } from '../types/kitchen.types';
export default function KitchenOrdersScreen() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { filters } = useKitchenStore();
  const pulseAnim = useRef(new Animated.Value(1)).current;
  const [isSwipingCard, setIsSwipingCard] = useState(false);
  const { refetchRef } = useKitchenContext();
  const { data: orders, isLoading, refetch } = useKitchenOrders(filters);
  const startOrderPreparation = useStartOrderPreparation();
  const cancelOrderPreparation = useCancelOrderPreparation();
  const completeOrderPreparation = useCompleteOrderPreparation();
  useEffect(() => {
    refetchRef.current = refetch;
  }, [refetch, refetchRef]);
  const hasOrders = !!orders?.length;
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const cardWidth = useMemo(() => {
    if (responsive.isDesktop) {
      return responsive.getResponsiveDimension(340, 380);
    }
    if (responsive.isWeb && responsive.isTablet) {
      return responsive.getResponsiveDimension(300, 340);
    }
    return responsive.isTablet
      ? responsive.getResponsiveDimension(280, 320)
      : responsive.getResponsiveDimension(240, 280);
  }, [responsive.isTablet, responsive.isDesktop, responsive.isWeb]);
  const handleStartPreparation = useCallback(
    (orderId: string) => {
      startOrderPreparation.mutate(orderId);
    },
    [startOrderPreparation],
  );
  const handleCancelPreparation = useCallback(
    (orderId: string) => {
      cancelOrderPreparation.mutate(orderId);
    },
    [cancelOrderPreparation],
  );
  const handleCompletePreparation = useCallback(
    (orderId: string) => {
      completeOrderPreparation.mutate(orderId);
    },
    [completeOrderPreparation],
  );
  useEffect(() => {
    if (Platform.OS !== 'web') {
      const setLandscape = async () => {
        await ScreenOrientation.lockAsync(
          ScreenOrientation.OrientationLock.LANDSCAPE,
        );
      };
      setLandscape();
      return () => {
        ScreenOrientation.unlockAsync();
      };
    }
  }, []);
  useEffect(() => {
    if (!hasOrders) {
      const animation = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.2,
            duration: 1500,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 1500,
            useNativeDriver: true,
          }),
        ]),
      );
      animation.start();
      return () => animation.stop();
    }
  }, [hasOrders, pulseAnim]);
  const emptyMessage = useMemo(() => {
    const activeFilters = [];
    if (filters.orderType) {
      const typeLabels = {
        [OrderType.DINE_IN]: 'Para Mesa',
        [OrderType.TAKE_AWAY]: 'Para Llevar',
        [OrderType.DELIVERY]: 'Delivery',
      };
      activeFilters.push(`Tipo: ${typeLabels[filters.orderType]}`);
    }
    if (filters.showPrepared) {
      activeFilters.push('Solo órdenes listas');
    }
    if (!filters.showAllProducts && filters.screenId) {
      activeFilters.push('Solo productos de esta pantalla');
    }
    if (activeFilters.length > 0) {
      return {
        title: 'No hay pedidos con los filtros activos',
        subtitle: `Filtros: ${activeFilters.join(', ')}`,
        hint: 'Ajusta los filtros o espera nuevos pedidos',
      };
    }
    return {
      title: 'No hay pedidos pendientes',
      subtitle: 'Los nuevos pedidos aparecerán aquí automáticamente',
      hint: 'Presiona el botón de recargar para verificar nuevos pedidos',
    };
  }, [filters]);
  const handleSwipeStart = useCallback(() => setIsSwipingCard(true), []);
  const handleSwipeEnd = useCallback(() => {
    setTimeout(() => setIsSwipingCard(false), 100);
  }, []);
  if (isLoading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text variant="bodyLarge" style={styles.loadingText}>
          Cargando pedidos...
        </Text>
      </View>
    );
  }
  return (
    <View style={styles.container}>
      {hasOrders ? (
        <ScrollView
          horizontal={!responsive.isWeb || responsive.width < 1200}
          scrollEnabled={!isSwipingCard}
          showsHorizontalScrollIndicator={false}
          pagingEnabled={false}
          contentContainerStyle={[
            styles.horizontalListContainer,
            responsive.isWeb &&
              responsive.width >= 1200 &&
              styles.gridContainer,
          ]}
          snapToInterval={
            responsive.isWeb ? undefined : cardWidth + responsive.spacing.m
          }
          decelerationRate="fast"
          snapToAlignment={responsive.isWeb ? undefined : 'start'}
        >
          {orders.map((item, index) => (
            <View
              key={item.id}
              style={[
                styles.cardContainer,
                {
                  width: cardWidth,
                  marginRight:
                    index === orders.length - 1 ? 0 : responsive.spacing.xxs,
                },
                responsive.isWeb &&
                  responsive.width >= 1200 &&
                  styles.cardContainerWeb,
              ]}
            >
              <OrderCard
                order={item}
                onStartPreparation={handleStartPreparation}
                onCancelPreparation={handleCancelPreparation}
                onCompletePreparation={handleCompletePreparation}
                onSwipeStart={handleSwipeStart}
                onSwipeEnd={handleSwipeEnd}
              />
            </View>
          ))}
        </ScrollView>
      ) : (
        <View style={styles.emptyStateContainer}>
          <Surface style={styles.emptyCard} elevation={4}>
            <Animated.View
              style={[
                styles.emptyIconContainer,
                { transform: [{ scale: pulseAnim }] },
              ]}
            >
              <Icon
                name={
                  filters.orderType ||
                  filters.showPrepared ||
                  !filters.showAllProducts
                    ? 'filter-remove'
                    : 'chef-hat'
                }
                size={
                  responsive.isWeb
                    ? 64
                    : responsive.getResponsiveDimension(32, 40)
                }
                color={theme.colors.primary}
              />
            </Animated.View>
            <Text
              variant="titleMedium"
              style={[styles.emptyText, { color: theme.colors.onSurface }]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.title}
            </Text>
            <Text
              variant="bodyMedium"
              style={[
                styles.emptySubtext,
                { color: theme.colors.onSurfaceVariant },
              ]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.subtitle}
            </Text>
            <Text
              variant="bodySmall"
              style={[
                styles.emptyHint,
                { color: theme.colors.onSurfaceVariant },
              ]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.hint}
            </Text>
          </Surface>
        </View>
      )}
    </View>
  );
}
const createStyles = (theme: any, responsive: any) =>
  StyleSheet.create({
    container: {
      flex: 1,
      position: 'relative',
      backgroundColor: theme.colors.background,
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.background,
    },
    horizontalListContainer: {
      paddingLeft: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.xxs,
      paddingRight: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.xs,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.s
        : responsive.spacing.xxs,
      minHeight: '100%',
      alignItems:
        responsive.isWeb && responsive.width >= 1200 ? 'flex-start' : 'center',
    },
    gridContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      justifyContent: 'flex-start',
      alignItems: 'flex-start',
      paddingHorizontal: responsive.spacing.l,
      paddingVertical: responsive.spacing.m,
    },
    emptyStateContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.spacing.m,
      paddingVertical: responsive.spacing.xs,
      backgroundColor: theme.colors.background,
    },
    emptyCard: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.xl
        : responsive.spacing.m,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.xl
        : responsive.spacing.m,
      borderRadius: theme.roundness * 2,
      alignItems: 'center',
      maxHeight: '70%',
      width: responsive.isWeb
        ? responsive.getResponsiveDimension(400, 480)
        : responsive.getResponsiveDimension(280, 320),
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.1,
      shadowRadius: 4,
      elevation: 3,
    },
    emptyIconContainer: {
      marginBottom: responsive.spacing.s,
      padding: responsive.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: theme.roundness,
    },
    emptyText: {
      textAlign: 'center',
      marginBottom: responsive.spacing.xs,
      fontWeight: '600',
      fontSize: responsive.fontSize.s,
      paddingHorizontal: responsive.spacing.xs,
      maxWidth: '100%',
      color: theme.colors.onSurface,
    },
    emptySubtext: {
      textAlign: 'center',
      lineHeight: responsive.getResponsiveDimension(16, 18),
      opacity: 0.7,
      marginBottom: responsive.spacing.s,
      fontSize: responsive.fontSize.xs,
      paddingHorizontal: responsive.spacing.xs,
      maxWidth: '100%',
      fontWeight: '400',
      color: theme.colors.onSurfaceVariant,
    },
    emptyHint: {
      textAlign: 'center',
      opacity: 0.5,
      fontStyle: 'italic',
      fontSize: responsive.fontSize.xs - 1,
      paddingHorizontal: responsive.spacing.xs,
      maxWidth: '100%',
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingTop: responsive.spacing.s,
      marginTop: responsive.spacing.xs,
      width: '80%',
      fontWeight: '400',
      color: theme.colors.onSurfaceVariant,
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onBackground,
    },
    cardContainer: {
      height: '100%',
      paddingVertical: responsive.spacing.xxxs,
    },
    cardContainerWeb: {
      marginRight: responsive.spacing.s,
      marginBottom: responsive.spacing.s,
      height: 'auto',
    },
  });

================
File: app/src/services/audioServiceHealth.ts
================
import axios from 'axios';
import { serverConnectionService } from '@/services/serverConnectionService';
import { useAuthStore } from '@/app/store/authStore';
import NetInfo from '@react-native-community/netinfo';
import { API_PATHS } from '@/app/constants/apiPaths';
export interface AudioServiceHealthStatus {
  isAvailable: boolean;
  hasInternet: boolean;
  serviceStatus: 'ok' | 'error' | 'disabled' | 'misconfigured' | 'checking';
  message?: string;
  lastChecked: Date;
}
class AudioServiceHealthChecker {
  private static instance: AudioServiceHealthChecker;
  private healthStatus: AudioServiceHealthStatus = {
    isAvailable: false,
    hasInternet: false,
    serviceStatus: 'checking',
    lastChecked: new Date(),
  };
  private listeners: ((status: AudioServiceHealthStatus) => void)[] = [];
  private checkInterval: NodeJS.Timeout | null = null;
  private lastCheckTime: number = 0;
  private readonly CHECK_INTERVAL = 30000;
  private readonly MIN_CHECK_INTERVAL = 5000;
  private isActive: boolean = false;
  private networkListener: (() => void) | null = null;
  private constructor() {
  }
  static getInstance(): AudioServiceHealthChecker {
    if (!AudioServiceHealthChecker.instance) {
      AudioServiceHealthChecker.instance = new AudioServiceHealthChecker();
    }
    return AudioServiceHealthChecker.instance;
  }
  async checkHealth(force: boolean = false): Promise<AudioServiceHealthStatus> {
    const now = Date.now();
    if (!force && now - this.lastCheckTime < this.MIN_CHECK_INTERVAL) {
      return this.healthStatus;
    }
    this.lastCheckTime = now;
    try {
      const netInfo = await NetInfo.fetch();
      const hasInternet =
        netInfo.isConnected && netInfo.isInternetReachable !== false;
      if (!hasInternet) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: false,
          serviceStatus: 'error',
          message: 'Sin conexión a internet',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }
      const accessToken = useAuthStore.getState().accessToken;
      if (!accessToken) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: true,
          serviceStatus: 'error',
          message: 'Usuario no autenticado',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }
      const connectionState = serverConnectionService.getState();
      if (!connectionState.currentUrl || !connectionState.isConnected) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: true,
          serviceStatus: 'error',
          message: 'Servidor no conectado',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }
      const apiUrl = connectionState.currentUrl.endsWith('/')
        ? connectionState.currentUrl.slice(0, -1)
        : connectionState.currentUrl;
      const response = await axios.get(
        `${apiUrl}${API_PATHS.AUDIO_ORDERS_HEALTH}`,
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
          timeout: 5000,
        },
      );
      const { available, status, message } = response.data;
      this.updateStatus({
        isAvailable: available,
        hasInternet: true,
        serviceStatus: status,
        message,
        lastChecked: new Date(),
      });
    } catch (error) {
      let errorMessage = 'Servicio de voz no disponible';
      if (axios.isAxiosError(error)) {
        if (error.code === 'ECONNABORTED') {
          errorMessage = 'Tiempo de espera agotado';
        } else if (error.response?.status === 503) {
          errorMessage = 'Servicio temporalmente no disponible';
        } else if (error.response?.status === 404) {
          errorMessage = 'Servicio de voz no configurado';
        }
      }
      this.updateStatus({
        isAvailable: false,
        hasInternet: true,
        serviceStatus: 'error',
        message: errorMessage,
        lastChecked: new Date(),
      });
    }
    return this.healthStatus;
  }
  private updateStatus(status: AudioServiceHealthStatus) {
    this.healthStatus = status;
    this.notifyListeners();
  }
  private notifyListeners() {
    this.listeners.forEach((listener) => listener(this.healthStatus));
  }
  subscribe(listener: (status: AudioServiceHealthStatus) => void): () => void {
    this.listeners.push(listener);
    listener(this.healthStatus);
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }
  startPeriodicCheck() {
    if (this.checkInterval || !this.listeners.length) {
      return;
    }
    this.isActive = true;
    if (!this.networkListener) {
      this.networkListener = NetInfo.addEventListener((state) => {
        if (
          this.isActive &&
          state.isConnected !== this.healthStatus.hasInternet
        ) {
          this.checkHealth();
        }
      });
    }
    this.checkHealth();
    this.checkInterval = setInterval(() => {
      if (this.isActive) {
        this.checkHealth();
      }
    }, this.CHECK_INTERVAL);
  }
  stopPeriodicCheck() {
    this.isActive = false;
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    if (this.networkListener) {
      this.networkListener();
      this.networkListener = null;
    }
    this.updateStatus({
      isAvailable: false,
      hasInternet: false,
      serviceStatus: 'checking',
      message: undefined,
      lastChecked: new Date(),
    });
  }
  getStatus(): AudioServiceHealthStatus {
    return this.healthStatus;
  }
}
export const audioServiceHealth = AudioServiceHealthChecker.getInstance();

================
File: backend/src/orders/dto/order-for-finalization-list.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { OrderType } from '../domain/enums/order-type.enum';
import { OrderStatus } from '../domain/enums/order-status.enum';
export class OrderForFinalizationListDto {
  @ApiProperty({ description: 'ID de la orden' })
  id: string;
  @ApiProperty({ description: 'Número de orden en el turno' })
  shiftOrderNumber: number;
  @ApiProperty({
    description: 'Tipo de orden',
    enum: OrderType,
  })
  orderType: OrderType;
  @ApiProperty({
    description: 'Estado de la orden',
    enum: OrderStatus,
  })
  orderStatus: OrderStatus;
  @ApiProperty({ description: 'Total de la orden' })
  total: number;
  @ApiProperty({ description: 'Fecha de creación' })
  createdAt: Date;
  @ApiProperty({ description: 'Fecha de finalización', required: false })
  finalizedAt?: Date;
  @ApiProperty({
    description: 'Fecha y hora de entrega programada',
    required: false,
  })
  scheduledAt?: Date;
  @ApiProperty({
    description: 'Resumen de pagos para calcular el monto pendiente',
    required: false,
  })
  paymentsSummary?: {
    totalPaid: number;
  };
  @ApiProperty({
    description: 'Información básica de la mesa para órdenes DINE_IN',
    required: false,
  })
  table?: {
    number: string;
    area?: {
      name: string;
    };
  };
  @ApiProperty({
    description:
      'Información básica de entrega para órdenes DELIVERY/TAKE_AWAY',
    required: false,
  })
  deliveryInfo?: {
    recipientName?: string;
    recipientPhone?: string;
    fullAddress?: string;
  };
  @ApiProperty({
    description: 'Pantallas de preparación únicas de los productos en la orden',
    required: false,
    type: [String],
  })
  preparationScreens?: string[];
  @ApiProperty({
    type: 'array',
    items: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        status: { type: 'string', enum: ['PENDING', 'IN_PROGRESS', 'READY'] },
      },
    },
    required: false,
    description: 'Estados de las pantallas de preparación',
  })
  preparationScreenStatuses?: Array<{ name: string; status: string }>;
  @ApiProperty({
    description: 'Cantidad de tickets impresos para esta orden',
    required: false,
  })
  ticketImpressionCount?: number;
  @ApiProperty({
    description: 'Notas de la orden',
    required: false,
  })
  notes?: string;
  @ApiProperty({
    required: false,
    description: 'Usuario que creó la orden',
    example: {
      username: 'john.doe',
      firstName: 'John',
      lastName: 'Doe',
    },
  })
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
  @ApiProperty({
    required: false,
    description: 'Indica si la orden proviene de WhatsApp',
    example: true,
  })
  isFromWhatsApp?: boolean;
}

================
File: backend/src/sync/services/local-sync.service.ts
================
import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
  Logger,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { HttpService } from '@nestjs/axios';
import { io, Socket } from 'socket.io-client';
import { firstValueFrom } from 'rxjs';
import { SyncConfig } from '../config/sync-config.type';
import { CategoriesService } from '../../categories/categories.service';
import { RestaurantConfigService } from '../../restaurant-config/restaurant-config.service';
import { DataSource } from 'typeorm';
import { InjectDataSource } from '@nestjs/typeorm';
import { OrderEntity } from '../../orders/infrastructure/persistence/relational/entities/order.entity';
import { OrderStatus } from '../../orders/domain/enums/order-status.enum';
import { OrderType } from '../../orders/domain/enums/order-type.enum';
import { CustomerEntity } from '../../customers/infrastructure/persistence/relational/entities/customer.entity';
import { OrderItemEntity } from '../../orders/infrastructure/persistence/relational/entities/order-item.entity';
import { DeliveryInfoEntity } from '../../orders/infrastructure/persistence/relational/entities/delivery-info.entity';
import { AddressEntity } from '../../customers/infrastructure/persistence/relational/entities/address.entity';
import { PullChangesResponseDto } from '../dto/pull-changes-response.dto';
import { Order } from '../../orders/domain/order';
import { Customer } from '../../customers/domain/customer';
import { PreparationStatus } from '../../orders/domain/order-item';
import { UpdateOrderStatusDto } from '../dto/update-order-status.dto';
import { UpdateOrderStatusResponseDto } from '../dto/update-order-status-response.dto';
import {
  SyncActivityEntity,
  SyncActivityType,
} from '../infrastructure/persistence/relational/entities/sync-activity.entity';
import { PullChangesRequestDto } from '../dto/pull-changes-request.dto';
import { ShiftEntity } from '../../shifts/infrastructure/persistence/relational/entities/shift.entity';
import { ShiftStatus } from '../../shifts/domain/shift';
@Injectable()
export class LocalSyncService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(LocalSyncService.name);
  private socket: Socket | null = null;
  private readonly syncConfig: SyncConfig;
  private isWebSocketConnected = false;
  private webSocketFailed = false;
  private pullInterval: NodeJS.Timeout | null = null;
  private heartbeatInterval: NodeJS.Timeout | null = null;
  private pullCount = 0;
  constructor(
    private readonly configService: ConfigService,
    private readonly httpService: HttpService,
    private readonly categoriesService: CategoriesService,
    private readonly restaurantConfigService: RestaurantConfigService,
    @InjectDataSource() private readonly dataSource: DataSource,
  ) {
    this.syncConfig = this.configService.get<SyncConfig>('sync', {
      infer: true,
    }) || {
      enabled: false,
      cloudApiUrl: '',
      cloudApiKey: '',
      intervalMinutes: 5,
      webSocketEnabled: false,
    };
  }
  async onModuleInit() {
    if (!this.syncConfig.enabled) {
      return;
    }
    this.logger.log('🚀 Iniciando servicio de sincronización...');
    this.logger.log(
      `⏰ Intervalo: ${this.syncConfig.intervalMinutes} minuto(s)`,
    );
    this.logger.log(`🌐 URL: ${this.syncConfig.cloudApiUrl}`);
    this.logger.log(
      `🔌 WebSocket habilitado: ${this.syncConfig.webSocketEnabled}`,
    );
    // Inicializar pull automático
    this.startAutomaticPull();
    // Solo inicializar WebSocket para notificaciones en tiempo real
    if (this.syncConfig.webSocketEnabled) {
      try {
        await this.connectWebSocket();
      } catch (error) {
        this.logger.error('❌ Error al conectar WebSocket:', error.message);
        this.logger.warn(
          '⚠️ Continuando sin WebSocket, usando solo pull periódico',
        );
      }
    }
    try {
      this.logger.log('🔄 Ejecutando sincronización inicial...');
      await this.pullChanges();
    } catch (error) {
      this.logger.error('❌ Error en sincronización inicial:', error.message);
    }
  }
  onModuleDestroy() {
    this.disconnect();
    this.stopAutomaticPull();
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
    if ((global as any).__syncSocket) {
      delete (global as any).__syncSocket;
    }
  }
  private async connectWebSocket(): Promise<void> {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
    const wsUrl = this.syncConfig.cloudApiUrl;
    const isProduction = wsUrl.includes('https://');
    const fullUrl = `${wsUrl}/sync`;
    this.logger.log(`📡 Conectando WebSocket a ${fullUrl}...`);
    const socketOptions = {
      auth: {
        apiKey: this.syncConfig.cloudApiKey,
      },
      path: '/socket.io/',
      transports: ['websocket', 'polling'],
      secure: isProduction,
      reconnection: true,
      reconnectionAttempts: Infinity,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      randomizationFactor: 0.5,
      timeout: 20000,
      forceNew: true,
    };
    this.socket = io(fullUrl, socketOptions);
    this.socket.on('disconnect', (reason) => {
      this.isWebSocketConnected = false;
      this.logger.warn(`⚠️ WebSocket desconectado: ${reason}`);
    });
    this.socket.on('connect_error', (error) => {
      this.isWebSocketConnected = false;
      if (!this.webSocketFailed) {
        this.logger.error(`❌ Error de conexión WebSocket: ${error.message}`);
        this.webSocketFailed = true;
      }
    });
    this.socket.on('connect', () => {
      this.isWebSocketConnected = true;
      this.webSocketFailed = false;
      this.logger.log(`✅ WebSocket conectado (ID: ${this.socket?.id})`);
    });
    this.socket.on('changes:pending', async () => {
      this.logger.log('📨 Evento recibido: changes:pending');
      try {
        await this.pullChanges();
      } catch (error) {
      }
    });
    this.socket.io.on('reconnect', (attempt) => {
      this.logger.log(
        `✅ WebSocket reconectado después de ${attempt} intentos`,
      );
      this.isWebSocketConnected = true;
    });
    let reconnectAttempts = 0;
    this.socket.io.on('reconnect_attempt', (attempt) => {
      reconnectAttempts = attempt;
      if (attempt === 1 || attempt % 5 === 0) {
        this.logger.log(`🔄 Intentando reconectar... (intento #${attempt})`);
      }
    });
    this.socket.io.on('reconnect_failed', () => {
      this.logger.error(
        `❌ Reconexión fallida después de ${reconnectAttempts} intentos`,
      );
      this.webSocketFailed = true;
    });
    return new Promise((resolve, reject) => {
      if (!this.socket) {
        reject(new Error('Socket not initialized'));
        return;
      }
      const timeout = setTimeout(() => {
        this.logger.error('❌ Timeout esperando conexión WebSocket');
        reject(new Error('WebSocket connection timeout'));
      }, 30000);
      this.socket.once('connect', () => {
        clearTimeout(timeout);
        this.heartbeatInterval = setInterval(() => {
          if (this.socket?.connected) {
            this.socket.emit('ping');
            this.socket.emit('heartbeat', {
              timestamp: new Date().toISOString(),
            });
          } else if (!this.socket?.io?._reconnecting) {
            this.socket?.connect();
          }
        }, 20000);
        (global as any).__syncSocket = this.socket;
        resolve();
      });
      this.socket.once('connect_error', (error) => {
        clearTimeout(timeout);
        reject(error);
      });
    });
  }
  private disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }
  private startAutomaticPull() {
    const intervalMs = this.syncConfig.intervalMinutes * 60 * 1000;
    this.logger.log(
      `⏱️ Pull automático configurado cada ${this.syncConfig.intervalMinutes} minuto(s)`,
    );
    this.pullInterval = setInterval(async () => {
      this.pullCount++;
      this.logger.log(`🔄 Ejecutando pull automático #${this.pullCount}...`);
      try {
        await this.pullChanges();
      } catch (error) {
        this.logger.error(
          `❌ Error en pull automático #${this.pullCount}:`,
          error.message,
        );
      }
    }, intervalMs);
  }
  private stopAutomaticPull() {
    if (this.pullInterval) {
      clearInterval(this.pullInterval);
      this.pullInterval = null;
    }
  }
  async pullChanges(
    confirmDto?: PullChangesRequestDto,
  ): Promise<PullChangesResponseDto> {
    await this.pushRestaurantData();
    try {
      const headers = { 'X-API-Key': this.syncConfig.cloudApiKey };
      const url = `${this.syncConfig.cloudApiUrl}/api/sync/pull-changes`;
      const body = confirmDto || {
        confirmedOrders: [],
        confirmedCustomerIds: [],
      };
      const response = await firstValueFrom(
        this.httpService.post<PullChangesResponseDto>(url, body, { headers }),
      );
      const pullData = response.data;
      await this.logSyncActivity(SyncActivityType.PULL_CHANGES, 'IN', true);
      this.logger.log(
        `📥 Recibidos: ${pullData.pending_orders?.length || 0} pedidos, ${
          pullData.updated_customers?.length || 0
        } clientes actualizados`,
      );
      if (pullData.pending_orders && pullData.pending_orders.length > 0) {
        this.logger.log('📋 Estructura de pedidos recibidos:');
        pullData.pending_orders.forEach((order, index) => {
          this.logger.log(
            `  Pedido ${index + 1}/${pullData.pending_orders.length}:`,
          );
          this.logger.log(`    - ID: ${order.id}`);
          this.logger.log(
            `    - Cliente: ${order.customer?.firstName || 'N/A'} ${order.customer?.lastName || ''}`,
          );
          this.logger.log(`    - Tipo: ${order.orderType}`);
          this.logger.log(`    - Estado: ${order.orderStatus}`);
          this.logger.log(
            `    - Total: $${order.total || order.subtotal || 0}`,
          );
          this.logger.log(`    - Items: ${order.orderItems?.length || 0}`);
          if (order.deliveryInfo) {
            this.logger.log(
              `    - Entrega a: ${order.deliveryInfo.recipientName || 'N/A'}`,
            );
          }
        });
      }
      if (pullData.updated_customers && pullData.updated_customers.length > 0) {
        this.logger.log('👥 Clientes actualizados:');
        pullData.updated_customers.forEach((customer, index) => {
          this.logger.log(
            `  Cliente ${index + 1}/${pullData.updated_customers.length}:`,
          );
          this.logger.log(`    - ID: ${customer.id}`);
          this.logger.log(
            `    - Nombre: ${customer.firstName} ${customer.lastName || ''}`,
          );
          this.logger.log(
            `    - WhatsApp: ${customer.whatsappPhoneNumber || 'N/A'}`,
          );
          this.logger.log(
            `    - Direcciones: ${customer.addresses?.length || 0}`,
          );
        });
      }
      if (
        (!pullData.pending_orders || pullData.pending_orders.length === 0) &&
        (!pullData.updated_customers || pullData.updated_customers.length === 0)
      ) {
        return pullData;
      }
      if (pullData.pending_orders && pullData.pending_orders.length > 0) {
        this.logger.log(
          `🔄 Iniciando procesamiento de ${pullData.pending_orders.length} pedidos...`,
        );
        let processedCount = 0;
        let skippedNoShiftCount = 0;
        let errorCount = 0;
        for (const remoteOrder of pullData.pending_orders) {
          try {
            this.logger.log(`  ⏳ Procesando pedido ${remoteOrder.id}...`);
            await this.dataSource.transaction(async (manager) => {
              await this.processRemoteOrder(manager, remoteOrder);
            });
            processedCount++;
            this.logger.log(
              `  ✅ Pedido ${remoteOrder.id} procesado exitosamente`,
            );
          } catch (error) {
            if (
              error.message === 'No hay shift abierto para sincronizar órdenes'
            ) {
              skippedNoShiftCount++;
            } else {
              errorCount++;
              this.logger.error(
                `  ❌ Error procesando pedido ${remoteOrder.id}:`,
                error.message,
              );
              if (error.stack) {
                this.logger.error(`     Stack: ${error.stack}`);
              }
            }
          }
        }
        const parts = [`📊 Resumen: ${processedCount} procesados`];
        if (skippedNoShiftCount > 0) {
          parts.push(`${skippedNoShiftCount} esperando shift`);
        }
        if (errorCount > 0) {
          parts.push(`${errorCount} errores`);
        }
        this.logger.log(parts.join(', '));
      }
      if (pullData.updated_customers && pullData.updated_customers.length > 0) {
        this.logger.log(
          `👥 Procesando ${pullData.updated_customers.length} clientes actualizados...`,
        );
        let customerProcessed = 0;
        let customerErrors = 0;
        for (const remoteCustomer of pullData.updated_customers) {
          try {
            await this.dataSource.transaction(async (manager) => {
              await this.processRemoteCustomer(manager, remoteCustomer);
            });
            customerProcessed++;
          } catch (error) {
            customerErrors++;
            this.logger.error(
              `  ❌ Error procesando cliente ${remoteCustomer.id}:`,
              error.message,
            );
          }
        }
        if (customerErrors > 0) {
          this.logger.log(
            `  📊 Clientes: ${customerProcessed} procesados, ${customerErrors} errores`,
          );
        }
      }
      return pullData;
    } catch (error) {
      await this.logSyncActivity(SyncActivityType.PULL_CHANGES, 'IN', false);
      throw error;
    }
  }
  private async processRemoteOrder(
    manager: any,
    remoteOrder: Order,
  ): Promise<void> {
    this.logger.log(`    🔍 Verificando si existe orden ${remoteOrder.id}...`);
    const existingOrder = await manager.findOne(OrderEntity, {
      where: { id: remoteOrder.id },
    });
    if (existingOrder) {
      this.logger.log(`    ⚠️ Orden ${remoteOrder.id} ya existe, saltando...`);
      return;
    }
    const activeShift = await manager.findOne(ShiftEntity, {
      where: { status: ShiftStatus.OPEN },
      order: { openedAt: 'DESC' },
    });
    if (!activeShift) {
      this.logger.warn(
        `    ⏸️ No hay shift abierto. Orden ${remoteOrder.id} se sincronizará cuando se abra un shift.`,
      );
      throw new Error('No hay shift abierto para sincronizar órdenes');
    }
    this.logger.log(
      `    ✨ Orden ${remoteOrder.id} no existe, creando nueva...`,
    );
    const shiftId = remoteOrder.shiftId || activeShift.id;
    const shiftOrderNumber = await this.getNextShiftOrderNumber(
      manager,
      shiftId,
    );
    this.logger.log(
      `    📝 Número de orden del turno: ${shiftOrderNumber} (Shift: ${shiftId})`,
    );
    let customer: CustomerEntity | null = null;
    if (remoteOrder.customer) {
      this.logger.log(
        `    👤 Procesando cliente ${remoteOrder.customer.id}...`,
      );
      customer = await this.findOrCreateCustomer(manager, remoteOrder.customer);
      this.logger.log(`    ✅ Cliente procesado: ${customer.id}`);
    }
    this.logger.log(`    💾 Guardando orden en base de datos...`);
    const order = await manager.save(OrderEntity, {
      id: remoteOrder.id,
      customer,
      customerId: customer?.id || remoteOrder.customerId || null,
      shiftOrderNumber,
      shiftId: shiftId,
      userId: remoteOrder.userId || remoteOrder.user?.id || null,
      tableId: remoteOrder.tableId || remoteOrder.table?.id || null,
      isFromWhatsApp: true,
      orderStatus: remoteOrder.orderStatus || OrderStatus.PENDING,
      orderType: remoteOrder.orderType || OrderType.DELIVERY,
      subtotal: remoteOrder.subtotal || 0,
      total: remoteOrder.total || remoteOrder.subtotal || 0,
      notes: remoteOrder.notes || null,
      scheduledAt: remoteOrder.scheduledAt || null,
      estimatedDeliveryTime: remoteOrder.estimatedDeliveryTime || null,
      finalizedAt: remoteOrder.finalizedAt || null,
    });
    this.logger.log(
      `    ✅ Orden guardada con ID: ${order.id}, Número: ${order.shiftOrderNumber}`,
    );
    if (remoteOrder.deliveryInfo) {
      this.logger.log(`    🚚 Guardando información de entrega...`);
      await this.saveDeliveryInfo(
        manager,
        order,
        remoteOrder.deliveryInfo,
        customer,
      );
    }
    if (remoteOrder.orderItems && remoteOrder.orderItems.length > 0) {
      this.logger.log(
        `    📦 Guardando ${remoteOrder.orderItems.length} items de la orden...`,
      );
      for (const item of remoteOrder.orderItems) {
        const orderItem = await manager.save(OrderItemEntity, {
          order,
          productId: item.productId || item.product?.id,
          productVariantId: item.productVariantId || item.productVariant?.id,
          basePrice: item.basePrice || 0,
          finalPrice: item.finalPrice || 0,
          preparationStatus:
            item.preparationStatus || PreparationStatus.PENDING,
          statusChangedAt: new Date(),
          preparationNotes: item.preparationNotes || null,
          preparedAt: item.preparedAt || null,
          preparedById: item.preparedById || item.preparedBy?.id || null,
        });
        if (item.productModifiers && item.productModifiers.length > 0) {
          const modifierIds = item.productModifiers
            .map((mod) => mod.id || mod)
            .filter(Boolean);
          if (modifierIds.length > 0) {
            await manager
              .createQueryBuilder()
              .insert()
              .into('order_item_product_modifiers')
              .values(
                modifierIds.map((modifierId) => ({
                  order_item_id: orderItem.id,
                  product_modifier_id: modifierId,
                })),
              )
              .execute();
          }
        }
        if (
          item.selectedPizzaCustomizations &&
          item.selectedPizzaCustomizations.length > 0
        ) {
          for (const customization of item.selectedPizzaCustomizations) {
            await manager.save('selected_pizza_customization', {
              orderItemId: orderItem.id,
              pizzaCustomizationId:
                customization.pizzaCustomizationId ||
                customization.pizzaCustomization?.id,
              half: customization.half,
              action: customization.action,
            });
          }
        }
        if (item.adjustments && item.adjustments.length > 0) {
          for (const adjustment of item.adjustments) {
            await manager.save('adjustment', {
              orderItemId: orderItem.id,
              name: adjustment.name,
              isPercentage: adjustment.isPercentage,
              value: adjustment.value,
              amount: adjustment.amount,
              appliedById: adjustment.appliedById || adjustment.appliedBy?.id,
              appliedAt: adjustment.appliedAt || new Date(),
            });
          }
        }
      }
    }
    this.logger.log(
      `    🎉 Orden ${remoteOrder.id} procesada completamente con ${remoteOrder.orderItems?.length || 0} items`,
    );
  }
  private async processRemoteCustomer(
    manager: any,
    remoteCustomer: Customer,
  ): Promise<void> {
    let existingCustomer = await manager.findOne(CustomerEntity, {
      where: { id: remoteCustomer.id },
    });
    if (!existingCustomer && remoteCustomer.whatsappPhoneNumber) {
      existingCustomer = await manager.findOne(CustomerEntity, {
        where: { whatsappPhoneNumber: remoteCustomer.whatsappPhoneNumber },
      });
    }
    if (existingCustomer) {
      await manager.update(
        CustomerEntity,
        { id: existingCustomer.id },
        {
          firstName: remoteCustomer.firstName,
          lastName: remoteCustomer.lastName,
          email: remoteCustomer.email,
          whatsappPhoneNumber: remoteCustomer.whatsappPhoneNumber,
        },
      );
      if (existingCustomer.id !== remoteCustomer.id) {
        this.logger.warn(
          `Cliente con WhatsApp ${remoteCustomer.whatsappPhoneNumber} ya existe con ID diferente. Local: ${existingCustomer.id}, Remoto: ${remoteCustomer.id}`,
        );
      }
    } else {
      await manager.save(CustomerEntity, {
        id: remoteCustomer.id,
        firstName: remoteCustomer.firstName,
        lastName: remoteCustomer.lastName,
        email: remoteCustomer.email,
        whatsappPhoneNumber: remoteCustomer.whatsappPhoneNumber,
      });
    }
    if (remoteCustomer.addresses && remoteCustomer.addresses.length > 0) {
      for (const address of remoteCustomer.addresses) {
        const existingAddress = await manager.findOne(AddressEntity, {
          where: { id: address.id },
        });
        if (!existingAddress) {
          await manager.save(AddressEntity, {
            id: address.id,
            customer: { id: remoteCustomer.id },
            name: address.name,
            street: address.street,
            number: address.number,
            interiorNumber: address.interiorNumber,
            neighborhood: address.neighborhood,
            city: address.city,
            state: address.state,
            zipCode: address.zipCode,
            country: address.country,
            latitude: address.latitude,
            longitude: address.longitude,
            deliveryInstructions: address.deliveryInstructions,
            isDefault: address.isDefault,
          });
        }
      }
    }
  }
  private async findOrCreateCustomer(
    manager: any,
    customerData: any,
  ): Promise<CustomerEntity> {
    const whatsappNumber =
      customerData.phoneNumber || customerData.whatsappPhoneNumber;
    if (customerData.id) {
      const customerById = await manager.findOne(CustomerEntity, {
        where: { id: customerData.id },
      });
      if (customerById) {
        this.logger.log(
          `      ✅ Cliente encontrado por ID: ${customerById.id}`,
        );
        return customerById;
      }
    }
    if (whatsappNumber) {
      const customerByWhatsApp = await manager.findOne(CustomerEntity, {
        where: { whatsappPhoneNumber: whatsappNumber },
      });
      if (customerByWhatsApp) {
        this.logger.log(
          `      ✅ Cliente encontrado por WhatsApp: ${customerByWhatsApp.id}`,
        );
        if (customerData.id && customerByWhatsApp.id !== customerData.id) {
          this.logger.warn(
            `      ⚠️ Cliente con WhatsApp ${whatsappNumber} tiene ID diferente. Local: ${customerByWhatsApp.id}, Remoto: ${customerData.id}`,
          );
        }
        return customerByWhatsApp;
      }
    }
    this.logger.log(
      `      ✨ Creando nuevo cliente: ${customerData.firstName} ${customerData.lastName || ''}`,
    );
    const customer = await manager.save(CustomerEntity, {
      id: customerData.id,
      firstName: customerData.firstName,
      lastName: customerData.lastName,
      email: customerData.email,
      whatsappPhoneNumber: whatsappNumber,
    });
    return customer;
  }
  private async saveDeliveryInfo(
    manager: any,
    order: OrderEntity,
    deliveryInfo: any,
    customer: CustomerEntity | null,
  ): Promise<void> {
    let address: AddressEntity | null = null;
    if (customer && deliveryInfo.address) {
      const addressData = deliveryInfo.address;
      address = await manager.save(AddressEntity, {
        customer,
        name: addressData.name || 'Dirección de entrega',
        street: addressData.street || addressData.addressLine1,
        number: addressData.number || 'S/N',
        interiorNumber: addressData.interiorNumber || addressData.addressLine2,
        neighborhood: addressData.neighborhood,
        city: addressData.city,
        state: addressData.state,
        zipCode: addressData.zipCode,
        country: addressData.country || 'México',
        latitude: addressData.latitude,
        longitude: addressData.longitude,
        deliveryInstructions: addressData.deliveryInstructions,
        isDefault: false,
      });
    }
    await manager.save(DeliveryInfoEntity, {
      order,
      recipientName: deliveryInfo.recipientName,
      recipientPhone: deliveryInfo.recipientPhone,
      deliveryInstructions: deliveryInfo.deliveryInstructions,
      fullAddress: deliveryInfo.fullAddress,
      street: address?.street || deliveryInfo.street,
      number: address?.number || deliveryInfo.number,
      interiorNumber: address?.interiorNumber || deliveryInfo.interiorNumber,
      neighborhood: address?.neighborhood || deliveryInfo.neighborhood,
      city: address?.city || deliveryInfo.city,
      state: address?.state || deliveryInfo.state,
      zipCode: address?.zipCode || deliveryInfo.zipCode,
      country: address?.country || deliveryInfo.country,
      latitude: address?.latitude || deliveryInfo.latitude,
      longitude: address?.longitude || deliveryInfo.longitude,
    });
  }
  async pushRestaurantData(): Promise<void> {
    try {
      const headers = { 'X-API-Key': this.syncConfig.cloudApiKey };
      const url = `${this.syncConfig.cloudApiUrl}/api/sync/push-restaurant-data`;
      this.logger.log('📤 Iniciando push de datos del restaurante...');
      const categories = await this.categoriesService.getFullMenu();
      this.logger.log(`✅ Menú obtenido: ${categories.length} categorías`);
      const config = await this.restaurantConfigService.getConfig();
      this.logger.log(`✅ Configuración obtenida: ${config?.restaurantName}`);
      this.logger.log('📋 Configuración del restaurante completa:');
      this.logger.log(
        JSON.stringify(
          {
            id: config?.id,
            restaurantName: config?.restaurantName,
            phoneMain: config?.phoneMain,
            phoneSecondary: config?.phoneSecondary,
            address: config?.address,
            city: config?.city,
            state: config?.state,
            postalCode: config?.postalCode,
            country: config?.country,
            acceptingOrders: config?.acceptingOrders,
            estimatedPickupTime: config?.estimatedPickupTime,
            estimatedDeliveryTime: config?.estimatedDeliveryTime,
            estimatedDineInTime: config?.estimatedDineInTime,
            openingGracePeriod: config?.openingGracePeriod,
            closingGracePeriod: config?.closingGracePeriod,
            timeZone: config?.timeZone,
            scheduledOrdersLeadTime: config?.scheduledOrdersLeadTime,
            deliveryCoverageArea: config?.deliveryCoverageArea,
            businessHours: config?.businessHours,
            createdAt: config?.createdAt,
            updatedAt: config?.updatedAt,
          },
          null,
          2,
        ),
      );
      if (config?.businessHours && config.businessHours.length > 0) {
        this.logger.log(
          `📅 Horarios de apertura (${config.businessHours.length} registros):`,
        );
        config.businessHours.forEach((bh) => {
          const dayNames = [
            'Domingo',
            'Lunes',
            'Martes',
            'Miércoles',
            'Jueves',
            'Viernes',
            'Sábado',
          ];
          const dayName = dayNames[bh.dayOfWeek] || `Día ${bh.dayOfWeek}`;
          if (bh.isClosed) {
            this.logger.log(`  - ${dayName}: CERRADO`);
          } else {
            this.logger.log(
              `  - ${dayName}: ${bh.openingTime || 'N/A'} - ${bh.closingTime || 'N/A'}`,
            );
          }
        });
      }
      let menuLastUpdated = new Date(0);
      for (const category of categories) {
        if (category.updatedAt && category.updatedAt > menuLastUpdated) {
          menuLastUpdated = category.updatedAt;
        }
        if (category.subcategories) {
          for (const subcategory of category.subcategories) {
            if (
              subcategory.updatedAt &&
              subcategory.updatedAt > menuLastUpdated
            ) {
              menuLastUpdated = subcategory.updatedAt;
            }
            if (subcategory.products) {
              for (const product of subcategory.products) {
                if (product.updatedAt && product.updatedAt > menuLastUpdated) {
                  menuLastUpdated = product.updatedAt;
                }
                if (product.variants) {
                  for (const variant of product.variants) {
                    if (
                      variant.updatedAt &&
                      variant.updatedAt > menuLastUpdated
                    ) {
                      menuLastUpdated = variant.updatedAt;
                    }
                  }
                }
              }
            }
          }
        }
      }
      const configLastUpdated = config?.updatedAt || new Date();
      const processedCategories = categories.map((category) => ({
        ...category,
        subcategories: category.subcategories?.map((subcategory) => ({
          ...subcategory,
          products: subcategory.products?.map((product) => ({
            ...product,
            price: product.price ? parseFloat(product.price.toString()) : null,
            pizzaConfiguration: product.pizzaConfiguration
              ? {
                  ...product.pizzaConfiguration,
                  extraToppingCost: parseFloat(
                    product.pizzaConfiguration.extraToppingCost.toString(),
                  ),
                }
              : undefined,
            variants: product.variants?.map((variant) => ({
              ...variant,
              price: variant.price ? parseFloat(variant.price.toString()) : 0,
            })),
            modifierGroups: product.modifierGroups?.map((group) => ({
              ...group,
              productModifiers: group.productModifiers?.map((modifier) => ({
                ...modifier,
                price: modifier.price
                  ? parseFloat(modifier.price.toString())
                  : 0,
              })),
            })),
          })),
        })),
      }));
      const pushData = {
        menu: {
          categories: processedCategories,
          lastUpdated: menuLastUpdated.toISOString(),
        },
        config: {
          restaurantConfig: {
            id: config?.id,
            restaurantName: config?.restaurantName,
            phoneMain: config?.phoneMain,
            phoneSecondary: config?.phoneSecondary,
            address: config?.address,
            city: config?.city,
            state: config?.state,
            postalCode: config?.postalCode,
            country: config?.country,
            acceptingOrders: config?.acceptingOrders,
            estimatedPickupTime: config?.estimatedPickupTime,
            estimatedDeliveryTime: config?.estimatedDeliveryTime,
            estimatedDineInTime: config?.estimatedDineInTime,
            openingGracePeriod: config?.openingGracePeriod,
            closingGracePeriod: config?.closingGracePeriod,
            timeZone: config?.timeZone,
            scheduledOrdersLeadTime: config?.scheduledOrdersLeadTime,
            deliveryCoverageArea: config?.deliveryCoverageArea,
            businessHours: config?.businessHours || [],
            updatedAt: config?.updatedAt,
            createdAt: config?.createdAt,
          },
          lastUpdated: configLastUpdated.toISOString(),
        },
      };
      this.logger.log(`📡 POST ${url}`);
      this.logger.log(
        `📦 Enviando ${processedCategories.length} categorías con menú completo`,
      );
      this.logger.log('🔍 Datos de configuración a enviar:');
      this.logger.log(JSON.stringify(pushData.config, null, 2));
      const response = await firstValueFrom(
        this.httpService.post(url, pushData, { headers }),
      );
      this.logger.log('✅ Push de datos del restaurante exitoso');
      await this.logSyncActivity(SyncActivityType.RESTAURANT_DATA, 'OUT', true);
    } catch (error) {
      this.logger.error(
        '❌ Error en push de datos del restaurante:',
        error.response?.data || error.message,
      );
      this.logger.error(
        `Status: ${error.response?.status}, URL: ${error.config?.url}`,
      );
      await this.logSyncActivity(
        SyncActivityType.RESTAURANT_DATA,
        'OUT',
        false,
      );
    }
  }
  async updateOrderStatus(
    updateDto: UpdateOrderStatusDto,
  ): Promise<UpdateOrderStatusResponseDto> {
    try {
      const headers = { 'X-API-Key': this.syncConfig.cloudApiKey };
      const response = await firstValueFrom(
        this.httpService.post<UpdateOrderStatusResponseDto>(
          `${this.syncConfig.cloudApiUrl}/api/sync/order-status`,
          updateDto,
          { headers },
        ),
      );
      const result = response.data;
      await this.logSyncActivity(SyncActivityType.ORDER_STATUS, 'OUT', true);
      return result;
    } catch (error) {
      await this.logSyncActivity(SyncActivityType.ORDER_STATUS, 'OUT', false);
      return {
        success: false,
        message: `Error al sincronizar con la nube: ${error.message}`,
        updatedAt: new Date().toISOString(),
        customerNotified: false,
      };
    }
  }
  private async getNextShiftOrderNumber(
    manager: any,
    shiftId: string | null,
  ): Promise<number> {
    if (!shiftId) {
      return 1;
    }
    const lastOrder = await manager.findOne(OrderEntity, {
      where: { shiftId },
      order: { shiftOrderNumber: 'DESC' },
      select: ['shiftOrderNumber'],
    });
    return lastOrder ? lastOrder.shiftOrderNumber + 1 : 1;
  }
  private async getCurrentShiftId(manager: any): Promise<string | null> {
    const activeShift = await manager.findOne(ShiftEntity, {
      where: { status: ShiftStatus.OPEN },
      order: { openedAt: 'DESC' },
    });
    if (activeShift) {
      return activeShift.id;
    }
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const lastShiftToday = await manager.findOne(ShiftEntity, {
      where: { date: today },
      order: { shiftNumber: 'DESC' },
    });
    if (lastShiftToday) {
      return lastShiftToday.id;
    }
    const lastShift = await manager.findOne(ShiftEntity, {
      order: { openedAt: 'DESC' },
    });
    if (lastShift) {
      this.logger.warn(
        `⚠️ No hay shift activo, usando el último shift disponible: ${lastShift.id}`,
      );
      return lastShift.id;
    }
    this.logger.error(
      '❌ No hay ningún shift en el sistema. Las órdenes se crearán sin shift.',
    );
    return null;
  }
  private async logSyncActivity(
    type: SyncActivityType,
    direction: 'IN' | 'OUT',
    success: boolean,
  ): Promise<void> {
    try {
      await this.dataSource.manager.save(SyncActivityEntity, {
        type,
        direction,
        success,
      });
    } catch (error) {
    }
  }
  async getRecentActivity(limit: number = 20): Promise<SyncActivityEntity[]> {
    return await this.dataSource.manager.find(SyncActivityEntity, {
      order: { timestamp: 'DESC' },
      take: limit,
    });
  }
  getWebSocketStatus(): { connected: boolean; failed: boolean } {
    return {
      connected: this.isWebSocketConnected && this.socket?.connected === true,
      failed: this.webSocketFailed,
    };
  }
}

================
File: app/src/modules/customers/components/AddressFormModal.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  Chip,
  Avatar,
  IconButton,
  Icon,
  ActivityIndicator,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { Address, CreateAddressDto } from '../types/customer.types';
import { addressSchema, AddressFormInputs } from '../schema/customer.schema';
import { WebView } from 'react-native-webview';
import { GOOGLE_MAPS_CONFIG } from '../constants/maps.config';
import { useGoogleMapsConfig } from '@/hooks/useGoogleMapsConfig';
import { useSnackbarStore } from '@/app/store/snackbarStore';
interface AddressFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: CreateAddressDto) => Promise<void>;
  editingItem: Address | null;
  isSubmitting: boolean;
  customerId: string;
}
export default function AddressFormModal({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}: AddressFormModalProps) {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  const showSnackbar = useSnackbarStore((state) => state.show);
  const { config: mapsConfig, loading: isLoadingApiKey } =
    useGoogleMapsConfig();
  const apiKey = mapsConfig?.apiKey;
  const [mapReady, setMapReady] = useState(false);
  const [isMapLoading, setIsMapLoading] = useState(true);
  const [isMapFullscreen, setIsMapFullscreen] = useState(false);
  const webViewRef = useRef<WebView>(null);
  const scrollViewRef = useRef<ScrollView>(null);
  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
    watch,
    trigger,
  } = useForm<AddressFormInputs>({
    resolver: zodResolver(addressSchema),
    defaultValues: {
      name: '',
      street: '',
      number: '',
      interiorNumber: '',
      neighborhood: '',
      city: '',
      state: '',
      zipCode: '',
      country: 'México',
      deliveryInstructions: '',
      isDefault: false,
    },
  });
  const latitude = watch('latitude');
  const longitude = watch('longitude');
  useEffect(() => {
    if (editingItem) {
      reset({
        name: editingItem.name,
        street: editingItem.street,
        number: editingItem.number,
        interiorNumber: editingItem.interiorNumber || '',
        neighborhood: editingItem.neighborhood,
        city: editingItem.city,
        state: editingItem.state,
        zipCode: editingItem.zipCode,
        country: editingItem.country || 'México',
        deliveryInstructions: editingItem.deliveryInstructions || '',
        // Convertir a número si existe, undefined si no
        latitude: editingItem.latitude
          ? Number(editingItem.latitude)
          : undefined,
        longitude: editingItem.longitude
          ? Number(editingItem.longitude)
          : undefined,
        isDefault: editingItem.isDefault,
      });
    } else {
      reset({
        name: '',
        street: '',
        number: '',
        interiorNumber: '',
        neighborhood: '',
        city: '',
        state: '',
        zipCode: '',
        country: 'México',
        deliveryInstructions: '',
        isDefault: false,
      });
    }
  }, [editingItem, reset]);
  // HTML del mapa con Google Maps API - Memoizado para evitar recrearlo en cada render
  const mapHtml = React.useMemo(
    () =>
      apiKey
        ? `
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      touch-action: manipulation;
    }
    #map {
      height: 100%;
      width: 100%;
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    let map;
    let marker;
    let currentLocation = null;
    function initMap() {
      // Inicializar el mapa
      const initialLocation = ${
        latitude && longitude
          ? `{ lat: ${latitude}, lng: ${longitude} }`
          : 'null'
      };
      const mapCenter = initialLocation || { lat: ${GOOGLE_MAPS_CONFIG.defaultCenter.lat}, lng: ${GOOGLE_MAPS_CONFIG.defaultCenter.lng} };
      map = new google.maps.Map(document.getElementById('map'), {
        center: mapCenter,
        zoom: initialLocation ? ${GOOGLE_MAPS_CONFIG.locationZoom} : ${GOOGLE_MAPS_CONFIG.defaultZoom},
        ...${JSON.stringify(GOOGLE_MAPS_CONFIG.mapOptions)},
        gestureHandling: ${isMapFullscreen ? "'greedy'" : "'cooperative'"},
      });
      if (initialLocation) {
        marker = new google.maps.Marker({
          position: initialLocation,
          map: map,
          draggable: true,
          animation: google.maps.Animation.DROP,
          title: "Ubicación de la dirección"
        });
        currentLocation = initialLocation;
        marker.addListener('dragend', function() {
          currentLocation = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          sendMessage('locationUpdated', {
            latitude: currentLocation.lat,
            longitude: currentLocation.lng
          });
        });
      }
      map.addListener('click', function(event) {
        if (!marker) {
          marker = new google.maps.Marker({
            position: event.latLng,
            map: map,
            draggable: true,
            animation: google.maps.Animation.DROP,
            title: "Ubicación de la dirección"
          });
          marker.addListener('dragend', function() {
            currentLocation = {
              lat: marker.getPosition().lat(),
              lng: marker.getPosition().lng()
            };
            sendMessage('locationUpdated', {
              latitude: currentLocation.lat,
              longitude: currentLocation.lng
            });
          });
        } else {
          marker.setPosition(event.latLng);
        }
        currentLocation = {
          lat: event.latLng.lat(),
          lng: event.latLng.lng()
        };
        sendMessage('locationUpdated', {
          latitude: currentLocation.lat,
          longitude: currentLocation.lng
        });
      });
      window.addEventListener('message', handleMessage);
      sendMessage('mapReady', {});
    }
    function handleMessage(event) {
      try {
        const data = JSON.parse(event.data);
        switch(data.type) {
          case 'setLocation':
            setLocation(data.latitude, data.longitude);
            break;
          case 'centerOnLocation':
            centerOnLocation();
            break;
        }
      } catch (e) {
      }
    }
    function setLocation(lat, lng) {
      const position = new google.maps.LatLng(lat, lng);
      if (!marker) {
        marker = new google.maps.Marker({
          position: position,
          map: map,
          draggable: true,
          animation: google.maps.Animation.DROP,
          title: "Ubicación de la dirección"
        });
        marker.addListener('dragend', function() {
          currentLocation = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          sendMessage('locationUpdated', {
            latitude: currentLocation.lat,
            longitude: currentLocation.lng
          });
        });
      } else {
        marker.setPosition(position);
      }
      map.setCenter(position);
      currentLocation = { lat, lng };
    }
    function centerOnLocation() {
      if (currentLocation) {
        map.setCenter(currentLocation);
        map.setZoom(16);
      }
    }
    function sendMessage(type, data) {
      try {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: type,
            ...data
          }));
        }
      } catch (e) {
      }
    }
  </script>
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap">
  </script>
</body>
</html>
  `
        : '',
    [latitude, longitude, isMapFullscreen, apiKey],
  );
  // Manejar mensajes del WebView
  const handleWebViewMessage = React.useCallback(
    (event: any) => {
      try {
        const data = JSON.parse(event.nativeEvent.data);
        switch (data.type) {
          case 'mapReady':
            setMapReady(true);
            setIsMapLoading(false);
            break;
          case 'locationUpdated':
            // Convertir a número antes de guardar
            setValue('latitude', Number(data.latitude));
            setValue('longitude', Number(data.longitude));
            break;
        }
      } catch (e) {}
    },
    [setValue],
  );
  // Enviar mensaje al WebView
  const sendMessageToWebView = React.useCallback((type: string, data: any) => {
    if (webViewRef.current) {
      const message = JSON.stringify({ type, ...data });
      webViewRef.current.postMessage(message);
    }
  }, []);
  // Actualizar la ubicación en el mapa cuando cambie
  useEffect(() => {
    if (mapReady && latitude !== undefined && longitude !== undefined) {
      sendMessageToWebView('setLocation', {
        latitude,
        longitude,
      });
    }
  }, [latitude, longitude, mapReady]);
  // Resetear estados cuando el componente se monta
  useEffect(() => {
    if (visible) {
      setIsMapLoading(true);
      setMapReady(false);
    }
  }, [visible]);
  const handleFormSubmit = React.useCallback(
    async (data: AddressFormInputs) => {
      const formattedData: CreateAddressDto = {
        name: data.name,
        street: data.street,
        number: data.number,
        interiorNumber: data.interiorNumber || undefined,
        neighborhood: data.neighborhood,
        city: data.city,
        state: data.state,
        zipCode: data.zipCode,
        country: data.country,
        deliveryInstructions: data.deliveryInstructions || undefined,
        latitude: data.latitude !== undefined ? data.latitude : undefined,
        longitude: data.longitude !== undefined ? data.longitude : undefined,
        isDefault: data.isDefault || false,
      };
      await onSubmit(formattedData);
    },
    [onSubmit],
  );
  const hasValidCoordinates = React.useMemo(() => {
    return (
      latitude !== undefined &&
      longitude !== undefined &&
      !isNaN(Number(latitude)) &&
      !isNaN(Number(longitude)) &&
      Number(latitude) !== 0 &&
      Number(longitude) !== 0
    );
  }, [latitude, longitude]);
  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.primary },
              ]}
            >
              <View style={styles.headerLeft}>
                <Avatar.Icon
                  size={28}
                  icon={editingItem ? 'map-marker-radius' : 'map-marker-plus'}
                  style={[
                    styles.headerIcon,
                    { backgroundColor: theme.colors.onPrimary + '20' },
                  ]}
                  color={theme.colors.onPrimary}
                />
                <View style={styles.headerTextContainer}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onPrimary },
                    ]}
                    variant="titleMedium"
                  >
                    {editingItem ? 'Editar Dirección' : 'Nueva Dirección'}
                  </Text>
                </View>
              </View>
              <IconButton
                icon="close"
                size={24}
                onPress={onDismiss}
                disabled={isSubmitting}
                iconColor={theme.colors.onPrimary}
              />
            </View>
            <ScrollView
              ref={scrollViewRef}
              style={styles.formContainer}
              showsVerticalScrollIndicator={false}
              keyboardShouldPersistTaps="handled"
            >
              {/* Switch de dirección predeterminada al inicio */}
              <Controller
                control={control}
                name="isDefault"
                render={({ field: { onChange, value } }) => (
                  <Surface
                    style={[
                      styles.switchContainer,
                      { marginBottom: theme.spacing.m },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.switchContent}>
                      <View style={styles.switchTextContainer}>
                        <Text style={styles.switchLabel} variant="bodyLarge">
                          Dirección predeterminada
                        </Text>
                        <Text
                          style={styles.switchDescription}
                          variant="bodySmall"
                        >
                          Esta será la dirección principal para los pedidos
                        </Text>
                      </View>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                )}
              />
              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información de la Dirección
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.requiredChip}
                    textStyle={styles.requiredChipText}
                  >
                    Requerido
                  </Chip>
                </View>
                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Nombre de la dirección"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.name}
                        mode="outlined"
                        placeholder="Ej: Casa, Oficina, Casa de mamá"
                        left={<TextInput.Icon icon="tag" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.name && (
                        <HelperText type="error" visible={!!errors.name}>
                          {errors.name.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
                <Controller
                  control={control}
                  name="street"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Calle"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.street}
                        mode="outlined"
                        placeholder="Ej: Av. Insurgentes"
                        left={<TextInput.Icon icon="road" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.street && (
                        <HelperText type="error" visible={!!errors.street}>
                          {errors.street.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
                <View style={styles.row}>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="number"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Número"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.number}
                            mode="outlined"
                            placeholder="123"
                            left={<TextInput.Icon icon="numeric" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.number && (
                            <HelperText type="error" visible={!!errors.number}>
                              {errors.number.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="interiorNumber"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Interior"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            mode="outlined"
                            placeholder="Depto 4B"
                            left={<TextInput.Icon icon="home-variant" />}
                            outlineStyle={styles.inputOutline}
                          />
                        </View>
                      )}
                    />
                  </View>
                </View>
                <Controller
                  control={control}
                  name="neighborhood"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Colonia"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.neighborhood}
                        mode="outlined"
                        placeholder="Ej: Roma Norte"
                        left={<TextInput.Icon icon="map" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.neighborhood && (
                        <HelperText
                          type="error"
                          visible={!!errors.neighborhood}
                        >
                          {errors.neighborhood.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
                <Controller
                  control={control}
                  name="city"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Ciudad"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.city}
                        mode="outlined"
                        placeholder="Ej: Ciudad de México"
                        left={<TextInput.Icon icon="city" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.city && (
                        <HelperText type="error" visible={!!errors.city}>
                          {errors.city.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
                <View style={styles.row}>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="state"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Estado"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.state}
                            mode="outlined"
                            placeholder="Ej: CDMX"
                            left={<TextInput.Icon icon="map-marker" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.state && (
                            <HelperText type="error" visible={!!errors.state}>
                              {errors.state.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="zipCode"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="C.P."
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.zipCode}
                            mode="outlined"
                            placeholder="06700"
                            keyboardType="numeric"
                            maxLength={5}
                            left={<TextInput.Icon icon="mailbox" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.zipCode && (
                            <HelperText type="error" visible={!!errors.zipCode}>
                              {errors.zipCode.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>
                </View>
                <Controller
                  control={control}
                  name="country"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="País"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.country}
                        mode="outlined"
                        placeholder="México"
                        left={<TextInput.Icon icon="earth" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.country && (
                        <HelperText type="error" visible={!!errors.country}>
                          {errors.country.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>
              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Información Adicional
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.optionalChip}
                    textStyle={styles.optionalChipText}
                  >
                    Opcional
                  </Chip>
                </View>
                <Controller
                  control={control}
                  name="deliveryInstructions"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Instrucciones de entrega"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Entre calles, color de fachada, etc."
                        multiline
                        numberOfLines={2}
                        left={<TextInput.Icon icon="sign-direction" />}
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
                {/* Sección de Ubicación con Mapa Integrado */}
                <View style={styles.locationWrapper}>
                  <View style={styles.locationHeader}>
                    <Text style={styles.locationLabel} variant="bodyMedium">
                      Ubicación en el mapa
                    </Text>
                    {hasValidCoordinates && (
                      <Button
                        mode="text"
                        onPress={() => {
                          setValue('latitude', undefined);
                          setValue('longitude', undefined);
                          // Forzar la validación del formulario
                          trigger(['latitude', 'longitude']);
                        }}
                        icon="close"
                        compact
                        style={styles.clearLocationBtn}
                      >
                        Limpiar
                      </Button>
                    )}
                  </View>
                  <Surface style={styles.mapContainer} elevation={1}>
                    <View style={styles.mapInstructions}>
                      <Icon
                        source="gesture-two-double-tap"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text
                        style={styles.mapInstructionText}
                        variant="bodySmall"
                      >
                        Usa dos dedos para mover el mapa • Toca para marcar
                        ubicación
                      </Text>
                    </View>
                    <View style={styles.mapView}>
                      {isLoadingApiKey || !mapHtml ? (
                        <View style={[styles.map, styles.mapLoadingContainer]}>
                          <ActivityIndicator
                            size="large"
                            color={theme.colors.primary}
                          />
                          <Text style={styles.mapLoadingText}>
                            Cargando mapa...
                          </Text>
                        </View>
                      ) : (
                        <WebView
                          ref={webViewRef}
                          source={{ html: mapHtml }}
                          style={styles.map}
                          onMessage={handleWebViewMessage}
                          onError={(_error) => {}}
                          javaScriptEnabled={true}
                          domStorageEnabled={true}
                          startInLoadingState={true}
                          mixedContentMode="compatibility"
                          allowsInlineMediaPlayback={true}
                          originWhitelist={['*']}
                          scalesPageToFit={false}
                          bounces={false}
                          scrollEnabled={false}
                          nestedScrollEnabled={false}
                        />
                      )}
                      {/* Indicador de carga */}
                      {isMapLoading && (
                        <View style={styles.mapLoadingContainer}>
                          <Surface style={styles.mapLoadingCard} elevation={3}>
                            <ActivityIndicator
                              size="large"
                              color={theme.colors.primary}
                            />
                            <Text style={styles.mapLoadingText}>
                              Cargando mapa...
                            </Text>
                          </Surface>
                        </View>
                      )}
                      {/* Botones flotantes */}
                      {mapReady && (
                        <>
                          {/* Botón de expandir */}
                          <View style={styles.expandButtonContainer}>
                            <Button
                              mode="contained"
                              icon={
                                isMapFullscreen
                                  ? 'fullscreen-exit'
                                  : 'fullscreen'
                              }
                              onPress={() =>
                                setIsMapFullscreen(!isMapFullscreen)
                              }
                              style={styles.expandButton}
                              labelStyle={styles.expandButtonLabel}
                            >
                              {isMapFullscreen ? 'Cerrar' : 'Expandir mapa'}
                            </Button>
                          </View>
                          {/* Botón de centrar */}
                          {hasValidCoordinates && (
                            <View style={styles.centerButtonContainer}>
                              <IconButton
                                icon="crosshairs-gps"
                                mode="contained"
                                containerColor={theme.colors.primaryContainer}
                                iconColor={theme.colors.onPrimaryContainer}
                                size={20}
                                onPress={() =>
                                  sendMessageToWebView('centerOnLocation', {})
                                }
                                style={styles.floatingButton}
                              />
                            </View>
                          )}
                        </>
                      )}
                    </View>
                    {/* Mostrar coordenadas */}
                    {hasValidCoordinates && (
                      <View style={styles.coordinatesContainer}>
                        <Text
                          variant="labelSmall"
                          style={styles.coordinatesLabel}
                        >
                          Coordenadas:
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={styles.coordinatesText}
                        >
                          {Number(latitude).toFixed(6)},{' '}
                          {Number(longitude).toFixed(6)}
                        </Text>
                      </View>
                    )}
                  </Surface>
                </View>
              </View>
              {/* Espacio adicional para el teclado */}
              <View style={{ height: 10 }} />
            </ScrollView>
            <Surface style={styles.buttonContainer} elevation={2}>
              <Button
                onPress={onDismiss}
                disabled={isSubmitting}
                style={[styles.button, styles.cancelButton]}
                textColor={theme.colors.onSecondaryContainer}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={() => {
                  handleSubmit(handleFormSubmit, (validationErrors) => {
                    const errorMessages = Object.entries(validationErrors)
                      .map(([field, error]) => {
                        if (error && 'message' in error) {
                          const fieldNames: Record<string, string> = {
                            name: 'Nombre de la dirección',
                            street: 'Calle',
                            number: 'Número',
                            neighborhood: 'Colonia',
                            city: 'Ciudad',
                            state: 'Estado',
                            zipCode: 'Código postal',
                            country: 'País',
                          };
                          const fieldName = fieldNames[field] || field;
                          return `${fieldName}: ${error.message}`;
                        }
                        return null;
                      })
                      .filter(Boolean);
                    if (errorMessages.length > 0) {
                      showSnackbar({
                        message: errorMessages[0],
                        type: 'error',
                      });
                      scrollViewRef.current?.scrollTo({
                        x: 0,
                        y: 0,
                        animated: true,
                      });
                    }
                  })();
                }}
                disabled={isSubmitting}
                loading={isSubmitting}
                style={[styles.button, styles.confirmButton]}
                buttonColor={theme.colors.primary}
              >
                {editingItem ? 'Guardar' : 'Crear'}
              </Button>
            </Surface>
          </Surface>
        </Modal>
      </Portal>
      {}
      <Portal>
        <Modal
          visible={isMapFullscreen}
          onDismiss={() => setIsMapFullscreen(false)}
          contentContainerStyle={styles.fullscreenModalContainer}
        >
          <Surface style={styles.fullscreenModalContent} elevation={5}>
            <View style={styles.fullscreenHeader}>
              <Text variant="titleLarge" style={styles.fullscreenTitle}>
                Ubicación
              </Text>
              <IconButton
                icon="close"
                size={28}
                onPress={() => setIsMapFullscreen(false)}
                style={styles.fullscreenCloseButton}
              />
            </View>
            <View style={styles.fullscreenMapContainer}>
              <WebView
                source={{ html: mapHtml }}
                style={styles.map}
                onMessage={handleWebViewMessage}
                javaScriptEnabled={true}
                domStorageEnabled={true}
                startInLoadingState={false}
                mixedContentMode="compatibility"
                allowsInlineMediaPlayback={true}
                originWhitelist={['*']}
                scalesPageToFit={false}
              />
              {hasValidCoordinates && (
                <View style={styles.fullscreenCoordinates}>
                  <Surface style={styles.coordinatesBadge} elevation={3}>
                    <Icon
                      source="map-marker"
                      size={20}
                      color={theme.colors.primary}
                    />
                    <Text variant="bodyLarge" style={styles.coordinatesText}>
                      {Number(latitude).toFixed(6)},{' '}
                      {Number(longitude).toFixed(6)}
                    </Text>
                  </Surface>
                </View>
              )}
            </View>
          </Surface>
        </Modal>
      </Portal>
    </>
  );
}
const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContainer: {
      margin: 10,
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      maxHeight: '95%',
      minHeight: '80%',
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.xs,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: theme.spacing.m,
      paddingTop: theme.spacing.xs,
    },
    sectionContainer: {
      marginBottom: theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 14,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    requiredChipText: {
      color: theme.colors.onErrorContainer,
      fontSize: 11,
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    inputContainer: {
      marginBottom: theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
    row: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    halfInput: {
      flex: 1,
    },
    locationWrapper: {
      marginTop: theme.spacing.m,
    },
    locationHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    locationLabel: {
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    clearLocationBtn: {
      marginRight: -theme.spacing.s,
    },
    mapContainer: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      backgroundColor: theme.colors.surface,
    },
    mapInstructions: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      gap: theme.spacing.s,
    },
    mapInstructionText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
    },
    mapView: {
      height: 300,
      position: 'relative',
    },
    map: {
      ...StyleSheet.absoluteFillObject,
    },
    mapLoadingContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
    },
    mapLoadingCard: {
      padding: theme.spacing.xl,
      borderRadius: 16,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
    },
    mapLoadingText: {
      marginTop: theme.spacing.m,
      fontSize: 14,
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    expandButtonContainer: {
      position: 'absolute',
      top: theme.spacing.s,
      right: theme.spacing.s,
      zIndex: 10,
    },
    expandButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    expandButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
    },
    centerButtonContainer: {
      position: 'absolute',
      bottom: theme.spacing.s,
      right: theme.spacing.s,
    },
    floatingButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    coordinatesContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.xs,
    },
    coordinatesLabel: {
      color: theme.colors.onSurfaceVariant,
    },
    coordinatesText: {
      fontWeight: '500',
      color: theme.colors.onSurface,
      fontFamily: 'monospace',
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.xs,
      marginTop: theme.spacing.xs,
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: 12,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.s,
    },
    button: {
      flex: 1,
      maxWidth: 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    fullscreenModalContainer: {
      flex: 1,
      margin: 0,
    },
    fullscreenModalContent: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    fullscreenHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingLeft: theme.spacing.l,
      paddingRight: theme.spacing.s,
      paddingVertical: theme.spacing.s,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      height: 56,
    },
    fullscreenTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    fullscreenCloseButton: {
      margin: 0,
    },
    fullscreenMapContainer: {
      flex: 1,
      position: 'relative',
    },
    fullscreenCoordinates: {
      position: 'absolute',
      bottom: theme.spacing.m,
      left: theme.spacing.m,
    },
    coordinatesBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      gap: theme.spacing.s,
    },
    coordinatesText: {
      fontFamily: 'monospace',
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
  });

================
File: app/src/modules/orderFinalization/components/OrderDetailsModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Modal,
  Portal,
  Surface,
  Text,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
} from 'react-native-paper';
import {
  OrderForFinalization,
  OrderItemForFinalization,
} from '../types/orderFinalization.types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
interface OrderDetailsModalProps {
  visible: boolean;
  onDismiss: () => void;
  order: OrderForFinalization | null;
  isLoading?: boolean;
  onPrintPress: (order: OrderForFinalization) => void;
}
const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';
  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalf.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalf.HALF_2
            ? 'HALF_2'
            : 'FULL';
      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }
      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;
      if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationType.INGREDIENT
      ) {
        if (curr.action === CustomizationAction.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }
      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );
  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };
    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';
    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }
  return '';
};
export const OrderDetailsModal: React.FC<OrderDetailsModalProps> = ({
  visible,
  onDismiss,
  order,
  isLoading = false,
  onPrintPress,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [showPrintHistory, setShowPrintHistory] = useState(false);
  if (!order && !isLoading) return null;
  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return '🍽️ Local';
      case 'TAKE_AWAY':
        return '🥡 Llevar';
      case 'DELIVERY':
        return '🚚 Envío';
      default:
        return type;
    }
  };
  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparación';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      default:
        return status;
    }
  };
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0';
      default:
        return theme.colors.onSurfaceVariant;
    }
  };
  const getPaymentStatus = () => {
    if (order?.payments && order.payments.length > 0) {
      const totalPaid = order.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof order.total === 'string' ? parseFloat(order.total) : order.total;
      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };
  const paymentStatus = order
    ? getPaymentStatus()
    : { label: 'Pendiente', color: '#EF4444' };
  const renderItem = (item: OrderItemForFinalization) => {
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * item.quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;
    return (
      <Surface
        key={`${item.product.id}-${item.productVariant?.id || ''}-${item.preparationStatus || ''}`}
        style={[
          styles.itemCard,
          { backgroundColor: theme.colors.elevation.level1, marginBottom: 8 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {item.quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>
          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}
            {item.modifiers && item.modifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.modifiers.map((modifier) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      • {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}
            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  📝 {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>
          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {item.quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total ×{item.quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContent,
          { backgroundColor: theme.colors.background },
        ]}
      >
        {isLoading || !order ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text
              style={[
                styles.loadingText,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Cargando detalles de la orden...
            </Text>
          </View>
        ) : (
          <>
            <View style={styles.header}>
              <View style={styles.headerInfo}>
                <View style={styles.headerTopRow}>
                  <View style={styles.headerLeft}>
                    <Text
                      style={[styles.title, { color: theme.colors.onSurface }]}
                    >
                      Orden #{order?.shiftOrderNumber || ''}
                    </Text>
                    <Text
                      style={[
                        styles.headerSeparator,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      •
                    </Text>
                    <Text
                      style={[
                        styles.orderType,
                        { color: theme.colors.primary },
                      ]}
                    >
                      {order ? getOrderTypeLabel(order.orderType) : ''}
                    </Text>
                    <Text
                      style={[
                        styles.headerSeparator,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      •
                    </Text>
                    <Text
                      style={[
                        styles.headerDate,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {order?.createdAt
                        ? format(new Date(order.createdAt), 'dd/MM HH:mm', {
                            locale: es,
                          })
                        : ''}
                    </Text>
                  </View>
                  <View style={styles.headerActions}>
                    <IconButton
                      icon="close"
                      size={24}
                      onPress={onDismiss}
                      style={styles.closeButton}
                    />
                  </View>
                </View>
                <View style={styles.headerBottomRow}>
                  <View style={styles.chipsRow}>
                    <View
                      style={[
                        styles.headerStatusChip,
                        {
                          backgroundColor: order
                            ? getStatusColor(order.orderStatus, theme)
                            : theme.colors.surfaceVariant,
                        },
                      ]}
                    >
                      <Text style={styles.headerStatusChipText}>
                        {order ? getOrderStatusLabel(order.orderStatus) : ''}
                      </Text>
                    </View>
                    {order?.preparationScreens &&
                      order.preparationScreens.map((screen, index) => (
                        <Chip
                          key={index}
                          mode="outlined"
                          compact
                          style={styles.screenChip}
                          textStyle={styles.screenChipText}
                        >
                          🍳 {screen}
                        </Chip>
                      ))}
                  </View>
                </View>
              </View>
            </View>
            <ScrollView
              style={styles.scrollView}
              showsVerticalScrollIndicator={false}
              contentContainerStyle={styles.scrollContent}
            >
              <View style={styles.infoSection}>
                {order?.deliveryInfo?.recipientName && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      👤 Nombre del Cliente: {order.deliveryInfo.recipientName}
                    </Text>
                  </View>
                )}
                {order?.deliveryInfo?.recipientPhone && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      📞 Teléfono: {order.deliveryInfo.recipientPhone}
                    </Text>
                  </View>
                )}
                {order?.orderType === 'DELIVERY' &&
                  order?.deliveryInfo?.fullAddress && (
                    <View style={styles.infoRow}>
                      <Text
                        style={[
                          styles.addressText,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        📦 Dirección de Entrega:{' '}
                        {order.deliveryInfo.fullAddress}
                      </Text>
                    </View>
                  )}
                {order?.orderType === 'DINE_IN' && order?.table && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.tableText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      🏛️ Mesa: {order.table.area?.name || 'Sin área'} -{' '}
                      {order.table.number}
                    </Text>
                  </View>
                )}
                {order?.scheduledAt && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.primary, fontWeight: '600' },
                      ]}
                    >
                      ⏰ Hora de Entrega Programada:{' '}
                      {format(new Date(order.scheduledAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                )}
              </View>
              <Divider style={styles.divider} />
              <View style={styles.itemsList}>
                {order?.orderItems?.map((item) => renderItem(item)) || []}
              </View>
              <Divider style={styles.divider} />
              {order?.payments && order.payments.length > 0 && (
                <>
                  <View style={styles.paymentsSection}>
                    <View style={styles.paymentSummaryCompact}>
                      <View style={styles.summaryCompactRow}>
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            { color: theme.colors.onSurfaceVariant },
                          ]}
                        >
                          Total: $
                          {typeof order.total === 'string'
                            ? parseFloat(order.total).toFixed(2)
                            : order.total.toFixed(2)}
                        </Text>
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            { color: '#10B981' },
                          ]}
                        >
                          Pagado: $
                          {order.payments
                            .reduce((sum, p) => sum + p.amount, 0)
                            .toFixed(2)}
                        </Text>
                        {(() => {
                          const totalOrder =
                            typeof order.total === 'string'
                              ? parseFloat(order.total)
                              : order.total;
                          const totalPaid = order.payments.reduce(
                            (sum, p) => sum + p.amount,
                            0,
                          );
                          const remaining = totalOrder - totalPaid;
                          if (remaining > 0) {
                            return (
                              <Text
                                style={[
                                  styles.summaryCompactLabel,
                                  {
                                    color: theme.colors.error,
                                    fontWeight: '600',
                                  },
                                ]}
                              >
                                Resta: ${remaining.toFixed(2)}
                              </Text>
                            );
                          }
                          return null;
                        })()}
                      </View>
                    </View>
                    {order.payments.map((payment, index) => {
                      const getPaymentMethodLabel = (method: string) => {
                        switch (method) {
                          case 'CASH':
                            return 'Efectivo';
                          case 'CREDIT_CARD':
                            return 'Tarjeta de Crédito';
                          case 'DEBIT_CARD':
                            return 'Tarjeta de Débito';
                          case 'TRANSFER':
                            return 'Transferencia';
                          case 'OTHER':
                            return 'Otro';
                          default:
                            return method;
                        }
                      };
                      const getPaymentStatusColor = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return '#10B981';
                          case 'PENDING':
                            return '#F59E0B';
                          case 'FAILED':
                            return theme.colors.error;
                          case 'REFUNDED':
                            return '#6B7280';
                          case 'CANCELLED':
                            return theme.colors.error;
                          default:
                            return theme.colors.onSurfaceVariant;
                        }
                      };
                      const getPaymentStatusLabel = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return 'Completado';
                          case 'PENDING':
                            return 'Pendiente';
                          case 'FAILED':
                            return 'Fallido';
                          case 'REFUNDED':
                            return 'Reembolsado';
                          case 'CANCELLED':
                            return 'Cancelado';
                          default:
                            return status;
                        }
                      };
                      return (
                        <View
                          key={payment.id || index}
                          style={styles.paymentRowCompact}
                        >
                          <Text
                            style={[
                              styles.paymentMethodCompact,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            💳 {getPaymentMethodLabel(payment.paymentMethod)}
                          </Text>
                          <Text
                            style={[
                              styles.paymentDateCompact,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {format(new Date(payment.createdAt), 'HH:mm', {
                              locale: es,
                            })}
                          </Text>
                          <View
                            style={[
                              styles.paymentStatusBadgeCompact,
                              {
                                backgroundColor:
                                  getPaymentStatusColor(payment.paymentStatus) +
                                  '20',
                              },
                            ]}
                          >
                            <Text
                              style={[
                                styles.paymentStatusTextCompact,
                                {
                                  color: getPaymentStatusColor(
                                    payment.paymentStatus,
                                  ),
                                },
                              ]}
                            >
                              {getPaymentStatusLabel(payment.paymentStatus)}
                            </Text>
                          </View>
                          <Text
                            style={[
                              styles.paymentAmountCompact,
                              { color: theme.colors.primary },
                            ]}
                          >
                            ${payment.amount.toFixed(2)}
                          </Text>
                        </View>
                      );
                    })}
                  </View>
                  <Divider style={styles.divider} />
                </>
              )}
              {order?.ticketImpressions &&
                order.ticketImpressions.length > 0 && (
                  <>
                    <View style={styles.ticketImpressionsSection}>
                      <TouchableOpacity
                        style={styles.collapsibleHeader}
                        onPress={() => setShowPrintHistory(!showPrintHistory)}
                        activeOpacity={0.7}
                      >
                        <Text
                          style={[
                            styles.sectionTitle,
                            { color: theme.colors.primary },
                          ]}
                        >
                          🖨️ Historial de Impresiones (
                          {order.ticketImpressions.length})
                        </Text>
                        <IconButton
                          icon={
                            showPrintHistory ? 'chevron-up' : 'chevron-down'
                          }
                          size={20}
                          style={styles.collapseIcon}
                        />
                      </TouchableOpacity>
                      {showPrintHistory && (
                        <View style={styles.collapsibleContent}>
                          {order.ticketImpressions.map((impression, index) => {
                            const getTicketTypeLabel = (type: string) => {
                              switch (type) {
                                case 'KITCHEN':
                                  return '🍳 Cocina';
                                case 'BAR':
                                  return '🍺 Barra';
                                case 'BILLING':
                                  return '💵 Cuenta';
                                case 'CUSTOMER_COPY':
                                  return '📄 Copia Cliente';
                                case 'GENERAL':
                                  return '📋 General';
                                default:
                                  return type;
                              }
                            };
                            return (
                              <View
                                key={impression.id || index}
                                style={styles.impressionRow}
                              >
                                <View style={styles.impressionLeft}>
                                  <Text
                                    style={[
                                      styles.impressionType,
                                      { color: theme.colors.onSurface },
                                    ]}
                                  >
                                    {getTicketTypeLabel(impression.ticketType)}
                                  </Text>
                                  <View style={styles.impressionDetails}>
                                    {impression.user && (
                                      <Text
                                        style={[
                                          styles.impressionUser,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        por {impression.user.firstName || ''}{' '}
                                        {impression.user.lastName || ''}
                                      </Text>
                                    )}
                                    {impression.printer && (
                                      <Text
                                        style={[
                                          styles.impressionPrinter,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        🖨️ {impression.printer.name}
                                      </Text>
                                    )}
                                  </View>
                                </View>
                                <Text
                                  style={[
                                    styles.impressionTime,
                                    { color: theme.colors.onSurfaceVariant },
                                  ]}
                                >
                                  {format(
                                    new Date(impression.impressionTime),
                                    'HH:mm:ss',
                                    { locale: es },
                                  )}
                                </Text>
                              </View>
                            );
                          })}
                        </View>
                      )}
                    </View>
                  </>
                )}
            </ScrollView>
            <Divider style={styles.divider} />
            <View style={styles.footer}>
              <View style={styles.footerLeft}>
                <Text
                  style={[
                    styles.totalLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Por pagar:
                </Text>
                <Text
                  style={[
                    styles.totalAmount,
                    {
                      color: (() => {
                        const totalOrder =
                          typeof order.total === 'string'
                            ? parseFloat(order.total)
                            : order.total;
                        const totalPaid =
                          order.payments?.reduce(
                            (sum, p) => sum + p.amount,
                            0,
                          ) || 0;
                        const remaining = totalOrder - totalPaid;
                        return remaining > 0 ? theme.colors.error : '#10B981';
                      })(),
                    },
                  ]}
                >
                  $
                  {(() => {
                    if (!order) return '0.00';
                    const totalOrder =
                      typeof order.total === 'string'
                        ? parseFloat(order.total)
                        : order.total;
                    const totalPaid =
                      order.payments?.reduce((sum, p) => sum + p.amount, 0) ||
                      0;
                    const remaining = totalOrder - totalPaid;
                    return remaining > 0 ? remaining.toFixed(2) : '0.00';
                  })()}
                </Text>
              </View>
              <View
                style={[
                  styles.paymentBadge,
                  { backgroundColor: paymentStatus.color },
                ]}
              >
                <Text style={styles.paymentBadgeText}>
                  💵 {paymentStatus.label}
                </Text>
              </View>
            </View>
          </>
        )}
      </Modal>
    </Portal>
  );
};
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContent: {
      margin: 12,
      borderRadius: 12,
      maxHeight: '90%',
      elevation: 4,
      overflow: 'hidden',
    },
    header: {
      paddingHorizontal: 16,
      paddingTop: 10,
      paddingBottom: 6,
    },
    headerTopRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 6,
    },
    headerLeft: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
    },
    headerBottomRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    chipsRow: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
      flexWrap: 'wrap',
    },
    headerSeparator: {
      fontSize: responsive.fontSize(11),
      marginHorizontal: 6,
    },
    orderType: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    headerDate: {
      fontSize: responsive.fontSize(11),
    },
    infoSection: {
      paddingHorizontal: 16,
      paddingTop: 4,
      paddingBottom: 6,
      gap: 4,
    },
    infoRow: {
      marginVertical: 2,
    },
    contactText: {
      fontSize: responsive.fontSize(12),
    },
    addressText: {
      fontSize: responsive.fontSize(12),
      lineHeight: 16,
    },
    tableText: {
      fontSize: responsive.fontSize(12),
    },
    screenChip: {
      height: 20,
    },
    screenChipText: {
      fontSize: responsive.fontSize(10),
      marginVertical: -2,
    },
    paymentBadge: {
      paddingHorizontal: 10,
      paddingVertical: 4,
      borderRadius: 12,
    },
    paymentBadgeText: {
      color: 'white',
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    totalAmount: {
      fontSize: responsive.fontSize(16),
      fontWeight: '700',
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.08)',
      backgroundColor: 'inherit',
    },
    footerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    totalLabel: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
    },
    divider: {
      marginVertical: 2,
    },
    closeButton: {
      margin: -8,
    },
    headerActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 16,
    },
    headerStatusChip: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 10,
    },
    headerStatusChipText: {
      color: 'white',
      fontSize: responsive.fontSize(11),
      fontWeight: '600',
    },
    title: {
      fontSize: responsive.fontSize(20),
      fontWeight: '700',
    },
    scrollView: {
      flexGrow: 0,
      flexShrink: 1,
      maxHeight: '70%',
    },
    scrollContent: {
      paddingBottom: 8,
    },
    itemsList: {
      padding: 12,
      paddingBottom: 16,
    },
    itemCard: {
      borderRadius: 8,
      overflow: 'hidden',
    },
    itemContent: {
      padding: 10,
    },
    itemHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 6,
    },
    nameContainer: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    itemQuantity: {
      fontSize: responsive.fontSize(14),
      fontWeight: '700',
      marginRight: 6,
    },
    itemName: {
      fontSize: responsive.fontSize(13),
      fontWeight: '600',
      flex: 1,
      lineHeight: 16,
    },
    statusChip: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
    },
    statusChipText: {
      color: 'white',
      fontSize: responsive.fontSize(10),
      fontWeight: '600',
    },
    itemDetailsContainer: {
      marginBottom: 6,
    },
    customizationContainer: {
      marginBottom: 4,
    },
    pizzaCustomizationText: {
      fontSize: responsive.fontSize(11),
      fontStyle: 'italic',
      lineHeight: 14,
    },
    modifiersContainer: {
      marginTop: 2,
    },
    modifierRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 1,
    },
    modifierText: {
      fontSize: responsive.fontSize(11),
      flex: 1,
      lineHeight: 14,
    },
    modifierPrice: {
      fontSize: responsive.fontSize(11),
      fontWeight: '500',
      marginLeft: 4,
    },
    notesContainer: {
      marginTop: 4,
      paddingTop: 4,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.06)',
    },
    notesText: {
      fontSize: responsive.fontSize(11),
      fontStyle: 'italic',
      lineHeight: 14,
    },
    priceContainer: {
      marginTop: 6,
      paddingTop: 6,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.06)',
    },
    priceRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    priceLabel: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    priceValue: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    totalPrice: {
      fontSize: responsive.fontSize(14),
      fontWeight: '700',
    },
    paymentsSection: {
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    paymentSummaryCompact: {
      marginBottom: 8,
    },
    summaryCompactRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    summaryCompactLabel: {
      fontSize: responsive.fontSize(12),
      fontWeight: '500',
    },
    paymentRowCompact: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 6,
      gap: 8,
    },
    paymentMethodCompact: {
      fontSize: responsive.fontSize(11),
      fontWeight: '500',
      flex: 1,
    },
    paymentDateCompact: {
      fontSize: responsive.fontSize(10),
    },
    paymentAmountCompact: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
      minWidth: 50,
      textAlign: 'right',
    },
    paymentStatusBadgeCompact: {
      paddingHorizontal: 6,
      paddingVertical: 1,
      borderRadius: 10,
    },
    paymentStatusTextCompact: {
      fontSize: responsive.fontSize(9),
      fontWeight: '600',
    },
    ticketImpressionsSection: {
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    collapsibleHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingRight: 4,
    },
    collapseIcon: {
      margin: -8,
    },
    collapsibleContent: {
      marginTop: 8,
    },
    sectionTitle: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
      marginBottom: 0,
    },
    impressionRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 8,
      paddingLeft: 8,
    },
    impressionLeft: {
      flex: 1,
      gap: 2,
    },
    impressionType: {
      fontSize: responsive.fontSize(12),
      fontWeight: '500',
    },
    impressionDetails: {
      gap: 2,
    },
    impressionUser: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    impressionPrinter: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
      fontStyle: 'italic',
    },
    impressionTime: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    loadingContainer: {
      minHeight: 200,
      justifyContent: 'center',
      alignItems: 'center',
      paddingVertical: 40,
    },
    loadingText: {
      marginTop: 16,
      fontSize: responsive.fontSize(14),
    },
  });
export default OrderDetailsModal;

================
File: app/src/modules/orderFinalization/types/orderFinalization.types.ts
================
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';
export interface OrderForFinalizationList {
  id: string;
  shiftOrderNumber: number;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN';
  orderStatus:
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'COMPLETED'
    | 'CANCELLED';
  total: string | number;
  createdAt: string;
  scheduledAt?: string;
  paymentsSummary?: {
    totalPaid: number;
  };
  deliveryInfo?: {
    recipientName?: string;
    recipientPhone?: string;
    fullAddress?: string;
  };
  preparationScreens?: string[];
  preparationScreenStatuses?: Array<{
    name: string;
    status: 'PENDING' | 'IN_PROGRESS' | 'READY';
  }>;
  ticketImpressionCount?: number;
  notes?: string;
  table?: {
    number: string;
    name: string;
    isTemporary: boolean;
    area?: {
      name: string;
    };
  };
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
  isFromWhatsApp?: boolean;
}
export interface OrderForFinalization {
  id: string;
  shiftOrderNumber: number;
  deliveryInfo: DeliveryInfo;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN';
  orderStatus:
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'COMPLETED'
    | 'CANCELLED';
  total: string | number;
  orderItems: OrderItemForFinalization[];
  createdAt: string;
  updatedAt: string;
  scheduledAt?: string;
  tableId?: string;
  user?: {
    id: string;
    firstName?: string;
    lastName?: string;
  };
  table?: {
    id: string;
    number: string;
    area?: {
      name: string;
    };
  } | null;
  isFromWhatsApp?: boolean;
  preparationScreens?: string[];
  payments?: {
    id: string;
    amount: number;
    paymentMethod: string;
    paymentStatus: string;
    createdAt: string;
    updatedAt: string;
  }[];
  notes?: string;
  ticketImpressions?: {
    id: string;
    ticketType: string;
    impressionTime: string;
    user?: {
      id: string;
      firstName?: string;
      lastName?: string;
    };
    printer?: {
      id: string;
      name: string;
    };
  }[];
}
export interface OrderItemForFinalization {
  id: string;
  quantity: number;
  basePrice: string;
  finalPrice: string;
  preparationNotes?: string;
  preparationStatus?: string;
  product: {
    id: string;
    name: string;
    description?: string;
  };
  productVariant?: {
    id: string;
    name: string;
  } | null;
  modifiers: OrderItemModifierForFinalization[];
  selectedPizzaCustomizations?: any[];
}
export interface OrderItemModifierForFinalization {
  id: string;
  name: string;
  price: number | string;
}
export interface OrderSelectionState {
  selectedOrders: Set<string>;
  totalAmount: number;
}
export interface FinalizeOrdersPayload {
  orderIds: string[];
  paymentMethod?: string;
  notes?: string;
}
export type OrderFinalizationFilter = 'delivery' | 'take_away' | 'dine_in';

================
File: app/src/modules/restaurantConfig/screens/RestaurantConfigScreen.tsx
================
import React, { useState } from 'react';
import { Portal } from 'react-native-paper';
import {
  View,
  StyleSheet,
  useWindowDimensions,
  BackHandler,
  Pressable,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import {
  Text,
  Switch,
  TextInput,
  Button,
  ActivityIndicator,
  Dialog,
  Surface,
  Chip,
  Icon,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useRestaurantConfigQueries } from '../hooks/useRestaurantConfigQueries';
import {
  UpdateRestaurantConfigDto,
  CreateBusinessHoursDto,
} from '../types/restaurantConfig.types';
import BusinessHoursForm from '../components/BusinessHoursForm';
import TimeZoneSelector from '../components/TimeZoneSelector';
import { WebViewDeliveryCoverageMap } from '../components/WebViewDeliveryCoverageMap';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useNavigation } from '@react-navigation/native';
import { useFocusEffect } from '@react-navigation/native';
import { useRefreshOnFocus } from '@/app/hooks/useRefreshOnFocus';
type TabType = 'basic' | 'operation' | 'schedule';
const RestaurantConfigScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { width, height } = useWindowDimensions();
  const navigation = useNavigation();
  const styles = React.useMemo(
    () => createStyles(theme, responsive, width, height),
    [theme, responsive, width, height],
  );
  const { useGetConfig, useUpdateConfig } = useRestaurantConfigQueries();
  const { data: config, isLoading, error } = useGetConfig();
  const updateConfigMutation = useUpdateConfig();
  const updateDeliveryAreaMutation = useUpdateConfig({
    successMessage: 'Área de cobertura actualizada exitosamente',
  });
  const [activeTab, setActiveTab] = useState<TabType>('basic');
  const [pendingTab, setPendingTab] = useState<TabType | null>(null);
  const [formData, setFormData] = useState<UpdateRestaurantConfigDto>({});
  const [isEditing, setIsEditing] = useState(false);
  const [showDiscardDialog, setShowDiscardDialog] = useState(false);
  const [showDeliveryModal, setShowDeliveryModal] = useState(false);
  const [isEditingDelivery, setIsEditingDelivery] = useState(false);
  const [isNavigatingAway, setIsNavigatingAway] = useState(false);
  const [businessHoursModified, setBusinessHoursModified] = useState(false);
  const [originalDeliveryArea, setOriginalDeliveryArea] = useState<any>(null);
  const [showAreaValidationModal, setShowAreaValidationModal] = useState(false);
  const [showScheduleConflictModal, setShowScheduleConflictModal] =
    useState(false);
  useRefreshOnFocus([['restaurantConfig']]);
  const hasScheduleConflicts = React.useCallback(() => {
    if (!formData.businessHours) return false;
    for (let i = 0; i < formData.businessHours.length; i++) {
      const currentDay = formData.businessHours[i];
      if (currentDay.isClosed || !currentDay.openingTime) continue;
      const previousDayIndex = i === 0 ? 6 : i - 1;
      const previousDay = formData.businessHours.find(
        (h) => h.dayOfWeek === previousDayIndex,
      );
      if (
        !previousDay ||
        previousDay.isClosed ||
        !previousDay.closesNextDay ||
        !previousDay.closingTime
      ) {
        continue;
      }
      const [currentOpenHour, currentOpenMin] = currentDay.openingTime
        .split(':')
        .map(Number);
      const [prevCloseHour, prevCloseMin] = previousDay.closingTime
        .split(':')
        .map(Number);
      const currentOpenMinutes = currentOpenHour * 60 + currentOpenMin;
      const prevCloseMinutes = prevCloseHour * 60 + prevCloseMin;
      if (currentOpenMinutes <= prevCloseMinutes) {
        return true;
      }
    }
    return false;
  }, [formData.businessHours]);
  const hasChanges = React.useCallback(() => {
    if (!config) return false;
    const simpleFieldsChanged =
      formData.restaurantName !== config.restaurantName ||
      formData.phoneMain !== config.phoneMain ||
      formData.phoneSecondary !== config.phoneSecondary ||
      formData.address !== config.address ||
      formData.city !== config.city ||
      formData.state !== config.state ||
      formData.postalCode !== config.postalCode ||
      formData.country !== config.country ||
      formData.acceptingOrders !== config.acceptingOrders ||
      formData.estimatedPickupTime !== config.estimatedPickupTime ||
      formData.estimatedDeliveryTime !== config.estimatedDeliveryTime ||
      formData.estimatedDineInTime !== config.estimatedDineInTime ||
      formData.openingGracePeriod !== config.openingGracePeriod ||
      formData.closingGracePeriod !== config.closingGracePeriod ||
      formData.timeZone !== config.timeZone ||
      formData.scheduledOrdersLeadTime !== config.scheduledOrdersLeadTime ||
      formData.minimumOrderValueForDelivery !==
        config.minimumOrderValueForDelivery;
    const deliveryAreaChanged =
      JSON.stringify(formData.deliveryCoverageArea) !==
      JSON.stringify(config.deliveryCoverageArea);
    return simpleFieldsChanged || deliveryAreaChanged || businessHoursModified;
  }, [config, formData, businessHoursModified]);
  useFocusEffect(
    React.useCallback(() => {
      const unsubscribe = navigation.addListener('beforeRemove', (e) => {
        if (!isEditing || !hasChanges()) {
          return;
        }
        e.preventDefault();
        setIsNavigatingAway(true);
        setShowDiscardDialog(true);
      });
      return unsubscribe;
    }, [navigation, isEditing, hasChanges]),
  );
  useFocusEffect(
    React.useCallback(() => {
      const onBackPress = () => {
        if (isEditing && hasChanges()) {
          setIsNavigatingAway(true);
          setShowDiscardDialog(true);
          return true;
        }
        return false;
      };
      const subscription = BackHandler.addEventListener(
        'hardwareBackPress',
        onBackPress,
      );
      return () => subscription.remove();
    }, [isEditing, hasChanges]),
  );
  React.useEffect(() => {
    if (config && !isEditing) {
      const initialBusinessHours =
        config.businessHours && config.businessHours.length > 0
          ? config.businessHours.map((hour) => ({
              ...hour,
              openingTime: hour.openingTime
                ? hour.openingTime.substring(0, 5)
                : null,
              closingTime: hour.closingTime
                ? hour.closingTime.substring(0, 5)
                : null,
            }))
          : [0, 1, 2, 3, 4, 5, 6].map((dayOfWeek) => ({
              dayOfWeek,
              openingTime: '09:00',
              closingTime: '22:00',
              isClosed: false,
            }));
      setFormData({
        restaurantName: config.restaurantName,
        phoneMain: config.phoneMain,
        phoneSecondary: config.phoneSecondary,
        address: config.address,
        city: config.city,
        state: config.state,
        postalCode: config.postalCode,
        country: config.country,
        acceptingOrders: config.acceptingOrders,
        estimatedPickupTime: config.estimatedPickupTime,
        estimatedDeliveryTime: config.estimatedDeliveryTime,
        estimatedDineInTime: config.estimatedDineInTime,
        openingGracePeriod: config.openingGracePeriod,
        closingGracePeriod: config.closingGracePeriod,
        timeZone: config.timeZone || 'America/Mexico_City',
        scheduledOrdersLeadTime: config.scheduledOrdersLeadTime,
        deliveryCoverageArea: config.deliveryCoverageArea,
        minimumOrderValueForDelivery:
          typeof config.minimumOrderValueForDelivery === 'string'
            ? parseFloat(config.minimumOrderValueForDelivery)
            : config.minimumOrderValueForDelivery,
        businessHours: initialBusinessHours,
      });
    }
  }, [config, isEditing]);
  const handleSubmit = async () => {
    if (hasScheduleConflicts()) {
      setShowScheduleConflictModal(true);
      return;
    }
    try {
      const dataToSubmit = {
        ...formData,
        businessHours: formData.businessHours?.map((hour) => ({
          ...hour,
          openingTime: hour.openingTime
            ? hour.openingTime.substring(0, 5)
            : null,
          closingTime: hour.closingTime
            ? hour.closingTime.substring(0, 5)
            : null,
        })),
      };
      await updateConfigMutation.mutateAsync(dataToSubmit);
      setIsEditing(false);
      setBusinessHoursModified(false);
    } catch (error) {
    }
  };
  const handleSaveDeliveryArea = async () => {
    try {
      await updateDeliveryAreaMutation.mutateAsync({
        deliveryCoverageArea: formData.deliveryCoverageArea,
      });
      if (config) {
        setFormData((prev) => ({
          ...prev,
          deliveryCoverageArea: formData.deliveryCoverageArea,
        }));
      }
    } catch (error) {
    }
  };
  const handleCancel = () => {
    if (hasChanges()) {
      setShowDiscardDialog(true);
    } else {
      resetForm();
    }
  };
  const resetForm = () => {
    if (config) {
      const initialBusinessHours =
        config.businessHours && config.businessHours.length > 0
          ? config.businessHours.map((hour) => ({
              ...hour,
              openingTime: hour.openingTime
                ? hour.openingTime.substring(0, 5)
                : null,
              closingTime: hour.closingTime
                ? hour.closingTime.substring(0, 5)
                : null,
            }))
          : [0, 1, 2, 3, 4, 5, 6].map((dayOfWeek) => ({
              dayOfWeek,
              openingTime: '09:00',
              closingTime: '22:00',
              isClosed: false,
            }));
      setFormData({
        restaurantName: config.restaurantName,
        phoneMain: config.phoneMain,
        phoneSecondary: config.phoneSecondary,
        address: config.address,
        city: config.city,
        state: config.state,
        postalCode: config.postalCode,
        country: config.country,
        acceptingOrders: config.acceptingOrders,
        estimatedPickupTime: config.estimatedPickupTime,
        estimatedDeliveryTime: config.estimatedDeliveryTime,
        estimatedDineInTime: config.estimatedDineInTime,
        openingGracePeriod: config.openingGracePeriod,
        closingGracePeriod: config.closingGracePeriod,
        timeZone: config.timeZone || 'America/Mexico_City',
        scheduledOrdersLeadTime: config.scheduledOrdersLeadTime,
        deliveryCoverageArea: config.deliveryCoverageArea,
        minimumOrderValueForDelivery:
          typeof config.minimumOrderValueForDelivery === 'string'
            ? parseFloat(config.minimumOrderValueForDelivery)
            : config.minimumOrderValueForDelivery,
        businessHours: initialBusinessHours,
      });
    }
    setIsEditing(false);
    setBusinessHoursModified(false);
  };
  const confirmDiscard = () => {
    resetForm();
    setShowDiscardDialog(false);
    if (isNavigatingAway) {
      setIsNavigatingAway(false);
      navigation.goBack();
      return;
    }
    if (pendingTab) {
      setActiveTab(pendingTab);
      setPendingTab(null);
    }
  };
  const handleTabChange = (newTab: TabType) => {
    setActiveTab(newTab);
  };
  const renderBasicInfo = () => (
    <View style={styles.tabContent}>
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="store-outline"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Información del Restaurante</Text>
        </View>
        <View style={styles.sectionContent}>
          <TextInput
            label="Nombre del restaurante"
            value={formData.restaurantName || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, restaurantName: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
          />
          <TextInput
            label="Teléfono principal"
            value={formData.phoneMain || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, phoneMain: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            keyboardType="phone-pad"
            left={<TextInput.Icon icon="phone" />}
          />
          <TextInput
            label="Teléfono secundario"
            value={formData.phoneSecondary || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, phoneSecondary: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            keyboardType="phone-pad"
            left={<TextInput.Icon icon="cellphone" />}
          />
          <TextInput
            label="Dirección"
            value={formData.address || ''}
            onChangeText={(text) => setFormData({ ...formData, address: text })}
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            multiline
            numberOfLines={2}
            left={<TextInput.Icon icon="map-marker" />}
          />
          <View style={styles.row}>
            <TextInput
              label="Ciudad"
              value={formData.city || ''}
              onChangeText={(text) => setFormData({ ...formData, city: text })}
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
            <TextInput
              label="Estado"
              value={formData.state || ''}
              onChangeText={(text) => setFormData({ ...formData, state: text })}
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
          </View>
          <View style={styles.row}>
            <TextInput
              label="Código postal"
              value={formData.postalCode || ''}
              onChangeText={(text) =>
                setFormData({ ...formData, postalCode: text })
              }
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
              keyboardType="numeric"
            />
            <TextInput
              label="País"
              value={formData.country || ''}
              onChangeText={(text) =>
                setFormData({ ...formData, country: text })
              }
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
          </View>
          {/* Botón para área de cobertura */}
          <View style={styles.deliveryButtonContainer}>
            <Button
              mode="contained-tonal"
              onPress={() => setShowDeliveryModal(true)}
              icon="map-marker-radius"
              style={styles.deliveryButton}
              contentStyle={styles.deliveryButtonContent}
              labelStyle={styles.deliveryButtonLabel}
            >
              Área de Cobertura
            </Button>
            {formData.deliveryCoverageArea &&
            formData.deliveryCoverageArea.length > 0 ? (
              <Text style={styles.deliveryStatusText}>
                Área de cobertura definida
              </Text>
            ) : (
              <Text
                style={[
                  styles.deliveryStatusText,
                  styles.deliveryStatusWarning,
                ]}
              >
                Sin área de cobertura definida
              </Text>
            )}
          </View>
        </View>
      </Surface>
    </View>
  );
  const renderOperationConfig = () => (
    <View style={styles.tabContent}>
      {/* Service Status Card */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="store-check"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Estado del Servicio</Text>
        </View>
        <View style={styles.sectionContent}>
          <View style={styles.statusRow}>
            <View style={styles.statusInfo}>
              <Text style={styles.statusLabel}>Recepción de Órdenes</Text>
              <Text style={styles.statusDescription}>
                {formData.acceptingOrders
                  ? 'Las órdenes están siendo aceptadas'
                  : 'No se están aceptando órdenes nuevas'}
              </Text>
            </View>
            <Switch
              value={formData.acceptingOrders}
              onValueChange={(value) =>
                setFormData({ ...formData, acceptingOrders: value })
              }
              disabled={!isEditing}
              color={theme.colors.primary}
            />
          </View>
        </View>
      </Surface>
      {}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="clock-time-four"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Tiempos de Servicio</Text>
        </View>
        <View style={styles.sectionContent}>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="walk"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Para recoger en tienda"
              value={formData.estimatedPickupTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedPickupTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="moped"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Entrega a domicilio"
              value={formData.estimatedDeliveryTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedDeliveryTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="currency-usd"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Valor mínimo para delivery"
              value={formData.minimumOrderValueForDelivery?.toString() || ''}
              onChangeText={(text) => {
                const value = parseFloat(text);
                setFormData({
                  ...formData,
                  minimumOrderValueForDelivery: isNaN(value) ? 0 : value,
                });
              }}
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="$" />}
              outlineStyle={styles.inputOutline}
            />
          </View>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="silverware-fork-knife"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Para comer en el local"
              value={formData.estimatedDineInTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedDineInTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="timer"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Periodo de gracia al abrir"
              value={formData.openingGracePeriod?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  openingGracePeriod: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="timer-off-outline"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Periodo de gracia al cerrar"
              value={formData.closingGracePeriod?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  closingGracePeriod: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="calendar-clock"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Anticipación órdenes programadas"
              value={formData.scheduledOrdersLeadTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  scheduledOrdersLeadTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>
          <View style={styles.infoChip}>
            <Chip
              icon="information"
              mode="flat"
              style={styles.chip}
              textStyle={styles.chipText}
            >
              Los tiempos son estimados y pueden variar
            </Chip>
          </View>
        </View>
      </Surface>
      {/* Time Zone */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="earth"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Zona Horaria</Text>
        </View>
        <View style={styles.sectionContent}>
          <TimeZoneSelector
            value={formData.timeZone || 'America/Mexico_City'}
            onChange={(timezone) => {
              setFormData({ ...formData, timeZone: timezone });
            }}
            disabled={!isEditing}
          />
        </View>
      </Surface>
    </View>
  );
  const renderSchedule = () => (
    <View style={styles.tabContent}>
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="calendar-clock"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Horario de Operación</Text>
        </View>
        <View style={styles.sectionContent}>
          <BusinessHoursForm
            businessHours={formData.businessHours || []}
            isEditing={isEditing}
            onChange={(hours: CreateBusinessHoursDto[]) => {
              setFormData((prev) => ({ ...prev, businessHours: hours }));
              setBusinessHoursModified(true);
            }}
          />
        </View>
      </Surface>
    </View>
  );
  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }
  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>Error al cargar la configuración</Text>
      </View>
    );
  }
  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      {}
      <View style={styles.header}>
        <View style={styles.tabsContainer}>
          <Pressable
            style={[styles.tab, activeTab === 'basic' && styles.tabActive]}
            onPress={() => handleTabChange('basic')}
          >
            <Icon
              source="store"
              size={20}
              color={
                activeTab === 'basic'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'basic' && styles.tabTextActive,
              ]}
            >
              Información
            </Text>
          </Pressable>
          <Pressable
            style={[styles.tab, activeTab === 'operation' && styles.tabActive]}
            onPress={() => handleTabChange('operation')}
          >
            <Icon
              source="cog"
              size={20}
              color={
                activeTab === 'operation'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'operation' && styles.tabTextActive,
              ]}
            >
              Operación
            </Text>
          </Pressable>
          <Pressable
            style={[styles.tab, activeTab === 'schedule' && styles.tabActive]}
            onPress={() => handleTabChange('schedule')}
          >
            <Icon
              source="calendar"
              size={20}
              color={
                activeTab === 'schedule'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'schedule' && styles.tabTextActive,
              ]}
            >
              Horarios
            </Text>
          </Pressable>
        </View>
      </View>
      {}
      <KeyboardAvoidingView
        style={{ flex: 1 }}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
          keyboardShouldPersistTaps="handled"
        >
          {activeTab === 'basic' && renderBasicInfo()}
          {activeTab === 'operation' && renderOperationConfig()}
          {activeTab === 'schedule' && renderSchedule()}
        </ScrollView>
      </KeyboardAvoidingView>
      {}
      <View style={styles.actionContainer}>
        {!isEditing ? (
          <Button
            mode="contained"
            onPress={() => {
              setIsEditing(true);
              setBusinessHoursModified(false);
            }}
            style={[
              styles.editButton,
              { backgroundColor: theme.colors.tertiary },
            ]}
            contentStyle={styles.editButtonContent}
            labelStyle={styles.editButtonLabel}
            icon="pencil"
            textColor={theme.colors.onTertiary}
          >
            Editar Configuración
          </Button>
        ) : (
          <View style={styles.editActions}>
            <Button
              mode="outlined"
              onPress={handleCancel}
              style={styles.cancelButton}
              contentStyle={styles.buttonContent}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit}
              loading={updateConfigMutation.isPending}
              disabled={updateConfigMutation.isPending}
              style={styles.saveButton}
              contentStyle={styles.buttonContent}
              icon="check"
            >
              Guardar
            </Button>
          </View>
        )}
      </View>
      {}
      {config && (
        <Surface style={styles.infoCard} elevation={1}>
          <View style={styles.infoContent}>
            <MaterialCommunityIcons
              name="information-outline"
              size={20}
              color={theme.colors.onSurfaceVariant}
            />
            <View style={styles.infoTextContainer}>
              <Text style={styles.infoTitle}>Última actualización</Text>
              <Text style={styles.infoText}>
                {new Date(config.updatedAt).toLocaleString('es-MX', {
                  dateStyle: 'medium',
                  timeStyle: 'short',
                  timeZone: config.timeZone || 'America/Mexico_City',
                })}
              </Text>
            </View>
          </View>
        </Surface>
      )}
      <ConfirmationModal
        visible={showDiscardDialog}
        title="Descartar cambios"
        message="¿Estás seguro de que deseas descartar los cambios realizados?"
        onConfirm={confirmDiscard}
        onCancel={() => {
          setShowDiscardDialog(false);
          setIsNavigatingAway(false);
          setPendingTab(null);
        }}
        confirmText="Descartar"
        cancelText="Continuar editando"
        confirmButtonColor={theme.colors.error}
      />
      {}
      <Portal>
        <Dialog
          visible={showDeliveryModal}
          onDismiss={() => {
            if (!updateDeliveryAreaMutation.isPending) {
              if (isEditingDelivery) {
                setFormData({
                  ...formData,
                  deliveryCoverageArea: originalDeliveryArea,
                });
              }
              setShowDeliveryModal(false);
              setIsEditingDelivery(false);
            }
          }}
          style={styles.deliveryDialog}
        >
          <Dialog.Content style={styles.deliveryDialogContent}>
            <Surface style={styles.deliveryMapWrapper} elevation={1}>
              <View style={styles.deliveryMapContainer}>
                <WebViewDeliveryCoverageMap
                  key={`coverage-map-${isEditingDelivery}`}
                  initialPolygon={formData.deliveryCoverageArea}
                  isEditing={isEditingDelivery}
                  onChange={(polygon) =>
                    setFormData({ ...formData, deliveryCoverageArea: polygon })
                  }
                  restaurantLocation={{
                    latitude: 20.5425,
                    longitude: -102.7935,
                  }}
                />
              </View>
            </Surface>
          </Dialog.Content>
          <View style={styles.deliveryDialogActions}>
            <View style={styles.deliveryDialogButtonsContainer}>
              {!isEditingDelivery ? (
                <>
                  <Button
                    onPress={() => setShowDeliveryModal(false)}
                    mode="outlined"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.cancelButtonLabel}
                  >
                    Cerrar
                  </Button>
                  <Button
                    onPress={() => {
                      setOriginalDeliveryArea(formData.deliveryCoverageArea);
                      setIsEditingDelivery(true);
                    }}
                    icon="pencil"
                    mode="contained"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.deliveryButtonLabel}
                  >
                    Editar
                  </Button>
                </>
              ) : (
                <>
                  <Button
                    onPress={() => {
                      setFormData({
                        ...formData,
                        deliveryCoverageArea: originalDeliveryArea,
                      });
                      setIsEditingDelivery(false);
                    }}
                    mode="outlined"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.cancelButtonLabel}
                    disabled={updateDeliveryAreaMutation.isPending}
                  >
                    Cancelar
                  </Button>
                  <Button
                    onPress={async () => {
                      if (
                        !formData.deliveryCoverageArea ||
                        formData.deliveryCoverageArea.length < 3
                      ) {
                        setShowAreaValidationModal(true);
                        return;
                      }
                      setIsEditingDelivery(false);
                      await handleSaveDeliveryArea();
                      setShowDeliveryModal(false);
                    }}
                    mode="contained"
                    icon="check"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.deliveryButtonLabel}
                    loading={updateDeliveryAreaMutation.isPending}
                    disabled={updateDeliveryAreaMutation.isPending}
                  >
                    Guardar
                  </Button>
                </>
              )}
            </View>
          </View>
        </Dialog>
      </Portal>
      {}
      <Portal>
        <Dialog
          visible={showAreaValidationModal}
          onDismiss={() => setShowAreaValidationModal(false)}
          style={styles.validationDialog}
        >
          <View style={styles.validationIconContainer}>
            <Surface style={styles.validationIconWrapper} elevation={0}>
              <MaterialCommunityIcons
                name="map-marker-alert"
                size={36}
                color={theme.colors.error}
              />
            </Surface>
          </View>
          <Dialog.Title style={styles.validationTitle}>
            Área incompleta
          </Dialog.Title>
          <Dialog.Content>
            <Text style={styles.validationMessage}>
              Se requieren al menos 3 puntos para definir un área de cobertura
              válida.
            </Text>
            <Text style={styles.validationHint}>
              Haz clic en el mapa para agregar más puntos o usa el botón de
              dibujar.
            </Text>
          </Dialog.Content>
          <Dialog.Actions style={styles.validationActions}>
            <Button
              onPress={() => setShowAreaValidationModal(false)}
              mode="contained"
              style={styles.validationButton}
              contentStyle={styles.validationButtonContent}
              labelStyle={styles.validationButtonLabel}
            >
              Entendido
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
      {}
      <Portal>
        <Dialog
          visible={showScheduleConflictModal}
          onDismiss={() => setShowScheduleConflictModal(false)}
          style={styles.validationDialog}
        >
          <View style={styles.validationIconContainer}>
            <Surface style={styles.validationIconWrapper} elevation={0}>
              <MaterialCommunityIcons
                name="clock-alert"
                size={36}
                color={theme.colors.error}
              />
            </Surface>
          </View>
          <Dialog.Title style={styles.validationTitle}>
            Conflicto de horarios
          </Dialog.Title>
          <Dialog.Content>
            <Text style={styles.validationMessage}>
              Hay conflictos en los horarios de operación. Un día no puede abrir
              antes o al mismo tiempo que cierre el día anterior.
            </Text>
            <Text style={styles.validationHint}>
              Debe haber al menos 1 minuto de diferencia entre el cierre y la
              siguiente apertura. Revisa los horarios marcados con advertencia.
            </Text>
          </Dialog.Content>
          <Dialog.Actions style={styles.validationActions}>
            <Button
              onPress={() => setShowScheduleConflictModal(false)}
              mode="contained"
              style={styles.validationButton}
              contentStyle={styles.validationButtonContent}
              labelStyle={styles.validationButtonLabel}
            >
              Revisar horarios
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </SafeAreaView>
  );
};
const createStyles = (
  theme: AppTheme,
  responsive: any,
  width: number,
  height: number,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: responsive.spacing(theme.spacing.xl),
    },
    deliveryContent: {
      flex: 1,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.xl),
    },
    errorText: {
      fontSize: responsive.fontSize(16),
      color: theme.colors.error,
      textAlign: 'center',
    },
    header: {
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    tabsContainer: {
      flexDirection: 'row',
      height: responsive.scaleHeight(48),
    },
    tab: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.xs),
    },
    tabActive: {
      borderBottomWidth: 2,
      borderBottomColor: theme.colors.primary,
    },
    tabText: {
      fontSize: responsive.fontSize(14),
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    tabTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    tabContent: {
      padding: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.m),
    },
    section: {
      borderRadius: 16,
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surface,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.m),
    },
    sectionTitle: {
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginLeft: responsive.spacing(theme.spacing.s),
    },
    sectionContent: {
      gap: responsive.spacing(theme.spacing.m),
    },
    deliveryInfo: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
    input: {
      backgroundColor: theme.colors.surface,
    },
    inputOutline: {
      borderRadius: 12,
    },
    row: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.s),
    },
    halfInput: {
      flex: 1,
    },
    statusRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    statusInfo: {
      flex: 1,
      marginRight: responsive.spacing(theme.spacing.m),
    },
    statusLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs),
    },
    statusDescription: {
      fontSize: responsive.fontSize(14),
      color: theme.colors.onSurfaceVariant,
    },
    timeInputContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    timeIconWrapper: {
      width: responsive.scaleWidth(40),
      height: responsive.scaleWidth(40),
      borderRadius: responsive.scaleWidth(20),
      backgroundColor: theme.colors.surfaceVariant,
      justifyContent: 'center',
      alignItems: 'center',
    },
    timeInput: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    infoChip: {
      marginTop: responsive.spacing(theme.spacing.xs),
    },
    chip: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    chipText: {
      fontSize: responsive.fontSize(12),
    },
    deliveryInfo: {
      marginTop: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
    },
    actionContainer: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      marginTop: responsive.spacing(theme.spacing.l),
      alignItems: 'center',
    },
    editButton: {
      borderRadius: 12,
      elevation: 2,
      alignSelf: 'stretch',
    },
    editButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    editButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
    editActions: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.l),
      width: '100%',
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    cancelButton: {
      flex: 1,
      borderRadius: 12,
    },
    saveButton: {
      flex: 1,
      borderRadius: 12,
      elevation: 2,
    },
    buttonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    infoCard: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      marginTop: responsive.spacing(theme.spacing.m),
      borderRadius: 12,
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
    },
    infoContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    infoTextContainer: {
      flex: 1,
    },
    infoTitle: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
      opacity: 0.7,
    },
    infoText: {
      fontSize: responsive.fontSize(14),
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    deliveryContainer: {
      flex: 1,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    deliveryActions: {
      position: 'absolute',
      bottom: 16,
      right: 16,
    },
    deliveryFab: {
      position: 'absolute',
      bottom: 0,
      right: 0,
    },
    deliveryFabSmall: {
      position: 'absolute',
      right: 0,
    },
    mapSection: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
    deliveryButtonContainer: {
      marginTop: responsive.spacing(theme.spacing.l),
      alignItems: 'center',
    },
    deliveryButton: {
      borderRadius: 12,
      width: '100%',
    },
    deliveryButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    deliveryButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
    },
    deliveryStatusText: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.spacing(theme.spacing.xs),
      fontStyle: 'italic',
    },
    deliveryStatusWarning: {
      color: theme.colors.error,
    },
    deliveryDialog: {
      maxWidth: width * 0.95,
      width: width * 0.95,
      maxHeight: height * 0.9,
      alignSelf: 'center',
      borderRadius: 20,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 12,
    },
    deliveryDialogContent: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
    deliveryMapWrapper: {
      borderRadius: 12,
      padding: responsive.spacing(theme.spacing.xs),
      backgroundColor: theme.colors.surfaceVariant,
    },
    deliveryMapContainer: {
      height: height * 0.65,
      width: '100%',
      borderRadius: 8,
      overflow: 'hidden',
    },
    deliveryDialogActions: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.l),
    },
    deliveryDialogButtonsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.m),
    },
    deliveryDialogButton: {
      flex: 1,
      borderRadius: 12,
    },
    deliveryButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    deliveryButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
    cancelButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    validationDialog: {
      borderRadius: 24,
      backgroundColor: theme.colors.surface,
      maxWidth: 340,
      width: '85%',
      alignSelf: 'center',
      paddingVertical: 0,
    },
    validationIconContainer: {
      alignItems: 'center',
      marginTop: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
    validationIconWrapper: {
      width: responsive.scaleWidth(64),
      height: responsive.scaleWidth(64),
      borderRadius: responsive.scaleWidth(32),
      backgroundColor: theme.colors.errorContainer,
      justifyContent: 'center',
      alignItems: 'center',
    },
    validationTitle: {
      textAlign: 'center',
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    validationMessage: {
      textAlign: 'center',
      fontSize: responsive.fontSize(15),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.s),
      lineHeight: responsive.fontSize(21),
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    validationHint: {
      textAlign: 'center',
      fontSize: responsive.fontSize(13),
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      lineHeight: responsive.fontSize(18),
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    validationActions: {
      paddingBottom: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.xs),
    },
    validationButton: {
      borderRadius: 12,
      minWidth: 120,
    },
    validationButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    validationButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
  });
export default RestaurantConfigScreen;

================
File: app/src/app/services/apiClient.ts
================
import axios, {
  type AxiosError,
  type InternalAxiosRequestConfig,
  type AxiosResponse,
} from 'axios';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useAuthStore } from '../store/authStore';
import { ApiError } from '../lib/errors';
import axiosRetry from 'axios-retry';
import { discoveryService } from './discoveryService';
import { useSnackbarStore } from '../store/snackbarStore';
import { API_PATHS } from '../constants/apiPaths';
import { certificateValidator } from './certificateValidator';
const REFRESH_TOKEN_KEY = 'refresh_token';
let isRefreshing = false;
let failedQueue: Array<{
  resolve: (token: string) => void;
  reject: (error: Error) => void;
}> = [];
const processQueue = (error: Error | null, token: string | null = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token!);
    }
  });
  failedQueue = [];
};
async function refreshToken(baseURL: string): Promise<string> {
  try {
    const currentRefreshToken =
      await EncryptedStorage.getItem(REFRESH_TOKEN_KEY);
    if (!currentRefreshToken) {
      throw new Error('No refresh token available.');
    }
    const { data } = await axios.post<{ token: string; refreshToken?: string }>(
      `${baseURL}${API_PATHS.AUTH_REFRESH}`,
      {},
      { headers: { Authorization: `Bearer ${currentRefreshToken}` } },
    );
    const authStore = useAuthStore.getState();
    await authStore.setAccessToken(data.token);
    if (data.refreshToken && data.refreshToken !== currentRefreshToken) {
      await authStore.setRefreshToken(data.refreshToken);
    }
    return data.token;
  } catch (error: any) {
    if (error.response?.status === 401 || error.response?.status === 404) {
      await useAuthStore.getState().logout();
    }
    throw error;
  }
}
const apiClient = axios.create({
  headers: {
    'Cache-Control': 'no-cache',
    Accept: 'application/json',
    'Content-Type': 'application/json',
  },
  timeout: 5000,
});
axiosRetry(apiClient, {
  retries: 1,
  retryDelay: () => 500,
  retryCondition: (error: AxiosError) => {
    if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
      return false;
    }
    return (
      error.code === 'ENOTFOUND' ||
      error.code === 'ECONNREFUSED' ||
      error.code === 'ECONNRESET'
    );
  },
  shouldResetTimeout: false,
});
const initializationPromise = (async () => {
  try {
    const baseURL = await discoveryService.getApiUrl();
    if (!baseURL) {
      throw new Error('No se pudo obtener la URL del servidor');
    }
    certificateValidator.validateConnection(baseURL);
    apiClient.defaults.baseURL = baseURL;
    apiClient.defaults.httpsAgent =
      certificateValidator.getAxiosSecurityConfig().httpsAgent;
  } catch (error) {
    console.error('Error al inicializar apiClient:', error);
  }
})();
apiClient.interceptors.request.use(
  async (config: InternalAxiosRequestConfig) => {
    await initializationPromise;
    if (!config.baseURL) {
      throw new axios.Cancel('La URL del servidor no está configurada.');
    }
    const accessToken = useAuthStore.getState().accessToken;
    if (accessToken && config.url !== API_PATHS.AUTH_REFRESH) {
      config.headers['Authorization'] = `Bearer ${accessToken}`;
    }
    if (!config.timeout) {
      const timeouts = {
        get: 5000,
        post: config.url?.includes('/files/upload') ? 30000 : 5000,
        put: 5000,
        patch: 5000,
        delete: 5000,
      };
      config.timeout = timeouts[config.method as keyof typeof timeouts] || 5000;
    }
    return config;
  },
  (error: any) => Promise.reject(error),
);
apiClient.interceptors.response.use(
  (response: AxiosResponse) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & {
      _retry?: boolean;
    };
    if (!error.response) {
      let specificError: Error;
      const showSnackbar = useSnackbarStore.getState().showSnackbar;
      if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
        specificError = new Error('El servidor no responde');
        (specificError as any).code = 'SERVER_TIMEOUT';
      } else if (error.code === 'ECONNREFUSED') {
        specificError = new Error('El servidor está apagado o no accesible');
        (specificError as any).code = 'SERVER_DOWN';
      } else if (
        error.message === 'Network Error' ||
        error.code === 'ENETUNREACH'
      ) {
        specificError = new Error('No se pudo encontrar el servidor CloudBite');
        (specificError as any).code = 'SERVER_NOT_FOUND';
      } else {
        specificError = new Error('Error de conexión de red');
        (specificError as any).code = 'NETWORK_ERROR';
      }
      const method = originalRequest.method?.toLowerCase();
      let errorMessage = 'Sin conexión al servidor';
      if (method === 'post') {
        errorMessage = 'No se puede guardar sin conexión';
      } else if (method === 'put' || method === 'patch') {
        errorMessage = 'No se puede actualizar sin conexión';
      } else if (method === 'delete') {
        errorMessage = 'No se puede eliminar sin conexión';
      } else if (method === 'get') {
        errorMessage = 'No se pueden cargar los datos sin conexión';
      }
      setTimeout(() => {
        showSnackbar({
          message: errorMessage,
          type: 'error',
          duration: 5000,
        });
      }, 100);
      return Promise.reject(ApiError.fromAxiosError(error));
    }
    if (
      error.response?.status === 401 &&
      !originalRequest._retry &&
      originalRequest.url !== API_PATHS.AUTH_REFRESH
    ) {
      if (isRefreshing) {
        return new Promise((resolve, reject) => {
          failedQueue.push({
            resolve: (token) => {
              originalRequest.headers['Authorization'] = `Bearer ${token}`;
              resolve(apiClient(originalRequest));
            },
            reject: (err) => {
              reject(err);
            },
          });
        });
      }
      originalRequest._retry = true;
      isRefreshing = true;
      try {
        const baseURL = apiClient.defaults.baseURL!;
        const newAccessToken = await refreshToken(baseURL);
        processQueue(null, newAccessToken);
        originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;
        return apiClient(originalRequest);
      } catch (refreshError: any) {
        processQueue(refreshError, null);
        return Promise.reject(ApiError.fromRefreshError(refreshError));
      } finally {
        isRefreshing = false;
      }
    }
    return Promise.reject(ApiError.fromAxiosError(error));
  },
);
export const reinitializeApiClient = async (url?: string) => {
  const baseURL = url || (await discoveryService.getApiUrl());
  if (baseURL) {
    apiClient.defaults.baseURL = baseURL;
  }
};
export default apiClient;

================
File: app/src/modules/kitchen/components/OrderCard.tsx
================
import React, { useRef, useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Animated,
  Pressable,
  Vibration,
  Platform,
} from 'react-native';
import { Card, Text, Divider, Surface, IconButton } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import {
  KitchenOrder,
  OrderType,
  PreparationStatus,
  PreparationScreenStatus,
} from '../types/kitchen.types';
import { OrderItemRow } from './OrderItemRow';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Swipeable } from 'react-native-gesture-handler';
import { OrderHistoryModal } from '@/modules/shared/components/OrderHistoryModal';
import { useMarkItemPrepared } from '../hooks/useKitchenOrders';
interface OrderCardProps {
  order: KitchenOrder;
  onStartPreparation?: (orderId: string) => void;
  onCancelPreparation?: (orderId: string) => void;
  onCompletePreparation?: (orderId: string) => void;
  onSwipeStart?: () => void;
  onSwipeEnd?: () => void;
}
export const OrderCard: React.FC<OrderCardProps> = ({
  order,
  onStartPreparation,
  onCancelPreparation,
  onCompletePreparation,
  onSwipeStart,
  onSwipeEnd,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = createStyles(responsive, theme);
  const [isSwipeable, setIsSwipeable] = React.useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const swipeableRef = useRef<Swipeable>(null);
  const [isPressing, setIsPressing] = useState(false);
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const animatedValue = useRef(new Animated.Value(0)).current;
  const markItemPrepared = useMarkItemPrepared();
  const getOrderTypeColor = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return theme.colors.error;
      case OrderType.TAKE_AWAY:
        return '#00ACC1';
      case OrderType.DINE_IN:
        return theme.colors.primary;
      default:
        return theme.colors.surface;
    }
  };
  const getOrderTypeLabel = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return 'DOMICILIO';
      case OrderType.TAKE_AWAY:
        return 'PARA LLEVAR';
      case OrderType.DINE_IN:
        return 'MESA';
      default:
        return '';
    }
  };
  const getOrderTypeBackgroundColor = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return '#FFEBEE';
      case OrderType.TAKE_AWAY:
        return '#E0F2F1';
      case OrderType.DINE_IN:
        return '#E3F2FD';
      default:
        return theme.colors.surfaceVariant;
    }
  };
  const getOrderTypeTextColor = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return '#C62828';
      case OrderType.TAKE_AWAY:
        return '#00838F';
      case OrderType.DINE_IN:
        return '#1565C0';
      default:
        return theme.colors.onSurfaceVariant;
    }
  };
  const getScreenStatusColor = (status: PreparationScreenStatus) => {
    switch (status) {
      case PreparationScreenStatus.READY:
        return theme.colors.success;
      case PreparationScreenStatus.IN_PREPARATION:
        return '#FF6B35';
      default:
        return '#9C27B0';
    }
  };
  const getOrderTypeIcon = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return 'moped';
      case OrderType.TAKE_AWAY:
        return 'shopping-outline';
      case OrderType.DINE_IN:
        return 'silverware-fork-knife';
      default:
        return 'help-circle-outline';
    }
  };
  const getOrderPreparationStatus = () => {
    if (!order.items || order.items.length === 0) {
      return {
        label: 'Sin items',
        color: '#E0E0E0',
        textColor: '#424242',
        borderColor: '#BDBDBD',
      };
    }
    const myItems = order.items.filter((item) => item.belongsToMyScreen);
    if (myItems.length === 0) {
      return {
        label: 'Sin items asignados',
        color: '#E0E0E0',
        textColor: '#424242',
        borderColor: '#BDBDBD',
      };
    }
    switch (order.myScreenStatus) {
      case PreparationScreenStatus.READY:
        return {
          label: 'Lista',
          color: '#4CAF50',
          textColor: '#FFFFFF',
          borderColor: null,
        };
      case PreparationScreenStatus.IN_PREPARATION:
        return {
          label: 'En preparación',
          color: '#FF6B35',
          textColor: '#FFFFFF',
          borderColor: null,
        };
      case PreparationScreenStatus.PENDING:
      default:
        return {
          label: 'Pendiente',
          color: '#9C27B0',
          textColor: '#FFFFFF',
          borderColor: null,
        };
    }
  };
  const hasOrderDetails = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return !!order.deliveryAddress;
      case OrderType.TAKE_AWAY:
        return !!order.receiptName;
      case OrderType.DINE_IN:
        return !!(order.areaName || order.tableName);
      default:
        return false;
    }
  };
  const orderStatus = getOrderPreparationStatus();
  const isOrderInPreparation =
    order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION;
  const handleToggleItemPrepared = (itemId: string, currentStatus: boolean) => {
    markItemPrepared.mutate({
      itemId,
      isPrepared: !currentStatus,
    });
  };
  const getSwipeActions = () => {
    const rightAction = (() => {
      if (order.myScreenStatus === PreparationScreenStatus.PENDING) {
        return {
          type: 'start',
          color: '#FF6B35',
          textColor: '#FFFFFF',
          icon: 'chef-hat',
          text: 'En Preparación',
        };
      }
      return null;
    })();
    const leftAction = (() => {
      if (
        order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION ||
        order.myScreenStatus === PreparationScreenStatus.READY
      ) {
        return {
          type: 'cancel',
          color: '#9C27B0',
          textColor: '#FFFFFF',
          icon: 'arrow-left',
          text: 'Regresar',
        };
      }
      return null;
    })();
    return { rightAction, leftAction };
  };
  const swipeActions = getSwipeActions();
  React.useEffect(() => {
    setIsSwipeable(!!swipeActions.rightAction || !!swipeActions.leftAction);
  }, [swipeActions.rightAction, swipeActions.leftAction]);
  const renderRightActions = () => {
    if (!swipeActions.rightAction) return null;
    return (
      <View
        style={[
          styles.swipeAction,
          { backgroundColor: swipeActions.rightAction.color },
        ]}
      >
        <Icon
          name={swipeActions.rightAction.icon}
          size={24}
          color={swipeActions.rightAction.textColor}
        />
        <Text
          style={[
            styles.swipeText,
            { color: swipeActions.rightAction.textColor },
          ]}
        >
          {swipeActions.rightAction.text}
        </Text>
      </View>
    );
  };
  const renderLeftActions = () => {
    if (!swipeActions.leftAction) return null;
    return (
      <View
        style={[
          styles.swipeAction,
          { backgroundColor: swipeActions.leftAction.color },
        ]}
      >
        <Text
          style={[
            styles.swipeText,
            { color: swipeActions.leftAction.textColor },
          ]}
        >
          {swipeActions.leftAction.text}
        </Text>
        <Icon
          name={swipeActions.leftAction.icon}
          size={24}
          color={swipeActions.leftAction.textColor}
        />
      </View>
    );
  };
  const canMarkAsReady = () => {
    return (
      order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION &&
      onCompletePreparation
    );
  };
  const canReturnToInProgress = () => {
    return (
      order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION &&
      onCancelPreparation
    );
  };
  const handlePressIn = () => {
    const canComplete = canMarkAsReady();
    const canReturn = canReturnToInProgress();
    if (!canComplete && !canReturn) return;
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      if ((longPressTimer.current as any).interval) {
        clearInterval((longPressTimer.current as any).interval);
      }
      longPressTimer.current = null;
    }
    animatedValue.stopAnimation();
    animatedValue.setValue(0);
    Vibration.vibrate(10);
    setIsPressing(true);
    Animated.timing(animatedValue, {
      toValue: 1,
      duration: 2000,
      useNativeDriver: false,
    }).start();
    longPressTimer.current = setTimeout(() => {
      Vibration.vibrate([0, 50, 100, 50]);
      if (canComplete && onCompletePreparation) {
        onCompletePreparation(order.id);
      } else if (canReturn && onCancelPreparation) {
        onCancelPreparation(order.id);
      }
      setIsPressing(false);
      Animated.timing(animatedValue, {
        toValue: 0,
        duration: 200,
        useNativeDriver: false,
      }).start();
    }, 2000);
  };
  const handlePressOut = () => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }
    setIsPressing(false);
    animatedValue.stopAnimation();
    animatedValue.setValue(0);
  };
  useEffect(() => {
    return () => {
      if (longPressTimer.current) {
        clearTimeout(longPressTimer.current);
      }
    };
  }, []);
  const handleRightSwipeComplete = () => {
    if (!swipeActions.rightAction) return;
    switch (swipeActions.rightAction.type) {
      case 'start':
        if (onStartPreparation) onStartPreparation(order.id);
        break;
    }
    swipeableRef.current?.close();
  };
  const handleLeftSwipeComplete = () => {
    if (!swipeActions.leftAction) return;
    if (swipeActions.leftAction.type === 'cancel') {
      if (onCancelPreparation) onCancelPreparation(order.id);
    }
    swipeableRef.current?.close();
  };
  return (
    <Surface
      style={[styles.card, { backgroundColor: theme.colors.surface }]}
      elevation={1}
    >
      <View style={styles.cardContent}>
        {}
        {isSwipeable ? (
          <Swipeable
            ref={swipeableRef}
            renderRightActions={renderRightActions}
            renderLeftActions={renderLeftActions}
            onSwipeableWillOpen={() => onSwipeStart && onSwipeStart()}
            onSwipeableWillClose={() => onSwipeEnd && onSwipeEnd()}
            onSwipeableRightOpen={handleRightSwipeComplete}
            onSwipeableLeftOpen={handleLeftSwipeComplete}
            overshootRight={false}
            overshootLeft={false}
            friction={1.2}
            rightThreshold={50}
            leftThreshold={50}
            activationDistance={15}
          >
            <Pressable
              onPressIn={handlePressIn}
              onPressOut={handlePressOut}
              delayLongPress={0}
            >
              <View
                style={[
                  styles.header,
                  styles.headerSwipeable,
                  { backgroundColor: getOrderTypeColor() },
                ]}
              >
                <View style={styles.headerLeft}>
                  <Text style={[styles.orderNumber, styles.headerText]}>
                    #{order.shiftOrderNumber}
                  </Text>
                  {hasOrderDetails() && (
                    <Text
                      style={[styles.headerDetails, styles.headerText]}
                      numberOfLines={2}
                    >
                      {(() => {
                        switch (order.orderType) {
                          case OrderType.DELIVERY:
                            return `📍 ${order.deliveryAddress}${order.deliveryPhone ? `\n📱 ${order.deliveryPhone}` : ''}`;
                          case OrderType.TAKE_AWAY:
                            return `👤 ${order.receiptName}${order.customerPhone ? `\n📱 ${order.customerPhone}` : ''}`;
                          case OrderType.DINE_IN:
                            return `🪑 ${order.areaName} - ${order.tableName}`;
                          default:
                            return '';
                        }
                      })()}
                    </Text>
                  )}
                  {/* Badge de WhatsApp */}
                  {order.isFromWhatsApp && (
                    <View style={styles.whatsappBadgeContainer}>
                      <View style={styles.whatsappBadge}>
                        <Icon
                          source="whatsapp"
                          size={12}
                          color={theme.colors.surface}
                        />
                      </View>
                    </View>
                  )}
                </View>
                <View style={[styles.headerRight, styles.headerRightSwipeable]}>
                  <View style={[styles.typeChip, styles.typeChipSwipeable]}>
                    <Icon
                      name={getOrderTypeIcon()}
                      size={responsive.isWeb ? 18 : 14}
                      color={theme.colors.surface}
                      style={styles.typeChipIcon}
                    />
                    <Text style={[styles.typeChipText, styles.headerText]}>
                      {getOrderTypeLabel()}
                    </Text>
                  </View>
                  <View
                    style={[
                      styles.statusChip,
                      styles.statusChipSwipeable,
                      {
                        backgroundColor: orderStatus.color,
                        borderWidth:
                          orderStatus.label === 'En progreso' ? 1 : 0,
                        borderColor: theme.colors.outline,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.statusChipText,
                        {
                          color:
                            orderStatus.label === 'En progreso'
                              ? theme.colors.onSurface
                              : theme.colors.surface,
                        },
                      ]}
                    >
                      {orderStatus.label}
                    </Text>
                  </View>
                  <Text style={[styles.headerTime, styles.headerText]}>
                    {format(new Date(order.createdAt), 'HH:mm', { locale: es })}
                  </Text>
                </View>
              </View>
              {}
              {isPressing && (canMarkAsReady() || canReturnToInProgress()) && (
                <View style={styles.progressBarContainer}>
                  <Animated.View
                    style={[
                      styles.progressBar,
                      {
                        width: animatedValue.interpolate({
                          inputRange: [0, 1],
                          outputRange: ['0%', '100%'],
                        }),
                        backgroundColor: canMarkAsReady()
                          ? theme.colors.success
                          : '#FF6B35',
                      },
                    ]}
                  />
                </View>
              )}
            </Pressable>
          </Swipeable>
        ) : (
          <View
            style={[
              styles.header,
              styles.headerSwipeable,
              { backgroundColor: getOrderTypeColor() },
            ]}
          >
            <View style={styles.headerLeft}>
              <Text style={[styles.orderNumber, styles.headerText]}>
                #{order.shiftOrderNumber}
              </Text>
              {hasOrderDetails() && (
                <Text
                  style={[styles.headerDetails, styles.headerText]}
                  numberOfLines={2}
                >
                  {(() => {
                    switch (order.orderType) {
                      case OrderType.DELIVERY:
                        return `📍 ${order.deliveryAddress}${order.deliveryPhone ? `\n📱 ${order.deliveryPhone}` : ''}`;
                      case OrderType.TAKE_AWAY:
                        return `👤 ${order.receiptName}${order.customerPhone ? `\n📱 ${order.customerPhone}` : ''}`;
                      case OrderType.DINE_IN:
                        return `🪑 ${order.areaName} - ${order.tableName}`;
                      default:
                        return '';
                    }
                  })()}
                </Text>
              )}
            </View>
            <View style={[styles.headerRight, styles.headerRightNormal]}>
              <View
                style={[
                  styles.typeChip,
                  styles.typeChipNormal,
                  { backgroundColor: getOrderTypeBackgroundColor() },
                ]}
              >
                <Icon
                  name={getOrderTypeIcon()}
                  size={responsive.isTablet ? 13 : 14}
                  color={getOrderTypeTextColor()}
                  style={styles.typeChipIcon}
                />
                <Text
                  style={[
                    styles.typeChipText,
                    { color: getOrderTypeTextColor() },
                  ]}
                >
                  {getOrderTypeLabel()}
                </Text>
              </View>
              <View
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: orderStatus.color,
                    borderWidth: orderStatus.borderColor ? 1 : 0,
                    borderColor: orderStatus.borderColor || 'transparent',
                    marginBottom: 2,
                  },
                ]}
              >
                <Text
                  style={[
                    styles.statusChipText,
                    { color: orderStatus.textColor },
                  ]}
                >
                  {orderStatus.label}
                </Text>
              </View>
              <Text
                style={[styles.headerTime, { color: theme.colors.surface }]}
              >
                {format(new Date(order.createdAt), 'HH:mm', { locale: es })}
              </Text>
            </View>
          </View>
        )}
        {}
        {order.orderNotes && (
          <>
            <View
              style={[
                styles.details,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <Text
                variant="bodyMedium"
                style={[styles.notes, { color: theme.colors.onErrorContainer }]}
              >
                📝 {order.orderNotes}
              </Text>
            </View>
            <Divider style={styles.divider} />
          </>
        )}
        {}
        {order.screenStatuses && order.screenStatuses.length > 1 && (
          <>
            <View
              style={[
                styles.screenStatusContainer,
                {
                  backgroundColor: theme.colors.surfaceVariant,
                  paddingVertical: 8,
                  paddingHorizontal: 8,
                },
              ]}
            >
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                <View style={[styles.screenStatusList, { gap: 8 }]}>
                  {order.screenStatuses.map((screenStatus) => (
                    <View
                      key={screenStatus.screenId}
                      style={[
                        styles.screenStatusItem,
                        {
                          backgroundColor: (() => {
                            switch (screenStatus.status) {
                              case PreparationScreenStatus.READY:
                                return '#4CAF50';
                              case PreparationScreenStatus.IN_PREPARATION:
                                return '#FF6B35';
                              default:
                                return '#9C27B0';
                            }
                          })(),
                        },
                      ]}
                    >
                      <Text style={styles.screenStatusText}>
                        {screenStatus.screenName}
                      </Text>
                    </View>
                  ))}
                </View>
              </ScrollView>
            </View>
            <Divider style={styles.divider} />
          </>
        )}
        {}
        <View style={styles.itemsWrapper}>
          {order.items && order.items.length > 0 ? (
            <ScrollView
              style={styles.itemsContainer}
              showsVerticalScrollIndicator={true}
              nestedScrollEnabled={true}
            >
              {(() => {
                const myScreenItems = order.items
                  .map((item, originalIndex) => ({ item, originalIndex }))
                  .filter(({ item }) => item.belongsToMyScreen);
                const otherScreenItems = order.items
                  .map((item, originalIndex) => ({ item, originalIndex }))
                  .filter(({ item }) => !item.belongsToMyScreen);
                const sortedMyScreenItems = myScreenItems.sort((a, b) => {
                  const aIsPrepared =
                    a.item.preparationStatus === PreparationStatus.READY;
                  const bIsPrepared =
                    b.item.preparationStatus === PreparationStatus.READY;
                  if (aIsPrepared === bIsPrepared) {
                    return a.originalIndex - b.originalIndex;
                  }
                  return a.originalIndex - b.originalIndex;
                });
                const sortedOtherScreenItems = otherScreenItems;
                return [...sortedMyScreenItems, ...sortedOtherScreenItems];
              })().map(({ item }, index) => (
                <OrderItemRow
                  key={`${item.id}-${index}`}
                  item={item}
                  onTogglePrepared={handleToggleItemPrepared}
                  isOrderInPreparation={isOrderInPreparation}
                />
              ))}
            </ScrollView>
          ) : (
            <View style={styles.emptyItemsContainer}>
              <Text variant="bodyLarge" style={styles.emptyItemsText}>
                No hay productos para mostrar
              </Text>
            </View>
          )}
        </View>
        {}
        <View style={styles.floatingButtonContainer}>
          <IconButton
            icon="file-document-multiple-outline"
            size={responsive.isWeb ? 32 : 28}
            iconColor={theme.colors.surface}
            style={[
              styles.floatingButton,
              {
                backgroundColor: theme.colors.primary,
                width: responsive.isWeb ? 56 : 48,
                height: responsive.isWeb ? 56 : 48,
                borderRadius: responsive.isWeb ? 28 : 24,
              },
            ]}
            onPress={() => setShowHistory(true)}
          />
        </View>
      </View>
      {}
      <OrderHistoryModal
        visible={showHistory}
        onDismiss={() => setShowHistory(false)}
        orderId={order.id}
        orderNumber={order.shiftOrderNumber}
        orderData={order}
      />
    </Surface>
  );
};
const createStyles = (responsive: any, theme: any) =>
  StyleSheet.create({
    card: {
      width: '100%',
      height: '100%',
      maxHeight:
        responsive.height -
        responsive.dimensions.headerHeight -
        responsive.spacing.s,
      borderRadius: theme.roundness / 2,
      borderWidth: 0.5,
      borderColor: 'rgba(0,0,0,0.05)',
    },
    cardContent: {
      flex: 1,
      display: 'flex',
      flexDirection: 'column',
      position: 'relative',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.l
        : responsive.spacing.m,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.s,
      borderTopLeftRadius: theme.roundness,
      borderTopRightRadius: theme.roundness,
      minHeight: responsive.isWeb
        ? 80
        : responsive.getResponsiveDimension(50, 60),
    },
    headerLeft: {
      flex: 1,
      flexDirection: 'column',
      gap: responsive.spacing.xxxs,
    },
    headerTopRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing.xs,
    },
    headerDetails: {
      fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 12 : 13,
      lineHeight: responsive.isWeb ? 22 : responsive.isTablet ? 16 : 18,
      opacity: 0.95,
      marginTop: responsive.spacing.xxxs,
      fontWeight: '500',
    },
    headerRight: {
      alignItems: 'flex-end',
      gap: responsive.spacing.xs,
      marginLeft: responsive.spacing.xs,
    },
    orderNumber: {
      fontWeight: 'bold',
      fontSize: responsive.isWeb ? 24 : responsive.isTablet ? 18 : 20,
      lineHeight: responsive.isWeb ? 32 : responsive.isTablet ? 24 : 28,
    },
    typeChip: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.s,
      paddingVertical: responsive.isWeb ? 6 : 4,
      minHeight: responsive.isWeb ? 36 : 28,
      borderRadius: theme.roundness / 2,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      alignSelf: 'flex-end',
      marginBottom: responsive.spacing.xxxs,
    },
    typeChipText: {
      fontSize: responsive.isWeb ? 14 : responsive.isTablet ? 11 : 12,
      fontWeight: '700',
      letterSpacing: 0.4,
      textAlign: 'center',
      textAlignVertical: 'center',
      lineHeight: responsive.isTablet ? 16 : 18,
      includeFontPadding: false,
    },
    headerTime: {
      fontWeight: '500',
      fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 12 : 13,
    },
    statusChip: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.xs,
      paddingVertical: responsive.isWeb ? 6 : 4,
      minHeight: responsive.isWeb ? 36 : 28,
      borderRadius: theme.roundness / 2,
      alignItems: 'center',
      justifyContent: 'center',
      alignSelf: 'flex-end',
      marginBottom: responsive.spacing.xxxs,
    },
    statusChipText: {
      fontSize: responsive.isWeb ? 15 : responsive.isTablet ? 12 : 13,
      fontWeight: '600',
      letterSpacing: 0.3,
      textAlign: 'center',
      textAlignVertical: 'center',
      lineHeight: responsive.isWeb ? 22 : responsive.isTablet ? 18 : 20,
      includeFontPadding: false,
    },
    details: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.s,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.s
        : responsive.spacing.xs,
    },
    detailText: {
      marginBottom: 0,
      fontSize: responsive.isWeb ? 15 : responsive.isTablet ? 11 : 12,
      lineHeight: responsive.isWeb ? 20 : responsive.isTablet ? 16 : 14,
    },
    notesContainer: {
      marginTop: responsive.spacing.xxs,
      padding: responsive.spacing.xxs,
      borderRadius: theme.roundness / 2,
    },
    notes: {
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 11 : 12,
      lineHeight: responsive.isTablet ? 16 : 14,
    },
    itemsWrapper: {
      flex: 1,
      minHeight: responsive.isTablet ? 100 : 60,
    },
    itemsContainer: {
      flex: 1,
    },
    emptyItemsContainer: {
      padding: responsive.spacing.s,
      alignItems: 'center',
      justifyContent: 'center',
      minHeight: responsive.getResponsiveDimension(60, 80),
    },
    swipeAction: {
      width: 120,
      height: '100%',
      justifyContent: 'center',
      alignItems: 'center',
      flexDirection: 'row',
      gap: responsive.spacing.xs,
      paddingHorizontal: responsive.spacing.s,
    },
    swipeText: {
      fontWeight: 'bold',
      fontSize: responsive.fontSize.s,
    },
    screenStatusContainer: {
      paddingVertical: responsive.spacing.s,
      paddingHorizontal: responsive.spacing.s,
      paddingRight: responsive.spacing.m,
    },
    screenStatusList: {
      flexDirection: 'row',
      gap: responsive.spacing.s,
      paddingHorizontal: responsive.spacing.xs,
    },
    screenStatusItem: {
      paddingHorizontal: responsive.spacing.s,
      paddingVertical: responsive.spacing.xs,
      borderRadius: theme.roundness / 2,
      minHeight: 24,
      justifyContent: 'center',
    },
    screenStatusText: {
      fontSize: responsive.fontSize.xs,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    whatsappBadgeContainer: {
      marginTop: 4,
      alignItems: 'flex-start',
    },
    whatsappBadge: {
      width: 24,
      height: 24,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
      elevation: 2,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.2,
      shadowRadius: 2,
      backgroundColor: '#25D366',
    },
    headerText: {
      color: theme.colors.surface,
    },
    headerSwipeable: {
      paddingHorizontal: responsive.spacing.s,
    },
    headerRightSwipeable: {
      marginLeft: responsive.spacing.xs,
    },
    headerRightNormal: {
      marginLeft: responsive.spacing.m,
    },
    typeChipSwipeable: {
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      marginTop: 2,
      marginBottom: 3,
    },
    typeChipNormal: {
      marginTop: 2,
      marginBottom: 3,
    },
    typeChipIcon: {
      marginRight: 4,
    },
    statusChipSwipeable: {
      marginBottom: 2,
    },
    statusChipNormal: {
      marginBottom: 2,
    },
    progressBarContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      height: 20,
      backgroundColor: 'rgba(0, 0, 0, 0.2)',
      overflow: 'hidden',
    },
    progressBar: {
      height: '100%',
    },
    notesContainer: {
      backgroundColor: theme.colors.errorContainer,
    },
    notesText: {
      color: theme.colors.onErrorContainer,
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 0.5,
    },
    screenStatusContainerStyle: {
      backgroundColor: theme.colors.surfaceVariant,
      paddingVertical: responsive.spacing.s,
      paddingHorizontal: responsive.spacing.s,
    },
    emptyItemsText: {
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
    },
    floatingButtonContainer: {
      position: 'absolute',
      bottom: 10,
      right: 10,
      width: 48,
      height: 48,
    },
    floatingButton: {
      elevation: 6,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 3 },
      shadowOpacity: 0.3,
      shadowRadius: 4.65,
      margin: 0,
      opacity: 0.7,
    },
  });

================
File: app/src/modules/orders/screens/CreateOrderScreen.tsx
================
import React, {
  useState,
  useMemo,
  useRef,
  useCallback,
  useEffect,
} from 'react';
import { StyleSheet, View, FlatList } from 'react-native';
import {
  Text,
  Portal,
  ActivityIndicator,
  Card,
  Title,
  Appbar,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation } from '@react-navigation/native';
import { useGetOrderMenu } from '../hooks/useMenuQueries';
import { useCreateOrderMutation } from '@/modules/orders/hooks/useOrdersQueries';
import {
  useCartStore,
  useIsCartEmpty,
  useCartItemsCount,
  useClearAll,
  CartItem,
  CartItemModifier,
} from '../stores/useCartStore';
import { useOrderFormStore } from '../stores/useOrderFormStore';
import { Product, Category, SubCategory } from '../types/orders.types';
import { AutoImage } from '@/app/components/common/AutoImage';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import OrderCartDetail from '../components/OrderCartDetail';
import ProductCustomizationModal from '../components/ProductCustomizationModal';
import SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';
import CartButton from '../components/CartButton';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { AudioRecorderWidget } from '@/components/AudioRecorderWidget';
import { AudioOrderModal } from '@/components/AudioOrderModal';
import {
  audioOrderService,
  type AIOrderItem,
} from '@/services/audioOrderService';
import { useAuthStore } from '@/app/store/authStore';
import { canOpenShift } from '@/app/utils/roleUtils';
import { useGlobalShift } from '@/app/hooks/useGlobalShift';
import { useAppTheme } from '@/app/styles/theme';
import type { OrderDetailsForBackend } from '../components/OrderCartDetail';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import { useResponsive } from '@/app/hooks/useResponsive';
interface CartButtonHandle {
  animate: () => void;
}
const CreateOrderScreen = () => {
  const theme = useAppTheme();
  const { colors, fonts } = theme;
  const responsive = useResponsive();
  const navigation = useNavigation();
  const {
    addItem: originalAddItem,
    updateItem,
    isCartVisible,
    showCart,
    hideCart,
  } = useCartStore();
  const isCartEmpty = useIsCartEmpty();
  const totalItemsCount = useCartItemsCount();
  const clearAll = useClearAll();
  const { setOrderType, setDeliveryInfo } = useOrderFormStore();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const user = useAuthStore((state) => state.user);
  const { data: shift, isLoading: shiftLoading } = useGlobalShift();
  const userCanOpenShift = canOpenShift(user);
  const createOrderMutation = useCreateOrderMutation();
  const cartButtonRef = useRef<CartButtonHandle>(null);
  const [navigationLevel, setNavigationLevel] = useState<
    'categories' | 'subcategories' | 'products'
  >('categories');
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null,
  );
  const [selectedSubcategoryId, setSelectedSubcategoryId] = useState<
    string | null
  >(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [showExitConfirmationModal, setShowExitConfirmationModal] =
    useState(false);
  const [pendingNavigationAction, setPendingNavigationAction] = useState<
    (() => void) | null
  >(null);
  const [isProcessingOrder, setIsProcessingOrder] = useState(false);
  const isProcessingOrderRef = useRef(false);
  const [selectedProductForDescription, setSelectedProductForDescription] =
    useState<Product | null>(null);
  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =
    useState(false);
  const [showAudioModal, setShowAudioModal] = useState(false);
  const [audioOrderData, setAudioOrderData] = useState<any>(null);
  const [isProcessingAudio, setIsProcessingAudio] = useState(false);
  const [audioError, setAudioError] = useState<string | undefined>();
  const { data: menu, isLoading } = useGetOrderMenu();
  const numColumns = useMemo(() => {
    if (responsive.width >= 600) {
      if (responsive.width >= 1200) return 6;
      if (responsive.width >= 900) return 5;
      if (responsive.width >= 768) return 4;
      return 3;
    }
    if (responsive.width >= 480) return 3;
    if (responsive.width >= 360) return 2;
    return 2;
  }, [responsive.width]);
  const itemWidth = useMemo(() => {
    const padding = responsive.spacing(theme.spacing.m);
    const totalPadding = padding * 2;
    const gap = responsive.spacing(8);
    const totalGaps = gap * (numColumns - 1);
    const availableWidth = responsive.width - totalPadding - totalGaps;
    return Math.floor(availableWidth / numColumns);
  }, [responsive.width, numColumns, theme.spacing.m, responsive]);
  const handleCategorySelect = useCallback((categoryId: string) => {
    setSelectedCategoryId(categoryId);
    setSelectedSubcategoryId(null);
    setNavigationLevel('subcategories');
  }, []);
  const handleSubCategorySelect = useCallback((subcategoryId: string) => {
    setSelectedSubcategoryId(subcategoryId);
    setNavigationLevel('products');
  }, []);
  const productNeedsCustomization = useCallback((product: Product): boolean => {
    if (!product) return false;
    const hasVariants =
      product.hasVariants &&
      product.variants &&
      Array.isArray(product.variants) &&
      product.variants.length > 0;
    const hasModifiers =
      product.modifierGroups &&
      Array.isArray(product.modifierGroups) &&
      product.modifierGroups.length > 0;
    return hasVariants || hasModifiers;
  }, []);
  const handleProductSelect = useCallback(
    (product: Product) => {
      if (productNeedsCustomization(product)) {
        setSelectedProduct(product);
      } else {
        handleAddItem(product, 1);
      }
    },
    [handleAddItem],
  );
  const handleCloseProductModal = useCallback(() => {
    setSelectedProduct(null);
    setEditingItem(null);
    if (editingItem && !isCartEmpty) {
      showCart();
    }
  }, [editingItem, isCartEmpty, showCart]);
  const handleEditItem = useCallback(
    (item: CartItem) => {
      if (!menu || !Array.isArray(menu)) {
        showSnackbar({
          message:
            'El menú aún se está cargando. Por favor, intenta nuevamente.',
          type: 'info',
        });
        return;
      }
      let product: Product | undefined;
      for (const category of menu) {
        if (category.subcategories && Array.isArray(category.subcategories)) {
          for (const subcategory of category.subcategories) {
            if (subcategory.products && Array.isArray(subcategory.products)) {
              product = subcategory.products.find(
                (p) => p.id === item.productId,
              );
              if (product) break;
            }
          }
        }
        if (product) break;
      }
      if (product) {
        setEditingItem(item);
        setSelectedProduct(product);
        hideCart();
      } else {
        showSnackbar({
          message:
            'No se pudo encontrar el producto. Por favor, recarga la pantalla.',
          type: 'error',
        });
      }
    },
    [menu, showSnackbar, hideCart],
  );
  const handleGoBackInternal = () => {
    if (navigationLevel === 'products') {
      setNavigationLevel('subcategories');
      setSelectedSubcategoryId(null);
    } else if (navigationLevel === 'subcategories') {
      setNavigationLevel('categories');
      setSelectedCategoryId(null);
    }
  };
  const handleAttemptExit = (goBackAction: () => void) => {
    if (isCartEmpty) {
      goBackAction();
    } else {
      setPendingNavigationAction(() => goBackAction);
      setShowExitConfirmationModal(true);
    }
  };
  useEffect(() => {
    const unsubscribe = navigation.addListener('beforeRemove', (e) => {
      if (isCartEmpty || showExitConfirmationModal || isProcessingOrder) {
        return;
      }
      e.preventDefault();
      setPendingNavigationAction(
        () => () => navigation.dispatch(e.data.action),
      );
      setShowExitConfirmationModal(true);
    });
    return unsubscribe;
  }, [navigation, isCartEmpty, showExitConfirmationModal, isProcessingOrder]);
  const handleViewCart = useCallback(() => {
    showCart();
  }, [showCart]);
  const handleCloseCart = useCallback(() => {
    hideCart();
  }, [hideCart]);
  const handleConfirmOrder = async (details: OrderDetailsForBackend) => {
    if (isProcessingOrderRef.current) return;
    isProcessingOrderRef.current = true;
    setIsProcessingOrder(true);
    try {
      const createdOrder = await createOrderMutation.mutateAsync(details);
      showSnackbar({
        message: `Orden #${createdOrder.shiftOrderNumber} creada con éxito`,
        type: 'success',
      });
      hideCart();
      clearAll();
      setTimeout(() => {
        navigation.goBack();
      }, 100);
    } catch (error) {
      const message = getApiErrorMessage(error as Error);
      showSnackbar({
        message: `Error al crear orden: ${message}`,
        type: 'error',
      });
    } finally {
      setIsProcessingOrder(false);
      isProcessingOrderRef.current = false;
    }
  };
  const handleAddItem = (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    originalAddItem(
      product,
      quantity,
      selectedVariantId,
      selectedModifiers,
      preparationNotes,
      selectedPizzaCustomizations,
      pizzaExtraCost,
    );
    cartButtonRef.current?.animate();
  };
  const handleAudioRecordingComplete = useCallback(
    async (audioUri: string, transcription: string) => {
      setIsProcessingAudio(true);
      setShowAudioModal(true);
      setAudioError(undefined);
      try {
        const response = await audioOrderService.processAudioOrder(
          audioUri,
          transcription,
        );
        if (response.success && response.data) {
          setAudioOrderData(response.data);
        } else {
          setAudioError(response.error?.message || 'Error procesando la orden');
        }
      } catch (error) {
        setAudioError('Error al procesar la orden por voz');
      } finally {
        setIsProcessingAudio(false);
      }
    },
    [],
  );
  const handleAudioError = useCallback(
    (error: string) => {
      showSnackbar({
        message: error,
        type: 'error',
      });
    },
    [showSnackbar],
  );
  const handleConfirmAudioOrder = async (
    items: AIOrderItem[],
    deliveryInfo?: any,
    scheduledDelivery?: any,
    orderType?: 'DELIVERY' | 'TAKE_AWAY' | 'DINE_IN',
  ) => {
    try {
      if (!menu) {
        throw new Error('El menú no está disponible');
      }
      let addedCount = 0;
      let failedCount = 0;
      for (const item of items) {
        let foundProduct: Product | null = null;
        outer: for (const category of menu) {
          for (const subcategory of category.subcategories || []) {
            for (const product of subcategory.products || []) {
              if (product.id === item.productId) {
                foundProduct = product;
                break outer;
              }
            }
          }
        }
        if (foundProduct) {
          const selectedModifiers: CartItemModifier[] = [];
          if (item.modifiers && item.modifiers.length > 0) {
            for (const modName of item.modifiers) {
              for (const modGroup of foundProduct.modifierGroups || []) {
                const modifier = modGroup.productModifiers?.find(
                  (m) => m.name === modName,
                );
                if (modifier) {
                  selectedModifiers.push({
                    id: modifier.id,
                    modifierGroupId: modGroup.id,
                    name: modifier.name,
                    price: modifier.price || 0,
                  });
                  break;
                }
              }
            }
          }
          const pizzaCustomizations = item.pizzaCustomizations?.map((pc) => ({
            pizzaCustomizationId: pc.customizationId,
            half: pc.half as any,
            action: pc.action as any,
          }));
          handleAddItem(
            foundProduct,
            item.quantity,
            item.variantId,
            selectedModifiers,
            undefined,
            pizzaCustomizations,
            0,
          );
          addedCount++;
        } else {
          failedCount++;
        }
      }
      if (addedCount > 0 && failedCount === 0) {
        showSnackbar({
          message: `Se agregaron ${addedCount} producto${addedCount > 1 ? 's' : ''} al carrito`,
          type: 'success',
        });
      } else if (addedCount > 0 && failedCount > 0) {
        showSnackbar({
          message: `Se agregaron ${addedCount} producto${addedCount > 1 ? 's' : ''}, ${failedCount} no se encontraron`,
          type: 'warning',
        });
      } else {
        showSnackbar({
          message: 'No se pudieron agregar los productos al carrito',
          type: 'error',
        });
      }
      if (deliveryInfo && Object.keys(deliveryInfo).length > 0) {
        setDeliveryInfo(deliveryInfo);
      }
      if (orderType) {
        setOrderType(orderType);
      } else {
      }
      setShowAudioModal(false);
      setAudioOrderData(null);
      if (addedCount > 0) {
        cartButtonRef.current?.animate();
      }
    } catch (error) {
      showSnackbar({
        message: 'Error al agregar los productos al carrito',
        type: 'error',
      });
    }
  };
  const getCategories = () => {
    if (!menu || !Array.isArray(menu)) return [];
    return menu;
  };
  const getSubcategories = () => {
    if (!selectedCategory || !Array.isArray(selectedCategory.subcategories))
      return [];
    return selectedCategory.subcategories;
  };
  const getProducts = () => {
    if (!selectedSubCategory || !Array.isArray(selectedSubCategory.products))
      return [];
    return selectedSubCategory.products;
  };
  const selectedCategory =
    menu && Array.isArray(menu)
      ? menu.find((cat: Category) => cat.id === selectedCategoryId)
      : null;
  const selectedSubCategory =
    selectedCategory && Array.isArray(selectedCategory.subcategories)
      ? selectedCategory.subcategories.find(
          (sub: SubCategory) => sub.id === selectedSubcategoryId,
        )
      : null;
  const getNavTitle = useCallback(() => {
    if (selectedProduct) {
      return selectedProduct.name;
    }
    switch (navigationLevel) {
      case 'categories':
        return 'Categorías';
      case 'subcategories':
        return selectedCategory?.name
          ? `Categoría: ${selectedCategory.name}`
          : 'Subcategorías';
      case 'products':
        return selectedSubCategory?.name
          ? `Subcategoría: ${selectedSubCategory.name}`
          : 'Productos';
      default:
        return 'Categorías';
    }
  }, [navigationLevel, selectedCategory, selectedSubCategory, selectedProduct]);
  const styles = useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: colors.background,
        },
        container: {
          flex: 1,
        },
        content: {
          flex: 1,
        },
        gridContainer: {
          padding: responsive.spacing(theme.spacing.m),
          paddingBottom: 60,
        },
        row: {
          justifyContent: 'flex-start',
          paddingHorizontal: 0,
          marginBottom: responsive.spacing(8),
          gap: responsive.spacing(8),
        },
        cardItem: {
          width: itemWidth,
          marginHorizontal: 0,
          marginVertical: 0,
          overflow: 'hidden',
          borderRadius: theme.roundness * 2,
          elevation: 2,
          backgroundColor: colors.surface,
          aspectRatio: 0.85,
        },
        cardItemInactive: {
          opacity: 0.5,
        },
        itemImage: {
          width: '100%',
          height: itemWidth * 0.65,
        },
        imageInactive: {
          opacity: 0.6,
        },
        cardContent: {
          paddingHorizontal: responsive.spacing(theme.spacing.s),
          paddingVertical: responsive.spacing(theme.spacing.xs),
          height: itemWidth * 0.35,
          justifyContent: 'center',
        },
        cardTitle: {
          fontSize: responsive.fontSize(responsive.width >= 600 ? 16 : 15),
          fontWeight: '600',
          lineHeight:
            responsive.fontSize(responsive.width >= 600 ? 16 : 15) * 1.2,
          marginBottom: responsive.spacing(2),
        },
        cardHeader: {
          flexDirection: 'row',
          justifyContent: 'space-between',
          alignItems: 'flex-start',
        },
        infoButton: {
          margin: -8,
          marginTop: -12,
          marginRight: -12,
        },
        priceText: {
          color: theme.colors.primary,
          fontWeight: '600',
          fontSize: responsive.fontSize(responsive.width >= 600 ? 14 : 13),
          marginTop: 2,
        },
        noItemsText: {
          textAlign: 'center',
          marginTop: 40,
          fontSize: 16,
          color: '#666',
        },
        loadingContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
        },
        appBar: {
          backgroundColor: colors.elevation.level2,
          alignItems: 'center',
        },
        appBarTitle: {
          ...fonts.titleMedium,
          color: colors.onSurface,
          fontWeight: 'bold',
          textAlign: 'center',
        },
        appBarContent: {},
        spacer: {
          width: 48,
        },
        inactiveBadge: {
          position: 'absolute',
          top: 8,
          right: 8,
          backgroundColor: colors.errorContainer,
          paddingHorizontal: 8,
          paddingVertical: 4,
          borderRadius: 4,
        },
        inactiveBadgeText: {
          fontSize: 12,
          color: colors.onErrorContainer,
          fontWeight: '600',
        },
        emptyStateContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacing.l,
        },
        emptyStateTitle: {
          marginTop: responsive.spacing.l,
          marginBottom: responsive.spacing.m,
          textAlign: 'center',
          color: colors.onSurface,
          fontWeight: '600',
        },
        emptyStateText: {
          textAlign: 'center',
          color: colors.onSurfaceVariant,
          maxWidth: 320,
          lineHeight: 24,
        },
      }),
    [colors, fonts, theme, responsive, itemWidth],
  );
  const handleConfirmExit = () => {
    setShowExitConfirmationModal(false);
    const navigationAction =
      pendingNavigationAction || (() => navigation.goBack());
    setPendingNavigationAction(null);
    navigationAction();
    setTimeout(() => {
      clearAll();
    }, 100);
  };
  const handleCancelExit = () => {
    setShowExitConfirmationModal(false);
    setPendingNavigationAction(null);
  };
  const handleShowProductDescription = (product: Product) => {
    setSelectedProductForDescription(product);
    setIsDescriptionModalVisible(true);
  };
  const handleCloseDescriptionModal = () => {
    setIsDescriptionModalVisible(false);
    setSelectedProductForDescription(null);
  };
  const blurhash =
    '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';
  const renderItem = useCallback(
    ({ item }: { item: Category | SubCategory | Product }) => {
      const imageSource = item.photo ? item.photo.path : null;
      const isActive = item.isActive !== false;
      const isProductWithoutScreen =
        navigationLevel === 'products' &&
        'preparationScreenId' in item &&
        !item.preparationScreenId;
      const handlePress = () => {
        if (!isActive || isProductWithoutScreen) return;
        if (navigationLevel === 'categories') {
          handleCategorySelect(item.id);
        } else if (navigationLevel === 'subcategories') {
          handleSubCategorySelect(item.id);
        } else if ('price' in item) {
          handleProductSelect(item as Product);
        }
      };
      const renderPrice = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          'hasVariants' in item
        ) {
          const productItem = item as Product;
          if (
            !productItem.hasVariants &&
            productItem.price !== null &&
            productItem.price !== undefined
          ) {
            return (
              <Text style={styles.priceText}>
                ${Number(productItem.price).toFixed(2)}
              </Text>
            );
          }
        }
        return null;
      };
      return (
        <Card
          style={[
            styles.cardItem,
            (!isActive || isProductWithoutScreen) && styles.cardItemInactive,
          ]}
          onPress={handlePress}
          disabled={!isActive || isProductWithoutScreen}
        >
          <AutoImage
            source={imageSource}
            style={[
              styles.itemImage,
              (!isActive || isProductWithoutScreen) && styles.imageInactive,
            ]}
            contentFit="cover"
            placeholder={blurhash}
            transition={300}
            placeholderIcon="image-outline"
          />
          {!isActive && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>INACTIVO</Text>
            </View>
          )}
          {isProductWithoutScreen && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>SIN PANTALLA</Text>
            </View>
          )}
          <View style={styles.cardContent}>
            {navigationLevel === 'products' &&
            'price' in item &&
            (item as Product).description ? (
              <View style={styles.cardHeader}>
                <Title
                  style={[styles.cardTitle, { flex: 1 }]}
                  numberOfLines={2}
                  ellipsizeMode="tail"
                >
                  {item.name}
                </Title>
                <IconButton
                  icon="information-outline"
                  size={20}
                  onPress={() => handleShowProductDescription(item as Product)}
                  style={styles.infoButton}
                />
              </View>
            ) : (
              <Title
                style={styles.cardTitle}
                numberOfLines={2}
                ellipsizeMode="tail"
              >
                {item.name}
              </Title>
            )}
            {renderPrice()}
          </View>
        </Card>
      );
    },
    [
      navigationLevel,
      handleCategorySelect,
      handleSubCategorySelect,
      handleProductSelect,
      handleShowProductDescription,
      styles,
      blurhash,
    ],
  );
  const getItemsToDisplay = () => {
    switch (navigationLevel) {
      case 'categories':
        return getCategories();
      case 'subcategories':
        return getSubcategories();
      case 'products':
        return getProducts();
      default:
        return [];
    }
  };
  const itemsToDisplay = getItemsToDisplay();
  const showCartButton = !isCartVisible && !selectedProduct;
  const backAction = selectedProduct
    ? handleCloseProductModal
    : navigationLevel === 'categories'
      ? () => handleAttemptExit(() => navigation.goBack())
      : handleGoBackInternal;
  const renderContent = () => {
    if (isCartVisible) {
      return (
        <SafeAreaView
          style={styles.safeArea}
          edges={['left', 'right', 'bottom']}
        >
          <Appbar.Header style={styles.appBar}>
            <Appbar.BackAction onPress={handleCloseCart} />
            <Appbar.Content
              title="Carrito de Compras"
              titleStyle={styles.appBarTitle}
              style={styles.appBarContent}
            />
            <View style={styles.spacer} />
          </Appbar.Header>
          <OrderCartDetail
            visible={isCartVisible}
            onClose={handleCloseCart}
            onConfirmOrder={handleConfirmOrder}
            onEditItem={handleEditItem}
            isEditMode={false}
          />
        </SafeAreaView>
      );
    }
    if (!shiftLoading && (!shift || shift.status !== 'OPEN')) {
      return (
        <SafeAreaView
          style={styles.safeArea}
          edges={['left', 'right', 'bottom']}
        >
          <Appbar.Header style={styles.appBar} elevated>
            <Appbar.BackAction onPress={() => navigation.goBack()} />
            <Appbar.Content
              title="Crear Orden"
              titleStyle={styles.appBarTitle}
              style={styles.appBarContent}
            />
          </Appbar.Header>
          <View style={styles.emptyStateContainer}>
            <MaterialCommunityIcons
              name="store-alert"
              size={64}
              color={theme.colors.onSurfaceVariant}
            />
            <Text variant="headlineSmall" style={styles.emptyStateTitle}>
              Turno Cerrado
            </Text>
            <Text variant="bodyLarge" style={styles.emptyStateText}>
              {userCanOpenShift
                ? 'Para crear órdenes, primero debes abrir el turno usando el indicador en la barra superior.'
                : 'El turno debe estar abierto para crear órdenes. Contacta a un administrador.'}
            </Text>
          </View>
        </SafeAreaView>
      );
    }
    return (
      <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction onPress={backAction} />
          <Appbar.Content
            title={getNavTitle()}
            titleStyle={styles.appBarTitle}
            style={styles.appBarContent}
          />
          {showCartButton ? (
            <CartButton
              ref={cartButtonRef}
              itemCount={totalItemsCount}
              onPress={handleViewCart}
            />
          ) : (
            <View style={styles.spacer} />
          )}
        </Appbar.Header>
        <View style={styles.content}>
          {isLoading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color="#2e7d32" />
              <Text>Cargando...</Text>
            </View>
          ) : itemsToDisplay.length > 0 ? (
            <FlatList
              data={itemsToDisplay}
              renderItem={renderItem}
              keyExtractor={(item) => item.id}
              numColumns={numColumns}
              key={numColumns}
              contentContainerStyle={styles.gridContainer}
              columnWrapperStyle={numColumns > 1 ? styles.row : undefined}
              showsVerticalScrollIndicator={false}
            />
          ) : (
            <Text style={styles.noItemsText}>
              {navigationLevel === 'products'
                ? 'No hay productos disponibles'
                : navigationLevel === 'subcategories'
                  ? 'No hay subcategorías disponibles'
                  : 'No hay categorías disponibles'}
            </Text>
          )}
        </View>
        <ConfirmationModal
          visible={showExitConfirmationModal}
          title="¿Descartar Orden?"
          message="Tienes artículos en el carrito. Si sales, se perderán. ¿Estás seguro?"
          confirmText="Salir y Descartar"
          cancelText="Cancelar"
          onConfirm={handleConfirmExit}
          onCancel={handleCancelExit}
        />
        <Portal>
          {selectedProduct && productNeedsCustomization(selectedProduct) && (
            <ProductCustomizationModal
              visible={true}
              product={selectedProduct}
              editingItem={editingItem}
              onAddToCart={handleAddItem}
              onUpdateItem={updateItem}
              onDismiss={handleCloseProductModal}
            />
          )}
          <SimpleProductDescriptionModal
            visible={isDescriptionModalVisible}
            product={selectedProductForDescription}
            onDismiss={handleCloseDescriptionModal}
          />
          <AudioOrderModal
            visible={showAudioModal}
            onDismiss={() => {
              setShowAudioModal(false);
              setAudioOrderData(null);
              setAudioError(undefined);
            }}
            onConfirm={handleConfirmAudioOrder}
            isProcessing={isProcessingAudio}
            orderData={audioOrderData}
            error={audioError}
          />
        </Portal>
        {}
        {!isCartVisible && !selectedProduct && (
          <AudioRecorderWidget
            onRecordingComplete={handleAudioRecordingComplete}
            onError={handleAudioError}
          />
        )}
      </SafeAreaView>
    );
  };
  return renderContent();
};
export default CreateOrderScreen;

================
File: app/app.config.js
================
export default {
  expo: {
    name: "CloudBite",
    slug: "cloudbite",
    version: "1.0.0",
    orientation: "default",
    icon: "./assets/icon.png",
    userInterfaceStyle: "automatic",
    splash: {
      image: "./assets/splash.png",
      resizeMode: "cover",
      backgroundColor: "#ffffff"
    },
    web: {
      favicon: "./assets/favicon.png"
    },
    assetBundlePatterns: [
      "**/*"
    ],
    extra: {
      eas: {
        projectId: "556b2536-af8e-4b1c-8013-20f9e876d57e"
      }
    },
    plugins: [
      "expo-speech-recognition",
      "expo-audio",
      [
        "expo-build-properties",
        {
          android: {
            compileSdkVersion: 35,
            targetSdkVersion: 34,
            buildToolsVersion: "35.0.0",
            usesCleartextTraffic: process.env.EAS_BUILD_PROFILE !== 'production',
            newArchEnabled: true
          },
          ios: {
            newArchEnabled: true
          }
        }
      ],
      "./plugins/withCustomIcons"
    ],
    android: {
      permissions: [
        "android.permission.INTERNET",
        "android.permission.ACCESS_NETWORK_STATE",
        "android.permission.ACCESS_WIFI_STATE",
        "android.permission.RECORD_AUDIO",
        "android.permission.MODIFY_AUDIO_SETTINGS"
      ],
      package: "com.viefmoon.cloudbite",
      icon: "./assets/icon.png",
      supportsTablet: true,
      googleServicesFile: process.env.GOOGLE_SERVICES_JSON ? "./google-services.json" : undefined,
      networkSecurityConfig: "./android/app/src/main/res/xml/network_security_config.xml"
    },
    ios: {
      infoPlist: {
        NSSpeechRecognitionUsageDescription: "Allow CloudBite to use speech recognition for voice orders.",
        NSMicrophoneUsageDescription: "Allow CloudBite to use the microphone for voice orders."
      },
      bundleIdentifier: "com.viefmoon.cloudbite",
      supportsTablet: true,
      icon: "./assets/icon.png"
    },
    web: {
      favicon: "./assets/favicon.png"
    },
    owner: "viefmoon"
  }
};

================
File: app/src/app/navigation/AppDrawerNavigator.tsx
================
import React from 'react';
import {
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  View,
  Text,
} from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { MenuStackNavigator } from '../../modules/menu/navigation/MenuStackNavigator';
import ModifiersStackNavigator from '../../modules/modifiers/navigation/ModifiersStackNavigator';
import PreparationScreensStackNavigator from '../../modules/preparationScreens/navigation/PreparationScreensStackNavigator';
import AreasTablesStackNavigator from '../../modules/areasTables/navigation/AreasTablesStackNavigator';
import OrdersStackNavigator from './OrdersStackNavigator';
import PrintersStackNavigator from '../../modules/printers/navigation/PrintersStackNavigator';
import { ReceiptsStackNavigator } from '../../modules/receipts/navigation/ReceiptsStackNavigator';
import { AvailabilityStackNavigator } from '../../modules/availability/navigation/AvailabilityStackNavigator';
import { OrderFinalizationStackNavigator } from '../../modules/orderFinalization/navigation/OrderFinalizationStackNavigator';
import { RestaurantConfigStackNavigator } from '../../modules/restaurantConfig/navigation/RestaurantConfigStackNavigator';
import { CustomersStackNavigator } from '../../modules/customers/navigation/CustomersStackNavigator';
import { PizzaCustomizationsStackNavigator } from '../../modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator';
import { SyncStackNavigator } from '../../modules/sync/navigation/SyncStackNavigator';
import { UsersStackNavigator } from '../../modules/users/navigation/UsersStackNavigator';
import KitchenNavigator from '../../modules/kitchen/navigation/KitchenNavigator';
import { ShiftAuditStackNavigator } from '../../modules/shiftAudit/navigation/ShiftAuditStackNavigator';
import { SettingsStackNavigator } from '../../modules/settings/navigation/SettingsStackNavigator';
import { ServerSettingsScreen } from '../../modules/settings/screens/ServerSettingsScreen';
import { CustomDrawerContent } from './components/CustomDrawerContent';
import { useAppTheme } from '../styles/theme';
import { Icon, Surface, Checkbox, Text as PaperText } from 'react-native-paper';
import type { AppDrawerParamList } from './types';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { ShiftIndicator } from '../components/ShiftIndicator';
import { useAuthStore } from '../store/authStore';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderType } from '../../modules/kitchen/types/kitchen.types';
const Drawer = createDrawerNavigator<AppDrawerParamList>();
export function AppDrawerNavigator() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const kitchenScreenName =
    user?.preparationScreen?.name || 'Pantalla de Preparación';
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderType.DINE_IN:
        return ' • Mesa';
      case OrderType.TAKE_AWAY:
        return ' • Llevar';
      case OrderType.DELIVERY:
        return ' • Domicilio';
      default:
        return '';
    }
  };
  // Ruta inicial por defecto (no-kitchen users)
  const initialRouteName = 'OrdersStack';
  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        drawerButtonContainer: {
          width: 56,
          height: 56,
          justifyContent: 'center',
          alignItems: 'center',
          marginLeft: 0,
          borderRadius: 28,
        },
        headerStyle: {
          backgroundColor: theme.colors.primary,
          height: responsive.dimensions.headerHeight,
          elevation: 2,
        },
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
          color: theme.colors.onPrimary,
          fontWeight: 'bold',
          fontSize: responsive.isTablet ? 20 : 22,
        },
        drawerStyle: {
          backgroundColor: theme.colors.surface,
          width: responsive.dimensions.drawerWidth,
          borderTopRightRadius: theme.roundness * 2,
          borderBottomRightRadius: theme.roundness * 2,
        },
      }),
    [theme, responsive],
  );
  return (
    <>
      <StatusBar
        backgroundColor={theme.colors.primary}
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
      />
      <Drawer.Navigator
        initialRouteName={initialRouteName}
        drawerContent={(props) => <CustomDrawerContent {...props} />}
        screenOptions={({ navigation, route }) => ({
          headerStyle: styles.headerStyle,
          headerTintColor: theme.colors.onPrimary,
          headerTitleStyle: styles.headerTitleStyle,
          drawerStyle: styles.drawerStyle,
          drawerActiveTintColor: theme.colors.primary,
          drawerInactiveTintColor: theme.colors.onSurfaceVariant,
          drawerLabelStyle: {
            ...theme.fonts.labelLarge,
            fontSize: responsive.fontSize.m,
          },
          drawerItemStyle: {
            marginVertical: responsive.spacing.xxs,
            borderRadius: theme.roundness * 2,
            paddingVertical: responsive.spacing.xxs,
            paddingHorizontal: responsive.spacing.xs,
          },
          headerShown: true,
          drawerType: 'front',
          drawerPosition: 'left',
          headerShadowVisible: false,
          swipeEdgeWidth: 100,
          headerLeft: () => (
            <TouchableOpacity
              style={styles.drawerButtonContainer}
              onPress={() => navigation.openDrawer()}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Icon source="menu" size={32} color={theme.colors.onPrimary} />
            </TouchableOpacity>
          ),
          headerTitle: ({ children }) => {
            let title = '';
            switch (children) {
              case 'MenuStack':
                title = 'Menú';
                break;
              case 'ModifiersStack':
                title = 'Modificadores';
                break;
              case 'PreparationScreensStack':
                title = 'Pantallas Preparación';
                break;
              case 'AreasTablesStack':
                title = 'Áreas y Mesas';
                break;
              case 'OrdersStack':
                title = 'Órdenes';
                break;
              case 'PrintersStack':
                title = 'Impresoras';
                break;
              case 'ReceiptsStack':
                title = 'Recibos';
                break;
              case 'AvailabilityStack':
                title = 'Disponibilidad';
                break;
              case 'OrderFinalizationStack':
                title = 'Finalización';
                break;
              case 'RestaurantConfigStack':
                title = 'Configuración';
                break;
              case 'CustomersStack':
                title = 'Clientes';
                break;
              case 'PizzaCustomizationsStack':
                title = 'Personalizaciones';
                break;
              case 'SyncStack':
                title = 'Sincronización';
                break;
              case 'UsersStack':
                title = 'Usuarios';
                break;
              case 'KitchenStack':
                title =
                  kitchenScreenName +
                  (filters.orderType ? getFilterText() : '');
                break;
              case 'ShiftAuditStack':
                title = 'Historial de Turnos';
                break;
              case 'ServerSettings':
                title = 'Configuración del Servidor';
                break;
              default:
                title = children?.toString() || '';
            }
            return (
              <Surface
                elevation={0}
                style={{
                  backgroundColor: 'transparent',
                }}
              >
                <Text style={styles.headerTitleStyle}>{title}</Text>
              </Surface>
            );
          },
          headerRight: () => {
            const salesScreens = [
              'OrdersStack',
              'ReceiptsStack',
              'OrderFinalizationStack',
            ];
            const showShiftIndicator = salesScreens.includes(route.name);
            return (
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {showShiftIndicator && <ShiftIndicator />}
                <ConnectionIndicator />
              </View>
            );
          },
        })}
      >
        <Drawer.Screen
          name="OrdersStack"
          component={OrdersStackNavigator}
          options={{
            title: 'Órdenes',
            drawerIcon: ({ color }) => (
              <Icon
                source="clipboard-list-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ReceiptsStack"
          component={ReceiptsStackNavigator}
          options={{
            title: 'Recibos',
            drawerIcon: ({ color }) => (
              <Icon
                source="receipt"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="OrderFinalizationStack"
          component={OrderFinalizationStackNavigator}
          options={{
            title: 'Finalización',
            drawerIcon: ({ color }) => (
              <Icon
                source="clipboard-check-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="MenuStack"
          component={MenuStackNavigator}
          options={{
            title: 'Menú',
            drawerIcon: ({ color }) => (
              <Icon
                source="menu"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="AvailabilityStack"
          component={AvailabilityStackNavigator}
          options={{
            title: 'Disponibilidad',
            drawerIcon: ({ color }) => (
              <Icon
                source="eye-off-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ModifiersStack"
          component={ModifiersStackNavigator}
          options={{
            title: 'Modificadores',
            drawerIcon: ({ color }) => (
              <Icon
                source="tune"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="PizzaCustomizationsStack"
          component={PizzaCustomizationsStackNavigator}
          options={{
            title: 'Gestión de Pizzas',
            drawerIcon: ({ color }) => (
              <Icon
                source="pizza"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="PreparationScreensStack"
          component={PreparationScreensStackNavigator}
          options={{
            title: 'Pantallas Preparación',
            drawerIcon: ({ color }) => (
              <Icon
                source="monitor-dashboard"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="AreasTablesStack"
          component={AreasTablesStackNavigator}
          options={{
            title: 'Áreas y Mesas',
            drawerIcon: ({ color }) => (
              <Icon
                source="map-marker-radius-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="PrintersStack"
          component={PrintersStackNavigator}
          options={{
            title: 'Impresoras',
            drawerIcon: ({ color }) => (
              <Icon
                source="printer"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="RestaurantConfigStack"
          component={RestaurantConfigStackNavigator}
          options={{
            title: 'Configuración',
            drawerIcon: ({ color }) => (
              <Icon
                source="cog-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="CustomersStack"
          component={CustomersStackNavigator}
          options={{
            title: 'Clientes',
            drawerIcon: ({ color }) => (
              <Icon
                source="account-group-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="SyncStack"
          component={SyncStackNavigator}
          options={{
            title: 'Sincronización',
            drawerIcon: ({ color }) => (
              <Icon
                source="sync"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="UsersStack"
          component={UsersStackNavigator}
          options={{
            title: 'Usuarios',
            drawerIcon: ({ color }) => (
              <Icon
                source="account-multiple"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ShiftAuditStack"
          component={ShiftAuditStackNavigator}
          options={{
            title: 'Historial de Turnos',
            drawerIcon: ({ color }) => (
              <Icon
                source="history"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="KitchenStack"
          component={KitchenNavigator}
          options={{
            title: kitchenScreenName,
            drawerIcon: ({ color }) => (
              <Icon
                source="chef-hat"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
            headerRight: () => (
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {}
                <TouchableOpacity
                  style={{
                    flexDirection: 'row',
                    alignItems: 'center',
                    paddingHorizontal: 12,
                    paddingVertical: 8,
                    marginRight: 8,
                    backgroundColor: filters.showPrepared
                      ? 'rgba(255,255,255,0.2)'
                      : 'transparent',
                    borderRadius: 20,
                  }}
                  onPress={() =>
                    setFilters({
                      ...filters,
                      showPrepared: !filters.showPrepared,
                    })
                  }
                >
                  <Checkbox
                    status={filters.showPrepared ? 'checked' : 'unchecked'}
                    onPress={() =>
                      setFilters({
                        ...filters,
                        showPrepared: !filters.showPrepared,
                      })
                    }
                    color={theme.colors.onPrimary}
                    uncheckedColor={theme.colors.onPrimary}
                  />
                  <PaperText
                    style={{
                      color: theme.colors.onPrimary,
                      fontSize: 14,
                      marginLeft: 4,
                      fontWeight: filters.showPrepared ? 'bold' : 'normal',
                    }}
                  >
                    Mostrar Listas
                  </PaperText>
                </TouchableOpacity>
                <KitchenFilterButton />
                <ConnectionIndicator />
              </View>
            ),
          }}
        />
        <Drawer.Screen
          name="ServerSettings"
          component={ServerSettingsScreen}
          options={{
            title: 'Configuración del Servidor',
            drawerItemStyle: { display: 'none' },
          }}
        />
      </Drawer.Navigator>
    </>
  );
}

================
File: backend/src/orders/infrastructure/persistence/relational/repositories/order.repository.ts
================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { startOfDay, endOfDay } from 'date-fns';
import { toZonedTime, fromZonedTime } from 'date-fns-tz';
import { Between, FindOptionsWhere, Repository, In, Not } from 'typeorm';
import { NullableType } from '../../../../../utils/types/nullable.type';
import { IPaginationOptions } from '../../../../../utils/types/pagination-options';
import { Order } from '../../../../domain/order';
import { FindAllOrdersDto } from '../../../../dto/find-all-orders.dto';
import { OrderRepository } from '../../order.repository';
import { OrderEntity } from '../entities/order.entity';
import { OrderMapper } from '../mappers/order.mapper';
import { OrderStatus } from '../../../../domain/enums/order-status.enum';
import { ShiftsService } from '../../../../../shifts/shifts.service';
import { BadRequestException } from '@nestjs/common';
@Injectable()
export class OrdersRelationalRepository implements OrderRepository {
  constructor(
    @InjectRepository(OrderEntity)
    private readonly ordersRepository: Repository<OrderEntity>,
    @Inject(forwardRef(() => ShiftsService))
    private readonly shiftsService: ShiftsService,
    private readonly orderMapper: OrderMapper,
  ) {}
  async create(data: {
    userId: string | null;
    tableId: string | null;
    scheduledAt?: Date | null;
    orderStatus: string;
    orderType: string;
    subtotal: number;
    total: number;
    notes?: string;
    customerId?: string | null;
    isFromWhatsApp?: boolean;
    deliveryInfo: any;
    estimatedDeliveryTime?: Date | null;
    operationalDate?: Date;
  }): Promise<Order> {
    const currentShift = await this.shiftsService.getCurrentShift();
    if (!currentShift) {
      throw new BadRequestException(
        'No hay un turno activo. Debe abrir un turno antes de crear órdenes.',
      );
    }
    const shiftOrderNumber = await this.getNextShiftOrderNumber(
      currentShift.id,
    );
    const orderToCreate = {
      ...data,
      shiftOrderNumber,
      shiftId: currentShift.id,
    };
    const persistenceModel = this.orderMapper.toEntity(orderToCreate as Order);
    if (!persistenceModel) {
      throw new Error('Failed to map order domain to entity');
    }
    const newEntity = await this.ordersRepository.save(
      this.ordersRepository.create(persistenceModel),
    );
    const completeEntity = await this.ordersRepository.findOne({
      where: { id: newEntity.id },
      relations: [
        'user',
        'table',
        'table.area',
        'shift',
        'orderItems',
        'orderItems.product',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.preparedBy',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'payments',
        'adjustments',
        'deliveryInfo',
      ],
    });
    if (!completeEntity) {
      throw new Error(
        `No se pudo cargar la orden creada con ID ${newEntity.id}`,
      );
    }
    const domainResult = this.orderMapper.toDomain(completeEntity);
    if (!domainResult) {
      throw new Error('Failed to map complete order entity to domain');
    }
    return domainResult;
  }
  async findManyWithPagination({
    filterOptions,
    paginationOptions,
  }: {
    filterOptions?: FindAllOrdersDto | null;
    paginationOptions: IPaginationOptions;
  }): Promise<[Order[], number]> {
    const where: FindOptionsWhere<OrderEntity> = {};
    if (filterOptions?.userId) {
      where.userId = filterOptions.userId;
    }
    if (filterOptions?.tableId) {
      where.tableId = filterOptions.tableId;
    }
    if (filterOptions?.shiftId) {
      where.shiftId = filterOptions.shiftId;
    }
    if (
      filterOptions?.orderStatuses &&
      filterOptions.orderStatuses.length > 0
    ) {
      where.orderStatus = In(filterOptions.orderStatuses);
    } else if (filterOptions?.orderStatus) {
      where.orderStatus = filterOptions.orderStatus;
    }
    if (filterOptions?.orderType) {
      where.orderType = filterOptions.orderType;
    }
    if (filterOptions?.startDate && filterOptions?.endDate) {
      const startDate = new Date(filterOptions.startDate);
      const endDate = new Date(filterOptions.endDate);
      where.createdAt = Between(startDate, endDate);
    } else if (filterOptions?.startDate) {
      const startDate = new Date(filterOptions.startDate);
      where.createdAt = Between(startDate, new Date());
    } else if (filterOptions?.endDate) {
      const endDate = new Date(filterOptions.endDate);
      const startDate = new Date(0);
      where.createdAt = Between(startDate, endDate);
    }
    const [entities, count] = await this.ordersRepository.findAndCount({
      skip: (paginationOptions.page - 1) * paginationOptions.limit,
      take: paginationOptions.limit,
      where: where,
      relations: [
        'user',
        'table',
        'table.area',
        'shift',
        'orderItems',
        'orderItems.product',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.preparedBy',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'payments',
        'adjustments',
        'deliveryInfo',
      ],
      order: {
        createdAt: 'DESC',
      },
    });
    const domainOrders = entities
      .map((order) => this.orderMapper.toDomain(order))
      .filter((order): order is Order => order !== null);
    return [domainOrders, count];
  }
  async findById(id: Order['id']): Promise<NullableType<Order>> {
    const entity = await this.ordersRepository.findOne({
      where: { id },
      relations: [
        'user',
        'table',
        'table.area',
        'shift',
        'orderItems',
        'orderItems.product',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.preparedBy',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'payments',
        'adjustments',
        'deliveryInfo',
      ],
    });
    return entity ? this.orderMapper.toDomain(entity) : null;
  }
  async findByUserId(userId: Order['userId']): Promise<Order[]> {
    if (!userId) return [];
    const entities = await this.ordersRepository.find({
      where: { userId },
      relations: [
        'user',
        'table',
        'table.area',
        'shift',
        'orderItems',
        'orderItems.product',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.preparedBy',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'payments',
        'adjustments',
        'deliveryInfo',
      ],
      order: {
        createdAt: 'DESC',
      },
    });
    return entities
      .map((order) => this.orderMapper.toDomain(order))
      .filter((order): order is Order => order !== null);
  }
  async findByTableId(tableId: Order['tableId']): Promise<Order[]> {
    if (tableId === null) {
      return [];
    }
    const entities = await this.ordersRepository.find({
      where: { tableId },
      relations: [
        'user',
        'table',
        'table.area',
        'shift',
        'orderItems',
        'orderItems.product',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.preparedBy',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'payments',
        'adjustments',
        'deliveryInfo',
      ],
      order: {
        createdAt: 'DESC',
      },
    });
    return entities
      .map((order) => this.orderMapper.toDomain(order))
      .filter((order): order is Order => order !== null);
  }
  async findByShiftId(shiftId: Order['shiftId']): Promise<Order[]> {
    const entities = await this.ordersRepository.find({
      where: { shiftId },
      relations: [
        'user',
        'table',
        'table.area',
        'shift',
        'orderItems',
        'orderItems.product',
        'orderItems.product.preparationScreen',
        'orderItems.product.subcategory',
        'orderItems.product.subcategory.category',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.preparedBy',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'payments',
        'adjustments',
        'deliveryInfo',
      ],
      order: {
        shiftOrderNumber: 'ASC',
      },
    });
    return entities
      .map((order) => this.orderMapper.toDomain(order))
      .filter((order): order is Order => order !== null);
  }
  async findByShiftIdForSummary(shiftId: Order['shiftId']): Promise<Order[]> {
    const entities = await this.ordersRepository.find({
      where: { shiftId },
      relations: [
        'orderItems',
        'orderItems.product',
        'orderItems.product.subcategory',
        'orderItems.product.subcategory.category',
        'orderItems.productVariant',
      ],
      select: {
        id: true,
        orderStatus: true,
        total: true,
        orderItems: {
          id: true,
          finalPrice: true,
          product: {
            id: true,
            name: true,
            subcategory: {
              id: true,
              name: true,
              category: {
                id: true,
                name: true,
              },
            },
          },
          productVariant: {
            id: true,
            name: true,
          },
        },
      },
      order: {
        shiftOrderNumber: 'ASC',
      },
    });
    return entities
      .map((order) => this.orderMapper.toDomain(order))
      .filter((order): order is Order => order !== null);
  }
  async findOpenOrdersByDate(date: Date): Promise<Order[]> {
    const timeZone = 'America/Mexico_City';
    const localDate = toZonedTime(date, timeZone);
    const startLocal = startOfDay(localDate);
    const endLocal = endOfDay(localDate);
    const startUtc = fromZonedTime(startLocal, timeZone);
    const endUtc = fromZonedTime(endLocal, timeZone);
    const queryBuilder = this.ordersRepository
      .createQueryBuilder('order')
      .select([
        'order.id',
        'order.shiftOrderNumber',
        'order.shiftId',
        'order.orderType',
        'order.orderStatus',
        'order.subtotal',
        'order.total',
        'order.createdAt',
        'order.estimatedDeliveryTime',
        'order.notes',
      ])
      .leftJoin('order.user', 'user')
      .addSelect(['user.id', 'user.firstName', 'user.lastName'])
      .leftJoin('order.table', 'table')
      .addSelect(['table.id', 'table.name', 'table.isTemporary'])
      .leftJoin('table.area', 'area')
      .addSelect(['area.id', 'area.name'])
      .leftJoin('order.deliveryInfo', 'deliveryInfo')
      .addSelect([
        'deliveryInfo.recipientName',
        'deliveryInfo.recipientPhone',
        'deliveryInfo.fullAddress',
      ])
      .leftJoin('order.orderItems', 'orderItems')
      .addSelect(['orderItems.id', 'orderItems.preparationStatus'])
      .where('order.createdAt >= :start', { start: startUtc })
      .andWhere('order.createdAt < :end', { end: endUtc })
      .andWhere('order.orderStatus NOT IN (:...excludedStatuses)', {
        excludedStatuses: [OrderStatus.COMPLETED, OrderStatus.CANCELLED],
      })
      .orderBy('order.shiftOrderNumber', 'ASC');
    const entities = await queryBuilder.getMany();
    return entities
      .map((order) => this.orderMapper.toDomain(order))
      .filter((order): order is Order => order !== null);
  }
  async update(id: Order['id'], payload: Partial<Order>): Promise<Order> {
    const entity = await this.ordersRepository.findOne({
      where: { id },
      relations: [
        'user',
        'table',
        'table.area',
        'shift',
        'orderItems',
        'orderItems.product',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.preparedBy',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'payments',
        'adjustments',
        'deliveryInfo',
      ],
    });
    if (!entity) {
      throw new Error('Order not found');
    }
    const existingDomain = this.orderMapper.toDomain(entity);
    if (!existingDomain) {
      throw new Error('Failed to map existing order entity to domain');
    }
    const { shiftOrderNumber, shiftId, ...updateData } = payload;
    if ('deliveryInfo' in updateData) {
      if (updateData.deliveryInfo === null && entity.deliveryInfo) {
        await this.ordersRepository.manager.delete('delivery_info', {
          orderId: id,
        });
        entity.deliveryInfo = null;
      }
    }
    const updatedDomain = {
      ...existingDomain,
      ...updateData,
    };
    const persistenceModel = this.orderMapper.toEntity(updatedDomain);
    if (!persistenceModel) {
      throw new Error('Failed to map updated order domain to entity');
    }
    if (persistenceModel.deliveryInfo) {
      if (entity.deliveryInfo) {
        persistenceModel.deliveryInfo.id = entity.deliveryInfo.id;
        persistenceModel.deliveryInfo.createdAt = entity.deliveryInfo.createdAt;
        entity.deliveryInfo = persistenceModel.deliveryInfo;
      }
    } else if (persistenceModel.deliveryInfo === null && entity.deliveryInfo) {
      entity.deliveryInfo = null;
    }
    const mergedEntity = this.ordersRepository.merge(entity, persistenceModel);
    if ('tableId' in updateData) {
      mergedEntity.tableId =
        updateData.tableId === undefined ? null : updateData.tableId;
      if (updateData.tableId === null) {
        mergedEntity.table = null;
      }
    }
    const updatedEntity = await this.ordersRepository.save(mergedEntity);
    const completeEntity = await this.ordersRepository.findOne({
      where: { id: updatedEntity.id },
      relations: [
        'user',
        'table',
        'table.area',
        'shift',
        'orderItems',
        'orderItems.product',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.preparedBy',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'payments',
        'adjustments',
        'deliveryInfo',
      ],
    });
    if (!completeEntity) {
      throw new Error(
        `No se pudo cargar la orden actualizada con ID ${updatedEntity.id}`,
      );
    }
    const finalDomainResult = this.orderMapper.toDomain(completeEntity);
    if (!finalDomainResult) {
      throw new Error('Failed to map final updated order entity to domain');
    }
    return finalDomainResult;
  }
  async remove(id: Order['id']): Promise<void> {
    await this.ordersRepository.softDelete(id);
  }
  async findByDateRange(startDate: Date, endDate: Date): Promise<Order[]> {
    const entities = await this.ordersRepository.find({
      where: {
        createdAt: Between(startDate, endDate),
      },
      relations: [
        'user',
        'table',
        'shift',
        'orderItems',
        'payments',
        'deliveryInfo',
      ],
      order: {
        createdAt: 'DESC',
      },
    });
    return entities
      .map((entity) => this.orderMapper.toDomain(entity))
      .filter((order): order is Order => order !== null);
  }
  async findOpenOrdersOptimized(
    startDate: Date,
    endDate: Date,
  ): Promise<Order[]> {
    const queryBuilder = this.ordersRepository
      .createQueryBuilder('order')
      .select([
        'order.id',
        'order.shiftOrderNumber',
        'order.shiftId',
        'order.orderType',
        'order.orderStatus',
        'order.total',
        'order.subtotal',
        'order.createdAt',
        'order.scheduledAt',
        'order.notes',
        'order.isFromWhatsApp',
        'order.userId',
        'order.tableId',
        'order.customerId',
        'order.estimatedDeliveryTime',
        'order.finalizedAt',
        'order.deletedAt',
        'order.updatedAt',
      ])
      .leftJoin('order.table', 'table')
      .addSelect(['table.id', 'table.name', 'table.isTemporary'])
      .leftJoin('table.area', 'area')
      .addSelect(['area.name'])
      .leftJoin('order.deliveryInfo', 'deliveryInfo')
      .addSelect([
        'deliveryInfo.recipientName',
        'deliveryInfo.recipientPhone',
        'deliveryInfo.fullAddress',
      ])
      .leftJoin('order.user', 'user')
      .addSelect(['user.username', 'user.firstName', 'user.lastName'])
      .where('order.createdAt >= :startDate', { startDate })
      .andWhere('order.createdAt <= :endDate', { endDate })
      .andWhere('order.orderStatus NOT IN (:...excludedStatuses)', {
        excludedStatuses: [OrderStatus.COMPLETED, OrderStatus.CANCELLED],
      })
      .orderBy('order.createdAt', 'DESC');
    const entities = await queryBuilder.getMany();
    const ordersWithAggregates = await Promise.all(
      entities.map(async (entity) => {
        const aggregateResult = await this.ordersRepository
          .createQueryBuilder('o')
          .select([
            'COALESCE(SUM(CASE WHEN p.paymentStatus = :completed THEN p.amount ELSE 0 END), 0) as totalPaid',
            'COUNT(DISTINCT ti.id) as impressionCount',
          ])
          .leftJoin('o.payments', 'p')
          .leftJoin('o.ticketImpressions', 'ti')
          .where('o.id = :orderId', { orderId: entity.id })
          .setParameter('completed', 'COMPLETED')
          .getRawOne();
        const preparationScreensResult = await this.ordersRepository
          .createQueryBuilder('o')
          .select([
            'ps.name as "screenName"',
            'ps.id as "screenId"',
            `CASE
              WHEN COUNT(oi.id) = COUNT(CASE WHEN oi.preparationStatus IN ('READY', 'DELIVERED') THEN 1 END) THEN 'READY'
              WHEN COUNT(CASE WHEN oi.preparationStatus = 'IN_PROGRESS' THEN 1 END) > 0 THEN 'IN_PROGRESS'
              ELSE 'PENDING'
            END as "status"`,
          ])
          .leftJoin('o.orderItems', 'oi')
          .leftJoin('oi.product', 'p')
          .leftJoin('p.preparationScreen', 'ps')
          .where('o.id = :orderId', { orderId: entity.id })
          .andWhere('ps.id IS NOT NULL')
          .groupBy('ps.id, ps.name')
          .getRawMany();
        const preparationScreenStatuses = preparationScreensResult
          .map((r) => ({
            name: r.screenName,
            status: r.status,
          }))
          .filter((s) => s.name);
        const order = this.orderMapper.toDomain(entity);
        if (order) {
          const optimizedOrder: Order = {
            id: order.id,
            shiftOrderNumber: order.shiftOrderNumber,
            shiftId: order.shiftId,
            orderType: order.orderType,
            orderStatus: order.orderStatus,
            total: order.total,
            createdAt: order.createdAt,
            scheduledAt: order.scheduledAt,
            notes: order.notes,
            table: order.table,
            deliveryInfo: order.deliveryInfo,
            paymentsSummary: {
              totalPaid: parseFloat(aggregateResult?.totalpaid || '0'),
            },
            ticketImpressionCount: parseInt(
              aggregateResult?.impressioncount || '0',
            ),
            preparationScreenStatuses: preparationScreenStatuses,
            userId: order.userId,
            tableId: order.tableId,
            subtotal: order.subtotal,
            user: order.user,
            orderItems: [],
            payments: null,
            adjustments: undefined,
            deletedAt: order.deletedAt,
            updatedAt: order.updatedAt,
            customerId: order.customerId,
            customer: order.customer,
            isFromWhatsApp: order.isFromWhatsApp,
            estimatedDeliveryTime: order.estimatedDeliveryTime,
            preparationScreenStatusesFull: undefined,
            ticketImpressions: undefined,
            finalizedAt: order.finalizedAt,
          };
          return optimizedOrder;
        }
        return null;
      }),
    );
    return ordersWithAggregates.filter(
      (order): order is Order => order !== null,
    );
  }
  async findByStatus(statuses: string[]): Promise<Order[]> {
    const entities = await this.ordersRepository.find({
      where: {
        orderStatus: In(statuses as any),
      },
      relations: [
        'user',
        'table',
        'shift',
        'orderItems',
        'payments',
        'deliveryInfo',
      ],
      order: {
        createdAt: 'DESC',
      },
    });
    return entities
      .map((entity) => this.orderMapper.toDomain(entity))
      .filter((order): order is Order => order !== null);
  }
  async findOrderForFinalizationById(id: string): Promise<Order | null> {
    const entity = await this.ordersRepository.findOne({
      where: { id },
      relations: [
        'user',
        'table',
        'table.area',
        'shift',
        'orderItems',
        'orderItems.product',
        'orderItems.product.preparationScreen',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.preparedBy',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'payments',
        'adjustments',
        'deliveryInfo',
        'preparationScreenStatuses',
        'preparationScreenStatuses.preparationScreen',
        'ticketImpressions',
        'ticketImpressions.user',
        'ticketImpressions.printer',
      ],
    });
    if (!entity) {
      return null;
    }
    return this.orderMapper.toDomain(entity);
  }
  private async getNextShiftOrderNumber(shiftId: string): Promise<number> {
    const lastOrder = await this.ordersRepository.findOne({
      where: { shiftId },
      order: { shiftOrderNumber: 'DESC' },
      select: ['shiftOrderNumber'],
    });
    return lastOrder ? lastOrder.shiftOrderNumber + 1 : 1;
  }
}

================
File: app/src/modules/receipts/screens/ReceiptsScreen.tsx
================
import React, { useState, useCallback, useMemo } from 'react';
import {
  View,
  FlatList,
  RefreshControl,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import {
  Text,
  Searchbar,
  Chip,
  Surface,
  ActivityIndicator,
  Menu,
  IconButton,
  Divider,
  Badge,
  Icon,
} from 'react-native-paper';
import OrderSummaryCard from '@/modules/shared/components/OrderSummaryCard';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useReceipts, useRecoverOrder } from '../hooks/useReceiptsQueries';
import type { Receipt, ReceiptList } from '../types/receipt.types';
import { getPaymentStatus } from '@/app/utils/orderFormatters';
import { receiptService } from '../services/receiptService';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import EmptyState from '@/app/components/common/EmptyState';
import { ReceiptDetailsModal } from '../components/ReceiptDetailsModal';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { DatePickerModal } from 'react-native-paper-dates';
import { OrderTypeEnum } from '@/modules/orders/types/orders.types';
import { formatOrderTypeShort } from '@/app/utils/orderFormatters';
type StatusFilter = 'all' | 'COMPLETED' | 'CANCELLED';
export const ReceiptsScreen: React.FC = () => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [startDate, setStartDate] = useState<Date | undefined>(undefined);
  const [endDate, setEndDate] = useState<Date | undefined>(undefined);
  const [showDateRangePicker, setShowDateRangePicker] = useState(false);
  const [showFilterMenu, setShowFilterMenu] = useState(false);
  const [selectedReceipt, setSelectedReceipt] = useState<Receipt | null>(null);
  const [showDetailModal, setShowDetailModal] = useState(false);
  const [orderToRecover, setOrderToRecover] = useState<any>(null);
  const [showRecoverConfirm, setShowRecoverConfirm] = useState(false);
  const recoverOrderMutation = useRecoverOrder();
  const filters = useMemo(() => {
    const baseFilters: any = {};
    if (startDate) {
      baseFilters.startDate = startDate.toISOString();
    }
    if (endDate) {
      baseFilters.endDate = endDate.toISOString();
    }
    return baseFilters;
  }, [startDate, endDate]);
  const {
    data: allReceipts,
    isLoading,
    refetch,
    isRefetching,
  } = useReceipts(filters);
  useRefreshModuleOnFocus('receipts');
  const receipts = useMemo(() => {
    if (!allReceipts) return [];
    let filtered = [...allReceipts];
    if (statusFilter !== 'all') {
      filtered = filtered.filter(
        (receipt) => receipt.orderStatus === statusFilter,
      );
    }
    if (searchQuery.trim()) {
      const search = searchQuery.toLowerCase().trim();
      filtered = filtered.filter((receipt) => {
        if (receipt.shiftOrderNumber.toString().includes(search)) return true;
        if (receipt.deliveryInfo) {
          const { recipientName, recipientPhone, fullAddress } =
            receipt.deliveryInfo;
          if (recipientName?.toLowerCase().includes(search)) return true;
          if (recipientPhone?.includes(search)) return true;
          if (fullAddress?.toLowerCase().includes(search)) return true;
        }
        if (receipt.notes?.toLowerCase().includes(search)) return true;
        return false;
      });
    }
    return filtered;
  }, [allReceipts, statusFilter, searchQuery]);
  const handleReceiptPress = useCallback((receipt: ReceiptList) => {
    receiptService.getReceiptById(receipt.id).then((fullOrder) => {
      setSelectedReceipt(fullOrder);
      setShowDetailModal(true);
    });
  }, []);
  const handleClearFilters = useCallback(() => {
    setSearchQuery('');
    setStatusFilter('all');
    setStartDate(undefined);
    setEndDate(undefined);
  }, []);
  const handleRecoverPress = useCallback((receipt: ReceiptList) => {
    receiptService.getReceiptById(receipt.id).then((fullOrder) => {
      setOrderToRecover(fullOrder as any);
      setShowRecoverConfirm(true);
    });
  }, []);
  const handleConfirmRecover = useCallback(async () => {
    if (!orderToRecover) return;
    try {
      await recoverOrderMutation.mutateAsync(orderToRecover.id);
      setShowRecoverConfirm(false);
      setOrderToRecover(null);
    } catch (error) {
    }
  }, [orderToRecover, recoverOrderMutation]);
  const getReceiptStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return theme.colors.primary;
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceDisabled;
    }
  };
  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      default:
        return status;
    }
  };
  const hasActiveFilters = statusFilter !== 'all' || startDate || endDate;
  const renderRestoreAction = (item: ReceiptList) => (
    <TouchableOpacity
      style={styles.restoreContainer}
      onPress={() => handleRecoverPress(item)}
      activeOpacity={0.7}
    >
      <Surface style={styles.restoreButtonSurface} elevation={2}>
        <IconButton
          icon="restore"
          size={36}
          iconColor={theme.colors.primary}
          style={styles.restoreButton}
        />
      </Surface>
    </TouchableOpacity>
  );
  const renderReceiptItem = ({ item }: { item: ReceiptList }) => (
    <OrderSummaryCard
      item={item}
      onPress={() => handleReceiptPress(item)}
      renderActions={renderRestoreAction}
      getStatusColor={getReceiptStatusColor}
      getStatusLabel={getStatusLabel}
    />
  );
  const renderEmptyComponent = () => {
    if (isLoading) {
      return (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }
    return (
      <EmptyState
        icon="receipt"
        title="No hay recibos"
        message={
          hasActiveFilters
            ? 'No se encontraron recibos con los filtros seleccionados'
            : 'Los recibos de órdenes completadas o canceladas aparecerán aquí'
        }
        actionLabel={hasActiveFilters ? 'Limpiar filtros' : undefined}
        onAction={hasActiveFilters ? handleClearFilters : undefined}
      />
    );
  };
  return (
    <View style={styles.container}>
      {}
      <Surface style={styles.header} elevation={2}>
        <Surface style={styles.shiftIndicator} elevation={1}>
          <Icon source="cash-register" size={20} color={theme.colors.primary} />
          <Text style={styles.shiftText}>Recibos del turno actual</Text>
          <View style={styles.shiftBadge}>
            <Text style={styles.shiftBadgeText}>ACTIVO</Text>
          </View>
        </Surface>
        <View style={styles.searchContainer}>
          <Searchbar
            placeholder="Buscar por nombre, teléfono o dirección..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
          />
          <View style={styles.filterButton}>
            <Menu
              visible={showFilterMenu}
              onDismiss={() => setShowFilterMenu(false)}
              anchor={
                <IconButton
                  icon="filter-variant"
                  onPress={() => setShowFilterMenu(true)}
                  style={[
                    styles.filterIconButton,
                    hasActiveFilters && styles.filterIconButtonActive,
                  ]}
                />
              }
            >
              <Menu.Item
                title="Todos los estados"
                onPress={() => {
                  setStatusFilter('all');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'all' ? 'check' : undefined}
              />
              <Menu.Item
                title="Completadas"
                onPress={() => {
                  setStatusFilter('COMPLETED');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'COMPLETED' ? 'check' : undefined}
              />
              <Menu.Item
                title="Canceladas"
                onPress={() => {
                  setStatusFilter('CANCELLED');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'CANCELLED' ? 'check' : undefined}
              />
              <Divider />
              <Menu.Item
                title={
                  startDate && endDate
                    ? `${format(startDate, 'd/M/yyyy')} - ${format(endDate, 'd/M/yyyy')}`
                    : 'Seleccionar rango de fechas'
                }
                onPress={() => {
                  setShowDateRangePicker(true);
                  setShowFilterMenu(false);
                }}
                leadingIcon="calendar-range"
              />
              {hasActiveFilters && (
                <>
                  <Divider />
                  <Menu.Item
                    title="Limpiar filtros"
                    onPress={() => {
                      handleClearFilters();
                      setShowFilterMenu(false);
                    }}
                    leadingIcon="filter-remove"
                  />
                </>
              )}
            </Menu>
            {hasActiveFilters && <Badge size={8} style={styles.filterBadge} />}
          </View>
        </View>
        {}
        {hasActiveFilters && (
          <View style={styles.activeFilters}>
            {statusFilter !== 'all' && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setStatusFilter('all')}
                style={styles.filterChip}
              >
                {statusFilter === 'COMPLETED' ? 'Completadas' : 'Canceladas'}
              </Chip>
            )}
            {startDate && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setStartDate(undefined)}
                style={styles.filterChip}
              >
                Desde: {format(startDate, 'd/M')}
              </Chip>
            )}
            {endDate && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setEndDate(undefined)}
                style={styles.filterChip}
              >
                Hasta: {format(endDate, 'd/M')}
              </Chip>
            )}
          </View>
        )}
      </Surface>
      {}
      <FlatList
        data={receipts}
        renderItem={renderReceiptItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={refetch}
            colors={[theme.colors.primary]}
          />
        }
        ListEmptyComponent={renderEmptyComponent}
      />
      {}
      <ReceiptDetailsModal
        visible={showDetailModal}
        onDismiss={() => {
          setShowDetailModal(false);
          setSelectedReceipt(null);
        }}
        receipt={selectedReceipt}
      />
      {}
      <ConfirmationModal
        visible={showRecoverConfirm}
        title="Recuperar Orden"
        message={`¿Estás seguro de que deseas recuperar la orden #${orderToRecover?.shiftOrderNumber}?\n\nLa orden se marcará como entregada y volverá a estar visible en las órdenes activas.`}
        onConfirm={handleConfirmRecover}
        onCancel={() => {
          setShowRecoverConfirm(false);
          setOrderToRecover(null);
        }}
        confirmText="Confirmar"
        cancelText="Cancelar"
      />
      {}
      <DatePickerModal
        visible={showDateRangePicker}
        mode="range"
        onDismiss={() => setShowDateRangePicker(false)}
        startDate={startDate}
        endDate={endDate}
        onConfirm={(params) => {
          setStartDate(params.startDate);
          setEndDate(params.endDate);
          setShowDateRangePicker(false);
        }}
        validRange={{
          endDate: new Date(),
        }}
        locale="es"
        saveLabel="Confirmar"
        startLabel="Desde"
        endLabel="Hasta"
        label="Seleccionar rango de fechas"
      />
    </View>
  );
};
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: 16,
      paddingVertical: 12,
    },
    searchContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    searchbar: {
      flex: 1,
    },
    filterButton: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
    },
    filterIconButtonActive: {
      backgroundColor: 'rgba(0, 0, 0, 0.08)',
    },
    filterBadge: {
      position: 'absolute',
      top: 8,
      right: 8,
    },
    activeFilters: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: 8,
      marginTop: 12,
    },
    filterChip: {
      height: 32,
    },
    listContent: {
      padding: theme.spacing.s,
      paddingBottom: theme.spacing.l * 2,
      flexGrow: 1,
    },
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 12,
      flexShrink: 1,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: 120,
      gap: 8,
      flexShrink: 0,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 15,
      fontWeight: '700',
    },
    orderTime: {
      fontSize: 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: 14,
      marginLeft: 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: 11,
      fontWeight: '600',
      lineHeight: 14,
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: 8,
      marginTop: 4,
    },
    restoreContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    restoreButtonSurface: {
      borderRadius: 20,
      backgroundColor: theme.colors.primaryContainer,
      overflow: 'hidden',
    },
    restoreButton: {
      margin: 0,
      width: 44,
      height: 44,
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 32,
    },
    shiftIndicator: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
      paddingVertical: 8,
      paddingHorizontal: 16,
      marginBottom: 8,
      borderRadius: 20,
      backgroundColor: theme.colors.primaryContainer,
    },
    shiftText: {
      ...theme.fonts.bodyMedium,
      color: theme.colors.onPrimaryContainer,
      fontWeight: '600',
    },
    shiftBadge: {
      backgroundColor: theme.colors.primary,
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 10,
    },
    shiftBadgeText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: theme.colors.onPrimary,
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 4,
    },
    miniPreparationText: {
      fontSize: 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginLeft: 4,
    },
    createdByText: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
      textAlign: 'right',
    },
  });

================
File: backend/src/orders/orders.controller.ts
================
import {
  DefaultValuePipe,
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  ParseUUIDPipe,
  ParseIntPipe,
  HttpCode,
  HttpStatus,
  UseGuards,
} from '@nestjs/common';
import { OrdersService } from './orders.service';
import { CreateOrderDto } from './dto/create-order.dto';
import { UpdateOrderDto } from './dto/update-order.dto';
import { Order } from './domain/order';
import { OrderForFinalizationDto } from './dto/order-for-finalization.dto';
import { OrderForFinalizationListDto } from './dto/order-for-finalization-list.dto';
import { OrderOpenListDto } from './dto/order-open-list.dto';
import { ReceiptListDto } from './dto/receipt-list.dto';
import { ReceiptDetailDto } from './dto/receipt-detail.dto';
import { OrderType } from './domain/enums/order-type.enum';
import { CreateOrderItemDto } from './dto/create-order-item.dto';
import { UpdateOrderItemDto } from './dto/update-order-item.dto';
import { OrderItem } from './domain/order-item';
import { OrderStatus } from './domain/enums/order-status.enum';
import { FinalizeOrdersDto } from './dto/finalize-orders.dto';
import {
  ApiBearerAuth,
  ApiOperation,
  ApiResponse,
  ApiTags,
  ApiParam,
  ApiBody,
  ApiQuery,
} from '@nestjs/swagger';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';
import { RoleEnum } from '../roles/roles.enum';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import {
  OrderChangeLogService,
  EnrichedOrderHistoryDto,
} from './order-change-log.service';
import {
  InfinityPaginationResponseDto,
  InfinityPaginationResponse,
} from '../utils/dto/infinity-pagination-response.dto';
import { infinityPagination } from '../utils/infinity-pagination';
import { plainToInstance } from 'class-transformer';
import { IPaginationOptions } from '../utils/types/pagination-options';
@ApiTags('orders')
@Controller({ path: 'orders', version: '1' })
export class OrdersController {
  constructor(
    private readonly ordersService: OrdersService,
    private readonly orderChangeLogService: OrderChangeLogService,
  ) {}
  @Post()
  @ApiOperation({ summary: 'Create a new order' })
  @ApiResponse({
    status: 201,
    description: 'The order has been successfully created.',
    type: Order,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  create(@Body() createOrderDto: CreateOrderDto): Promise<Order> {
    return this.ordersService.create(createOrderDto);
  }
  @Get('open-today')
  @ApiOperation({ summary: 'Obtener las órdenes abiertas del turno actual' })
  @ApiResponse({
    status: 200,
    description: 'Lista de órdenes abiertas del turno actual.',
    type: [Order],
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @HttpCode(HttpStatus.OK)
  findOpenOrders(): Promise<Order[]> {
    return this.ordersService.findOpenOrders();
  }
  @Get('open-current-shift')
  @ApiOperation({ summary: 'Obtener las órdenes abiertas del turno actual' })
  @ApiResponse({
    status: 200,
    description: 'Lista de órdenes abiertas del turno actual.',
    type: [Order],
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @HttpCode(HttpStatus.OK)
  findOpenOrdersCurrentShift(): Promise<Order[]> {
    return this.ordersService.findOpenOrders();
  }
  @Get('open-orders-list')
  @ApiOperation({ summary: 'Obtener lista optimizada de órdenes abiertas' })
  @ApiResponse({
    status: 200,
    description:
      'Lista optimizada de órdenes abiertas con campos mínimos necesarios.',
    type: [OrderOpenListDto],
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @HttpCode(HttpStatus.OK)
  async findOpenOrdersList(): Promise<OrderOpenListDto[]> {
    return this.ordersService.findOpenOrdersOptimized();
  }
  @Get('receipts-list')
  @ApiOperation({
    summary:
      'Obtener lista optimizada de recibos del turno actual (órdenes completadas/canceladas)',
  })
  @ApiResponse({
    status: 200,
    description:
      'Lista optimizada de recibos del turno actual con campos mínimos necesarios.',
    type: [ReceiptListDto],
  })
  @ApiQuery({ name: 'startDate', required: false, type: String })
  @ApiQuery({ name: 'endDate', required: false, type: String })
  @ApiQuery({ name: 'orderType', required: false, enum: OrderType })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier)
  @HttpCode(HttpStatus.OK)
  async findReceiptsList(
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('orderType') orderType?: OrderType,
  ): Promise<ReceiptListDto[]> {
    const filterOptions: any = {};
    if (startDate) {
      filterOptions.startDate = new Date(startDate);
    }
    if (endDate) {
      filterOptions.endDate = new Date(endDate);
    }
    if (orderType) {
      filterOptions.orderType = orderType;
    }
    return this.ordersService.getReceiptsList(filterOptions);
  }
  @Get('receipts/:id')
  @ApiOperation({ summary: 'Obtener detalle completo de un recibo' })
  @ApiResponse({
    status: 200,
    description: 'Detalle completo del recibo con todos los datos necesarios.',
    type: ReceiptDetailDto,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @HttpCode(HttpStatus.OK)
  async getReceiptDetail(
    @Param('id', ParseUUIDPipe) id: string,
  ): Promise<ReceiptDetailDto> {
    return this.ordersService.getReceiptDetail(id);
  }
  @Get('for-finalization/list')
  @ApiOperation({ summary: 'Obtener lista ligera de órdenes para finalizar' })
  @ApiResponse({
    status: 200,
    description: 'Lista optimizada de órdenes para la vista de lista.',
    type: [OrderForFinalizationListDto],
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @HttpCode(HttpStatus.OK)
  async findOrdersForFinalizationList(): Promise<
    OrderForFinalizationListDto[]
  > {
    return this.ordersService.findOrdersForFinalizationList();
  }
  @Get('items/:id')
  @ApiOperation({ summary: 'Get a specific order item by ID' })
  @ApiResponse({
    status: 200,
    description: 'Return the order item with the specified ID.',
    type: OrderItem,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  findOrderItemById(
    @Param('id', ParseUUIDPipe) id: string,
  ): Promise<OrderItem> {
    return this.ordersService.findOrderItemById(id);
  }
  @Patch('finalize-multiple')
  @ApiOperation({ summary: 'Finalizar múltiples órdenes' })
  @ApiResponse({
    status: 200,
    description: 'Las órdenes han sido finalizadas exitosamente.',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @HttpCode(HttpStatus.OK)
  finalizeMultipleOrders(
    @Body() finalizeOrdersDto: FinalizeOrdersDto,
    @CurrentUser('id') userId: string,
  ): Promise<void> {
    return this.ordersService.finalizeMultipleOrders(finalizeOrdersDto, userId);
  }
  @Post('quick-finalize-multiple')
  @ApiOperation({
    summary: 'Finalización rápida de múltiples órdenes',
    description:
      'Finaliza múltiples órdenes de forma rápida, registrando automáticamente un pago en efectivo por el monto pendiente de cada una y cambiando su estado a COMPLETED.',
  })
  @ApiResponse({
    status: 200,
    description: 'Las órdenes han sido finalizadas exitosamente.',
  })
  @ApiResponse({
    status: 400,
    description: 'Una o más órdenes no pueden ser finalizadas.',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @HttpCode(HttpStatus.OK)
  async quickFinalizeMultipleOrders(
    @Body() dto: { orderIds: string[] },
    @CurrentUser('id') userId: string,
  ): Promise<{ message: string; ordersWithWarnings: string[] }> {
    const result = await this.ordersService.quickFinalizeMultipleOrders(
      dto.orderIds,
      userId,
    );
    return {
      message: 'Órdenes finalizadas exitosamente',
      ordersWithWarnings: result.ordersWithWarnings,
    };
  }
  @Patch('items/:id')
  @ApiOperation({ summary: 'Update a specific order item by ID' })
  @ApiResponse({
    status: 200,
    description: 'The order item has been successfully updated.',
    type: OrderItem,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  updateOrderItem(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updateOrderItemDto: UpdateOrderItemDto,
  ): Promise<OrderItem> {
    return this.ordersService.updateOrderItem(id, updateOrderItemDto);
  }
  @Delete('items/:id')
  @ApiOperation({ summary: 'Delete a specific order item by ID' })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'The order item has been successfully deleted.',
  })
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  removeOrderItem(@Param('id', ParseUUIDPipe) id: string): Promise<void> {
    return this.ordersService.deleteOrderItem(id);
  }
  @Get('for-finalization/:id')
  @ApiOperation({
    summary: 'Obtener detalle completo de una orden para finalización',
  })
  @ApiResponse({
    status: 200,
    description:
      'Detalle completo de la orden con todos sus items y relaciones.',
    type: OrderForFinalizationDto,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @HttpCode(HttpStatus.OK)
  findOrderForFinalizationById(
    @Param('id', ParseUUIDPipe) id: string,
  ): Promise<OrderForFinalizationDto> {
    return this.ordersService.findOrderForFinalizationById(id);
  }
  @Get('user/:userId')
  @ApiOperation({ summary: 'Get all orders for a specific user' })
  @ApiResponse({
    status: 200,
    description: 'Return all orders for the specified user.',
    type: [Order],
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  findByUserId(
    @Param('userId', ParseUUIDPipe) userId: string,
  ): Promise<Order[]> {
    return this.ordersService.findByUserId(userId);
  }
  @Get('table/:tableId')
  @ApiOperation({ summary: 'Get all orders for a specific table' })
  @ApiResponse({
    status: 200,
    description: 'Return all orders for the specified table.',
    type: [Order],
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  findByTableId(
    @Param('tableId', ParseUUIDPipe) tableId: string,
  ): Promise<Order[]> {
    return this.ordersService.findByTableId(tableId);
  }
  @Get('shift/:shiftId')
  @ApiOperation({
    summary:
      'Get all orders for a specific shift with preparation status summary',
  })
  @ApiResponse({
    status: 200,
    description:
      'Return all orders for the specified shift with calculated preparation screen statuses.',
    type: [Order],
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  findByShiftId(
    @Param('shiftId', ParseUUIDPipe) shiftId: string,
  ): Promise<any[]> {
    return this.ordersService.findByShiftId(shiftId);
  }
  @Get(':id')
  @ApiOperation({ summary: 'Get a specific order by ID' })
  @ApiResponse({
    status: 200,
    description: 'Return the order with the specified ID.',
    type: Order,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  findOne(@Param('id', ParseUUIDPipe) id: string): Promise<Order> {
    return this.ordersService.findOne(id);
  }
  @Patch(':id')
  @ApiOperation({ summary: 'Update a specific order by ID' })
  @ApiResponse({
    status: 200,
    description: 'The order has been successfully updated.',
    type: Order,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  update(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updateOrderDto: UpdateOrderDto,
  ): Promise<Order> {
    return this.ordersService.update(id, updateOrderDto);
  }
  @Delete(':id')
  @ApiOperation({ summary: 'Delete a specific order by ID' })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'The order has been successfully deleted.',
  })
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  remove(@Param('id', ParseUUIDPipe) id: string): Promise<void> {
    return this.ordersService.remove(id);
  }
  @Post(':id/recover')
  @ApiOperation({ summary: 'Recover a completed or cancelled order' })
  @ApiResponse({
    status: 200,
    description:
      'The order has been successfully recovered to DELIVERED status.',
    type: Order,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin)
  recoverOrder(@Param('id', ParseUUIDPipe) id: string): Promise<Order> {
    return this.ordersService.recoverOrder(id);
  }
  @Patch(':id/status')
  @ApiOperation({ summary: 'Change order status' })
  @ApiResponse({
    status: 200,
    description: 'The order status has been successfully changed.',
    type: Order,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  changeOrderStatus(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() body: { status: OrderStatus },
  ): Promise<Order> {
    return this.ordersService.changeOrderStatus(id, body.status);
  }
  @Post(':orderId/items')
  @ApiOperation({ summary: 'Create a new order item for an order' })
  @ApiResponse({
    status: 201,
    description: 'The order item has been successfully created.',
    type: OrderItem,
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  createOrderItem(
    @Param('orderId', ParseUUIDPipe) orderId: string,
    @Body() createOrderItemDto: CreateOrderItemDto,
  ): Promise<OrderItem> {
    createOrderItemDto.orderId = orderId;
    return this.ordersService.createOrderItem(createOrderItemDto);
  }
  @Get(':orderId/items')
  @ApiOperation({ summary: 'Get all order items for a specific order' })
  @ApiResponse({
    status: 200,
    description: 'Return all order items for the specified order.',
    type: [OrderItem],
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  findOrderItemsByOrderId(
    @Param('orderId', ParseUUIDPipe) orderId: string,
  ): Promise<OrderItem[]> {
    return this.ordersService.findOrderItemsByOrderId(orderId);
  }
  @Get(':id/history')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Get history for a specific order' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Return the history log for the specified order.',
    type: InfinityPaginationResponse(EnrichedOrderHistoryDto),
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(
    RoleEnum.admin,
    RoleEnum.manager,
    RoleEnum.cashier,
    RoleEnum.waiter,
    RoleEnum.kitchen,
  )
  async getOrderHistory(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,
    @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number,
  ): Promise<InfinityPaginationResponseDto<EnrichedOrderHistoryDto>> {
    const paginationOptions: IPaginationOptions = {
      page,
      limit: limit > 50 ? 50 : limit,
    };
    const [data] = await this.orderChangeLogService.findByOrderId(
      id,
      paginationOptions,
    );
    return infinityPagination(data, paginationOptions);
  }
  @Patch(':id/start-preparation')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Start order preparation',
    description:
      'Changes all pending items of an order to IN_PROGRESS status and updates order status',
  })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'Order preparation started successfully',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.kitchen)
  async startOrderPreparation(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser('id') userId: string,
  ): Promise<void> {
    await this.ordersService.changeOrderItemsStatus(
      id,
      userId,
      'PENDING',
      'IN_PROGRESS',
    );
    await this.ordersService.update(id, {
      orderStatus: OrderStatus.IN_PREPARATION,
    });
  }
  @Patch(':id/cancel-preparation')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Cancel order preparation',
    description:
      'Returns order to previous state. If order is READY goes back to IN_PREPARATION (items keep their state). If order is IN_PREPARATION goes back to IN_PROGRESS (all items go to PENDING).',
  })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'Order preparation cancelled successfully',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.kitchen)
  async cancelOrderPreparation(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser('id') userId: string,
  ): Promise<void> {
    const order = await this.ordersService.findOne(id);
    if (order.orderStatus === OrderStatus.READY) {
      await this.ordersService.update(id, {
        orderStatus: OrderStatus.IN_PREPARATION,
      });
    } else if (order.orderStatus === OrderStatus.IN_PREPARATION) {
      const hasInProgressItems = await this.ordersService.hasItemsWithStatus(
        id,
        'IN_PROGRESS',
      );
      if (hasInProgressItems) {
        await this.ordersService.changeOrderItemsStatus(
          id,
          userId,
          'IN_PROGRESS',
          'PENDING',
        );
      }
      const hasReadyItems = await this.ordersService.hasItemsWithStatus(
        id,
        'READY',
      );
      if (hasReadyItems) {
        await this.ordersService.changeOrderItemsStatus(
          id,
          userId,
          'READY',
          'PENDING',
        );
      }
      await this.ordersService.update(id, {
        orderStatus: OrderStatus.IN_PROGRESS,
      });
    }
  }
  @Patch(':id/complete-preparation')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Complete order preparation',
    description:
      'Changes all in-progress items of an order to READY status and updates order status',
  })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'Order preparation completed successfully',
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.kitchen)
  async completeOrderPreparation(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser('id') userId: string,
  ): Promise<void> {
    await this.ordersService.changeOrderItemsStatus(
      id,
      userId,
      'IN_PROGRESS',
      'READY',
    );
    await this.ordersService.update(id, {
      orderStatus: OrderStatus.READY,
    });
  }
  @Post(':id/print-ticket')
  @ApiOperation({ summary: 'Imprimir ticket de una orden' })
  @ApiParam({ name: 'id', type: 'string', description: 'ID de la orden' })
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        printerId: { type: 'string', description: 'ID de la impresora' },
        ticketType: {
          type: 'string',
          enum: ['GENERAL', 'BILLING'],
          description: 'Tipo de ticket a imprimir',
        },
      },
      required: ['printerId', 'ticketType'],
    },
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager, RoleEnum.cashier, RoleEnum.waiter)
  @HttpCode(HttpStatus.OK)
  async printTicket(
    @Param('id', ParseUUIDPipe) id: string,
    @Body()
    printTicketDto: { printerId: string; ticketType: 'GENERAL' | 'BILLING' },
    @CurrentUser('id') userId: string,
  ): Promise<void> {
    await this.ordersService.printOrderTicket(
      id,
      printTicketDto.printerId,
      printTicketDto.ticketType,
      userId,
    );
  }
  @Get('shift/:shiftId/sales-summary')
  @ApiOperation({
    summary: 'Obtener resumen de ventas de un turno',
    description:
      'Obtiene un resumen detallado de las ventas de un turno, agrupado por categorías, subcategorías y productos',
  })
  @ApiParam({
    name: 'shiftId',
    type: 'string',
    description: 'ID del turno',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Resumen de ventas del turno',
    schema: {
      type: 'object',
      properties: {
        shiftId: { type: 'string' },
        shiftNumber: { type: 'number' },
        date: { type: 'string', format: 'date' },
        totalSales: { type: 'number' },
        totalQuantity: { type: 'number' },
        completedOrders: { type: 'number' },
        averageTicket: { type: 'number' },
        categories: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              categoryId: { type: 'string' },
              categoryName: { type: 'string' },
              quantity: { type: 'number' },
              totalAmount: { type: 'number' },
              percentage: { type: 'number' },
              subcategories: { type: 'array' },
            },
          },
        },
        topProducts: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              productId: { type: 'string' },
              productName: { type: 'string' },
              quantity: { type: 'number' },
              totalAmount: { type: 'number' },
              averagePrice: { type: 'number' },
            },
          },
        },
        startTime: { type: 'string', format: 'date-time' },
        endTime: { type: 'string', format: 'date-time', nullable: true },
      },
    },
  })
  @ApiBearerAuth()
  @UseGuards(AuthGuard('jwt'), RolesGuard)
  @Roles(RoleEnum.admin, RoleEnum.manager)
  async getShiftSalesSummary(@Param('shiftId', ParseUUIDPipe) shiftId: string) {
    return this.ordersService.getShiftSalesSummary(shiftId);
  }
}

================
File: app/src/modules/orderFinalization/screens/OrderFinalizationScreen.tsx
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { FlashList } from '@shopify/flash-list';
import {
  Surface,
  Text,
  ActivityIndicator,
  Icon,
  Button,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { OrderCard } from '../components/OrderCard';
import { OrderDetailsModal } from '../components/OrderDetailsModal';
import { PrintTicketModal } from '@/modules/shared/components/PrintTicketModal';
import {
  useOrdersForFinalizationList,
  useOrderForFinalizationDetail,
} from '../hooks/useOrderFinalizationQueries';
import {
  OrderFinalizationFilter,
  OrderSelectionState,
  OrderForFinalizationList,
} from '../types/orderFinalization.types';
import EmptyState from '@/app/components/common/EmptyState';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { orderFinalizationService } from '../services/orderFinalizationService';
export const OrderFinalizationScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [filter, setFilter] = useState<OrderFinalizationFilter>('delivery');
  const [selectionState, setSelectionState] = useState<OrderSelectionState>({
    selectedOrders: new Set(),
    totalAmount: 0,
  });
  const [selectedOrderIdForDetails, setSelectedOrderIdForDetails] = useState<
    string | null
  >(null);
  const [showConfirmationModal, setShowConfirmationModal] = useState(false);
  const [isFinalizingOrders, setIsFinalizingOrders] = useState(false);
  const [showPrintModal, setShowPrintModal] = useState(false);
  const [selectedOrderForPrint, setSelectedOrderForPrint] =
    useState<OrderForFinalizationList | null>(null);
  const {
    data: orders = [],
    isLoading,
    refetch,
  } = useOrdersForFinalizationList();
  const { data: selectedOrderDetails, isLoading: isLoadingDetails } =
    useOrderForFinalizationDetail(selectedOrderIdForDetails);
  const { data: orderForPrint } = useOrderForFinalizationDetail(
    selectedOrderForPrint?.id || null,
  );
  const filteredOrders = useMemo(() => {
    if (!orders || !Array.isArray(orders)) return [];
    return orders.filter((order) => {
      switch (filter) {
        case 'delivery':
          return order.orderType === 'DELIVERY';
        case 'take_away':
          return order.orderType === 'TAKE_AWAY';
        case 'dine_in':
          return order.orderType === 'DINE_IN';
        default:
          return false;
      }
    });
  }, [orders, filter]);
  const orderCounts = useMemo(() => {
    if (!orders || !Array.isArray(orders)) {
      return {
        delivery: 0,
        take_away: 0,
        dine_in: 0,
      };
    }
    return orders.reduce(
      (counts, order) => {
        switch (order.orderType) {
          case 'DELIVERY':
            counts.delivery++;
            break;
          case 'TAKE_AWAY':
            counts.take_away++;
            break;
          case 'DINE_IN':
            counts.dine_in++;
            break;
        }
        return counts;
      },
      { delivery: 0, take_away: 0, dine_in: 0 },
    );
  }, [orders]);
  useEffect(() => {
    setSelectionState({
      selectedOrders: new Set(),
      totalAmount: 0,
    });
  }, [filter]);
  const handleToggleOrderSelection = useCallback(
    (orderId: string) => {
      if (!orders || !Array.isArray(orders)) return;
      const order = orders.find((o) => o.id === orderId);
      if (!order) return;
      setSelectionState((prevState) => {
        const newSelectedOrders = new Set(prevState.selectedOrders);
        let newTotalAmount = prevState.totalAmount;
        const orderTotal =
          typeof order.total === 'string'
            ? parseFloat(order.total)
            : order.total;
        const paymentsSummary = order.paymentsSummary;
        const paid = paymentsSummary?.totalPaid || 0;
        const pendingAmount = orderTotal - paid;
        if (newSelectedOrders.has(orderId)) {
          newSelectedOrders.delete(orderId);
          newTotalAmount -= pendingAmount;
        } else {
          newSelectedOrders.add(orderId);
          newTotalAmount += pendingAmount;
        }
        return {
          selectedOrders: newSelectedOrders,
          totalAmount: newTotalAmount,
        };
      });
    },
    [orders],
  );
  const ordersNotReady = useMemo(() => {
    if (selectionState.selectedOrders.size === 0) return [];
    const selectedOrdersList = Array.from(selectionState.selectedOrders)
      .map((id) => orders.find((o) => o.id === id))
      .filter(Boolean) as OrderForFinalizationList[];
    return selectedOrdersList.filter((order) => order.orderStatus !== 'READY');
  }, [selectionState.selectedOrders, orders]);
  const confirmationMessage = useMemo(() => {
    let message = `¿Desea finalizar ${selectionState.selectedOrders.size} ${
      selectionState.selectedOrders.size === 1 ? 'orden' : 'órdenes'
    }?\n\nTotal a cobrar: $${selectionState.totalAmount.toFixed(2)}`;
    if (ordersNotReady.length > 0) {
      message += `\n\n⚠️ ADVERTENCIA: ${ordersNotReady.length} ${
        ordersNotReady.length === 1 ? 'orden no está' : 'órdenes no están'
      } en estado "Listo"`;
    }
    return message;
  }, [selectionState, ordersNotReady]);
  const handleQuickFinalizeOrders = useCallback(() => {
    if (selectionState.selectedOrders.size === 0) return;
    setShowConfirmationModal(true);
  }, [selectionState.selectedOrders.size]);
  const handleConfirmFinalization = useCallback(async () => {
    setIsFinalizingOrders(true);
    try {
      await orderFinalizationService.quickFinalizeMultipleOrders(
        Array.from(selectionState.selectedOrders),
      );
      showSnackbar({
        message: 'Órdenes finalizadas exitosamente',
        type: 'success',
      });
      setSelectionState({
        selectedOrders: new Set(),
        totalAmount: 0,
      });
      setShowConfirmationModal(false);
      refetch();
    } catch (error) {
      showSnackbar({
        message: 'Error al finalizar las órdenes',
        type: 'error',
      });
    } finally {
      setIsFinalizingOrders(false);
    }
  }, [selectionState.selectedOrders, showSnackbar, refetch]);
  const handleShowOrderDetails = useCallback(
    (order: OrderForFinalizationList) => {
      setSelectedOrderIdForDetails(null);
      setTimeout(() => {
        setSelectedOrderIdForDetails(order.id);
      }, 50);
    },
    [],
  );
  const handlePrintPress = useCallback(() => {
    setShowPrintModal(true);
  }, []);
  const handlePrintFromList = useCallback(
    async (order: OrderForFinalizationList) => {
      setSelectedOrderForPrint(order);
      setShowPrintModal(true);
    },
    [],
  );
  const handlePrint = useCallback(
    async (printerId: string, ticketType: 'GENERAL' | 'BILLING') => {
      const orderToUse = orderForPrint || selectedOrderDetails;
      if (!orderToUse) return;
      try {
        await orderFinalizationService.printTicket(orderToUse.id, {
          printerId,
          ticketType,
        });
        showSnackbar({
          message: 'Ticket impreso exitosamente',
          type: 'success',
        });
        await refetch();
        setSelectedOrderForPrint(null);
      } catch (error) {
        showSnackbar({
          message: 'Error al imprimir el ticket',
          type: 'error',
        });
      }
    },
    [orderForPrint, selectedOrderDetails, showSnackbar, refetch],
  );
  const renderOrderCard = useCallback(
    ({ item }) => (
      <OrderCard
        order={item}
        isSelected={selectionState.selectedOrders.has(item.id)}
        onToggleSelection={handleToggleOrderSelection}
        onShowDetails={handleShowOrderDetails}
        onPrintPress={handlePrintFromList}
      />
    ),
    [
      selectionState.selectedOrders,
      handleToggleOrderSelection,
      handleShowOrderDetails,
      handlePrintFromList,
    ],
  );
  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text
          style={[styles.loadingText, { color: theme.colors.onSurfaceVariant }]}
        >
          Cargando órdenes...
        </Text>
      </View>
    );
  }
  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      edges={['top']}
    >
      <Surface style={styles.header}>
        <View style={styles.headerContent}>
          <View style={styles.filterContainer}>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'delivery' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'delivery'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('delivery')}
            >
              <Icon
                source="moped"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'delivery'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.delivery > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'delivery'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'delivery'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'delivery'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.delivery}
                  </Text>
                </View>
              )}
            </Pressable>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'take_away' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'take_away'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('take_away')}
            >
              <Icon
                source="bag-personal"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'take_away'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.take_away > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'take_away'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'take_away'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'take_away'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.take_away}
                  </Text>
                </View>
              )}
            </Pressable>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'dine_in' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'dine_in'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('dine_in')}
            >
              <Icon
                source="silverware-fork-knife"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'dine_in'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.dine_in > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'dine_in'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'dine_in'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'dine_in'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.dine_in}
                  </Text>
                </View>
              )}
            </Pressable>
          </View>
          <View style={styles.refreshButtonContainer}>
            <IconButton
              icon="refresh"
              size={responsive.isTablet ? 20 : 24}
              mode="contained"
              containerColor={theme.colors.surfaceVariant}
              iconColor={theme.colors.onSurfaceVariant}
              onPress={() => refetch()}
              style={styles.refreshButton}
            />
          </View>
        </View>
      </Surface>
      <View style={styles.content}>
        {filteredOrders.length === 0 ? (
          <EmptyState
            title="No hay órdenes para finalizar"
            description="Las órdenes aparecerán aquí cuando estén listas para finalizar"
            icon="clipboard-check-outline"
          />
        ) : (
          <FlashList
            data={filteredOrders}
            keyExtractor={(item) => item.id}
            renderItem={renderOrderCard}
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => null}
            onRefresh={refetch}
            refreshing={isLoading}
            estimatedItemSize={150}
            removeClippedSubviews={true}
          />
        )}
      </View>
      {selectionState.selectedOrders.size > 0 && (
        <Surface style={styles.floatingButton} elevation={8}>
          <Button
            mode="contained"
            onPress={handleQuickFinalizeOrders}
            style={styles.finalizeButton}
            labelStyle={styles.finalizeButtonLabel}
            disabled={isFinalizingOrders}
          >
            Finalizar ({selectionState.selectedOrders.size}) - $
            {(selectionState.totalAmount || 0).toFixed(2)}
          </Button>
        </Surface>
      )}
      <OrderDetailsModal
        visible={selectedOrderIdForDetails !== null}
        onDismiss={() => setSelectedOrderIdForDetails(null)}
        order={selectedOrderDetails}
        isLoading={isLoadingDetails}
        onPrintPress={handlePrintPress}
      />
      <PrintTicketModal
        visible={showPrintModal}
        onDismiss={() => {
          setShowPrintModal(false);
          setSelectedOrderForPrint(null);
        }}
        order={orderForPrint || selectedOrderDetails}
        onPrint={handlePrint}
      />
      <ConfirmationModal
        visible={showConfirmationModal}
        title="Finalizar Órdenes"
        message={confirmationMessage}
        onConfirm={handleConfirmFinalization}
        onCancel={() => setShowConfirmationModal(false)}
        onDismiss={() => setShowConfirmationModal(false)}
        confirmText={isFinalizingOrders ? 'Finalizando...' : 'Finalizar'}
        confirmButtonColor={
          ordersNotReady.length > 0 ? theme.colors.error : theme.colors.primary
        }
      />
    </SafeAreaView>
  );
};
const createStyles = (
  theme: typeof useAppTheme,
  responsive: typeof useResponsive,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: 0,
      paddingVertical: 0,
      backgroundColor: 'transparent',
      elevation: 0,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    filterContainer: {
      flex: 1,
      flexDirection: 'row',
      gap: 0,
    },
    refreshButtonContainer: {
      paddingHorizontal: responsive.isTablet ? 6 : 8,
    },
    refreshButton: {
      margin: 0,
    },
    filterButton: {
      flex: 1,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 0,
      elevation: 1,
      position: 'relative',
    },
    filterButtonActive: {
      elevation: 3,
    },
    countBadge: {
      position: 'absolute',
      top: responsive.isTablet ? 4 : 6,
      right: responsive.isTablet ? 4 : 6,
      minWidth: responsive.isTablet ? 18 : 22,
      height: responsive.isTablet ? 18 : 22,
      borderRadius: responsive.isTablet ? 9 : 11,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      borderWidth: 1,
      elevation: 2,
    },
    countBadgeText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '700',
    },
    floatingButton: {
      position: 'absolute',
      bottom: responsive.isTablet ? 12 : 16,
      left: responsive.isTablet ? 12 : 16,
      right: responsive.isTablet ? 12 : 16,
      borderRadius: responsive.isTablet ? 12 : 16,
      padding: responsive.isTablet ? 6 : 8,
      elevation: 8,
    },
    finalizeButton: {
      borderRadius: responsive.isTablet ? 10 : 12,
      paddingVertical: responsive.isTablet ? 3 : 4,
    },
    finalizeButtonLabel: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: '700',
      letterSpacing: 0.5,
    },
    content: {
      flex: 1,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.isTablet ? 8 : 12,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    listContent: {
      padding: responsive.isTablet ? 6 : 8,
      paddingBottom: responsive.isTablet ? 80 : 100,
    },
  });

================
File: app/src/modules/orders/components/OrderCartDetail.tsx
================
import React, { useState, useMemo, useEffect, useCallback } from 'react';
import { Portal } from 'react-native-paper';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  TouchableWithoutFeedback,
  Keyboard,
  Animated,
} from 'react-native';
import {
  Swipeable,
  GestureHandlerRootView,
} from 'react-native-gesture-handler';
import {
  Text,
  Divider,
  List,
  Button,
  RadioButton,
  HelperText,
  Menu,
  IconButton,
  Modal,
  Checkbox,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { OrderTypeEnum, type OrderType } from '../types/orders.types';
import { useGetAreas } from '@/modules/areasTables/services/areaService';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';
import OrderHeader from './OrderHeader';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import ProductCustomizationModal from './ProductCustomizationModal';
import type { FullMenuProduct as Product } from '../types/orders.types';
import { useGetTablesByArea } from '@/modules/areasTables/services/tableService';
import type { Table } from '@/modules/areasTables/types/areasTables.types';
import { canRegisterPayments as checkCanRegisterPayments } from '@/app/utils/roleUtils';
import {
  useCartStore,
  CartItem,
  CartItemModifier,
} from '../stores/useCartStore';
import { useOrderFormStore } from '../stores/useOrderFormStore';
import { useAuthStore } from '@/app/store/authStore';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useGetOrderByIdQuery } from '../hooks/useOrdersQueries';
import { useGetOrderMenu } from '../hooks/useMenuQueries';
import type { FullMenuCategory } from '../types/orders.types';
import OrderHistoryModal from '@/modules/shared/components/OrderHistoryModal';
import { OrderDetailModal } from './OrderDetailModal';
import PaymentModal from './PaymentModal';
import { FAB } from 'react-native-paper';
import { AdjustmentFormModal } from './AdjustmentFormModal';
import type { OrderAdjustment } from '../types/adjustments.types';
import { useGetPaymentsByOrderIdQuery } from '../hooks/usePaymentQueries';
import { PaymentStatusEnum } from '../types/payment.types';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import { prepaymentService } from '@/modules/payments/services/prepaymentService';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import type {
  OrderItemDtoForBackend,
  OrderItemModifierDto,
} from '../types/update-order.types';
export interface OrderDetailsForBackend {
  userId?: string;
  orderType: OrderType;
  subtotal: number;
  total: number;
  items: OrderItemDtoForBackend[];
  tableId?: string;
  isTemporaryTable?: boolean;
  temporaryTableName?: string;
  temporaryTableAreaId?: string;
  scheduledAt?: Date;
  deliveryInfo: DeliveryInfo;
  notes?: string;
  payment?: {
    amount: number;
    method: 'CASH' | 'CARD' | 'TRANSFER';
  };
  adjustments?: {
    orderId?: string;
    name: string;
    description?: string;
    isPercentage: boolean;
    value?: number;
    amount?: number;
  }[];
  customerId?: string;
  isFromWhatsApp?: boolean;
  prepaymentId?: string;
}
const formatOrderStatus = (status: string): string => {
  switch (status) {
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En Progreso';
    case 'IN_PREPARATION':
      return 'En Preparación';
    case 'READY':
      return 'Lista';
    case 'DELIVERED':
      return 'Entregada';
    case 'COMPLETED':
      return 'Completada';
    case 'CANCELLED':
      return 'Cancelada';
    default:
      return status;
  }
};
const getPreparationStatusColor = (status: string | undefined, theme: any) => {
  switch (status) {
    case 'NEW':
      return '#2196F3';
    case 'PENDING':
      return theme.colors.error;
    case 'IN_PROGRESS':
      return '#FFA000';
    case 'READY':
      return '#4CAF50';
    case 'DELIVERED':
      return theme.colors.tertiary;
    case 'CANCELLED':
      return theme.colors.onSurfaceDisabled;
    default:
      return theme.colors.onSurfaceVariant;
  }
};
const getPreparationStatusText = (status: string | undefined): string => {
  switch (status) {
    case 'NEW':
      return 'Nuevo';
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En Preparación';
    case 'READY':
      return 'Listo';
    case 'DELIVERED':
      return 'Entregado';
    case 'CANCELLED':
      return 'Cancelado';
    default:
      return '';
  }
};
interface OrderCartDetailProps {
  visible: boolean;
  onConfirmOrder: (details: OrderDetailsForBackend) => void;
  onClose?: () => void;
  onEditItem?: (item: CartItem) => void;
  isEditMode?: boolean;
  orderId?: string | null;
  orderNumber?: number;
  orderDate?: Date;
  onCancelOrder?: () => void; // Función para cancelar la orden
  navigation?: any; // Prop de navegación opcional para añadir productos
  onAddProducts?: () => void; // Callback para añadir productos
  pendingProductsToAdd?: CartItem[]; // Productos pendientes de añadir
  onItemsCountChanged?: (count: number) => void; // Callback cuando cambia el conteo de items
}
// Helper para obtener el color del estado de la orden
const getOrderStatusColor = (status: string, theme: any) => {
  switch (status) {
    case 'PENDING':
      return '#FFA000';
    case 'IN_PROGRESS':
      return theme.colors.primary;
    case 'IN_PREPARATION':
      return '#FF6B35';
    case 'READY':
      return '#4CAF50';
    case 'DELIVERED':
      return theme.colors.tertiary;
    case 'COMPLETED':
      return '#10B981';
    case 'CANCELLED':
      return theme.colors.error;
    default:
      return theme.colors.onSurfaceVariant;
  }
};
const OrderCartDetail: React.FC<OrderCartDetailProps> = ({
  visible,
  onConfirmOrder,
  onClose,
  onEditItem,
  isEditMode = false,
  orderId,
  orderNumber,
  orderDate,
  onCancelOrder,
  navigation,
  onAddProducts,
  pendingProductsToAdd = [],
  onItemsCountChanged,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const {
    data: orderData,
    isLoading: isLoadingOrder,
    isError: isErrorOrder,
    isSuccess: _isSuccessOrder,
    refetch: _refetchOrder,
  } = useGetOrderByIdQuery(orderId, {
    enabled: isEditMode && !!orderId && visible,
  });
  const { data: menu } = useGetOrderMenu();
  const { data: payments = [] } = useGetPaymentsByOrderIdQuery(orderId || '', {
    enabled: isEditMode && !!orderId && visible,
  });
  // Estados locales para modo edición (cuando no usamos el contexto del carrito)
  const [editItems, setEditItems] = useState<CartItem[]>([]);
  const [editOrderType, setEditOrderType] = useState<OrderType>(
    OrderTypeEnum.DINE_IN,
  );
  const [editSelectedAreaId, setEditSelectedAreaId] = useState<string | null>(
    null,
  );
  const [editSelectedTableId, setEditSelectedTableId] = useState<string | null>(
    null,
  );
  const [editScheduledTime, setEditScheduledTime] = useState<Date | null>(null);
  const [editDeliveryInfo, setEditDeliveryInfo] = useState<DeliveryInfo>({});
  const [editOrderNotes, setEditOrderNotes] = useState<string>('');
  const [editAdjustments, setEditAdjustments] = useState<OrderAdjustment[]>([]);
  const [editIsTemporaryTable, setEditIsTemporaryTable] =
    useState<boolean>(false);
  const [editTemporaryTableName, setEditTemporaryTableName] =
    useState<string>('');
  // Estados para controlar si ya procesamos los productos pendientes y si los datos de la orden ya se cargaron
  const [processedPendingProductsIds, setProcessedPendingProductsIds] =
    useState<string[]>([]);
  const [orderDataLoaded, setOrderDataLoaded] = useState(false);
  // Usar los stores separados en lugar del contexto unificado
  const cartStore = useCartStore();
  const orderFormStore = useOrderFormStore();
  const cartItems = !isEditMode ? cartStore.items : [];
  const removeCartItem = !isEditMode ? cartStore.removeItem : () => {};
  const updateCartItemQuantity = !isEditMode
    ? cartStore.updateItemQuantity
    : () => {};
  const isCartVisible = !isEditMode ? cartStore.isCartVisible : false;
  const cartOrderType = !isEditMode
    ? orderFormStore.orderType
    : OrderTypeEnum.DINE_IN;
  const setCartOrderType = !isEditMode ? orderFormStore.setOrderType : () => {};
  const cartSelectedAreaId = !isEditMode ? orderFormStore.selectedAreaId : null;
  const setCartSelectedAreaId = !isEditMode
    ? orderFormStore.setSelectedAreaId
    : () => {};
  const cartSelectedTableId = !isEditMode
    ? orderFormStore.selectedTableId
    : null;
  const setCartSelectedTableId = !isEditMode
    ? orderFormStore.setSelectedTableId
    : () => {};
  const cartIsTemporaryTable = !isEditMode
    ? orderFormStore.isTemporaryTable
    : false;
  const setCartIsTemporaryTable = !isEditMode
    ? orderFormStore.setIsTemporaryTable
    : () => {};
  const cartTemporaryTableName = !isEditMode
    ? orderFormStore.temporaryTableName
    : '';
  const setCartTemporaryTableName = !isEditMode
    ? orderFormStore.setTemporaryTableName
    : () => {};
  const cartScheduledTime = !isEditMode ? orderFormStore.scheduledTime : null;
  const setCartScheduledTime = !isEditMode
    ? orderFormStore.setScheduledTime
    : () => {};
  const cartDeliveryInfo = !isEditMode ? orderFormStore.deliveryInfo : {};
  const setCartDeliveryInfo = orderFormStore.setDeliveryInfo;
  const cartOrderNotes = orderFormStore.orderNotes;
  const setCartOrderNotes = orderFormStore.setOrderNotes;
  // Usar valores del contexto o locales según el modo
  const items = isEditMode ? editItems : cartItems;
  const orderType = isEditMode ? editOrderType : cartOrderType;
  const selectedAreaId = isEditMode ? editSelectedAreaId : cartSelectedAreaId;
  const selectedTableId = isEditMode
    ? editSelectedTableId
    : cartSelectedTableId;
  const isTemporaryTable = isEditMode
    ? editIsTemporaryTable
    : cartIsTemporaryTable;
  const temporaryTableName = isEditMode
    ? editTemporaryTableName
    : cartTemporaryTableName;
  const scheduledTime = isEditMode ? editScheduledTime : cartScheduledTime;
  const deliveryInfo = isEditMode ? editDeliveryInfo : cartDeliveryInfo;
  const orderNotes = isEditMode ? editOrderNotes : cartOrderNotes;
  const adjustments = isEditMode ? editAdjustments : [];
  const setOrderType = isEditMode ? setEditOrderType : setCartOrderType;
  const setSelectedAreaId = isEditMode
    ? setEditSelectedAreaId
    : setCartSelectedAreaId;
  const setSelectedTableId = isEditMode
    ? setEditSelectedTableId
    : setCartSelectedTableId;
  const setIsTemporaryTable = isEditMode
    ? setEditIsTemporaryTable
    : setCartIsTemporaryTable;
  const setTemporaryTableName = isEditMode
    ? setEditTemporaryTableName
    : setCartTemporaryTableName;
  const setScheduledTime = isEditMode
    ? setEditScheduledTime
    : setCartScheduledTime;
  const setDeliveryInfo = isEditMode
    ? setEditDeliveryInfo
    : setCartDeliveryInfo;
  const setOrderNotes = isEditMode ? setEditOrderNotes : setCartOrderNotes;
  const removeItem = useCallback(
    (itemId: string) => {
      if (isEditMode) {
        const item = editItems.find((i) => i.id === itemId);
        if (!item) return;
        // Verificar el estado del item
        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          showSnackbar({
            message: `No se puede eliminar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,
            type: 'error',
          });
          return;
        }
        if (item.preparationStatus === 'IN_PROGRESS') {
          setModifyingItemName(item.productName);
          setPendingModifyAction(() => () => {
            setEditItems((prev) => prev.filter((i) => i.id !== itemId));
          });
          setShowModifyInProgressConfirmation(true);
        } else {
          setEditItems((prev) => prev.filter((i) => i.id !== itemId));
        }
      } else {
        removeCartItem(itemId);
      }
    },
    [isEditMode, editItems, showSnackbar, removeCartItem],
  );
  const updateItemQuantity = useCallback(
    (itemId: string, quantity: number) => {
      if (isEditMode) {
        if (quantity <= 0) {
          removeItem(itemId);
          return;
        }
        const item = editItems.find((i) => i.id === itemId);
        if (!item) return;
        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          showSnackbar({
            message: `No se puede modificar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,
            type: 'error',
          });
          return;
        }
        const updateQuantity = () => {
          setEditItems((prev) =>
            prev.map((item) => {
              if (item.id === itemId) {
                const modifiersPrice = item.modifiers.reduce(
                  (sum, mod) => sum + Number(mod.price || 0),
                  0,
                );
                const newTotalPrice =
                  (item.unitPrice + modifiersPrice) * quantity;
                return {
                  ...item,
                  quantity,
                  totalPrice: newTotalPrice,
                };
              }
              return item;
            }),
          );
        };
        if (item.preparationStatus === 'IN_PROGRESS') {
          setModifyingItemName(item.productName);
          setPendingModifyAction(() => updateQuantity);
          setShowModifyInProgressConfirmation(true);
        } else {
          updateQuantity();
        }
      } else {
        updateCartItemQuantity(itemId, quantity);
      }
    },
    [isEditMode, editItems, removeItem, showSnackbar, updateCartItemQuantity],
  );
  const subtotal = useMemo(() => {
    if (!items || !Array.isArray(items)) return 0;
    return items.reduce((sum, item) => sum + (item.totalPrice || 0), 0);
  }, [items]);
  const totalAdjustments = useMemo(() => {
    if (!isEditMode) return 0;
    return editAdjustments
      .filter((adj) => !adj.isDeleted)
      .reduce((sum, adj) => sum + (adj.amount || 0), 0);
  }, [isEditMode, editAdjustments]);
  const total = useMemo(() => {
    return subtotal + totalAdjustments;
  }, [subtotal, totalAdjustments]);
  const totalItemsCount = useMemo(() => {
    return items.reduce((sum, item) => sum + item.quantity, 0);
  }, [items]);
  const existingItemsCount = useMemo(() => {
    if (!isEditMode) return 0;
    return editItems
      .filter((item) => !item.id.startsWith('new-'))
      .reduce((sum, item) => sum + item.quantity, 0);
  }, [isEditMode, editItems]);
  const [lastNotifiedCount, setLastNotifiedCount] = useState<number | null>(
    null,
  );
  useEffect(() => {
    if (isEditMode && onItemsCountChanged && visible && orderDataLoaded) {
      if (existingItemsCount !== lastNotifiedCount) {
        onItemsCountChanged(existingItemsCount);
        setLastNotifiedCount(existingItemsCount);
      }
    }
  }, [
    isEditMode,
    existingItemsCount,
    visible,
    orderDataLoaded,
    lastNotifiedCount,
    onItemsCountChanged,
  ]);
  const totalPaid = useMemo(() => {
    if (!isEditMode || !payments) return 0;
    return payments
      .filter((p) => p.paymentStatus === PaymentStatusEnum.COMPLETED)
      .reduce((sum, payment) => sum + (Number(payment.amount) || 0), 0);
  }, [payments, isEditMode]);
  const pendingAmount = useMemo(() => {
    return Math.max(0, total - totalPaid);
  }, [total, totalPaid]);
  const { user } = useAuthStore();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const canRegisterPayments = useMemo(() => {
    return checkCanRegisterPayments(user);
  }, [user]);
  const [areaMenuVisible, setAreaMenuVisible] = useState(false);
  const [tableMenuVisible, setTableMenuVisible] = useState(false);
  const [areaError, setAreaError] = useState<string | null>(null);
  const [tableError, setTableError] = useState<string | null>(null);
  const [recipientNameError, setRecipientNameError] = useState<string | null>(
    null,
  );
  const [recipientPhoneError, setRecipientPhoneError] = useState<string | null>(
    null,
  );
  const [addressError, setAddressError] = useState<string | null>(null);
  const [isTimePickerVisible, setTimePickerVisible] = useState(false);
  const [isTimeAlertVisible, setTimeAlertVisible] = useState(false);
  const [isConfirming, setIsConfirming] = useState(false);
  const [showExitConfirmation, setShowExitConfirmation] = useState(false);
  const [editingItemFromList, setEditingItemFromList] =
    useState<CartItem | null>(null);
  const [editingProduct, setEditingProduct] = useState<Product | null>(null);
  const [isModalReady, setIsModalReady] = useState(false);
  const [showOptionsMenu, setShowOptionsMenu] = useState(false);
  const [showCancelConfirmation, setShowCancelConfirmation] = useState(false);
  const [
    showModifyInProgressConfirmation,
    setShowModifyInProgressConfirmation,
  ] = useState(false);
  const [pendingModifyAction, setPendingModifyAction] = useState<
    (() => void) | null
  >(null);
  const [modifyingItemName, setModifyingItemName] = useState<string>('');
  const [showHistoryModal, setShowHistoryModal] = useState(false);
  const [showDetailModal, setShowDetailModal] = useState(false);
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [showAdjustmentModal, setShowAdjustmentModal] = useState(false);
  const [adjustmentToEdit, setAdjustmentToEdit] =
    useState<OrderAdjustment | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [paymentAmount, setPaymentAmount] = useState<string>('');
  const [_paymentMethod, _setPaymentMethod] = useState<
    'CASH' | 'CARD' | 'TRANSFER' | null
  >('CASH');
  const [prepaymentId, setPrepaymentId] = useState<string | null>(null);
  const [showPrepaymentModal, setShowPrepaymentModal] = useState(false);
  const [showDeletePrepaymentConfirm, setShowDeletePrepaymentConfirm] =
    useState(false);
  const [originalOrderState, setOriginalOrderState] = useState<{
    items: CartItem[];
    orderType: OrderType;
    tableId: string | null;
    isTemporaryTable: boolean;
    temporaryTableName: string;
    deliveryInfo: DeliveryInfo;
    notes: string;
    scheduledAt: Date | null;
    adjustments: OrderAdjustment[];
  } | null>(null);
  const {
    data: areasData,
    isLoading: isLoadingAreas,
    error: errorAreas,
  } = useGetAreas();
  const {
    data: tablesData,
    isLoading: isLoadingTables,
    error: errorTables,
  } = useGetTablesByArea(selectedAreaId);
  const findModifierById = useCallback(
    (modifierId: string): CartItemModifier | null => {
      if (!menu) return null;
      for (const category of menu) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            for (const modifierGroup of product.modifierGroups || []) {
              const modifier = modifierGroup.productModifiers?.find(
                (mod) => mod.id === modifierId,
              );
              if (modifier) {
                return {
                  id: modifier.id,
                  modifierGroupId: modifierGroup.id,
                  name: modifier.name,
                  price: modifier.price,
                };
              }
            }
          }
        }
      }
      return null;
    },
    [menu],
  );
  useEffect(() => {
    if (!isEditMode || !orderData || !visible) return;
    setEditOrderType(orderData.orderType);
    setEditSelectedTableId(orderData.tableId ?? null);
    setEditScheduledTime(
      orderData.scheduledAt ? new Date(orderData.scheduledAt) : null,
    );
    setEditDeliveryInfo(orderData.deliveryInfo || {});
    setEditOrderNotes(orderData.notes ?? '');
    // Cargar ajustes si existen
    if (orderData.adjustments && Array.isArray(orderData.adjustments)) {
      const mappedAdjustments = orderData.adjustments.map((adj) => ({
        id: adj.id,
        name: adj.name,
        description: adj.description || '',
        isPercentage: adj.isPercentage,
        value: adj.value,
        amount: adj.amount,
        isDeleted: false, // Importante: establecer como no eliminado
        isNew: false, // No es nuevo, viene del backend
      }));
      setEditAdjustments(mappedAdjustments);
    } else {
      setEditAdjustments([]);
    }
    // Si hay una mesa, necesitamos encontrar el área
    if (orderData.tableId && orderData.table) {
      // Intentar obtener el areaId de diferentes formas
      const areaId = orderData.table.areaId || orderData.table.area?.id;
      if (areaId) {
        setEditSelectedAreaId(areaId);
      }
      // Verificar si es una mesa temporal
      if (orderData.table.isTemporary) {
        setEditIsTemporaryTable(true);
        setEditTemporaryTableName(orderData.table.name || '');
      } else {
        setEditIsTemporaryTable(false);
        setEditTemporaryTableName('');
      }
    } else {
      setEditIsTemporaryTable(false);
      setEditTemporaryTableName('');
    }
    // Mapa para agrupar items idénticos
    const groupedItemsMap = new Map<string, CartItem>();
    // Mapear y agrupar los items de la orden
    if (orderData.orderItems && Array.isArray(orderData.orderItems)) {
      orderData.orderItems.forEach((item: any) => {
        // Mapear los modificadores desde el nuevo formato (productModifiers)
        const modifiers: CartItemModifier[] = [];
        // Si vienen en el formato antiguo (item.modifiers con objetos)
        if (item.modifiers && Array.isArray(item.modifiers)) {
          item.modifiers.forEach((mod: any) => {
            modifiers.push({
              id: mod.productModifierId,
              modifierGroupId: mod.productModifier?.modifierGroupId || '',
              name: mod.productModifier?.name || 'Modificador',
              price: parseFloat(mod.price) || 0,
            });
          });
        }
        else if (
          item.productModifiers &&
          Array.isArray(item.productModifiers)
        ) {
          item.productModifiers.forEach((mod: any) => {
            const modifierInfo = findModifierById(mod.id) || {
              id: mod.id,
              modifierGroupId: mod.modifierGroupId || '',
              name: mod.name || 'Modificador',
              price: parseFloat(mod.price) || 0,
            };
            modifiers.push(modifierInfo);
          });
        }
        const modifiersPrice = modifiers.reduce(
          (sum: number, mod: any) => sum + (parseFloat(mod.price) || 0),
          0,
        );
        const unitPrice = parseFloat(item.basePrice || '0');
        const modifierIds = modifiers
          .map((m) => m.id)
          .sort()
          .join(',');
        const pizzaCustomizationIds = item.selectedPizzaCustomizations
          ? item.selectedPizzaCustomizations
              .map((c) => `${c.pizzaCustomizationId}-${c.half}-${c.action}`)
              .sort()
              .join(',')
          : '';
        const groupKey = `${item.productId}-${item.productVariantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;
        const existingItem = groupedItemsMap.get(groupKey);
        if (
          existingItem &&
          existingItem.preparationStatus === item.preparationStatus
        ) {
          // Si ya existe un item idéntico con el mismo estado, incrementar la cantidad
          existingItem.quantity += 1;
          existingItem.totalPrice =
            (unitPrice + modifiersPrice) * existingItem.quantity;
          existingItem.id = `${existingItem.id},${item.id}`;
        } else {
          // Si es un nuevo item, agregarlo al mapa
          const cartItem: CartItem = {
            id: item.id,
            productId: item.productId,
            productName: item.product?.name || 'Producto desconocido',
            quantity: 1, // Empezar con 1, el backend ya no envía quantity
            unitPrice,
            totalPrice: unitPrice + modifiersPrice,
            modifiers,
            variantId: item.productVariantId || undefined,
            variantName: item.productVariant?.name || undefined,
            preparationNotes: item.preparationNotes || undefined,
            preparationStatus: item.preparationStatus || 'PENDING', // Incluir estado de preparación
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined, // Incluir personalizaciones de pizza
          };
          groupedItemsMap.set(groupKey, cartItem);
        }
      });
      // Convertir el mapa a array
      const mappedItems = Array.from(groupedItemsMap.values());
      setEditItems(mappedItems);
    }
    // Marcar que los datos de la orden ya se cargaron
    setOrderDataLoaded(true);
    // Guardar el estado original de la orden para detectar cambios
    const originalItems = Array.from(groupedItemsMap.values());
    const originalAdjustments =
      orderData.adjustments?.map((adj) => ({
        id: adj.id,
        name: adj.name,
        // description: adj.description, // No existe en el tipo Adjustment
        isPercentage: adj.isPercentage,
        value: adj.value,
        amount: adj.amount,
      })) || [];
    setOriginalOrderState({
      items: originalItems,
      orderType: orderData.orderType,
      tableId: orderData.tableId ?? null,
      isTemporaryTable: orderData.table?.isTemporary || false,
      temporaryTableName: orderData.table?.isTemporary
        ? orderData.table.name
        : '',
      deliveryInfo: orderData.deliveryInfo || {},
      notes: orderData.notes ?? '',
      scheduledAt: orderData.scheduledAt
        ? new Date(orderData.scheduledAt)
        : null,
      adjustments: originalAdjustments,
    });
    // Resetear el flag de cambios no guardados
    setHasUnsavedChanges(false);
  }, [isEditMode, orderData, visible]);
  // Función para formatear las personalizaciones de pizza
  const formatPizzaCustomizations = (
    customizations: SelectedPizzaCustomization[],
  ): string => {
    if (!customizations || customizations.length === 0) return '';
    // Agrupar por mitad y tipo
    const groupedByHalf = customizations.reduce(
      (acc, curr) => {
        const half =
          curr.half === PizzaHalf.HALF_1
            ? 'HALF_1'
            : curr.half === PizzaHalf.HALF_2
              ? 'HALF_2'
              : 'FULL';
        if (!acc[half]) {
          acc[half] = {
            flavors: [],
            addedIngredients: [],
            removedIngredients: [],
          };
        }
        // Primero intentar obtener la información de pizzaCustomization si está disponible
        let name = '';
        let type = null;
        if (curr.pizzaCustomization) {
          // Si viene la información completa del backend
          name = curr.pizzaCustomization.name;
          type = curr.pizzaCustomization.type;
        } else if (menu) {
          // Si no viene la información completa, buscarla en el menú
          outer: for (const category of menu) {
            for (const subcategory of category.subcategories || []) {
              for (const product of subcategory.products || []) {
                if (product.pizzaCustomizations) {
                  const customization = product.pizzaCustomizations.find(
                    (pc) => pc.id === curr.pizzaCustomizationId,
                  );
                  if (customization) {
                    name = customization.name;
                    type = customization.type;
                    break outer;
                  }
                }
              }
            }
          }
        }
        // Si aún no tenemos el nombre, usar el ID como fallback
        if (!name) {
          name = curr.pizzaCustomizationId;
        }
        if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
          acc[half].flavors.push(name);
        } else if (
          type === 'INGREDIENT' ||
          type === CustomizationType.INGREDIENT
        ) {
          if (curr.action === CustomizationAction.ADD) {
            acc[half].addedIngredients.push(name);
          } else {
            acc[half].removedIngredients.push(name);
          }
        }
        return acc;
      },
      {} as Record<
        string,
        {
          flavors: string[];
          addedIngredients: string[];
          removedIngredients: string[];
        }
      >,
    );
    // Formatear según el tipo de pizza
    if (groupedByHalf.FULL) {
      // Pizza completa
      const parts: string[] = [];
      if (groupedByHalf.FULL.flavors.length > 0) {
        parts.push(groupedByHalf.FULL.flavors.join(', '));
      }
      if (groupedByHalf.FULL.addedIngredients.length > 0) {
        parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
      }
      if (groupedByHalf.FULL.removedIngredients.length > 0) {
        parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
      // Pizza mitad y mitad
      const formatHalf = (halfData: {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }) => {
        const parts: string[] = [];
        if (halfData.flavors.length > 0) {
          parts.push(halfData.flavors.join(', '));
        }
        if (halfData.addedIngredients.length > 0) {
          parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
        }
        if (halfData.removedIngredients.length > 0) {
          parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
        }
        return parts.join(' - ');
      };
      const half1 = groupedByHalf.HALF_1
        ? formatHalf(groupedByHalf.HALF_1)
        : '';
      const half2 = groupedByHalf.HALF_2
        ? formatHalf(groupedByHalf.HALF_2)
        : '';
      return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
    }
    return '';
  };
  // Función para agrupar items idénticos
  const groupIdenticalItems = useCallback((items: CartItem[]): CartItem[] => {
    const groupedMap = new Map<string, CartItem>();
    items.forEach((item) => {
      // Crear una clave única basada en todas las propiedades que deben ser idénticas
      const modifierIds = item.modifiers
        .map((m) => m.id)
        .sort()
        .join(',');
      // Incluir personalizaciones de pizza en la clave
      const pizzaCustomizationIds = item.selectedPizzaCustomizations
        ? item.selectedPizzaCustomizations
            .map((pc) => `${pc.pizzaCustomizationId}-${pc.half}-${pc.action}`)
            .sort()
            .join(',')
        : '';
      const groupKey = `${item.productId}-${item.variantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;
      const existingItem = groupedMap.get(groupKey);
      if (existingItem) {
        // Si ya existe un item idéntico, incrementar la cantidad
        existingItem.quantity += item.quantity;
        // Recalcular el precio total considerando modificadores
        const modifiersPrice = existingItem.modifiers.reduce(
          (sum, mod) => sum + (mod.price || 0),
          0,
        );
        existingItem.totalPrice =
          (existingItem.unitPrice + modifiersPrice) * existingItem.quantity;
        // Concatenar IDs si ambos items tienen IDs reales (no temporales)
        if (
          !existingItem.id.startsWith('new-') &&
          !item.id.startsWith('new-')
        ) {
          const existingIds = existingItem.id.split(',');
          const newIds = item.id.split(',');
          const allIds = [...new Set([...existingIds, ...newIds])];
          existingItem.id = allIds.join(',');
        }
      } else {
        // Si es nuevo, agregarlo al mapa con una copia completa
        groupedMap.set(groupKey, { ...item });
      }
    });
    const result = Array.from(groupedMap.values());
    return result;
  }, []);
  // Manejar productos pendientes de añadir
  useEffect(() => {
    // Solo procesar cuando:
    // 1. Hay productos pendientes
    // 2. Estamos en modo edición
    // 3. El modal es visible
    // 4. Los datos de la orden ya se cargaron
    if (
      pendingProductsToAdd.length > 0 &&
      isEditMode &&
      visible &&
      orderDataLoaded
    ) {
      // Filtrar productos que no han sido procesados aún
      const unprocessedProducts = pendingProductsToAdd.filter((item) => {
        // Usar una clave única para cada producto basada en sus propiedades
        const productKey = `${item.productId}-${item.variantId || 'null'}-${JSON.stringify(item.modifiers.map((m) => m.id).sort())}-${item.preparationNotes || ''}`;
        return !processedPendingProductsIds.includes(productKey);
      });
      if (unprocessedProducts.length > 0) {
        // Marcar los nuevos productos con estado "NEW" temporal
        const newProductsWithStatus = unprocessedProducts.map((item) => ({
          ...item,
          preparationStatus: 'NEW' as const,
          id: `new-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
        }));
        setEditItems((prevItems) => {
          const allItems = [...prevItems, ...newProductsWithStatus];
          const grouped = groupIdenticalItems(allItems);
          return grouped;
        });
        const newProcessedIds = unprocessedProducts.map(
          (item) =>
            `${item.productId}-${item.variantId || 'null'}-${JSON.stringify(item.modifiers.map((m) => m.id).sort())}-${item.preparationNotes || ''}`,
        );
        setProcessedPendingProductsIds((prev) => [...prev, ...newProcessedIds]);
        const uniqueNewItems = newProductsWithStatus.length;
        showSnackbar({
          message: `${uniqueNewItems} producto${uniqueNewItems > 1 ? 's' : ''} añadido${uniqueNewItems > 1 ? 's' : ''}`,
          type: 'success',
        });
      }
    }
  }, [
    pendingProductsToAdd,
    isEditMode,
    visible,
    orderDataLoaded,
    processedPendingProductsIds,
    groupIdenticalItems,
    showSnackbar,
  ]);
  useEffect(() => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
  }, [orderType]);
  useEffect(() => {
    if (!isEditMode || !originalOrderState || !visible) {
      setHasUnsavedChanges(false);
      return;
    }
    const hasChanges =
      JSON.stringify(editItems) !== JSON.stringify(originalOrderState.items) ||
      editOrderType !== originalOrderState.orderType ||
      editSelectedTableId !== originalOrderState.tableId ||
      editIsTemporaryTable !== originalOrderState.isTemporaryTable ||
      editTemporaryTableName !== originalOrderState.temporaryTableName ||
      JSON.stringify(editDeliveryInfo) !==
        JSON.stringify(originalOrderState.deliveryInfo) ||
      editOrderNotes !== originalOrderState.notes ||
      (editScheduledTime?.getTime() ?? null) !==
        (originalOrderState.scheduledAt?.getTime() ?? null) ||
      JSON.stringify(editAdjustments) !==
        JSON.stringify(originalOrderState.adjustments);
    setHasUnsavedChanges(hasChanges);
  }, [
    isEditMode,
    originalOrderState,
    visible,
    editItems,
    editOrderType,
    editSelectedTableId,
    editIsTemporaryTable,
    editTemporaryTableName,
    editDeliveryInfo,
    editOrderNotes,
    editScheduledTime,
    editAdjustments,
  ]);
  useEffect(() => {
    if (!visible && isEditMode) {
      setEditOrderType(OrderTypeEnum.DINE_IN);
      setEditSelectedAreaId(null);
      setEditSelectedTableId(null);
      setEditScheduledTime(null);
      setEditDeliveryInfo({});
      setEditOrderNotes('');
      setEditItems([]);
      setShowExitConfirmation(false);
      setEditingItemFromList(null);
      setEditingProduct(null);
      setIsModalReady(false);
      setOrderDataLoaded(false); // Resetear el flag de datos cargados
      setProcessedPendingProductsIds([]); // Resetear los IDs de productos procesados
      setLastNotifiedCount(null); // Resetear el conteo notificado
      setOriginalOrderState(null); // Resetear el estado original
      setHasUnsavedChanges(false); // Resetear el flag de cambios
    }
  }, [visible, isEditMode]);
  // Manejar la preparación del modal con un pequeño delay
  useEffect(() => {
    if (visible && !isModalReady) {
      const timer = setTimeout(() => {
        setIsModalReady(true);
      }, 100); // 100ms delay para evitar conflictos de focus
      return () => clearTimeout(timer);
    }
  }, [visible, isModalReady]);
  // Funciones para manejar ajustes
  const handleAddAdjustment = useCallback(
    (adjustment: OrderAdjustment) => {
      if (isEditMode) {
        // Asegurar que el ajuste tenga un ID único
        const newAdjustment = {
          ...adjustment,
          id:
            adjustment.id ||
            `new-adjustment-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
          isNew: true,
        };
        setEditAdjustments((prev) => [...prev, newAdjustment]);
      }
    },
    [isEditMode],
  );
  const handleUpdateAdjustment = useCallback(
    (id: string, updatedAdjustment: OrderAdjustment) => {
      if (isEditMode) {
        setEditAdjustments((prev) =>
          prev.map((adj) =>
            adj.id === id ? { ...adj, ...updatedAdjustment, id } : adj,
          ),
        );
      }
    },
    [isEditMode],
  );
  const handleRemoveAdjustment = useCallback(
    (id: string) => {
      if (isEditMode) {
        setEditAdjustments((prev) => prev.filter((adj) => adj.id !== id));
      }
    },
    [isEditMode],
  );
  // Función para limpiar datos según el tipo de orden (solo se ejecuta al guardar)
  const cleanOrderDataForSubmission = useCallback(
    (
      orderType: OrderType,
      deliveryInfo: DeliveryInfo,
      selectedTableId: string | null,
      selectedAreaId: string | null,
      isTemporaryTable: boolean,
      temporaryTableName: string,
    ) => {
      const cleanedData: {
        deliveryInfo: DeliveryInfo;
        tableId?: string;
        isTemporaryTable?: boolean;
        temporaryTableName?: string;
        temporaryTableAreaId?: string;
      } = {
        deliveryInfo: {},
      };
      // Limpiar deliveryInfo según el tipo de orden
      if (orderType === OrderTypeEnum.DINE_IN) {
        // DINE_IN: No necesita deliveryInfo, pero sí mesa
        cleanedData.deliveryInfo = {};
        if (isTemporaryTable) {
          cleanedData.isTemporaryTable = true;
          cleanedData.temporaryTableName = temporaryTableName;
          cleanedData.temporaryTableAreaId = selectedAreaId || undefined;
        } else {
          cleanedData.tableId = selectedTableId || undefined;
        }
      } else if (orderType === OrderTypeEnum.TAKE_AWAY) {
        // TAKE_AWAY: Solo recipientName, recipientPhone y deliveryInstructions
        cleanedData.deliveryInfo = {
          recipientName: deliveryInfo.recipientName,
          recipientPhone: deliveryInfo.recipientPhone,
          deliveryInstructions: deliveryInfo.deliveryInstructions,
        };
        // No necesita mesa ni área
      } else if (orderType === OrderTypeEnum.DELIVERY) {
        // DELIVERY: Solo campos de dirección y recipientPhone
        cleanedData.deliveryInfo = {
          fullAddress: deliveryInfo.fullAddress,
          street: deliveryInfo.street,
          number: deliveryInfo.number,
          interiorNumber: deliveryInfo.interiorNumber,
          neighborhood: deliveryInfo.neighborhood,
          city: deliveryInfo.city,
          state: deliveryInfo.state,
          zipCode: deliveryInfo.zipCode,
          country: deliveryInfo.country,
          latitude: deliveryInfo.latitude,
          longitude: deliveryInfo.longitude,
          recipientPhone: deliveryInfo.recipientPhone,
          deliveryInstructions: deliveryInfo.deliveryInstructions,
        };
        // No necesita mesa ni área
      }
      return cleanedData;
    },
    [],
  );
  const handleConfirm = async () => {
    if (isConfirming) return; // Prevenir múltiples clics
    // Resetear errores
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
    if (items.length === 0) {
      return;
    }
    let isValid = true;
    // Validaciones según el tipo de orden
    if (orderType === OrderTypeEnum.DINE_IN) {
      if (!selectedAreaId) {
        setAreaError('Debe seleccionar un área');
        isValid = false;
      }
      if (isTemporaryTable) {
        if (!temporaryTableName || temporaryTableName.trim() === '') {
          setTableError('Debe ingresar un nombre para la mesa temporal');
          isValid = false;
        }
      } else {
        if (!selectedTableId) {
          setTableError('Debe seleccionar una mesa');
          isValid = false;
        }
      }
    } else if (orderType === OrderTypeEnum.TAKE_AWAY) {
      if (
        !deliveryInfo.recipientName ||
        deliveryInfo.recipientName.trim() === ''
      ) {
        setRecipientNameError('El nombre del cliente es obligatorio');
        isValid = false;
      }
      if (
        deliveryInfo.recipientPhone &&
        deliveryInfo.recipientPhone.trim() !== ''
      ) {
        const phoneDigits = deliveryInfo.recipientPhone.replace(/\D/g, '');
        if (phoneDigits.length < 10) {
          setRecipientPhoneError('El teléfono debe tener al menos 10 dígitos');
          isValid = false;
        }
      }
    } else if (orderType === OrderTypeEnum.DELIVERY) {
      if (!deliveryInfo.fullAddress || deliveryInfo.fullAddress.trim() === '') {
        setAddressError('La dirección es obligatoria para Domicilio');
        isValid = false;
      }
      if (
        !deliveryInfo.recipientPhone ||
        deliveryInfo.recipientPhone.trim() === ''
      ) {
        setRecipientPhoneError('El teléfono es obligatorio para Domicilio');
        isValid = false;
      } else {
        const phoneDigits = deliveryInfo.recipientPhone.replace(/\D/g, '');
        if (phoneDigits.length < 10) {
          setRecipientPhoneError('El teléfono debe tener al menos 10 dígitos');
          isValid = false;
        }
      }
    }
    if (!isValid) {
      return;
    }
    const cleanedData = cleanOrderDataForSubmission(
      orderType,
      deliveryInfo,
      selectedTableId,
      selectedAreaId,
      isTemporaryTable,
      temporaryTableName,
    );
    const itemsForBackend: OrderItemDtoForBackend[] = [];
    items.forEach((item: CartItem) => {
      if (isEditMode && item.id && !item.id.startsWith('new-')) {
        const existingIds = item.id
          .split(',')
          .filter((id) => id.trim() && !id.startsWith('new-'));
        const requiredQuantity = item.quantity;
        for (let i = 0; i < requiredQuantity; i++) {
          const isExistingItem = i < existingIds.length;
          itemsForBackend.push({
            id: isExistingItem ? existingIds[i] : undefined,
            productId: item.productId,
            productVariantId: item.variantId || null,
            basePrice: Number(item.unitPrice),
            finalPrice: Number(item.totalPrice / item.quantity),
            preparationNotes: item.preparationNotes || null,
            productModifiers:
              item.modifiers && item.modifiers.length > 0
                ? item.modifiers.map((mod) => ({
                    modifierId: mod.id,
                  }))
                : undefined,
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          });
        }
      } else {
        for (let i = 0; i < item.quantity; i++) {
          itemsForBackend.push({
            productId: item.productId,
            productVariantId: item.variantId || null,
            basePrice: Number(item.unitPrice),
            finalPrice: Number(item.totalPrice / item.quantity),
            preparationNotes: item.preparationNotes || null,
            productModifiers:
              item.modifiers && item.modifiers.length > 0
                ? item.modifiers.map((mod) => ({
                    modifierId: mod.id,
                  }))
                : undefined,
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          });
        }
      }
    });
    let formattedPhone: string | undefined = undefined;
    if (
      cleanedData.deliveryInfo.recipientPhone &&
      cleanedData.deliveryInfo.recipientPhone.trim() !== ''
    ) {
      formattedPhone = cleanedData.deliveryInfo.recipientPhone.trim();
    }
    const orderDetails: OrderDetailsForBackend = {
      userId: user?.id,
      orderType,
      subtotal,
      total,
      items: itemsForBackend,
      tableId: cleanedData.tableId,
      isTemporaryTable: cleanedData.isTemporaryTable,
      temporaryTableName: cleanedData.temporaryTableName,
      temporaryTableAreaId: cleanedData.temporaryTableAreaId,
      scheduledAt: scheduledTime ? scheduledTime : undefined,
      deliveryInfo: {
        ...cleanedData.deliveryInfo,
        recipientPhone: formattedPhone,
      },
      notes: orderNotes || undefined,
      adjustments: isEditMode
        ? editAdjustments
            .filter((adj) => !adj.isDeleted)
            .map((adj) => {
              return {
                orderId: orderId || undefined,
                name: adj.name,
                isPercentage: adj.isPercentage,
                value: adj.value,
                amount: adj.amount,
              };
            })
        : undefined,
    };
    if (!orderDetails.userId) {
      // Usuario no autenticado
      return;
    }
    setIsConfirming(true);
    // Si hay un pre-pago creado, incluir su ID
    if (!isEditMode && prepaymentId) {
      orderDetails.prepaymentId = prepaymentId;
    }
    try {
      await onConfirmOrder(orderDetails);
      setIsConfirming(false);
      if (isEditMode) {
        setOriginalOrderState({
          items: [...editItems],
          orderType: editOrderType,
          tableId: editSelectedTableId,
          isTemporaryTable: editIsTemporaryTable,
          temporaryTableName: editTemporaryTableName,
          deliveryInfo: editDeliveryInfo,
          notes: editOrderNotes,
          scheduledAt: editScheduledTime,
          adjustments: editAdjustments,
        });
        setHasUnsavedChanges(false);
        showSnackbar({
          message: 'Cambios guardados exitosamente',
          type: 'success',
        });
        onClose?.();
      }
    } catch (error) {
      setIsConfirming(false);
    }
  };
  const selectedAreaName = useMemo(
    () => areasData?.find((a: any) => a.id === selectedAreaId)?.name,
    [areasData, selectedAreaId],
  );
  const selectedTableName = useMemo(() => {
    return tablesData?.find((t) => t.id === selectedTableId)?.name;
  }, [tablesData, selectedTableId]);
  const showTimePicker = () => {
    setTimePickerVisible(true);
  };
  const hideTimePicker = () => setTimePickerVisible(false);
  const handlePrepaymentCreated = async (
    prepaymentIdCreated: string,
    amount: number,
    method: 'CASH' | 'CARD' | 'TRANSFER',
  ) => {
    const isUpdate = prepaymentId === prepaymentIdCreated;
    setPrepaymentId(prepaymentIdCreated);
    setPaymentAmount(amount.toFixed(2));
    setPaymentMethod(method);
    setShowPrepaymentModal(false);
    showSnackbar({
      message: isUpdate
        ? 'Pago actualizado correctamente'
        : 'Pago registrado correctamente',
      type: 'success',
    });
  };
  const handleDeletePrepayment = () => {
    if (!prepaymentId) return;
    setShowDeletePrepaymentConfirm(true);
  };
  const confirmDeletePrepayment = async () => {
    if (!prepaymentId) return;
    try {
      await prepaymentService.deletePrepayment(prepaymentId);
      setPrepaymentId(null);
      setPaymentAmount('');
      setPaymentMethod(null);
      showSnackbar({
        message: 'Prepago eliminado correctamente',
        type: 'success',
      });
    } catch (error: any) {
      let errorMessage = 'Error al eliminar el prepago';
      if (error?.response?.status === 404) {
        errorMessage = 'El prepago ya no existe o fue eliminado previamente';
        setPrepaymentId(null);
        setPaymentAmount('');
        setPaymentMethod(null);
      } else if (error?.response?.data?.message) {
        errorMessage = error.response.data.message;
      }
      showSnackbar({
        message: errorMessage,
        type: 'error',
      });
    } finally {
      setShowDeletePrepaymentConfirm(false);
    }
  };
  const handlePrepaymentDeleted = () => {
    setPrepaymentId(null);
    setPaymentAmount('');
    setPaymentMethod('CASH');
    setShowPrepaymentModal(false);
    showSnackbar({
      message: 'Pago eliminado correctamente',
      type: 'success',
    });
  };
  const handleTimeConfirm = (date: Date) => {
    const now = new Date();
    now.setSeconds(0, 0);
    if (date < now) {
      hideTimePicker();
      setTimeAlertVisible(true);
    } else {
      if (isEditMode) {
        setEditScheduledTime(date);
      } else {
        setScheduledTime(date);
      }
      hideTimePicker();
    }
  };
  const formattedScheduledTime = useMemo(() => {
    if (!scheduledTime) return null;
    try {
      return format(scheduledTime, 'h:mm a').toLowerCase();
    } catch (error) {
      return 'Hora inválida';
    }
  }, [scheduledTime]);
  const handleEditCartItem = useCallback(
    (item: CartItem) => {
      if (!isEditMode) {
        if (onEditItem) {
          onEditItem(item);
        }
      } else {
        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          showSnackbar({
            message: `No se puede editar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,
            type: 'error',
          });
          return;
        }
        const proceedWithEdit = () => {
          if (!menu || !Array.isArray(menu)) {
            return;
          }
          let product: Product | undefined;
          for (const category of menu as FullMenuCategory[]) {
            if (
              category.subcategories &&
              Array.isArray(category.subcategories)
            ) {
              for (const subcategory of category.subcategories) {
                if (
                  subcategory.products &&
                  Array.isArray(subcategory.products)
                ) {
                  product = subcategory.products.find(
                    (p: Product) => p.id === item.productId,
                  );
                  if (product) break;
                }
              }
            }
            if (product) break;
          }
          if (product) {
            setEditingItemFromList(item);
            setEditingProduct(product);
          } else {
            setEditingItemFromList(item);
            const tempProduct: Product = {
              id: item.productId,
              name: item.productName,
              price: item.unitPrice,
              hasVariants: !!item.variantId,
              variants: item.variantId
                ? [
                    {
                      id: item.variantId,
                      name: item.variantName || '',
                      price: item.unitPrice,
                    },
                  ]
                : [],
              modifierGroups: [], // Sin grupos de modificadores
              photo: null,
              subcategoryId: '',
              createdAt: new Date(),
              updatedAt: new Date(),
            };
            setEditingProduct(tempProduct);
          }
        };
        if (item.preparationStatus === 'IN_PROGRESS') {
          setModifyingItemName(item.productName);
          setPendingModifyAction(() => proceedWithEdit);
          setShowModifyInProgressConfirmation(true);
        } else {
          proceedWithEdit();
        }
      }
    },
    [isEditMode, onEditItem, menu, showSnackbar],
  );
  const handleUpdateEditedItem = useCallback(
    (
      itemId: string,
      quantity: number,
      modifiers: CartItemModifier[],
      preparationNotes?: string,
      variantId?: string,
      variantName?: string,
      unitPrice?: number,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
      pizzaExtraCost?: number,
    ) => {
      if (!isEditMode) return;
      setEditItems((prev) =>
        prev.map((item) => {
          if (item.id === itemId) {
            const modifiersPrice = modifiers.reduce(
              (sum, mod) => sum + Number(mod.price || 0),
              0,
            );
            const finalUnitPrice =
              unitPrice !== undefined ? unitPrice : item.unitPrice;
            const extraCost = pizzaExtraCost || 0;
            const newTotalPrice =
              (finalUnitPrice + modifiersPrice + extraCost) * quantity;
            return {
              ...item,
              quantity,
              modifiers,
              preparationNotes:
                preparationNotes !== undefined
                  ? preparationNotes
                  : item.preparationNotes,
              variantId: variantId !== undefined ? variantId : item.variantId,
              variantName:
                variantName !== undefined ? variantName : item.variantName,
              unitPrice: finalUnitPrice,
              totalPrice: newTotalPrice,
              selectedPizzaCustomizations:
                selectedPizzaCustomizations !== undefined
                  ? selectedPizzaCustomizations
                  : item.selectedPizzaCustomizations,
            };
          }
          return item;
        }),
      );
      setEditingItemFromList(null);
      setEditingProduct(null);
    },
    [isEditMode],
  );
  const renderFields = () => {
    switch (orderType) {
      case OrderTypeEnum.DINE_IN:
        return (
          <>
            {}
            <View style={styles.dineInSelectorsRow}>
              <View style={styles.dineInSelectorContainer}>
                <Menu
                  visible={areaMenuVisible}
                  onDismiss={() => setAreaMenuVisible(false)}
                  anchor={
                    <AnimatedLabelSelector
                      label="Área *"
                      value={selectedAreaName}
                      onPress={() => setAreaMenuVisible(true)}
                      isLoading={isLoadingAreas}
                      error={!!areaError || !!errorAreas}
                      disabled={isLoadingAreas}
                    />
                  }
                >
                  {areasData?.map((area: any) => (
                    <Menu.Item
                      key={area.id}
                      onPress={() => {
                        setSelectedAreaId(area.id);
                        setSelectedTableId(null);
                        setAreaMenuVisible(false);
                        setAreaError(null);
                      }}
                      title={area.name}
                    />
                  ))}
                  {errorAreas && (
                    <Menu.Item title="Error al cargar áreas" disabled />
                  )}
                </Menu>
                {areaError && !errorAreas && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    {areaError}
                  </HelperText>
                )}
                {errorAreas && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    Error al cargar áreas
                  </HelperText>
                )}
              </View>
              {}
              <View style={styles.dineInSelectorContainer}>
                <Menu
                  visible={tableMenuVisible}
                  onDismiss={() => setTableMenuVisible(false)}
                  anchor={
                    <AnimatedLabelSelector
                      label="Mesa *"
                      value={selectedTableName}
                      onPress={() => setTableMenuVisible(true)}
                      isLoading={isLoadingTables}
                      error={!!tableError || !!errorTables}
                      disabled={
                        !selectedAreaId ||
                        isLoadingTables ||
                        isLoadingAreas ||
                        isTemporaryTable
                      }
                    />
                  }
                >
                  {tablesData?.map((table: Table) => {
                    const isCurrentTable =
                      isEditMode && orderData?.tableId === table.id;
                    const canSelect = table.isAvailable || isCurrentTable;
                    return (
                      <Menu.Item
                        key={table.id}
                        onPress={() => {
                          if (canSelect) {
                            setSelectedTableId(table.id);
                            setTableMenuVisible(false);
                            setTableError(null);
                          }
                        }}
                        title={`${table.name}${!table.isAvailable && !isCurrentTable ? ' (Ocupada)' : ''}`}
                        disabled={!canSelect}
                        titleStyle={
                          !canSelect ? { color: theme.colors.error } : undefined
                        }
                      />
                    );
                  })}
                  {selectedAreaId &&
                    tablesData?.length === 0 &&
                    !isLoadingTables &&
                    !errorTables && <Menu.Item title="No hay mesas" disabled />}
                  {errorTables && (
                    <Menu.Item title="Error al cargar mesas" disabled />
                  )}
                </Menu>
                {tableError && !errorTables && !isTemporaryTable && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    {tableError}
                  </HelperText>
                )}
                {errorTables && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    Error al cargar mesas
                  </HelperText>
                )}
              </View>
            </View>
            {}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <TouchableOpacity
                onPress={() => {
                  setIsTemporaryTable(!isTemporaryTable);
                  if (!isTemporaryTable) {
                    setSelectedTableId(null);
                    setTableError(null);
                  } else {
                    setTemporaryTableName('');
                  }
                }}
                style={styles.checkboxContainer}
              >
                <Checkbox.Android
                  status={isTemporaryTable ? 'checked' : 'unchecked'}
                  onPress={() => {
                    setIsTemporaryTable(!isTemporaryTable);
                    if (!isTemporaryTable) {
                      setSelectedTableId(null);
                      setTableError(null);
                    } else {
                      setTemporaryTableName('');
                    }
                  }}
                  color={theme.colors.primary}
                />
                <Text style={styles.checkboxLabel}>
                  {isEditMode && isTemporaryTable
                    ? 'Mesa temporal'
                    : 'Crear mesa temporal'}
                </Text>
              </TouchableOpacity>
              {}
              {(isTemporaryTable || (isEditMode && editIsTemporaryTable)) && (
                <View style={styles.temporaryTableInputContainer}>
                  <SpeechRecognitionInput
                    key={`temporary-table-name-${isEditMode ? 'edit' : 'create'}`}
                    label="Nombre de la Mesa Temporal *"
                    value={temporaryTableName}
                    onChangeText={(text) => {
                      setTemporaryTableName(text);
                      if (tableError) setTableError(null);
                    }}
                    error={!!tableError && isTemporaryTable}
                    speechLang="es-MX"
                    autoCapitalize="words"
                    autoCorrect={false}
                    placeholder="Ej: Mesa Terraza 1"
                    editable={true}
                  />
                  {tableError && isTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                </View>
              )}
            </View>
            {}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="notes-input-dine-in"
                label="Notas de la Orden (Opcional)"
                value={orderNotes}
                onChangeText={setOrderNotes}
                multiline
                speechLang="es-MX"
              />
            </View>
            {}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <AnimatedLabelSelector
                label="Programar Hora (Opcional)"
                value={formattedScheduledTime}
                onPress={showTimePicker}
                onClear={() => setScheduledTime(null)}
              />
            </View>
          </>
        );
      case OrderTypeEnum.TAKE_AWAY:
        return (
          <>
            {}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key={`customer-name-input-${orderType}`}
                label="Nombre del Cliente *"
                value={deliveryInfo.recipientName || ''}
                onChangeText={(text) => {
                  setDeliveryInfo({ ...deliveryInfo, recipientName: text });
                  if (recipientNameError) setRecipientNameError(null);
                }}
                error={!!recipientNameError}
                speechLang="es-MX"
                autoCapitalize="words"
                autoCorrect={false}
              />
              {recipientNameError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientNameError}
                </HelperText>
              )}
            </View>
            {/* 2. Teléfono */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <View style={styles.phoneInputWrapper}>
                <SpeechRecognitionInput
                  key={`phone-input-takeaway-${orderType}`}
                  label="Teléfono (Opcional)"
                  value={deliveryInfo.recipientPhone || ''}
                  onChangeText={(text) => {
                    setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });
                    if (recipientPhoneError) setRecipientPhoneError(null);
                  }}
                  keyboardType="phone-pad"
                  error={!!recipientPhoneError} // Aunque opcional, puede tener errores de formato si se ingresa
                  speechLang="es-MX"
                  autoCorrect={false}
                />
                {(deliveryInfo.recipientPhone || '').length > 0 &&
                  !recipientPhoneError && (
                    <Text style={styles.digitCounterAbsolute}>
                      {
                        (deliveryInfo.recipientPhone || '').replace(/\D/g, '')
                          .length
                      }{' '}
                      dígitos
                    </Text>
                  )}
              </View>
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>
            {/* 3. Notas */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="notes-input-takeaway"
                label="Notas de la Orden (Opcional)"
                value={orderNotes}
                onChangeText={setOrderNotes}
                multiline
                speechLang="es-MX"
              />
            </View>
            {/* 4. Programar Hora */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <AnimatedLabelSelector
                label="Programar Hora Recolección (Opcional)"
                value={formattedScheduledTime}
                onPress={showTimePicker}
                onClear={() => setScheduledTime(null)}
              />
            </View>
          </>
        );
      case OrderTypeEnum.DELIVERY: // Usar Enum
        return (
          <>
            {/* 1. Dirección */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="address-input-delivery"
                label="Dirección de Entrega *"
                value={deliveryInfo.fullAddress || ''}
                onChangeText={(text) => {
                  setDeliveryInfo({ ...deliveryInfo, fullAddress: text });
                  if (addressError) setAddressError(null);
                }}
                error={!!addressError}
                speechLang="es-MX"
                multiline
                isInModal={true}
              />
              {addressError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {addressError}
                </HelperText>
              )}
            </View>
            {/* 2. Teléfono */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key={`phone-input-delivery-${orderType}`} // Key única y específica
                label="Teléfono *"
                value={deliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  // Asegurar que la función esté bien definida aquí
                  setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });
                  if (recipientPhoneError) {
                    setRecipientPhoneError(null);
                  }
                }}
                keyboardType="phone-pad"
                error={!!recipientPhoneError}
                speechLang="es-MX"
                autoCorrect={false}
              />
              <View style={styles.phoneHelperContainer}>
                {recipientPhoneError ? (
                  <HelperText
                    type="error"
                    visible={true}
                    style={[styles.helperTextFix, styles.recipientPhoneError]}
                  >
                    {recipientPhoneError}
                  </HelperText>
                ) : (
                  (deliveryInfo.recipientPhone || '').length > 0 && (
                    <Text style={styles.digitCounter}>
                      {
                        (deliveryInfo.recipientPhone || '').replace(/\D/g, '')
                          .length
                      }{' '}
                      dígitos
                    </Text>
                  )
                )}
              </View>
            </View>
            {/* 3. Notas */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="notes-input-delivery" // Key única y específica
                label="Notas de la Orden (Opcional)"
                value={orderNotes}
                onChangeText={setOrderNotes}
                multiline
                speechLang="es-MX"
              />
            </View>
            {/* 4. Programar Hora */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <AnimatedLabelSelector
                label="Programar Hora Entrega (Opcional)"
                value={formattedScheduledTime}
                onPress={showTimePicker}
                onClear={() => setScheduledTime(null)}
              />
            </View>
          </>
        );
      default:
        return null;
    }
  };
  // Mostrar loading si estamos en modo edición y aún cargando
  if (isEditMode && isLoadingOrder) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onClose}
          contentContainerStyle={styles.modalContent}
        >
          <View style={[styles.container, styles.loadingContainer]}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando orden...</Text>
          </View>
        </Modal>
      </Portal>
    );
  }
  // Mostrar error si falló la carga en modo edición
  if (isEditMode && isErrorOrder) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onClose}
          contentContainerStyle={styles.errorModalContent}
        >
          <View style={styles.errorModalContainer}>
            {/* Icono de error */}
            <View
              style={[
                styles.errorIconContainer,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <IconButton
                icon="alert-circle-outline"
                size={48}
                iconColor={theme.colors.error}
                style={styles.iconButtonNoMargin}
              />
            </View>
            {/* Título del error */}
            <Text
              style={[
                styles.errorModalTitle,
                { color: theme.colors.onSurface },
              ]}
            >
              No se pudo cargar la orden
            </Text>
            {/* Mensaje descriptivo */}
            <Text
              style={[
                styles.errorModalMessage,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Ha ocurrido un error al intentar cargar los datos de la orden. Por
              favor, intenta nuevamente más tarde.
            </Text>
            {/* Botón de cerrar */}
            <Button
              mode="contained"
              onPress={onClose}
              style={styles.errorModalButton}
              contentStyle={styles.errorModalButtonContent}
              labelStyle={styles.errorModalButtonLabel}
            >
              Entendido
            </Button>
          </View>
        </Modal>
      </Portal>
    );
  }
  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (isEditMode && hasUnsavedChanges) {
            setShowExitConfirmation(true);
          } else {
            onClose?.();
          }
        }}
        contentContainerStyle={styles.modalContent}
        dismissable={true}
        dismissableBackButton={false}
      >
        <GestureHandlerRootView style={styles.container}>
          <TouchableWithoutFeedback
            onPress={Keyboard.dismiss}
            accessible={false}
          >
            <View>
              {isEditMode ? (
                <View style={styles.customHeader}>
                  <IconButton
                    icon="arrow-left"
                    size={24}
                    onPress={() => {
                      if (hasUnsavedChanges) {
                        setShowExitConfirmation(true);
                      } else {
                        onClose?.();
                      }
                    }}
                    iconColor={theme.colors.onSurface}
                  />
                  <View style={styles.headerTitleContainer}>
                    <Text style={styles.headerTitle}>
                      {orderNumber && orderDate
                        ? `Editar Orden #${orderNumber} - ${format(orderDate, 'dd/MM/yyyy', { locale: es })}`
                        : orderNumber
                          ? `Editando Orden #${orderNumber}`
                          : 'Editar Orden'}
                    </Text>
                    {orderData?.orderStatus && (
                      <View
                        style={[
                          styles.orderStatusBadge,
                          {
                            backgroundColor: getOrderStatusColor(
                              orderData.orderStatus,
                              theme,
                            ),
                          },
                        ]}
                      >
                        <Text style={styles.orderStatusText}>
                          {formatOrderStatus(orderData.orderStatus)}
                        </Text>
                      </View>
                    )}
                  </View>
                  <Menu
                    visible={showOptionsMenu}
                    onDismiss={() => setShowOptionsMenu(false)}
                    anchor={
                      <IconButton
                        icon="dots-vertical"
                        size={24}
                        onPress={() => setShowOptionsMenu(true)}
                        iconColor={theme.colors.onSurface}
                      />
                    }
                  >
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        setShowDetailModal(true);
                      }}
                      title="Ver Detalles"
                      leadingIcon="file-document-outline"
                    />
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        setShowHistoryModal(true);
                      }}
                      title="Ver Historial"
                      leadingIcon="history"
                    />
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        setShowCancelConfirmation(true);
                      }}
                      title="Cancelar Orden"
                      leadingIcon="cancel"
                    />
                  </Menu>
                </View>
              ) : (
                <OrderHeader
                  title={
                    orderNumber ? `Orden #${orderNumber}` : 'Resumen de Orden'
                  }
                  onBackPress={() => onClose?.()}
                  itemCount={totalItemsCount}
                  onCartPress={() => {}}
                  isCartVisible={isCartVisible}
                />
              )}
            </View>
          </TouchableWithoutFeedback>
          <ScrollView
            style={styles.scrollView}
            keyboardShouldPersistTaps="handled"
            keyboardDismissMode="on-drag"
          >
            {/* Order Type Selection */}
            <View style={styles.sectionCompact}>
              <RadioButton.Group
                onValueChange={(newValue) =>
                  setOrderType(newValue as OrderType)
                }
                value={orderType}
              >
                <View style={styles.radioGroupHorizontal}>
                  <RadioButton.Item
                    label="COMER AQUÍ"
                    value={OrderTypeEnum.DINE_IN} // Usar Enum
                    style={styles.radioButtonItem}
                    labelStyle={styles.radioLabel}
                    position="leading"
                  />
                  <RadioButton.Item
                    label="PARA LLEVAR"
                    value={OrderTypeEnum.TAKE_AWAY} // Usar Enum
                    style={styles.radioButtonItem}
                    labelStyle={styles.radioLabel}
                    position="leading"
                  />
                  <RadioButton.Item
                    label="DOMICILIO"
                    value={OrderTypeEnum.DELIVERY} // Usar Enum
                    style={styles.radioButtonItem}
                    labelStyle={styles.radioLabel}
                    position="leading"
                  />
                </View>
              </RadioButton.Group>
            </View>
            {/* Render fields based on order type */}
            {renderFields()}
            <Divider style={styles.divider} />
            {/* Cart Items */}
            <List.Section>
              {items.map((item) => {
                // Crear función de renderizado de acción de eliminar
                const renderRightActions = (progress, dragX) => {
                  const translateX = dragX.interpolate({
                    inputRange: [-100, 0],
                    outputRange: [0, 100],
                    extrapolate: 'clamp',
                  });
                  const scale = dragX.interpolate({
                    inputRange: [-100, -50, 0],
                    outputRange: [1, 0.8, 0.5],
                    extrapolate: 'clamp',
                  });
                  const opacity = dragX.interpolate({
                    inputRange: [-100, -20, 0],
                    outputRange: [1, 0.5, 0],
                    extrapolate: 'clamp',
                  });
                  return (
                    <Animated.View
                      style={[
                        styles.deleteActionContainer,
                        {
                          opacity,
                          transform: [{ translateX }],
                        },
                      ]}
                    >
                      <Animated.View
                        style={[
                          styles.deleteAction,
                          {
                            backgroundColor: theme.colors.error,
                            transform: [{ scale }],
                          },
                        ]}
                      >
                        <View style={styles.deleteIconContainer}>
                          <IconButton
                            icon="delete-sweep"
                            size={28}
                            iconColor="white"
                            style={styles.deleteIcon}
                          />
                        </View>
                        <Text style={styles.deleteActionText}>ELIMINAR</Text>
                      </Animated.View>
                    </Animated.View>
                  );
                };
                return (
                  <Swipeable
                    key={item.id}
                    renderRightActions={renderRightActions}
                    overshootRight={false}
                    friction={2}
                    rightThreshold={90}
                    leftThreshold={100}
                    onSwipeableOpen={(direction) => {
                      if (direction === 'right') {
                        // Pequeño delay para que se vea la animación completa
                        setTimeout(() => {
                          removeItem(item.id);
                        }, 150);
                      }
                    }}
                  >
                    <TouchableOpacity
                      onPress={() => handleEditCartItem(item)}
                      disabled={!onEditItem && !isEditMode}
                      activeOpacity={0.7}
                    >
                      <List.Item
                        // Mover title y description a un View contenedor para controlar el ancho
                        title={() => (
                          <View style={styles.itemTextContainer}>
                            <View>
                              <Text style={styles.itemTitleText}>
                                {`${item.quantity}x ${item.variantName ? String(item.variantName ?? '') : String(item.productName ?? '')}`}
                              </Text>
                              {/* Mostrar estado de preparación solo en modo edición - siempre en nueva línea */}
                              {isEditMode && item.preparationStatus && (
                                <View style={styles.statusContainer}>
                                  <View
                                    style={[
                                      styles.statusBadge,
                                      {
                                        backgroundColor:
                                          getPreparationStatusColor(
                                            item.preparationStatus,
                                            theme,
                                          ) + '20',
                                      },
                                    ]}
                                  >
                                    <View
                                      style={[
                                        styles.statusDot,
                                        {
                                          backgroundColor:
                                            getPreparationStatusColor(
                                              item.preparationStatus,
                                              theme,
                                            ),
                                        },
                                      ]}
                                    />
                                    <Text
                                      style={[
                                        styles.statusText,
                                        {
                                          color: getPreparationStatusColor(
                                            item.preparationStatus,
                                            theme,
                                          ),
                                        },
                                      ]}
                                    >
                                      {getPreparationStatusText(
                                        item.preparationStatus,
                                      )}
                                    </Text>
                                  </View>
                                </View>
                              )}
                            </View>
                            {(() => {
                              const hasModifiers =
                                item.modifiers && item.modifiers.length > 0;
                              const hasNotes =
                                item.preparationNotes &&
                                item.preparationNotes.trim() !== '';
                              const hasPizzaCustomizations =
                                item.selectedPizzaCustomizations &&
                                item.selectedPizzaCustomizations.length > 0;
                              return (
                                <View>
                                  {/* Renderizar personalizaciones de pizza */}
                                  {hasPizzaCustomizations && (
                                    <Text style={styles.itemDescription}>
                                      {formatPizzaCustomizations(
                                        item.selectedPizzaCustomizations,
                                      )}
                                    </Text>
                                  )}
                                  {/* Renderizar modificadores */}
                                  {hasModifiers &&
                                    item.modifiers.map(
                                      (mod: any, index: number) => (
                                        <Text
                                          key={mod.id || index}
                                          style={styles.itemDescription}
                                        >
                                          • {mod.name}{' '}
                                          {mod.price && Number(mod.price) > 0
                                            ? `(+$${Number(mod.price).toFixed(2)})`
                                            : ''}
                                        </Text>
                                      ),
                                    )}
                                  {/* Renderizar notas */}
                                  {hasNotes && (
                                    <Text
                                      style={[
                                        styles.itemDescription,
                                        styles.notesText,
                                      ]}
                                    >
                                      Notas: {item.preparationNotes}
                                    </Text>
                                  )}
                                </View>
                              );
                            })()}
                          </View>
                        )}
                        // titleNumberOfLines y description ya no se usan directamente aquí
                        right={() => (
                          // Usar paréntesis para retorno implícito si es una sola expresión
                          <View style={styles.itemActionsContainer}>
                            <View style={styles.quantityActions}>
                              <IconButton
                                icon="minus-circle-outline"
                                size={20} // Reducir tamaño de icono
                                onPress={() =>
                                  updateItemQuantity(item.id, item.quantity - 1)
                                }
                                style={styles.quantityButton}
                                disabled={item.quantity <= 1} // Deshabilitar si es 1
                              />
                              <Text style={styles.quantityText}>
                                {item.quantity}
                              </Text>
                              <IconButton
                                icon="plus-circle-outline"
                                size={20} // Reducir tamaño de icono
                                onPress={() =>
                                  updateItemQuantity(item.id, item.quantity + 1)
                                }
                                style={styles.quantityButton}
                              />
                            </View>
                            <View style={styles.priceContainer}>
                              <Text style={styles.itemPrice}>
                                ${Number(item.totalPrice || 0).toFixed(2)}
                              </Text>
                              {item.quantity > 1 && (
                                <Text style={styles.unitPriceText}>
                                  ($
                                  {(
                                    Number(item.unitPrice || 0) +
                                    (item.modifiers || []).reduce(
                                      (sum, mod) =>
                                        sum + Number(mod.price || 0),
                                      0,
                                    )
                                  ).toFixed(2)}{' '}
                                  c/u)
                                </Text>
                              )}
                            </View>
                          </View>
                        )}
                        style={styles.listItem}
                      />
                    </TouchableOpacity>
                  </Swipeable>
                );
              })}
              {/* Renderizar ajustes como OrderItems - dentro del mismo List.Section */}
              {isEditMode &&
                adjustments
                  .filter((adj) => !adj.isDeleted)
                  .map((adjustment, index) => {
                    const renderRightActions = (progress, dragX) => {
                      const translateX = dragX.interpolate({
                        inputRange: [-100, 0],
                        outputRange: [0, 100],
                        extrapolate: 'clamp',
                      });
                      const scale = dragX.interpolate({
                        inputRange: [-100, -50, 0],
                        outputRange: [1, 0.8, 0.5],
                        extrapolate: 'clamp',
                      });
                      const opacity = dragX.interpolate({
                        inputRange: [-100, -20, 0],
                        outputRange: [1, 0.5, 0],
                        extrapolate: 'clamp',
                      });
                      return (
                        <Animated.View
                          style={[
                            styles.deleteActionContainer,
                            {
                              opacity,
                              transform: [{ translateX }],
                            },
                          ]}
                        >
                          <Animated.View
                            style={[
                              styles.deleteAction,
                              {
                                backgroundColor: theme.colors.error,
                                transform: [{ scale }],
                              },
                            ]}
                          >
                            <View style={styles.deleteIconContainer}>
                              <IconButton
                                icon="delete-sweep"
                                size={28}
                                iconColor="white"
                                style={styles.deleteIcon}
                              />
                            </View>
                            <Text style={styles.deleteActionText}>
                              ELIMINAR
                            </Text>
                          </Animated.View>
                        </Animated.View>
                      );
                    };
                    return (
                      <Swipeable
                        key={adjustment.id || `new-${index}`}
                        renderRightActions={renderRightActions}
                        overshootRight={false}
                        friction={2}
                        rightThreshold={90}
                        leftThreshold={100}
                        onSwipeableOpen={(direction) => {
                          if (direction === 'right') {
                            setTimeout(() => {
                              if (adjustment.id) {
                                handleRemoveAdjustment(adjustment.id);
                              }
                            }, 150);
                          }
                        }}
                      >
                        <TouchableOpacity
                          onPress={() => {
                            setAdjustmentToEdit(adjustment);
                            setShowAdjustmentModal(true);
                          }}
                          activeOpacity={0.7}
                        >
                          <List.Item
                            title={() => (
                              <View style={styles.itemTextContainer}>
                                <Text
                                  style={[
                                    styles.itemTitleText,
                                    {
                                      color:
                                        adjustment.amount < 0
                                          ? theme.colors.error
                                          : theme.colors.primary,
                                    },
                                  ]}
                                >
                                  {adjustment.name}
                                  {adjustment.isPercentage
                                    ? ` (${adjustment.value}%)`
                                    : ''}
                                </Text>
                              </View>
                            )}
                            right={() => (
                              <View style={styles.itemActionsContainer}>
                                <View style={styles.priceContainer}>
                                  <Text
                                    style={[
                                      styles.itemPrice,
                                      {
                                        color:
                                          adjustment.amount < 0
                                            ? theme.colors.error
                                            : theme.colors.primary,
                                      },
                                    ]}
                                  >
                                    {adjustment.amount < 0 ? '-' : '+'}$
                                    {Math.abs(adjustment.amount || 0).toFixed(
                                      2,
                                    )}
                                  </Text>
                                </View>
                              </View>
                            )}
                            style={styles.listItem}
                          />
                        </TouchableOpacity>
                      </Swipeable>
                    );
                  })}
            </List.Section>
            {/* Botón de ajustes - Solo en modo edición */}
            {isEditMode && (
              <Button
                onPress={() => setShowAdjustmentModal(true)}
                mode="outlined"
                style={styles.adjustmentButton}
                icon="calculator-variant"
              >
                Ajustes
              </Button>
            )}
            {/* Botón para añadir productos en modo edición */}
            {isEditMode && (
              <Button
                onPress={() => {
                  if (onAddProducts) {
                    // Si tenemos un callback personalizado, usarlo
                    onAddProducts();
                  } else if (navigation && orderId && orderNumber) {
                    // Si no, usar navegación directa
                    try {
                      navigation.navigate('AddProductsToOrder', {
                        orderId,
                        orderNumber,
                        existingOrderItemsCount: editItems
                          .filter((item) => !item.id.startsWith('new-'))
                          .reduce((sum, item) => sum + item.quantity, 0),
                        onProductsAdded: (newProducts: CartItem[]) => {
                          const newProductsWithStatus = newProducts.map(
                            (item) => ({
                              ...item,
                              preparationStatus: 'NEW' as const,
                              id: `new-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
                            }),
                          );
                          const allItems = [
                            ...editItems,
                            ...newProductsWithStatus,
                          ];
                          const groupedItems = groupIdenticalItems(allItems);
                          setEditItems(groupedItems);
                          showSnackbar({
                            message: `${newProducts.length} producto${newProducts.length > 1 ? 's' : ''} añadido${newProducts.length > 1 ? 's' : ''}`,
                            type: 'success',
                          });
                        },
                      });
                    } catch (error) {
                    }
                  }
                }}
                mode="outlined"
                style={styles.addProductsButton}
                icon="plus-circle-outline"
              >
                Añadir Productos
              </Button>
            )}
            <Divider style={styles.divider} />
            {}
            <View style={styles.totalsContainer}>
              <Text style={styles.totalsText}>Subtotal:</Text>
              <Text style={styles.totalsValue}>
                ${(subtotal || 0).toFixed(2)}
              </Text>
            </View>
            {isEditMode && totalAdjustments !== 0 && (
              <View style={styles.totalsContainer}>
                <Text style={styles.totalsText}>Ajustes:</Text>
                <Text
                  style={[
                    styles.totalsValue,
                    {
                      color:
                        totalAdjustments < 0
                          ? theme.colors.error
                          : theme.colors.primary,
                    },
                  ]}
                >
                  {totalAdjustments < 0 ? '-' : '+'}$
                  {Math.abs(totalAdjustments || 0).toFixed(2)}
                </Text>
              </View>
            )}
            <View style={styles.totalsContainer}>
              <Text style={[styles.totalsText, styles.totalLabel]}>Total:</Text>
              <Text style={[styles.totalsValue, styles.totalValue]}>
                ${(total || 0).toFixed(2)}
              </Text>
            </View>
            {}
            {!isEditMode && prepaymentId && (
              <>
                <View style={styles.prepaymentSection}>
                  <View style={styles.prepaymentHeader}>
                    <Text style={styles.prepaymentTitle}>
                      Prepago registrado
                    </Text>
                    <View style={styles.prepaymentActions}>
                      <IconButton
                        icon="pencil"
                        size={28}
                        iconColor={theme.colors.primary}
                        onPress={() => setShowPrepaymentModal(true)}
                        style={styles.prepaymentIconButton}
                      />
                      <IconButton
                        icon="delete"
                        size={28}
                        iconColor={theme.colors.error}
                        onPress={handleDeletePrepayment}
                        style={styles.prepaymentIconButton}
                      />
                    </View>
                  </View>
                  <View style={styles.totalsContainer}>
                    <Text style={styles.totalsText}>Monto pagado:</Text>
                    <Text style={[styles.totalsValue, { color: '#4CAF50' }]}>
                      ${parseFloat(paymentAmount || '0').toFixed(2)}
                    </Text>
                  </View>
                  {}
                  {parseFloat(paymentAmount || '0') > total && (
                    <View style={styles.prepaymentWarning}>
                      <IconButton
                        icon="alert-circle"
                        size={16}
                        iconColor={theme.colors.error}
                        style={styles.iconButtonNoMargin}
                      />
                      <Text style={styles.prepaymentWarningText}>
                        El prepago excede el total de la orden. Edite el pago
                        antes de continuar.
                      </Text>
                    </View>
                  )}
                </View>
                <View style={styles.totalsContainer}>
                  <Text style={[styles.totalsText, { fontWeight: '600' }]}>
                    Restante:
                  </Text>
                  <Text
                    style={[
                      styles.totalsValue,
                      {
                        fontWeight: 'bold',
                        color:
                          total - parseFloat(paymentAmount || '0') <= 0
                            ? '#4CAF50'
                            : theme.colors.error,
                      },
                    ]}
                  >
                    $
                    {Math.max(
                      0,
                      total - parseFloat(paymentAmount || '0'),
                    ).toFixed(2)}
                  </Text>
                </View>
              </>
            )}
            {}
            {isEditMode && (
              <>
                <View style={styles.totalsContainer}>
                  <Text style={styles.totalsText}>Pagado:</Text>
                  <Text style={[styles.totalsValue, { color: '#4CAF50' }]}>
                    ${(totalPaid || 0).toFixed(2)}
                  </Text>
                </View>
                <View style={styles.totalsContainer}>
                  <Text style={[styles.totalsText, { fontWeight: 'bold' }]}>
                    Restante:
                  </Text>
                  <Text
                    style={[
                      styles.totalsValue,
                      {
                        fontWeight: 'bold',
                        color:
                          pendingAmount > 0 ? theme.colors.error : '#4CAF50',
                      },
                    ]}
                  >
                    ${(pendingAmount || 0).toFixed(2)}
                  </Text>
                </View>
              </>
            )}
          </ScrollView>
          {}
          {!isEditMode && canRegisterPayments && !prepaymentId && (
            <View style={styles.paymentButtonContainer}>
              <Button
                mode="outlined"
                onPress={() => setShowPrepaymentModal(true)}
                style={styles.paymentButton}
                icon="credit-card"
              >
                💵 Registrar pago con la orden
              </Button>
            </View>
          )}
          <View style={styles.footer}>
            <Button
              mode="contained"
              onPress={handleConfirm}
              disabled={
                isConfirming ||
                items.length === 0 ||
                (isEditMode && !hasUnsavedChanges) ||
                (orderType === OrderTypeEnum.DINE_IN &&
                  (!selectedAreaId ||
                    (isTemporaryTable
                      ? !temporaryTableName || temporaryTableName.trim() === ''
                      : !selectedTableId))) || // Usar Enum
                (orderType === OrderTypeEnum.TAKE_AWAY &&
                  (!deliveryInfo.recipientName ||
                    deliveryInfo.recipientName.trim() === '')) || // Usar Enum
                (orderType === OrderTypeEnum.DELIVERY &&
                  (!deliveryInfo.fullAddress ||
                    deliveryInfo.fullAddress.trim() === '')) || // Usar Enum
                (orderType === OrderTypeEnum.DELIVERY &&
                  (!deliveryInfo.recipientPhone ||
                    deliveryInfo.recipientPhone.trim() === '')) // Usar Enum
              }
              style={[
                styles.confirmButton,
                isEditMode &&
                  hasUnsavedChanges && {
                    backgroundColor: '#FF6B35',
                  },
              ]}
              loading={isConfirming}
            >
              {isConfirming
                ? isEditMode
                  ? 'Guardando...'
                  : 'Enviando...'
                : isEditMode
                  ? hasUnsavedChanges
                    ? '⚠️ Guardar Cambios'
                    : 'Guardar Cambios'
                  : 'Enviar Orden'}
            </Button>
          </View>
          {}
          <Portal>
            <DateTimePickerSafe
              visible={isTimePickerVisible}
              mode="time"
              value={scheduledTime}
              onConfirm={handleTimeConfirm}
              onCancel={hideTimePicker}
              minimumDate={new Date()}
              minuteInterval={5}
              title={
                orderType === OrderTypeEnum.DELIVERY
                  ? 'Seleccionar Hora de Entrega'
                  : orderType === OrderTypeEnum.TAKE_AWAY
                    ? 'Seleccionar Hora de Recolección'
                    : 'Seleccionar Hora'
              }
              allowManualInput={true}
            />
          </Portal>
          <ConfirmationModal
            visible={isTimeAlertVisible}
            title="Hora Inválida"
            message="No puedes seleccionar una hora que ya ha pasado. Por favor, elige una hora futura."
            confirmText="Entendido"
            onConfirm={() => setTimeAlertVisible(false)}
          />
          {}
          <ConfirmationModal
            visible={showExitConfirmation}
            title="¿Descartar cambios?"
            message="Tienes cambios sin guardar. ¿Estás seguro de que quieres salir?"
            confirmText="Descartar"
            cancelText="Cancelar"
            onConfirm={() => {
              setShowExitConfirmation(false);
              onClose?.();
            }}
            onCancel={() => setShowExitConfirmation(false)}
          />
          {}
          <ConfirmationModal
            visible={showCancelConfirmation}
            title="¿Cancelar orden?"
            message={`¿Estás seguro de que quieres cancelar la orden #${orderNumber}? Esta acción no se puede deshacer.`}
            confirmText="Cancelar Orden"
            cancelText="No, mantener"
            onConfirm={() => {
              setShowCancelConfirmation(false);
              if (onCancelOrder) {
                onCancelOrder();
              }
            }}
            onCancel={() => setShowCancelConfirmation(false)}
          />
          {}
          <ConfirmationModal
            visible={showModifyInProgressConfirmation}
            title="¿Modificar producto en preparación?"
            message={`El producto "${modifyingItemName}" está actualmente en preparación. ¿Estás seguro de que quieres modificarlo?`}
            confirmText="Sí, modificar"
            cancelText="No, cancelar"
            onConfirm={() => {
              setShowModifyInProgressConfirmation(false);
              if (pendingModifyAction) {
                pendingModifyAction();
                setPendingModifyAction(null);
              }
              setModifyingItemName('');
            }}
            onCancel={() => {
              setShowModifyInProgressConfirmation(false);
              setPendingModifyAction(null);
              setModifyingItemName('');
            }}
          />
          {/* Modal de personalización de producto para edición */}
          {isEditMode && editingProduct && editingItemFromList && (
            <ProductCustomizationModal
              visible={true}
              product={editingProduct}
              editingItem={editingItemFromList}
              onDismiss={() => {
                setEditingItemFromList(null);
                setEditingProduct(null);
              }}
              onAddToCart={() => {}} // No usado en modo edición
              onUpdateItem={handleUpdateEditedItem}
            />
          )}
          {/* Modal de detalles de orden */}
          {isEditMode && (
            <OrderDetailModal
              visible={showDetailModal}
              onDismiss={() => setShowDetailModal(false)}
              orderId={orderId}
              orderNumber={orderNumber}
              orderData={orderData}
            />
          )}
          {/* Modal de historial de cambios */}
          {isEditMode && (
            <OrderHistoryModal
              visible={showHistoryModal}
              onDismiss={() => setShowHistoryModal(false)}
              orderId={orderId}
              orderNumber={orderNumber}
            />
          )}
          {/* FAB para pagos - solo en modo edición */}
          {isEditMode && orderId && visible && (
            <FAB
              icon="cash-multiple"
              style={[
                styles.paymentFab,
                {
                  backgroundColor: hasUnsavedChanges
                    ? '#9CA3AF'
                    : pendingAmount <= 0
                      ? '#4CAF50'
                      : theme.colors.primary,
                },
              ]}
              color="white"
              onPress={() => {
                if (hasUnsavedChanges) {
                  showSnackbar({
                    message:
                      'Debes guardar los cambios antes de registrar pagos',
                    type: 'warning',
                  });
                } else {
                  setShowPaymentModal(true);
                }
              }}
              visible={true}
            />
          )}
          {}
          {showPaymentModal && isEditMode && orderId && (
            <PaymentModal
              visible={showPaymentModal}
              onDismiss={() => setShowPaymentModal(false)}
              orderId={orderId}
              orderTotal={total}
              orderNumber={orderNumber}
              orderStatus={orderData?.orderStatus}
              onOrderCompleted={() => {
                setShowPaymentModal(false);
                onClose?.();
              }}
            />
          )}
          {}
          {showAdjustmentModal && isEditMode && (
            <AdjustmentFormModal
              visible={showAdjustmentModal}
              onDismiss={() => {
                setShowAdjustmentModal(false);
                setAdjustmentToEdit(null);
              }}
              onSave={(adjustment: OrderAdjustment) => {
                if (adjustmentToEdit) {
                  handleUpdateAdjustment(adjustmentToEdit.id!, adjustment);
                } else {
                  handleAddAdjustment(adjustment);
                }
                setShowAdjustmentModal(false);
                setAdjustmentToEdit(null);
              }}
              adjustment={adjustmentToEdit}
              orderSubtotal={subtotal}
            />
          )}
          {}
          <PaymentModal
            visible={showPrepaymentModal}
            onDismiss={() => setShowPrepaymentModal(false)}
            orderTotal={total}
            mode="prepayment"
            onPrepaymentCreated={handlePrepaymentCreated}
            existingPrepaymentId={prepaymentId || undefined}
            onPrepaymentDeleted={handlePrepaymentDeleted}
          />
          {}
          <ConfirmationModal
            visible={showDeletePrepaymentConfirm}
            onDismiss={() => setShowDeletePrepaymentConfirm(false)}
            title="¿Eliminar prepago?"
            message="¿Estás seguro de que deseas eliminar este prepago? Esta acción no se puede deshacer."
            confirmText="Eliminar"
            cancelText="Cancelar"
            onConfirm={confirmDeletePrepayment}
            onCancel={() => setShowDeletePrepaymentConfirm(false)}
          />
        </GestureHandlerRootView>
      </Modal>
    </Portal>
  );
};
const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '100%',
      height: '100%',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0,
    },
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
      paddingHorizontal: theme.spacing.s,
    },
    divider: {
      marginVertical: theme.spacing.s,
    },
    listItem: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      minHeight: 80,
    },
    itemTextContainer: {
      flex: 3,
      marginRight: theme.spacing.xs,
      justifyContent: 'center',
    },
    itemTitleText: {
      fontSize: 15,
      fontWeight: '500',
      color: theme.colors.onSurface,
      flexWrap: 'wrap',
      lineHeight: 20,
    },
    itemDescription: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      flexWrap: 'wrap',
      lineHeight: 18,
    },
    itemActionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      flexShrink: 0,
    },
    quantityActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    quantityButton: {
      marginHorizontal: -4,
      padding: 0,
    },
    quantityText: {
      fontSize: 14,
      fontWeight: 'bold',
      minWidth: 20,
      textAlign: 'center',
      marginHorizontal: 2,
    },
    itemPrice: {
      alignSelf: 'center',
      marginRight: theme.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      fontSize: 15,
      fontWeight: 'bold',
      minWidth: 55,
      textAlign: 'right',
    },
    priceContainer: {
      flexDirection: 'column',
      alignItems: 'flex-end',
      marginRight: theme.spacing.xs,
    },
    unitPriceText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    deleteActionContainer: {
      width: 120,
      height: '100%',
      justifyContent: 'center',
      alignItems: 'flex-end',
      paddingRight: theme.spacing.m,
    },
    deleteAction: {
      backgroundColor: theme.colors.error,
      justifyContent: 'center',
      alignItems: 'center',
      width: 90,
      height: '90%',
      borderRadius: theme.roundness * 2,
      flexDirection: 'column',
      shadowColor: theme.colors.error,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      elevation: 5,
    },
    deleteIconContainer: {
      width: 50,
      height: 50,
      borderRadius: 25,
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: 4,
    },
    deleteIcon: {
      margin: 0,
      padding: 0,
    },
    deleteActionText: {
      color: 'white',
      fontSize: 11,
      fontWeight: '700',
      letterSpacing: 1,
      textTransform: 'uppercase',
    },
    totalsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
    },
    totalsText: {
      fontSize: 16,
    },
    totalsValue: {
      fontSize: 16,
      fontWeight: 'bold',
    },
    totalLabel: {
      fontWeight: 'bold',
      fontSize: 18,
    },
    totalValue: {
      fontSize: 18,
      color: theme.colors.primary,
    },
    section: {
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.s,
    },
    sectionCompact: {
      marginBottom: 0,
      paddingBottom: 0,
    },
    dineInSelectorsRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: 0,
      gap: theme.spacing.s,
      marginTop: theme.spacing.s,
    },
    dineInSelectorContainer: {
      flex: 1,
    },
    selectorLoader: {},
    sectionTitleContainer: {
      flexDirection: 'row',
      alignItems: 'baseline',
      marginBottom: theme.spacing.xs,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.xs,
    },
    sectionTitleOptional: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
      marginLeft: theme.spacing.xs,
    },
    radioGroupHorizontal: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      alignItems: 'center',
      width: '100%',
      paddingVertical: theme.spacing.xs,
    },
    radioLabel: {
      marginLeft: 0,
      fontSize: 11,
      textTransform: 'uppercase',
      textAlign: 'center',
    },
    radioButtonItem: {
      paddingHorizontal: 0,
      paddingVertical: 4,
      flexShrink: 1,
      flex: 1,
      marginHorizontal: 2,
    },
    dropdownAnchor: {},
    dropdownContent: {},
    dropdownLabel: {},
    helperTextFix: {
      marginTop: -6,
      marginBottom: 0,
      paddingHorizontal: 12,
    },
    footer: {
      padding: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    },
    confirmButton: {
      paddingVertical: theme.spacing.xs,
    },
    input: {},
    fieldContainer: {
      marginTop: theme.spacing.s,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: theme.spacing.m,
    },
    phoneHelperContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginTop: 2,
      paddingHorizontal: 12,
      minHeight: 20,
    },
    recipientPhoneError: {
      flex: 1,
      marginBottom: 0,
      marginTop: 0,
    },
    digitCounter: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
      marginLeft: theme.spacing.xs,
      marginTop: 2,
    },
    phoneInputWrapper: {
      position: 'relative',
    },
    digitCounterAbsolute: {
      position: 'absolute',
      right: 50,
      top: 10,
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.7,
      backgroundColor: theme.colors.background,
      paddingHorizontal: 8,
      paddingVertical: 3,
      borderRadius: 12,
      zIndex: 1,
    },
    notesText: {
      fontStyle: 'italic',
      marginTop: 4,
      paddingTop: 4,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    customHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 4,
      paddingVertical: 8,
      backgroundColor: theme.colors.elevation.level2,
    },
    headerTitleContainer: {
      flex: 1,
      alignItems: 'center',
      gap: 4,
    },
    headerTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
    },
    orderStatusBadge: {
      paddingHorizontal: 12,
      paddingVertical: 4,
      borderRadius: 12,
    },
    orderStatusText: {
      ...theme.fonts.labelSmall,
      color: 'white',
      fontWeight: '600',
      fontSize: 11,
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 2,
      justifyContent: 'flex-start',
    },
    statusBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.s,
      paddingVertical: 2,
      borderRadius: 12,
      gap: 4,
    },
    statusDot: {
      width: 6,
      height: 6,
      borderRadius: 3,
    },
    statusText: {
      fontSize: 11,
      fontWeight: '600',
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    paymentFab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 140,
      zIndex: 1000,
      elevation: 6,
      width: 56,
      height: 56,
      justifyContent: 'center',
      alignItems: 'center',
    },
    paymentConfigButton: {
      marginTop: theme.spacing.s,
    },
    paymentButtonContainer: {
      paddingHorizontal: theme.spacing.s,
      paddingVertical: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    paymentButton: {
      marginVertical: theme.spacing.xs,
    },
    paymentValueContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    editPaymentButton: {
      margin: 0,
      marginLeft: theme.spacing.xs,
      width: 28,
      height: 28,
    },
    checkboxContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: theme.spacing.s,
      marginBottom: theme.spacing.xs,
    },
    checkboxLabel: {
      fontSize: 16,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    temporaryTableInputContainer: {
      marginTop: theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    prepaymentSection: {
      marginBottom: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    prepaymentHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    prepaymentTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    prepaymentActions: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
    },
    prepaymentIconButton: {
      margin: 0,
    },
    prepaymentWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.errorContainer,
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    prepaymentWarningText: {
      flex: 1,
      fontSize: 14,
      color: theme.colors.onErrorContainer,
      marginLeft: theme.spacing.xs,
    },
    errorModalContent: {
      backgroundColor: 'transparent',
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.m,
    },
    errorModalContainer: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      padding: theme.spacing.xl,
      alignItems: 'center',
      width: '90%',
      maxWidth: 400,
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    errorIconContainer: {
      width: 80,
      height: 80,
      borderRadius: 40,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    errorModalTitle: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: theme.spacing.s,
      textAlign: 'center',
    },
    errorModalMessage: {
      fontSize: 16,
      textAlign: 'center',
      marginBottom: theme.spacing.l,
      lineHeight: 22,
    },
    errorModalButton: {
      marginTop: theme.spacing.m,
      minWidth: 120,
    },
    errorModalButtonContent: {
      paddingHorizontal: theme.spacing.l,
    },
    errorModalButtonLabel: {
      fontSize: 16,
    },
    iconButtonNoMargin: {
      margin: 0,
    },
    adjustmentButton: {
      marginTop: theme.spacing.m,
      marginBottom: theme.spacing.s,
    },
    addProductsButton: {
      marginTop: theme.spacing.m,
      marginBottom: theme.spacing.m,
    },
  });
export default OrderCartDetail;

================
File: backend/src/orders/orders.service.ts
================
import {
  Inject,
  forwardRef,
  Injectable,
  NotFoundException,
  BadRequestException,
  Logger,
} from '@nestjs/common';
import { Order } from './domain/order';
import { OrderRepository } from './infrastructure/persistence/order.repository';
import { CreateOrderDto } from './dto/create-order.dto';
import { UpdateOrderDto } from './dto/update-order.dto';
import { FindAllOrdersDto } from './dto/find-all-orders.dto';
import { IPaginationOptions } from '../utils/types/pagination-options';
import { OrderStatus } from './domain/enums/order-status.enum';
import { OrderItemRepository } from './infrastructure/persistence/order-item.repository';
import { OrderItem } from './domain/order-item';
import { CreateOrderItemDto } from './dto/create-order-item.dto';
import { UpdateOrderItemDto } from './dto/update-order-item.dto';
import { PreparationStatus } from './domain/order-item';
import { PaymentMethod } from '../payments/domain/enums/payment-method.enum';
import { PaymentStatus } from '../payments/domain/enums/payment-status.enum';
import { v4 as uuidv4 } from 'uuid';
import { TicketImpressionRepository } from './infrastructure/persistence/ticket-impression.repository';
import { TicketType } from './domain/enums/ticket-type.enum';
import { TicketImpression } from './domain/ticket-impression';
import {
  ORDER_REPOSITORY,
  ORDER_ITEM_REPOSITORY,
  TICKET_IMPRESSION_REPOSITORY,
  PRODUCT_REPOSITORY,
  ORDER_PREPARATION_SCREEN_STATUS_REPOSITORY,
} from '../common/tokens';
import { FinalizeOrdersDto } from './dto/finalize-orders.dto';
import {
  OrderForFinalizationDto,
  OrderItemForFinalizationDto,
} from './dto/order-for-finalization.dto';
import { OrderForFinalizationListDto } from './dto/order-for-finalization-list.dto';
import { OrderOpenListDto } from './dto/order-open-list.dto';
import { ReceiptListDto } from './dto/receipt-list.dto';
import { CustomersService } from '../customers/customers.service';
import { DeliveryInfo } from './domain/delivery-info';
import { RestaurantConfigService } from '../restaurant-config/restaurant-config.service';
import { OrderType } from './domain/enums/order-type.enum';
import { ProductRepository } from '../products/infrastructure/persistence/product.repository';
import { OrderChangeTrackerV2Service } from './services/order-change-tracker-v2.service';
import { DataSource, Not, In, Between } from 'typeorm';
import { OrderEntity } from './infrastructure/persistence/relational/entities/order.entity';
import { format } from 'date-fns';
import { OrderPreparationScreenStatusRepository } from './infrastructure/persistence/order-preparation-screen-status.repository';
import {
  PreparationScreenStatus,
  OrderPreparationScreenStatus,
} from './domain/order-preparation-screen-status';
import { PaymentsService } from '../payments/payments.service';
import { TablesService } from '../tables/tables.service';
import { AutomaticPrintingService } from '../thermal-printers/automatic-printing.service';
import { ShiftsService } from '../shifts/shifts.service';
import { ThermalPrintersService } from '../thermal-printers/thermal-printers.service';
import { ThermalPrinter } from '../thermal-printers/domain/thermal-printer';
@Injectable()
export class OrdersService {
  private readonly logger = new Logger(OrdersService.name);
  constructor(
    @Inject(ORDER_REPOSITORY)
    private readonly orderRepository: OrderRepository,
    @Inject(ORDER_ITEM_REPOSITORY)
    private readonly orderItemRepository: OrderItemRepository,
    @Inject(TICKET_IMPRESSION_REPOSITORY)
    private readonly ticketImpressionRepository: TicketImpressionRepository,
    @Inject(PRODUCT_REPOSITORY)
    private readonly productRepository: ProductRepository,
    @Inject(ORDER_PREPARATION_SCREEN_STATUS_REPOSITORY)
    private readonly screenStatusRepository: OrderPreparationScreenStatusRepository,
    private readonly customersService: CustomersService,
    private readonly restaurantConfigService: RestaurantConfigService,
    private readonly orderChangeTracker: OrderChangeTrackerV2Service,
    private readonly dataSource: DataSource,
    private readonly paymentsService: PaymentsService,
    private readonly tablesService: TablesService,
    private readonly shiftsService: ShiftsService,
    @Inject(forwardRef(() => AutomaticPrintingService))
    private readonly automaticPrintingService: AutomaticPrintingService,
    @Inject(forwardRef(() => ThermalPrintersService))
    private readonly thermalPrintersService: ThermalPrintersService,
  ) {}
  async create(createOrderDto: CreateOrderDto): Promise<Order> {
    const currentShift = await this.shiftsService.getCurrentShift();
    if (!currentShift || !currentShift.isOpen()) {
      throw new BadRequestException(
        'No se pueden crear órdenes. No hay un turno abierto. Por favor, solicite a un administrador o gerente que abra el turno.',
      );
    }
    if (createOrderDto.customerId) {
      const isBanned = await this.customersService.isCustomerBanned(
        createOrderDto.customerId,
      );
      if (isBanned) {
        throw new BadRequestException(
          'No se puede crear un pedido para un cliente baneado',
        );
      }
    }
    let tableId = createOrderDto.tableId;
    if (
      createOrderDto.isTemporaryTable &&
      createOrderDto.temporaryTableName &&
      createOrderDto.temporaryTableAreaId
    ) {
      const temporaryTable = await this.tablesService.create({
        name: createOrderDto.temporaryTableName,
        areaId: createOrderDto.temporaryTableAreaId,
        isTemporary: true,
        temporaryIdentifier: uuidv4(),
        isActive: true,
        isAvailable: false,
        capacity: 4,
      });
      tableId = temporaryTable.id;
    }
    const restaurantConfig = await this.restaurantConfigService.getConfig();
    let estimatedMinutes = 0;
    switch (createOrderDto.orderType) {
      case OrderType.DINE_IN:
        estimatedMinutes = restaurantConfig.estimatedDineInTime;
        break;
      case OrderType.TAKE_AWAY:
        estimatedMinutes = restaurantConfig.estimatedPickupTime;
        break;
      case OrderType.DELIVERY:
        estimatedMinutes = restaurantConfig.estimatedDeliveryTime;
        break;
    }
    const now = new Date();
    const estimatedDeliveryTime = new Date(
      now.getTime() + estimatedMinutes * 60000,
    );
    let deliveryInfo: DeliveryInfo | null = null;
    const hasDeliveryData =
      createOrderDto.deliveryInfo &&
      Object.entries(createOrderDto.deliveryInfo).some(
        ([key, value]) => value !== undefined && value !== null && value !== '',
      );
    if (hasDeliveryData) {
      // Limpiar campos de deliveryInfo según el tipo de pedido
      const cleanedDeliveryInfo = this.cleanDeliveryInfoByOrderType(
        createOrderDto.deliveryInfo,
        createOrderDto.orderType,
      );
      // Solo crear deliveryInfo si quedan campos después de la limpieza
      const hasCleanedData = Object.entries(cleanedDeliveryInfo).some(
        ([key, value]) => value !== undefined && value !== null && value !== '',
      );
      if (hasCleanedData) {
        deliveryInfo = {
          id: uuidv4(),
          ...cleanedDeliveryInfo,
          createdAt: new Date(),
          updatedAt: new Date(),
        } as DeliveryInfo;
      }
    }
    const order = await this.orderRepository.create({
      userId: createOrderDto.userId || null,
      tableId: tableId || null, // Usar el tableId que puede ser de una mesa temporal
      shiftId: currentShift.id, // Asociar la orden al turno actual
      scheduledAt: createOrderDto.scheduledAt || null,
      orderType: createOrderDto.orderType,
      orderStatus: OrderStatus.IN_PROGRESS, // Estado inicial cuando se crea una orden
      subtotal: createOrderDto.subtotal,
      total: createOrderDto.total,
      notes: createOrderDto.notes,
      customerId: createOrderDto.customerId || null,
      isFromWhatsApp: createOrderDto.isFromWhatsApp || false,
      deliveryInfo: deliveryInfo,
      estimatedDeliveryTime: estimatedDeliveryTime,
    });
    // Marcar la mesa como ocupada si se asignó una mesa a la orden
    if (tableId && !createOrderDto.isTemporaryTable) {
      // Verificar que la mesa esté disponible antes de asignarla
      const table = await this.tablesService.findOne(tableId);
      if (!table.isAvailable) {
        throw new BadRequestException(
          `La mesa ${table.name} no está disponible`,
        );
      }
      await this.tablesService.update(tableId, { isAvailable: false });
    }
    if (createOrderDto.items && createOrderDto.items.length > 0) {
      for (const itemDto of createOrderDto.items) {
        // Crear un item individual
        const createOrderItemDto: CreateOrderItemDto = {
          orderId: order.id,
          productId: itemDto.productId,
          productVariantId: itemDto.productVariantId,
          basePrice: itemDto.basePrice,
          finalPrice: itemDto.finalPrice,
          preparationNotes: itemDto.preparationNotes,
          productModifiers: itemDto.productModifiers, // Pasar los modificadores aquí
          selectedPizzaCustomizations: itemDto.selectedPizzaCustomizations,
        };
        // Guardar el item
        await this.createOrderItemInternal(createOrderItemDto); // Usar método interno
      }
    }
    // Crear estados de pantalla para cada pantalla que tenga items
    await this.createInitialScreenStatuses(order.id);
    // Asociar pre-pago si se proporcionó uno
    if (createOrderDto.prepaymentId) {
      try {
        await this.paymentsService.associatePaymentToOrder(
          createOrderDto.prepaymentId,
          order.id,
        );
      } catch (error) {
        // Si falla la asociación del pago, registrar el error pero continuar
        // Ya que la orden ya fue creada exitosamente
        this.logger.error(
          `Error asociando pre-pago ${createOrderDto.prepaymentId} a orden ${order.id}:`,
          error,
        );
      }
    }
    // Recargar la orden completa con todas las relaciones
    const fullOrder = await this.findOne(order.id);
    // Obtener la entidad de orden para el historial
    const orderEntity = await this.dataSource.manager.findOne(OrderEntity, {
      where: { id: order.id },
      relations: [
        'orderItems',
        'orderItems.product',
        'orderItems.productVariant',
        'orderItems.productModifiers',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'table',
        'customer',
        'customer.addresses',
      ],
    });
    if (orderEntity) {
      await this.orderChangeTracker.trackOrderWithItems(
        'INSERT',
        orderEntity,
        null,
        createOrderDto.userId || 'system',
        this.dataSource.manager,
      );
    }
    if (
      order.orderType === OrderType.DELIVERY ||
      order.orderType === OrderType.TAKE_AWAY
    ) {
      await this.automaticPrintingService.printOrderAutomatically(
        order.id,
        order.orderType,
        createOrderDto.userId || null,
      );
    }
    return fullOrder;
  }
  private async createOrderItemInternal(
    createOrderItemDto: CreateOrderItemDto,
  ): Promise<OrderItem> {
    const order = await this.findOne(createOrderItemDto.orderId);
    const product = await this.productRepository.findOne(
      createOrderItemDto.productId,
    );
    if (!product) {
      throw new NotFoundException(
        `Product with ID ${createOrderItemDto.productId} not found`,
      );
    }
    const orderItem = new OrderItem();
    orderItem.id = uuidv4();
    orderItem.orderId = createOrderItemDto.orderId;
    orderItem.productId = createOrderItemDto.productId;
    orderItem.productVariantId = createOrderItemDto.productVariantId || null;
    orderItem.basePrice = createOrderItemDto.basePrice;
    orderItem.finalPrice = createOrderItemDto.finalPrice;
    if (
      order.orderStatus === OrderStatus.IN_PREPARATION ||
      order.orderStatus === OrderStatus.READY
    ) {
      orderItem.preparationStatus = PreparationStatus.IN_PROGRESS;
    } else {
      orderItem.preparationStatus = PreparationStatus.PENDING;
    }
    orderItem.statusChangedAt = new Date();
    orderItem.preparationNotes = createOrderItemDto.preparationNotes || null;
    orderItem.productModifiers = createOrderItemDto.productModifiers
      ? createOrderItemDto.productModifiers.map(
          (modifier) => ({ id: modifier.modifierId }) as any,
        )
      : [];
    if (createOrderItemDto.selectedPizzaCustomizations) {
      orderItem.selectedPizzaCustomizations =
        createOrderItemDto.selectedPizzaCustomizations.map(
          (customization) =>
            ({
              id: uuidv4(),
              orderItemId: orderItem.id,
              pizzaCustomizationId: customization.pizzaCustomizationId,
              half: customization.half,
              action: customization.action,
            }) as any,
        );
    }
    return this.orderItemRepository.save(orderItem);
  }
  async findOne(id: string): Promise<Order> {
    const order = await this.orderRepository.findById(id);
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }
  async update(id: string, updateOrderDto: UpdateOrderDto): Promise<Order> {
    const existingOrder = await this.findOne(id);
    let previousOrderEntity: OrderEntity | null = null;
    if (
      existingOrder.orderType === OrderType.DELIVERY ||
      existingOrder.orderType === OrderType.TAKE_AWAY
    ) {
      const queryRunner = this.dataSource.createQueryRunner();
      try {
        await queryRunner.connect();
        previousOrderEntity = await queryRunner.manager.findOne(OrderEntity, {
          where: { id },
          relations: [
            'orderItems',
            'orderItems.product',
            'orderItems.productVariant',
            'orderItems.productModifiers',
            'orderItems.selectedPizzaCustomizations',
            'orderItems.selectedPizzaCustomizations.pizzaCustomization',
            'deliveryInfo',
          ],
        });
      } finally {
        await queryRunner.release();
      }
    }
    let newTableId = updateOrderDto.tableId;
    if (
      updateOrderDto.isTemporaryTable &&
      updateOrderDto.temporaryTableName &&
      updateOrderDto.temporaryTableAreaId
    ) {
      const temporaryTable = await this.tablesService.create({
        name: updateOrderDto.temporaryTableName,
        areaId: updateOrderDto.temporaryTableAreaId,
        isTemporary: true,
        temporaryIdentifier: uuidv4(),
        isActive: true,
        isAvailable: false,
        capacity: 4,
      });
      newTableId = temporaryTable.id;
    }
    const updatePayload: Partial<Order> = {};
    if (
      updateOrderDto.userId !== undefined &&
      updateOrderDto.userId !== existingOrder.userId
    )
      updatePayload.userId = updateOrderDto.userId;
    if (newTableId !== undefined && newTableId !== existingOrder.tableId) {
      updatePayload.tableId = newTableId;
      if (
        existingOrder.orderStatus !== OrderStatus.COMPLETED &&
        existingOrder.orderStatus !== OrderStatus.CANCELLED
      ) {
        if (existingOrder.tableId) {
          const oldTable = await this.tablesService.findOne(
            existingOrder.tableId,
          );
          if (oldTable.isTemporary) {
            await this.tablesService.remove(existingOrder.tableId);
          } else {
            await this.tablesService.update(existingOrder.tableId, {
              isAvailable: true,
            });
          }
        }
        if (newTableId) {
          if (!updateOrderDto.isTemporaryTable) {
            const newTable = await this.tablesService.findOne(newTableId);
            if (!newTable.isAvailable) {
              throw new BadRequestException(
                `La mesa ${newTable.name} no está disponible`,
              );
            }
            await this.tablesService.update(newTableId, {
              isAvailable: false,
            });
          }
        }
      }
    }
    if (
      updateOrderDto.scheduledAt !== undefined &&
      new Date(updateOrderDto.scheduledAt).getTime() !==
        new Date(existingOrder.scheduledAt || 0).getTime()
    )
      updatePayload.scheduledAt = updateOrderDto.scheduledAt;
    if (
      updateOrderDto.orderStatus !== undefined &&
      updateOrderDto.orderStatus !== existingOrder.orderStatus
    ) {
      updatePayload.orderStatus = updateOrderDto.orderStatus;
      if (
        updateOrderDto.orderStatus === OrderStatus.COMPLETED ||
        updateOrderDto.orderStatus === OrderStatus.CANCELLED
      ) {
        updatePayload.finalizedAt = new Date();
        if (existingOrder.tableId) {
          const table = await this.tablesService.findOne(existingOrder.tableId);
          if (table.isTemporary) {
            await this.tablesService.remove(existingOrder.tableId);
          } else {
            await this.tablesService.update(existingOrder.tableId, {
              isAvailable: true,
            });
          }
        }
      }
    }
    if (
      updateOrderDto.orderType !== undefined &&
      updateOrderDto.orderType !== existingOrder.orderType
    ) {
      updatePayload.orderType = updateOrderDto.orderType;
      if (
        existingOrder.orderType === OrderType.DINE_IN &&
        updateOrderDto.orderType !== OrderType.DINE_IN
      ) {
        updatePayload.tableId = null;
        if (
          existingOrder.tableId &&
          existingOrder.orderStatus !== OrderStatus.COMPLETED &&
          existingOrder.orderStatus !== OrderStatus.CANCELLED
        ) {
          try {
            const table = await this.tablesService.findOne(
              existingOrder.tableId,
            );
            if (table.isTemporary) {
              await this.tablesService.remove(existingOrder.tableId);
            } else {
              await this.tablesService.update(existingOrder.tableId, {
                isAvailable: true,
              });
            }
          } catch (error) {
            this.logger.error(
              `Error al liberar mesa ${existingOrder.tableId}:`,
              error,
            );
          }
        }
      }
      if (
        (existingOrder.orderType === OrderType.DELIVERY ||
          existingOrder.orderType === OrderType.TAKE_AWAY) &&
        updateOrderDto.orderType === OrderType.DINE_IN
      ) {
      }
    }
    if (
      updateOrderDto.subtotal !== undefined &&
      Number(updateOrderDto.subtotal) !== Number(existingOrder.subtotal)
    )
      updatePayload.subtotal = updateOrderDto.subtotal;
    if (
      updateOrderDto.total !== undefined &&
      Number(updateOrderDto.total) !== Number(existingOrder.total)
    )
      updatePayload.total = updateOrderDto.total;
    if (
      updateOrderDto.notes !== undefined &&
      updateOrderDto.notes !== existingOrder.notes
    )
      updatePayload.notes = updateOrderDto.notes;
    if (
      updateOrderDto.customerId !== undefined &&
      updateOrderDto.customerId !== existingOrder.customerId
    )
      updatePayload.customerId = updateOrderDto.customerId;
    const finalOrderType = updateOrderDto.orderType || existingOrder.orderType;
    const deliveryInfoInPayload = 'deliveryInfo' in updateOrderDto;
    if (finalOrderType === OrderType.DINE_IN) {
      updatePayload.deliveryInfo = null;
    } else if (deliveryInfoInPayload || (existingOrder as any).deliveryInfo) {
      const deliveryData = deliveryInfoInPayload
        ? {
            ...(existingOrder as any).deliveryInfo,
            ...updateOrderDto.deliveryInfo,
          }
        : (existingOrder as any).deliveryInfo;
      updatePayload.deliveryInfo = await this.handleDeliveryInfo(
        id,
        deliveryData,
        finalOrderType,
      );
    }
    if (Object.keys(updatePayload).length > 0) {
      const updatedOrder = await this.orderRepository.update(id, updatePayload);
      if (!updatedOrder) {
        throw new Error(`Failed to update order with ID ${id}`);
      }
    }
    if (
      updateOrderDto.items !== undefined &&
      Array.isArray(updateOrderDto.items)
    ) {
      const existingItems = await this.orderItemRepository.findByOrderId(id);
      const existingItemsMap = new Map(
        existingItems.map((item) => [item.id, item]),
      );
      const itemsToUpdate = new Set<string>();
      const itemsToDelete = new Set(existingItemsMap.keys());
      let hasNewItems = false;
      for (const itemDto of updateOrderDto.items) {
        if (itemDto.id) {
          if (itemDto.id.includes(',')) {
            const itemIds = itemDto.id.split(',').filter((id) => id.trim());
            const existingGroupItems = itemIds.filter((id) =>
              existingItemsMap.has(id),
            );
            const nonExistingCount = itemIds.length - existingGroupItems.length;
            for (const singleItemId of existingGroupItems) {
              itemsToUpdate.add(singleItemId);
              itemsToDelete.delete(singleItemId);
              await this.updateOrderItem(singleItemId, {
                productId: itemDto.productId,
                productVariantId: itemDto.productVariantId,
                basePrice: itemDto.basePrice,
                finalPrice: itemDto.finalPrice,
                preparationNotes: itemDto.preparationNotes,
                productModifiers: itemDto.productModifiers,
                selectedPizzaCustomizations:
                  itemDto.selectedPizzaCustomizations,
              });
            }
            for (let i = 0; i < nonExistingCount; i++) {
              const createOrderItemDto: CreateOrderItemDto = {
                orderId: id,
                productId: itemDto.productId,
                productVariantId: itemDto.productVariantId,
                basePrice: itemDto.basePrice,
                finalPrice: itemDto.finalPrice,
                preparationNotes: itemDto.preparationNotes,
                productModifiers: itemDto.productModifiers,
                selectedPizzaCustomizations:
                  itemDto.selectedPizzaCustomizations,
              };
              await this.createOrderItemInternal(createOrderItemDto);
              hasNewItems = true;
            }
          } else if (existingItemsMap.has(itemDto.id)) {
            itemsToUpdate.add(itemDto.id);
            itemsToDelete.delete(itemDto.id);
            await this.updateOrderItem(itemDto.id, {
              productId: itemDto.productId,
              productVariantId: itemDto.productVariantId,
              basePrice: itemDto.basePrice,
              finalPrice: itemDto.finalPrice,
              preparationNotes: itemDto.preparationNotes,
              productModifiers: itemDto.productModifiers,
              selectedPizzaCustomizations: itemDto.selectedPizzaCustomizations,
            });
          } else {
            const createOrderItemDto: CreateOrderItemDto = {
              orderId: id,
              productId: itemDto.productId,
              productVariantId: itemDto.productVariantId,
              basePrice: itemDto.basePrice,
              finalPrice: itemDto.finalPrice,
              preparationNotes: itemDto.preparationNotes,
              productModifiers: itemDto.productModifiers,
              selectedPizzaCustomizations: itemDto.selectedPizzaCustomizations,
            };
            await this.createOrderItemInternal(createOrderItemDto);
            hasNewItems = true;
          }
        } else {
          const createOrderItemDto: CreateOrderItemDto = {
            orderId: id,
            productId: itemDto.productId,
            productVariantId: itemDto.productVariantId,
            basePrice: itemDto.basePrice,
            finalPrice: itemDto.finalPrice,
            preparationNotes: itemDto.preparationNotes,
            productModifiers: itemDto.productModifiers,
            selectedPizzaCustomizations: itemDto.selectedPizzaCustomizations,
          };
          await this.createOrderItemInternal(createOrderItemDto);
          hasNewItems = true;
        }
      }
      for (const itemIdToDelete of itemsToDelete) {
        await this.orderItemRepository.delete(itemIdToDelete);
      }
      if (hasNewItems) {
        await this.handleNewItemsAddedToOrder(id, existingOrder);
      }
    }
    if (
      updateOrderDto.adjustments !== undefined &&
      updateOrderDto.adjustments !== null
    ) {
      await this.dataSource.manager.transaction(async (manager) => {
        await manager.delete('adjustment', { orderId: id });
        for (const adj of updateOrderDto.adjustments!) {
          if (!adj.isDeleted) {
            await manager.save('adjustment', {
              orderId: id,
              name: adj.name,
              isPercentage: adj.isPercentage || false,
              value: adj.value || 0,
              amount: adj.amount || 0,
              appliedAt: new Date(),
              appliedById:
                updateOrderDto.userId || existingOrder.userId || 'system',
            });
          }
        }
      });
    }
    const updatedOrder = await this.findOne(id);
    let hasRealChanges = false;
    if (
      (updatedOrder.orderType === OrderType.DELIVERY ||
        updatedOrder.orderType === OrderType.TAKE_AWAY) &&
      previousOrderEntity
    ) {
      const queryRunner = this.dataSource.createQueryRunner();
      try {
        await queryRunner.connect();
        const currentEntity = await queryRunner.manager.findOne(OrderEntity, {
          where: { id: updatedOrder.id },
          relations: [
            'orderItems',
            'orderItems.product',
            'orderItems.productVariant',
            'orderItems.productModifiers',
            'orderItems.selectedPizzaCustomizations',
            'orderItems.selectedPizzaCustomizations.pizzaCustomization',
            'deliveryInfo',
          ],
        });
        if (currentEntity) {
          hasRealChanges = this.orderChangeTracker.detectStructuralChangesOnly(
            currentEntity,
            previousOrderEntity,
          );
        }
      } catch (error) {
        this.logger.error(`Error al detectar cambios en orden ${id}:`, error);
        hasRealChanges = true;
      } finally {
        await queryRunner.release();
      }
    }
    if (hasRealChanges) {
      await this.automaticPrintingService.printOrderAutomatically(
        updatedOrder.id,
        updatedOrder.orderType,
        updateOrderDto.userId || null,
        true,
      );
    }
    return updatedOrder;
  }
  async remove(id: string): Promise<void> {
    await this.findOne(id);
    return this.orderRepository.remove(id);
  }
  async findByUserId(userId: string): Promise<Order[]> {
    return this.orderRepository.findByUserId(userId);
  }
  async findByTableId(tableId: string): Promise<Order[]> {
    return this.orderRepository.findByTableId(tableId);
  }
  async findByShiftId(shiftId: string): Promise<Order[]> {
    const orders = await this.orderRepository.findByShiftId(shiftId);
    return orders.map((order) => {
      const preparationScreensMap = new Map<string, any>();
      if (order.orderItems) {
        order.orderItems.forEach((item) => {
          const screenName = item.product?.preparationScreen?.name;
          if (screenName) {
            if (!preparationScreensMap.has(screenName)) {
              preparationScreensMap.set(screenName, {
                name: screenName,
                items: [],
              });
            }
            preparationScreensMap.get(screenName)!.items.push(item);
          }
        });
      }
      const preparationScreenStatuses = Array.from(
        preparationScreensMap.values(),
      ).map((screen) => {
        const items = screen.items;
        const allReady = items.every(
          (item: any) =>
            item.preparationStatus === 'READY' ||
            item.preparationStatus === 'DELIVERED',
        );
        const someInProgress = items.some(
          (item: any) => item.preparationStatus === 'IN_PROGRESS',
        );
        let status: string;
        if (allReady) {
          status = 'READY';
        } else if (someInProgress) {
          status = 'IN_PROGRESS';
        } else {
          status = 'PENDING';
        }
        return {
          name: screen.name,
          status,
        };
      });
      const totalPaid =
        order.payments?.reduce(
          (sum, payment) => sum + (payment.amount || 0),
          0,
        ) || 0;
      return {
        ...order,
        preparationScreenStatuses:
          preparationScreenStatuses.length > 0
            ? preparationScreenStatuses
            : undefined,
        paymentsSummary: {
          totalPaid,
        },
      };
    });
  }
  async findOpenOrders(): Promise<Order[]> {
    const currentShift = await this.shiftsService.getCurrentShift();
    if (!currentShift) {
      return [];
    }
    const openOrders = await this.orderRepository.findByDateRange(
      currentShift.openedAt,
      new Date(),
    );
    return openOrders.filter(
      (order) =>
        order.orderStatus !== OrderStatus.COMPLETED &&
        order.orderStatus !== OrderStatus.CANCELLED,
    );
  }
  async findOpenOrdersOptimized(): Promise<OrderOpenListDto[]> {
    const currentShift = await this.shiftsService.getCurrentShift();
    if (!currentShift) {
      return [];
    }
    const orders = await this.orderRepository.findOpenOrdersOptimized(
      currentShift.openedAt,
      new Date(),
    );
    return orders.map((order) => this.mapToOpenListDto(order));
  }
  async createOrderItem(
    createOrderItemDto: CreateOrderItemDto,
  ): Promise<OrderItem> {
    return this.createOrderItemInternal(createOrderItemDto);
  }
  async findOrderItemById(id: string): Promise<OrderItem> {
    const orderItem = await this.orderItemRepository.findById(id);
    if (!orderItem) {
      throw new NotFoundException(`OrderItem with ID ${id} not found`);
    }
    return orderItem;
  }
  async findOrderItemsByOrderId(orderId: string): Promise<OrderItem[]> {
    await this.findOne(orderId);
    return this.orderItemRepository.findByOrderId(orderId);
  }
  private cleanDeliveryInfoByOrderType(
    deliveryInfo: Partial<DeliveryInfo>,
    orderType: OrderType,
  ): any {
    const result: any = {};
    const allFields = [
      'fullAddress',
      'street',
      'number',
      'interiorNumber',
      'neighborhood',
      'city',
      'state',
      'zipCode',
      'country',
      'latitude',
      'longitude',
      'recipientName',
      'recipientPhone',
      'deliveryInstructions',
    ];
    if (orderType === OrderType.DINE_IN) {
      allFields.forEach((field) => (result[field] = undefined));
      return result;
    }
    const getValue = (field: keyof DeliveryInfo) => {
      const value = deliveryInfo[field];
      return value !== undefined && value !== null && value !== ''
        ? value
        : undefined;
    };
    if (orderType === OrderType.TAKE_AWAY) {
      result.recipientName = getValue('recipientName');
      result.recipientPhone = getValue('recipientPhone');
      result.deliveryInstructions = getValue('deliveryInstructions');
      [
        'fullAddress',
        'street',
        'number',
        'interiorNumber',
        'neighborhood',
        'city',
        'state',
        'zipCode',
        'country',
        'latitude',
        'longitude',
      ].forEach((field) => (result[field] = null));
      return result;
    }
    if (orderType === OrderType.DELIVERY) {
      [
        'fullAddress',
        'street',
        'number',
        'interiorNumber',
        'neighborhood',
        'city',
        'state',
        'zipCode',
        'country',
        'deliveryInstructions',
        'recipientPhone',
      ].forEach(
        (field) => (result[field] = getValue(field as keyof DeliveryInfo)),
      );
      result.latitude =
        deliveryInfo.latitude !== undefined && deliveryInfo.latitude !== null
          ? deliveryInfo.latitude
          : undefined;
      result.longitude =
        deliveryInfo.longitude !== undefined && deliveryInfo.longitude !== null
          ? deliveryInfo.longitude
          : undefined;
      result.recipientName = null;
      return result;
    }
    allFields.forEach((field) => (result[field] = undefined));
    return result;
  }
  private hasDeliveryInfoChanges(
    existing: DeliveryInfo | null | undefined,
    updated: Partial<DeliveryInfo>,
  ): boolean {
    if (!existing && updated) {
      const hasAnyValue = Object.values(updated).some(
        (value) => value !== undefined && value !== null && value !== '',
      );
      return hasAnyValue;
    }
    // Si existe pero se está eliminando
    if (existing && !updated) {
      return true;
    }
    // Si ambos no existen, no hay cambios
    if (!existing && !updated) {
      return false;
    }
    // Comparar cada campo, incluyendo todos los campos de dirección
    const fieldsToCompare = [
      'recipientName',
      'recipientPhone',
      'fullAddress',
      'street',
      'number',
      'interiorNumber',
      'neighborhood',
      'city',
      'state',
      'zipCode',
      'country',
      'deliveryInstructions',
      'latitude',
      'longitude',
    ];
    for (const field of fieldsToCompare) {
      const existingValue = existing?.[field as keyof DeliveryInfo];
      const updatedValue = updated[field as keyof DeliveryInfo];
      const normalizedExisting =
        existingValue === null || existingValue === ''
          ? undefined
          : existingValue;
      const normalizedUpdated =
        updatedValue === null || updatedValue === '' ? undefined : updatedValue;
      // Si los valores normalizados son diferentes, hay cambio
      if (normalizedExisting !== normalizedUpdated) {
        return true;
      }
    }
    return false;
  }
  // Función helper para comparar si dos order items son iguales
  private areOrderItemsEqual(
    existingItem: OrderItem,
    updateDto: UpdateOrderItemDto,
  ): boolean {
    // Comparar campos básicos (comparando precios como números)
    const basicFieldsEqual =
      (updateDto.productId === undefined ||
        existingItem.productId === updateDto.productId) &&
      (updateDto.productVariantId === undefined ||
        existingItem.productVariantId === updateDto.productVariantId) &&
      (updateDto.basePrice === undefined ||
        Number(existingItem.basePrice) === Number(updateDto.basePrice)) &&
      (updateDto.finalPrice === undefined ||
        Number(existingItem.finalPrice) === Number(updateDto.finalPrice)) &&
      (updateDto.preparationNotes === undefined ||
        existingItem.preparationNotes === updateDto.preparationNotes ||
        (existingItem.preparationNotes === null &&
          updateDto.preparationNotes === '') ||
        (existingItem.preparationNotes === '' &&
          updateDto.preparationNotes === null));
    if (!basicFieldsEqual) {
      return false;
    }
    // Comparar modificadores
    if (updateDto.productModifiers !== undefined) {
      const existingModifierIds =
        existingItem.productModifiers
          ?.map((m) => (typeof m === 'object' && m.id ? m.id : m))
          .sort() || [];
      const newModifierIds = updateDto.productModifiers
        .map((m) => m.modifierId)
        .sort();
      if (
        JSON.stringify(existingModifierIds) !== JSON.stringify(newModifierIds)
      ) {
        return false;
      }
    }
    if (updateDto.selectedPizzaCustomizations !== undefined) {
      const existingCustomizations =
        existingItem.selectedPizzaCustomizations || [];
      const newCustomizations = updateDto.selectedPizzaCustomizations;
      if (existingCustomizations.length !== newCustomizations.length) {
        return false;
      }
      const sortedExisting = existingCustomizations
        .map((c) => ({
          pizzaCustomizationId: c.pizzaCustomizationId,
          half: c.half,
          action: c.action,
        }))
        .sort((a, b) => JSON.stringify(a).localeCompare(JSON.stringify(b)));
      const sortedNew = newCustomizations
        .map((c) => ({
          pizzaCustomizationId: c.pizzaCustomizationId,
          half: c.half,
          action: c.action,
        }))
        .sort((a, b) => JSON.stringify(a).localeCompare(JSON.stringify(b)));
      if (JSON.stringify(sortedExisting) !== JSON.stringify(sortedNew)) {
        return false;
      }
    }
    return true;
  }
  async updateOrderItem(
    id: string,
    updateOrderItemDto: UpdateOrderItemDto,
  ): Promise<OrderItem> {
    const existingOrderItem = await this.findOrderItemById(id);
    if (this.areOrderItemsEqual(existingOrderItem, updateOrderItemDto)) {
      return existingOrderItem;
    }
    const updatedData = {
      ...existingOrderItem,
      productId: updateOrderItemDto.productId ?? existingOrderItem.productId,
      productVariantId:
        updateOrderItemDto.productVariantId ??
        existingOrderItem.productVariantId,
      basePrice: updateOrderItemDto.basePrice ?? existingOrderItem.basePrice,
      finalPrice: updateOrderItemDto.finalPrice ?? existingOrderItem.finalPrice,
      preparationStatus:
        updateOrderItemDto.preparationStatus ??
        existingOrderItem.preparationStatus,
      statusChangedAt: updateOrderItemDto.preparationStatus
        ? new Date()
        : existingOrderItem.statusChangedAt,
      preparationNotes:
        updateOrderItemDto.preparationNotes !== undefined
          ? updateOrderItemDto.preparationNotes
          : existingOrderItem.preparationNotes,
    };
    const updatedOrderItem = new OrderItem();
    updatedOrderItem.id = updatedData.id;
    updatedOrderItem.orderId = updatedData.orderId;
    updatedOrderItem.productId = updatedData.productId;
    updatedOrderItem.productVariantId = updatedData.productVariantId;
    updatedOrderItem.basePrice = updatedData.basePrice;
    updatedOrderItem.finalPrice = updatedData.finalPrice;
    updatedOrderItem.preparationStatus = updatedData.preparationStatus;
    updatedOrderItem.statusChangedAt = updatedData.statusChangedAt;
    updatedOrderItem.preparationNotes = updatedData.preparationNotes;
    updatedOrderItem.preparedAt = existingOrderItem.preparedAt;
    updatedOrderItem.preparedById = existingOrderItem.preparedById;
    updatedOrderItem.order = existingOrderItem.order;
    updatedOrderItem.product = existingOrderItem.product;
    updatedOrderItem.productVariant = existingOrderItem.productVariant;
    updatedOrderItem.productModifiers = updateOrderItemDto.productModifiers
      ? updateOrderItemDto.productModifiers.map(
          (modifier) => ({ id: modifier.modifierId }) as any,
        )
      : existingOrderItem.productModifiers;
    if (updateOrderItemDto.selectedPizzaCustomizations !== undefined) {
      const existingCustomizations =
        existingOrderItem.selectedPizzaCustomizations || [];
      const newCustomizations = updateOrderItemDto.selectedPizzaCustomizations;
      const existingMap = new Map(
        existingCustomizations.map((c) => [
          `${c.pizzaCustomizationId}-${c.half}-${c.action}`,
          c.id,
        ]),
      );
      updatedOrderItem.selectedPizzaCustomizations = newCustomizations.map(
        (customization) => {
          const key = `${customization.pizzaCustomizationId}-${customization.half}-${customization.action}`;
          const existingId = existingMap.get(key);
          return {
            id: existingId || uuidv4(),
            orderItemId: updatedOrderItem.id,
            pizzaCustomizationId: customization.pizzaCustomizationId,
            half: customization.half,
            action: customization.action,
          } as any;
        },
      );
    } else {
      updatedOrderItem.selectedPizzaCustomizations =
        existingOrderItem.selectedPizzaCustomizations;
    }
    updatedOrderItem.createdAt = existingOrderItem.createdAt;
    updatedOrderItem.deletedAt = existingOrderItem.deletedAt;
    return this.orderItemRepository.update(updatedOrderItem);
  }
  async deleteOrderItem(id: string): Promise<void> {
    const orderItem = await this.findOrderItemById(id);
    await this.orderItemRepository.delete(orderItem.id);
  }
  async registerTicketImpression(
    orderId: string,
    userId: string,
    ticketType: TicketType,
    printerId?: string,
  ): Promise<TicketImpression> {
    await this.findOne(orderId);
    const impressionData = {
      orderId,
      userId,
      ticketType,
      printerId,
      impressionTime: new Date(),
    };
    return this.ticketImpressionRepository.create(impressionData);
  }
  async findImpressionsByOrderId(orderId: string): Promise<TicketImpression[]> {
    await this.findOne(orderId);
    return this.ticketImpressionRepository.findByOrderId(orderId);
  }
  async recoverOrder(id: string): Promise<Order> {
    const order = await this.findOne(id);
    if (
      order.orderStatus !== OrderStatus.COMPLETED &&
      order.orderStatus !== OrderStatus.CANCELLED
    ) {
      throw new NotFoundException(
        `La orden no está en un estado recuperable. Estado actual: ${order.orderStatus}`,
      );
    }
    const updateData: UpdateOrderDto = {
      orderStatus: OrderStatus.DELIVERED,
    };
    return this.update(id, updateData);
  }
  async findOrdersForFinalizationList(): Promise<
    OrderForFinalizationListDto[]
  > {
    const currentShift = await this.shiftsService.getCurrentShift();
    if (!currentShift) {
      return [];
    }
    const orders = await this.dataSource.getRepository(OrderEntity).find({
      where: {
        shiftId: currentShift.id,
        orderStatus: Not(In([OrderStatus.COMPLETED, OrderStatus.CANCELLED])),
      },
      relations: [
        'user',
        'table',
        'table.area',
        'payments',
        'deliveryInfo',
        'orderItems',
        'orderItems.product',
        'orderItems.product.preparationScreen',
        'ticketImpressions',
      ],
      select: {
        id: true,
        shiftOrderNumber: true,
        orderType: true,
        orderStatus: true,
        total: true,
        createdAt: true,
        scheduledAt: true,
        notes: true,
        isFromWhatsApp: true,
        user: {
          username: true,
          firstName: true,
          lastName: true,
        },
        table: {
          id: true,
          name: true,
          area: {
            id: true,
            name: true,
          },
        },
        payments: {
          id: true,
          amount: true,
        },
        deliveryInfo: {
          id: true,
          recipientName: true,
          recipientPhone: true,
          fullAddress: true,
        },
        orderItems: {
          id: true,
          product: {
            id: true,
            preparationScreen: {
              id: true,
              name: true,
            },
          },
        },
      },
      order: {
        createdAt: 'ASC',
      },
    });
    return orders.map((order) => this.mapToFinalizationListDto(order));
  }
  async findOrderForFinalizationById(
    id: string,
  ): Promise<OrderForFinalizationDto> {
    const order = await this.orderRepository.findOrderForFinalizationById(id);
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return this.mapOrderToFinalizationDto(order);
  }
  private mapOrderToFinalizationDto(order: Order): OrderForFinalizationDto {
    const groupedItems = new Map<
      string,
      {
        items: OrderItem[];
        modifiers: any[];
      }
    >();
    const preparationScreens = new Set<string>();
    order.orderItems.forEach((item) => {
      if (item.product?.preparationScreen?.name) {
        preparationScreens.add(item.product.preparationScreen.name);
      }
      const modifierKeys =
        item.productModifiers
          ?.map((m) => m.id)
          .sort()
          .join(',') || '';
      const key = `${item.productId}-${item.productVariantId || ''}-${modifierKeys}-${item.preparationNotes || ''}-${item.preparationStatus}`;
      if (!groupedItems.has(key)) {
        groupedItems.set(key, {
          items: [],
          modifiers: item.productModifiers || [],
        });
      }
      groupedItems.get(key)!.items.push(item);
    });
    const orderItemDtos: OrderItemForFinalizationDto[] = [];
    groupedItems.forEach(({ items, modifiers }) => {
      const firstItem = items[0];
      const dto: OrderItemForFinalizationDto = {
        productId: firstItem.productId,
        productVariantId: firstItem.productVariantId || undefined,
        quantity: items.length,
        basePrice: firstItem.basePrice,
        finalPrice: firstItem.finalPrice,
        preparationNotes: firstItem.preparationNotes || undefined,
        preparationStatus: firstItem.preparationStatus,
        product: firstItem.product
          ? {
              id: firstItem.product.id,
              name: firstItem.product.name,
              description: firstItem.product.description || undefined,
            }
          : {
              id: firstItem.productId,
              name: 'Producto no encontrado',
              description: undefined,
            },
        productVariant: firstItem.productVariant
          ? {
              id: firstItem.productVariant.id,
              name: firstItem.productVariant.name,
            }
          : undefined,
        modifiers: modifiers.map((m) => ({
          id: m.id,
          name: m.name,
          price: m.price,
        })),
        selectedPizzaCustomizations:
          firstItem.selectedPizzaCustomizations || undefined,
      };
      orderItemDtos.push(dto);
    });
    const orderDto: OrderForFinalizationDto = {
      id: order.id,
      shiftOrderNumber: order.shiftOrderNumber,
      orderType: order.orderType,
      orderStatus: order.orderStatus,
      total: order.total,
      orderItems: orderItemDtos,
      createdAt: order.createdAt,
      updatedAt: order.updatedAt,
      scheduledAt: order.scheduledAt || undefined,
      tableId: order.tableId || undefined,
      user: order.user
        ? {
            id: order.user.id,
            firstName: order.user.firstName || undefined,
            lastName: order.user.lastName || undefined,
          }
        : undefined,
      table: order.table
        ? {
            id: order.table.id,
            number: order.table.name,
            area: order.table.area
              ? {
                  name: order.table.area.name,
                }
              : undefined,
          }
        : undefined,
      deliveryInfo: order.deliveryInfo || undefined,
      isFromWhatsApp: order.isFromWhatsApp,
      preparationScreens: Array.from(preparationScreens).sort(),
      payments:
        order.payments?.map((payment) => ({
          id: payment.id,
          amount: payment.amount,
          paymentMethod: payment.paymentMethod,
          paymentStatus: payment.paymentStatus,
          createdAt: payment.createdAt,
          updatedAt: payment.updatedAt,
        })) || undefined,
      preparationScreenStatuses: order.preparationScreenStatusesFull?.map(
        (status) => ({
          id: status.id,
          preparationScreenId: status.preparationScreenId,
          preparationScreenName:
            status.preparationScreen?.name || 'Pantalla desconocida',
          status: status.status,
          startedAt: status.startedAt,
          completedAt: status.completedAt,
        }),
      ),
      ticketImpressions:
        order.ticketImpressions?.map((impression) => ({
          id: impression.id,
          ticketType: impression.ticketType,
          impressionTime: impression.impressionTime,
          user: impression.user
            ? {
                id: impression.user.id,
                firstName: impression.user.firstName || undefined,
                lastName: impression.user.lastName || undefined,
              }
            : undefined,
          printer: impression.printer
            ? {
                id: impression.printer.id,
                name: impression.printer.name,
              }
            : undefined,
        })) || undefined,
    };
    return orderDto;
  }
  async getReceiptDetail(id: string): Promise<any> {
    const order = await this.dataSource.getRepository(OrderEntity).findOne({
      where: {
        id,
        orderStatus: In([OrderStatus.COMPLETED, OrderStatus.CANCELLED]),
      },
      relations: [
        'user',
        'table',
        'table.area',
        'deliveryInfo',
        'orderItems',
        'orderItems.product',
        'orderItems.product.preparationScreen',
        'orderItems.productVariant',
        'orderItems.selectedPizzaCustomizations',
        'orderItems.selectedPizzaCustomizations.pizzaCustomization',
        'orderItems.productModifiers',
        'payments',
        'ticketImpressions',
        'ticketImpressions.user',
        'ticketImpressions.printer',
      ],
    });
    if (!order) {
      throw new NotFoundException('Recibo no encontrado');
    }
    const preparationScreens = new Set<string>();
    if (order.orderItems) {
      order.orderItems.forEach((item: any) => {
        if (item.product?.preparationScreen?.name) {
          preparationScreens.add(item.product.preparationScreen.name);
        }
      });
    }
    return {
      id: order.id,
      shiftOrderNumber: order.shiftOrderNumber,
      orderType: order.orderType,
      orderStatus: order.orderStatus,
      total: Number(order.total),
      subtotal: Number(order.subtotal),
      createdAt: order.createdAt,
      updatedAt: order.updatedAt,
      finalizedAt: order.finalizedAt || undefined,
      scheduledAt: order.scheduledAt || undefined,
      notes: order.notes || undefined,
      user: order.user
        ? {
            id: order.user.id,
            firstName: order.user.firstName || undefined,
            lastName: order.user.lastName || undefined,
            username: order.user.username,
          }
        : undefined,
      table: order.table
        ? {
            id: order.table.id,
            number: order.table.name,
            name: order.table.name,
            isTemporary: order.table.isTemporary,
            area: order.table.area
              ? {
                  id: order.table.area.id,
                  name: order.table.area.name,
                }
              : undefined,
          }
        : undefined,
      deliveryInfo: order.deliveryInfo || undefined,
      preparationScreens: Array.from(preparationScreens).sort(),
      orderItems:
        order.orderItems?.map((item: any) => ({
          id: item.id,
          quantity: item.quantity,
          basePrice: Number(item.basePrice),
          finalPrice: Number(item.finalPrice),
          preparationNotes: item.preparationNotes || undefined,
          preparationStatus: item.preparationStatus || undefined,
          product: {
            id: item.product.id,
            name: item.product.name,
            description: item.product.description || undefined,
            price: Number(item.product.price),
          },
          productVariant: item.productVariant
            ? {
                id: item.productVariant.id,
                name: item.productVariant.name,
                price: Number(item.productVariant.price),
              }
            : undefined,
          productModifiers:
            item.productModifiers?.map((mod: any) => ({
              id: mod.id,
              name: mod.name,
              price: Number(mod.price),
            })) || undefined,
          selectedPizzaCustomizations:
            item.selectedPizzaCustomizations?.map((custom: any) => ({
              pizzaCustomizationId: custom.pizzaCustomizationId,
              half: custom.half,
              action: custom.action,
              pizzaCustomization: custom.pizzaCustomization
                ? {
                    id: custom.pizzaCustomization.id,
                    name: custom.pizzaCustomization.name,
                    type: custom.pizzaCustomization.type,
                  }
                : undefined,
            })) || undefined,
        })) || [],
      payments:
        order.payments?.map((payment: any) => ({
          id: payment.id,
          amount: Number(payment.amount),
          paymentMethod: payment.paymentMethod,
          paymentStatus: payment.paymentStatus,
          createdAt: payment.createdAt,
          updatedAt: payment.updatedAt,
        })) || undefined,
      ticketImpressions:
        order.ticketImpressions?.map((impression: any) => ({
          id: impression.id,
          ticketType: impression.ticketType,
          impressionTime: impression.impressionTime,
          user: impression.user
            ? {
                id: impression.user.id,
                firstName: impression.user.firstName || undefined,
                lastName: impression.user.lastName || undefined,
              }
            : undefined,
          printer: impression.printer
            ? {
                id: impression.printer.id,
                name: impression.printer.name,
              }
            : undefined,
        })) || undefined,
    };
  }
  private mapToFinalizationListDto(order: any): OrderForFinalizationListDto {
    const totalPaid =
      order.payments?.reduce(
        (sum: number, payment: any) => sum + Number(payment.amount),
        0,
      ) || 0;
    const preparationScreensMap = new Map<
      string,
      {
        items: any[];
        name: string;
      }
    >();
    if (order.orderItems) {
      order.orderItems.forEach((item: any) => {
        if (item.product?.preparationScreen?.name) {
          const screenName = item.product.preparationScreen.name;
          if (!preparationScreensMap.has(screenName)) {
            preparationScreensMap.set(screenName, {
              name: screenName,
              items: [],
            });
          }
          preparationScreensMap.get(screenName)!.items.push(item);
        }
      });
    }
    const preparationScreenStatuses = Array.from(
      preparationScreensMap.values(),
    ).map((screen) => {
      const items = screen.items;
      const allReady = items.every(
        (item: any) =>
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED',
      );
      const someInProgress = items.some(
        (item: any) => item.preparationStatus === 'IN_PROGRESS',
      );
      let status: string;
      if (allReady) {
        status = 'READY';
      } else if (someInProgress) {
        status = 'IN_PROGRESS';
      } else {
        status = 'PENDING';
      }
      return {
        name: screen.name,
        status,
      };
    });
    const dto: OrderForFinalizationListDto = {
      id: order.id,
      shiftOrderNumber: order.shiftOrderNumber,
      orderType: order.orderType,
      orderStatus: order.orderStatus,
      total: Number(order.total),
      createdAt: order.createdAt,
      scheduledAt: order.scheduledAt || undefined,
      isFromWhatsApp: order.isFromWhatsApp,
      paymentsSummary: {
        totalPaid,
      },
    };
    if (preparationScreenStatuses.length > 0) {
      dto.preparationScreens = preparationScreenStatuses.map((s) => s.name);
      dto.preparationScreenStatuses = preparationScreenStatuses;
    }
    if (order.table) {
      dto.table = {
        number: order.table.name,
        area: order.table.area
          ? {
              name: order.table.area.name,
            }
          : undefined,
      };
    }
    if (order.deliveryInfo) {
      dto.deliveryInfo = {
        recipientName: order.deliveryInfo.recipientName || undefined,
        recipientPhone: order.deliveryInfo.recipientPhone || undefined,
        fullAddress: order.deliveryInfo.fullAddress || undefined,
      };
    }
    if (order.ticketImpressions && order.ticketImpressions.length > 0) {
      dto.ticketImpressionCount = order.ticketImpressions.length;
    }
    if (order.notes) {
      dto.notes = order.notes;
    }
    if (order.user) {
      dto.createdBy = {
        username: order.user.username,
        firstName: order.user.firstName,
        lastName: order.user.lastName,
      };
    }
    return dto;
  }
  private mapToReceiptListDto(order: any): ReceiptListDto {
    const totalPaid =
      order.payments?.reduce(
        (sum: number, payment: any) =>
          payment.paymentStatus === 'COMPLETED'
            ? sum + Number(payment.amount)
            : sum,
        0,
      ) || 0;
    const preparationScreensMap = new Map<
      string,
      {
        items: any[];
        name: string;
      }
    >();
    if (order.orderItems) {
      order.orderItems.forEach((item: any) => {
        if (item.product?.preparationScreen?.name) {
          const screenName = item.product.preparationScreen.name;
          if (!preparationScreensMap.has(screenName)) {
            preparationScreensMap.set(screenName, {
              name: screenName,
              items: [],
            });
          }
          preparationScreensMap.get(screenName)!.items.push(item);
        }
      });
    }
    const preparationScreenStatuses = Array.from(
      preparationScreensMap.values(),
    ).map((screen) => {
      const items = screen.items;
      const allReady = items.every(
        (item: any) =>
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED',
      );
      const someInProgress = items.some(
        (item: any) => item.preparationStatus === 'IN_PROGRESS',
      );
      let status: string;
      if (allReady) {
        status = 'READY';
      } else if (someInProgress) {
        status = 'IN_PROGRESS';
      } else {
        status = 'PENDING';
      }
      return {
        name: screen.name,
        status,
      };
    });
    const dto: ReceiptListDto = {
      id: order.id,
      shiftOrderNumber: order.shiftOrderNumber,
      orderType: order.orderType,
      orderStatus: order.orderStatus,
      total: Number(order.total),
      createdAt: order.createdAt,
      finalizedAt: order.finalizedAt,
      scheduledAt: order.scheduledAt || undefined,
      isFromWhatsApp: order.isFromWhatsApp,
      paymentsSummary: {
        totalPaid,
      },
    };
    if (preparationScreenStatuses.length > 0) {
      dto.preparationScreenStatuses = preparationScreenStatuses;
    }
    if (order.table) {
      dto.table = {
        id: order.table.id,
        number: order.table.number || order.table.name,
        name: order.table.name,
        isTemporary: order.table.isTemporary || false,
        area: order.table.area
          ? {
              name: order.table.area.name,
            }
          : undefined,
      };
    }
    if (order.deliveryInfo) {
      dto.deliveryInfo = {
        recipientName: order.deliveryInfo.recipientName || undefined,
        recipientPhone: order.deliveryInfo.recipientPhone || undefined,
        fullAddress: order.deliveryInfo.fullAddress || undefined,
      };
    }
    if (order.ticketImpressions && order.ticketImpressions.length > 0) {
      dto.ticketImpressionCount = order.ticketImpressions.length;
    }
    if (order.notes) {
      dto.notes = order.notes;
    }
    if (order.user) {
      dto.createdBy = {
        username: order.user.username,
        firstName: order.user.firstName,
        lastName: order.user.lastName,
      };
    }
    return dto;
  }
  private mapToOpenListDto(order: Order): OrderOpenListDto {
    const dto: OrderOpenListDto = {
      id: order.id,
      shiftOrderNumber: order.shiftOrderNumber,
      orderType: order.orderType,
      orderStatus: order.orderStatus,
      total: order.total,
      createdAt: order.createdAt,
      scheduledAt: order.scheduledAt || undefined,
      notes: order.notes,
      paymentsSummary: order.paymentsSummary,
      ticketImpressionCount: order.ticketImpressionCount,
      preparationScreenStatuses: order.preparationScreenStatuses,
      isFromWhatsApp: order.isFromWhatsApp,
    };
    if (order.table) {
      dto.table = {
        id: order.table.id,
        number: order.table.name,
        name: order.table.name,
        isTemporary: order.table.isTemporary,
        area: order.table.area
          ? {
              name: order.table.area.name,
            }
          : undefined,
      };
    }
    if (order.deliveryInfo) {
      dto.deliveryInfo = {
        recipientName: order.deliveryInfo.recipientName || undefined,
        recipientPhone: order.deliveryInfo.recipientPhone || undefined,
        fullAddress: order.deliveryInfo.fullAddress || undefined,
      };
    }
    if (order.user) {
      dto.createdBy = {
        username: order.user.username,
        firstName: order.user.firstName,
        lastName: order.user.lastName,
      };
    }
    return dto;
  }
  async getReceiptsList(filterOptions?: {
    startDate?: Date;
    endDate?: Date;
    orderType?: OrderType;
  }): Promise<ReceiptListDto[]> {
    const currentShift = await this.shiftsService.getCurrentShift();
    if (!currentShift) {
      return [];
    }
    const orders = await this.dataSource.getRepository(OrderEntity).find({
      where: {
        shiftId: currentShift.id,
        orderStatus: In([OrderStatus.COMPLETED, OrderStatus.CANCELLED]),
        ...(filterOptions?.orderType && { orderType: filterOptions.orderType }),
        ...(filterOptions?.startDate &&
          filterOptions?.endDate && {
            finalizedAt: Between(
              filterOptions.startDate,
              filterOptions.endDate,
            ),
          }),
      },
      relations: [
        'user',
        'table',
        'table.area',
        'payments',
        'deliveryInfo',
        'orderItems',
        'orderItems.product',
        'orderItems.product.preparationScreen',
        'ticketImpressions',
      ],
      order: {
        finalizedAt: 'DESC',
      },
    });
    return orders.map((order) => this.mapToReceiptListDto(order));
  }
  async finalizeMultipleOrders(
    finalizeOrdersDto: FinalizeOrdersDto,
    userId: string,
  ): Promise<void> {
    const { orderIds, paymentMethod, notes } = finalizeOrdersDto;
    for (const orderId of orderIds) {
      const order = await this.findOne(orderId);
      if (
        order.orderStatus !== OrderStatus.READY &&
        order.orderStatus !== OrderStatus.DELIVERED
      ) {
        continue;
      }
      const finalizationNote = `[Finalizada por usuario ${userId} el ${new Date().toLocaleString()}] Método de pago: ${paymentMethod}`;
      const currentNotes = order.notes || '';
      let finalNotes = finalizationNote;
      if (notes && notes.trim()) {
        finalNotes += ` - ${notes.trim()}`;
      }
      if (currentNotes) {
        finalNotes = `${currentNotes}\n${finalNotes}`;
      }
      // Actualizar el estado de la orden a COMPLETED
      const updateData: UpdateOrderDto = {
        orderStatus: OrderStatus.COMPLETED,
        notes: finalNotes,
      };
      await this.update(orderId, updateData);
      // Liberar la mesa si la orden tenía una asignada
      if (order.tableId) {
        // Verificar si es una mesa temporal
        const table = await this.tablesService.findOne(order.tableId);
        if (table.isTemporary) {
          // Eliminar mesa temporal
          await this.tablesService.remove(order.tableId);
        } else {
          // Liberar mesa normal
          await this.tablesService.update(order.tableId, { isAvailable: true });
        }
      }
    }
  }
  async changeOrderStatus(id: string, newStatus: OrderStatus): Promise<Order> {
    const order = await this.findOne(id);
    const validTransitions: Record<OrderStatus, OrderStatus[]> = {
      [OrderStatus.PENDING]: [
        OrderStatus.IN_PROGRESS,
        OrderStatus.IN_PREPARATION,
        OrderStatus.CANCELLED,
      ],
      [OrderStatus.IN_PROGRESS]: [
        OrderStatus.IN_PREPARATION,
        OrderStatus.READY,
        OrderStatus.CANCELLED,
      ],
      [OrderStatus.IN_PREPARATION]: [OrderStatus.READY, OrderStatus.CANCELLED],
      [OrderStatus.READY]: [
        OrderStatus.IN_DELIVERY,
        OrderStatus.DELIVERED,
        OrderStatus.COMPLETED,
        OrderStatus.CANCELLED,
      ],
      [OrderStatus.IN_DELIVERY]: [OrderStatus.DELIVERED, OrderStatus.CANCELLED],
      [OrderStatus.DELIVERED]: [OrderStatus.COMPLETED],
      [OrderStatus.COMPLETED]: [], // No se puede cambiar desde completado
      [OrderStatus.CANCELLED]: [], // No se puede cambiar desde cancelado
    };
    const allowedTransitions = validTransitions[order.orderStatus] || [];
    if (!allowedTransitions.includes(newStatus)) {
      throw new BadRequestException(
        `No se puede cambiar el estado de ${order.orderStatus} a ${newStatus}`,
      );
    }
    const updatedOrder = await this.update(id, { orderStatus: newStatus });
    if (
      order.tableId &&
      (newStatus === OrderStatus.COMPLETED ||
        newStatus === OrderStatus.CANCELLED)
    ) {
      // Verificar si es una mesa temporal
      const table = await this.tablesService.findOne(order.tableId);
      if (table.isTemporary) {
        // Eliminar mesa temporal
        await this.tablesService.remove(order.tableId);
      } else {
        // Liberar mesa normal
        await this.tablesService.update(order.tableId, { isAvailable: true });
      }
    }
    return updatedOrder;
  }
  async hasItemsWithStatus(orderId: string, status: string): Promise<boolean> {
    const items = await this.orderItemRepository.findByOrderId(orderId);
    return items.some((item) => item.preparationStatus === status);
  }
  async changeOrderItemsStatus(
    orderId: string,
    userId: string,
    fromStatus: string,
    toStatus: string,
  ): Promise<void> {
    // Esta implementación delega al servicio de kitchen que ya tiene la lógica correcta
    // pero necesitamos inyectarlo primero. Por ahora usaremos TypeORM directamente.
    // Verificar que la orden existe
    const order = await this.findOne(orderId);
    if (!order) {
      throw new NotFoundException('Order not found');
    }
    const items = await this.orderItemRepository.findByOrderId(orderId);
    for (const item of items) {
      if (item.preparationStatus === fromStatus) {
        const updatedItem = {
          ...item,
          preparationStatus: toStatus as PreparationStatus,
          statusChangedAt: new Date(),
          ...(toStatus === 'READY' && {
            preparedAt: new Date(),
            preparedById: userId,
          }),
          ...(toStatus === 'PENDING' && {
            preparedAt: null,
            preparedById: null,
          }),
        };
        await this.orderItemRepository.save(updatedItem);
      }
    }
  }
  private async createInitialScreenStatuses(orderId: string): Promise<void> {
    const orderItems = await this.orderItemRepository.findByOrderId(orderId);
    const screenIds = new Set<string>();
    for (const item of orderItems) {
      if (item.product?.preparationScreenId) {
        screenIds.add(item.product.preparationScreenId);
      }
    }
    for (const screenId of screenIds) {
      await this.screenStatusRepository.create({
        orderId,
        preparationScreenId: screenId,
        status: PreparationScreenStatus.PENDING,
      } as OrderPreparationScreenStatus);
    }
  }
  private async handleNewItemsAddedToOrder(
    orderId: string,
    existingOrder: Order,
  ): Promise<void> {
    const orderItems = await this.orderItemRepository.findByOrderId(orderId);
    const itemsByScreen = new Map<string, OrderItem[]>();
    for (const item of orderItems) {
      if (item.product?.preparationScreenId) {
        const screenId = item.product.preparationScreenId;
        if (!itemsByScreen.has(screenId)) {
          itemsByScreen.set(screenId, []);
        }
        itemsByScreen.get(screenId)!.push(item);
      }
    }
    for (const [screenId, items] of itemsByScreen) {
      const existingStatus =
        await this.screenStatusRepository.findByOrderAndScreen(
          orderId,
          screenId,
        );
      if (existingStatus) {
        const hasPendingItems = items.some(
          (item) => item.preparationStatus === PreparationStatus.PENDING,
        );
        if (
          existingStatus.status === PreparationScreenStatus.READY &&
          hasPendingItems
        ) {
          await this.screenStatusRepository.update(existingStatus.id, {
            status: PreparationScreenStatus.IN_PREPARATION,
            completedAt: null,
            completedById: null,
          });
          if (existingOrder.orderStatus === OrderStatus.READY) {
            await this.orderRepository.update(orderId, {
              orderStatus: OrderStatus.IN_PREPARATION,
            });
          }
        }
      } else {
        await this.screenStatusRepository.create({
          orderId,
          preparationScreenId: screenId,
          status: PreparationScreenStatus.PENDING,
        } as OrderPreparationScreenStatus);
      }
    }
  }
  private async handleDeliveryInfo(
    orderId: string,
    deliveryData: Partial<DeliveryInfo>,
    orderType: OrderType,
  ): Promise<DeliveryInfo | null> {
    if (orderType === OrderType.DINE_IN) {
      return null;
    }
    const cleanedData = this.cleanDeliveryInfoByOrderType(
      deliveryData,
      orderType,
    );
    const hasValidFields = Object.entries(cleanedData).some(
      ([key, value]) => value !== undefined,
    );
    if (!hasValidFields) {
      return null;
    }
    const DeliveryInfoEntity = await import(
      './infrastructure/persistence/relational/entities/delivery-info.entity'
    );
    const DeliveryInfoRepo = this.dataSource.getRepository(
      DeliveryInfoEntity.DeliveryInfoEntity,
    );
    const existingDeliveryInfo = await DeliveryInfoRepo.findOne({
      where: { orderId },
    });
    if (existingDeliveryInfo) {
      return {
        ...existingDeliveryInfo,
        ...cleanedData,
        updatedAt: new Date(),
      } as DeliveryInfo;
    } else {
      const newId = uuidv4();
      return {
        id: newId,
        orderId,
        ...cleanedData,
        createdAt: new Date(),
        updatedAt: new Date(),
      } as DeliveryInfo;
    }
  }
  async quickFinalizeMultipleOrders(
    orderIds: string[],
    userId: string,
  ): Promise<{ ordersWithWarnings: string[] }> {
    const ordersWithWarnings: string[] = [];
    for (const orderId of orderIds) {
      try {
        const order = await this.findOne(orderId);
        if (order.orderStatus !== OrderStatus.READY) {
          ordersWithWarnings.push(orderId);
        }
        await this.quickFinalizeOrder(orderId, userId);
      } catch (error) {
        this.logger.error(
          `Error finalizando orden ${orderId}: ${error.message}`,
        );
      }
    }
    return { ordersWithWarnings };
  }
  async quickFinalizeOrder(orderId: string, userId: string): Promise<void> {
    const order = await this.findOne(orderId);
    if (!order) {
      throw new NotFoundException(`Orden con ID ${orderId} no encontrada`);
    }
    if (
      order.orderStatus === OrderStatus.COMPLETED ||
      order.orderStatus === OrderStatus.CANCELLED
    ) {
      throw new BadRequestException('La orden ya está finalizada o cancelada');
    }
    const totalPaid =
      order.payments?.reduce((sum, payment) => {
        return sum + Number(payment.amount);
      }, 0) || 0;
    const totalOrder =
      typeof order.total === 'string' ? parseFloat(order.total) : order.total;
    const pendingAmount = totalOrder - totalPaid;
    if (pendingAmount > 0) {
      await this.paymentsService.create({
        orderId: orderId,
        amount: pendingAmount,
        paymentMethod: PaymentMethod.CASH,
      });
    }
    await this.update(orderId, { orderStatus: OrderStatus.COMPLETED });
    if (order.tableId) {
      const table = await this.tablesService.findOne(order.tableId);
      if (table.isTemporary) {
        await this.tablesService.remove(order.tableId);
      } else {
        await this.tablesService.update(order.tableId, { isAvailable: true });
      }
    }
  }
  async printOrderTicket(
    orderId: string,
    printerId: string,
    ticketType: 'GENERAL' | 'BILLING',
    userId: string,
  ): Promise<void> {
    const printerDetails = await this.thermalPrintersService.findOne(printerId);
    if (!printerDetails || !printerDetails.isActive) {
      throw new BadRequestException('Printer not found or inactive');
    }
    if (ticketType === 'BILLING') {
      await this.printBillingTicketWithPrinter(orderId, printerDetails, userId);
    } else {
      await this.automaticPrintingService.printDeliveryPickupTicket(
        orderId,
        printerDetails,
        userId,
        true,
      );
    }
  }
  private async printBillingTicketWithPrinter(
    orderId: string,
    printerDetails: ThermalPrinter,
    userId: string,
  ): Promise<void> {
    const order = await this.findOne(orderId);
    if (!order) {
      throw new NotFoundException(`Order with ID ${orderId} not found`);
    }
    const restaurantConfig = await this.restaurantConfigService.getConfig();
    const {
      ThermalPrinter: ThermalPrinterLib,
      PrinterTypes,
    } = require('node-thermal-printer');
    const printer = new ThermalPrinterLib({
      type: PrinterTypes.EPSON,
      interface: `tcp://${printerDetails.ipAddress}:${printerDetails.port}`,
      removeSpecialCharacters: false,
      lineCharacter: '=',
    });
    try {
      const isConnected = await printer.isPrinterConnected();
      if (!isConnected) {
        throw new Error(
          `No se pudo conectar a la impresora ${printerDetails.name}`,
        );
      }
      await this.printBillingTicket(printer, order, restaurantConfig);
      for (let i = 0; i < printerDetails.feedLines; i++) {
        printer.newLine();
      }
      if (printerDetails.cutPaper) {
        printer.cut();
      }
      await printer.execute();
      printer.clear();
    } catch (error) {
      printer.clear();
      throw error;
    }
    await this.registerTicketImpression(orderId, userId, TicketType.BILLING);
  }
  private async printBillingTicket(
    printer: any,
    order: Order,
    restaurantConfig: any,
  ): Promise<void> {
    const {
      TicketFormatter,
    } = require('../thermal-printers/utils/ticket-formatter');
    const formatter = new TicketFormatter(80);
    printer.alignCenter();
    printer.setTextSize(1, 1);
    printer.bold(true);
    printer.println(restaurantConfig.restaurantName || 'Restaurant');
    printer.bold(false);
    printer.setTextNormal();
    if (restaurantConfig.address) {
      printer.println(restaurantConfig.address);
      if (
        restaurantConfig.city ||
        restaurantConfig.state ||
        restaurantConfig.postalCode
      ) {
        const cityStateParts = [
          restaurantConfig.city,
          restaurantConfig.state,
          restaurantConfig.postalCode,
        ]
          .filter(Boolean)
          .join(', ');
        printer.println(cityStateParts);
      }
    }
    if (restaurantConfig.phoneMain || restaurantConfig.phoneSecondary) {
      const phones: string[] = [];
      if (restaurantConfig.phoneMain)
        phones.push(`Tel: ${restaurantConfig.phoneMain}`);
      if (restaurantConfig.phoneSecondary)
        phones.push(`Tel 2: ${restaurantConfig.phoneSecondary}`);
      printer.println(phones.join(' - '));
    }
    printer.drawLine();
    printer.setTextSize(2, 2);
    printer.bold(true);
    if (order.table) {
      if (order.table.area) {
        printer.println(
          `#${order.shiftOrderNumber} - ${order.table.area.name}`,
        );
        printer.println(`Mesa: ${order.table.name}`);
      } else {
        printer.println(`#${order.shiftOrderNumber}`);
        printer.println(`Mesa: ${order.table.name}`);
      }
    } else {
      printer.println(
        `#${order.shiftOrderNumber} - ${this.getOrderTypeLabel(order.orderType)}`,
      );
    }
    printer.bold(false);
    printer.setTextNormal();
    printer.drawLine();
    printer.alignLeft();
    printer.println(
      `Fecha: ${new Date(order.createdAt).toLocaleString('es-MX', {
        timeZone: 'America/Mexico_City',
      })}`,
    );
    if (order.user?.firstName || order.user?.lastName) {
      const userName = [order.user.firstName, order.user.lastName]
        .filter(Boolean)
        .join(' ');
      printer.println(`Atendido por: ${userName}`);
    }
    if (order.deliveryInfo && order.deliveryInfo.recipientName) {
      printer.println(`Cliente: ${order.deliveryInfo.recipientName}`);
      if (order.deliveryInfo.recipientPhone) {
        printer.println(`Tel: ${order.deliveryInfo.recipientPhone}`);
      }
    }
    printer.drawLine();
    printer.bold(true);
    printer.println('DETALLE DE CONSUMO');
    printer.bold(false);
    const groupedItems = this.groupIdenticalItemsForBilling(
      order.orderItems || [],
    );
    let maxPriceWidth = 0;
    for (const item of groupedItems) {
      const priceStr = this.formatMoney(item.totalPrice);
      maxPriceWidth = Math.max(maxPriceWidth, priceStr.length);
    }
    const dynamicPriceColumnWidth = maxPriceWidth + 2;
    for (const item of groupedItems) {
      const productTitle = `${item.quantity}x ${item.variantName || item.productName}`;
      const productLines = formatter.formatProductTable(
        productTitle,
        this.formatMoney(item.totalPrice),
        'normal',
        dynamicPriceColumnWidth,
      );
      for (const line of productLines) {
        printer.println(line);
      }
      if (item.pizzaCustomizations) {
        printer.println(`  ${item.pizzaCustomizations}`);
      }
      if (item.modifiers && item.modifiers.length > 0) {
        for (const modifier of item.modifiers) {
          let modifierText: string;
          if (modifier.price > 0) {
            if (item.quantity > 1) {
              modifierText = `• ${modifier.name} (+${this.formatMoney(modifier.price)} c/u)`;
            } else {
              modifierText = `• ${modifier.name} (+${this.formatMoney(modifier.price)})`;
            }
          } else {
            modifierText = `• ${modifier.name}`;
          }
          printer.println(`  ${modifierText}`);
        }
      }
      if (item.preparationNotes) {
        const wrappedNotes = formatter.wrapText(
          `  Notas: ${item.preparationNotes}`,
          'normal',
        );
        for (const line of wrappedNotes) {
          printer.println(line);
        }
      }
    }
    printer.drawLine();
    const subtotal = Number(order.subtotal || order.total);
    const total = Number(order.total);
    const subtotalStr = this.formatMoney(subtotal);
    const totalStr = this.formatMoney(total);
    const maxTotalWidth = Math.max(subtotalStr.length, totalStr.length) + 2;
    const subtotalLines = formatter.formatProductTable(
      'Subtotal:',
      subtotalStr,
      'normal',
      maxTotalWidth,
    );
    for (const line of subtotalLines) {
      printer.println(line);
    }
    const totalLines = formatter.formatProductTable(
      'TOTAL:',
      totalStr,
      'normal',
      maxTotalWidth,
    );
    printer.setTextSize(1, 1);
    printer.bold(true);
    for (const line of totalLines) {
      printer.println(line);
    }
    printer.setTextNormal();
    printer.bold(false);
    if (order.payments && order.payments.length > 0) {
      printer.drawLine();
      printer.bold(true);
      printer.println('DETALLE DE PAGOS');
      printer.bold(false);
      let totalPaid = 0;
      order.payments.forEach((payment) => {
        const amount = payment.amount;
        totalPaid += amount;
        const paymentLines = formatter.formatProductTable(
          this.getPaymentMethodLabel(payment.paymentMethod),
          this.formatMoney(amount),
          'normal',
          maxTotalWidth,
        );
        for (const line of paymentLines) {
          printer.println(line);
        }
      });
      const remaining = total - totalPaid;
      if (remaining > 0.01) {
        printer.println('');
        const remainingLines = formatter.formatProductTable(
          'POR PAGAR:',
          this.formatMoney(remaining),
          'normal',
          maxTotalWidth,
        );
        printer.bold(true);
        for (const line of remainingLines) {
          printer.println(line);
        }
        printer.bold(false);
      }
    }
    if (order.notes) {
      printer.drawLine();
      printer.bold(true);
      printer.println('NOTAS:');
      printer.bold(false);
      const wrappedNotes = formatter.wrapText(order.notes, 'normal');
      for (const line of wrappedNotes) {
        printer.println(line);
      }
    }
    printer.drawLine();
    printer.alignCenter();
    printer.println('¡Gracias por su preferencia!');
    printer.println('');
    // RFC y datos fiscales si están configurados
    if (restaurantConfig.rfc) {
      printer.println(`RFC: ${restaurantConfig.rfc}`);
    }
    printer.println('');
  }
  private getItemDescription(item: OrderItem): string {
    if (!item.product) return 'Producto desconocido';
    let description = item.product.name;
    if (item.productVariant) {
      description += ' - ' + item.productVariant.name;
    }
    if (item.productModifiers && item.productModifiers.length > 0) {
      const modifiers = item.productModifiers.map((m) => m.name).join(', ');
      description += ' (' + modifiers + ')';
    }
    return description;
  }
  private formatMoney(amount: number): string {
    return `$${amount.toFixed(2)}`;
  }
  private groupIdenticalItemsForBilling(items: any[]): any[] {
    const groupedMap = new Map<string, any>();
    items.forEach((item) => {
      const modifierIds = (item.productModifiers || [])
        .map((mod) => mod.id)
        .sort()
        .join(',');
      const pizzaCustomizationIds = (item.selectedPizzaCustomizations || [])
        .map((pc) => `${pc.pizzaCustomizationId}-${pc.half}-${pc.action}`)
        .sort()
        .join(',');
      const groupKey = `${item.productId}-${item.productVariantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}`;
      const existingItem = groupedMap.get(groupKey);
      if (existingItem) {
        existingItem.quantity += 1;
        existingItem.totalPrice += Number(item.finalPrice);
      } else {
        const groupedItem = {
          productId: item.productId,
          productName: item.product?.name || 'Producto',
          variantId: item.productVariantId || undefined,
          variantName: item.productVariant?.name || undefined,
          quantity: 1,
          unitPrice: Number(item.basePrice),
          totalPrice: Number(item.finalPrice),
          modifiers: (item.productModifiers || []).map((mod) => ({
            id: mod.id,
            name: mod.name,
            price: Number(mod.price) || 0,
          })),
          preparationNotes: item.preparationNotes || undefined,
          pizzaCustomizations: this.formatPizzaCustomizationsForBilling(
            item.selectedPizzaCustomizations,
          ),
        };
        groupedMap.set(groupKey, groupedItem);
      }
    });
    return Array.from(groupedMap.values());
  }
  private formatPizzaCustomizationsForBilling(
    customizations: any[],
  ): string | undefined {
    if (!customizations || customizations.length === 0) return undefined;
    const parts: string[] = [];
    customizations.forEach((cust) => {
      if (cust.pizzaCustomization?.name) {
        parts.push(cust.pizzaCustomization.name);
      }
    });
    return parts.length > 0 ? parts.join(', ') : undefined;
  }
  private getPaymentMethodLabel(method: string): string {
    switch (method) {
      case 'CASH':
        return 'Efectivo';
      case 'CREDIT_CARD':
        return 'T. Crédito';
      case 'DEBIT_CARD':
        return 'T. Débito';
      case 'TRANSFER':
        return 'Transferencia';
      default:
        return method;
    }
  }
  private getOrderTypeLabel(orderType: OrderType): string {
    switch (orderType) {
      case OrderType.DELIVERY:
        return 'DOMICILIO';
      case OrderType.TAKE_AWAY:
        return 'PARA LLEVAR';
      case OrderType.DINE_IN:
        return 'MESA';
      default:
        return orderType;
    }
  }
  async getShiftSalesSummary(shiftId: string): Promise<any> {
    const shift = await this.shiftsService.getShiftSummary(shiftId);
    if (!shift) {
      throw new NotFoundException('Turno no encontrado');
    }
    const orders = await this.orderRepository.findByShiftIdForSummary(shiftId);
    const completedOrders = orders.filter(
      (order) =>
        order.orderStatus === OrderStatus.COMPLETED ||
        order.orderStatus === OrderStatus.DELIVERED,
    );
    const categoriesMap = new Map<
      string,
      {
        categoryId: string;
        categoryName: string;
        quantity: number;
        totalAmount: number;
        subcategories: Map<
          string,
          {
            subcategoryId: string;
            subcategoryName: string;
            quantity: number;
            totalAmount: number;
            products: Map<
              string,
              {
                productId: string;
                productName: string;
                quantity: number;
                totalAmount: number;
              }
            >;
          }
        >;
      }
    >();
    let totalQuantity = 0;
    let totalSales = 0;
    const productSalesMap = new Map<
      string,
      {
        productId: string;
        productName: string;
        quantity: number;
        totalAmount: number;
      }
    >();
    for (const order of completedOrders) {
      if (!order.orderItems) continue;
      for (const item of order.orderItems) {
        const product = item.product;
        if (!product || !product.subcategory) continue;
        const subcategory = product.subcategory;
        const category = subcategory.category;
        if (!category) continue;
        const quantity = 1;
        const itemPrice = Number(item.finalPrice) || 0;
        const amount = itemPrice;
        if (itemPrice === 0) continue;
        totalQuantity += quantity;
        totalSales += amount;
        if (!categoriesMap.has(category.id)) {
          categoriesMap.set(category.id, {
            categoryId: category.id,
            categoryName: category.name,
            quantity: 0,
            totalAmount: 0,
            subcategories: new Map(),
          });
        }
        const categoryData = categoriesMap.get(category.id)!;
        categoryData.quantity += quantity;
        categoryData.totalAmount += amount;
        if (!categoryData.subcategories.has(subcategory.id)) {
          categoryData.subcategories.set(subcategory.id, {
            subcategoryId: subcategory.id,
            subcategoryName: subcategory.name,
            quantity: 0,
            totalAmount: 0,
            products: new Map(),
          });
        }
        const subcategoryData = categoryData.subcategories.get(subcategory.id)!;
        subcategoryData.quantity += quantity;
        subcategoryData.totalAmount += amount;
        const productKey = item.productVariant
          ? `${product.id}-${item.productVariant.id}`
          : product.id;
        const productName = item.productVariant
          ? `${product.name} - ${item.productVariant.name}`
          : product.name;
        if (!subcategoryData.products.has(productKey)) {
          subcategoryData.products.set(productKey, {
            productId: productKey,
            productName: productName,
            quantity: 0,
            totalAmount: 0,
          });
        }
        const productData = subcategoryData.products.get(productKey)!;
        productData.quantity += quantity;
        productData.totalAmount += amount;
        if (!productSalesMap.has(productKey)) {
          productSalesMap.set(productKey, {
            productId: productKey,
            productName: productName,
            quantity: 0,
            totalAmount: 0,
          });
        }
        const totalProductData = productSalesMap.get(productKey)!;
        totalProductData.quantity += quantity;
        totalProductData.totalAmount += amount;
      }
    }
    const categories = Array.from(categoriesMap.values())
      .map((cat) => ({
        ...cat,
        percentage: totalSales > 0 ? (cat.totalAmount / totalSales) * 100 : 0,
        subcategories: Array.from(cat.subcategories.values())
          .map((sub) => ({
            ...sub,
            products: Array.from(sub.products.values())
              .sort((a, b) => b.totalAmount - a.totalAmount)
              .map((prod) => ({
                ...prod,
                averagePrice:
                  prod.quantity > 0 ? prod.totalAmount / prod.quantity : 0,
              })),
          }))
          .sort((a, b) => b.totalAmount - a.totalAmount),
      }))
      .sort((a, b) => b.totalAmount - a.totalAmount);
    const topProducts = Array.from(productSalesMap.values())
      .sort((a, b) => b.quantity - a.quantity)
      .slice(0, 10)
      .map((prod) => ({
        ...prod,
        averagePrice: prod.quantity > 0 ? prod.totalAmount / prod.quantity : 0,
      }));
    return {
      shiftId: shift.id,
      shiftNumber: shift.shiftNumber,
      date: shift.date,
      totalSales,
      totalQuantity,
      completedOrders: completedOrders.length,
      averageTicket:
        completedOrders.length > 0 ? totalSales / completedOrders.length : 0,
      categories,
      topProducts,
      startTime: shift.openedAt,
      endTime: shift.closedAt,
    };
  }
}

================
File: app/src/modules/orderFinalization/components/OrderCard.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Card,
  Text,
  Checkbox,
  Chip,
  IconButton,
  Icon,
} from 'react-native-paper';
import { OrderForFinalizationList } from '../types/orderFinalization.types';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import {
  formatOrderTypeShort,
  formatOrderStatus,
  getStatusColor,
  getPaymentStatus,
} from '@/app/utils/orderFormatters';
interface OrderCardProps {
  order: OrderForFinalizationList;
  isSelected: boolean;
  onToggleSelection: (orderId: string) => void;
  onShowDetails: (order: OrderForFinalizationList) => void;
  onPrintPress?: (order: OrderForFinalizationList) => void;
}
export const OrderCard = React.memo<OrderCardProps>(
  ({ order, isSelected, onToggleSelection, onShowDetails, onPrintPress }) => {
    const theme = useAppTheme();
    const responsive = useResponsive();
    const styles = React.useMemo(() => createStyles(responsive), [responsive]);
    let orderTitle = `#${order.shiftOrderNumber} • ${formatOrderTypeShort(order.orderType)}`;
    if (order.orderType === 'DINE_IN' && order.table) {
      const tableDisplay = order.table.isTemporary
        ? order.table.name
        : `Mesa ${order.table.name || order.table.number || 'N/A'}`;
      orderTitle += ` • ${order.table.area?.name || 'Sin área'} • ${tableDisplay}`;
    } else if (order.orderType === 'TAKE_AWAY') {
      if (order.deliveryInfo?.recipientName) {
        orderTitle += ` • ${order.deliveryInfo.recipientName}`;
      }
      if (order.deliveryInfo?.recipientPhone) {
        orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;
      }
    } else if (order.orderType === 'DELIVERY') {
      if (order.deliveryInfo?.fullAddress) {
        orderTitle += ` • ${order.deliveryInfo.fullAddress}`;
      }
      if (order.deliveryInfo?.recipientPhone) {
        orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;
      }
    }
    const totalAmount =
      typeof order.total === 'string' ? parseFloat(order.total) : order.total;
    const totalPaid = order.paymentsSummary?.totalPaid || 0;
    const pendingAmount = totalAmount - totalPaid;
    const paymentStatus = getPaymentStatus(order);
    return (
      <TouchableOpacity
        activeOpacity={0.95}
        onPress={() => onShowDetails(order)}
      >
        <Card
          style={[
            styles.orderCard,
            {
              backgroundColor: isSelected
                ? theme.colors.primaryContainer
                : theme.colors.surface,
              borderColor: isSelected ? theme.colors.primary : 'transparent',
              borderWidth: isSelected ? 2 : 0,
            },
          ]}
          mode="elevated"
        >
          <Card.Content style={styles.cardContent}>
            <View style={styles.mainContainer}>
              <View style={styles.leftContainer}>
                <Text
                  style={[
                    styles.orderNumber,
                    {
                      color: isSelected
                        ? theme.colors.onPrimaryContainer
                        : theme.colors.onSurface,
                    },
                  ]}
                >
                  {orderTitle}
                  <Text
                    style={[
                      styles.orderPrice,
                      {
                        color:
                          pendingAmount > 0 ? theme.colors.error : '#10B981',
                      },
                    ]}
                  >
                    {' • '}
                    {pendingAmount > 0
                      ? `Por pagar: $${pendingAmount.toFixed(2)}`
                      : `Pagado: $${totalAmount.toFixed(2)}`}
                  </Text>
                  {order.notes && (
                    <Text
                      style={[
                        styles.notesInline,
                        {
                          color: isSelected
                            ? theme.colors.onPrimaryContainer
                            : theme.colors.onSurfaceVariant,
                        },
                      ]}
                      numberOfLines={1}
                    >
                      {' • '}
                      {order.notes}
                    </Text>
                  )}
                </Text>
                <View style={styles.timeAndPaymentRow}>
                  <Text
                    style={[
                      styles.orderTime,
                      {
                        color: isSelected
                          ? theme.colors.primary
                          : theme.colors.primary,
                      },
                    ]}
                  >
                    {format(new Date(order.createdAt), 'p', { locale: es })}
                  </Text>
                  {(() => {
                    const color =
                      paymentStatus === 'paid'
                        ? '#10B981'
                        : paymentStatus === 'partial'
                          ? '#F59E0B'
                          : '#EF4444';
                    const icon =
                      paymentStatus === 'paid'
                        ? '✓'
                        : paymentStatus === 'partial'
                          ? '½'
                          : '•';
                    return (
                      <View
                        style={[
                          styles.miniPaymentBadge,
                          { backgroundColor: color },
                        ]}
                      >
                        <Text style={styles.miniPaymentText}>{icon}</Text>
                      </View>
                    );
                  })()}
                  {}
                  {order.isFromWhatsApp && (
                    <View
                      style={[
                        styles.inlinePreparationBadge,
                        {
                          backgroundColor: '#25D366',
                          borderColor: '#25D366',
                        },
                      ]}
                    >
                      <Icon source="whatsapp" size={12} color="#FFFFFF" />
                    </View>
                  )}
                  {order.preparationScreenStatuses &&
                    order.preparationScreenStatuses.length > 0 && (
                      <>
                        {order.preparationScreenStatuses.map(
                          (screen, index) => {
                            const backgroundColor =
                              screen.status === 'READY'
                                ? '#4CAF50'
                                : screen.status === 'IN_PROGRESS'
                                  ? '#FFA000'
                                  : isSelected
                                    ? theme.colors.primaryContainer
                                    : theme.colors.surfaceVariant;
                            const textColor =
                              screen.status === 'READY' ||
                              screen.status === 'IN_PROGRESS'
                                ? '#FFFFFF'
                                : isSelected
                                  ? theme.colors.onPrimaryContainer
                                  : theme.colors.onSurfaceVariant;
                            return (
                              <View
                                key={`${order.id}-screen-${index}`}
                                style={[
                                  styles.inlinePreparationBadge,
                                  {
                                    backgroundColor,
                                    borderColor:
                                      backgroundColor ===
                                      theme.colors.surfaceVariant
                                        ? theme.colors.outline
                                        : backgroundColor,
                                  },
                                ]}
                              >
                                <Text
                                  style={[
                                    styles.inlinePreparationText,
                                    { color: textColor },
                                  ]}
                                >
                                  {screen.status === 'READY'
                                    ? '✓ '
                                    : screen.status === 'IN_PROGRESS'
                                      ? '⏳ '
                                      : ''}
                                  🍳 {screen.name}
                                </Text>
                              </View>
                            );
                          },
                        )}
                      </>
                    )}
                </View>
              </View>
              <View style={styles.rightContainer}>
                {order.createdBy && (
                  <Text
                    style={[
                      styles.createdByText,
                      {
                        color: isSelected
                          ? theme.colors.onPrimaryContainer
                          : theme.colors.onSurfaceVariant,
                      },
                    ]}
                    numberOfLines={1}
                  >
                    {order.createdBy.firstName && order.createdBy.lastName
                      ? `${order.createdBy.firstName} ${order.createdBy.lastName}`
                      : order.createdBy.username}
                  </Text>
                )}
                <Chip
                  mode="flat"
                  compact
                  style={[
                    styles.statusChip,
                    {
                      backgroundColor: getStatusColor(order.orderStatus, theme),
                    },
                  ]}
                  textStyle={styles.statusChipText}
                >
                  {formatOrderStatus(order.orderStatus)}
                </Chip>
                <View style={styles.actionsContainer}>
                  {onPrintPress && (
                    <TouchableOpacity
                      style={styles.printContainer}
                      onPress={() => onPrintPress(order)}
                      activeOpacity={0.7}
                    >
                      <IconButton
                        icon="printer"
                        size={32}
                        style={styles.printButton}
                        disabled
                      />
                      {(order.ticketImpressionCount ?? 0) > 0 && (
                        <View style={styles.printCountBadge}>
                          <Text style={styles.printCountText}>
                            {order.ticketImpressionCount}
                          </Text>
                        </View>
                      )}
                    </TouchableOpacity>
                  )}
                  <View style={styles.checkboxContainer}>
                    <Checkbox
                      status={isSelected ? 'checked' : 'unchecked'}
                      onPress={() => {
                        onToggleSelection(order.id);
                      }}
                      color={theme.colors.primary}
                      style={styles.checkbox}
                    />
                  </View>
                </View>
              </View>
            </View>
          </Card.Content>
        </Card>
      </TouchableOpacity>
    );
  },
);
OrderCard.displayName = 'OrderCard';
const createStyles = (responsive: ReturnType<typeof useResponsive>) =>
  StyleSheet.create({
    orderCard: {
      marginBottom: responsive.isTablet ? 6 : 8,
    },
    cardContent: {
      paddingBottom: responsive.isTablet ? 6 : 8,
      paddingTop: responsive.isTablet ? 8 : 12,
      paddingHorizontal: responsive.isTablet ? 12 : 16,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 8,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: responsive.isTablet ? 120 : 140,
      gap: responsive.isTablet ? 4 : 8,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: 4,
    },
    orderNumber: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: 'bold',
      lineHeight: responsive.isTablet ? 18 : 22,
      marginBottom: responsive.isTablet ? 2 : 4,
    },
    orderPrice: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '700',
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 12 : 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    orderTime: {
      fontSize: responsive.isTablet ? 13 : 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: 14,
      marginLeft: 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: 11,
      fontWeight: '600',
      lineHeight: 14,
    },
    checkboxContainer: {
      padding: 8,
      marginLeft: -8,
      marginRight: -12,
    },
    checkbox: {
      margin: 0,
      transform: [{ scale: 1.5 }],
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
      marginLeft: 4,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 4,
    },
    miniPreparationText: {
      fontSize: 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: 10,
      marginLeft: 4,
    },
    createdByText: {
      fontSize: 10,
      marginBottom: 4,
      textAlign: 'right',
    },
    rightTopRow: {
      width: '100%',
    },
    printButton: {
      margin: -4,
    },
    printContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: '#3B82F6',
      borderRadius: 10,
      minWidth: 20,
      height: 20,
      paddingHorizontal: 4,
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountText: {
      color: '#FFFFFF',
      fontSize: 10,
      fontWeight: 'bold',
    },
  });

================
File: .claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(npm install)",
      "Bash(npm run:*)",
      "Bash(npm run build:*)",
      "Bash(npm install:*)",
      "Bash(npx env-cmd ts-node:*)",
      "Bash(node:*)",
      "Bash(npx typeorm migration:run:*)",
      "Bash(npx ts-node:*)",
      "Bash(cat:*)",
      "Bash(sed:*)",
      "Bash(rm:*)",
      "Bash(del fileService.ts)",
      "Bash(ls:*)",
      "Bash(npx expo install:*)",
      "Bash(npx expo prebuild:*)",
      "Bash(npx sharp-cli:*)",
      "Bash(npx eas build:*)",
      "Bash(cp:*)",
      "Bash(mkdir:*)",
      "Bash(python:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(mv:*)",
      "Bash(npm start)",
      "Bash(npx expo start:*)",
      "Bash(grep:*)",
      "Bash(del /Q srcdatabasemigrations*.*)",
      "Bash(cmd.exe:*)",
      "Bash(npx typeorm-ts-node-commonjs schema:sync:*)",
      "Bash(cmd //c:*)",
      "Bash(db-reset-windows.bat)",
      "Bash(start db-reset-windows.bat)",
      "Bash(generate-migration.bat)",
      "Bash(del /Q srcdatabasemigrations*.ts)",
      "Bash(cmd:*)",
      "Bash(del generate-migration.bat)",
      "Bash(npm config set script-shell \"cmd.exe\")",
      "Bash(powershell:*)",
      "Bash(npm config:*)",
      "Bash(npx typeorm:*)",
      "Bash(dir:*)",
      "Bash(find:*)",
      "Bash(npx tsc:*)",
      "Bash(npm info:*)",
      "Bash(curl:*)",
      "Bash(npx eslint:*)",
      "Bash(timeout 30 npm run start:dev)",
      "Bash(taskkill:*)",
      "Bash(del \"C:\\Users\\Leonel\\Desktop\\bite\\app\\src\\modules\\orders\\screens\\OpenOrdersScreenCompact.tsx\")",
      "Bash(del srcutilslogging.ts)",
      "Bash(del RegisterScreen.tsx)",
      "Bash(del:*)",
      "Bash(npm uninstall:*)",
      "Bash(npm ls:*)",
      "Bash(npm uninstall:*)",
      "Bash(for f in assets/*.png)",
      "Bash(do echo \"$f:\")",
      "Bash(file:*)",
      "Bash(done)",
      "Bash(npm test)",
      "Bash(git checkout:*)",
      "Bash(git log:*)",
      "Bash(npx expo config:*)",
      "Bash(set PLATFORM=web)",
      "Bash(npx create-expo-webpack-config:*)",
      "Bash(npx expo export:*)",
      "Bash(npx kill-port:*)",
      "Bash(docker compose:*)",
      "Bash(timeout:*)",
      "Bash(pkill:*)"
    ],
    "deny": []
  }
}

================
File: app/src/app/services/discoveryService.ts
================
import NetInfo from '@react-native-community/netinfo';
import EncryptedStorage from '@/app/services/secureStorageService';
import { NETWORK_CONFIG } from '../constants/network';
import { API_PATHS } from '../constants/apiPaths';
import { Platform } from 'react-native';
const DISCOVERY_ENDPOINT = API_PATHS.DISCOVERY.substring(1);
const STORAGE_KEY = 'last_known_api_url';
interface DiscoveryResponse {
  type: string;
  name: string;
  version: string;
  port: number;
  features: string[];
  timestamp: number;
  remoteUrl?: string;
  tunnelEnabled?: boolean;
}
export class DiscoveryService {
  private static instance: DiscoveryService;
  private cachedUrl: string | null = null;
  private discovering = false;
  private discoveryPromise: Promise<string | null> | null = null;
  private lastDiscoveryTime = 0;
  private logCallback: ((message: string) => void) | null = null;
  private manualUrl: string | null = null;
  private progressCallback:
    | ((progress: { current: number; total: number; message: string }) => void)
    | null = null;
  private constructor() {}
  setLogCallback(callback: ((message: string) => void) | null) {
    this.logCallback = callback;
  }
  setProgressCallback(
    callback:
      | ((progress: {
          current: number;
          total: number;
          message: string;
        }) => void)
      | null,
  ) {
    this.progressCallback = callback;
  }
  private log(message: string) {
    if (this.logCallback) {
      this.logCallback(message);
    }
  }
  private updateProgress(current: number, total: number, message: string) {
    if (this.progressCallback) {
      this.progressCallback({ current, total, message });
    }
  }
  static getInstance(): DiscoveryService {
    if (!DiscoveryService.instance) {
      DiscoveryService.instance = new DiscoveryService();
    }
    return DiscoveryService.instance;
  }
  async getApiUrl(): Promise<string | null> {
    if (this.manualUrl) {
      return this.manualUrl;
    }
    if (Platform.OS === 'web') {
      try {
        const savedUrl = await EncryptedStorage.getItem('manual_server_url');
        if (savedUrl) {
          this.manualUrl = savedUrl;
          return savedUrl;
        }
      } catch {}
      return null;
    }
    if (this.cachedUrl) {
      return this.cachedUrl;
    }
    try {
      const lastKnown = await EncryptedStorage.getItem(STORAGE_KEY);
      if (lastKnown) {
        this.cachedUrl = lastKnown;
        return lastKnown;
      }
    } catch {}
    return null;
  }
  async forceRediscovery(): Promise<string> {
    if (this.discoveryPromise && this.discovering) {
      const result = await this.discoveryPromise;
      if (result) return result;
    }
    await this.clearCache();
    const timeSinceLastDiscovery = Date.now() - this.lastDiscoveryTime;
    if (timeSinceLastDiscovery < NETWORK_CONFIG.MIN_DISCOVERY_INTERVAL) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }
    const discoveredUrl = await this.discoverBackend();
    if (!discoveredUrl) {
      throw new Error(
        'No se pudo encontrar el servidor CloudBite en la red local',
      );
    }
    return discoveredUrl;
  }
  async clearCache(): Promise<void> {
    this.cachedUrl = null;
    try {
      await EncryptedStorage.removeItem(STORAGE_KEY);
    } catch {}
  }
  async getLastKnownUrl(): Promise<string | null> {
    if (this.cachedUrl) {
      return this.cachedUrl;
    }
    try {
      const lastKnown = await EncryptedStorage.getItem(STORAGE_KEY);
      return lastKnown;
    } catch {
      return null;
    }
  }
  private async checkServer(url: string): Promise<boolean> {
    const controller = new AbortController();
    const timeoutId = setTimeout(
      () => controller.abort(),
      NETWORK_CONFIG.DISCOVERY_TIMEOUT,
    );
    try {
      const response = await fetch(`${url}${DISCOVERY_ENDPOINT}`, {
        method: 'GET',
        signal: controller.signal,
        headers: {
          Accept: 'application/json',
        },
      });
      if (!response.ok) return false;
      const data: DiscoveryResponse = await response.json();
      return data.type === 'cloudbite-api';
    } catch (error) {
      return false;
    } finally {
      clearTimeout(timeoutId);
    }
  }
  private async discoverBackend(): Promise<string | null> {
    if (this.discoveryPromise && this.discovering) {
      return this.discoveryPromise;
    }
    this.lastDiscoveryTime = Date.now();
    this.discovering = true;
    this.discoveryPromise = this.performDiscovery()
      .then(async (result) => {
        if (result) {
          await this.setServerUrl(result, false);
        }
        return result;
      })
      .finally(() => {
        this.discoveryPromise = null;
        this.discovering = false;
      });
    return this.discoveryPromise;
  }
  private async performDiscovery(): Promise<string | null> {
    try {
      if (Platform.OS === 'web') {
        this.log('❌ El descubrimiento automático no está disponible en web');
        return null;
      }
      const netInfo = await NetInfo.fetch();
      if (!netInfo.isConnected) {
        throw new Error('No hay conexión de red disponible');
      }
      this.log(
        `🔧 Buscando servidor en puerto ${NETWORK_CONFIG.DISCOVERY_PORT}`,
      );
      const subnets = this.detectCurrentSubnet();
      this.log(`📡 Iniciando búsqueda en redes: ${subnets.join(', ')}`);
      let totalIps = 0;
      for (const subnet of subnets) {
        totalIps += 254;
      }
      this.updateProgress(0, totalIps, 'Iniciando búsqueda...');
      let globalIpsScanned = 0;
      for (const subnet of subnets) {
        this.log(`🔍 Escaneando red ${subnet}.*`);
        this.updateProgress(
          globalIpsScanned,
          totalIps,
          `Escaneando red ${subnet}.*`,
        );
        const ips = this.generateIpRange(subnet);
        const chunks = this.chunkArray(
          ips,
          NETWORK_CONFIG.MAX_CONCURRENT_REQUESTS,
        );
        let totalIpsScanned = 0;
        for (let i = 0; i < chunks.length; i++) {
          const currentIps = chunks[i];
          const results = await Promise.allSettled(
            currentIps.map((ip) => this.probeServer(ip)),
          );
          totalIpsScanned += currentIps.length;
          globalIpsScanned += currentIps.length;
          this.updateProgress(
            globalIpsScanned,
            totalIps,
            `Escaneando ${subnet}.* (${Math.round((globalIpsScanned / totalIps) * 100)}%)`,
          );
          for (let j = 0; j < results.length; j++) {
            const result = results[j];
            if (result.status === 'fulfilled' && result.value) {
              const foundIp = currentIps[j];
              this.log(`✅ ¡SERVIDOR ENCONTRADO EN ${foundIp}!`);
              this.updateProgress(
                globalIpsScanned,
                totalIps,
                `¡Servidor encontrado en ${foundIp}!`,
              );
              return result.value;
            }
          }
          if (totalIpsScanned % 10 === 0) {
            const lastIp = currentIps[currentIps.length - 1];
            this.log(
              `  ▶ Escaneadas ${totalIpsScanned} IPs (última: ${lastIp})`,
            );
          }
        }
        this.log(`  ❌ No encontrado en ${subnet}.*`);
      }
      return null;
    } catch (error) {
      this.log(
        `❌ Error durante el descubrimiento: ${error instanceof Error ? error.message : 'Error desconocido'}`,
      );
      return null;
    }
  }
  private async probeServer(ip: string): Promise<string | null> {
    const url = `http://${ip}:${NETWORK_CONFIG.DISCOVERY_PORT}`;
    const fullUrl = `http://${ip}:${NETWORK_CONFIG.DISCOVERY_PORT}${API_PATHS.DISCOVERY}`;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
    }, NETWORK_CONFIG.DISCOVERY_TIMEOUT);
    try {
      const response = await fetch(fullUrl, {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      if (response.ok) {
        const text = await response.text();
        try {
          const data = JSON.parse(text);
          if (data.type === 'cloudbite-api') {
            this.log(`✅ ¡SERVIDOR ENCONTRADO!`);
            this.log(`📍 IP: ${ip}`);
            this.log(`🔗 URL: ${url}`);
            return url;
          }
        } catch {
        }
      }
    } catch {
    } finally {
      clearTimeout(timeoutId);
    }
    return null;
  }
  private detectCurrentSubnet(): string[] {
    return NETWORK_CONFIG.COMMON_SUBNETS;
  }
  private generateIpRange(subnet: string): string[] {
    const ips: string[] = [];
    for (let i = 1; i <= 254; i++) {
      ips.push(`${subnet}.${i}`);
    }
    return ips;
  }
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
  private async saveUrl(url: string): Promise<void> {
    try {
      await EncryptedStorage.setItem(STORAGE_KEY, url);
    } catch {}
  }
  async setServerUrl(
    url: string | null,
    isManual: boolean = false,
  ): Promise<void> {
    if (url) {
      this.cachedUrl = url;
      if (isManual) {
        this.manualUrl = url;
      }
      await this.saveUrl(url);
    } else if (isManual) {
      this.manualUrl = null;
    }
  }
  async discoverServer(): Promise<string | null> {
    return this.discoverBackend();
  }
  async getServerInfo(): Promise<DiscoveryResponse | null> {
    const url = await this.getApiUrl();
    if (!url) return null;
    try {
      const response = await fetch(`${url}${DISCOVERY_ENDPOINT}`, {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
      });
      if (response.ok) {
        const data: DiscoveryResponse = await response.json();
        return data;
      }
    } catch (error) {
      console.error('Error getting server info:', error);
    }
    return null;
  }
}
export const discoveryService = DiscoveryService.getInstance();

================
File: app/src/modules/orders/screens/OpenOrdersScreen.tsx
================
import React, { useCallback, useEffect, useState } from 'react';
import {
  StyleSheet,
  View,
  Pressable,
  TouchableOpacity,
  Animated,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { FlashList } from '@shopify/flash-list';
import {
  Text,
  ActivityIndicator,
  Appbar,
  IconButton,
  Portal,
  Card,
  Chip,
  Icon,
  Surface,
  Button,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { OrdersStackParamList } from '../../../app/navigation/types';
import { useAuthStore } from '../../../app/store/authStore';
import { canOpenShift } from '../../../app/utils/roleUtils';
import { useGlobalShift } from '../../../app/hooks/useGlobalShift';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';
import {
  useGetOpenOrdersListQuery,
  useUpdateOrderMutation,
  useCancelOrderMutation,
} from '../hooks/useOrdersQueries';
import {
  OrderOpenList,
  OrderType,
  OrderTypeEnum,
  OrderStatusEnum,
} from '../types/orders.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { PrintTicketModal } from '@/modules/shared/components/PrintTicketModal';
import { orderPrintService } from '../services/orderPrintService';
import OrderCartDetail from '../components/OrderCartDetail';
import { useListState } from '../../../app/hooks/useListState';
import { CartItem } from '../stores/useCartStore';
import {
  formatOrderStatus,
  formatOrderType,
  formatOrderTypeShort,
  getPaymentStatus,
  getStatusColor,
} from '../../../app/utils/orderFormatters';
type OpenOrdersScreenProps = NativeStackScreenProps<
  OrdersStackParamList,
  'OpenOrders'
>;
const OpenOrdersScreen: React.FC<OpenOrdersScreenProps> = ({ navigation }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [isPrintModalVisible, setIsPrintModalVisible] = useState(false);
  const [orderToPrint, setOrderToPrint] = useState<OrderOpenList | null>(null);
  const [acceptingOrderId, setAcceptingOrderId] = useState<string | null>(null);
  const user = useAuthStore((state) => state.user);
  const { data: shift, isLoading: shiftLoading } = useGlobalShift();
  const userCanOpenShift = canOpenShift(user);
  const [isEditModalVisible, setIsEditModalVisible] = useState(false);
  const [editingOrderId, setEditingOrderId] = useState<string | null>(null);
  const [pendingProductsToAdd, setPendingProductsToAdd] = useState<CartItem[]>(
    [],
  );
  const [temporaryProducts, setTemporaryProducts] = useState<{
    [orderId: string]: CartItem[];
  }>({});
  const [existingItemsCount, setExistingItemsCount] = useState<{
    [orderId: string]: number;
  }>({});
  const [selectedOrderType, setSelectedOrderType] = useState<
    OrderType | 'ALL' | 'WHATSAPP'
  >('ALL');
  const updateOrderMutation = useUpdateOrderMutation();
  const cancelOrderMutation = useCancelOrderMutation();
  const {
    data: ordersData,
    isLoading,
    isError,
    refetch,
    isFetching,
  } = useGetOpenOrdersListQuery();
  const filteredOrders = React.useMemo(() => {
    if (!ordersData) return [];
    if (selectedOrderType === 'ALL') {
      return ordersData.filter(
        (order) =>
          !(
            order.isFromWhatsApp &&
            order.orderStatus === OrderStatusEnum.PENDING
          ),
      );
    }
    if (selectedOrderType === 'WHATSAPP') {
      return ordersData.filter(
        (order) =>
          order.isFromWhatsApp && order.orderStatus === OrderStatusEnum.PENDING,
      );
    }
    return ordersData.filter(
      (order) =>
        order.orderType === selectedOrderType &&
        !(
          order.isFromWhatsApp && order.orderStatus === OrderStatusEnum.PENDING
        ),
    );
  }, [ordersData, selectedOrderType]);
  const handleRefresh = useCallback(() => {
    refetch();
  }, [refetch]);
  const handleOpenPrintModal = useCallback((order: OrderOpenList) => {
    setOrderToPrint(order);
    setIsPrintModalVisible(true);
  }, []);
  const handleOrderItemPress = (order: OrderOpenList) => {
    setEditingOrderId(order.id);
    setIsEditModalVisible(true);
  };
  const renderOrderItem = useCallback(
    ({ item: order }: { item: OrderOpenList }) => {
      let orderTitle = `#${order.shiftOrderNumber} • ${formatOrderTypeShort(order.orderType)}`;
      if (order.orderType === OrderTypeEnum.DINE_IN && order.table) {
        const tableDisplay = order.table.isTemporary
          ? order.table.name
          : `Mesa ${order.table.name || order.table.number || 'N/A'}`;
        orderTitle += ` • ${order.table.area?.name || 'Sin área'} • ${tableDisplay}`;
      } else if (order.orderType === OrderTypeEnum.TAKE_AWAY) {
        if (order.deliveryInfo?.recipientName) {
          orderTitle += ` • ${order.deliveryInfo.recipientName}`;
        }
        if (order.deliveryInfo?.recipientPhone) {
          orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;
        }
      } else if (order.orderType === OrderTypeEnum.DELIVERY) {
        if (order.deliveryInfo?.fullAddress) {
          orderTitle += ` • ${order.deliveryInfo.fullAddress}`;
        }
        if (order.deliveryInfo?.recipientPhone) {
          orderTitle += ` • ${order.deliveryInfo.recipientPhone}`;
        }
      }
      const totalAmount =
        typeof order.total === 'string' ? parseFloat(order.total) : order.total;
      const totalPaid = order.paymentsSummary?.totalPaid || 0;
      const pendingAmount = totalAmount - totalPaid;
      return (
        <TouchableOpacity
          activeOpacity={0.95}
          onPress={() => handleOrderItemPress(order)}
        >
          <Card
            style={[
              styles.orderCard,
              {
                backgroundColor: theme.colors.surface,
              },
            ]}
            mode="elevated"
          >
            <Card.Content style={styles.cardContent}>
              <View style={styles.mainContainer}>
                <View style={styles.leftContainer}>
                  <Text
                    style={[
                      styles.orderNumber,
                      { color: theme.colors.onSurface },
                    ]}
                  >
                    {orderTitle}
                    <Text
                      style={[
                        styles.orderPrice,
                        {
                          color:
                            pendingAmount > 0 ? theme.colors.error : '#10B981',
                        },
                      ]}
                    >
                      {' • '}
                      {pendingAmount > 0
                        ? `Por pagar: $${pendingAmount.toFixed(2)}`
                        : `Pagado: $${totalAmount.toFixed(2)}`}
                    </Text>
                    {order.notes && (
                      <Text
                        style={[
                          styles.notesInline,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                        numberOfLines={1}
                      >
                        {' • '}
                        {order.notes}
                      </Text>
                    )}
                  </Text>
                  <View style={styles.timeAndPaymentRow}>
                    <Text
                      style={[
                        styles.orderTime,
                        { color: theme.colors.primary },
                      ]}
                    >
                      {format(new Date(order.createdAt), 'p', { locale: es })}
                    </Text>
                    {(() => {
                      const paymentStatus = getPaymentStatus(order);
                      const color =
                        paymentStatus === 'paid'
                          ? '#10B981'
                          : paymentStatus === 'partial'
                            ? '#F59E0B'
                            : '#EF4444';
                      const icon =
                        paymentStatus === 'paid'
                          ? '✓'
                          : paymentStatus === 'partial'
                            ? '½'
                            : '•';
                      return (
                        <View
                          style={[
                            styles.miniPaymentBadge,
                            { backgroundColor: color },
                          ]}
                        >
                          <Text style={styles.miniPaymentText}>{icon}</Text>
                        </View>
                      );
                    })()}
                    {}
                    {order.isFromWhatsApp && (
                      <View
                        style={[
                          styles.inlinePreparationBadge,
                          {
                            backgroundColor: '#25D366',
                            borderColor: '#25D366',
                          },
                        ]}
                      >
                        <Icon source="whatsapp" size={12} color="#FFFFFF" />
                      </View>
                    )}
                    {order.preparationScreenStatuses &&
                      order.preparationScreenStatuses.length > 0 && (
                        <>
                          {order.preparationScreenStatuses.map(
                            (screen, index) => {
                              const backgroundColor =
                                screen.status === 'READY'
                                  ? '#4CAF50'
                                  : screen.status === 'IN_PROGRESS'
                                    ? '#FFA000'
                                    : theme.colors.surfaceVariant;
                              const textColor =
                                screen.status === 'READY' ||
                                screen.status === 'IN_PROGRESS'
                                  ? '#FFFFFF'
                                  : theme.colors.onSurfaceVariant;
                              return (
                                <View
                                  key={`${order.id}-screen-${index}`}
                                  style={[
                                    styles.inlinePreparationBadge,
                                    {
                                      backgroundColor,
                                      borderColor:
                                        backgroundColor ===
                                        theme.colors.surfaceVariant
                                          ? theme.colors.outline
                                          : backgroundColor,
                                    },
                                  ]}
                                >
                                  <Text
                                    style={[
                                      styles.inlinePreparationText,
                                      { color: textColor },
                                    ]}
                                  >
                                    {screen.status === 'READY'
                                      ? '✓ '
                                      : screen.status === 'IN_PROGRESS'
                                        ? '⏳ '
                                        : ''}
                                    🍳 {screen.name}
                                  </Text>
                                </View>
                              );
                            },
                          )}
                        </>
                      )}
                  </View>
                </View>
                <View style={styles.rightContainer}>
                  {order.createdBy && (
                    <Text style={styles.createdByText} numberOfLines={1}>
                      {order.createdBy.firstName && order.createdBy.lastName
                        ? `${order.createdBy.firstName} ${order.createdBy.lastName}`
                        : order.createdBy.username}
                    </Text>
                  )}
                  <Chip
                    mode="flat"
                    compact
                    style={[
                      styles.statusChip,
                      {
                        backgroundColor: getStatusColor(
                          order.orderStatus,
                          theme,
                        ),
                      },
                    ]}
                    textStyle={styles.statusChipText}
                  >
                    {formatOrderStatus(order.orderStatus)}
                  </Chip>
                  <View style={styles.actionsContainer}>
                    {selectedOrderType === 'WHATSAPP' &&
                    order.orderStatus === OrderStatusEnum.PENDING ? (
                      <Button
                        mode="contained"
                        icon="check"
                        onPress={() => handleAcceptWhatsAppOrder(order.id)}
                        disabled={acceptingOrderId === order.id}
                        loading={acceptingOrderId === order.id}
                        compact
                      >
                        Aceptar
                      </Button>
                    ) : (
                      <TouchableOpacity
                        style={styles.printContainer}
                        onPress={() => handleOpenPrintModal(order)}
                        activeOpacity={0.7}
                      >
                        <IconButton
                          icon="printer"
                          size={32}
                          style={styles.printButton}
                          disabled
                        />
                        {(order.ticketImpressionCount ?? 0) > 0 && (
                          <View style={styles.printCountBadge}>
                            <Text style={styles.printCountText}>
                              {order.ticketImpressionCount}
                            </Text>
                          </View>
                        )}
                      </TouchableOpacity>
                    )}
                  </View>
                </View>
              </View>
            </Card.Content>
          </Card>
        </TouchableOpacity>
      );
    },
    [
      handleOrderItemPress,
      handleOpenPrintModal,
      handleAcceptWhatsAppOrder,
      selectedOrderType,
      acceptingOrderId,
      theme,
      styles,
    ],
  );
  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: filteredOrders,
    emptyConfig: {
      title:
        selectedOrderType === 'ALL'
          ? 'No hay órdenes abiertas'
          : selectedOrderType === 'WHATSAPP'
            ? 'No hay pedidos de WhatsApp pendientes'
            : `No hay órdenes de tipo ${formatOrderType(
                selectedOrderType as OrderType,
              )
                .replace(/[\u{1F37D}]|[\u{FE0F}]|[\u{1F961}]|[\u{1F69A}]/gu, '')
                .trim()}`,
      message:
        selectedOrderType === 'ALL'
          ? 'No hay órdenes abiertas en este momento.'
          : selectedOrderType === 'WHATSAPP'
            ? 'No hay pedidos de WhatsApp esperando aceptación.'
            : `No hay órdenes de este tipo en este momento.`,
      icon:
        selectedOrderType === 'WHATSAPP'
          ? 'whatsapp'
          : 'clipboard-text-outline',
    },
    errorConfig: {
      title: 'Error al cargar órdenes',
      message: 'No se pudieron cargar las órdenes. Verifica tu conexión.',
      icon: 'wifi-off',
      actionLabel: 'Reintentar',
      onAction: () => refetch(),
    },
  });
  useEffect(() => {
    navigation.setOptions({
      headerRight: () => (
        <Appbar.Action
          icon="refresh"
          iconColor={theme.colors.onPrimary}
          size={28}
          onPress={handleRefresh}
          disabled={isFetching}
          style={styles.headerRefreshButton}
        />
      ),
    });
  }, [navigation, handleRefresh, isFetching, theme.colors.onPrimary]);
  useEffect(() => {
    if (
      isEditModalVisible &&
      editingOrderId &&
      temporaryProducts[editingOrderId]
    ) {
      setPendingProductsToAdd(temporaryProducts[editingOrderId]);
    }
  }, [isEditModalVisible, editingOrderId, temporaryProducts]);
  const handlePrint = useCallback(
    async (printerId: string, ticketType: 'GENERAL' | 'BILLING') => {
      if (!orderToPrint) return;
      try {
        await orderPrintService.printTicket(orderToPrint.id, {
          printerId,
          ticketType,
        });
        showSnackbar({
          message: 'Ticket impreso exitosamente',
          type: 'success',
        });
        refetch();
        setOrderToPrint(null);
      } catch (error) {
        showSnackbar({
          message: 'Error al imprimir el ticket',
          type: 'error',
        });
      }
    },
    [orderToPrint, refetch, showSnackbar],
  );
  const handleAcceptWhatsAppOrder = useCallback(
    async (orderId: string) => {
      if (acceptingOrderId !== null) return;
      setAcceptingOrderId(orderId);
      try {
        await updateOrderMutation.mutateAsync({
          orderId,
          payload: {
            orderStatus: OrderStatusEnum.IN_PROGRESS,
          },
        });
        showSnackbar({
          message: 'Pedido aceptado exitosamente',
          type: 'success',
        });
        refetch();
      } catch (error) {
        showSnackbar({
          message: 'Error al aceptar el pedido',
          type: 'error',
        });
      } finally {
        setAcceptingOrderId(null);
      }
    },
    [acceptingOrderId, updateOrderMutation, refetch, showSnackbar],
  );
  const handleCancelOrder = useCallback(
    async (orderId: string) => {
      try {
        await cancelOrderMutation.mutateAsync(orderId);
        setIsEditModalVisible(false);
        setEditingOrderId(null);
      } catch (error) {
      }
    },
    [cancelOrderMutation],
  );
  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      {!shiftLoading && (!shift || shift.status !== 'OPEN') ? (
        <View style={styles.container}>
          <View style={styles.emptyStateContainer}>
            <Icon
              source="store-alert"
              size={64}
              color={theme.colors.onSurfaceVariant}
            />
            <Text variant="headlineSmall" style={styles.emptyStateTitle}>
              Turno Cerrado
            </Text>
            <Text variant="bodyLarge" style={styles.emptyStateText}>
              {userCanOpenShift
                ? 'Para ver las órdenes abiertas, primero debes abrir el turno usando el indicador en la barra superior.'
                : 'El turno debe estar abierto para ver las órdenes. Contacta a un administrador.'}
            </Text>
          </View>
        </View>
      ) : isLoading && !ordersData ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>Cargando órdenes...</Text>
        </View>
      ) : (
        <>
          {}
          <Surface style={styles.header}>
            <View style={styles.headerContent}>
              <View style={styles.filterContainer}>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === 'ALL' && styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === 'ALL'
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType('ALL')}
                >
                  <Icon
                    source="view-grid"
                    size={26}
                    color={
                      selectedOrderType === 'ALL'
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === 'ALL'
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === 'ALL'
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === 'ALL'
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.DINE_IN &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.DINE_IN
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.DINE_IN)}
                >
                  <Icon
                    source="silverware-fork-knife"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.DINE_IN
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.DINE_IN &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.DINE_IN
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.DINE_IN
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.DINE_IN
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.DINE_IN &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.TAKE_AWAY &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.TAKE_AWAY
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.TAKE_AWAY)}
                >
                  <Icon
                    source="bag-personal"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.TAKE_AWAY
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.TAKE_AWAY &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.TAKE_AWAY &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.DELIVERY &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.DELIVERY
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.DELIVERY)}
                >
                  <Icon
                    source="moped"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.DELIVERY
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.DELIVERY &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.DELIVERY
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.DELIVERY
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.DELIVERY
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.DELIVERY &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === 'WHATSAPP' &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === 'WHATSAPP'
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType('WHATSAPP')}
                >
                  <Icon
                    source="whatsapp"
                    size={26}
                    color={
                      selectedOrderType === 'WHATSAPP'
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.isFromWhatsApp &&
                        o.orderStatus === OrderStatusEnum.PENDING,
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === 'WHATSAPP'
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === 'WHATSAPP'
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === 'WHATSAPP'
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.isFromWhatsApp &&
                                o.orderStatus === OrderStatusEnum.PENDING,
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
              </View>
            </View>
          </Surface>
          {}
          <View style={styles.listContainer}>
            <FlashList
              data={filteredOrders}
              keyExtractor={(item) => item.id}
              renderItem={renderOrderItem}
              refreshing={isFetching}
              onRefresh={handleRefresh}
              contentContainerStyle={styles.listContentContainer}
              ListEmptyComponent={ListEmptyComponent}
              estimatedItemSize={120}
              removeClippedSubviews={true}
            />
          </View>
        </>
      )}
      {}
      <Portal>
        <PrintTicketModal
          visible={isPrintModalVisible}
          onDismiss={() => {
            setIsPrintModalVisible(false);
            setOrderToPrint(null);
          }}
          order={orderToPrint}
          onPrint={handlePrint}
        />
        {}
        {editingOrderId && (
          <OrderCartDetail
            visible={isEditModalVisible}
            isEditMode={true}
            orderId={editingOrderId}
            orderNumber={
              ordersData?.find((o) => o.id === editingOrderId)?.shiftOrderNumber
            }
            orderDate={
              ordersData?.find((o) => o.id === editingOrderId)?.createdAt
                ? new Date(
                    ordersData.find((o) => o.id === editingOrderId)!.createdAt,
                  )
                : undefined
            }
            navigation={navigation}
            pendingProductsToAdd={
              editingOrderId && temporaryProducts[editingOrderId]
                ? temporaryProducts[editingOrderId]
                : pendingProductsToAdd
            }
            onItemsCountChanged={(count) => {
              setExistingItemsCount((prev) => ({
                ...prev,
                [editingOrderId]: count,
              }));
            }}
            onClose={() => {
              setIsEditModalVisible(false);
              setEditingOrderId(null);
              setPendingProductsToAdd([]);
            }}
            onAddProducts={() => {
              setIsEditModalVisible(false);
              const orderNumber = ordersData?.find(
                (o) => o.id === editingOrderId,
              )?.shiftOrderNumber;
              setTimeout(() => {
                const existingProducts =
                  temporaryProducts[editingOrderId!] || [];
                navigation.navigate(NAVIGATION_PATHS.ADD_PRODUCTS_TO_ORDER, {
                  orderId: editingOrderId!,
                  orderNumber: orderNumber!,
                  existingTempProducts: existingProducts,
                  existingOrderItemsCount:
                    existingItemsCount[editingOrderId!] || 0,
                  onProductsAdded: (newProducts) => {
                    setTemporaryProducts((prev) => ({
                      ...prev,
                      [editingOrderId!]: newProducts,
                    }));
                    setIsEditModalVisible(true);
                  },
                });
              }, 100);
            }}
            onConfirmOrder={async (details: OrderDetailsForBackend) => {
              const payload = {
                orderType: details.orderType,
                items: details.items,
                tableId: details.tableId || null,
                isTemporaryTable: details.isTemporaryTable || false,
                temporaryTableName: details.temporaryTableName || null,
                temporaryTableAreaId: details.temporaryTableAreaId || null,
                scheduledAt: details.scheduledAt || null,
                deliveryInfo: (() => {
                  if (!details.deliveryInfo) return null;
                  const filteredDeliveryInfo = Object.entries(
                    details.deliveryInfo,
                  )
                    .filter(([_, value]) => value !== undefined)
                    .reduce(
                      (acc, [key, value]) => ({ ...acc, [key]: value }),
                      {},
                    );
                  return Object.keys(filteredDeliveryInfo).length > 0
                    ? filteredDeliveryInfo
                    : null;
                })(),
                notes: details.notes || null,
                total: details.total,
                subtotal: details.subtotal,
                adjustments: details.adjustments || [],
              };
              try {
                await updateOrderMutation.mutateAsync({
                  orderId: editingOrderId,
                  payload,
                });
                setIsEditModalVisible(false);
                setEditingOrderId(null);
                if (editingOrderId) {
                  setTemporaryProducts((prev) => {
                    const newState = { ...prev };
                    delete newState[editingOrderId];
                    return newState;
                  });
                  setExistingItemsCount((prev) => {
                    const newState = { ...prev };
                    delete newState[editingOrderId];
                    return newState;
                  });
                }
              } catch (error) {
              }
            }}
            onCancelOrder={() => {
              if (editingOrderId) {
                handleCancelOrder(editingOrderId);
              }
            }}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
};
const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.isTablet ? theme.spacing.s : theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 16,
    },
    header: {
      paddingHorizontal: 0,
      paddingVertical: 0,
      backgroundColor: 'transparent',
      elevation: 0,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    filterContainer: {
      flex: 1,
      flexDirection: 'row',
      gap: 0,
    },
    filterButton: {
      flex: 1,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 0,
      elevation: 1,
      position: 'relative',
    },
    filterButtonActive: {
      elevation: 3,
    },
    countBadge: {
      position: 'absolute',
      top: responsive.isTablet ? 3 : 6,
      right: responsive.isTablet ? 3 : 6,
      minWidth: responsive.isTablet ? 18 : 22,
      height: responsive.isTablet ? 18 : 22,
      borderRadius: responsive.isTablet ? 9 : 11,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      borderWidth: 1,
      elevation: 2,
    },
    countBadgeText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '700',
    },
    listContainer: {
      flex: 1,
    },
    listContentContainer: {
      padding: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
      paddingBottom: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.l * 2,
    },
    orderCard: {
      marginBottom: responsive.isTablet ? 6 : 8,
    },
    cardContent: {
      paddingBottom: responsive.isTablet ? 6 : 8,
      paddingHorizontal: responsive.isTablet ? 12 : 16,
      paddingTop: responsive.isTablet ? 12 : 16,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: responsive.isTablet ? 6 : 8,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: responsive.isTablet ? 120 : 140,
      gap: responsive.isTablet ? 6 : 8,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: responsive.isTablet ? 2 : 4,
    },
    orderNumber: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: 'bold',
      lineHeight: responsive.isTablet ? 20 : 22,
      marginBottom: responsive.isTablet ? 2 : 4,
    },
    orderPrice: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '700',
    },
    statusChip: {
      minHeight: responsive.isTablet ? 22 : 24,
      alignSelf: 'flex-end',
      paddingVertical: responsive.isTablet ? 1 : 2,
    },
    statusChipText: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 13 : 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    paidChip: {
      height: responsive.isTablet ? 24 : 28,
      minHeight: responsive.isTablet ? 24 : 28,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    paidChipText: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 14 : 16,
    },
    orderTime: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: responsive.isTablet ? 12 : 14,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: responsive.isTablet ? 6 : 8,
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: responsive.isTablet ? 10 : 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: responsive.isTablet ? 10 : 11,
      fontWeight: '600',
      lineHeight: responsive.isTablet ? 12 : 14,
    },
    printButton: {
      margin: responsive.isTablet ? -6 : -4,
    },
    printContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: '#3B82F6',
      borderRadius: responsive.isTablet ? 8 : 10,
      minWidth: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      paddingHorizontal: responsive.isTablet ? 3 : 4,
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountText: {
      color: '#FFFFFF',
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: 'bold',
    },
    customerInfo: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.isTablet ? 13 : 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    phoneInfo: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    notesInline: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: responsive.isTablet ? 8 : 10,
      borderWidth: 0.5,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    inlinePreparationText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      borderRadius: responsive.isTablet ? 9 : 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: responsive.isTablet ? 4 : 6,
    },
    miniPaymentText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      borderRadius: responsive.isTablet ? 9 : 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    miniPreparationText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onSurfaceVariant,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    createdByText: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet ? 3 : 4,
      textAlign: 'right',
    },
    emptyStateContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.l,
    },
    emptyStateTitle: {
      marginTop: responsive.isTablet ? theme.spacing.m : theme.spacing.l,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.onSurface,
      fontWeight: '600',
      fontSize: responsive.isTablet ? 20 : 24,
    },
    emptyStateText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      maxWidth: responsive.isTablet ? 280 : 320,
      lineHeight: responsive.isTablet ? 20 : 24,
      fontSize: responsive.isTablet ? 14 : 16,
    },
    headerRefreshButton: {
      marginRight: 8,
    },
  });
export default OpenOrdersScreen;




================================================================
End of Codebase
================================================================
